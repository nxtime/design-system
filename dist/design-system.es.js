import va, { Fragment as cE, useRef as mr, useState as fr, useCallback as Du, useEffect as Hf, useDebugValue as F_ } from "react";
import tr from "moment";
function Y_(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var o1 = { exports: {} }, Jp = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var QT;
function H_() {
  if (QT)
    return Jp;
  QT = 1;
  var s = va, u = Symbol.for("react.element"), h = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, w = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, T = { key: !0, ref: !0, __self: !0, __source: !0 };
  function A(F, H, j) {
    var V, q = {}, te = null, ae = null;
    j !== void 0 && (te = "" + j), H.key !== void 0 && (te = "" + H.key), H.ref !== void 0 && (ae = H.ref);
    for (V in H)
      m.call(H, V) && !T.hasOwnProperty(V) && (q[V] = H[V]);
    if (F && F.defaultProps)
      for (V in H = F.defaultProps, H)
        q[V] === void 0 && (q[V] = H[V]);
    return { $$typeof: u, type: F, key: te, ref: ae, props: q, _owner: w.current };
  }
  return Jp.Fragment = h, Jp.jsx = A, Jp.jsxs = A, Jp;
}
var eg = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var KT;
function j_() {
  return KT || (KT = 1, process.env.NODE_ENV !== "production" && function() {
    var s = va, u = Symbol.for("react.element"), h = Symbol.for("react.portal"), m = Symbol.for("react.fragment"), w = Symbol.for("react.strict_mode"), T = Symbol.for("react.profiler"), A = Symbol.for("react.provider"), F = Symbol.for("react.context"), H = Symbol.for("react.forward_ref"), j = Symbol.for("react.suspense"), V = Symbol.for("react.suspense_list"), q = Symbol.for("react.memo"), te = Symbol.for("react.lazy"), ae = Symbol.for("react.offscreen"), se = Symbol.iterator, ue = "@@iterator";
    function Ce(le) {
      if (le === null || typeof le != "object")
        return null;
      var Ye = se && le[se] || le[ue];
      return typeof Ye == "function" ? Ye : null;
    }
    var Pe = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function K(le) {
      {
        for (var Ye = arguments.length, tt = new Array(Ye > 1 ? Ye - 1 : 0), Dt = 1; Dt < Ye; Dt++)
          tt[Dt - 1] = arguments[Dt];
        we("error", le, tt);
      }
    }
    function we(le, Ye, tt) {
      {
        var Dt = Pe.ReactDebugCurrentFrame, qt = Dt.getStackAddendum();
        qt !== "" && (Ye += "%s", tt = tt.concat([qt]));
        var cn = tt.map(function(Zt) {
          return String(Zt);
        });
        cn.unshift("Warning: " + Ye), Function.prototype.apply.call(console[le], console, cn);
      }
    }
    var Ee = !1, re = !1, me = !1, Me = !1, Je = !1, Ve;
    Ve = Symbol.for("react.module.reference");
    function Xe(le) {
      return !!(typeof le == "string" || typeof le == "function" || le === m || le === T || Je || le === w || le === j || le === V || Me || le === ae || Ee || re || me || typeof le == "object" && le !== null && (le.$$typeof === te || le.$$typeof === q || le.$$typeof === A || le.$$typeof === F || le.$$typeof === H || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      le.$$typeof === Ve || le.getModuleId !== void 0));
    }
    function it(le, Ye, tt) {
      var Dt = le.displayName;
      if (Dt)
        return Dt;
      var qt = Ye.displayName || Ye.name || "";
      return qt !== "" ? tt + "(" + qt + ")" : tt;
    }
    function ht(le) {
      return le.displayName || "Context";
    }
    function Ke(le) {
      if (le == null)
        return null;
      if (typeof le.tag == "number" && K("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof le == "function")
        return le.displayName || le.name || null;
      if (typeof le == "string")
        return le;
      switch (le) {
        case m:
          return "Fragment";
        case h:
          return "Portal";
        case T:
          return "Profiler";
        case w:
          return "StrictMode";
        case j:
          return "Suspense";
        case V:
          return "SuspenseList";
      }
      if (typeof le == "object")
        switch (le.$$typeof) {
          case F:
            var Ye = le;
            return ht(Ye) + ".Consumer";
          case A:
            var tt = le;
            return ht(tt._context) + ".Provider";
          case H:
            return it(le, le.render, "ForwardRef");
          case q:
            var Dt = le.displayName || null;
            return Dt !== null ? Dt : Ke(le.type) || "Memo";
          case te: {
            var qt = le, cn = qt._payload, Zt = qt._init;
            try {
              return Ke(Zt(cn));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Ze = Object.assign, Tt = 0, It, Jt, We, pt, ye, je, Qe;
    function kt() {
    }
    kt.__reactDisabledLog = !0;
    function mt() {
      {
        if (Tt === 0) {
          It = console.log, Jt = console.info, We = console.warn, pt = console.error, ye = console.group, je = console.groupCollapsed, Qe = console.groupEnd;
          var le = {
            configurable: !0,
            enumerable: !0,
            value: kt,
            writable: !0
          };
          Object.defineProperties(console, {
            info: le,
            log: le,
            warn: le,
            error: le,
            group: le,
            groupCollapsed: le,
            groupEnd: le
          });
        }
        Tt++;
      }
    }
    function Pt() {
      {
        if (Tt--, Tt === 0) {
          var le = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Ze({}, le, {
              value: It
            }),
            info: Ze({}, le, {
              value: Jt
            }),
            warn: Ze({}, le, {
              value: We
            }),
            error: Ze({}, le, {
              value: pt
            }),
            group: Ze({}, le, {
              value: ye
            }),
            groupCollapsed: Ze({}, le, {
              value: je
            }),
            groupEnd: Ze({}, le, {
              value: Qe
            })
          });
        }
        Tt < 0 && K("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var st = Pe.ReactCurrentDispatcher, Nt;
    function Et(le, Ye, tt) {
      {
        if (Nt === void 0)
          try {
            throw Error();
          } catch (qt) {
            var Dt = qt.stack.trim().match(/\n( *(at )?)/);
            Nt = Dt && Dt[1] || "";
          }
        return `
` + Nt + le;
      }
    }
    var Ht = !1, Wt;
    {
      var mn = typeof WeakMap == "function" ? WeakMap : Map;
      Wt = new mn();
    }
    function qe(le, Ye) {
      if (!le || Ht)
        return "";
      {
        var tt = Wt.get(le);
        if (tt !== void 0)
          return tt;
      }
      var Dt;
      Ht = !0;
      var qt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var cn;
      cn = st.current, st.current = null, mt();
      try {
        if (Ye) {
          var Zt = function() {
            throw Error();
          };
          if (Object.defineProperty(Zt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Zt, []);
            } catch (o) {
              Dt = o;
            }
            Reflect.construct(le, [], Zt);
          } else {
            try {
              Zt.call();
            } catch (o) {
              Dt = o;
            }
            le.call(Zt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (o) {
            Dt = o;
          }
          le();
        }
      } catch (o) {
        if (o && Dt && typeof o.stack == "string") {
          for (var Mt = o.stack.split(`
`), or = Dt.stack.split(`
`), Yn = Mt.length - 1, W = or.length - 1; Yn >= 1 && W >= 0 && Mt[Yn] !== or[W]; )
            W--;
          for (; Yn >= 1 && W >= 0; Yn--, W--)
            if (Mt[Yn] !== or[W]) {
              if (Yn !== 1 || W !== 1)
                do
                  if (Yn--, W--, W < 0 || Mt[Yn] !== or[W]) {
                    var t = `
` + Mt[Yn].replace(" at new ", " at ");
                    return le.displayName && t.includes("<anonymous>") && (t = t.replace("<anonymous>", le.displayName)), typeof le == "function" && Wt.set(le, t), t;
                  }
                while (Yn >= 1 && W >= 0);
              break;
            }
        }
      } finally {
        Ht = !1, st.current = cn, Pt(), Error.prepareStackTrace = qt;
      }
      var n = le ? le.displayName || le.name : "", a = n ? Et(n) : "";
      return typeof le == "function" && Wt.set(le, a), a;
    }
    function pn(le, Ye, tt) {
      return qe(le, !1);
    }
    function jn(le) {
      var Ye = le.prototype;
      return !!(Ye && Ye.isReactComponent);
    }
    function ir(le, Ye, tt) {
      if (le == null)
        return "";
      if (typeof le == "function")
        return qe(le, jn(le));
      if (typeof le == "string")
        return Et(le);
      switch (le) {
        case j:
          return Et("Suspense");
        case V:
          return Et("SuspenseList");
      }
      if (typeof le == "object")
        switch (le.$$typeof) {
          case H:
            return pn(le.render);
          case q:
            return ir(le.type, Ye, tt);
          case te: {
            var Dt = le, qt = Dt._payload, cn = Dt._init;
            try {
              return ir(cn(qt), Ye, tt);
            } catch {
            }
          }
        }
      return "";
    }
    var Dr = Object.prototype.hasOwnProperty, Mr = {}, ta = Pe.ReactDebugCurrentFrame;
    function Za(le) {
      if (le) {
        var Ye = le._owner, tt = ir(le.type, le._source, Ye ? Ye.type : null);
        ta.setExtraStackFrame(tt);
      } else
        ta.setExtraStackFrame(null);
    }
    function _i(le, Ye, tt, Dt, qt) {
      {
        var cn = Function.call.bind(Dr);
        for (var Zt in le)
          if (cn(le, Zt)) {
            var Mt = void 0;
            try {
              if (typeof le[Zt] != "function") {
                var or = Error((Dt || "React class") + ": " + tt + " type `" + Zt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof le[Zt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw or.name = "Invariant Violation", or;
              }
              Mt = le[Zt](Ye, Zt, Dt, tt, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Yn) {
              Mt = Yn;
            }
            Mt && !(Mt instanceof Error) && (Za(qt), K("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Dt || "React class", tt, Zt, typeof Mt), Za(null)), Mt instanceof Error && !(Mt.message in Mr) && (Mr[Mt.message] = !0, Za(qt), K("Failed %s type: %s", tt, Mt.message), Za(null));
          }
      }
    }
    var di = Array.isArray;
    function Qa(le) {
      return di(le);
    }
    function ya(le) {
      {
        var Ye = typeof Symbol == "function" && Symbol.toStringTag, tt = Ye && le[Symbol.toStringTag] || le.constructor.name || "Object";
        return tt;
      }
    }
    function fi(le) {
      try {
        return xa(le), !1;
      } catch {
        return !0;
      }
    }
    function xa(le) {
      return "" + le;
    }
    function na(le) {
      if (fi(le))
        return K("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ya(le)), xa(le);
    }
    var sr = Pe.ReactCurrentOwner, ra = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Pi, Ka, et;
    et = {};
    function Lt(le) {
      if (Dr.call(le, "ref")) {
        var Ye = Object.getOwnPropertyDescriptor(le, "ref").get;
        if (Ye && Ye.isReactWarning)
          return !1;
      }
      return le.ref !== void 0;
    }
    function nn(le) {
      if (Dr.call(le, "key")) {
        var Ye = Object.getOwnPropertyDescriptor(le, "key").get;
        if (Ye && Ye.isReactWarning)
          return !1;
      }
      return le.key !== void 0;
    }
    function bn(le, Ye) {
      if (typeof le.ref == "string" && sr.current && Ye && sr.current.stateNode !== Ye) {
        var tt = Ke(sr.current.type);
        et[tt] || (K('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Ke(sr.current.type), le.ref), et[tt] = !0);
      }
    }
    function Bn(le, Ye) {
      {
        var tt = function() {
          Pi || (Pi = !0, K("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ye));
        };
        tt.isReactWarning = !0, Object.defineProperty(le, "key", {
          get: tt,
          configurable: !0
        });
      }
    }
    function vr(le, Ye) {
      {
        var tt = function() {
          Ka || (Ka = !0, K("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ye));
        };
        tt.isReactWarning = !0, Object.defineProperty(le, "ref", {
          get: tt,
          configurable: !0
        });
      }
    }
    var $n = function(le, Ye, tt, Dt, qt, cn, Zt) {
      var Mt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: u,
        // Built-in properties that belong on the element
        type: le,
        key: Ye,
        ref: tt,
        props: Zt,
        // Record the component responsible for creating this element.
        _owner: cn
      };
      return Mt._store = {}, Object.defineProperty(Mt._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Mt, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Dt
      }), Object.defineProperty(Mt, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: qt
      }), Object.freeze && (Object.freeze(Mt.props), Object.freeze(Mt)), Mt;
    };
    function aa(le, Ye, tt, Dt, qt) {
      {
        var cn, Zt = {}, Mt = null, or = null;
        tt !== void 0 && (na(tt), Mt = "" + tt), nn(Ye) && (na(Ye.key), Mt = "" + Ye.key), Lt(Ye) && (or = Ye.ref, bn(Ye, qt));
        for (cn in Ye)
          Dr.call(Ye, cn) && !ra.hasOwnProperty(cn) && (Zt[cn] = Ye[cn]);
        if (le && le.defaultProps) {
          var Yn = le.defaultProps;
          for (cn in Yn)
            Zt[cn] === void 0 && (Zt[cn] = Yn[cn]);
        }
        if (Mt || or) {
          var W = typeof le == "function" ? le.displayName || le.name || "Unknown" : le;
          Mt && Bn(Zt, W), or && vr(Zt, W);
        }
        return $n(le, Mt, or, qt, Dt, sr.current, Zt);
      }
    }
    var Ln = Pe.ReactCurrentOwner, yr = Pe.ReactDebugCurrentFrame;
    function kn(le) {
      if (le) {
        var Ye = le._owner, tt = ir(le.type, le._source, Ye ? Ye.type : null);
        yr.setExtraStackFrame(tt);
      } else
        yr.setExtraStackFrame(null);
    }
    var Cn;
    Cn = !1;
    function cs(le) {
      return typeof le == "object" && le !== null && le.$$typeof === u;
    }
    function ds() {
      {
        if (Ln.current) {
          var le = Ke(Ln.current.type);
          if (le)
            return `

Check the render method of \`` + le + "`.";
        }
        return "";
      }
    }
    function fs(le) {
      {
        if (le !== void 0) {
          var Ye = le.fileName.replace(/^.*[\\\/]/, ""), tt = le.lineNumber;
          return `

Check your code at ` + Ye + ":" + tt + ".";
        }
        return "";
      }
    }
    var Vs = {};
    function Ol(le) {
      {
        var Ye = ds();
        if (!Ye) {
          var tt = typeof le == "string" ? le : le.displayName || le.name;
          tt && (Ye = `

Check the top-level render call using <` + tt + ">.");
        }
        return Ye;
      }
    }
    function hs(le, Ye) {
      {
        if (!le._store || le._store.validated || le.key != null)
          return;
        le._store.validated = !0;
        var tt = Ol(Ye);
        if (Vs[tt])
          return;
        Vs[tt] = !0;
        var Dt = "";
        le && le._owner && le._owner !== Ln.current && (Dt = " It was passed a child from " + Ke(le._owner.type) + "."), kn(le), K('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', tt, Dt), kn(null);
      }
    }
    function Gs(le, Ye) {
      {
        if (typeof le != "object")
          return;
        if (Qa(le))
          for (var tt = 0; tt < le.length; tt++) {
            var Dt = le[tt];
            cs(Dt) && hs(Dt, Ye);
          }
        else if (cs(le))
          le._store && (le._store.validated = !0);
        else if (le) {
          var qt = Ce(le);
          if (typeof qt == "function" && qt !== le.entries)
            for (var cn = qt.call(le), Zt; !(Zt = cn.next()).done; )
              cs(Zt.value) && hs(Zt.value, Ye);
        }
      }
    }
    function ps(le) {
      {
        var Ye = le.type;
        if (Ye == null || typeof Ye == "string")
          return;
        var tt;
        if (typeof Ye == "function")
          tt = Ye.propTypes;
        else if (typeof Ye == "object" && (Ye.$$typeof === H || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Ye.$$typeof === q))
          tt = Ye.propTypes;
        else
          return;
        if (tt) {
          var Dt = Ke(Ye);
          _i(tt, le.props, "prop", Dt, le);
        } else if (Ye.PropTypes !== void 0 && !Cn) {
          Cn = !0;
          var qt = Ke(Ye);
          K("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", qt || "Unknown");
        }
        typeof Ye.getDefaultProps == "function" && !Ye.getDefaultProps.isReactClassApproved && K("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function $s(le) {
      {
        for (var Ye = Object.keys(le.props), tt = 0; tt < Ye.length; tt++) {
          var Dt = Ye[tt];
          if (Dt !== "children" && Dt !== "key") {
            kn(le), K("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Dt), kn(null);
            break;
          }
        }
        le.ref !== null && (kn(le), K("Invalid attribute `ref` supplied to `React.Fragment`."), kn(null));
      }
    }
    function Ma(le, Ye, tt, Dt, qt, cn) {
      {
        var Zt = Xe(le);
        if (!Zt) {
          var Mt = "";
          (le === void 0 || typeof le == "object" && le !== null && Object.keys(le).length === 0) && (Mt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var or = fs(qt);
          or ? Mt += or : Mt += ds();
          var Yn;
          le === null ? Yn = "null" : Qa(le) ? Yn = "array" : le !== void 0 && le.$$typeof === u ? (Yn = "<" + (Ke(le.type) || "Unknown") + " />", Mt = " Did you accidentally export a JSX literal instead of a component?") : Yn = typeof le, K("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Yn, Mt);
        }
        var W = aa(le, Ye, tt, qt, cn);
        if (W == null)
          return W;
        if (Zt) {
          var t = Ye.children;
          if (t !== void 0)
            if (Dt)
              if (Qa(t)) {
                for (var n = 0; n < t.length; n++)
                  Gs(t[n], le);
                Object.freeze && Object.freeze(t);
              } else
                K("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Gs(t, le);
        }
        return le === m ? $s(W) : ps(W), W;
      }
    }
    function Ni(le, Ye, tt) {
      return Ma(le, Ye, tt, !0);
    }
    function jr(le, Ye, tt) {
      return Ma(le, Ye, tt, !1);
    }
    var ba = jr, ia = Ni;
    eg.Fragment = m, eg.jsx = ba, eg.jsxs = ia;
  }()), eg;
}
process.env.NODE_ENV === "production" ? o1.exports = H_() : o1.exports = j_();
var ce = o1.exports;
const B_ = {
  type: "logger",
  log(s) {
    this.output("log", s);
  },
  warn(s) {
    this.output("warn", s);
  },
  error(s) {
    this.output("error", s);
  },
  output(s, u) {
    console && console[s] && console[s].apply(console, u);
  }
};
class _y {
  constructor(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(u, h);
  }
  init(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = h.prefix || "i18next:", this.logger = u || B_, this.options = h, this.debug = h.debug;
  }
  log() {
    for (var u = arguments.length, h = new Array(u), m = 0; m < u; m++)
      h[m] = arguments[m];
    return this.forward(h, "log", "", !0);
  }
  warn() {
    for (var u = arguments.length, h = new Array(u), m = 0; m < u; m++)
      h[m] = arguments[m];
    return this.forward(h, "warn", "", !0);
  }
  error() {
    for (var u = arguments.length, h = new Array(u), m = 0; m < u; m++)
      h[m] = arguments[m];
    return this.forward(h, "error", "");
  }
  deprecate() {
    for (var u = arguments.length, h = new Array(u), m = 0; m < u; m++)
      h[m] = arguments[m];
    return this.forward(h, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(u, h, m, w) {
    return w && !this.debug ? null : (typeof u[0] == "string" && (u[0] = `${m}${this.prefix} ${u[0]}`), this.logger[h](u));
  }
  create(u) {
    return new _y(this.logger, {
      prefix: `${this.prefix}:${u}:`,
      ...this.options
    });
  }
  clone(u) {
    return u = u || this.options, u.prefix = u.prefix || this.prefix, new _y(this.logger, u);
  }
}
var Oo = new _y();
class Gy {
  constructor() {
    this.observers = {};
  }
  on(u, h) {
    return u.split(" ").forEach((m) => {
      this.observers[m] = this.observers[m] || [], this.observers[m].push(h);
    }), this;
  }
  off(u, h) {
    if (this.observers[u]) {
      if (!h) {
        delete this.observers[u];
        return;
      }
      this.observers[u] = this.observers[u].filter((m) => m !== h);
    }
  }
  emit(u) {
    for (var h = arguments.length, m = new Array(h > 1 ? h - 1 : 0), w = 1; w < h; w++)
      m[w - 1] = arguments[w];
    this.observers[u] && [].concat(this.observers[u]).forEach((T) => {
      T(...m);
    }), this.observers["*"] && [].concat(this.observers["*"]).forEach((T) => {
      T.apply(T, [u, ...m]);
    });
  }
}
function tg() {
  let s, u;
  const h = new Promise((m, w) => {
    s = m, u = w;
  });
  return h.resolve = s, h.reject = u, h;
}
function JT(s) {
  return s == null ? "" : "" + s;
}
function W_(s, u, h) {
  s.forEach((m) => {
    u[m] && (h[m] = u[m]);
  });
}
function _1(s, u, h) {
  function m(A) {
    return A && A.indexOf("###") > -1 ? A.replace(/###/g, ".") : A;
  }
  function w() {
    return !s || typeof s == "string";
  }
  const T = typeof u != "string" ? [].concat(u) : u.split(".");
  for (; T.length > 1; ) {
    if (w())
      return {};
    const A = m(T.shift());
    !s[A] && h && (s[A] = new h()), Object.prototype.hasOwnProperty.call(s, A) ? s = s[A] : s = {};
  }
  return w() ? {} : {
    obj: s,
    k: m(T.shift())
  };
}
function eA(s, u, h) {
  const {
    obj: m,
    k: w
  } = _1(s, u, Object);
  m[w] = h;
}
function U_(s, u, h, m) {
  const {
    obj: w,
    k: T
  } = _1(s, u, Object);
  w[T] = w[T] || [], m && (w[T] = w[T].concat(h)), m || w[T].push(h);
}
function Py(s, u) {
  const {
    obj: h,
    k: m
  } = _1(s, u);
  if (h)
    return h[m];
}
function X_(s, u, h) {
  const m = Py(s, h);
  return m !== void 0 ? m : Py(u, h);
}
function dE(s, u, h) {
  for (const m in u)
    m !== "__proto__" && m !== "constructor" && (m in s ? typeof s[m] == "string" || s[m] instanceof String || typeof u[m] == "string" || u[m] instanceof String ? h && (s[m] = u[m]) : dE(s[m], u[m], h) : s[m] = u[m]);
  return s;
}
function Mf(s) {
  return s.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var V_ = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function G_(s) {
  return typeof s == "string" ? s.replace(/[&<>"'\/]/g, (u) => V_[u]) : s;
}
const $_ = [" ", ",", "?", "!", ";"];
function q_(s, u, h) {
  u = u || "", h = h || "";
  const m = $_.filter((A) => u.indexOf(A) < 0 && h.indexOf(A) < 0);
  if (m.length === 0)
    return !0;
  const w = new RegExp(`(${m.map((A) => A === "?" ? "\\?" : A).join("|")})`);
  let T = !w.test(s);
  if (!T) {
    const A = s.indexOf(h);
    A > 0 && !w.test(s.substring(0, A)) && (T = !0);
  }
  return T;
}
function Ny(s, u) {
  let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!s)
    return;
  if (s[u])
    return s[u];
  const m = u.split(h);
  let w = s;
  for (let T = 0; T < m.length; ++T) {
    if (!w || typeof w[m[T]] == "string" && T + 1 < m.length)
      return;
    if (w[m[T]] === void 0) {
      let A = 2, F = m.slice(T, T + A).join(h), H = w[F];
      for (; H === void 0 && m.length > T + A; )
        A++, F = m.slice(T, T + A).join(h), H = w[F];
      if (H === void 0)
        return;
      if (H === null)
        return null;
      if (u.endsWith(F)) {
        if (typeof H == "string")
          return H;
        if (F && typeof H[F] == "string")
          return H[F];
      }
      const j = m.slice(T + A).join(h);
      return j ? Ny(H, j, h) : void 0;
    }
    w = w[m[T]];
  }
  return w;
}
function zy(s) {
  return s && s.indexOf("_") > 0 ? s.replace("_", "-") : s;
}
class tA extends Gy {
  constructor(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = u || {}, this.options = h, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(u) {
    this.options.ns.indexOf(u) < 0 && this.options.ns.push(u);
  }
  removeNamespaces(u) {
    const h = this.options.ns.indexOf(u);
    h > -1 && this.options.ns.splice(h, 1);
  }
  getResource(u, h, m) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const T = w.keySeparator !== void 0 ? w.keySeparator : this.options.keySeparator, A = w.ignoreJSONStructure !== void 0 ? w.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let F = [u, h];
    m && typeof m != "string" && (F = F.concat(m)), m && typeof m == "string" && (F = F.concat(T ? m.split(T) : m)), u.indexOf(".") > -1 && (F = u.split("."));
    const H = Py(this.data, F);
    return H || !A || typeof m != "string" ? H : Ny(this.data && this.data[u] && this.data[u][h], m, T);
  }
  addResource(u, h, m, w) {
    let T = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const A = T.keySeparator !== void 0 ? T.keySeparator : this.options.keySeparator;
    let F = [u, h];
    m && (F = F.concat(A ? m.split(A) : m)), u.indexOf(".") > -1 && (F = u.split("."), w = h, h = F[1]), this.addNamespaces(h), eA(this.data, F, w), T.silent || this.emit("added", u, h, m, w);
  }
  addResources(u, h, m) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const T in m)
      (typeof m[T] == "string" || Object.prototype.toString.apply(m[T]) === "[object Array]") && this.addResource(u, h, T, m[T], {
        silent: !0
      });
    w.silent || this.emit("added", u, h, m);
  }
  addResourceBundle(u, h, m, w, T) {
    let A = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: !1
    }, F = [u, h];
    u.indexOf(".") > -1 && (F = u.split("."), w = m, m = h, h = F[1]), this.addNamespaces(h);
    let H = Py(this.data, F) || {};
    w ? dE(H, m, T) : H = {
      ...H,
      ...m
    }, eA(this.data, F, H), A.silent || this.emit("added", u, h, m);
  }
  removeResourceBundle(u, h) {
    this.hasResourceBundle(u, h) && delete this.data[u][h], this.removeNamespaces(h), this.emit("removed", u, h);
  }
  hasResourceBundle(u, h) {
    return this.getResource(u, h) !== void 0;
  }
  getResourceBundle(u, h) {
    return h || (h = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? {
      ...this.getResource(u, h)
    } : this.getResource(u, h);
  }
  getDataByLanguage(u) {
    return this.data[u];
  }
  hasLanguageSomeTranslations(u) {
    const h = this.getDataByLanguage(u);
    return !!(h && Object.keys(h) || []).find((m) => h[m] && Object.keys(h[m]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var fE = {
  processors: {},
  addPostProcessor(s) {
    this.processors[s.name] = s;
  },
  handle(s, u, h, m, w) {
    return s.forEach((T) => {
      this.processors[T] && (u = this.processors[T].process(u, h, m, w));
    }), u;
  }
};
const nA = {};
class Iy extends Gy {
  constructor(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), W_(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], u, this), this.options = h, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = Oo.create("translator");
  }
  changeLanguage(u) {
    u && (this.language = u);
  }
  exists(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (u == null)
      return !1;
    const m = this.resolve(u, h);
    return m && m.res !== void 0;
  }
  extractFromKey(u, h) {
    let m = h.nsSeparator !== void 0 ? h.nsSeparator : this.options.nsSeparator;
    m === void 0 && (m = ":");
    const w = h.keySeparator !== void 0 ? h.keySeparator : this.options.keySeparator;
    let T = h.ns || this.options.defaultNS || [];
    const A = m && u.indexOf(m) > -1, F = !this.options.userDefinedKeySeparator && !h.keySeparator && !this.options.userDefinedNsSeparator && !h.nsSeparator && !q_(u, m, w);
    if (A && !F) {
      const H = u.match(this.interpolator.nestingRegexp);
      if (H && H.length > 0)
        return {
          key: u,
          namespaces: T
        };
      const j = u.split(m);
      (m !== w || m === w && this.options.ns.indexOf(j[0]) > -1) && (T = j.shift()), u = j.join(w);
    }
    return typeof T == "string" && (T = [T]), {
      key: u,
      namespaces: T
    };
  }
  translate(u, h, m) {
    if (typeof h != "object" && this.options.overloadTranslationOptionHandler && (h = this.options.overloadTranslationOptionHandler(arguments)), typeof h == "object" && (h = {
      ...h
    }), h || (h = {}), u == null)
      return "";
    Array.isArray(u) || (u = [String(u)]);
    const w = h.returnDetails !== void 0 ? h.returnDetails : this.options.returnDetails, T = h.keySeparator !== void 0 ? h.keySeparator : this.options.keySeparator, {
      key: A,
      namespaces: F
    } = this.extractFromKey(u[u.length - 1], h), H = F[F.length - 1], j = h.lng || this.language, V = h.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (j && j.toLowerCase() === "cimode") {
      if (V) {
        const we = h.nsSeparator || this.options.nsSeparator;
        return w ? {
          res: `${H}${we}${A}`,
          usedKey: A,
          exactUsedKey: A,
          usedLng: j,
          usedNS: H
        } : `${H}${we}${A}`;
      }
      return w ? {
        res: A,
        usedKey: A,
        exactUsedKey: A,
        usedLng: j,
        usedNS: H
      } : A;
    }
    const q = this.resolve(u, h);
    let te = q && q.res;
    const ae = q && q.usedKey || A, se = q && q.exactUsedKey || A, ue = Object.prototype.toString.apply(te), Ce = ["[object Number]", "[object Function]", "[object RegExp]"], Pe = h.joinArrays !== void 0 ? h.joinArrays : this.options.joinArrays, K = !this.i18nFormat || this.i18nFormat.handleAsObject;
    if (K && te && typeof te != "string" && typeof te != "boolean" && typeof te != "number" && Ce.indexOf(ue) < 0 && !(typeof Pe == "string" && ue === "[object Array]")) {
      if (!h.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const we = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(ae, te, {
          ...h,
          ns: F
        }) : `key '${A} (${this.language})' returned an object instead of string.`;
        return w ? (q.res = we, q) : we;
      }
      if (T) {
        const we = ue === "[object Array]", Ee = we ? [] : {}, re = we ? se : ae;
        for (const me in te)
          if (Object.prototype.hasOwnProperty.call(te, me)) {
            const Me = `${re}${T}${me}`;
            Ee[me] = this.translate(Me, {
              ...h,
              joinArrays: !1,
              ns: F
            }), Ee[me] === Me && (Ee[me] = te[me]);
          }
        te = Ee;
      }
    } else if (K && typeof Pe == "string" && ue === "[object Array]")
      te = te.join(Pe), te && (te = this.extendTranslation(te, u, h, m));
    else {
      let we = !1, Ee = !1;
      const re = h.count !== void 0 && typeof h.count != "string", me = Iy.hasDefaultValue(h), Me = re ? this.pluralResolver.getSuffix(j, h.count, h) : "", Je = h.ordinal && re ? this.pluralResolver.getSuffix(j, h.count, {
        ordinal: !1
      }) : "", Ve = h[`defaultValue${Me}`] || h[`defaultValue${Je}`] || h.defaultValue;
      !this.isValidLookup(te) && me && (we = !0, te = Ve), this.isValidLookup(te) || (Ee = !0, te = A);
      const Xe = (h.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && Ee ? void 0 : te, it = me && Ve !== te && this.options.updateMissing;
      if (Ee || we || it) {
        if (this.logger.log(it ? "updateKey" : "missingKey", j, H, A, it ? Ve : te), T) {
          const Tt = this.resolve(A, {
            ...h,
            keySeparator: !1
          });
          Tt && Tt.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let ht = [];
        const Ke = this.languageUtils.getFallbackCodes(this.options.fallbackLng, h.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && Ke && Ke[0])
          for (let Tt = 0; Tt < Ke.length; Tt++)
            ht.push(Ke[Tt]);
        else
          this.options.saveMissingTo === "all" ? ht = this.languageUtils.toResolveHierarchy(h.lng || this.language) : ht.push(h.lng || this.language);
        const Ze = (Tt, It, Jt) => {
          const We = me && Jt !== te ? Jt : Xe;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(Tt, H, It, We, it, h) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(Tt, H, It, We, it, h), this.emit("missingKey", Tt, H, It, te);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && re ? ht.forEach((Tt) => {
          this.pluralResolver.getSuffixes(Tt, h).forEach((It) => {
            Ze([Tt], A + It, h[`defaultValue${It}`] || Ve);
          });
        }) : Ze(ht, A, Ve));
      }
      te = this.extendTranslation(te, u, h, q, m), Ee && te === A && this.options.appendNamespaceToMissingKey && (te = `${H}:${A}`), (Ee || we) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? te = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${H}:${A}` : A, we ? te : void 0) : te = this.options.parseMissingKeyHandler(te));
    }
    return w ? (q.res = te, q) : te;
  }
  extendTranslation(u, h, m, w, T) {
    var A = this;
    if (this.i18nFormat && this.i18nFormat.parse)
      u = this.i18nFormat.parse(u, {
        ...this.options.interpolation.defaultVariables,
        ...m
      }, m.lng || this.language || w.usedLng, w.usedNS, w.usedKey, {
        resolved: w
      });
    else if (!m.skipInterpolation) {
      m.interpolation && this.interpolator.init({
        ...m,
        interpolation: {
          ...this.options.interpolation,
          ...m.interpolation
        }
      });
      const j = typeof u == "string" && (m && m.interpolation && m.interpolation.skipOnVariables !== void 0 ? m.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let V;
      if (j) {
        const te = u.match(this.interpolator.nestingRegexp);
        V = te && te.length;
      }
      let q = m.replace && typeof m.replace != "string" ? m.replace : m;
      if (this.options.interpolation.defaultVariables && (q = {
        ...this.options.interpolation.defaultVariables,
        ...q
      }), u = this.interpolator.interpolate(u, q, m.lng || this.language, m), j) {
        const te = u.match(this.interpolator.nestingRegexp), ae = te && te.length;
        V < ae && (m.nest = !1);
      }
      !m.lng && this.options.compatibilityAPI !== "v1" && w && w.res && (m.lng = w.usedLng), m.nest !== !1 && (u = this.interpolator.nest(u, function() {
        for (var te = arguments.length, ae = new Array(te), se = 0; se < te; se++)
          ae[se] = arguments[se];
        return T && T[0] === ae[0] && !m.context ? (A.logger.warn(`It seems you are nesting recursively key: ${ae[0]} in key: ${h[0]}`), null) : A.translate(...ae, h);
      }, m)), m.interpolation && this.interpolator.reset();
    }
    const F = m.postProcess || this.options.postProcess, H = typeof F == "string" ? [F] : F;
    return u != null && H && H.length && m.applyPostProcessor !== !1 && (u = fE.handle(H, u, h, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: w,
      ...m
    } : m, this)), u;
  }
  resolve(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, m, w, T, A, F;
    return typeof u == "string" && (u = [u]), u.forEach((H) => {
      if (this.isValidLookup(m))
        return;
      const j = this.extractFromKey(H, h), V = j.key;
      w = V;
      let q = j.namespaces;
      this.options.fallbackNS && (q = q.concat(this.options.fallbackNS));
      const te = h.count !== void 0 && typeof h.count != "string", ae = te && !h.ordinal && h.count === 0 && this.pluralResolver.shouldUseIntlApi(), se = h.context !== void 0 && (typeof h.context == "string" || typeof h.context == "number") && h.context !== "", ue = h.lngs ? h.lngs : this.languageUtils.toResolveHierarchy(h.lng || this.language, h.fallbackLng);
      q.forEach((Ce) => {
        this.isValidLookup(m) || (F = Ce, !nA[`${ue[0]}-${Ce}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(F) && (nA[`${ue[0]}-${Ce}`] = !0, this.logger.warn(`key "${w}" for languages "${ue.join(", ")}" won't get resolved as namespace "${F}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), ue.forEach((Pe) => {
          if (this.isValidLookup(m))
            return;
          A = Pe;
          const K = [V];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys)
            this.i18nFormat.addLookupKeys(K, V, Pe, Ce, h);
          else {
            let Ee;
            te && (Ee = this.pluralResolver.getSuffix(Pe, h.count, h));
            const re = `${this.options.pluralSeparator}zero`, me = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (te && (K.push(V + Ee), h.ordinal && Ee.indexOf(me) === 0 && K.push(V + Ee.replace(me, this.options.pluralSeparator)), ae && K.push(V + re)), se) {
              const Me = `${V}${this.options.contextSeparator}${h.context}`;
              K.push(Me), te && (K.push(Me + Ee), h.ordinal && Ee.indexOf(me) === 0 && K.push(Me + Ee.replace(me, this.options.pluralSeparator)), ae && K.push(Me + re));
            }
          }
          let we;
          for (; we = K.pop(); )
            this.isValidLookup(m) || (T = we, m = this.getResource(Pe, Ce, we, h));
        }));
      });
    }), {
      res: m,
      usedKey: w,
      exactUsedKey: T,
      usedLng: A,
      usedNS: F
    };
  }
  isValidLookup(u) {
    return u !== void 0 && !(!this.options.returnNull && u === null) && !(!this.options.returnEmptyString && u === "");
  }
  getResource(u, h, m) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(u, h, m, w) : this.resourceStore.getResource(u, h, m, w);
  }
  static hasDefaultValue(u) {
    const h = "defaultValue";
    for (const m in u)
      if (Object.prototype.hasOwnProperty.call(u, m) && h === m.substring(0, h.length) && u[m] !== void 0)
        return !0;
    return !1;
  }
}
function Fw(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
class rA {
  constructor(u) {
    this.options = u, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Oo.create("languageUtils");
  }
  getScriptPartFromCode(u) {
    if (u = zy(u), !u || u.indexOf("-") < 0)
      return null;
    const h = u.split("-");
    return h.length === 2 || (h.pop(), h[h.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(h.join("-"));
  }
  getLanguagePartFromCode(u) {
    if (u = zy(u), !u || u.indexOf("-") < 0)
      return u;
    const h = u.split("-");
    return this.formatLanguageCode(h[0]);
  }
  formatLanguageCode(u) {
    if (typeof u == "string" && u.indexOf("-") > -1) {
      const h = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let m = u.split("-");
      return this.options.lowerCaseLng ? m = m.map((w) => w.toLowerCase()) : m.length === 2 ? (m[0] = m[0].toLowerCase(), m[1] = m[1].toUpperCase(), h.indexOf(m[1].toLowerCase()) > -1 && (m[1] = Fw(m[1].toLowerCase()))) : m.length === 3 && (m[0] = m[0].toLowerCase(), m[1].length === 2 && (m[1] = m[1].toUpperCase()), m[0] !== "sgn" && m[2].length === 2 && (m[2] = m[2].toUpperCase()), h.indexOf(m[1].toLowerCase()) > -1 && (m[1] = Fw(m[1].toLowerCase())), h.indexOf(m[2].toLowerCase()) > -1 && (m[2] = Fw(m[2].toLowerCase()))), m.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? u.toLowerCase() : u;
  }
  isSupportedCode(u) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (u = this.getLanguagePartFromCode(u)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(u) > -1;
  }
  getBestMatchFromCodes(u) {
    if (!u)
      return null;
    let h;
    return u.forEach((m) => {
      if (h)
        return;
      const w = this.formatLanguageCode(m);
      (!this.options.supportedLngs || this.isSupportedCode(w)) && (h = w);
    }), !h && this.options.supportedLngs && u.forEach((m) => {
      if (h)
        return;
      const w = this.getLanguagePartFromCode(m);
      if (this.isSupportedCode(w))
        return h = w;
      h = this.options.supportedLngs.find((T) => {
        if (T === w || !(T.indexOf("-") < 0 && w.indexOf("-") < 0) && T.indexOf(w) === 0)
          return T;
      });
    }), h || (h = this.getFallbackCodes(this.options.fallbackLng)[0]), h;
  }
  getFallbackCodes(u, h) {
    if (!u)
      return [];
    if (typeof u == "function" && (u = u(h)), typeof u == "string" && (u = [u]), Object.prototype.toString.apply(u) === "[object Array]")
      return u;
    if (!h)
      return u.default || [];
    let m = u[h];
    return m || (m = u[this.getScriptPartFromCode(h)]), m || (m = u[this.formatLanguageCode(h)]), m || (m = u[this.getLanguagePartFromCode(h)]), m || (m = u.default), m || [];
  }
  toResolveHierarchy(u, h) {
    const m = this.getFallbackCodes(h || this.options.fallbackLng || [], u), w = [], T = (A) => {
      A && (this.isSupportedCode(A) ? w.push(A) : this.logger.warn(`rejecting language code not found in supportedLngs: ${A}`));
    };
    return typeof u == "string" && (u.indexOf("-") > -1 || u.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && T(this.formatLanguageCode(u)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && T(this.getScriptPartFromCode(u)), this.options.load !== "currentOnly" && T(this.getLanguagePartFromCode(u))) : typeof u == "string" && T(this.formatLanguageCode(u)), m.forEach((A) => {
      w.indexOf(A) < 0 && T(this.formatLanguageCode(A));
    }), w;
  }
}
let Z_ = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], Q_ = {
  1: function(s) {
    return +(s > 1);
  },
  2: function(s) {
    return +(s != 1);
  },
  3: function(s) {
    return 0;
  },
  4: function(s) {
    return s % 10 == 1 && s % 100 != 11 ? 0 : s % 10 >= 2 && s % 10 <= 4 && (s % 100 < 10 || s % 100 >= 20) ? 1 : 2;
  },
  5: function(s) {
    return s == 0 ? 0 : s == 1 ? 1 : s == 2 ? 2 : s % 100 >= 3 && s % 100 <= 10 ? 3 : s % 100 >= 11 ? 4 : 5;
  },
  6: function(s) {
    return s == 1 ? 0 : s >= 2 && s <= 4 ? 1 : 2;
  },
  7: function(s) {
    return s == 1 ? 0 : s % 10 >= 2 && s % 10 <= 4 && (s % 100 < 10 || s % 100 >= 20) ? 1 : 2;
  },
  8: function(s) {
    return s == 1 ? 0 : s == 2 ? 1 : s != 8 && s != 11 ? 2 : 3;
  },
  9: function(s) {
    return +(s >= 2);
  },
  10: function(s) {
    return s == 1 ? 0 : s == 2 ? 1 : s < 7 ? 2 : s < 11 ? 3 : 4;
  },
  11: function(s) {
    return s == 1 || s == 11 ? 0 : s == 2 || s == 12 ? 1 : s > 2 && s < 20 ? 2 : 3;
  },
  12: function(s) {
    return +(s % 10 != 1 || s % 100 == 11);
  },
  13: function(s) {
    return +(s !== 0);
  },
  14: function(s) {
    return s == 1 ? 0 : s == 2 ? 1 : s == 3 ? 2 : 3;
  },
  15: function(s) {
    return s % 10 == 1 && s % 100 != 11 ? 0 : s % 10 >= 2 && (s % 100 < 10 || s % 100 >= 20) ? 1 : 2;
  },
  16: function(s) {
    return s % 10 == 1 && s % 100 != 11 ? 0 : s !== 0 ? 1 : 2;
  },
  17: function(s) {
    return s == 1 || s % 10 == 1 && s % 100 != 11 ? 0 : 1;
  },
  18: function(s) {
    return s == 0 ? 0 : s == 1 ? 1 : 2;
  },
  19: function(s) {
    return s == 1 ? 0 : s == 0 || s % 100 > 1 && s % 100 < 11 ? 1 : s % 100 > 10 && s % 100 < 20 ? 2 : 3;
  },
  20: function(s) {
    return s == 1 ? 0 : s == 0 || s % 100 > 0 && s % 100 < 20 ? 1 : 2;
  },
  21: function(s) {
    return s % 100 == 1 ? 1 : s % 100 == 2 ? 2 : s % 100 == 3 || s % 100 == 4 ? 3 : 0;
  },
  22: function(s) {
    return s == 1 ? 0 : s == 2 ? 1 : (s < 0 || s > 10) && s % 10 == 0 ? 2 : 3;
  }
};
const K_ = ["v1", "v2", "v3"], J_ = ["v4"], aA = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function eP() {
  const s = {};
  return Z_.forEach((u) => {
    u.lngs.forEach((h) => {
      s[h] = {
        numbers: u.nr,
        plurals: Q_[u.fc]
      };
    });
  }), s;
}
class tP {
  constructor(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = u, this.options = h, this.logger = Oo.create("pluralResolver"), (!this.options.compatibilityJSON || J_.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = eP();
  }
  addRule(u, h) {
    this.rules[u] = h;
  }
  getRule(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi())
      try {
        return new Intl.PluralRules(zy(u), {
          type: h.ordinal ? "ordinal" : "cardinal"
        });
      } catch {
        return;
      }
    return this.rules[u] || this.rules[this.languageUtils.getLanguagePartFromCode(u)];
  }
  needsPlural(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const m = this.getRule(u, h);
    return this.shouldUseIntlApi() ? m && m.resolvedOptions().pluralCategories.length > 1 : m && m.numbers.length > 1;
  }
  getPluralFormsOfKey(u, h) {
    let m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(u, m).map((w) => `${h}${w}`);
  }
  getSuffixes(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const m = this.getRule(u, h);
    return m ? this.shouldUseIntlApi() ? m.resolvedOptions().pluralCategories.sort((w, T) => aA[w] - aA[T]).map((w) => `${this.options.prepend}${h.ordinal ? `ordinal${this.options.prepend}` : ""}${w}`) : m.numbers.map((w) => this.getSuffix(u, w, h)) : [];
  }
  getSuffix(u, h) {
    let m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const w = this.getRule(u, m);
    return w ? this.shouldUseIntlApi() ? `${this.options.prepend}${m.ordinal ? `ordinal${this.options.prepend}` : ""}${w.select(h)}` : this.getSuffixRetroCompatible(w, h) : (this.logger.warn(`no plural rule found for: ${u}`), "");
  }
  getSuffixRetroCompatible(u, h) {
    const m = u.noAbs ? u.plurals(h) : u.plurals(Math.abs(h));
    let w = u.numbers[m];
    this.options.simplifyPluralSuffix && u.numbers.length === 2 && u.numbers[0] === 1 && (w === 2 ? w = "plural" : w === 1 && (w = ""));
    const T = () => this.options.prepend && w.toString() ? this.options.prepend + w.toString() : w.toString();
    return this.options.compatibilityJSON === "v1" ? w === 1 ? "" : typeof w == "number" ? `_plural_${w.toString()}` : T() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && u.numbers.length === 2 && u.numbers[0] === 1 ? T() : this.options.prepend && m.toString() ? this.options.prepend + m.toString() : m.toString();
  }
  shouldUseIntlApi() {
    return !K_.includes(this.options.compatibilityJSON);
  }
}
function iA(s, u, h) {
  let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", w = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, T = X_(s, u, h);
  return !T && w && typeof h == "string" && (T = Ny(s, h, m), T === void 0 && (T = Ny(u, h, m))), T;
}
class nP {
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Oo.create("interpolator"), this.options = u, this.format = u.interpolation && u.interpolation.format || ((h) => h), this.init(u);
  }
  init() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    u.interpolation || (u.interpolation = {
      escapeValue: !0
    });
    const h = u.interpolation;
    this.escape = h.escape !== void 0 ? h.escape : G_, this.escapeValue = h.escapeValue !== void 0 ? h.escapeValue : !0, this.useRawValueToEscape = h.useRawValueToEscape !== void 0 ? h.useRawValueToEscape : !1, this.prefix = h.prefix ? Mf(h.prefix) : h.prefixEscaped || "{{", this.suffix = h.suffix ? Mf(h.suffix) : h.suffixEscaped || "}}", this.formatSeparator = h.formatSeparator ? h.formatSeparator : h.formatSeparator || ",", this.unescapePrefix = h.unescapeSuffix ? "" : h.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : h.unescapeSuffix || "", this.nestingPrefix = h.nestingPrefix ? Mf(h.nestingPrefix) : h.nestingPrefixEscaped || Mf("$t("), this.nestingSuffix = h.nestingSuffix ? Mf(h.nestingSuffix) : h.nestingSuffixEscaped || Mf(")"), this.nestingOptionsSeparator = h.nestingOptionsSeparator ? h.nestingOptionsSeparator : h.nestingOptionsSeparator || ",", this.maxReplaces = h.maxReplaces ? h.maxReplaces : 1e3, this.alwaysFormat = h.alwaysFormat !== void 0 ? h.alwaysFormat : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const u = `${this.prefix}(.+?)${this.suffix}`;
    this.regexp = new RegExp(u, "g");
    const h = `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`;
    this.regexpUnescape = new RegExp(h, "g");
    const m = `${this.nestingPrefix}(.+?)${this.nestingSuffix}`;
    this.nestingRegexp = new RegExp(m, "g");
  }
  interpolate(u, h, m, w) {
    let T, A, F;
    const H = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    function j(ae) {
      return ae.replace(/\$/g, "$$$$");
    }
    const V = (ae) => {
      if (ae.indexOf(this.formatSeparator) < 0) {
        const Pe = iA(h, H, ae, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(Pe, void 0, m, {
          ...w,
          ...h,
          interpolationkey: ae
        }) : Pe;
      }
      const se = ae.split(this.formatSeparator), ue = se.shift().trim(), Ce = se.join(this.formatSeparator).trim();
      return this.format(iA(h, H, ue, this.options.keySeparator, this.options.ignoreJSONStructure), Ce, m, {
        ...w,
        ...h,
        interpolationkey: ue
      });
    };
    this.resetRegExp();
    const q = w && w.missingInterpolationHandler || this.options.missingInterpolationHandler, te = w && w.interpolation && w.interpolation.skipOnVariables !== void 0 ? w.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (ae) => j(ae)
    }, {
      regex: this.regexp,
      safeValue: (ae) => this.escapeValue ? j(this.escape(ae)) : j(ae)
    }].forEach((ae) => {
      for (F = 0; T = ae.regex.exec(u); ) {
        const se = T[1].trim();
        if (A = V(se), A === void 0)
          if (typeof q == "function") {
            const Ce = q(u, T, w);
            A = typeof Ce == "string" ? Ce : "";
          } else if (w && Object.prototype.hasOwnProperty.call(w, se))
            A = "";
          else if (te) {
            A = T[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${se} for interpolating ${u}`), A = "";
        else
          typeof A != "string" && !this.useRawValueToEscape && (A = JT(A));
        const ue = ae.safeValue(A);
        if (u = u.replace(T[0], ue), te ? (ae.regex.lastIndex += A.length, ae.regex.lastIndex -= T[0].length) : ae.regex.lastIndex = 0, F++, F >= this.maxReplaces)
          break;
      }
    }), u;
  }
  nest(u, h) {
    let m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, w, T, A;
    function F(H, j) {
      const V = this.nestingOptionsSeparator;
      if (H.indexOf(V) < 0)
        return H;
      const q = H.split(new RegExp(`${V}[ ]*{`));
      let te = `{${q[1]}`;
      H = q[0], te = this.interpolate(te, A);
      const ae = te.match(/'/g), se = te.match(/"/g);
      (ae && ae.length % 2 === 0 && !se || se.length % 2 !== 0) && (te = te.replace(/'/g, '"'));
      try {
        A = JSON.parse(te), j && (A = {
          ...j,
          ...A
        });
      } catch (ue) {
        return this.logger.warn(`failed parsing options string in nesting for key ${H}`, ue), `${H}${V}${te}`;
      }
      return delete A.defaultValue, H;
    }
    for (; w = this.nestingRegexp.exec(u); ) {
      let H = [];
      A = {
        ...m
      }, A = A.replace && typeof A.replace != "string" ? A.replace : A, A.applyPostProcessor = !1, delete A.defaultValue;
      let j = !1;
      if (w[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(w[1])) {
        const V = w[1].split(this.formatSeparator).map((q) => q.trim());
        w[1] = V.shift(), H = V, j = !0;
      }
      if (T = h(F.call(this, w[1].trim(), A), A), T && w[0] === u && typeof T != "string")
        return T;
      typeof T != "string" && (T = JT(T)), T || (this.logger.warn(`missed to resolve ${w[1]} for nesting ${u}`), T = ""), j && (T = H.reduce((V, q) => this.format(V, q, m.lng, {
        ...m,
        interpolationkey: w[1].trim()
      }), T.trim())), u = u.replace(w[0], T), this.regexp.lastIndex = 0;
    }
    return u;
  }
}
function rP(s) {
  let u = s.toLowerCase().trim();
  const h = {};
  if (s.indexOf("(") > -1) {
    const m = s.split("(");
    u = m[0].toLowerCase().trim();
    const w = m[1].substring(0, m[1].length - 1);
    u === "currency" && w.indexOf(":") < 0 ? h.currency || (h.currency = w.trim()) : u === "relativetime" && w.indexOf(":") < 0 ? h.range || (h.range = w.trim()) : w.split(";").forEach((T) => {
      if (!T)
        return;
      const [A, ...F] = T.split(":"), H = F.join(":").trim().replace(/^'+|'+$/g, "");
      h[A.trim()] || (h[A.trim()] = H), H === "false" && (h[A.trim()] = !1), H === "true" && (h[A.trim()] = !0), isNaN(H) || (h[A.trim()] = parseInt(H, 10));
    });
  }
  return {
    formatName: u,
    formatOptions: h
  };
}
function _f(s) {
  const u = {};
  return function(h, m, w) {
    const T = m + JSON.stringify(w);
    let A = u[T];
    return A || (A = s(zy(m), w), u[T] = A), A(h);
  };
}
class aP {
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Oo.create("formatter"), this.options = u, this.formats = {
      number: _f((h, m) => {
        const w = new Intl.NumberFormat(h, {
          ...m
        });
        return (T) => w.format(T);
      }),
      currency: _f((h, m) => {
        const w = new Intl.NumberFormat(h, {
          ...m,
          style: "currency"
        });
        return (T) => w.format(T);
      }),
      datetime: _f((h, m) => {
        const w = new Intl.DateTimeFormat(h, {
          ...m
        });
        return (T) => w.format(T);
      }),
      relativetime: _f((h, m) => {
        const w = new Intl.RelativeTimeFormat(h, {
          ...m
        });
        return (T) => w.format(T, m.range || "day");
      }),
      list: _f((h, m) => {
        const w = new Intl.ListFormat(h, {
          ...m
        });
        return (T) => w.format(T);
      })
    }, this.init(u);
  }
  init(u) {
    const h = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    }).interpolation;
    this.formatSeparator = h.formatSeparator ? h.formatSeparator : h.formatSeparator || ",";
  }
  add(u, h) {
    this.formats[u.toLowerCase().trim()] = h;
  }
  addCached(u, h) {
    this.formats[u.toLowerCase().trim()] = _f(h);
  }
  format(u, h, m) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return h.split(this.formatSeparator).reduce((T, A) => {
      const {
        formatName: F,
        formatOptions: H
      } = rP(A);
      if (this.formats[F]) {
        let j = T;
        try {
          const V = w && w.formatParams && w.formatParams[w.interpolationkey] || {}, q = V.locale || V.lng || w.locale || w.lng || m;
          j = this.formats[F](T, q, {
            ...H,
            ...w,
            ...V
          });
        } catch (V) {
          this.logger.warn(V);
        }
        return j;
      } else
        this.logger.warn(`there was no format function for ${F}`);
      return T;
    }, u);
  }
}
function iP(s, u) {
  s.pending[u] !== void 0 && (delete s.pending[u], s.pendingCount--);
}
class sP extends Gy {
  constructor(u, h, m) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = u, this.store = h, this.services = m, this.languageUtils = m.languageUtils, this.options = w, this.logger = Oo.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = w.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = w.maxRetries >= 0 ? w.maxRetries : 5, this.retryTimeout = w.retryTimeout >= 1 ? w.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(m, w.backend, w);
  }
  queueLoad(u, h, m, w) {
    const T = {}, A = {}, F = {}, H = {};
    return u.forEach((j) => {
      let V = !0;
      h.forEach((q) => {
        const te = `${j}|${q}`;
        !m.reload && this.store.hasResourceBundle(j, q) ? this.state[te] = 2 : this.state[te] < 0 || (this.state[te] === 1 ? A[te] === void 0 && (A[te] = !0) : (this.state[te] = 1, V = !1, A[te] === void 0 && (A[te] = !0), T[te] === void 0 && (T[te] = !0), H[q] === void 0 && (H[q] = !0)));
      }), V || (F[j] = !0);
    }), (Object.keys(T).length || Object.keys(A).length) && this.queue.push({
      pending: A,
      pendingCount: Object.keys(A).length,
      loaded: {},
      errors: [],
      callback: w
    }), {
      toLoad: Object.keys(T),
      pending: Object.keys(A),
      toLoadLanguages: Object.keys(F),
      toLoadNamespaces: Object.keys(H)
    };
  }
  loaded(u, h, m) {
    const w = u.split("|"), T = w[0], A = w[1];
    h && this.emit("failedLoading", T, A, h), m && this.store.addResourceBundle(T, A, m), this.state[u] = h ? -1 : 2;
    const F = {};
    this.queue.forEach((H) => {
      U_(H.loaded, [T], A), iP(H, u), h && H.errors.push(h), H.pendingCount === 0 && !H.done && (Object.keys(H.loaded).forEach((j) => {
        F[j] || (F[j] = {});
        const V = H.loaded[j];
        V.length && V.forEach((q) => {
          F[j][q] === void 0 && (F[j][q] = !0);
        });
      }), H.done = !0, H.errors.length ? H.callback(H.errors) : H.callback());
    }), this.emit("loaded", F), this.queue = this.queue.filter((H) => !H.done);
  }
  read(u, h, m) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, T = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, A = arguments.length > 5 ? arguments[5] : void 0;
    if (!u.length)
      return A(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: u,
        ns: h,
        fcName: m,
        tried: w,
        wait: T,
        callback: A
      });
      return;
    }
    this.readingCalls++;
    const F = (j, V) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const q = this.waitingReads.shift();
        this.read(q.lng, q.ns, q.fcName, q.tried, q.wait, q.callback);
      }
      if (j && V && w < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, u, h, m, w + 1, T * 2, A);
        }, T);
        return;
      }
      A(j, V);
    }, H = this.backend[m].bind(this.backend);
    if (H.length === 2) {
      try {
        const j = H(u, h);
        j && typeof j.then == "function" ? j.then((V) => F(null, V)).catch(F) : F(null, j);
      } catch (j) {
        F(j);
      }
      return;
    }
    return H(u, h, F);
  }
  prepareLoading(u, h) {
    let m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, w = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), w && w();
    typeof u == "string" && (u = this.languageUtils.toResolveHierarchy(u)), typeof h == "string" && (h = [h]);
    const T = this.queueLoad(u, h, m, w);
    if (!T.toLoad.length)
      return T.pending.length || w(), null;
    T.toLoad.forEach((A) => {
      this.loadOne(A);
    });
  }
  load(u, h, m) {
    this.prepareLoading(u, h, {}, m);
  }
  reload(u, h, m) {
    this.prepareLoading(u, h, {
      reload: !0
    }, m);
  }
  loadOne(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const m = u.split("|"), w = m[0], T = m[1];
    this.read(w, T, "read", void 0, void 0, (A, F) => {
      A && this.logger.warn(`${h}loading namespace ${T} for language ${w} failed`, A), !A && F && this.logger.log(`${h}loaded namespace ${T} for language ${w}`, F), this.loaded(u, A, F);
    });
  }
  saveMissing(u, h, m, w, T) {
    let A = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, F = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(h)) {
      this.logger.warn(`did not save key "${m}" as the namespace "${h}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(m == null || m === "")) {
      if (this.backend && this.backend.create) {
        const H = {
          ...A,
          isUpdate: T
        }, j = this.backend.create.bind(this.backend);
        if (j.length < 6)
          try {
            let V;
            j.length === 5 ? V = j(u, h, m, w, H) : V = j(u, h, m, w), V && typeof V.then == "function" ? V.then((q) => F(null, q)).catch(F) : F(null, V);
          } catch (V) {
            F(V);
          }
        else
          j(u, h, m, w, F, H);
      }
      !u || !u[0] || this.store.addResource(u[0], h, m, w);
    }
  }
}
function sA() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !1,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(s) {
      let u = {};
      if (typeof s[1] == "object" && (u = s[1]), typeof s[1] == "string" && (u.defaultValue = s[1]), typeof s[2] == "string" && (u.tDescription = s[2]), typeof s[2] == "object" || typeof s[3] == "object") {
        const h = s[3] || s[2];
        Object.keys(h).forEach((m) => {
          u[m] = h[m];
        });
      }
      return u;
    },
    interpolation: {
      escapeValue: !0,
      format: (s, u, h, m) => s,
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
function oA(s) {
  return typeof s.ns == "string" && (s.ns = [s.ns]), typeof s.fallbackLng == "string" && (s.fallbackLng = [s.fallbackLng]), typeof s.fallbackNS == "string" && (s.fallbackNS = [s.fallbackNS]), s.supportedLngs && s.supportedLngs.indexOf("cimode") < 0 && (s.supportedLngs = s.supportedLngs.concat(["cimode"])), s;
}
function yy() {
}
function oP(s) {
  Object.getOwnPropertyNames(Object.getPrototypeOf(s)).forEach((u) => {
    typeof s[u] == "function" && (s[u] = s[u].bind(s));
  });
}
class hg extends Gy {
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = oA(u), this.services = {}, this.logger = Oo, this.modules = {
      external: []
    }, oP(this), h && !this.isInitialized && !u.isClone) {
      if (!this.options.initImmediate)
        return this.init(u, h), this;
      setTimeout(() => {
        this.init(u, h);
      }, 0);
    }
  }
  init() {
    var u = this;
    let h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, m = arguments.length > 1 ? arguments[1] : void 0;
    typeof h == "function" && (m = h, h = {}), !h.defaultNS && h.defaultNS !== !1 && h.ns && (typeof h.ns == "string" ? h.defaultNS = h.ns : h.ns.indexOf("translation") < 0 && (h.defaultNS = h.ns[0]));
    const w = sA();
    this.options = {
      ...w,
      ...this.options,
      ...oA(h)
    }, this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
      ...w.interpolation,
      ...this.options.interpolation
    }), h.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = h.keySeparator), h.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = h.nsSeparator);
    function T(H) {
      return H ? typeof H == "function" ? new H() : H : null;
    }
    if (!this.options.isClone) {
      this.modules.logger ? Oo.init(T(this.modules.logger), this.options) : Oo.init(null, this.options);
      let H;
      this.modules.formatter ? H = this.modules.formatter : typeof Intl < "u" && (H = aP);
      const j = new rA(this.options);
      this.store = new tA(this.options.resources, this.options);
      const V = this.services;
      V.logger = Oo, V.resourceStore = this.store, V.languageUtils = j, V.pluralResolver = new tP(j, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), H && (!this.options.interpolation.format || this.options.interpolation.format === w.interpolation.format) && (V.formatter = T(H), V.formatter.init(V, this.options), this.options.interpolation.format = V.formatter.format.bind(V.formatter)), V.interpolator = new nP(this.options), V.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, V.backendConnector = new sP(T(this.modules.backend), V.resourceStore, V, this.options), V.backendConnector.on("*", function(q) {
        for (var te = arguments.length, ae = new Array(te > 1 ? te - 1 : 0), se = 1; se < te; se++)
          ae[se - 1] = arguments[se];
        u.emit(q, ...ae);
      }), this.modules.languageDetector && (V.languageDetector = T(this.modules.languageDetector), V.languageDetector.init && V.languageDetector.init(V, this.options.detection, this.options)), this.modules.i18nFormat && (V.i18nFormat = T(this.modules.i18nFormat), V.i18nFormat.init && V.i18nFormat.init(this)), this.translator = new Iy(this.services, this.options), this.translator.on("*", function(q) {
        for (var te = arguments.length, ae = new Array(te > 1 ? te - 1 : 0), se = 1; se < te; se++)
          ae[se - 1] = arguments[se];
        u.emit(q, ...ae);
      }), this.modules.external.forEach((q) => {
        q.init && q.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, m || (m = yy), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const H = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      H.length > 0 && H[0] !== "dev" && (this.options.lng = H[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((H) => {
      this[H] = function() {
        return u.store[H](...arguments);
      };
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((H) => {
      this[H] = function() {
        return u.store[H](...arguments), u;
      };
    });
    const A = tg(), F = () => {
      const H = (j, V) => {
        this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), A.resolve(V), m(j, V);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized)
        return H(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, H);
    };
    return this.options.resources || !this.options.initImmediate ? F() : setTimeout(F, 0), A;
  }
  loadResources(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : yy;
    const m = typeof u == "string" ? u : this.language;
    if (typeof u == "function" && (h = u), !this.options.resources || this.options.partialBundledLanguages) {
      if (m && m.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0))
        return h();
      const w = [], T = (A) => {
        !A || A === "cimode" || this.services.languageUtils.toResolveHierarchy(A).forEach((F) => {
          F !== "cimode" && w.indexOf(F) < 0 && w.push(F);
        });
      };
      m ? T(m) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((A) => T(A)), this.options.preload && this.options.preload.forEach((A) => T(A)), this.services.backendConnector.load(w, this.options.ns, (A) => {
        !A && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), h(A);
      });
    } else
      h(null);
  }
  reloadResources(u, h, m) {
    const w = tg();
    return u || (u = this.languages), h || (h = this.options.ns), m || (m = yy), this.services.backendConnector.reload(u, h, (T) => {
      w.resolve(), m(T);
    }), w;
  }
  use(u) {
    if (!u)
      throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!u.type)
      throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return u.type === "backend" && (this.modules.backend = u), (u.type === "logger" || u.log && u.warn && u.error) && (this.modules.logger = u), u.type === "languageDetector" && (this.modules.languageDetector = u), u.type === "i18nFormat" && (this.modules.i18nFormat = u), u.type === "postProcessor" && fE.addPostProcessor(u), u.type === "formatter" && (this.modules.formatter = u), u.type === "3rdParty" && this.modules.external.push(u), this;
  }
  setResolvedLanguage(u) {
    if (!(!u || !this.languages) && !(["cimode", "dev"].indexOf(u) > -1))
      for (let h = 0; h < this.languages.length; h++) {
        const m = this.languages[h];
        if (!(["cimode", "dev"].indexOf(m) > -1) && this.store.hasLanguageSomeTranslations(m)) {
          this.resolvedLanguage = m;
          break;
        }
      }
  }
  changeLanguage(u, h) {
    var m = this;
    this.isLanguageChangingTo = u;
    const w = tg();
    this.emit("languageChanging", u);
    const T = (H) => {
      this.language = H, this.languages = this.services.languageUtils.toResolveHierarchy(H), this.resolvedLanguage = void 0, this.setResolvedLanguage(H);
    }, A = (H, j) => {
      j ? (T(j), this.translator.changeLanguage(j), this.isLanguageChangingTo = void 0, this.emit("languageChanged", j), this.logger.log("languageChanged", j)) : this.isLanguageChangingTo = void 0, w.resolve(function() {
        return m.t(...arguments);
      }), h && h(H, function() {
        return m.t(...arguments);
      });
    }, F = (H) => {
      !u && !H && this.services.languageDetector && (H = []);
      const j = typeof H == "string" ? H : this.services.languageUtils.getBestMatchFromCodes(H);
      j && (this.language || T(j), this.translator.language || this.translator.changeLanguage(j), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(j)), this.loadResources(j, (V) => {
        A(V, j);
      });
    };
    return !u && this.services.languageDetector && !this.services.languageDetector.async ? F(this.services.languageDetector.detect()) : !u && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(F) : this.services.languageDetector.detect(F) : F(u), w;
  }
  getFixedT(u, h, m) {
    var w = this;
    const T = function(A, F) {
      let H;
      if (typeof F != "object") {
        for (var j = arguments.length, V = new Array(j > 2 ? j - 2 : 0), q = 2; q < j; q++)
          V[q - 2] = arguments[q];
        H = w.options.overloadTranslationOptionHandler([A, F].concat(V));
      } else
        H = {
          ...F
        };
      H.lng = H.lng || T.lng, H.lngs = H.lngs || T.lngs, H.ns = H.ns || T.ns, H.keyPrefix = H.keyPrefix || m || T.keyPrefix;
      const te = w.options.keySeparator || ".";
      let ae;
      return H.keyPrefix && Array.isArray(A) ? ae = A.map((se) => `${H.keyPrefix}${te}${se}`) : ae = H.keyPrefix ? `${H.keyPrefix}${te}${A}` : A, w.t(ae, H);
    };
    return typeof u == "string" ? T.lng = u : T.lngs = u, T.ns = h, T.keyPrefix = m, T;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(u) {
    this.options.defaultNS = u;
  }
  hasLoadedNamespace(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const m = h.lng || this.resolvedLanguage || this.languages[0], w = this.options ? this.options.fallbackLng : !1, T = this.languages[this.languages.length - 1];
    if (m.toLowerCase() === "cimode")
      return !0;
    const A = (F, H) => {
      const j = this.services.backendConnector.state[`${F}|${H}`];
      return j === -1 || j === 2;
    };
    if (h.precheck) {
      const F = h.precheck(this, A);
      if (F !== void 0)
        return F;
    }
    return !!(this.hasResourceBundle(m, u) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || A(m, u) && (!w || A(T, u)));
  }
  loadNamespaces(u, h) {
    const m = tg();
    return this.options.ns ? (typeof u == "string" && (u = [u]), u.forEach((w) => {
      this.options.ns.indexOf(w) < 0 && this.options.ns.push(w);
    }), this.loadResources((w) => {
      m.resolve(), h && h(w);
    }), m) : (h && h(), Promise.resolve());
  }
  loadLanguages(u, h) {
    const m = tg();
    typeof u == "string" && (u = [u]);
    const w = this.options.preload || [], T = u.filter((A) => w.indexOf(A) < 0);
    return T.length ? (this.options.preload = w.concat(T), this.loadResources((A) => {
      m.resolve(), h && h(A);
    }), m) : (h && h(), Promise.resolve());
  }
  dir(u) {
    if (u || (u = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !u)
      return "rtl";
    const h = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], m = this.services && this.services.languageUtils || new rA(sA());
    return h.indexOf(m.getLanguagePartFromCode(u)) > -1 || u.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = arguments.length > 1 ? arguments[1] : void 0;
    return new hg(u, h);
  }
  cloneInstance() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : yy;
    const m = u.forkResourceStore;
    m && delete u.forkResourceStore;
    const w = {
      ...this.options,
      ...u,
      isClone: !0
    }, T = new hg(w);
    return (u.debug !== void 0 || u.prefix !== void 0) && (T.logger = T.logger.clone(u)), ["store", "services", "language"].forEach((A) => {
      T[A] = this[A];
    }), T.services = {
      ...this.services
    }, T.services.utils = {
      hasLoadedNamespace: T.hasLoadedNamespace.bind(T)
    }, m && (T.store = new tA(this.store.data, w), T.services.resourceStore = T.store), T.translator = new Iy(T.services, w), T.translator.on("*", function(A) {
      for (var F = arguments.length, H = new Array(F > 1 ? F - 1 : 0), j = 1; j < F; j++)
        H[j - 1] = arguments[j];
      T.emit(A, ...H);
    }), T.init(w, h), T.translator.options = w, T.translator.backendConnector.services.utils = {
      hasLoadedNamespace: T.hasLoadedNamespace.bind(T)
    }, T;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const Da = hg.createInstance();
Da.createInstance = hg.createInstance;
Da.createInstance;
Da.dir;
Da.init;
Da.loadResources;
Da.reloadResources;
Da.use;
const lP = Da.changeLanguage;
Da.getFixedT;
Da.t;
Da.exists;
Da.setDefaultNamespace;
Da.hasLoadedNamespace;
Da.loadNamespaces;
Da.loadLanguages;
const nr = (s, u) => Da.t(s, u), uP = {
  common: {
    ok: "Okay",
    workgroup: "Workgroup",
    "not-found": "Not Found",
    "accumulated-in-day": "Accumulated in Day",
    data: "Data",
    settings: "Settings",
    period: "Period",
    confirm: "Confirm",
    dates: "Dates",
    home: "Home",
    none: "None",
    user: "User",
    tenant: "Tenant",
    "select-all": "Select all",
    "disposition-with": "Disposition With Groups",
    "disposition-without": "Disposition Without Groups",
    "disposition-groups": "Disposition Groups",
    "remember-me": "Remember Me",
    admin: "Administrator",
    calls: "Calls",
    viewer: "Viewer",
    role: "Role",
    roles: "Roles",
    attempt: "Attempt",
    add: "Add",
    adherence: "Adherence",
    "file-type": "File Type",
    file: "File",
    "contact-right-person": "Contact Right Person",
    error: "Error",
    cancel: "Cancel",
    "real-time": "Real Time",
    back: "Back",
    name: "Name",
    email: "Email",
    group: "Group",
    password: "Password",
    services: "Services",
    visualization: "Visualization",
    table: "Table",
    chart: "Chart",
    continue: "Continue",
    close: "Close",
    save: "Save",
    open: "Open",
    break: "Break",
    breaks: "Breaks",
    edit: "Edit",
    logout: "Log Out",
    "sign-in": "Sign In",
    new: "New",
    agents: "Agents",
    agent: "Agent",
    users: "Users",
    applications: "Applications",
    general: "General",
    workgroups: "Work Groups",
    scalesgroups: "Scales Group",
    scales: "Scales",
    remove: "Remove",
    company: "Company",
    companies: "Companies",
    database: "Databases",
    theme: "Theme",
    language: "Language",
    search: "Search",
    done: "Done",
    next: "Next",
    previous: "Previous",
    loading: "Loading",
    journey: "Journey",
    action: "Action",
    start: "Start",
    entry: "Entry",
    end: "End",
    finish: "Finish",
    weekdays: "Weekdays",
    weekdaysNames: {
      sunday: "Sunday",
      monday: "Monday",
      tuesday: "Tuesday",
      wednesday: "Wednesday",
      thursday: "Thursday",
      friday: "Friday",
      saturday: "Saturday"
    },
    charts: {
      types: "Chart Types",
      bar: "Bar",
      line: "Line",
      time: "Time"
    }
  },
  complement: {
    add: "Add {{complement}}",
    select: "Select {{complement}}",
    remove: "Remove {{complement}}",
    name: "{{complement}}`s name",
    new: "New {{complement}}",
    edit: "Edit {{complement}}",
    open: "Open {{complement}}",
    close: "Close {{complement}}"
  },
  settings: {
    "application-title": "Select a company and database",
    tabs: {
      personal: "Personal",
      application: "Application"
    },
    themes: {
      coffe: "Coffee",
      light: "Light",
      dark: "Dark",
      forest: "Forest"
    },
    langs: {
      english: "English",
      portuguese: "Portuguese",
      spanish: "Spanish"
    }
  },
  messages: {
    "not-found": "No {{item}} was found",
    typing: "Type your {{item}}...",
    success: "{{item}} {{action}} successfully",
    failed: "{{item}} {{action}} failed"
  },
  table: {
    page: "Page",
    of: "of",
    "per-page": "Per page",
    items: "Items"
  },
  picker: {
    date: {
      days: {
        su: "Su",
        mo: "Mo",
        tu: "Tu",
        we: "We",
        th: "Th",
        fr: "Fr",
        sa: "Sa"
      }
    }
  },
  select: {
    "select-one": "Select one of the options"
  },
  sidebar: {
    general: "General",
    other: "Other",
    agents: "Agents",
    users: "Users",
    "disposition-groups": "Disposition Groups",
    services: "Services",
    calls: "Calls",
    "contact-right-person": "Contact Right Person",
    dashboard: "Dashboard",
    adherence: "Adherence",
    "real-time": "Real Time",
    workgroups: "Workgroups",
    staffing: "Staffing",
    home: "Home",
    scales: "Scales",
    scalesgroups: "Scales Groups",
    forecast: "Forecast"
  },
  conditions: {
    none: "None",
    greater: "Greater",
    greaterOrEqual: "Greater Or Equal",
    lesser: "Less",
    lesserOrEqual: "Less Or Equal",
    equal: "Equal",
    different: "Different"
  },
  actions: {
    create: "create",
    created: "created",
    download: "download",
    downloaded: "downloaded",
    update: "update",
    updated: "updated",
    remove: "remove",
    removed: "removed"
  },
  data: {
    users: {
      firstName: "First Name",
      lastName: "Last Name",
      email: "Email",
      role: "Role",
      active: "Active"
    },
    workgroups: {
      name: "Name",
      agents: "Agents",
      weekWorkDays: "Week Work Days",
      workGroups: "Work Groups",
      timeScale: "Time Scale",
      supervisor: "Supervisor"
    },
    agents: {
      firstName: "First Name",
      lastName: "Last Name",
      name: "Name",
      email: "Email",
      baseUserId: "Base User ID"
    },
    scales: {
      firstName: "First Name",
      lastName: "Last Name",
      baseUserId: "Base User ID"
    },
    scalesgroups: {
      name: "Name",
      timeScale: "Time Scale",
      workGroups: "Work Groups",
      breaks: "Breaks"
    },
    services: {
      attempts: "Attempts",
      hour: "Hour",
      answereds: "Answereds",
      contact_right_person: "Contact Right Person",
      loggeds_agents: "Loggeds Agents",
      average_service_time: "Average Service Time",
      occupancyRate: "Occupancy Rate",
      productivityRate: "Productivity Rate",
      availabilityFee: "Availability Fee",
      averageTimeLoggedIn: "Average Time Logged In",
      averageTimeSpoken: "Average Time Spoken",
      averageIdleTime: "Average Idle Time",
      averageOperatingTime: "Average Operating Time",
      hitRate: "Hit Rate"
    },
    charts: {
      absenteeism: "Absenteeism",
      topAdherenceOffenders: "Top Adherence Offenders",
      mediumWorkGroupsAdherence: "Medium WorkGroups Adherence",
      totalOperationBreakWorkedTime: "Total Operation Break Worked Time",
      totalOperationBreakScaledTime: "Total Operation Break Scaled Time",
      totalOperationLoggedTime: "Total Operation Logged Time",
      totalOperationScaledTime: "Total Operation Scaled Time",
      totalWorkGroupsExtraHours: "Total Work Groups Extra Hours",
      mediumWorkGroupsBreaksTimes: "Medium Work Groups Breaks Times",
      mediumWorkGroupsLoggedTimes: "Medium Work Groups Logged Times"
    },
    "real-time": {
      serviceName: "Service Name",
      serviceId: "Service Id",
      allAgentsLoggeds: "Agents Logged In",
      allAgentsInCall: "Agents in Call",
      allAgentIdle: "Agents Idle",
      allAgentNotReady: "Agents Not Ready",
      allAgentOthers: "Others",
      occupancyRate: "Occupancy Rate",
      inHold: "In Hold",
      inWrap: "In Wrap",
      date: "Date",
      totalCalls: "Total Calls",
      answered: "Answered",
      answeredPercentage: "Answered Percentage",
      notAnswered: "Not Answered",
      notAnsweredPercentage: "Not Answered Percentage",
      busy: "Busy",
      busyPercentage: "Busy Percentage",
      notAttend: "Not Attended",
      notAttendPercentage: "Not Attended Percentage",
      message: "Message",
      messagePercentage: "Message Percentage",
      cpc: "Contact Right Person"
    },
    adherence: {
      companyOperationBreakScaledTime: "Company Operation Scaled Break Time",
      companyOperationBreakWorkedTime: "Company Operation Worked Break Time",
      companyOperationLoggedTime: "Company Operation Logged Time",
      companyOperationScaledTime: "Company Operation Scaled Time",
      totalCompanyAdherence: "Total Company Adherence",
      totalCompanyBreaksAdherence: "Total Company Breaks Adherence",
      groupName: "Group Name",
      agents: "Agents",
      totalOperationLoggedTime: "Total Logged Time",
      totalOperationBreakWorkedTime: "Total Worked Break Time",
      totalOperationScaledTime: "Total scaled Time",
      totalOperationBreakScaledTime: "Total Scaled Break Time",
      breakAdherence: "Break Adherence",
      adherence: "Adherence"
    },
    "workgroup-adherence": {
      date: "Date",
      totalAgents: "Total Agents",
      averageServiceTime: "Average Service Time",
      occupancyRate: "Occupancy Rate",
      productivityRate: "Productivity Rate",
      availabilityFee: "Availability Fee",
      averageTimeLoggedIn: "Average Time Logged In",
      averageTimeSpoken: "Average Time Spoken",
      averageIdleTime: "Average Idle Time",
      averageRestBreak: "Average Rest Break",
      mediumBreakSnackOrLunch: "Medium Break (Snack or Lunch)",
      averageTrainingBreak: "Average Training Break",
      averageFeedbackBreak: "Average Feedback Break",
      answereds: "Answereds",
      contactRightPerson: "Contact Right Person",
      notContactRightPerson: "Not Contact Right Person",
      errands: "Errands",
      errandsPerContactRightPerson: "Errands per Contact Right Person",
      contactRightPersonPerAnswereds: "Contact Right Person per Answereds",
      percentageIdleTime: "Percentage Idle Time"
    },
    forecast: {
      hour: "Hour",
      answereds: "Answereds",
      attempts: "Attempts",
      hitRate: "Hit Rate",
      averageServiceTime: "Average Service Time",
      contactRightPerson: "Contact Right Person",
      contactRightPersonRatePerTotal: "Contact Right Person Rate per Total",
      contactRightPersonRatePerAnswered: "Contact Right Person Rate per Answered",
      loggedsAgents: "Loggeds Agents"
    }
  }
}, cP = {
  common: {
    ok: "Aceptar",
    confirm: "Confirm",
    dates: "Datas",
    "accumulated-in-day": "Acumulado no dia",
    data: "Dados",
    workgroup: "Grupo de Trabajo",
    "not-found": "No Encontrado",
    period: "Periodo",
    settings: "Configuraciones",
    "select-all": "Selecionar Tudo",
    "disposition-with": "Grupos com Disposio",
    "disposition-without": "Grupos sem Disposio",
    none: "Nenhum",
    "disposition-groups": "Grupos de Disposies",
    home: "Inicio",
    user: "Usuario",
    tenant: "Inquilino",
    "remember-me": "Lembrar-me",
    "sign-in": "Logar",
    admin: "Administrador",
    calls: "Llamadas",
    viewer: "Visualizador",
    role: "Rol",
    roles: "Roles",
    attempt: "Intento",
    add: "Agregar",
    adherence: "Adhesin",
    "file-type": "Tipo de Archivo",
    file: "Archivo",
    "contact-right-person": "Contactar a la Persona Correcta",
    error: "Error",
    cancel: "Cancelar",
    "real-time": "Tiempo Real",
    back: "Volver",
    name: "Nombre",
    email: "Correo Electrnico",
    group: "Grupo",
    password: "Contrasea",
    services: "Servicios",
    visualization: "Visualizacin",
    table: "Tabla",
    chart: "Grfico",
    continue: "Continuar",
    close: "Cerrar",
    save: "Guardar",
    open: "Abrir",
    break: "Descanso",
    breaks: "Descansos",
    edit: "Editar",
    logout: "Cerrar Sesin",
    new: "Nuevo",
    agents: "Agentes",
    agent: "Agente",
    users: "Usuarios",
    applications: "Aplicaciones",
    general: "General",
    workgroups: "Grupos de Trabajo",
    scalesgroups: "Grupo de Escalas",
    scales: "Escalas",
    remove: "Eliminar",
    company: "Empresa",
    companies: "Empresas",
    database: "Bases de Datos",
    theme: "Tema",
    language: "Idioma",
    search: "Buscar",
    done: "Hecho",
    next: "Siguiente",
    previous: "Anterior",
    loading: "Cargando",
    journey: "Trayecto",
    action: "Accin",
    start: "Comenzar",
    entry: "Entrada",
    end: "Fin",
    finish: "Finalizar",
    weekdays: "Das de la Semana",
    weekdaysNames: {
      sunday: "Domingo",
      monday: "Lunes",
      tuesday: "Martes",
      wednesday: "Mircoles",
      thursday: "Jueves",
      friday: "Viernes",
      saturday: "Sbado"
    },
    charts: {
      types: "Tipos de Grficos",
      bar: "Barra",
      line: "Lnea",
      time: "Tiempo"
    }
  },
  complement: {
    add: "Agregar {{complement}}",
    select: "Seleccionar {{complement}}",
    remove: "Eliminar {{complement}}",
    name: "Nombre de {{complement}}",
    new: "Nuevo {{complement}}",
    edit: "Editar {{complement}}",
    open: "Abrir {{complement}}",
    close: "Cerrar {{complement}}"
  },
  settings: {
    "application-title": "Seleccione una empresa y una base de datos",
    tabs: {
      personal: "Personal",
      application: "Aplicacin"
    },
    themes: {
      coffe: "Caf",
      light: "Claro",
      dark: "Oscuro",
      forest: "Bosque"
    },
    langs: {
      english: "Ingls",
      portuguese: "Portugus",
      spanish: "Espaol"
    }
  },
  messages: {
    "not-found": "No se encontr {{item}}",
    typing: "Escribe tu {{item}}...",
    success: "{{item}} {{action}} exitosamente",
    failed: "{{item}} {{action}} fall"
  },
  table: {
    page: "Pgina",
    of: "de",
    "per-page": "Por pgina",
    items: "Elementos"
  },
  picker: {
    date: {
      days: {
        su: "Do",
        mo: "Lu",
        tu: "Ma",
        we: "Mi",
        th: "Ju",
        fr: "Vi",
        sa: "S"
      }
    }
  },
  select: {
    "select-one": "Selecciona una de las opciones"
  },
  sidebar: {
    general: "General",
    agents: "Agentes",
    users: "Usuarios",
    other: "Otro",
    services: "Servicios",
    calls: "Llamadas",
    "disposition-groups": "Grupos de Disposio",
    "contact-right-person": "Contactar a la Persona Correcta",
    dashboard: "Tablero",
    adherence: "Adhesin",
    "real-time": "Tiempo Real",
    workgroups: "Grupos de Trabajo",
    staffing: "Personal",
    home: "Inicio",
    scales: "Escalas",
    scalesgroups: "Grupos de Escalas",
    forecast: "Pronstico"
  },
  actions: {
    create: "crear",
    created: "creado",
    download: "descargar",
    downloaded: "descargado",
    update: "actualizar",
    updated: "actualizado",
    remove: "eliminar",
    removed: "eliminado"
  },
  conditions: {
    none: "Nenhum",
    greater: "Maior",
    greaterOrEqual: "Acima ou Igual",
    lesser: "Menor",
    lesserOrEqual: "Menor ou Igual",
    equal: "Equal",
    different: "Diferente"
  },
  data: {
    users: {
      firstName: "Nombre",
      lastName: "Apellido",
      email: "Correo Electrnico",
      role: "Rol",
      active: "Activo"
    },
    workgroups: {
      weekWorkDays: "Dias del Semana",
      name: "Nombre",
      agents: "Agentes",
      workGroups: "Grupos de Trabajo",
      timeScale: "Escala de Tiempo",
      supervisor: "Supervisor"
    },
    scales: {
      firstName: "Nombre",
      lastName: "Apellido",
      baseUserId: "ID del Usuario Base"
    },
    scalesgroups: {
      name: "Nombre",
      timeScale: "Escala de Tiempo",
      workGroups: "Grupos de Trabajo",
      breaks: "Descansos"
    },
    services: {
      attempts: "Intentos",
      hour: "Hora",
      answereds: "Atendidas",
      contact_right_person: "Contactar a la Persona Correcta",
      loggeds_agents: "Agentes Registrados",
      average_service_time: "Tiempo Promedio de Servicio",
      occupancyRate: "Tasa de Ocupacin",
      productivityRate: "Tasa de Productividad",
      availabilityFee: "Tarifa de Disponibilidad",
      averageTimeLoggedIn: "Tiempo Promedio Conectado",
      averageTimeSpoken: "Tiempo Promedio Hablado",
      averageIdleTime: "Tiempo Promedio de Inactividad",
      averageOperatingTime: "Tiempo Promedio de Operacin",
      hitRate: "Tasa de xito"
    },
    charts: {
      totalOperationBreakWorkedTime: "Total de Pausa Trabalhada da Operao",
      totalOperationLoggedTime: "Total de Tempo Logado da Operao",
      totalOperationScaledTime: "Total de Tempo Escala da Operao",
      totalOperationBreakScaledTime: "Total de Pausa Escalada da Operao",
      absenteeism: "Absentismo",
      topAdherenceOffenders: "Principales Infractores de Adhesin",
      mediumWorkGroupsAdherence: "Adhesin Media de Grupos de Trabajo",
      totalWorkGroupsExtraHours: "Total de Horas Extra de Grupos de Trabajo",
      mediumWorkGroupsBreaksTimes: "Tiempos Medios de Descansos de Grupos de Trabajo",
      mediumWorkGroupsLoggedTimes: "Tiempos Medios de Registro de Grupos de Trabajo"
    },
    "real-time": {
      serviceName: "Nombre del Servicio",
      serviceId: "ID del Servicio",
      allAgentsLoggeds: "Agentes Conectados",
      allAgentsInCall: "Agentes en Llamada",
      allAgentIdle: "Agentes Inactivos",
      allAgentNotReady: "Agentes No Listos",
      allAgentOthers: "Otros",
      occupancyRate: "Tasa de Ocupacin",
      inHold: "En Espera",
      inWrap: "En Finalizacin",
      date: "Fecha",
      totalCalls: "Total de Llamadas",
      answered: "Atendidas",
      answeredPercentage: "Porcentaje Atendidas",
      notAnswered: "No Atendidas",
      notAnsweredPercentage: "Porcentaje No Atendidas",
      busy: "Ocupadas",
      busyPercentage: "Porcentaje Ocupadas",
      notAttend: "No Atendidas",
      notAttendPercentage: "Porcentaje No Atendidas",
      message: "Mensaje",
      messagePercentage: "Porcentaje de Mensajes",
      cpc: "Contactar a la Persona Correcta"
    },
    adherence: {
      companyOperationBreakScaledTime: "Tempo Total de Pausa Escalada da Empresa",
      companyOperationBreakWorkedTime: "Tempo Total de Pausa Trabalhada da Empresa",
      companyOperationLoggedTime: "Tempo de Operao Ativa da Empresa",
      companyOperationScaledTime: "Tempo de Operao Escalada da Empresa",
      totalCompanyAdherence: "Total de Aderncia da Empresa",
      totalCompanyBreaksAdherence: "Total de Aderncia em Pausas da Empresa",
      groupName: "Nome do Grupo",
      agents: "Agentes",
      totalOperationLoggedTime: "Tempo Total Logado da Opereao",
      totalOperationBreakWorkedTime: "Tempo Total de Pausa Trabalhada da Operao",
      totalOperationScaledTime: "Tempo Total Escalado da Operao",
      totalOperationBreakScaledTime: "Tempo Total de Pausa Escala da Operao",
      breakAdherence: "Pausa em Aderncia",
      adherence: "Aderncia"
    },
    agents: {
      firstName: "Nome",
      name: "Nome",
      lastName: "Sobrenome",
      email: "Email",
      baseUserId: "Usurio Base"
    },
    "workgroup-adherence": {
      date: "Data",
      totalAgents: "Total de Agentes",
      averageServiceTime: "Tiempo Promedio de Servicio",
      occupancyRate: "Tasa de Ocupacin",
      productivityRate: "Tasa de Productividad",
      availabilityFee: "Tarifa de Disponibilidad",
      averageTimeLoggedIn: "Tiempo Promedio Conectado",
      averageTimeSpoken: "Tiempo Promedio Hablado",
      averageIdleTime: "Tiempo Promedio de Inactividad",
      averageRestBreak: "Tiempo Promedio de Descanso",
      mediumBreakSnackOrLunch: "Tiempo Medio de Descanso (Refrigerio o Almuerzo)",
      averageTrainingBreak: "Tiempo Promedio de Descanso por Capacitacin",
      averageFeedbackBreak: "Tiempo Promedio de Descanso por Retroalimentacin",
      answereds: "Atendidas",
      contactRightPerson: "Contactar a la Persona Correcta",
      notContactRightPerson: "No Contactar a la Persona Correcta",
      errands: "Tareas",
      errandsPerContactRightPerson: "Tareas por Contactar a la Persona Correcta",
      contactRightPersonPerAnswereds: "Contactar a la Persona Correcta por Atendidas",
      percentageIdleTime: "Porcentaje de Tiempo Inactivo"
    },
    forecast: {
      hour: "Hora",
      answereds: "Respostas",
      attempts: "Tentativas",
      hitRate: "Percentual De Acerto",
      averageServiceTime: "Tempo mdio de Servio",
      contactRightPerson: "Contatar Pessoa Certa",
      contactRightPersonRatePerTotal: "Percentual Total de Contatar Pessoa Certa",
      contactRightPersonRatePerAnswered: "Percentual por Resposta de Contatar Pessoa Certa",
      loggedsAgents: "Agentes Logados"
    }
  }
}, dP = {
  common: {
    ok: "Ok",
    confirm: "Confirmar",
    workgroup: "Grupo de Trabalho",
    period: "Periodo",
    dates: "Datas",
    "accumulated-in-day": "Acumulado no dia",
    data: "Dados",
    "not-found": "No Encontrado",
    settings: "Configuraes",
    home: "Incio",
    user: "Usurio",
    none: "Nenhum",
    "select-all": "Selecionar Tudo",
    "disposition-with": "Grupos com Disposio",
    "disposition-without": "Grupos sem Disposio",
    "disposition-groups": "Grupos de Disposies",
    tenant: "Inquilino",
    admin: "Administrador",
    calls: "Chamadas",
    "remember-me": "Lembrar-me",
    "sign-in": "Logar",
    viewer: "Visualizador",
    role: "Cargo",
    roles: "Cargos",
    attempt: "Tentativa",
    add: "Adicionar",
    adherence: "Aderncia",
    "file-type": "Tipo de Arquivo",
    file: "Arquivo",
    "contact-right-person": "Contatar a Pessoa Certa",
    error: "Erro",
    cancel: "Cancelar",
    "real-time": "Tempo Real",
    back: "Voltar",
    name: "Nome",
    email: "E-mail",
    group: "Grupo",
    password: "Senha",
    services: "Servios",
    visualization: "Visualizao",
    table: "Tabela",
    chart: "Grfico",
    continue: "Continuar",
    close: "Fechar",
    save: "Salvar",
    open: "Abrir",
    break: "Pausa",
    breaks: "Pausas",
    edit: "Editar",
    logout: "Sair",
    new: "Novo",
    agents: "Agentes",
    agent: "Agente",
    users: "Usurios",
    applications: "Aplicaes",
    general: "Geral",
    workgroups: "Grupos de Trabalho",
    scalesgroups: "Grupo de Escalas",
    scales: "Escalas",
    remove: "Remover",
    company: "Empresa",
    companies: "Empresas",
    database: "Banco de Dados",
    theme: "Tema",
    language: "Idioma",
    search: "Pesquisar",
    done: "Concludo",
    next: "Prximo",
    previous: "Anterior",
    loading: "Carregando",
    journey: "Jornada",
    action: "Ao",
    start: "Incio",
    entry: "Entrada",
    end: "Fim",
    finish: "Terminar",
    weekdays: "Dias da Semana",
    weekdaysNames: {
      sunday: "Domingo",
      monday: "Segunda-feira",
      tuesday: "Tera-feira",
      wednesday: "Quarta-feira",
      thursday: "Quinta-feira",
      friday: "Sexta-feira",
      saturday: "Sbado"
    },
    charts: {
      types: "Tipos de Grfico",
      bar: "Barra",
      line: "Linha",
      time: "Tempo"
    }
  },
  complement: {
    add: "Adicionar {{complement}}",
    select: "Selecionar {{complement}}",
    remove: "Remover {{complement}}",
    name: "Nome de {{complement}}",
    new: "Novo {{complement}}",
    edit: "Editar {{complement}}",
    open: "Abrir {{complement}}",
    close: "Fechar {{complement}}"
  },
  settings: {
    "application-title": "Selecione uma empresa e banco de dados",
    tabs: {
      personal: "Pessoal",
      application: "Aplicao"
    },
    themes: {
      coffe: "Caf",
      light: "Claro",
      dark: "Escuro",
      forest: "Floresta"
    },
    langs: {
      english: "Ingls",
      portuguese: "Portugus",
      spanish: "Espanhol"
    }
  },
  messages: {
    "not-found": "Nenhum(a) {{item}} foi encontrado(a)",
    typing: "Digite o seu {{item}}...",
    success: "{{item}} {{action}} realizado com sucesso",
    failed: "{{item}} {{action}} falhou"
  },
  table: {
    page: "Pgina",
    of: "de",
    "per-page": "Por pgina",
    items: "Itens"
  },
  picker: {
    date: {
      days: {
        su: "Dom",
        mo: "Seg",
        tu: "Ter",
        we: "Qua",
        th: "Qui",
        fr: "Sex",
        sa: "Sb"
      }
    }
  },
  select: {
    "select-one": "Selecione uma das opes"
  },
  sidebar: {
    general: "Geral",
    agents: "Agentes",
    other: "Outro",
    users: "Usurios",
    services: "Servios",
    calls: "Chamadas",
    "contact-right-person": "Contatar a Pessoa Certa",
    dashboard: "Painel",
    adherence: "Aderncia",
    "real-time": "Tempo Real",
    "disposition-groups": "Grupos de Disposio",
    workgroups: "Grupos de Trabalho",
    staffing: "Alocao de Pessoal",
    home: "Incio",
    scales: "Escalas",
    scalesgroups: "Grupos de Escalas",
    forecast: "Previso"
  },
  actions: {
    create: "criar",
    created: "criado",
    download: "baixar",
    downloaded: "baixado",
    update: "atualizar",
    updated: "atualizado",
    remove: "remover",
    removed: "removido"
  },
  conditions: {
    none: "Nenhum",
    greater: "Maior",
    greaterOrEqual: "Acima ou Igual",
    lesser: "Menor",
    lesserOrEqual: "Menor ou Igual",
    equal: "Equal",
    different: "Diferente"
  },
  data: {
    users: {
      firstName: "Primeiro Nome",
      lastName: "Sobrenome",
      email: "E-mail",
      role: "Cargo",
      active: "Ativo"
    },
    agents: {
      firstName: "Nome",
      name: "Nome",
      lastName: "Sobrenome",
      email: "Email",
      baseUserId: "Usurio Base"
    },
    workgroups: {
      name: "Nome",
      weekWorkDays: "Dias da Semana",
      agents: "Agentes",
      workGroups: "Grupos de Trabalho",
      timeScale: "Escala de Tempo",
      supervisor: "Supervisor"
    },
    scales: {
      firstName: "Primeiro Nome",
      lastName: "Sobrenome",
      baseUserId: "ID do Usurio Base"
    },
    scalesgroups: {
      name: "Nome",
      timeScale: "Escala de Tempo",
      workGroups: "Grupos de Trabalho",
      breaks: "Pausas"
    },
    services: {
      attempts: "Tentativas",
      hour: "Hora",
      answereds: "Atendidas",
      contact_right_person: "Contatar a Pessoa Certa",
      loggeds_agents: "Agentes Registrados",
      average_service_time: "Tempo Mdio de Atendimento",
      occupancyRate: "Taxa de Ocupao",
      productivityRate: "Taxa de Produtividade",
      availabilityFee: "Taxa de Disponibilidade",
      averageTimeLoggedIn: "Tempo Mdio Logado",
      averageTimeSpoken: "Tempo Mdio Falado",
      averageIdleTime: "Tempo Mdio de Inatividade",
      averageOperatingTime: "Tempo Mdio de Operao",
      hitRate: "Taxa de Acerto"
    },
    charts: {
      absenteeism: "Absentesmo",
      topAdherenceOffenders: "Principais Infratores de Adeso",
      totalOperationBreakWorkedTime: "Total de Pausa Trabalhada da Operao",
      totalOperationLoggedTime: "Total de Tempo Logado da Operao",
      totalOperationScaledTime: "Total de Tempo Escala da Operao",
      totalOperationBreakScaledTime: "Total de Pausa Escalada da Operao",
      mediumWorkGroupsAdherence: "Adeso Mdia dos Grupos de Trabalho",
      totalWorkGroupsExtraHours: "Total de Horas Extras dos Grupos de Trabalho",
      mediumWorkGroupsBreaksTimes: "Tempo Mdio de Pausas dos Grupos de Trabalho",
      mediumWorkGroupsLoggedTimes: "Tempo Mdio Logado dos Grupos de Trabalho"
    },
    "real-time": {
      serviceName: "Nome do Servio",
      serviceId: "ID do Servio",
      allAgentsLoggeds: "Agentes Logados",
      allAgentsInCall: "Agentes em Chamada",
      allAgentIdle: "Agentes Inativos",
      allAgentNotReady: "Agentes No Prontos",
      allAgentOthers: "Outros",
      occupancyRate: "Taxa de Ocupao",
      inHold: "Em Espera",
      inWrap: "Em Finalizao",
      date: "Data",
      totalCalls: "Total de Chamadas",
      answered: "Atendidas",
      answeredPercentage: "Percentual Atendido",
      notAnswered: "No Atendidas",
      notAnsweredPercentage: "Percentual No Atendido",
      busy: "Ocupadas",
      busyPercentage: "Percentual Ocupado",
      notAttend: "No Atendidas",
      notAttendPercentage: "Percentual No Atendido",
      message: "Mensagem",
      messagePercentage: "Percentual de Mensagens",
      cpc: "Contatar a Pessoa Certa"
    },
    adherence: {
      companyOperationBreakScaledTime: "Tempo Total de Pausa Escalada da Empresa",
      companyOperationBreakWorkedTime: "Tempo Total de Pausa Trabalhada da Empresa",
      companyOperationLoggedTime: "Tempo de Operao Ativa da Empresa",
      companyOperationScaledTime: "Tempo de Operao Escalada da Empresa",
      totalCompanyAdherence: "Total de Aderncia da Empresa",
      totalCompanyBreaksAdherence: "Total de Aderncia em Pausas da Empresa",
      groupName: "Nome do Grupo",
      agents: "Agentes",
      totalOperationLoggedTime: "Tempo Total Logado da Operao",
      totalOperationBreakWorkedTime: "Tempo Total de Pausa Trabalhada da Operao",
      totalOperationScaledTime: "Tempo Total Escalado da Operao",
      totalOperationBreakScaledTime: "Tempo Total de Pausa Escala da Operao",
      breakAdherence: "Pausa em Aderncia",
      adherence: "Aderncia"
    },
    "workgroup-adherence": {
      date: "Data",
      totalAgents: "Total de Agentes",
      averageServiceTime: "Tempo Mdio de Servio",
      occupancyRate: "Taxa de Ocupao",
      productivityRate: "Taxa de Produtividade",
      availabilityFee: "Taxa de Disponibilidade",
      averageTimeLoggedIn: "Tempo Mdio Logado",
      averageTimeSpoken: "Tempo Mdio Falado",
      averageIdleTime: "Tempo Mdio de Inatividade",
      averageRestBreak: "Tempo Mdio de Descanso",
      mediumBreakSnackOrLunch: "Intervalo Mdio (Lanche ou Almoo)",
      averageTrainingBreak: "Intervalo Mdio de Treinamento",
      averageFeedbackBreak: "Intervalo Mdio de Feedback",
      answereds: "Atendimentos",
      contactRightPerson: "Contato com a Pessoa Certa",
      notContactRightPerson: "No Contato com a Pessoa Certa",
      errands: "Tarefas",
      errandsPerContactRightPerson: "Tarefas por Contato com a Pessoa Certa",
      contactRightPersonPerAnswereds: "Contato com a Pessoa Certa por Atendimentos",
      percentageIdleTime: "Percentual de Tempo Inativo"
    },
    forecast: {
      hour: "Hora",
      answereds: "Respostas",
      attempts: "Tentativas",
      hitRate: "Percentual De Acerto",
      averageServiceTime: "Tempo mdio de Servio",
      contactRightPerson: "Contatar Pessoa Certa",
      contactRightPersonRatePerTotal: "Percentual Total de Contatar Pessoa Certa",
      contactRightPersonRatePerAnswered: "Percentual por Resposta de Contatar Pessoa Certa",
      loggedsAgents: "Agentes Logados"
    }
  }
}, hE = ({ language: s = "en" }) => {
  Da.init({
    lng: s,
    fallbackLng: "en",
    resources: {
      en: { translation: uP },
      "pt-BR": { translation: dP },
      es: { translation: cP }
    }
  });
}, fP = (s) => {
  lP(s);
}, hP = (s, u, h, m, w, T) => {
  u = u - 16;
  const A = u / m, F = [];
  return Object.values(s).forEach((H) => {
    let j = "";
    H.forEach((V, q) => {
      q === 0 && (T ? j += `M-4,${u + 50}L-4,${u - V * A}` : j += `M0,${u - V * A}`), q > 0 && (j += `L${w * q},${u - V * A}`), q === H.length - 1 && (j += `L${h + 4},${u + 50}`);
    }), F.push(j);
  }), F;
}, pP = ({
  data: s,
  width: u,
  height: h,
  filled: m = !1,
  tooltipRef: w,
  translation: T,
  maxItemValue: A,
  lineRef: F
}) => {
  if (u === 0 || h === 0 || s.length === 0)
    return null;
  const H = Object.keys(s[0]).length, j = u / (s.length - 1) + 1, V = s.reduce(
    (te, ae) => (Object.entries(ae).forEach(
      ([se, ue]) => {
        te != null && te[se] ? te[se].push(ue) : te[se] = [ue];
      }
    ), te),
    {}
  ), q = hP(
    V,
    h,
    u,
    A,
    j,
    m
  );
  return /* @__PURE__ */ ce.jsx(ce.Fragment, { children: q == null ? void 0 : q.map((te, ae) => /* @__PURE__ */ ce.jsxs("g", { children: [
    /* @__PURE__ */ ce.jsx(
      "path",
      {
        className: m ? "filled" : "",
        d: te,
        strokeWidth: "3",
        fill: m ? "currentColor" : "none",
        strokeLinejoin: "round",
        strokeLinecap: "round",
        onMouseMove: (se) => {
          const ue = se.clientX;
          if (F.current) {
            const Ce = F.current.parentNode.getBoundingClientRect().left, K = Array.from({ length: H }).map(
              (Ee, re) => j * re
            ).map(
              (Ee) => Math.abs(ue - Ce - Ee)
            ), we = K.indexOf(
              Math.min(...K)
            );
            if (w.current) {
              const Ee = Object.entries(
                s[we] ?? []
              ).reduce((re, me) => (re += `<span>${nr(
                `data.${T}.${me[0]}`
              )}: ${me[1]}</span>`, re), "");
              w.current.innerHTML = `
                       ${Ee}
                    `;
            }
          }
        }
      }
    ),
    m && /* @__PURE__ */ ce.jsxs("linearGradient", { id: `lgrad-${ae}`, gradientTransform: "rotate(90)", children: [
      /* @__PURE__ */ ce.jsx("stop", { offset: "0%", stopColor: "#4169e1" }),
      /* @__PURE__ */ ce.jsx("stop", { offset: "75%", stopColor: "#c44764" })
    ] })
  ] }, ae)) });
}, gP = ({
  label: s,
  onMouseEnter: u,
  x: h,
  y: m,
  height: w,
  width: T,
  ...A
}) => {
  if (A.value === 0)
    return null;
  const F = String(A.value).length * 4, H = T / 2 - F;
  return /* @__PURE__ */ ce.jsxs(
    "g",
    {
      onMouseEnter: () => u == null ? void 0 : u({
        label: s,
        value: Number(A.value)
      }),
      onMouseMove: (j) => {
        var V;
        return (V = A.onMouseMove) == null ? void 0 : V.call(A, { x: j.clientX, y: j.clientY });
      },
      children: [
        /* @__PURE__ */ ce.jsx("text", { x: h + H, y: m - 5, children: A.value }),
        /* @__PURE__ */ ce.jsx("rect", { x: h, y: m, height: w, width: T, rx: 4 })
      ]
    }
  );
}, mP = ({
  width: s,
  height: u,
  data: h,
  showOnly: m,
  tooltipRef: w,
  groupBy: T,
  translation: A,
  maxItemValue: F
}) => {
  if (console.log(h), s === 0 || u === 0 || h.length === 0)
    return null;
  m && (h = h.map((q) => ({
    [T]: q[T],
    [m]: q[m]
  })));
  const H = Object.keys(h[0]).length;
  let j = 24, V = (s - j * (h.length - 1)) / h.length;
  return m ? j = 24 : (j = 0, V = (s - j * (h.length - 1) * (H - 1)) / h.length / H), console.log(h, V, H), /* @__PURE__ */ ce.jsx(ce.Fragment, { children: h.map((q, te) => {
    const ae = (u - 40) / F, se = { ...q };
    delete se[T];
    let ue = 1, Pe = te * ue * H * ((V + j) / (H - 1)), K = te > 0 ? Pe / 2 : Pe;
    K += String(q[T]).length * 6;
    const we = (V + j) * H;
    let Ee = 0;
    if (!m) {
      const re = (s - j * (h.length - 1)) / h.length;
      K = re * te + re / 2 - String(q[T]).length * 8;
    }
    return console.log(nr("data.workgroups.name")), /* @__PURE__ */ ce.jsxs("g", { children: [
      Object.entries(se).map(([re, me]) => {
        const Me = Ee;
        if (me === 0)
          return null;
        Pe = Me * H * ((V + j * (H - 1)) / (H - 1)), Pe = Pe + te * we, m && (Pe /= 2);
        const Ve = Number(me) * ae;
        return ue += 1, Ee += 1, /* @__PURE__ */ ce.jsx(
          gP,
          {
            x: Pe + 16,
            value: Number(me),
            y: u - 20 - Ve,
            onMouseEnter: ({ label: Xe, value: it }) => {
              w.current && (w.current.innerHTML = `
                         <span>${Xe}: ${it}</span>
                    `);
            },
            itemIndex: te,
            width: V,
            height: Ve,
            label: nr(
              `data.${A}.${re}`
            )
          },
          `${re}-${te}`
        );
      }),
      /* @__PURE__ */ ce.jsx(
        "text",
        {
          y: u - 4,
          x: K + (V - j - V * (H - 3) - String(q[T]).length * 8) / 2 + 16,
          children: q[T]
        }
      )
    ] }, te);
  }) });
}, vP = ({
  tooltipRef: s,
  width: u,
  maxDate: h,
  minDate: m,
  labels: w,
  spacing: T,
  iteration: A,
  rectHeight: F,
  proportion: H,
  theme: j,
  items: V,
  translation: q
}) => {
  const te = mr(null);
  return /* @__PURE__ */ ce.jsxs(
    "g",
    {
      onMouseMove: (ae) => {
        if (ae.target === te.current && s.current) {
          const ue = ae.nativeEvent.offsetX / u * h.diff(m), Ce = m.clone().add(ue, "milliseconds"), K = h.diff(m) / 3600 / 1e3 > 24 ? "YYYY-MM-DD HH:mm:ss" : "HH:mm:ss";
          s.current.innerHTML = `
              ${Ce.format(K)}
          `;
        }
      },
      children: [
        (w == null ? void 0 : w.length) && (w == null ? void 0 : w.length) > 0 && /* @__PURE__ */ ce.jsx(
          "text",
          {
            x: T / 2 - w[A].length * 4,
            y: F / 2 + F * A + 4 + 20,
            children: w[A]
          }
        ),
        /* @__PURE__ */ ce.jsx(
          "rect",
          {
            rx: 4,
            x: T,
            y: F * A + 20,
            ref: te,
            width: h.diff(m) * H,
            height: F,
            className: j == null ? void 0 : j.period
          }
        ),
        Object.values(V).map(
          (ae, se) => ae.map((ue, Ce) => {
            if (Object.keys(V)[se] === "period")
              return null;
            const Pe = ue.start.diff(m) * H, K = ue.finish.diff(ue.start), we = K * H, Ee = Object.keys(V)[se];
            let re = K / 3600 / 1e3 < 1 ? tr.utc(K).format("mm[m]") : tr.utc(K).format("HH[h]mm");
            re = re.substring(re.length - 2, re.length) === "00" ? re.substring(0, re.length - 2) : re;
            const me = (re.length + 0.5) * 4;
            return /* @__PURE__ */ ce.jsxs(
              "g",
              {
                y: 20,
                onMouseMove: (Me) => {
                  const Ve = Me.nativeEvent.offsetX / u * h.diff(m), Xe = m.clone().add(Ve, "milliseconds"), ht = h.diff(m) / 3600 / 1e3 > 24 ? "YYYY-MM-DD HH:mm:ss" : "HH:mm:ss";
                  s.current && (s.current.innerHTML = `
                  <span>${q(Ee)}</span>
                  <span>
                  ${Xe.format(ht)} |
                    ${tr.utc(ue.start).format("HH[h]mm")} -
                    ${tr.utc(ue.finish).format("HH[h]mm")}
                  </span>
                  <span>
                    Escalado: ${tr.utc(ue == null ? void 0 : ue.scaled).format("HH[h]mm")}
                  </span>
                  <span>
                    Durao: ${re}
                 </span>
              `);
                },
                children: [
                  /* @__PURE__ */ ce.jsx(
                    "rect",
                    {
                      className: (j == null ? void 0 : j[Object.keys(V)[se]]) ?? "fill-text-disabled",
                      width: we,
                      rx: 4,
                      x: Pe + T,
                      height: F,
                      y: F * A + 20,
                      fill: "currentColor"
                    }
                  ),
                  me < we / 2 && /* @__PURE__ */ ce.jsx(
                    "text",
                    {
                      x: Pe + we / 2 - me + T,
                      y: F * A + F / 2 + 26,
                      children: re
                    }
                  )
                ]
              },
              Ce
            );
          })
        )
      ]
    }
  );
}, yP = ({
  data: s,
  width: u,
  height: h,
  labels: m,
  tooltipRef: w,
  translation: T,
  theme: A
}) => {
  if (u === 0 || h === 0 || s.length === 0)
    return null;
  const F = m != null && m.length && (m == null ? void 0 : m.length) > 0 ? 80 : 0;
  u = u - F, h = h - 20;
  const H = h / s.length;
  let j = tr(), V = tr();
  s.forEach((ue) => {
    Object.values(ue).forEach((Ce) => {
      Ce.forEach((Pe) => {
        j = tr.min(j, Pe.start), V = tr.max(V, Pe.finish);
      });
    });
  });
  const q = V.diff(j), te = u / q, ae = tr.duration(q, "milliseconds").hours(), se = u / ae / 4;
  return /* @__PURE__ */ ce.jsxs(ce.Fragment, { children: [
    s.map((ue, Ce) => /* @__PURE__ */ ce.jsx(cE, { children: /* @__PURE__ */ ce.jsx(
      vP,
      {
        width: u + F,
        labels: m,
        items: ue,
        maxDate: V,
        minDate: j,
        spacing: F,
        iteration: Ce,
        proportion: te,
        rectHeight: H,
        translation: T,
        tooltipRef: w,
        theme: A
      }
    ) }, Ce)),
    Array.from({ length: ae * 4 }).map((ue, Ce) => /* @__PURE__ */ ce.jsx("g", { className: "interval", children: /* @__PURE__ */ ce.jsx(
      "line",
      {
        x1: se * Ce + 80,
        x2: se * Ce + 80,
        y1: 20,
        y2: h + 20
      }
    ) }, Ce)),
    Array.from({ length: ae + 1 }).map((ue, Ce) => {
      const Pe = tr.utc(j).hours() + Ce;
      return /* @__PURE__ */ ce.jsxs(
        "text",
        {
          x: se * 4 * Ce + F - String(Pe).length * 8,
          y: 12,
          fill: "#fff",
          children: [
            Pe,
            "h"
          ]
        },
        Ce
      );
    })
  ] });
};
function xP(s, u = 300) {
  let h;
  return function(...m) {
    clearTimeout(h), h = setTimeout(() => {
      s.apply(this, m);
    }, u);
  };
}
const Yw = (s, u, h, m = !1) => {
  var A, F, H, j;
  const w = s.clientWidth, T = s.clientHeight;
  if ((A = u.current) == null || A.setAttribute("viewBox", `0 0 ${w} ${T}`), (F = u.current) == null || F.setAttribute("width", String(w)), !m) {
    (H = u.current) == null || H.setAttribute("height", String(T)), h({
      height: T,
      width: w
    });
    return;
  }
  (j = u.current) == null || j.setAttribute("height", String(T)), h((V) => ({
    ...V,
    width: w
  }));
}, bP = ({
  type: s,
  width: u,
  height: h,
  hide: m,
  data: w,
  children: T,
  translation: A = "workgroups",
  snap: F = !1
}) => {
  const H = mr(null), [j, V] = fr({
    width: u !== void 0 ? u - 32 : 0,
    height: h ?? 0
  }), q = mr(null), te = mr(null), ae = Du(() => m ? [...w].filter((ue) => (m.forEach((Ce) => delete ue[Ce]), ue)) : w, [m, w]);
  console.log(j), Hf(() => {
    var Ce;
    const ue = (Ce = H == null ? void 0 : H.current) == null ? void 0 : Ce.parentNode;
    return window == null || window.addEventListener(
      "resize",
      xP(
        () => Yw(ue, H, V, h !== void 0)
      )
    ), (!u || !h) && Yw(ue, H, V, h !== void 0), () => ue == null ? void 0 : ue.removeEventListener(
      "resize",
      () => Yw(ue, H, () => {
      }, h !== void 0)
    );
  }, [V, u, h]);
  const se = Math.max(
    ...ae().map((ue) => {
      const Ce = Object.values(ue).filter(
        (Pe) => typeof Pe == "number"
      );
      return Math.max(...Ce);
    })
  );
  return /* @__PURE__ */ ce.jsxs(ce.Fragment, { children: [
    /* @__PURE__ */ ce.jsx(
      "div",
      {
        ref: q,
        className: "chart-tooltip container rounded-box bg-neutral shadow-md gap-sm"
      }
    ),
    /* @__PURE__ */ ce.jsxs(
      "svg",
      {
        ref: H,
        className: `chart ${s}`,
        viewBox: `0 0 ${u ?? 0} ${h ?? 0}`,
        width: j.width,
        height: j.height,
        onMouseMove: (ue) => {
          if (te.current && H.current && q.current) {
            const Ce = te.current.style, Pe = ue.clientX, K = H.current.getBoundingClientRect().left, we = H.current.getBoundingClientRect().top;
            if (Ce.opacity = "1", F) {
              const Je = j.width / (w.length * 4), Ve = Array.from({
                length: w.length
              }).map((ht, Ke) => Math.abs(
                Pe - K - Je * Ke - j.width / w.length * Ke
              )), Xe = Ve.indexOf(
                Math.min(...Ve)
              ), it = j.width / w.length * Xe + Je * Xe;
              Ce.transform = `translate(${it}px, 0px)`;
            } else
              Ce.transform = `translate(${ue.clientX - K}px, 0px)`, Ce.transition = "none";
            if (q.current.innerHTML === "") {
              q.current.style.opacity = "0";
              return;
            }
            const Ee = ue.clientX - K, re = q.current.clientWidth;
            q.current.style.opacity = "1";
            let me = Ee + 20;
            const Me = ue.clientY - we + 20;
            q.current.offsetLeft + Ee + re + 20 > window.innerWidth && (me = Ee - re - 20), q.current.style.transform = `translate(${me}px, ${Me}px)`;
          }
        },
        onMouseLeave: () => {
          q.current && te.current && (q.current.innerHTML = "", q.current.style.opacity = "0", te.current.style.opacity = "0");
        },
        children: [
          T({
            currentSize: j,
            tooltipRef: q,
            data: ae(),
            maxItemValue: se,
            lineRef: te,
            translation: A
          }),
          /* @__PURE__ */ ce.jsx(
            "line",
            {
              ref: te,
              x1: "0",
              y1: "0",
              x2: "0",
              y2: h,
              strokeDasharray: 8,
              style: { stroke: "#ded", strokeWidth: "2px" }
            }
          )
        ]
      }
    )
  ] });
}, Wj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bar: mP,
  Line: pP,
  Time: yP,
  default: bP
}, Symbol.toStringTag, { value: "Module" }));
var Mu = va;
const og = /^[a-z0-9]+(-[a-z0-9]+)*$/, $y = (s, u, h, m = "") => {
  const w = s.split(":");
  if (s.slice(0, 1) === "@") {
    if (w.length < 2 || w.length > 3)
      return null;
    m = w.shift().slice(1);
  }
  if (w.length > 3 || !w.length)
    return null;
  if (w.length > 1) {
    const F = w.pop(), H = w.pop(), j = {
      // Allow provider without '@': "provider:prefix:name"
      provider: w.length > 0 ? w[0] : m,
      prefix: H,
      name: F
    };
    return u && !Ay(j) ? null : j;
  }
  const T = w[0], A = T.split("-");
  if (A.length > 1) {
    const F = {
      provider: m,
      prefix: A.shift(),
      name: A.join("-")
    };
    return u && !Ay(F) ? null : F;
  }
  if (h && m === "") {
    const F = {
      provider: m,
      prefix: "",
      name: T
    };
    return u && !Ay(F, h) ? null : F;
  }
  return null;
}, Ay = (s, u) => s ? !!((s.provider === "" || s.provider.match(og)) && (u && s.prefix === "" || s.prefix.match(og)) && s.name.match(og)) : !1, pE = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), Fy = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), P1 = Object.freeze({
  ...pE,
  ...Fy
}), l1 = Object.freeze({
  ...P1,
  body: "",
  hidden: !1
});
function wP(s, u) {
  const h = {};
  !s.hFlip != !u.hFlip && (h.hFlip = !0), !s.vFlip != !u.vFlip && (h.vFlip = !0);
  const m = ((s.rotate || 0) + (u.rotate || 0)) % 4;
  return m && (h.rotate = m), h;
}
function lA(s, u) {
  const h = wP(s, u);
  for (const m in l1)
    m in Fy ? m in s && !(m in h) && (h[m] = Fy[m]) : m in u ? h[m] = u[m] : m in s && (h[m] = s[m]);
  return h;
}
function SP(s, u) {
  const h = s.icons, m = s.aliases || /* @__PURE__ */ Object.create(null), w = /* @__PURE__ */ Object.create(null);
  function T(A) {
    if (h[A])
      return w[A] = [];
    if (!(A in w)) {
      w[A] = null;
      const F = m[A] && m[A].parent, H = F && T(F);
      H && (w[A] = [F].concat(H));
    }
    return w[A];
  }
  return (u || Object.keys(h).concat(Object.keys(m))).forEach(T), w;
}
function kP(s, u, h) {
  const m = s.icons, w = s.aliases || /* @__PURE__ */ Object.create(null);
  let T = {};
  function A(F) {
    T = lA(
      m[F] || w[F],
      T
    );
  }
  return A(u), h.forEach(A), lA(s, T);
}
function gE(s, u) {
  const h = [];
  if (typeof s != "object" || typeof s.icons != "object")
    return h;
  s.not_found instanceof Array && s.not_found.forEach((w) => {
    u(w, null), h.push(w);
  });
  const m = SP(s);
  for (const w in m) {
    const T = m[w];
    T && (u(w, kP(s, w, T)), h.push(w));
  }
  return h;
}
const CP = {
  provider: "",
  aliases: {},
  not_found: {},
  ...pE
};
function Hw(s, u) {
  for (const h in u)
    if (h in s && typeof s[h] != typeof u[h])
      return !1;
  return !0;
}
function mE(s) {
  if (typeof s != "object" || s === null)
    return null;
  const u = s;
  if (typeof u.prefix != "string" || !s.icons || typeof s.icons != "object" || !Hw(s, CP))
    return null;
  const h = u.icons;
  for (const w in h) {
    const T = h[w];
    if (!w.match(og) || typeof T.body != "string" || !Hw(
      T,
      l1
    ))
      return null;
  }
  const m = u.aliases || /* @__PURE__ */ Object.create(null);
  for (const w in m) {
    const T = m[w], A = T.parent;
    if (!w.match(og) || typeof A != "string" || !h[A] && !m[A] || !Hw(
      T,
      l1
    ))
      return null;
  }
  return u;
}
const uA = /* @__PURE__ */ Object.create(null);
function TP(s, u) {
  return {
    provider: s,
    prefix: u,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function Hc(s, u) {
  const h = uA[s] || (uA[s] = /* @__PURE__ */ Object.create(null));
  return h[u] || (h[u] = TP(s, u));
}
function N1(s, u) {
  return mE(u) ? gE(u, (h, m) => {
    m ? s.icons[h] = m : s.missing.add(h);
  }) : [];
}
function AP(s, u, h) {
  try {
    if (typeof h.body == "string")
      return s.icons[u] = { ...h }, !0;
  } catch {
  }
  return !1;
}
let pg = !1;
function vE(s) {
  return typeof s == "boolean" && (pg = s), pg;
}
function EP(s) {
  const u = typeof s == "string" ? $y(s, !0, pg) : s;
  if (u) {
    const h = Hc(u.provider, u.prefix), m = u.name;
    return h.icons[m] || (h.missing.has(m) ? null : void 0);
  }
}
function RP(s, u) {
  const h = $y(s, !0, pg);
  if (!h)
    return !1;
  const m = Hc(h.provider, h.prefix);
  return AP(m, h.name, u);
}
function LP(s, u) {
  if (typeof s != "object")
    return !1;
  if (typeof u != "string" && (u = s.provider || ""), pg && !u && !s.prefix) {
    let w = !1;
    return mE(s) && (s.prefix = "", gE(s, (T, A) => {
      A && RP(T, A) && (w = !0);
    })), w;
  }
  const h = s.prefix;
  if (!Ay({
    provider: u,
    prefix: h,
    name: "a"
  }))
    return !1;
  const m = Hc(u, h);
  return !!N1(m, s);
}
const yE = Object.freeze({
  width: null,
  height: null
}), xE = Object.freeze({
  // Dimensions
  ...yE,
  // Transformations
  ...Fy
}), OP = /(-?[0-9.]*[0-9]+[0-9.]*)/g, DP = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function cA(s, u, h) {
  if (u === 1)
    return s;
  if (h = h || 100, typeof s == "number")
    return Math.ceil(s * u * h) / h;
  if (typeof s != "string")
    return s;
  const m = s.split(OP);
  if (m === null || !m.length)
    return s;
  const w = [];
  let T = m.shift(), A = DP.test(T);
  for (; ; ) {
    if (A) {
      const F = parseFloat(T);
      isNaN(F) ? w.push(T) : w.push(Math.ceil(F * u * h) / h);
    } else
      w.push(T);
    if (T = m.shift(), T === void 0)
      return w.join("");
    A = !A;
  }
}
const MP = (s) => s === "unset" || s === "undefined" || s === "none";
function _P(s, u) {
  const h = {
    ...P1,
    ...s
  }, m = {
    ...xE,
    ...u
  }, w = {
    left: h.left,
    top: h.top,
    width: h.width,
    height: h.height
  };
  let T = h.body;
  [h, m].forEach((se) => {
    const ue = [], Ce = se.hFlip, Pe = se.vFlip;
    let K = se.rotate;
    Ce ? Pe ? K += 2 : (ue.push(
      "translate(" + (w.width + w.left).toString() + " " + (0 - w.top).toString() + ")"
    ), ue.push("scale(-1 1)"), w.top = w.left = 0) : Pe && (ue.push(
      "translate(" + (0 - w.left).toString() + " " + (w.height + w.top).toString() + ")"
    ), ue.push("scale(1 -1)"), w.top = w.left = 0);
    let we;
    switch (K < 0 && (K -= Math.floor(K / 4) * 4), K = K % 4, K) {
      case 1:
        we = w.height / 2 + w.top, ue.unshift(
          "rotate(90 " + we.toString() + " " + we.toString() + ")"
        );
        break;
      case 2:
        ue.unshift(
          "rotate(180 " + (w.width / 2 + w.left).toString() + " " + (w.height / 2 + w.top).toString() + ")"
        );
        break;
      case 3:
        we = w.width / 2 + w.left, ue.unshift(
          "rotate(-90 " + we.toString() + " " + we.toString() + ")"
        );
        break;
    }
    K % 2 === 1 && (w.left !== w.top && (we = w.left, w.left = w.top, w.top = we), w.width !== w.height && (we = w.width, w.width = w.height, w.height = we)), ue.length && (T = '<g transform="' + ue.join(" ") + '">' + T + "</g>");
  });
  const A = m.width, F = m.height, H = w.width, j = w.height;
  let V, q;
  A === null ? (q = F === null ? "1em" : F === "auto" ? j : F, V = cA(q, H / j)) : (V = A === "auto" ? H : A, q = F === null ? cA(V, j / H) : F === "auto" ? j : F);
  const te = {}, ae = (se, ue) => {
    MP(ue) || (te[se] = ue.toString());
  };
  return ae("width", V), ae("height", q), te.viewBox = w.left.toString() + " " + w.top.toString() + " " + H.toString() + " " + j.toString(), {
    attributes: te,
    body: T
  };
}
const PP = /\sid="(\S+)"/g, NP = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let zP = 0;
function IP(s, u = NP) {
  const h = [];
  let m;
  for (; m = PP.exec(s); )
    h.push(m[1]);
  if (!h.length)
    return s;
  const w = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return h.forEach((T) => {
    const A = typeof u == "function" ? u(T) : u + (zP++).toString(), F = T.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    s = s.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + F + ')([")]|\\.[a-z])', "g"),
      "$1" + A + w + "$3"
    );
  }), s = s.replace(new RegExp(w, "g"), ""), s;
}
const u1 = /* @__PURE__ */ Object.create(null);
function FP(s, u) {
  u1[s] = u;
}
function c1(s) {
  return u1[s] || u1[""];
}
function z1(s) {
  let u;
  if (typeof s.resources == "string")
    u = [s.resources];
  else if (u = s.resources, !(u instanceof Array) || !u.length)
    return null;
  return {
    // API hosts
    resources: u,
    // Root path
    path: s.path || "/",
    // URL length limit
    maxURL: s.maxURL || 500,
    // Timeout before next host is used.
    rotate: s.rotate || 750,
    // Timeout before failing query.
    timeout: s.timeout || 5e3,
    // Randomise default API end point.
    random: s.random === !0,
    // Start index
    index: s.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: s.dataAfterTimeout !== !1
  };
}
const I1 = /* @__PURE__ */ Object.create(null), ng = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], Ey = [];
for (; ng.length > 0; )
  ng.length === 1 || Math.random() > 0.5 ? Ey.push(ng.shift()) : Ey.push(ng.pop());
I1[""] = z1({
  resources: ["https://api.iconify.design"].concat(Ey)
});
function YP(s, u) {
  const h = z1(u);
  return h === null ? !1 : (I1[s] = h, !0);
}
function F1(s) {
  return I1[s];
}
const HP = () => {
  let s;
  try {
    if (s = fetch, typeof s == "function")
      return s;
  } catch {
  }
};
let dA = HP();
function jP(s, u) {
  const h = F1(s);
  if (!h)
    return 0;
  let m;
  if (!h.maxURL)
    m = 0;
  else {
    let w = 0;
    h.resources.forEach((A) => {
      w = Math.max(w, A.length);
    });
    const T = u + ".json?icons=";
    m = h.maxURL - w - h.path.length - T.length;
  }
  return m;
}
function BP(s) {
  return s === 404;
}
const WP = (s, u, h) => {
  const m = [], w = jP(s, u), T = "icons";
  let A = {
    type: T,
    provider: s,
    prefix: u,
    icons: []
  }, F = 0;
  return h.forEach((H, j) => {
    F += H.length + 1, F >= w && j > 0 && (m.push(A), A = {
      type: T,
      provider: s,
      prefix: u,
      icons: []
    }, F = H.length), A.icons.push(H);
  }), m.push(A), m;
};
function UP(s) {
  if (typeof s == "string") {
    const u = F1(s);
    if (u)
      return u.path;
  }
  return "/";
}
const XP = (s, u, h) => {
  if (!dA) {
    h("abort", 424);
    return;
  }
  let m = UP(u.provider);
  switch (u.type) {
    case "icons": {
      const T = u.prefix, F = u.icons.join(","), H = new URLSearchParams({
        icons: F
      });
      m += T + ".json?" + H.toString();
      break;
    }
    case "custom": {
      const T = u.uri;
      m += T.slice(0, 1) === "/" ? T.slice(1) : T;
      break;
    }
    default:
      h("abort", 400);
      return;
  }
  let w = 503;
  dA(s + m).then((T) => {
    const A = T.status;
    if (A !== 200) {
      setTimeout(() => {
        h(BP(A) ? "abort" : "next", A);
      });
      return;
    }
    return w = 501, T.json();
  }).then((T) => {
    if (typeof T != "object" || T === null) {
      setTimeout(() => {
        T === 404 ? h("abort", T) : h("next", w);
      });
      return;
    }
    setTimeout(() => {
      h("success", T);
    });
  }).catch(() => {
    h("next", w);
  });
}, VP = {
  prepare: WP,
  send: XP
};
function GP(s) {
  const u = {
    loaded: [],
    missing: [],
    pending: []
  }, h = /* @__PURE__ */ Object.create(null);
  s.sort((w, T) => w.provider !== T.provider ? w.provider.localeCompare(T.provider) : w.prefix !== T.prefix ? w.prefix.localeCompare(T.prefix) : w.name.localeCompare(T.name));
  let m = {
    provider: "",
    prefix: "",
    name: ""
  };
  return s.forEach((w) => {
    if (m.name === w.name && m.prefix === w.prefix && m.provider === w.provider)
      return;
    m = w;
    const T = w.provider, A = w.prefix, F = w.name, H = h[T] || (h[T] = /* @__PURE__ */ Object.create(null)), j = H[A] || (H[A] = Hc(T, A));
    let V;
    F in j.icons ? V = u.loaded : A === "" || j.missing.has(F) ? V = u.missing : V = u.pending;
    const q = {
      provider: T,
      prefix: A,
      name: F
    };
    V.push(q);
  }), u;
}
function bE(s, u) {
  s.forEach((h) => {
    const m = h.loaderCallbacks;
    m && (h.loaderCallbacks = m.filter((w) => w.id !== u));
  });
}
function $P(s) {
  s.pendingCallbacksFlag || (s.pendingCallbacksFlag = !0, setTimeout(() => {
    s.pendingCallbacksFlag = !1;
    const u = s.loaderCallbacks ? s.loaderCallbacks.slice(0) : [];
    if (!u.length)
      return;
    let h = !1;
    const m = s.provider, w = s.prefix;
    u.forEach((T) => {
      const A = T.icons, F = A.pending.length;
      A.pending = A.pending.filter((H) => {
        if (H.prefix !== w)
          return !0;
        const j = H.name;
        if (s.icons[j])
          A.loaded.push({
            provider: m,
            prefix: w,
            name: j
          });
        else if (s.missing.has(j))
          A.missing.push({
            provider: m,
            prefix: w,
            name: j
          });
        else
          return h = !0, !0;
        return !1;
      }), A.pending.length !== F && (h || bE([s], T.id), T.callback(
        A.loaded.slice(0),
        A.missing.slice(0),
        A.pending.slice(0),
        T.abort
      ));
    });
  }));
}
let qP = 0;
function ZP(s, u, h) {
  const m = qP++, w = bE.bind(null, h, m);
  if (!u.pending.length)
    return w;
  const T = {
    id: m,
    icons: u,
    callback: s,
    abort: w
  };
  return h.forEach((A) => {
    (A.loaderCallbacks || (A.loaderCallbacks = [])).push(T);
  }), w;
}
function QP(s, u = !0, h = !1) {
  const m = [];
  return s.forEach((w) => {
    const T = typeof w == "string" ? $y(w, u, h) : w;
    T && m.push(T);
  }), m;
}
var KP = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function JP(s, u, h, m) {
  const w = s.resources.length, T = s.random ? Math.floor(Math.random() * w) : s.index;
  let A;
  if (s.random) {
    let me = s.resources.slice(0);
    for (A = []; me.length > 1; ) {
      const Me = Math.floor(Math.random() * me.length);
      A.push(me[Me]), me = me.slice(0, Me).concat(me.slice(Me + 1));
    }
    A = A.concat(me);
  } else
    A = s.resources.slice(T).concat(s.resources.slice(0, T));
  const F = Date.now();
  let H = "pending", j = 0, V, q = null, te = [], ae = [];
  typeof m == "function" && ae.push(m);
  function se() {
    q && (clearTimeout(q), q = null);
  }
  function ue() {
    H === "pending" && (H = "aborted"), se(), te.forEach((me) => {
      me.status === "pending" && (me.status = "aborted");
    }), te = [];
  }
  function Ce(me, Me) {
    Me && (ae = []), typeof me == "function" && ae.push(me);
  }
  function Pe() {
    return {
      startTime: F,
      payload: u,
      status: H,
      queriesSent: j,
      queriesPending: te.length,
      subscribe: Ce,
      abort: ue
    };
  }
  function K() {
    H = "failed", ae.forEach((me) => {
      me(void 0, V);
    });
  }
  function we() {
    te.forEach((me) => {
      me.status === "pending" && (me.status = "aborted");
    }), te = [];
  }
  function Ee(me, Me, Je) {
    const Ve = Me !== "success";
    switch (te = te.filter((Xe) => Xe !== me), H) {
      case "pending":
        break;
      case "failed":
        if (Ve || !s.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (Me === "abort") {
      V = Je, K();
      return;
    }
    if (Ve) {
      V = Je, te.length || (A.length ? re() : K());
      return;
    }
    if (se(), we(), !s.random) {
      const Xe = s.resources.indexOf(me.resource);
      Xe !== -1 && Xe !== s.index && (s.index = Xe);
    }
    H = "completed", ae.forEach((Xe) => {
      Xe(Je);
    });
  }
  function re() {
    if (H !== "pending")
      return;
    se();
    const me = A.shift();
    if (me === void 0) {
      if (te.length) {
        q = setTimeout(() => {
          se(), H === "pending" && (we(), K());
        }, s.timeout);
        return;
      }
      K();
      return;
    }
    const Me = {
      status: "pending",
      resource: me,
      callback: (Je, Ve) => {
        Ee(Me, Je, Ve);
      }
    };
    te.push(Me), j++, q = setTimeout(re, s.rotate), h(me, u, Me.callback);
  }
  return setTimeout(re), Pe;
}
function wE(s) {
  const u = {
    ...KP,
    ...s
  };
  let h = [];
  function m() {
    h = h.filter((F) => F().status === "pending");
  }
  function w(F, H, j) {
    const V = JP(
      u,
      F,
      H,
      (q, te) => {
        m(), j && j(q, te);
      }
    );
    return h.push(V), V;
  }
  function T(F) {
    return h.find((H) => F(H)) || null;
  }
  return {
    query: w,
    find: T,
    setIndex: (F) => {
      u.index = F;
    },
    getIndex: () => u.index,
    cleanup: m
  };
}
function fA() {
}
const jw = /* @__PURE__ */ Object.create(null);
function eN(s) {
  if (!jw[s]) {
    const u = F1(s);
    if (!u)
      return;
    const h = wE(u), m = {
      config: u,
      redundancy: h
    };
    jw[s] = m;
  }
  return jw[s];
}
function tN(s, u, h) {
  let m, w;
  if (typeof s == "string") {
    const T = c1(s);
    if (!T)
      return h(void 0, 424), fA;
    w = T.send;
    const A = eN(s);
    A && (m = A.redundancy);
  } else {
    const T = z1(s);
    if (T) {
      m = wE(T);
      const A = s.resources ? s.resources[0] : "", F = c1(A);
      F && (w = F.send);
    }
  }
  return !m || !w ? (h(void 0, 424), fA) : m.query(u, w, h)().abort;
}
const hA = "iconify2", gg = "iconify", SE = gg + "-count", pA = gg + "-version", kE = 36e5, nN = 168;
function d1(s, u) {
  try {
    return s.getItem(u);
  } catch {
  }
}
function Y1(s, u, h) {
  try {
    return s.setItem(u, h), !0;
  } catch {
  }
}
function gA(s, u) {
  try {
    s.removeItem(u);
  } catch {
  }
}
function f1(s, u) {
  return Y1(s, SE, u.toString());
}
function h1(s) {
  return parseInt(d1(s, SE)) || 0;
}
const qy = {
  local: !0,
  session: !0
}, CE = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let H1 = !1;
function rN(s) {
  H1 = s;
}
let xy = typeof window > "u" ? {} : window;
function TE(s) {
  const u = s + "Storage";
  try {
    if (xy && xy[u] && typeof xy[u].length == "number")
      return xy[u];
  } catch {
  }
  qy[s] = !1;
}
function AE(s, u) {
  const h = TE(s);
  if (!h)
    return;
  const m = d1(h, pA);
  if (m !== hA) {
    if (m) {
      const F = h1(h);
      for (let H = 0; H < F; H++)
        gA(h, gg + H.toString());
    }
    Y1(h, pA, hA), f1(h, 0);
    return;
  }
  const w = Math.floor(Date.now() / kE) - nN, T = (F) => {
    const H = gg + F.toString(), j = d1(h, H);
    if (typeof j == "string") {
      try {
        const V = JSON.parse(j);
        if (typeof V == "object" && typeof V.cached == "number" && V.cached > w && typeof V.provider == "string" && typeof V.data == "object" && typeof V.data.prefix == "string" && // Valid item: run callback
        u(V, F))
          return !0;
      } catch {
      }
      gA(h, H);
    }
  };
  let A = h1(h);
  for (let F = A - 1; F >= 0; F--)
    T(F) || (F === A - 1 ? (A--, f1(h, A)) : CE[s].add(F));
}
function EE() {
  if (!H1) {
    rN(!0);
    for (const s in qy)
      AE(s, (u) => {
        const h = u.data, m = u.provider, w = h.prefix, T = Hc(
          m,
          w
        );
        if (!N1(T, h).length)
          return !1;
        const A = h.lastModified || -1;
        return T.lastModifiedCached = T.lastModifiedCached ? Math.min(T.lastModifiedCached, A) : A, !0;
      });
  }
}
function aN(s, u) {
  const h = s.lastModifiedCached;
  if (
    // Matches or newer
    h && h >= u
  )
    return h === u;
  if (s.lastModifiedCached = u, h)
    for (const m in qy)
      AE(m, (w) => {
        const T = w.data;
        return w.provider !== s.provider || T.prefix !== s.prefix || T.lastModified === u;
      });
  return !0;
}
function iN(s, u) {
  H1 || EE();
  function h(m) {
    let w;
    if (!qy[m] || !(w = TE(m)))
      return;
    const T = CE[m];
    let A;
    if (T.size)
      T.delete(A = Array.from(T).shift());
    else if (A = h1(w), !f1(w, A + 1))
      return;
    const F = {
      cached: Math.floor(Date.now() / kE),
      provider: s.provider,
      data: u
    };
    return Y1(
      w,
      gg + A.toString(),
      JSON.stringify(F)
    );
  }
  u.lastModified && !aN(s, u.lastModified) || Object.keys(u.icons).length && (u.not_found && (u = Object.assign({}, u), delete u.not_found), h("local") || h("session"));
}
function mA() {
}
function sN(s) {
  s.iconsLoaderFlag || (s.iconsLoaderFlag = !0, setTimeout(() => {
    s.iconsLoaderFlag = !1, $P(s);
  }));
}
function oN(s, u) {
  s.iconsToLoad ? s.iconsToLoad = s.iconsToLoad.concat(u).sort() : s.iconsToLoad = u, s.iconsQueueFlag || (s.iconsQueueFlag = !0, setTimeout(() => {
    s.iconsQueueFlag = !1;
    const { provider: h, prefix: m } = s, w = s.iconsToLoad;
    delete s.iconsToLoad;
    let T;
    if (!w || !(T = c1(h)))
      return;
    T.prepare(h, m, w).forEach((F) => {
      tN(h, F, (H) => {
        if (typeof H != "object")
          F.icons.forEach((j) => {
            s.missing.add(j);
          });
        else
          try {
            const j = N1(
              s,
              H
            );
            if (!j.length)
              return;
            const V = s.pendingIcons;
            V && j.forEach((q) => {
              V.delete(q);
            }), iN(s, H);
          } catch (j) {
            console.error(j);
          }
        sN(s);
      });
    });
  }));
}
const lN = (s, u) => {
  const h = QP(s, !0, vE()), m = GP(h);
  if (!m.pending.length) {
    let H = !0;
    return u && setTimeout(() => {
      H && u(
        m.loaded,
        m.missing,
        m.pending,
        mA
      );
    }), () => {
      H = !1;
    };
  }
  const w = /* @__PURE__ */ Object.create(null), T = [];
  let A, F;
  return m.pending.forEach((H) => {
    const { provider: j, prefix: V } = H;
    if (V === F && j === A)
      return;
    A = j, F = V, T.push(Hc(j, V));
    const q = w[j] || (w[j] = /* @__PURE__ */ Object.create(null));
    q[V] || (q[V] = []);
  }), m.pending.forEach((H) => {
    const { provider: j, prefix: V, name: q } = H, te = Hc(j, V), ae = te.pendingIcons || (te.pendingIcons = /* @__PURE__ */ new Set());
    ae.has(q) || (ae.add(q), w[j][V].push(q));
  }), T.forEach((H) => {
    const { provider: j, prefix: V } = H;
    w[j][V].length && oN(H, w[j][V]);
  }), u ? ZP(u, m, T) : mA;
};
function uN(s, u) {
  const h = {
    ...s
  };
  for (const m in u) {
    const w = u[m], T = typeof w;
    m in yE ? (w === null || w && (T === "string" || T === "number")) && (h[m] = w) : T === typeof h[m] && (h[m] = m === "rotate" ? w % 4 : w);
  }
  return h;
}
const cN = /[\s,]+/;
function dN(s, u) {
  u.split(cN).forEach((h) => {
    switch (h.trim()) {
      case "horizontal":
        s.hFlip = !0;
        break;
      case "vertical":
        s.vFlip = !0;
        break;
    }
  });
}
function fN(s, u = 0) {
  const h = s.replace(/^-?[0-9.]*/, "");
  function m(w) {
    for (; w < 0; )
      w += 4;
    return w % 4;
  }
  if (h === "") {
    const w = parseInt(s);
    return isNaN(w) ? 0 : m(w);
  } else if (h !== s) {
    let w = 0;
    switch (h) {
      case "%":
        w = 25;
        break;
      case "deg":
        w = 90;
    }
    if (w) {
      let T = parseFloat(s.slice(0, s.length - h.length));
      return isNaN(T) ? 0 : (T = T / w, T % 1 === 0 ? m(T) : 0);
    }
  }
  return u;
}
function hN(s, u) {
  let h = s.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const m in u)
    h += " " + m + '="' + u[m] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + h + ">" + s + "</svg>";
}
function pN(s) {
  return s.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function gN(s) {
  return "data:image/svg+xml," + pN(s);
}
function mN(s) {
  return 'url("' + gN(s) + '")';
}
let lg;
function vN() {
  try {
    lg = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (s) => s
    });
  } catch {
    lg = null;
  }
}
function yN(s) {
  return lg === void 0 && vN(), lg ? lg.createHTML(s) : s;
}
const RE = {
  ...xE,
  inline: !1
}, xN = {
  xmlns: "http://www.w3.org/2000/svg",
  xmlnsXlink: "http://www.w3.org/1999/xlink",
  "aria-hidden": !0,
  role: "img"
}, bN = {
  display: "inline-block"
}, p1 = {
  backgroundColor: "currentColor"
}, LE = {
  backgroundColor: "transparent"
}, vA = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
}, yA = {
  WebkitMask: p1,
  mask: p1,
  background: LE
};
for (const s in yA) {
  const u = yA[s];
  for (const h in vA)
    u[s + h] = vA[h];
}
const wN = {
  ...RE,
  inline: !0
};
function xA(s) {
  return s + (s.match(/^[-0-9.]+$/) ? "px" : "");
}
const SN = (s, u, h, m) => {
  const w = h ? wN : RE, T = uN(w, u), A = u.mode || "svg", F = {}, H = u.style || {}, j = {
    ...A === "svg" ? xN : {},
    ref: m
  };
  for (let Pe in u) {
    const K = u[Pe];
    if (K !== void 0)
      switch (Pe) {
        case "icon":
        case "style":
        case "children":
        case "onLoad":
        case "mode":
        case "_ref":
        case "_inline":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          T[Pe] = K === !0 || K === "true" || K === 1;
          break;
        case "flip":
          typeof K == "string" && dN(T, K);
          break;
        case "color":
          F.color = K;
          break;
        case "rotate":
          typeof K == "string" ? T[Pe] = fN(K) : typeof K == "number" && (T[Pe] = K);
          break;
        case "ariaHidden":
        case "aria-hidden":
          K !== !0 && K !== "true" && delete j["aria-hidden"];
          break;
        default:
          w[Pe] === void 0 && (j[Pe] = K);
      }
  }
  const V = _P(s, T), q = V.attributes;
  if (T.inline && (F.verticalAlign = "-0.125em"), A === "svg") {
    j.style = {
      ...F,
      ...H
    }, Object.assign(j, q);
    let Pe = 0, K = u.id;
    return typeof K == "string" && (K = K.replace(/-/g, "_")), j.dangerouslySetInnerHTML = {
      __html: yN(IP(V.body, K ? () => K + "ID" + Pe++ : "iconifyReact"))
    }, Mu.createElement("svg", j);
  }
  const { body: te, width: ae, height: se } = s, ue = A === "mask" || (A === "bg" ? !1 : te.indexOf("currentColor") !== -1), Ce = hN(te, {
    ...q,
    width: ae + "",
    height: se + ""
  });
  return j.style = {
    ...F,
    "--svg": mN(Ce),
    width: xA(q.width),
    height: xA(q.height),
    ...bN,
    ...ue ? p1 : LE,
    ...H
  }, Mu.createElement("span", j);
};
vE(!0);
FP("", VP);
if (typeof document < "u" && typeof window < "u") {
  EE();
  const s = window;
  if (s.IconifyPreload !== void 0) {
    const u = s.IconifyPreload, h = "Invalid IconifyPreload syntax.";
    typeof u == "object" && u !== null && (u instanceof Array ? u : [u]).forEach((m) => {
      try {
        // Check if item is an object and not null/array
        (typeof m != "object" || m === null || m instanceof Array || // Check for 'icons' and 'prefix'
        typeof m.icons != "object" || typeof m.prefix != "string" || // Add icon set
        !LP(m)) && console.error(h);
      } catch {
        console.error(h);
      }
    });
  }
  if (s.IconifyProviders !== void 0) {
    const u = s.IconifyProviders;
    if (typeof u == "object" && u !== null)
      for (let h in u) {
        const m = "IconifyProviders[" + h + "] is invalid.";
        try {
          const w = u[h];
          if (typeof w != "object" || !w || w.resources === void 0)
            continue;
          YP(h, w) || console.error(m);
        } catch {
          console.error(m);
        }
      }
  }
}
let OE = class extends Mu.Component {
  constructor(u) {
    super(u), this.state = {
      // Render placeholder before component is mounted
      icon: null
    };
  }
  /**
   * Abort loading icon
   */
  _abortLoading() {
    this._loading && (this._loading.abort(), this._loading = null);
  }
  /**
   * Update state
   */
  _setData(u) {
    this.state.icon !== u && this.setState({
      icon: u
    });
  }
  /**
   * Check if icon should be loaded
   */
  _checkIcon(u) {
    const h = this.state, m = this.props.icon;
    if (typeof m == "object" && m !== null && typeof m.body == "string") {
      this._icon = "", this._abortLoading(), (u || h.icon === null) && this._setData({
        data: m
      });
      return;
    }
    let w;
    if (typeof m != "string" || (w = $y(m, !1, !0)) === null) {
      this._abortLoading(), this._setData(null);
      return;
    }
    const T = EP(w);
    if (!T) {
      (!this._loading || this._loading.name !== m) && (this._abortLoading(), this._icon = "", this._setData(null), T !== null && (this._loading = {
        name: m,
        abort: lN([w], this._checkIcon.bind(this, !1))
      }));
      return;
    }
    if (this._icon !== m || h.icon === null) {
      this._abortLoading(), this._icon = m;
      const A = ["iconify"];
      w.prefix !== "" && A.push("iconify--" + w.prefix), w.provider !== "" && A.push("iconify--" + w.provider), this._setData({
        data: T,
        classes: A
      }), this.props.onLoad && this.props.onLoad(m);
    }
  }
  /**
   * Component mounted
   */
  componentDidMount() {
    this._checkIcon(!1);
  }
  /**
   * Component updated
   */
  componentDidUpdate(u) {
    u.icon !== this.props.icon && this._checkIcon(!0);
  }
  /**
   * Abort loading
   */
  componentWillUnmount() {
    this._abortLoading();
  }
  /**
   * Render
   */
  render() {
    const u = this.props, h = this.state.icon;
    if (h === null)
      return u.children ? u.children : Mu.createElement("span", {});
    let m = u;
    return h.classes && (m = {
      ...u,
      className: (typeof u.className == "string" ? u.className + " " : "") + h.classes.join(" ")
    }), SN({
      ...P1,
      ...h.data
    }, m, u._inline, u._ref);
  }
};
const kN = Mu.forwardRef(function(u, h) {
  const m = {
    ...u,
    _ref: h,
    _inline: !1
  };
  return Mu.createElement(OE, m);
});
Mu.forwardRef(function(u, h) {
  const m = {
    ...u,
    _ref: h,
    _inline: !0
  };
  return Mu.createElement(OE, m);
});
var ma = kN;
const CN = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (s) => {
  const u = Math.random() * 16 | 0;
  return (s === "x" ? u : u & 3 | 8).toString(16);
}), TN = ({
  onChange: s,
  defaultValue: u,
  children: h,
  name: m,
  invalidText: w,
  placeholder: T,
  variant: A,
  icon: F,
  required: H = !0,
  className: j = "",
  type: V = "text",
  id: q = CN(),
  ...te
}) => /* @__PURE__ */ ce.jsxs("div", { className: `textfield ${A ? "bg-" + A : ""} ${j}`, children: [
  /* @__PURE__ */ ce.jsx("label", { htmlFor: q, children: T ?? m ?? q }),
  /* @__PURE__ */ ce.jsx(
    "input",
    {
      id: q,
      type: V,
      className: "input",
      name: m ?? q,
      onChange: s,
      defaultValue: u,
      placeholder: T ?? m ?? q ?? "",
      required: H,
      ...te
    }
  ),
  F && /* @__PURE__ */ ce.jsx(ma, { icon: F }),
  H && /* @__PURE__ */ ce.jsx("span", { className: "required", children: w ?? m ? `${m ?? q} should not be empty!` : "Should not be empty!" }),
  h && h
] }), Xj = ({
  defaultShow: s = !1,
  ...u
}) => {
  const [h, m] = fr(s);
  return /* @__PURE__ */ ce.jsx(ce.Fragment, { children: /* @__PURE__ */ ce.jsx(
    TN,
    {
      ...u,
      className: `textfield-password ${(u == null ? void 0 : u.className) ?? ""}`,
      type: h ? "text" : "password",
      autoComplete: "new-password",
      children: /* @__PURE__ */ ce.jsx(
        "button",
        {
          type: "button",
          title: "Show or hide the password",
          className: "btn btn-circle btn-sm ring-info",
          onClick: () => m((w) => !w),
          children: /* @__PURE__ */ ce.jsx(ma, { icon: h ? "ph:eye-slash" : "ph:eye-light" })
        }
      )
    }
  ) });
}, AN = (s) => {
  console.log(s);
}, EN = (s) => {
  console.log(s);
}, RN = ["Su", "Mo", "Tu", "We", "Th", "Fri", "Sa"], LN = ({
  defaultSelected: s,
  startDateRef: u,
  endDateRef: h,
  onClose: m
}) => {
  const [w, T] = fr(
    (s == null ? void 0 : s.start) === void 0 ? tr() : s.start
  ), [A, F] = fr(
    s === void 0 ? {
      start: null,
      end: null
    } : s
  ), H = w, j = H.clone().startOf("month"), V = H.clone().endOf("month"), q = [], te = j.day(), ae = V.day();
  for (let se = te - 1; se >= 0; se--)
    q.push(j.clone().subtract(se, "days"));
  for (let se = j.clone().add(1, "day"); se.isSameOrBefore(V); se.add(1, "day"))
    q.push(se.clone());
  for (let se = 1; se <= 6 - ae + 1; se++)
    q.push(V.clone().add(se, "days"));
  return /* @__PURE__ */ ce.jsx("div", { className: "dropdown", children: /* @__PURE__ */ ce.jsxs("div", { className: "container rounded-box shadow-md bg-base-200", children: [
    /* @__PURE__ */ ce.jsxs("header", { className: "date-header", children: [
      /* @__PURE__ */ ce.jsxs("div", { className: "date-header--actions", children: [
        /* @__PURE__ */ ce.jsx(
          "button",
          {
            type: "button",
            className: "btn btn-icon btn-sm btn-square btn-neutral",
            onClick: () => {
              T(
                (se) => se.clone().subtract(1, "month")
              );
            },
            children: /* @__PURE__ */ ce.jsx(ma, { icon: "ep:arrow-left-bold" })
          }
        ),
        /* @__PURE__ */ ce.jsx("button", { type: "button", className: "btn", children: H.format("MMM, YYYY") }),
        /* @__PURE__ */ ce.jsx(
          "button",
          {
            type: "button",
            className: "btn btn-icon btn-sm btn-square btn-neutral",
            onClick: () => {
              T(
                (se) => se.clone().add(1, "month")
              );
            },
            disabled: w.clone().add(1, "month").isSameOrAfter(tr()),
            children: /* @__PURE__ */ ce.jsx(ma, { icon: "ep:arrow-left-bold", hFlip: !0 })
          }
        )
      ] }),
      /* @__PURE__ */ ce.jsx("ul", { className: "date-weekdays", children: RN.map((se) => /* @__PURE__ */ ce.jsx("li", { children: /* @__PURE__ */ ce.jsx("span", { children: se }) }, se)) })
    ] }),
    /* @__PURE__ */ ce.jsx("ul", { className: "days-container", children: q.map((se, ue) => {
      var Ee, re, me;
      let Ce = "";
      const Pe = (Ee = A.start) != null && Ee.startOf("day").isSame(se) ? "selected start" : (me = (re = A.end) == null ? void 0 : re.startOf("day")) != null && me.isSame(se) ? "selected end" : "", K = se.format("MM") !== H.format("MM") ? "not-current" : "", we = se.isBetween(
        A.start,
        A.end
      ) ? "between" : "";
      return Ce += K + Pe + we, /* @__PURE__ */ ce.jsx("li", { children: /* @__PURE__ */ ce.jsx(
        "button",
        {
          type: "button",
          onClick: () => {
            var Me;
            if (!(u.current === null || h.current === null)) {
              if (((Me = A.start) == null ? void 0 : Me.date()) === se.date()) {
                F({
                  start: null,
                  end: null
                }), u.current.value = "", h.current.value = "";
                return;
              }
              if (A.start === null)
                F((Je) => ({
                  ...Je,
                  start: se
                })), u.current.value = se.format("YYYY-MM-DD");
              else if (A.start !== null) {
                if (se.isBefore(A.start)) {
                  F((Je) => ({
                    start: se,
                    end: Je.start
                  })), u.current.value = se.format("YYYY-MM-DD"), h.current.value = A.start.format("YYYY-MM-DD");
                  return;
                }
                F((Je) => ({
                  ...Je,
                  end: se
                })), h.current.value = se.format("YYYY-MM-DD");
              }
            }
          },
          className: Ce,
          disabled: se.isAfter(tr()),
          children: se.format("DD")
        }
      ) }, ue);
    }) }),
    /* @__PURE__ */ ce.jsx(
      "button",
      {
        type: "button",
        onClick: m,
        className: "btn btn-sm btn-primary",
        style: { alignSelf: "end" },
        children: nr("common.ok")
      }
    )
  ] }) });
}, Vj = ({
  defaultSelected: s,
  onSearch: u,
  children: h
}) => {
  const [m, w] = fr(!1), T = mr(null), A = mr(null), F = {
    ref: T,
    type: "date",
    name: "start",
    onFocus: AN,
    onClick: () => {
      w((j) => !j);
    },
    autoComplete: "off",
    defaultValue: s ? s.start.format("YYYY-MM-DD") : ""
  }, H = {
    ref: A,
    type: "date",
    name: "end",
    onFocus: EN,
    onClick: () => {
      w((j) => !j);
    },
    autoComplete: "off",
    defaultValue: s != null && s.end ? s.end.format("YYYY-MM-DD") : ""
  };
  return /* @__PURE__ */ ce.jsx(ce.Fragment, { children: /* @__PURE__ */ ce.jsxs(
    "form",
    {
      className: "date-range-picker",
      onSubmit: (j) => {
        j.preventDefault();
        const V = new FormData(j.target), q = Object.fromEntries(V.entries()), te = {
          start: tr(q.start, "YYYY-MM-DD"),
          end: tr(q.end, "YYYY-MM-DD")
        };
        u == null || u(te);
      },
      children: [
        /* @__PURE__ */ ce.jsxs("div", { className: "group rounded-box", children: [
          h({ startDateProps: F, endDateProps: H }),
          /* @__PURE__ */ ce.jsx("button", { className: "btn btn-primary ring-info", children: nr("common.search") })
        ] }),
        m && /* @__PURE__ */ ce.jsx(
          LN,
          {
            defaultSelected: s,
            startDateRef: T,
            endDateRef: A,
            onClose: () => w(!1)
          }
        )
      ]
    }
  ) });
}, ON = (s, u, h, m, w, T) => {
  let A = 0, F = !1;
  switch (s.key) {
    case "ArrowUp": {
      if (u === 0)
        return;
      A = u - 1, w.current[A].focus(), h(A), m.current = "";
      break;
    }
    case "ArrowDown": {
      if (u === T - 1)
        return;
      A = u + 1, w.current[A].focus(), m.current = "", h(A);
      break;
    }
    case "Backspace": {
      m.current = m.current.slice(0, -1), m.current.length > 0 && (F = !0);
      break;
    }
    default:
      s.key.length === 1 && isNaN(Number(s.key)) && (m.current += s.key, F = !0);
  }
  if (F) {
    const H = w.current.findIndex(
      (j) => j.innerText.toLowerCase().includes(m.current.toLowerCase())
    );
    if (H === -1)
      return;
    w.current[H].focus(), h(H);
  }
}, DN = (s) => typeof s == "object" ? /* @__PURE__ */ ce.jsx("span", { children: Object.values(s)[0] }) : /* @__PURE__ */ ce.jsx("span", { children: s }), Yy = ({
  items: s,
  selected: u,
  currentSelected: h,
  selector: m,
  onChange: w,
  labelExtractor: T,
  disabled: A = !1,
  required: F = !0,
  showQty: H = 4,
  style: j = {},
  name: V = "",
  position: q = "top",
  variant: te = "neutral",
  keyExtractor: ae = DN
}) => {
  const [se, ue] = fr(!1), [Ce, Pe] = fr(
    u !== void 0 ? u : s.findIndex(
      (Me) => m ? Me[m] === (h == null ? void 0 : h[m]) : Me === h
    )
  );
  Hf(() => {
    u && u !== Ce && Pe(u);
  }, [u, Ce]);
  const [K, we] = fr(Ce), Ee = mr(null), re = mr(""), me = mr([]);
  return /* @__PURE__ */ ce.jsxs(
    "div",
    {
      className: `select ${se ? "shadow-md" : ""} ${q}`,
      onBlur: () => {
      },
      style: j,
      children: [
        /* @__PURE__ */ ce.jsxs(
          "button",
          {
            type: "button",
            disabled: A,
            className: `btn btn-${te} btn-select ${se ? "active" : ""}`,
            onClick: () => {
              ue((Je) => !Je);
              const Me = h === void 0 ? 0 : Ce;
              we(Me), setTimeout(() => {
                se || me.current[Me].focus();
              }, 10);
            },
            children: [
              /* @__PURE__ */ ce.jsx("span", { className: Ce === -1 ? "not-selected" : "", children: Ce === -1 ? nr("select.select-one") : (T == null ? void 0 : T(s[Ce], -1)) ?? ae(s[Ce], -1) }),
              /* @__PURE__ */ ce.jsx(ma, { icon: "eva:arrow-down-fill", vFlip: se })
            ]
          }
        ),
        /* @__PURE__ */ ce.jsx(
          "input",
          {
            style: {
              display: "block",
              position: "absolute",
              top: "100%",
              opacity: 0,
              height: 1,
              pointerEvents: "none"
            },
            defaultValue: typeof h == "object" && m ? h == null ? void 0 : h[m] : typeof h == "string" ? h : "",
            autoComplete: "new-password",
            name: V,
            ref: Ee,
            required: F
          }
        ),
        se && /* @__PURE__ */ ce.jsx(
          "ul",
          {
            className: `select-items${s.length > 4 ? " custom-scroll " : " "}bg-${te} shadow-md`,
            style: { "--select-items": H },
            children: s.map((Me, Je) => /* @__PURE__ */ ce.jsx("li", { className: "item", children: /* @__PURE__ */ ce.jsx(
              "button",
              {
                type: "button",
                className: `${Je === Ce ? "active" : ""}`,
                ref: (Ve) => me.current[Je] = Ve,
                tabIndex: 0,
                onClick: () => {
                  Pe(Je), w !== void 0 && w(Je, s[Je]), Ee.current && m && (Ee.current.value = String(s[Je][m])), ue(!1);
                },
                onMouseEnter: (Ve) => {
                  we(Je), Ve.target.focus();
                },
                onMouseLeave: () => {
                  we(Ce);
                },
                onKeyDown: (Ve) => ON(
                  Ve,
                  K,
                  we,
                  re,
                  me,
                  s.length
                ),
                children: ae(Me, Je)
              }
            ) }, Je))
          }
        )
      ]
    }
  );
}, bA = (s, u, h, m, w, T) => {
  let A = 0, F = !1;
  switch (s.key) {
    case "ArrowUp": {
      if (u === 0)
        return;
      A = u - 1, w.current[A].focus(), h(A), m.current = "";
      break;
    }
    case "ArrowDown": {
      if (u === T - 1)
        return;
      A = u + 1, w.current[A].focus(), m.current = "", h(A);
      break;
    }
    case "Backspace": {
      m.current = m.current.slice(0, -1), m.current.length > 0 && (F = !0);
      break;
    }
    default:
      s.key.length === 1 && isNaN(Number(s.key)) && (m.current += s.key, F = !0);
  }
  if (F) {
    const H = w.current.findIndex(
      (j) => j.innerText.toLowerCase().includes(m.current.toLowerCase())
    );
    if (H === -1)
      return;
    w.current[H].focus(), h(H);
  }
}, j1 = (s, u, h) => {
  let m;
  return (...w) => {
    const A = () => {
      m = null, h || s.apply(void 0, w);
    }, F = h && !m;
    clearTimeout(m), m = setTimeout(A, u), F && s.apply(void 0, w);
  };
}, MN = [
  {
    mode: "all",
    label: "Todos"
  },
  {
    mode: "selected",
    label: "Selecionados"
  },
  {
    mode: "not-selected",
    label: "No selecionados"
  }
], _N = (s) => typeof s == "object" ? /* @__PURE__ */ ce.jsx("span", { children: Object.values(s)[0] }) : /* @__PURE__ */ ce.jsx("span", { children: s }), Gj = ({
  items: s,
  selected: u,
  selector: h,
  onChange: m,
  labelExtractor: w,
  onAllChange: T = () => {
  },
  showQty: A = 10,
  style: F = {},
  position: H = "top",
  variant: j = "neutral",
  keyExtractor: V = _N
}) => {
  const [q, te] = fr(!1), [ae, se] = fr(u ?? []), [ue, Ce] = fr(
    "all"
  ), [Pe, K] = fr("");
  Hf(() => {
    u && u !== ae && se(u ?? []);
  }, [u, ae]);
  const we = Du(() => {
    var Xe;
    const Ve = [];
    for (let it = 0; it < s.length; it++) {
      if (!String(h ? (Xe = s[it]) == null ? void 0 : Xe[h] : s[it]).toLowerCase().includes(Pe))
        continue;
      if (ue === "all") {
        Ve.push(it);
        continue;
      }
      const Ze = ae.includes(it);
      Ze && ue === "selected" && Ve.push(it), !Ze && ue === "not-selected" && Ve.push(it);
    }
    return Ve;
  }, [s, Pe, h, ue, ae]), [Ee, re] = fr(0), me = mr(null), Me = mr(""), Je = mr([]);
  return /* @__PURE__ */ ce.jsxs(
    "div",
    {
      className: `select multiselect ${q ? "shadow-md" : ""} ${H}`,
      onBlur: () => {
      },
      style: F,
      children: [
        /* @__PURE__ */ ce.jsxs(
          "button",
          {
            type: "button",
            className: `btn btn-${j} btn-select ${q ? "active" : ""}`,
            onClick: () => {
              te((Ve) => !Ve), re(0);
            },
            children: [
              /* @__PURE__ */ ce.jsx("span", { className: ae.length === 0 ? "not-selected" : "", children: ae.length === 0 ? "Clique para selecionar" : (w == null ? void 0 : w(ae)) ?? `${ae.length} selecionados` }),
              /* @__PURE__ */ ce.jsx(ma, { icon: "eva:arrow-down-fill", vFlip: q })
            ]
          }
        ),
        q && /* @__PURE__ */ ce.jsxs(
          "ul",
          {
            className: `select-items${s.length > 4 ? " custom-scroll " : " "}bg-${j} shadow-md`,
            style: { "--select-items": A },
            children: [
              /* @__PURE__ */ ce.jsx(
                "li",
                {
                  className: "group rounded-box",
                  style: { width: "fit-content", padding: "var(--spacing-xs)" },
                  children: MN.map((Ve) => /* @__PURE__ */ ce.jsx(
                    "button",
                    {
                      className: `btn no-bounce btn-${Ve.mode === ue ? "primary" : "neutral"} btn-sm`,
                      onClick: () => Ce(Ve.mode),
                      children: Ve.label
                    },
                    Ve.mode
                  ))
                }
              ),
              /* @__PURE__ */ ce.jsx("li", { className: "search-bar", children: /* @__PURE__ */ ce.jsx(
                "input",
                {
                  className: "input",
                  type: "input",
                  placeholder: "Buscar...",
                  onChange: j1((Ve) => {
                    K(Ve.target.value.toLowerCase());
                  }, 300)
                }
              ) }),
              /* @__PURE__ */ ce.jsx("li", { className: "item", children: /* @__PURE__ */ ce.jsxs(
                "button",
                {
                  type: "button",
                  ref: (Ve) => Je.current[0] = Ve,
                  className: `${ae.length === s.length ? "active" : ""}`,
                  onMouseEnter: (Ve) => {
                    re(0), Ve.target.focus();
                  },
                  onClick: () => {
                    T(ae.length !== s.length), ae.length === s.length ? se([]) : se(s.map((Ve, Xe) => Xe));
                  },
                  onKeyDown: (Ve) => bA(
                    Ve,
                    Ee,
                    re,
                    Me,
                    Je,
                    s.length
                  ),
                  tabIndex: 0,
                  children: [
                    /* @__PURE__ */ ce.jsx(
                      "input",
                      {
                        type: "checkbox",
                        className: "checkbox checkbox-secondary",
                        onChange: () => {
                          T(ae.length !== s.length), ae.length === s.length ? se([]) : se(s.map((Ve, Xe) => Xe));
                        },
                        checked: ae.length === s.length
                      }
                    ),
                    /* @__PURE__ */ ce.jsx("span", { children: "Selecionar Tudo" })
                  ]
                }
              ) }),
              s.length === 0 || we().length === 0 && /* @__PURE__ */ ce.jsx("li", { className: "item", style: { padding: "var(--spacing-xs)" }, children: /* @__PURE__ */ ce.jsx("span", { children: "Nenhum item foi encontrado" }) }),
              s.map((Ve, Xe) => {
                if (!we().includes(Xe))
                  return null;
                const it = ae.includes(Xe);
                return /* @__PURE__ */ ce.jsx("li", { className: "item", children: /* @__PURE__ */ ce.jsxs(
                  "button",
                  {
                    type: "button",
                    className: `${it ? "active" : ""}`,
                    ref: (ht) => Je.current[Xe + 1] = ht,
                    tabIndex: 0,
                    onClick: () => {
                      const ht = it ? ae.filter((Ke) => Ke !== Xe) : [...ae, Xe];
                      se(ht), m !== void 0 && m(Xe, s[Xe], ht), me.current && h && (me.current.value = String(s[Xe][h]));
                    },
                    onMouseEnter: (ht) => {
                      re(Xe), ht.target.focus();
                    },
                    onMouseLeave: () => {
                      re(0);
                    },
                    onKeyDown: (ht) => bA(
                      ht,
                      Ee,
                      re,
                      Me,
                      Je,
                      we().length + 1
                    ),
                    children: [
                      /* @__PURE__ */ ce.jsx(
                        "input",
                        {
                          type: "checkbox",
                          className: "checkbox checkbox-secondary",
                          checked: it ?? !1,
                          onChange: () => {
                            se((ht) => it ? ht.filter(
                              (Ke) => Ke !== Xe
                            ) : [...ht, Xe]), m !== void 0 && m(Xe, s[Xe]), me.current && h && (me.current.value = String(s[Xe][h]));
                          }
                        }
                      ),
                      V(Ve)
                    ]
                  }
                ) }, Xe);
              })
            ]
          }
        )
      ]
    }
  );
};
//! moment.js
//! version : 2.29.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var DE;
function ct() {
  return DE.apply(null, arguments);
}
function PN(s) {
  DE = s;
}
function Ws(s) {
  return s instanceof Array || Object.prototype.toString.call(s) === "[object Array]";
}
function Yc(s) {
  return s != null && Object.prototype.toString.call(s) === "[object Object]";
}
function En(s, u) {
  return Object.prototype.hasOwnProperty.call(s, u);
}
function B1(s) {
  if (Object.getOwnPropertyNames)
    return Object.getOwnPropertyNames(s).length === 0;
  var u;
  for (u in s)
    if (En(s, u))
      return !1;
  return !0;
}
function Mi(s) {
  return s === void 0;
}
function El(s) {
  return typeof s == "number" || Object.prototype.toString.call(s) === "[object Number]";
}
function wg(s) {
  return s instanceof Date || Object.prototype.toString.call(s) === "[object Date]";
}
function ME(s, u) {
  var h = [], m, w = s.length;
  for (m = 0; m < w; ++m)
    h.push(u(s[m], m));
  return h;
}
function Ru(s, u) {
  for (var h in u)
    En(u, h) && (s[h] = u[h]);
  return En(u, "toString") && (s.toString = u.toString), En(u, "valueOf") && (s.valueOf = u.valueOf), s;
}
function Mo(s, u, h, m) {
  return nR(s, u, h, m, !0).utc();
}
function NN() {
  return {
    empty: !1,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: !1,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: !1,
    userInvalidated: !1,
    iso: !1,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: !1,
    weekdayMismatch: !1
  };
}
function an(s) {
  return s._pf == null && (s._pf = NN()), s._pf;
}
var g1;
Array.prototype.some ? g1 = Array.prototype.some : g1 = function(s) {
  var u = Object(this), h = u.length >>> 0, m;
  for (m = 0; m < h; m++)
    if (m in u && s.call(this, u[m], m, u))
      return !0;
  return !1;
};
function W1(s) {
  if (s._isValid == null) {
    var u = an(s), h = g1.call(u.parsedDateParts, function(w) {
      return w != null;
    }), m = !isNaN(s._d.getTime()) && u.overflow < 0 && !u.empty && !u.invalidEra && !u.invalidMonth && !u.invalidWeekday && !u.weekdayMismatch && !u.nullInput && !u.invalidFormat && !u.userInvalidated && (!u.meridiem || u.meridiem && h);
    if (s._strict && (m = m && u.charsLeftOver === 0 && u.unusedTokens.length === 0 && u.bigHour === void 0), Object.isFrozen == null || !Object.isFrozen(s))
      s._isValid = m;
    else
      return m;
  }
  return s._isValid;
}
function Zy(s) {
  var u = Mo(NaN);
  return s != null ? Ru(an(u), s) : an(u).userInvalidated = !0, u;
}
var wA = ct.momentProperties = [], Bw = !1;
function U1(s, u) {
  var h, m, w, T = wA.length;
  if (Mi(u._isAMomentObject) || (s._isAMomentObject = u._isAMomentObject), Mi(u._i) || (s._i = u._i), Mi(u._f) || (s._f = u._f), Mi(u._l) || (s._l = u._l), Mi(u._strict) || (s._strict = u._strict), Mi(u._tzm) || (s._tzm = u._tzm), Mi(u._isUTC) || (s._isUTC = u._isUTC), Mi(u._offset) || (s._offset = u._offset), Mi(u._pf) || (s._pf = an(u)), Mi(u._locale) || (s._locale = u._locale), T > 0)
    for (h = 0; h < T; h++)
      m = wA[h], w = u[m], Mi(w) || (s[m] = w);
  return s;
}
function Sg(s) {
  U1(this, s), this._d = new Date(s._d != null ? s._d.getTime() : NaN), this.isValid() || (this._d = /* @__PURE__ */ new Date(NaN)), Bw === !1 && (Bw = !0, ct.updateOffset(this), Bw = !1);
}
function Us(s) {
  return s instanceof Sg || s != null && s._isAMomentObject != null;
}
function _E(s) {
  ct.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn("Deprecation warning: " + s);
}
function ls(s, u) {
  var h = !0;
  return Ru(function() {
    if (ct.deprecationHandler != null && ct.deprecationHandler(null, s), h) {
      var m = [], w, T, A, F = arguments.length;
      for (T = 0; T < F; T++) {
        if (w = "", typeof arguments[T] == "object") {
          w += `
[` + T + "] ";
          for (A in arguments[0])
            En(arguments[0], A) && (w += A + ": " + arguments[0][A] + ", ");
          w = w.slice(0, -2);
        } else
          w = arguments[T];
        m.push(w);
      }
      _E(
        s + `
Arguments: ` + Array.prototype.slice.call(m).join("") + `
` + new Error().stack
      ), h = !1;
    }
    return u.apply(this, arguments);
  }, u);
}
var SA = {};
function PE(s, u) {
  ct.deprecationHandler != null && ct.deprecationHandler(s, u), SA[s] || (_E(u), SA[s] = !0);
}
ct.suppressDeprecationWarnings = !1;
ct.deprecationHandler = null;
function _o(s) {
  return typeof Function < "u" && s instanceof Function || Object.prototype.toString.call(s) === "[object Function]";
}
function zN(s) {
  var u, h;
  for (h in s)
    En(s, h) && (u = s[h], _o(u) ? this[h] = u : this["_" + h] = u);
  this._config = s, this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function m1(s, u) {
  var h = Ru({}, s), m;
  for (m in u)
    En(u, m) && (Yc(s[m]) && Yc(u[m]) ? (h[m] = {}, Ru(h[m], s[m]), Ru(h[m], u[m])) : u[m] != null ? h[m] = u[m] : delete h[m]);
  for (m in s)
    En(s, m) && !En(u, m) && Yc(s[m]) && (h[m] = Ru({}, h[m]));
  return h;
}
function X1(s) {
  s != null && this.set(s);
}
var v1;
Object.keys ? v1 = Object.keys : v1 = function(s) {
  var u, h = [];
  for (u in s)
    En(s, u) && h.push(u);
  return h;
};
var IN = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function FN(s, u, h) {
  var m = this._calendar[s] || this._calendar.sameElse;
  return _o(m) ? m.call(u, h) : m;
}
function Do(s, u, h) {
  var m = "" + Math.abs(s), w = u - m.length, T = s >= 0;
  return (T ? h ? "+" : "" : "-") + Math.pow(10, Math.max(0, w)).toString().substr(1) + m;
}
var V1 = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, by = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, Ww = {}, If = {};
function Yt(s, u, h, m) {
  var w = m;
  typeof m == "string" && (w = function() {
    return this[m]();
  }), s && (If[s] = w), u && (If[u[0]] = function() {
    return Do(w.apply(this, arguments), u[1], u[2]);
  }), h && (If[h] = function() {
    return this.localeData().ordinal(
      w.apply(this, arguments),
      s
    );
  });
}
function YN(s) {
  return s.match(/\[[\s\S]/) ? s.replace(/^\[|\]$/g, "") : s.replace(/\\/g, "");
}
function HN(s) {
  var u = s.match(V1), h, m;
  for (h = 0, m = u.length; h < m; h++)
    If[u[h]] ? u[h] = If[u[h]] : u[h] = YN(u[h]);
  return function(w) {
    var T = "", A;
    for (A = 0; A < m; A++)
      T += _o(u[A]) ? u[A].call(w, s) : u[A];
    return T;
  };
}
function Ry(s, u) {
  return s.isValid() ? (u = NE(u, s.localeData()), Ww[u] = Ww[u] || HN(u), Ww[u](s)) : s.localeData().invalidDate();
}
function NE(s, u) {
  var h = 5;
  function m(w) {
    return u.longDateFormat(w) || w;
  }
  for (by.lastIndex = 0; h >= 0 && by.test(s); )
    s = s.replace(
      by,
      m
    ), by.lastIndex = 0, h -= 1;
  return s;
}
var jN = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function BN(s) {
  var u = this._longDateFormat[s], h = this._longDateFormat[s.toUpperCase()];
  return u || !h ? u : (this._longDateFormat[s] = h.match(V1).map(function(m) {
    return m === "MMMM" || m === "MM" || m === "DD" || m === "dddd" ? m.slice(1) : m;
  }).join(""), this._longDateFormat[s]);
}
var WN = "Invalid date";
function UN() {
  return this._invalidDate;
}
var XN = "%d", VN = /\d{1,2}/;
function GN(s) {
  return this._ordinal.replace("%d", s);
}
var $N = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function qN(s, u, h, m) {
  var w = this._relativeTime[h];
  return _o(w) ? w(s, u, h, m) : w.replace(/%d/i, s);
}
function ZN(s, u) {
  var h = this._relativeTime[s > 0 ? "future" : "past"];
  return _o(h) ? h(u) : h.replace(/%s/i, u);
}
var ug = {};
function $a(s, u) {
  var h = s.toLowerCase();
  ug[h] = ug[h + "s"] = ug[u] = s;
}
function us(s) {
  return typeof s == "string" ? ug[s] || ug[s.toLowerCase()] : void 0;
}
function G1(s) {
  var u = {}, h, m;
  for (m in s)
    En(s, m) && (h = us(m), h && (u[h] = s[m]));
  return u;
}
var zE = {};
function qa(s, u) {
  zE[s] = u;
}
function QN(s) {
  var u = [], h;
  for (h in s)
    En(s, h) && u.push({ unit: h, priority: zE[h] });
  return u.sort(function(m, w) {
    return m.priority - w.priority;
  }), u;
}
function Qy(s) {
  return s % 4 === 0 && s % 100 !== 0 || s % 400 === 0;
}
function os(s) {
  return s < 0 ? Math.ceil(s) || 0 : Math.floor(s);
}
function un(s) {
  var u = +s, h = 0;
  return u !== 0 && isFinite(u) && (h = os(u)), h;
}
function jf(s, u) {
  return function(h) {
    return h != null ? (IE(this, s, h), ct.updateOffset(this, u), this) : Hy(this, s);
  };
}
function Hy(s, u) {
  return s.isValid() ? s._d["get" + (s._isUTC ? "UTC" : "") + u]() : NaN;
}
function IE(s, u, h) {
  s.isValid() && !isNaN(h) && (u === "FullYear" && Qy(s.year()) && s.month() === 1 && s.date() === 29 ? (h = un(h), s._d["set" + (s._isUTC ? "UTC" : "") + u](
    h,
    s.month(),
    rx(h, s.month())
  )) : s._d["set" + (s._isUTC ? "UTC" : "") + u](h));
}
function KN(s) {
  return s = us(s), _o(this[s]) ? this[s]() : this;
}
function JN(s, u) {
  if (typeof s == "object") {
    s = G1(s);
    var h = QN(s), m, w = h.length;
    for (m = 0; m < w; m++)
      this[h[m].unit](s[h[m].unit]);
  } else if (s = us(s), _o(this[s]))
    return this[s](u);
  return this;
}
var FE = /\d/, Vi = /\d\d/, YE = /\d{3}/, $1 = /\d{4}/, Ky = /[+-]?\d{6}/, ar = /\d\d?/, HE = /\d\d\d\d?/, jE = /\d\d\d\d\d\d?/, Jy = /\d{1,3}/, q1 = /\d{1,4}/, ex = /[+-]?\d{1,6}/, Bf = /\d+/, tx = /[+-]?\d+/, ez = /Z|[+-]\d\d:?\d\d/gi, nx = /Z|[+-]\d\d(?::?\d\d)?/gi, tz = /[+-]?\d+(\.\d{1,3})?/, kg = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, jy;
jy = {};
function yt(s, u, h) {
  jy[s] = _o(u) ? u : function(m, w) {
    return m && h ? h : u;
  };
}
function nz(s, u) {
  return En(jy, s) ? jy[s](u._strict, u._locale) : new RegExp(rz(s));
}
function rz(s) {
  return Xi(
    s.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(u, h, m, w, T) {
        return h || m || w || T;
      }
    )
  );
}
function Xi(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var y1 = {};
function Hn(s, u) {
  var h, m = u, w;
  for (typeof s == "string" && (s = [s]), El(u) && (m = function(T, A) {
    A[u] = un(T);
  }), w = s.length, h = 0; h < w; h++)
    y1[s[h]] = m;
}
function Cg(s, u) {
  Hn(s, function(h, m, w, T) {
    w._w = w._w || {}, u(h, w._w, w, T);
  });
}
function az(s, u, h) {
  u != null && En(y1, s) && y1[s](u, h._a, h, s);
}
var Ga = 0, Cl = 1, Lo = 2, ea = 3, Bs = 4, Tl = 5, Fc = 6, iz = 7, sz = 8;
function oz(s, u) {
  return (s % u + u) % u;
}
var Or;
Array.prototype.indexOf ? Or = Array.prototype.indexOf : Or = function(s) {
  var u;
  for (u = 0; u < this.length; ++u)
    if (this[u] === s)
      return u;
  return -1;
};
function rx(s, u) {
  if (isNaN(s) || isNaN(u))
    return NaN;
  var h = oz(u, 12);
  return s += (u - h) / 12, h === 1 ? Qy(s) ? 29 : 28 : 31 - h % 7 % 2;
}
Yt("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
Yt("MMM", 0, 0, function(s) {
  return this.localeData().monthsShort(this, s);
});
Yt("MMMM", 0, 0, function(s) {
  return this.localeData().months(this, s);
});
$a("month", "M");
qa("month", 8);
yt("M", ar);
yt("MM", ar, Vi);
yt("MMM", function(s, u) {
  return u.monthsShortRegex(s);
});
yt("MMMM", function(s, u) {
  return u.monthsRegex(s);
});
Hn(["M", "MM"], function(s, u) {
  u[Cl] = un(s) - 1;
});
Hn(["MMM", "MMMM"], function(s, u, h, m) {
  var w = h._locale.monthsParse(s, m, h._strict);
  w != null ? u[Cl] = w : an(h).invalidMonth = s;
});
var lz = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), BE = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), WE = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, uz = kg, cz = kg;
function dz(s, u) {
  return s ? Ws(this._months) ? this._months[s.month()] : this._months[(this._months.isFormat || WE).test(u) ? "format" : "standalone"][s.month()] : Ws(this._months) ? this._months : this._months.standalone;
}
function fz(s, u) {
  return s ? Ws(this._monthsShort) ? this._monthsShort[s.month()] : this._monthsShort[WE.test(u) ? "format" : "standalone"][s.month()] : Ws(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
}
function hz(s, u, h) {
  var m, w, T, A = s.toLocaleLowerCase();
  if (!this._monthsParse)
    for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], m = 0; m < 12; ++m)
      T = Mo([2e3, m]), this._shortMonthsParse[m] = this.monthsShort(
        T,
        ""
      ).toLocaleLowerCase(), this._longMonthsParse[m] = this.months(T, "").toLocaleLowerCase();
  return h ? u === "MMM" ? (w = Or.call(this._shortMonthsParse, A), w !== -1 ? w : null) : (w = Or.call(this._longMonthsParse, A), w !== -1 ? w : null) : u === "MMM" ? (w = Or.call(this._shortMonthsParse, A), w !== -1 ? w : (w = Or.call(this._longMonthsParse, A), w !== -1 ? w : null)) : (w = Or.call(this._longMonthsParse, A), w !== -1 ? w : (w = Or.call(this._shortMonthsParse, A), w !== -1 ? w : null));
}
function pz(s, u, h) {
  var m, w, T;
  if (this._monthsParseExact)
    return hz.call(this, s, u, h);
  for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), m = 0; m < 12; m++) {
    if (w = Mo([2e3, m]), h && !this._longMonthsParse[m] && (this._longMonthsParse[m] = new RegExp(
      "^" + this.months(w, "").replace(".", "") + "$",
      "i"
    ), this._shortMonthsParse[m] = new RegExp(
      "^" + this.monthsShort(w, "").replace(".", "") + "$",
      "i"
    )), !h && !this._monthsParse[m] && (T = "^" + this.months(w, "") + "|^" + this.monthsShort(w, ""), this._monthsParse[m] = new RegExp(T.replace(".", ""), "i")), h && u === "MMMM" && this._longMonthsParse[m].test(s))
      return m;
    if (h && u === "MMM" && this._shortMonthsParse[m].test(s))
      return m;
    if (!h && this._monthsParse[m].test(s))
      return m;
  }
}
function UE(s, u) {
  var h;
  if (!s.isValid())
    return s;
  if (typeof u == "string") {
    if (/^\d+$/.test(u))
      u = un(u);
    else if (u = s.localeData().monthsParse(u), !El(u))
      return s;
  }
  return h = Math.min(s.date(), rx(s.year(), u)), s._d["set" + (s._isUTC ? "UTC" : "") + "Month"](u, h), s;
}
function XE(s) {
  return s != null ? (UE(this, s), ct.updateOffset(this, !0), this) : Hy(this, "Month");
}
function gz() {
  return rx(this.year(), this.month());
}
function mz(s) {
  return this._monthsParseExact ? (En(this, "_monthsRegex") || VE.call(this), s ? this._monthsShortStrictRegex : this._monthsShortRegex) : (En(this, "_monthsShortRegex") || (this._monthsShortRegex = uz), this._monthsShortStrictRegex && s ? this._monthsShortStrictRegex : this._monthsShortRegex);
}
function vz(s) {
  return this._monthsParseExact ? (En(this, "_monthsRegex") || VE.call(this), s ? this._monthsStrictRegex : this._monthsRegex) : (En(this, "_monthsRegex") || (this._monthsRegex = cz), this._monthsStrictRegex && s ? this._monthsStrictRegex : this._monthsRegex);
}
function VE() {
  function s(A, F) {
    return F.length - A.length;
  }
  var u = [], h = [], m = [], w, T;
  for (w = 0; w < 12; w++)
    T = Mo([2e3, w]), u.push(this.monthsShort(T, "")), h.push(this.months(T, "")), m.push(this.months(T, "")), m.push(this.monthsShort(T, ""));
  for (u.sort(s), h.sort(s), m.sort(s), w = 0; w < 12; w++)
    u[w] = Xi(u[w]), h[w] = Xi(h[w]);
  for (w = 0; w < 24; w++)
    m[w] = Xi(m[w]);
  this._monthsRegex = new RegExp("^(" + m.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp(
    "^(" + h.join("|") + ")",
    "i"
  ), this._monthsShortStrictRegex = new RegExp(
    "^(" + u.join("|") + ")",
    "i"
  );
}
Yt("Y", 0, 0, function() {
  var s = this.year();
  return s <= 9999 ? Do(s, 4) : "+" + s;
});
Yt(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
Yt(0, ["YYYY", 4], 0, "year");
Yt(0, ["YYYYY", 5], 0, "year");
Yt(0, ["YYYYYY", 6, !0], 0, "year");
$a("year", "y");
qa("year", 1);
yt("Y", tx);
yt("YY", ar, Vi);
yt("YYYY", q1, $1);
yt("YYYYY", ex, Ky);
yt("YYYYYY", ex, Ky);
Hn(["YYYYY", "YYYYYY"], Ga);
Hn("YYYY", function(s, u) {
  u[Ga] = s.length === 2 ? ct.parseTwoDigitYear(s) : un(s);
});
Hn("YY", function(s, u) {
  u[Ga] = ct.parseTwoDigitYear(s);
});
Hn("Y", function(s, u) {
  u[Ga] = parseInt(s, 10);
});
function cg(s) {
  return Qy(s) ? 366 : 365;
}
ct.parseTwoDigitYear = function(s) {
  return un(s) + (un(s) > 68 ? 1900 : 2e3);
};
var GE = jf("FullYear", !0);
function yz() {
  return Qy(this.year());
}
function xz(s, u, h, m, w, T, A) {
  var F;
  return s < 100 && s >= 0 ? (F = new Date(s + 400, u, h, m, w, T, A), isFinite(F.getFullYear()) && F.setFullYear(s)) : F = new Date(s, u, h, m, w, T, A), F;
}
function mg(s) {
  var u, h;
  return s < 100 && s >= 0 ? (h = Array.prototype.slice.call(arguments), h[0] = s + 400, u = new Date(Date.UTC.apply(null, h)), isFinite(u.getUTCFullYear()) && u.setUTCFullYear(s)) : u = new Date(Date.UTC.apply(null, arguments)), u;
}
function By(s, u, h) {
  var m = 7 + u - h, w = (7 + mg(s, 0, m).getUTCDay() - u) % 7;
  return -w + m - 1;
}
function $E(s, u, h, m, w) {
  var T = (7 + h - m) % 7, A = By(s, m, w), F = 1 + 7 * (u - 1) + T + A, H, j;
  return F <= 0 ? (H = s - 1, j = cg(H) + F) : F > cg(s) ? (H = s + 1, j = F - cg(s)) : (H = s, j = F), {
    year: H,
    dayOfYear: j
  };
}
function vg(s, u, h) {
  var m = By(s.year(), u, h), w = Math.floor((s.dayOfYear() - m - 1) / 7) + 1, T, A;
  return w < 1 ? (A = s.year() - 1, T = w + Al(A, u, h)) : w > Al(s.year(), u, h) ? (T = w - Al(s.year(), u, h), A = s.year() + 1) : (A = s.year(), T = w), {
    week: T,
    year: A
  };
}
function Al(s, u, h) {
  var m = By(s, u, h), w = By(s + 1, u, h);
  return (cg(s) - m + w) / 7;
}
Yt("w", ["ww", 2], "wo", "week");
Yt("W", ["WW", 2], "Wo", "isoWeek");
$a("week", "w");
$a("isoWeek", "W");
qa("week", 5);
qa("isoWeek", 5);
yt("w", ar);
yt("ww", ar, Vi);
yt("W", ar);
yt("WW", ar, Vi);
Cg(
  ["w", "ww", "W", "WW"],
  function(s, u, h, m) {
    u[m.substr(0, 1)] = un(s);
  }
);
function bz(s) {
  return vg(s, this._week.dow, this._week.doy).week;
}
var wz = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function Sz() {
  return this._week.dow;
}
function kz() {
  return this._week.doy;
}
function Cz(s) {
  var u = this.localeData().week(this);
  return s == null ? u : this.add((s - u) * 7, "d");
}
function Tz(s) {
  var u = vg(this, 1, 4).week;
  return s == null ? u : this.add((s - u) * 7, "d");
}
Yt("d", 0, "do", "day");
Yt("dd", 0, 0, function(s) {
  return this.localeData().weekdaysMin(this, s);
});
Yt("ddd", 0, 0, function(s) {
  return this.localeData().weekdaysShort(this, s);
});
Yt("dddd", 0, 0, function(s) {
  return this.localeData().weekdays(this, s);
});
Yt("e", 0, 0, "weekday");
Yt("E", 0, 0, "isoWeekday");
$a("day", "d");
$a("weekday", "e");
$a("isoWeekday", "E");
qa("day", 11);
qa("weekday", 11);
qa("isoWeekday", 11);
yt("d", ar);
yt("e", ar);
yt("E", ar);
yt("dd", function(s, u) {
  return u.weekdaysMinRegex(s);
});
yt("ddd", function(s, u) {
  return u.weekdaysShortRegex(s);
});
yt("dddd", function(s, u) {
  return u.weekdaysRegex(s);
});
Cg(["dd", "ddd", "dddd"], function(s, u, h, m) {
  var w = h._locale.weekdaysParse(s, m, h._strict);
  w != null ? u.d = w : an(h).invalidWeekday = s;
});
Cg(["d", "e", "E"], function(s, u, h, m) {
  u[m] = un(s);
});
function Az(s, u) {
  return typeof s != "string" ? s : isNaN(s) ? (s = u.weekdaysParse(s), typeof s == "number" ? s : null) : parseInt(s, 10);
}
function Ez(s, u) {
  return typeof s == "string" ? u.weekdaysParse(s) % 7 || 7 : isNaN(s) ? null : s;
}
function Z1(s, u) {
  return s.slice(u, 7).concat(s.slice(0, u));
}
var Rz = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), qE = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), Lz = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), Oz = kg, Dz = kg, Mz = kg;
function _z(s, u) {
  var h = Ws(this._weekdays) ? this._weekdays : this._weekdays[s && s !== !0 && this._weekdays.isFormat.test(u) ? "format" : "standalone"];
  return s === !0 ? Z1(h, this._week.dow) : s ? h[s.day()] : h;
}
function Pz(s) {
  return s === !0 ? Z1(this._weekdaysShort, this._week.dow) : s ? this._weekdaysShort[s.day()] : this._weekdaysShort;
}
function Nz(s) {
  return s === !0 ? Z1(this._weekdaysMin, this._week.dow) : s ? this._weekdaysMin[s.day()] : this._weekdaysMin;
}
function zz(s, u, h) {
  var m, w, T, A = s.toLocaleLowerCase();
  if (!this._weekdaysParse)
    for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], m = 0; m < 7; ++m)
      T = Mo([2e3, 1]).day(m), this._minWeekdaysParse[m] = this.weekdaysMin(
        T,
        ""
      ).toLocaleLowerCase(), this._shortWeekdaysParse[m] = this.weekdaysShort(
        T,
        ""
      ).toLocaleLowerCase(), this._weekdaysParse[m] = this.weekdays(T, "").toLocaleLowerCase();
  return h ? u === "dddd" ? (w = Or.call(this._weekdaysParse, A), w !== -1 ? w : null) : u === "ddd" ? (w = Or.call(this._shortWeekdaysParse, A), w !== -1 ? w : null) : (w = Or.call(this._minWeekdaysParse, A), w !== -1 ? w : null) : u === "dddd" ? (w = Or.call(this._weekdaysParse, A), w !== -1 || (w = Or.call(this._shortWeekdaysParse, A), w !== -1) ? w : (w = Or.call(this._minWeekdaysParse, A), w !== -1 ? w : null)) : u === "ddd" ? (w = Or.call(this._shortWeekdaysParse, A), w !== -1 || (w = Or.call(this._weekdaysParse, A), w !== -1) ? w : (w = Or.call(this._minWeekdaysParse, A), w !== -1 ? w : null)) : (w = Or.call(this._minWeekdaysParse, A), w !== -1 || (w = Or.call(this._weekdaysParse, A), w !== -1) ? w : (w = Or.call(this._shortWeekdaysParse, A), w !== -1 ? w : null));
}
function Iz(s, u, h) {
  var m, w, T;
  if (this._weekdaysParseExact)
    return zz.call(this, s, u, h);
  for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), m = 0; m < 7; m++) {
    if (w = Mo([2e3, 1]).day(m), h && !this._fullWeekdaysParse[m] && (this._fullWeekdaysParse[m] = new RegExp(
      "^" + this.weekdays(w, "").replace(".", "\\.?") + "$",
      "i"
    ), this._shortWeekdaysParse[m] = new RegExp(
      "^" + this.weekdaysShort(w, "").replace(".", "\\.?") + "$",
      "i"
    ), this._minWeekdaysParse[m] = new RegExp(
      "^" + this.weekdaysMin(w, "").replace(".", "\\.?") + "$",
      "i"
    )), this._weekdaysParse[m] || (T = "^" + this.weekdays(w, "") + "|^" + this.weekdaysShort(w, "") + "|^" + this.weekdaysMin(w, ""), this._weekdaysParse[m] = new RegExp(T.replace(".", ""), "i")), h && u === "dddd" && this._fullWeekdaysParse[m].test(s))
      return m;
    if (h && u === "ddd" && this._shortWeekdaysParse[m].test(s))
      return m;
    if (h && u === "dd" && this._minWeekdaysParse[m].test(s))
      return m;
    if (!h && this._weekdaysParse[m].test(s))
      return m;
  }
}
function Fz(s) {
  if (!this.isValid())
    return s != null ? this : NaN;
  var u = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  return s != null ? (s = Az(s, this.localeData()), this.add(s - u, "d")) : u;
}
function Yz(s) {
  if (!this.isValid())
    return s != null ? this : NaN;
  var u = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return s == null ? u : this.add(s - u, "d");
}
function Hz(s) {
  if (!this.isValid())
    return s != null ? this : NaN;
  if (s != null) {
    var u = Ez(s, this.localeData());
    return this.day(this.day() % 7 ? u : u - 7);
  } else
    return this.day() || 7;
}
function jz(s) {
  return this._weekdaysParseExact ? (En(this, "_weekdaysRegex") || Q1.call(this), s ? this._weekdaysStrictRegex : this._weekdaysRegex) : (En(this, "_weekdaysRegex") || (this._weekdaysRegex = Oz), this._weekdaysStrictRegex && s ? this._weekdaysStrictRegex : this._weekdaysRegex);
}
function Bz(s) {
  return this._weekdaysParseExact ? (En(this, "_weekdaysRegex") || Q1.call(this), s ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (En(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = Dz), this._weekdaysShortStrictRegex && s ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
}
function Wz(s) {
  return this._weekdaysParseExact ? (En(this, "_weekdaysRegex") || Q1.call(this), s ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (En(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = Mz), this._weekdaysMinStrictRegex && s ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
}
function Q1() {
  function s(V, q) {
    return q.length - V.length;
  }
  var u = [], h = [], m = [], w = [], T, A, F, H, j;
  for (T = 0; T < 7; T++)
    A = Mo([2e3, 1]).day(T), F = Xi(this.weekdaysMin(A, "")), H = Xi(this.weekdaysShort(A, "")), j = Xi(this.weekdays(A, "")), u.push(F), h.push(H), m.push(j), w.push(F), w.push(H), w.push(j);
  u.sort(s), h.sort(s), m.sort(s), w.sort(s), this._weekdaysRegex = new RegExp("^(" + w.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp(
    "^(" + m.join("|") + ")",
    "i"
  ), this._weekdaysShortStrictRegex = new RegExp(
    "^(" + h.join("|") + ")",
    "i"
  ), this._weekdaysMinStrictRegex = new RegExp(
    "^(" + u.join("|") + ")",
    "i"
  );
}
function K1() {
  return this.hours() % 12 || 12;
}
function Uz() {
  return this.hours() || 24;
}
Yt("H", ["HH", 2], 0, "hour");
Yt("h", ["hh", 2], 0, K1);
Yt("k", ["kk", 2], 0, Uz);
Yt("hmm", 0, 0, function() {
  return "" + K1.apply(this) + Do(this.minutes(), 2);
});
Yt("hmmss", 0, 0, function() {
  return "" + K1.apply(this) + Do(this.minutes(), 2) + Do(this.seconds(), 2);
});
Yt("Hmm", 0, 0, function() {
  return "" + this.hours() + Do(this.minutes(), 2);
});
Yt("Hmmss", 0, 0, function() {
  return "" + this.hours() + Do(this.minutes(), 2) + Do(this.seconds(), 2);
});
function ZE(s, u) {
  Yt(s, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      u
    );
  });
}
ZE("a", !0);
ZE("A", !1);
$a("hour", "h");
qa("hour", 13);
function QE(s, u) {
  return u._meridiemParse;
}
yt("a", QE);
yt("A", QE);
yt("H", ar);
yt("h", ar);
yt("k", ar);
yt("HH", ar, Vi);
yt("hh", ar, Vi);
yt("kk", ar, Vi);
yt("hmm", HE);
yt("hmmss", jE);
yt("Hmm", HE);
yt("Hmmss", jE);
Hn(["H", "HH"], ea);
Hn(["k", "kk"], function(s, u, h) {
  var m = un(s);
  u[ea] = m === 24 ? 0 : m;
});
Hn(["a", "A"], function(s, u, h) {
  h._isPm = h._locale.isPM(s), h._meridiem = s;
});
Hn(["h", "hh"], function(s, u, h) {
  u[ea] = un(s), an(h).bigHour = !0;
});
Hn("hmm", function(s, u, h) {
  var m = s.length - 2;
  u[ea] = un(s.substr(0, m)), u[Bs] = un(s.substr(m)), an(h).bigHour = !0;
});
Hn("hmmss", function(s, u, h) {
  var m = s.length - 4, w = s.length - 2;
  u[ea] = un(s.substr(0, m)), u[Bs] = un(s.substr(m, 2)), u[Tl] = un(s.substr(w)), an(h).bigHour = !0;
});
Hn("Hmm", function(s, u, h) {
  var m = s.length - 2;
  u[ea] = un(s.substr(0, m)), u[Bs] = un(s.substr(m));
});
Hn("Hmmss", function(s, u, h) {
  var m = s.length - 4, w = s.length - 2;
  u[ea] = un(s.substr(0, m)), u[Bs] = un(s.substr(m, 2)), u[Tl] = un(s.substr(w));
});
function Xz(s) {
  return (s + "").toLowerCase().charAt(0) === "p";
}
var Vz = /[ap]\.?m?\.?/i, Gz = jf("Hours", !0);
function $z(s, u, h) {
  return s > 11 ? h ? "pm" : "PM" : h ? "am" : "AM";
}
var KE = {
  calendar: IN,
  longDateFormat: jN,
  invalidDate: WN,
  ordinal: XN,
  dayOfMonthOrdinalParse: VN,
  relativeTime: $N,
  months: lz,
  monthsShort: BE,
  week: wz,
  weekdays: Rz,
  weekdaysMin: Lz,
  weekdaysShort: qE,
  meridiemParse: Vz
}, dr = {}, rg = {}, yg;
function qz(s, u) {
  var h, m = Math.min(s.length, u.length);
  for (h = 0; h < m; h += 1)
    if (s[h] !== u[h])
      return h;
  return m;
}
function kA(s) {
  return s && s.toLowerCase().replace("_", "-");
}
function Zz(s) {
  for (var u = 0, h, m, w, T; u < s.length; ) {
    for (T = kA(s[u]).split("-"), h = T.length, m = kA(s[u + 1]), m = m ? m.split("-") : null; h > 0; ) {
      if (w = ax(T.slice(0, h).join("-")), w)
        return w;
      if (m && m.length >= h && qz(T, m) >= h - 1)
        break;
      h--;
    }
    u++;
  }
  return yg;
}
function Qz(s) {
  return s.match("^[^/\\\\]*$") != null;
}
function ax(s) {
  var u = null, h;
  if (dr[s] === void 0 && typeof module < "u" && module && module.exports && Qz(s))
    try {
      u = yg._abbr, h = require, h("./locale/" + s), Ou(u);
    } catch {
      dr[s] = null;
    }
  return dr[s];
}
function Ou(s, u) {
  var h;
  return s && (Mi(u) ? h = Rl(s) : h = J1(s, u), h ? yg = h : typeof console < "u" && console.warn && console.warn(
    "Locale " + s + " not found. Did you forget to load it?"
  )), yg._abbr;
}
function J1(s, u) {
  if (u !== null) {
    var h, m = KE;
    if (u.abbr = s, dr[s] != null)
      PE(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      ), m = dr[s]._config;
    else if (u.parentLocale != null)
      if (dr[u.parentLocale] != null)
        m = dr[u.parentLocale]._config;
      else if (h = ax(u.parentLocale), h != null)
        m = h._config;
      else
        return rg[u.parentLocale] || (rg[u.parentLocale] = []), rg[u.parentLocale].push({
          name: s,
          config: u
        }), null;
    return dr[s] = new X1(m1(m, u)), rg[s] && rg[s].forEach(function(w) {
      J1(w.name, w.config);
    }), Ou(s), dr[s];
  } else
    return delete dr[s], null;
}
function Kz(s, u) {
  if (u != null) {
    var h, m, w = KE;
    dr[s] != null && dr[s].parentLocale != null ? dr[s].set(m1(dr[s]._config, u)) : (m = ax(s), m != null && (w = m._config), u = m1(w, u), m == null && (u.abbr = s), h = new X1(u), h.parentLocale = dr[s], dr[s] = h), Ou(s);
  } else
    dr[s] != null && (dr[s].parentLocale != null ? (dr[s] = dr[s].parentLocale, s === Ou() && Ou(s)) : dr[s] != null && delete dr[s]);
  return dr[s];
}
function Rl(s) {
  var u;
  if (s && s._locale && s._locale._abbr && (s = s._locale._abbr), !s)
    return yg;
  if (!Ws(s)) {
    if (u = ax(s), u)
      return u;
    s = [s];
  }
  return Zz(s);
}
function Jz() {
  return v1(dr);
}
function eS(s) {
  var u, h = s._a;
  return h && an(s).overflow === -2 && (u = h[Cl] < 0 || h[Cl] > 11 ? Cl : h[Lo] < 1 || h[Lo] > rx(h[Ga], h[Cl]) ? Lo : h[ea] < 0 || h[ea] > 24 || h[ea] === 24 && (h[Bs] !== 0 || h[Tl] !== 0 || h[Fc] !== 0) ? ea : h[Bs] < 0 || h[Bs] > 59 ? Bs : h[Tl] < 0 || h[Tl] > 59 ? Tl : h[Fc] < 0 || h[Fc] > 999 ? Fc : -1, an(s)._overflowDayOfYear && (u < Ga || u > Lo) && (u = Lo), an(s)._overflowWeeks && u === -1 && (u = iz), an(s)._overflowWeekday && u === -1 && (u = sz), an(s).overflow = u), s;
}
var eI = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tI = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, nI = /Z|[+-]\d\d(?::?\d\d)?/, wy = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, !1],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, !1],
  ["YYYY", /\d{4}/, !1]
], Uw = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], rI = /^\/?Date\((-?\d+)/i, aI = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, iI = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function JE(s) {
  var u, h, m = s._i, w = eI.exec(m) || tI.exec(m), T, A, F, H, j = wy.length, V = Uw.length;
  if (w) {
    for (an(s).iso = !0, u = 0, h = j; u < h; u++)
      if (wy[u][1].exec(w[1])) {
        A = wy[u][0], T = wy[u][2] !== !1;
        break;
      }
    if (A == null) {
      s._isValid = !1;
      return;
    }
    if (w[3]) {
      for (u = 0, h = V; u < h; u++)
        if (Uw[u][1].exec(w[3])) {
          F = (w[2] || " ") + Uw[u][0];
          break;
        }
      if (F == null) {
        s._isValid = !1;
        return;
      }
    }
    if (!T && F != null) {
      s._isValid = !1;
      return;
    }
    if (w[4])
      if (nI.exec(w[4]))
        H = "Z";
      else {
        s._isValid = !1;
        return;
      }
    s._f = A + (F || "") + (H || ""), nS(s);
  } else
    s._isValid = !1;
}
function sI(s, u, h, m, w, T) {
  var A = [
    oI(s),
    BE.indexOf(u),
    parseInt(h, 10),
    parseInt(m, 10),
    parseInt(w, 10)
  ];
  return T && A.push(parseInt(T, 10)), A;
}
function oI(s) {
  var u = parseInt(s, 10);
  return u <= 49 ? 2e3 + u : u <= 999 ? 1900 + u : u;
}
function lI(s) {
  return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function uI(s, u, h) {
  if (s) {
    var m = qE.indexOf(s), w = new Date(
      u[0],
      u[1],
      u[2]
    ).getDay();
    if (m !== w)
      return an(h).weekdayMismatch = !0, h._isValid = !1, !1;
  }
  return !0;
}
function cI(s, u, h) {
  if (s)
    return iI[s];
  if (u)
    return 0;
  var m = parseInt(h, 10), w = m % 100, T = (m - w) / 100;
  return T * 60 + w;
}
function eR(s) {
  var u = aI.exec(lI(s._i)), h;
  if (u) {
    if (h = sI(
      u[4],
      u[3],
      u[2],
      u[5],
      u[6],
      u[7]
    ), !uI(u[1], h, s))
      return;
    s._a = h, s._tzm = cI(u[8], u[9], u[10]), s._d = mg.apply(null, s._a), s._d.setUTCMinutes(s._d.getUTCMinutes() - s._tzm), an(s).rfc2822 = !0;
  } else
    s._isValid = !1;
}
function dI(s) {
  var u = rI.exec(s._i);
  if (u !== null) {
    s._d = /* @__PURE__ */ new Date(+u[1]);
    return;
  }
  if (JE(s), s._isValid === !1)
    delete s._isValid;
  else
    return;
  if (eR(s), s._isValid === !1)
    delete s._isValid;
  else
    return;
  s._strict ? s._isValid = !1 : ct.createFromInputFallback(s);
}
ct.createFromInputFallback = ls(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(s) {
    s._d = /* @__PURE__ */ new Date(s._i + (s._useUTC ? " UTC" : ""));
  }
);
function Nf(s, u, h) {
  return s ?? u ?? h;
}
function fI(s) {
  var u = new Date(ct.now());
  return s._useUTC ? [
    u.getUTCFullYear(),
    u.getUTCMonth(),
    u.getUTCDate()
  ] : [u.getFullYear(), u.getMonth(), u.getDate()];
}
function tS(s) {
  var u, h, m = [], w, T, A;
  if (!s._d) {
    for (w = fI(s), s._w && s._a[Lo] == null && s._a[Cl] == null && hI(s), s._dayOfYear != null && (A = Nf(s._a[Ga], w[Ga]), (s._dayOfYear > cg(A) || s._dayOfYear === 0) && (an(s)._overflowDayOfYear = !0), h = mg(A, 0, s._dayOfYear), s._a[Cl] = h.getUTCMonth(), s._a[Lo] = h.getUTCDate()), u = 0; u < 3 && s._a[u] == null; ++u)
      s._a[u] = m[u] = w[u];
    for (; u < 7; u++)
      s._a[u] = m[u] = s._a[u] == null ? u === 2 ? 1 : 0 : s._a[u];
    s._a[ea] === 24 && s._a[Bs] === 0 && s._a[Tl] === 0 && s._a[Fc] === 0 && (s._nextDay = !0, s._a[ea] = 0), s._d = (s._useUTC ? mg : xz).apply(
      null,
      m
    ), T = s._useUTC ? s._d.getUTCDay() : s._d.getDay(), s._tzm != null && s._d.setUTCMinutes(s._d.getUTCMinutes() - s._tzm), s._nextDay && (s._a[ea] = 24), s._w && typeof s._w.d < "u" && s._w.d !== T && (an(s).weekdayMismatch = !0);
  }
}
function hI(s) {
  var u, h, m, w, T, A, F, H, j;
  u = s._w, u.GG != null || u.W != null || u.E != null ? (T = 1, A = 4, h = Nf(
    u.GG,
    s._a[Ga],
    vg(rr(), 1, 4).year
  ), m = Nf(u.W, 1), w = Nf(u.E, 1), (w < 1 || w > 7) && (H = !0)) : (T = s._locale._week.dow, A = s._locale._week.doy, j = vg(rr(), T, A), h = Nf(u.gg, s._a[Ga], j.year), m = Nf(u.w, j.week), u.d != null ? (w = u.d, (w < 0 || w > 6) && (H = !0)) : u.e != null ? (w = u.e + T, (u.e < 0 || u.e > 6) && (H = !0)) : w = T), m < 1 || m > Al(h, T, A) ? an(s)._overflowWeeks = !0 : H != null ? an(s)._overflowWeekday = !0 : (F = $E(h, m, w, T, A), s._a[Ga] = F.year, s._dayOfYear = F.dayOfYear);
}
ct.ISO_8601 = function() {
};
ct.RFC_2822 = function() {
};
function nS(s) {
  if (s._f === ct.ISO_8601) {
    JE(s);
    return;
  }
  if (s._f === ct.RFC_2822) {
    eR(s);
    return;
  }
  s._a = [], an(s).empty = !0;
  var u = "" + s._i, h, m, w, T, A, F = u.length, H = 0, j, V;
  for (w = NE(s._f, s._locale).match(V1) || [], V = w.length, h = 0; h < V; h++)
    T = w[h], m = (u.match(nz(T, s)) || [])[0], m && (A = u.substr(0, u.indexOf(m)), A.length > 0 && an(s).unusedInput.push(A), u = u.slice(
      u.indexOf(m) + m.length
    ), H += m.length), If[T] ? (m ? an(s).empty = !1 : an(s).unusedTokens.push(T), az(T, m, s)) : s._strict && !m && an(s).unusedTokens.push(T);
  an(s).charsLeftOver = F - H, u.length > 0 && an(s).unusedInput.push(u), s._a[ea] <= 12 && an(s).bigHour === !0 && s._a[ea] > 0 && (an(s).bigHour = void 0), an(s).parsedDateParts = s._a.slice(0), an(s).meridiem = s._meridiem, s._a[ea] = pI(
    s._locale,
    s._a[ea],
    s._meridiem
  ), j = an(s).era, j !== null && (s._a[Ga] = s._locale.erasConvertYear(j, s._a[Ga])), tS(s), eS(s);
}
function pI(s, u, h) {
  var m;
  return h == null ? u : s.meridiemHour != null ? s.meridiemHour(u, h) : (s.isPM != null && (m = s.isPM(h), m && u < 12 && (u += 12), !m && u === 12 && (u = 0)), u);
}
function gI(s) {
  var u, h, m, w, T, A, F = !1, H = s._f.length;
  if (H === 0) {
    an(s).invalidFormat = !0, s._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (w = 0; w < H; w++)
    T = 0, A = !1, u = U1({}, s), s._useUTC != null && (u._useUTC = s._useUTC), u._f = s._f[w], nS(u), W1(u) && (A = !0), T += an(u).charsLeftOver, T += an(u).unusedTokens.length * 10, an(u).score = T, F ? T < m && (m = T, h = u) : (m == null || T < m || A) && (m = T, h = u, A && (F = !0));
  Ru(s, h || u);
}
function mI(s) {
  if (!s._d) {
    var u = G1(s._i), h = u.day === void 0 ? u.date : u.day;
    s._a = ME(
      [u.year, u.month, h, u.hour, u.minute, u.second, u.millisecond],
      function(m) {
        return m && parseInt(m, 10);
      }
    ), tS(s);
  }
}
function vI(s) {
  var u = new Sg(eS(tR(s)));
  return u._nextDay && (u.add(1, "d"), u._nextDay = void 0), u;
}
function tR(s) {
  var u = s._i, h = s._f;
  return s._locale = s._locale || Rl(s._l), u === null || h === void 0 && u === "" ? Zy({ nullInput: !0 }) : (typeof u == "string" && (s._i = u = s._locale.preparse(u)), Us(u) ? new Sg(eS(u)) : (wg(u) ? s._d = u : Ws(h) ? gI(s) : h ? nS(s) : yI(s), W1(s) || (s._d = null), s));
}
function yI(s) {
  var u = s._i;
  Mi(u) ? s._d = new Date(ct.now()) : wg(u) ? s._d = new Date(u.valueOf()) : typeof u == "string" ? dI(s) : Ws(u) ? (s._a = ME(u.slice(0), function(h) {
    return parseInt(h, 10);
  }), tS(s)) : Yc(u) ? mI(s) : El(u) ? s._d = new Date(u) : ct.createFromInputFallback(s);
}
function nR(s, u, h, m, w) {
  var T = {};
  return (u === !0 || u === !1) && (m = u, u = void 0), (h === !0 || h === !1) && (m = h, h = void 0), (Yc(s) && B1(s) || Ws(s) && s.length === 0) && (s = void 0), T._isAMomentObject = !0, T._useUTC = T._isUTC = w, T._l = h, T._i = s, T._f = u, T._strict = m, vI(T);
}
function rr(s, u, h, m) {
  return nR(s, u, h, m, !1);
}
var xI = ls(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var s = rr.apply(null, arguments);
    return this.isValid() && s.isValid() ? s < this ? this : s : Zy();
  }
), bI = ls(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var s = rr.apply(null, arguments);
    return this.isValid() && s.isValid() ? s > this ? this : s : Zy();
  }
);
function rR(s, u) {
  var h, m;
  if (u.length === 1 && Ws(u[0]) && (u = u[0]), !u.length)
    return rr();
  for (h = u[0], m = 1; m < u.length; ++m)
    (!u[m].isValid() || u[m][s](h)) && (h = u[m]);
  return h;
}
function wI() {
  var s = [].slice.call(arguments, 0);
  return rR("isBefore", s);
}
function SI() {
  var s = [].slice.call(arguments, 0);
  return rR("isAfter", s);
}
var kI = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
}, ag = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function CI(s) {
  var u, h = !1, m, w = ag.length;
  for (u in s)
    if (En(s, u) && !(Or.call(ag, u) !== -1 && (s[u] == null || !isNaN(s[u]))))
      return !1;
  for (m = 0; m < w; ++m)
    if (s[ag[m]]) {
      if (h)
        return !1;
      parseFloat(s[ag[m]]) !== un(s[ag[m]]) && (h = !0);
    }
  return !0;
}
function TI() {
  return this._isValid;
}
function AI() {
  return Xs(NaN);
}
function ix(s) {
  var u = G1(s), h = u.year || 0, m = u.quarter || 0, w = u.month || 0, T = u.week || u.isoWeek || 0, A = u.day || 0, F = u.hour || 0, H = u.minute || 0, j = u.second || 0, V = u.millisecond || 0;
  this._isValid = CI(u), this._milliseconds = +V + j * 1e3 + // 1000
  H * 6e4 + // 1000 * 60
  F * 1e3 * 60 * 60, this._days = +A + T * 7, this._months = +w + m * 3 + h * 12, this._data = {}, this._locale = Rl(), this._bubble();
}
function Ly(s) {
  return s instanceof ix;
}
function x1(s) {
  return s < 0 ? Math.round(-1 * s) * -1 : Math.round(s);
}
function EI(s, u, h) {
  var m = Math.min(s.length, u.length), w = Math.abs(s.length - u.length), T = 0, A;
  for (A = 0; A < m; A++)
    (h && s[A] !== u[A] || !h && un(s[A]) !== un(u[A])) && T++;
  return T + w;
}
function aR(s, u) {
  Yt(s, 0, 0, function() {
    var h = this.utcOffset(), m = "+";
    return h < 0 && (h = -h, m = "-"), m + Do(~~(h / 60), 2) + u + Do(~~h % 60, 2);
  });
}
aR("Z", ":");
aR("ZZ", "");
yt("Z", nx);
yt("ZZ", nx);
Hn(["Z", "ZZ"], function(s, u, h) {
  h._useUTC = !0, h._tzm = rS(nx, s);
});
var RI = /([\+\-]|\d\d)/gi;
function rS(s, u) {
  var h = (u || "").match(s), m, w, T;
  return h === null ? null : (m = h[h.length - 1] || [], w = (m + "").match(RI) || ["-", 0, 0], T = +(w[1] * 60) + un(w[2]), T === 0 ? 0 : w[0] === "+" ? T : -T);
}
function aS(s, u) {
  var h, m;
  return u._isUTC ? (h = u.clone(), m = (Us(s) || wg(s) ? s.valueOf() : rr(s).valueOf()) - h.valueOf(), h._d.setTime(h._d.valueOf() + m), ct.updateOffset(h, !1), h) : rr(s).local();
}
function b1(s) {
  return -Math.round(s._d.getTimezoneOffset());
}
ct.updateOffset = function() {
};
function LI(s, u, h) {
  var m = this._offset || 0, w;
  if (!this.isValid())
    return s != null ? this : NaN;
  if (s != null) {
    if (typeof s == "string") {
      if (s = rS(nx, s), s === null)
        return this;
    } else
      Math.abs(s) < 16 && !h && (s = s * 60);
    return !this._isUTC && u && (w = b1(this)), this._offset = s, this._isUTC = !0, w != null && this.add(w, "m"), m !== s && (!u || this._changeInProgress ? oR(
      this,
      Xs(s - m, "m"),
      1,
      !1
    ) : this._changeInProgress || (this._changeInProgress = !0, ct.updateOffset(this, !0), this._changeInProgress = null)), this;
  } else
    return this._isUTC ? m : b1(this);
}
function OI(s, u) {
  return s != null ? (typeof s != "string" && (s = -s), this.utcOffset(s, u), this) : -this.utcOffset();
}
function DI(s) {
  return this.utcOffset(0, s);
}
function MI(s) {
  return this._isUTC && (this.utcOffset(0, s), this._isUTC = !1, s && this.subtract(b1(this), "m")), this;
}
function _I() {
  if (this._tzm != null)
    this.utcOffset(this._tzm, !1, !0);
  else if (typeof this._i == "string") {
    var s = rS(ez, this._i);
    s != null ? this.utcOffset(s) : this.utcOffset(0, !0);
  }
  return this;
}
function PI(s) {
  return this.isValid() ? (s = s ? rr(s).utcOffset() : 0, (this.utcOffset() - s) % 60 === 0) : !1;
}
function NI() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function zI() {
  if (!Mi(this._isDSTShifted))
    return this._isDSTShifted;
  var s = {}, u;
  return U1(s, this), s = tR(s), s._a ? (u = s._isUTC ? Mo(s._a) : rr(s._a), this._isDSTShifted = this.isValid() && EI(s._a, u.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted;
}
function II() {
  return this.isValid() ? !this._isUTC : !1;
}
function FI() {
  return this.isValid() ? this._isUTC : !1;
}
function iR() {
  return this.isValid() ? this._isUTC && this._offset === 0 : !1;
}
var YI = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, HI = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function Xs(s, u) {
  var h = s, m = null, w, T, A;
  return Ly(s) ? h = {
    ms: s._milliseconds,
    d: s._days,
    M: s._months
  } : El(s) || !isNaN(+s) ? (h = {}, u ? h[u] = +s : h.milliseconds = +s) : (m = YI.exec(s)) ? (w = m[1] === "-" ? -1 : 1, h = {
    y: 0,
    d: un(m[Lo]) * w,
    h: un(m[ea]) * w,
    m: un(m[Bs]) * w,
    s: un(m[Tl]) * w,
    ms: un(x1(m[Fc] * 1e3)) * w
    // the millisecond decimal point is included in the match
  }) : (m = HI.exec(s)) ? (w = m[1] === "-" ? -1 : 1, h = {
    y: Ic(m[2], w),
    M: Ic(m[3], w),
    w: Ic(m[4], w),
    d: Ic(m[5], w),
    h: Ic(m[6], w),
    m: Ic(m[7], w),
    s: Ic(m[8], w)
  }) : h == null ? h = {} : typeof h == "object" && ("from" in h || "to" in h) && (A = jI(
    rr(h.from),
    rr(h.to)
  ), h = {}, h.ms = A.milliseconds, h.M = A.months), T = new ix(h), Ly(s) && En(s, "_locale") && (T._locale = s._locale), Ly(s) && En(s, "_isValid") && (T._isValid = s._isValid), T;
}
Xs.fn = ix.prototype;
Xs.invalid = AI;
function Ic(s, u) {
  var h = s && parseFloat(s.replace(",", "."));
  return (isNaN(h) ? 0 : h) * u;
}
function CA(s, u) {
  var h = {};
  return h.months = u.month() - s.month() + (u.year() - s.year()) * 12, s.clone().add(h.months, "M").isAfter(u) && --h.months, h.milliseconds = +u - +s.clone().add(h.months, "M"), h;
}
function jI(s, u) {
  var h;
  return s.isValid() && u.isValid() ? (u = aS(u, s), s.isBefore(u) ? h = CA(s, u) : (h = CA(u, s), h.milliseconds = -h.milliseconds, h.months = -h.months), h) : { milliseconds: 0, months: 0 };
}
function sR(s, u) {
  return function(h, m) {
    var w, T;
    return m !== null && !isNaN(+m) && (PE(
      u,
      "moment()." + u + "(period, number) is deprecated. Please use moment()." + u + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
    ), T = h, h = m, m = T), w = Xs(h, m), oR(this, w, s), this;
  };
}
function oR(s, u, h, m) {
  var w = u._milliseconds, T = x1(u._days), A = x1(u._months);
  s.isValid() && (m = m ?? !0, A && UE(s, Hy(s, "Month") + A * h), T && IE(s, "Date", Hy(s, "Date") + T * h), w && s._d.setTime(s._d.valueOf() + w * h), m && ct.updateOffset(s, T || A));
}
var BI = sR(1, "add"), WI = sR(-1, "subtract");
function lR(s) {
  return typeof s == "string" || s instanceof String;
}
function UI(s) {
  return Us(s) || wg(s) || lR(s) || El(s) || VI(s) || XI(s) || s === null || s === void 0;
}
function XI(s) {
  var u = Yc(s) && !B1(s), h = !1, m = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], w, T, A = m.length;
  for (w = 0; w < A; w += 1)
    T = m[w], h = h || En(s, T);
  return u && h;
}
function VI(s) {
  var u = Ws(s), h = !1;
  return u && (h = s.filter(function(m) {
    return !El(m) && lR(s);
  }).length === 0), u && h;
}
function GI(s) {
  var u = Yc(s) && !B1(s), h = !1, m = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], w, T;
  for (w = 0; w < m.length; w += 1)
    T = m[w], h = h || En(s, T);
  return u && h;
}
function $I(s, u) {
  var h = s.diff(u, "days", !0);
  return h < -6 ? "sameElse" : h < -1 ? "lastWeek" : h < 0 ? "lastDay" : h < 1 ? "sameDay" : h < 2 ? "nextDay" : h < 7 ? "nextWeek" : "sameElse";
}
function qI(s, u) {
  arguments.length === 1 && (arguments[0] ? UI(arguments[0]) ? (s = arguments[0], u = void 0) : GI(arguments[0]) && (u = arguments[0], s = void 0) : (s = void 0, u = void 0));
  var h = s || rr(), m = aS(h, this).startOf("day"), w = ct.calendarFormat(this, m) || "sameElse", T = u && (_o(u[w]) ? u[w].call(this, h) : u[w]);
  return this.format(
    T || this.localeData().calendar(w, this, rr(h))
  );
}
function ZI() {
  return new Sg(this);
}
function QI(s, u) {
  var h = Us(s) ? s : rr(s);
  return this.isValid() && h.isValid() ? (u = us(u) || "millisecond", u === "millisecond" ? this.valueOf() > h.valueOf() : h.valueOf() < this.clone().startOf(u).valueOf()) : !1;
}
function KI(s, u) {
  var h = Us(s) ? s : rr(s);
  return this.isValid() && h.isValid() ? (u = us(u) || "millisecond", u === "millisecond" ? this.valueOf() < h.valueOf() : this.clone().endOf(u).valueOf() < h.valueOf()) : !1;
}
function JI(s, u, h, m) {
  var w = Us(s) ? s : rr(s), T = Us(u) ? u : rr(u);
  return this.isValid() && w.isValid() && T.isValid() ? (m = m || "()", (m[0] === "(" ? this.isAfter(w, h) : !this.isBefore(w, h)) && (m[1] === ")" ? this.isBefore(T, h) : !this.isAfter(T, h))) : !1;
}
function eF(s, u) {
  var h = Us(s) ? s : rr(s), m;
  return this.isValid() && h.isValid() ? (u = us(u) || "millisecond", u === "millisecond" ? this.valueOf() === h.valueOf() : (m = h.valueOf(), this.clone().startOf(u).valueOf() <= m && m <= this.clone().endOf(u).valueOf())) : !1;
}
function tF(s, u) {
  return this.isSame(s, u) || this.isAfter(s, u);
}
function nF(s, u) {
  return this.isSame(s, u) || this.isBefore(s, u);
}
function rF(s, u, h) {
  var m, w, T;
  if (!this.isValid())
    return NaN;
  if (m = aS(s, this), !m.isValid())
    return NaN;
  switch (w = (m.utcOffset() - this.utcOffset()) * 6e4, u = us(u), u) {
    case "year":
      T = Oy(this, m) / 12;
      break;
    case "month":
      T = Oy(this, m);
      break;
    case "quarter":
      T = Oy(this, m) / 3;
      break;
    case "second":
      T = (this - m) / 1e3;
      break;
    case "minute":
      T = (this - m) / 6e4;
      break;
    case "hour":
      T = (this - m) / 36e5;
      break;
    case "day":
      T = (this - m - w) / 864e5;
      break;
    case "week":
      T = (this - m - w) / 6048e5;
      break;
    default:
      T = this - m;
  }
  return h ? T : os(T);
}
function Oy(s, u) {
  if (s.date() < u.date())
    return -Oy(u, s);
  var h = (u.year() - s.year()) * 12 + (u.month() - s.month()), m = s.clone().add(h, "months"), w, T;
  return u - m < 0 ? (w = s.clone().add(h - 1, "months"), T = (u - m) / (m - w)) : (w = s.clone().add(h + 1, "months"), T = (u - m) / (w - m)), -(h + T) || 0;
}
ct.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
ct.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function aF() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function iF(s) {
  if (!this.isValid())
    return null;
  var u = s !== !0, h = u ? this.clone().utc() : this;
  return h.year() < 0 || h.year() > 9999 ? Ry(
    h,
    u ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
  ) : _o(Date.prototype.toISOString) ? u ? this.toDate().toISOString() : new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", Ry(h, "Z")) : Ry(
    h,
    u ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function sF() {
  if (!this.isValid())
    return "moment.invalid(/* " + this._i + " */)";
  var s = "moment", u = "", h, m, w, T;
  return this.isLocal() || (s = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", u = "Z"), h = "[" + s + '("]', m = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", w = "-MM-DD[T]HH:mm:ss.SSS", T = u + '[")]', this.format(h + m + w + T);
}
function oF(s) {
  s || (s = this.isUtc() ? ct.defaultFormatUtc : ct.defaultFormat);
  var u = Ry(this, s);
  return this.localeData().postformat(u);
}
function lF(s, u) {
  return this.isValid() && (Us(s) && s.isValid() || rr(s).isValid()) ? Xs({ to: this, from: s }).locale(this.locale()).humanize(!u) : this.localeData().invalidDate();
}
function uF(s) {
  return this.from(rr(), s);
}
function cF(s, u) {
  return this.isValid() && (Us(s) && s.isValid() || rr(s).isValid()) ? Xs({ from: this, to: s }).locale(this.locale()).humanize(!u) : this.localeData().invalidDate();
}
function dF(s) {
  return this.to(rr(), s);
}
function uR(s) {
  var u;
  return s === void 0 ? this._locale._abbr : (u = Rl(s), u != null && (this._locale = u), this);
}
var cR = ls(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(s) {
    return s === void 0 ? this.localeData() : this.locale(s);
  }
);
function dR() {
  return this._locale;
}
var Wy = 1e3, Ff = 60 * Wy, Uy = 60 * Ff, fR = (365 * 400 + 97) * 24 * Uy;
function Yf(s, u) {
  return (s % u + u) % u;
}
function hR(s, u, h) {
  return s < 100 && s >= 0 ? new Date(s + 400, u, h) - fR : new Date(s, u, h).valueOf();
}
function pR(s, u, h) {
  return s < 100 && s >= 0 ? Date.UTC(s + 400, u, h) - fR : Date.UTC(s, u, h);
}
function fF(s) {
  var u, h;
  if (s = us(s), s === void 0 || s === "millisecond" || !this.isValid())
    return this;
  switch (h = this._isUTC ? pR : hR, s) {
    case "year":
      u = h(this.year(), 0, 1);
      break;
    case "quarter":
      u = h(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      u = h(this.year(), this.month(), 1);
      break;
    case "week":
      u = h(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      u = h(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      u = h(this.year(), this.month(), this.date());
      break;
    case "hour":
      u = this._d.valueOf(), u -= Yf(
        u + (this._isUTC ? 0 : this.utcOffset() * Ff),
        Uy
      );
      break;
    case "minute":
      u = this._d.valueOf(), u -= Yf(u, Ff);
      break;
    case "second":
      u = this._d.valueOf(), u -= Yf(u, Wy);
      break;
  }
  return this._d.setTime(u), ct.updateOffset(this, !0), this;
}
function hF(s) {
  var u, h;
  if (s = us(s), s === void 0 || s === "millisecond" || !this.isValid())
    return this;
  switch (h = this._isUTC ? pR : hR, s) {
    case "year":
      u = h(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      u = h(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      u = h(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      u = h(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      u = h(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      u = h(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      u = this._d.valueOf(), u += Uy - Yf(
        u + (this._isUTC ? 0 : this.utcOffset() * Ff),
        Uy
      ) - 1;
      break;
    case "minute":
      u = this._d.valueOf(), u += Ff - Yf(u, Ff) - 1;
      break;
    case "second":
      u = this._d.valueOf(), u += Wy - Yf(u, Wy) - 1;
      break;
  }
  return this._d.setTime(u), ct.updateOffset(this, !0), this;
}
function pF() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function gF() {
  return Math.floor(this.valueOf() / 1e3);
}
function mF() {
  return new Date(this.valueOf());
}
function vF() {
  var s = this;
  return [
    s.year(),
    s.month(),
    s.date(),
    s.hour(),
    s.minute(),
    s.second(),
    s.millisecond()
  ];
}
function yF() {
  var s = this;
  return {
    years: s.year(),
    months: s.month(),
    date: s.date(),
    hours: s.hours(),
    minutes: s.minutes(),
    seconds: s.seconds(),
    milliseconds: s.milliseconds()
  };
}
function xF() {
  return this.isValid() ? this.toISOString() : null;
}
function bF() {
  return W1(this);
}
function wF() {
  return Ru({}, an(this));
}
function SF() {
  return an(this).overflow;
}
function kF() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
Yt("N", 0, 0, "eraAbbr");
Yt("NN", 0, 0, "eraAbbr");
Yt("NNN", 0, 0, "eraAbbr");
Yt("NNNN", 0, 0, "eraName");
Yt("NNNNN", 0, 0, "eraNarrow");
Yt("y", ["y", 1], "yo", "eraYear");
Yt("y", ["yy", 2], 0, "eraYear");
Yt("y", ["yyy", 3], 0, "eraYear");
Yt("y", ["yyyy", 4], 0, "eraYear");
yt("N", iS);
yt("NN", iS);
yt("NNN", iS);
yt("NNNN", PF);
yt("NNNNN", NF);
Hn(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(s, u, h, m) {
    var w = h._locale.erasParse(s, m, h._strict);
    w ? an(h).era = w : an(h).invalidEra = s;
  }
);
yt("y", Bf);
yt("yy", Bf);
yt("yyy", Bf);
yt("yyyy", Bf);
yt("yo", zF);
Hn(["y", "yy", "yyy", "yyyy"], Ga);
Hn(["yo"], function(s, u, h, m) {
  var w;
  h._locale._eraYearOrdinalRegex && (w = s.match(h._locale._eraYearOrdinalRegex)), h._locale.eraYearOrdinalParse ? u[Ga] = h._locale.eraYearOrdinalParse(s, w) : u[Ga] = parseInt(s, 10);
});
function CF(s, u) {
  var h, m, w, T = this._eras || Rl("en")._eras;
  for (h = 0, m = T.length; h < m; ++h) {
    switch (typeof T[h].since) {
      case "string":
        w = ct(T[h].since).startOf("day"), T[h].since = w.valueOf();
        break;
    }
    switch (typeof T[h].until) {
      case "undefined":
        T[h].until = 1 / 0;
        break;
      case "string":
        w = ct(T[h].until).startOf("day").valueOf(), T[h].until = w.valueOf();
        break;
    }
  }
  return T;
}
function TF(s, u, h) {
  var m, w, T = this.eras(), A, F, H;
  for (s = s.toUpperCase(), m = 0, w = T.length; m < w; ++m)
    if (A = T[m].name.toUpperCase(), F = T[m].abbr.toUpperCase(), H = T[m].narrow.toUpperCase(), h)
      switch (u) {
        case "N":
        case "NN":
        case "NNN":
          if (F === s)
            return T[m];
          break;
        case "NNNN":
          if (A === s)
            return T[m];
          break;
        case "NNNNN":
          if (H === s)
            return T[m];
          break;
      }
    else if ([A, F, H].indexOf(s) >= 0)
      return T[m];
}
function AF(s, u) {
  var h = s.since <= s.until ? 1 : -1;
  return u === void 0 ? ct(s.since).year() : ct(s.since).year() + (u - s.offset) * h;
}
function EF() {
  var s, u, h, m = this.localeData().eras();
  for (s = 0, u = m.length; s < u; ++s)
    if (h = this.clone().startOf("day").valueOf(), m[s].since <= h && h <= m[s].until || m[s].until <= h && h <= m[s].since)
      return m[s].name;
  return "";
}
function RF() {
  var s, u, h, m = this.localeData().eras();
  for (s = 0, u = m.length; s < u; ++s)
    if (h = this.clone().startOf("day").valueOf(), m[s].since <= h && h <= m[s].until || m[s].until <= h && h <= m[s].since)
      return m[s].narrow;
  return "";
}
function LF() {
  var s, u, h, m = this.localeData().eras();
  for (s = 0, u = m.length; s < u; ++s)
    if (h = this.clone().startOf("day").valueOf(), m[s].since <= h && h <= m[s].until || m[s].until <= h && h <= m[s].since)
      return m[s].abbr;
  return "";
}
function OF() {
  var s, u, h, m, w = this.localeData().eras();
  for (s = 0, u = w.length; s < u; ++s)
    if (h = w[s].since <= w[s].until ? 1 : -1, m = this.clone().startOf("day").valueOf(), w[s].since <= m && m <= w[s].until || w[s].until <= m && m <= w[s].since)
      return (this.year() - ct(w[s].since).year()) * h + w[s].offset;
  return this.year();
}
function DF(s) {
  return En(this, "_erasNameRegex") || sS.call(this), s ? this._erasNameRegex : this._erasRegex;
}
function MF(s) {
  return En(this, "_erasAbbrRegex") || sS.call(this), s ? this._erasAbbrRegex : this._erasRegex;
}
function _F(s) {
  return En(this, "_erasNarrowRegex") || sS.call(this), s ? this._erasNarrowRegex : this._erasRegex;
}
function iS(s, u) {
  return u.erasAbbrRegex(s);
}
function PF(s, u) {
  return u.erasNameRegex(s);
}
function NF(s, u) {
  return u.erasNarrowRegex(s);
}
function zF(s, u) {
  return u._eraYearOrdinalRegex || Bf;
}
function sS() {
  var s = [], u = [], h = [], m = [], w, T, A = this.eras();
  for (w = 0, T = A.length; w < T; ++w)
    u.push(Xi(A[w].name)), s.push(Xi(A[w].abbr)), h.push(Xi(A[w].narrow)), m.push(Xi(A[w].name)), m.push(Xi(A[w].abbr)), m.push(Xi(A[w].narrow));
  this._erasRegex = new RegExp("^(" + m.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + u.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp(
    "^(" + h.join("|") + ")",
    "i"
  );
}
Yt(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
Yt(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function sx(s, u) {
  Yt(0, [s, s.length], 0, u);
}
sx("gggg", "weekYear");
sx("ggggg", "weekYear");
sx("GGGG", "isoWeekYear");
sx("GGGGG", "isoWeekYear");
$a("weekYear", "gg");
$a("isoWeekYear", "GG");
qa("weekYear", 1);
qa("isoWeekYear", 1);
yt("G", tx);
yt("g", tx);
yt("GG", ar, Vi);
yt("gg", ar, Vi);
yt("GGGG", q1, $1);
yt("gggg", q1, $1);
yt("GGGGG", ex, Ky);
yt("ggggg", ex, Ky);
Cg(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(s, u, h, m) {
    u[m.substr(0, 2)] = un(s);
  }
);
Cg(["gg", "GG"], function(s, u, h, m) {
  u[m] = ct.parseTwoDigitYear(s);
});
function IF(s) {
  return gR.call(
    this,
    s,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function FF(s) {
  return gR.call(
    this,
    s,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function YF() {
  return Al(this.year(), 1, 4);
}
function HF() {
  return Al(this.isoWeekYear(), 1, 4);
}
function jF() {
  var s = this.localeData()._week;
  return Al(this.year(), s.dow, s.doy);
}
function BF() {
  var s = this.localeData()._week;
  return Al(this.weekYear(), s.dow, s.doy);
}
function gR(s, u, h, m, w) {
  var T;
  return s == null ? vg(this, m, w).year : (T = Al(s, m, w), u > T && (u = T), WF.call(this, s, u, h, m, w));
}
function WF(s, u, h, m, w) {
  var T = $E(s, u, h, m, w), A = mg(T.year, 0, T.dayOfYear);
  return this.year(A.getUTCFullYear()), this.month(A.getUTCMonth()), this.date(A.getUTCDate()), this;
}
Yt("Q", 0, "Qo", "quarter");
$a("quarter", "Q");
qa("quarter", 7);
yt("Q", FE);
Hn("Q", function(s, u) {
  u[Cl] = (un(s) - 1) * 3;
});
function UF(s) {
  return s == null ? Math.ceil((this.month() + 1) / 3) : this.month((s - 1) * 3 + this.month() % 3);
}
Yt("D", ["DD", 2], "Do", "date");
$a("date", "D");
qa("date", 9);
yt("D", ar);
yt("DD", ar, Vi);
yt("Do", function(s, u) {
  return s ? u._dayOfMonthOrdinalParse || u._ordinalParse : u._dayOfMonthOrdinalParseLenient;
});
Hn(["D", "DD"], Lo);
Hn("Do", function(s, u) {
  u[Lo] = un(s.match(ar)[0]);
});
var mR = jf("Date", !0);
Yt("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
$a("dayOfYear", "DDD");
qa("dayOfYear", 4);
yt("DDD", Jy);
yt("DDDD", YE);
Hn(["DDD", "DDDD"], function(s, u, h) {
  h._dayOfYear = un(s);
});
function XF(s) {
  var u = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return s == null ? u : this.add(s - u, "d");
}
Yt("m", ["mm", 2], 0, "minute");
$a("minute", "m");
qa("minute", 14);
yt("m", ar);
yt("mm", ar, Vi);
Hn(["m", "mm"], Bs);
var VF = jf("Minutes", !1);
Yt("s", ["ss", 2], 0, "second");
$a("second", "s");
qa("second", 15);
yt("s", ar);
yt("ss", ar, Vi);
Hn(["s", "ss"], Tl);
var GF = jf("Seconds", !1);
Yt("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
Yt(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
Yt(0, ["SSS", 3], 0, "millisecond");
Yt(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
Yt(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
Yt(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
Yt(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
Yt(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
Yt(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
$a("millisecond", "ms");
qa("millisecond", 16);
yt("S", Jy, FE);
yt("SS", Jy, Vi);
yt("SSS", Jy, YE);
var Lu, vR;
for (Lu = "SSSS"; Lu.length <= 9; Lu += "S")
  yt(Lu, Bf);
function $F(s, u) {
  u[Fc] = un(("0." + s) * 1e3);
}
for (Lu = "S"; Lu.length <= 9; Lu += "S")
  Hn(Lu, $F);
vR = jf("Milliseconds", !1);
Yt("z", 0, 0, "zoneAbbr");
Yt("zz", 0, 0, "zoneName");
function qF() {
  return this._isUTC ? "UTC" : "";
}
function ZF() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var Ge = Sg.prototype;
Ge.add = BI;
Ge.calendar = qI;
Ge.clone = ZI;
Ge.diff = rF;
Ge.endOf = hF;
Ge.format = oF;
Ge.from = lF;
Ge.fromNow = uF;
Ge.to = cF;
Ge.toNow = dF;
Ge.get = KN;
Ge.invalidAt = SF;
Ge.isAfter = QI;
Ge.isBefore = KI;
Ge.isBetween = JI;
Ge.isSame = eF;
Ge.isSameOrAfter = tF;
Ge.isSameOrBefore = nF;
Ge.isValid = bF;
Ge.lang = cR;
Ge.locale = uR;
Ge.localeData = dR;
Ge.max = bI;
Ge.min = xI;
Ge.parsingFlags = wF;
Ge.set = JN;
Ge.startOf = fF;
Ge.subtract = WI;
Ge.toArray = vF;
Ge.toObject = yF;
Ge.toDate = mF;
Ge.toISOString = iF;
Ge.inspect = sF;
typeof Symbol < "u" && Symbol.for != null && (Ge[Symbol.for("nodejs.util.inspect.custom")] = function() {
  return "Moment<" + this.format() + ">";
});
Ge.toJSON = xF;
Ge.toString = aF;
Ge.unix = gF;
Ge.valueOf = pF;
Ge.creationData = kF;
Ge.eraName = EF;
Ge.eraNarrow = RF;
Ge.eraAbbr = LF;
Ge.eraYear = OF;
Ge.year = GE;
Ge.isLeapYear = yz;
Ge.weekYear = IF;
Ge.isoWeekYear = FF;
Ge.quarter = Ge.quarters = UF;
Ge.month = XE;
Ge.daysInMonth = gz;
Ge.week = Ge.weeks = Cz;
Ge.isoWeek = Ge.isoWeeks = Tz;
Ge.weeksInYear = jF;
Ge.weeksInWeekYear = BF;
Ge.isoWeeksInYear = YF;
Ge.isoWeeksInISOWeekYear = HF;
Ge.date = mR;
Ge.day = Ge.days = Fz;
Ge.weekday = Yz;
Ge.isoWeekday = Hz;
Ge.dayOfYear = XF;
Ge.hour = Ge.hours = Gz;
Ge.minute = Ge.minutes = VF;
Ge.second = Ge.seconds = GF;
Ge.millisecond = Ge.milliseconds = vR;
Ge.utcOffset = LI;
Ge.utc = DI;
Ge.local = MI;
Ge.parseZone = _I;
Ge.hasAlignedHourOffset = PI;
Ge.isDST = NI;
Ge.isLocal = II;
Ge.isUtcOffset = FI;
Ge.isUtc = iR;
Ge.isUTC = iR;
Ge.zoneAbbr = qF;
Ge.zoneName = ZF;
Ge.dates = ls(
  "dates accessor is deprecated. Use date instead.",
  mR
);
Ge.months = ls(
  "months accessor is deprecated. Use month instead",
  XE
);
Ge.years = ls(
  "years accessor is deprecated. Use year instead",
  GE
);
Ge.zone = ls(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  OI
);
Ge.isDSTShifted = ls(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  zI
);
function QF(s) {
  return rr(s * 1e3);
}
function KF() {
  return rr.apply(null, arguments).parseZone();
}
function yR(s) {
  return s;
}
var Rn = X1.prototype;
Rn.calendar = FN;
Rn.longDateFormat = BN;
Rn.invalidDate = UN;
Rn.ordinal = GN;
Rn.preparse = yR;
Rn.postformat = yR;
Rn.relativeTime = qN;
Rn.pastFuture = ZN;
Rn.set = zN;
Rn.eras = CF;
Rn.erasParse = TF;
Rn.erasConvertYear = AF;
Rn.erasAbbrRegex = MF;
Rn.erasNameRegex = DF;
Rn.erasNarrowRegex = _F;
Rn.months = dz;
Rn.monthsShort = fz;
Rn.monthsParse = pz;
Rn.monthsRegex = vz;
Rn.monthsShortRegex = mz;
Rn.week = bz;
Rn.firstDayOfYear = kz;
Rn.firstDayOfWeek = Sz;
Rn.weekdays = _z;
Rn.weekdaysMin = Nz;
Rn.weekdaysShort = Pz;
Rn.weekdaysParse = Iz;
Rn.weekdaysRegex = jz;
Rn.weekdaysShortRegex = Bz;
Rn.weekdaysMinRegex = Wz;
Rn.isPM = Xz;
Rn.meridiem = $z;
function Xy(s, u, h, m) {
  var w = Rl(), T = Mo().set(m, u);
  return w[h](T, s);
}
function xR(s, u, h) {
  if (El(s) && (u = s, s = void 0), s = s || "", u != null)
    return Xy(s, u, h, "month");
  var m, w = [];
  for (m = 0; m < 12; m++)
    w[m] = Xy(s, m, h, "month");
  return w;
}
function oS(s, u, h, m) {
  typeof s == "boolean" ? (El(u) && (h = u, u = void 0), u = u || "") : (u = s, h = u, s = !1, El(u) && (h = u, u = void 0), u = u || "");
  var w = Rl(), T = s ? w._week.dow : 0, A, F = [];
  if (h != null)
    return Xy(u, (h + T) % 7, m, "day");
  for (A = 0; A < 7; A++)
    F[A] = Xy(u, (A + T) % 7, m, "day");
  return F;
}
function JF(s, u) {
  return xR(s, u, "months");
}
function eY(s, u) {
  return xR(s, u, "monthsShort");
}
function tY(s, u, h) {
  return oS(s, u, h, "weekdays");
}
function nY(s, u, h) {
  return oS(s, u, h, "weekdaysShort");
}
function rY(s, u, h) {
  return oS(s, u, h, "weekdaysMin");
}
Ou("en", {
  eras: [
    {
      since: "0001-01-01",
      until: 1 / 0,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -1 / 0,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(s) {
    var u = s % 10, h = un(s % 100 / 10) === 1 ? "th" : u === 1 ? "st" : u === 2 ? "nd" : u === 3 ? "rd" : "th";
    return s + h;
  }
});
ct.lang = ls(
  "moment.lang is deprecated. Use moment.locale instead.",
  Ou
);
ct.langData = ls(
  "moment.langData is deprecated. Use moment.localeData instead.",
  Rl
);
var wl = Math.abs;
function aY() {
  var s = this._data;
  return this._milliseconds = wl(this._milliseconds), this._days = wl(this._days), this._months = wl(this._months), s.milliseconds = wl(s.milliseconds), s.seconds = wl(s.seconds), s.minutes = wl(s.minutes), s.hours = wl(s.hours), s.months = wl(s.months), s.years = wl(s.years), this;
}
function bR(s, u, h, m) {
  var w = Xs(u, h);
  return s._milliseconds += m * w._milliseconds, s._days += m * w._days, s._months += m * w._months, s._bubble();
}
function iY(s, u) {
  return bR(this, s, u, 1);
}
function sY(s, u) {
  return bR(this, s, u, -1);
}
function TA(s) {
  return s < 0 ? Math.floor(s) : Math.ceil(s);
}
function oY() {
  var s = this._milliseconds, u = this._days, h = this._months, m = this._data, w, T, A, F, H;
  return s >= 0 && u >= 0 && h >= 0 || s <= 0 && u <= 0 && h <= 0 || (s += TA(w1(h) + u) * 864e5, u = 0, h = 0), m.milliseconds = s % 1e3, w = os(s / 1e3), m.seconds = w % 60, T = os(w / 60), m.minutes = T % 60, A = os(T / 60), m.hours = A % 24, u += os(A / 24), H = os(wR(u)), h += H, u -= TA(w1(H)), F = os(h / 12), h %= 12, m.days = u, m.months = h, m.years = F, this;
}
function wR(s) {
  return s * 4800 / 146097;
}
function w1(s) {
  return s * 146097 / 4800;
}
function lY(s) {
  if (!this.isValid())
    return NaN;
  var u, h, m = this._milliseconds;
  if (s = us(s), s === "month" || s === "quarter" || s === "year")
    switch (u = this._days + m / 864e5, h = this._months + wR(u), s) {
      case "month":
        return h;
      case "quarter":
        return h / 3;
      case "year":
        return h / 12;
    }
  else
    switch (u = this._days + Math.round(w1(this._months)), s) {
      case "week":
        return u / 7 + m / 6048e5;
      case "day":
        return u + m / 864e5;
      case "hour":
        return u * 24 + m / 36e5;
      case "minute":
        return u * 1440 + m / 6e4;
      case "second":
        return u * 86400 + m / 1e3;
      case "millisecond":
        return Math.floor(u * 864e5) + m;
      default:
        throw new Error("Unknown unit " + s);
    }
}
function uY() {
  return this.isValid() ? this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + un(this._months / 12) * 31536e6 : NaN;
}
function Ll(s) {
  return function() {
    return this.as(s);
  };
}
var cY = Ll("ms"), dY = Ll("s"), fY = Ll("m"), hY = Ll("h"), pY = Ll("d"), gY = Ll("w"), mY = Ll("M"), vY = Ll("Q"), yY = Ll("y");
function xY() {
  return Xs(this);
}
function bY(s) {
  return s = us(s), this.isValid() ? this[s + "s"]() : NaN;
}
function Bc(s) {
  return function() {
    return this.isValid() ? this._data[s] : NaN;
  };
}
var wY = Bc("milliseconds"), SY = Bc("seconds"), kY = Bc("minutes"), CY = Bc("hours"), TY = Bc("days"), AY = Bc("months"), EY = Bc("years");
function RY() {
  return os(this.days() / 7);
}
var kl = Math.round, zf = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function LY(s, u, h, m, w) {
  return w.relativeTime(u || 1, !!h, s, m);
}
function OY(s, u, h, m) {
  var w = Xs(s).abs(), T = kl(w.as("s")), A = kl(w.as("m")), F = kl(w.as("h")), H = kl(w.as("d")), j = kl(w.as("M")), V = kl(w.as("w")), q = kl(w.as("y")), te = T <= h.ss && ["s", T] || T < h.s && ["ss", T] || A <= 1 && ["m"] || A < h.m && ["mm", A] || F <= 1 && ["h"] || F < h.h && ["hh", F] || H <= 1 && ["d"] || H < h.d && ["dd", H];
  return h.w != null && (te = te || V <= 1 && ["w"] || V < h.w && ["ww", V]), te = te || j <= 1 && ["M"] || j < h.M && ["MM", j] || q <= 1 && ["y"] || ["yy", q], te[2] = u, te[3] = +s > 0, te[4] = m, LY.apply(null, te);
}
function DY(s) {
  return s === void 0 ? kl : typeof s == "function" ? (kl = s, !0) : !1;
}
function MY(s, u) {
  return zf[s] === void 0 ? !1 : u === void 0 ? zf[s] : (zf[s] = u, s === "s" && (zf.ss = u - 1), !0);
}
function _Y(s, u) {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var h = !1, m = zf, w, T;
  return typeof s == "object" && (u = s, s = !1), typeof s == "boolean" && (h = s), typeof u == "object" && (m = Object.assign({}, zf, u), u.s != null && u.ss == null && (m.ss = u.s - 1)), w = this.localeData(), T = OY(this, !h, m, w), h && (T = w.pastFuture(+this, T)), w.postformat(T);
}
var Xw = Math.abs;
function Pf(s) {
  return (s > 0) - (s < 0) || +s;
}
function ox() {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var s = Xw(this._milliseconds) / 1e3, u = Xw(this._days), h = Xw(this._months), m, w, T, A, F = this.asSeconds(), H, j, V, q;
  return F ? (m = os(s / 60), w = os(m / 60), s %= 60, m %= 60, T = os(h / 12), h %= 12, A = s ? s.toFixed(3).replace(/\.?0+$/, "") : "", H = F < 0 ? "-" : "", j = Pf(this._months) !== Pf(F) ? "-" : "", V = Pf(this._days) !== Pf(F) ? "-" : "", q = Pf(this._milliseconds) !== Pf(F) ? "-" : "", H + "P" + (T ? j + T + "Y" : "") + (h ? j + h + "M" : "") + (u ? V + u + "D" : "") + (w || m || s ? "T" : "") + (w ? q + w + "H" : "") + (m ? q + m + "M" : "") + (s ? q + A + "S" : "")) : "P0D";
}
var xn = ix.prototype;
xn.isValid = TI;
xn.abs = aY;
xn.add = iY;
xn.subtract = sY;
xn.as = lY;
xn.asMilliseconds = cY;
xn.asSeconds = dY;
xn.asMinutes = fY;
xn.asHours = hY;
xn.asDays = pY;
xn.asWeeks = gY;
xn.asMonths = mY;
xn.asQuarters = vY;
xn.asYears = yY;
xn.valueOf = uY;
xn._bubble = oY;
xn.clone = xY;
xn.get = bY;
xn.milliseconds = wY;
xn.seconds = SY;
xn.minutes = kY;
xn.hours = CY;
xn.days = TY;
xn.weeks = RY;
xn.months = AY;
xn.years = EY;
xn.humanize = _Y;
xn.toISOString = ox;
xn.toString = ox;
xn.toJSON = ox;
xn.locale = uR;
xn.localeData = dR;
xn.toIsoString = ls(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  ox
);
xn.lang = cR;
Yt("X", 0, 0, "unix");
Yt("x", 0, 0, "valueOf");
yt("x", tx);
yt("X", tz);
Hn("X", function(s, u, h) {
  h._d = new Date(parseFloat(s) * 1e3);
});
Hn("x", function(s, u, h) {
  h._d = new Date(un(s));
});
//! moment.js
ct.version = "2.29.4";
PN(rr);
ct.fn = Ge;
ct.min = wI;
ct.max = SI;
ct.now = kI;
ct.utc = Mo;
ct.unix = QF;
ct.months = JF;
ct.isDate = wg;
ct.locale = Ou;
ct.invalid = Zy;
ct.duration = Xs;
ct.isMoment = Us;
ct.weekdays = tY;
ct.parseZone = KF;
ct.localeData = Rl;
ct.isDuration = Ly;
ct.monthsShort = eY;
ct.weekdaysMin = rY;
ct.defineLocale = J1;
ct.updateLocale = Kz;
ct.locales = Jz;
ct.weekdaysShort = nY;
ct.normalizeUnits = us;
ct.relativeTimeRounding = DY;
ct.relativeTimeThreshold = MY;
ct.calendarFormat = $I;
ct.prototype = Ge;
ct.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
//! moment.js locale configuration
//! locale : Portuguese (Brazil) [pt-br]
//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira
ct.defineLocale("pt-br", {
  months: "janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split(
    "_"
  ),
  monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
  weekdays: "domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado".split(
    "_"
  ),
  weekdaysShort: "dom_seg_ter_qua_qui_sex_sb".split("_"),
  weekdaysMin: "do_2_3_4_5_6_s".split("_"),
  weekdaysParseExact: !0,
  longDateFormat: {
    LT: "HH:mm",
    LTS: "HH:mm:ss",
    L: "DD/MM/YYYY",
    LL: "D [de] MMMM [de] YYYY",
    LLL: "D [de] MMMM [de] YYYY [s] HH:mm",
    LLLL: "dddd, D [de] MMMM [de] YYYY [s] HH:mm"
  },
  calendar: {
    sameDay: "[Hoje s] LT",
    nextDay: "[Amanh s] LT",
    nextWeek: "dddd [s] LT",
    lastDay: "[Ontem s] LT",
    lastWeek: function() {
      return this.day() === 0 || this.day() === 6 ? "[ltimo] dddd [s] LT" : "[ltima] dddd [s] LT";
    },
    sameElse: "L"
  },
  relativeTime: {
    future: "em %s",
    past: "h %s",
    s: "poucos segundos",
    ss: "%d segundos",
    m: "um minuto",
    mm: "%d minutos",
    h: "uma hora",
    hh: "%d horas",
    d: "um dia",
    dd: "%d dias",
    M: "um ms",
    MM: "%d meses",
    y: "um ano",
    yy: "%d anos"
  },
  dayOfMonthOrdinalParse: /\d{1,2}/,
  ordinal: "%d",
  invalidDate: "Data invlida"
});
const PY = [
  {
    agent: {
      firstName: "Ricardo",
      lastName: "Dutra",
      baseUserId: "ricardo.dutra"
    },
    period: [
      {
        date: "2023-08-08T03:00:00.002Z",
        start: "2023-08-08T06:24:32.532Z",
        finish: "2023-08-08T15:24:32.532Z",
        description: "Sada mais cedo",
        breaks: [
          {
            start: "2023-08-08T06:24:32.532Z",
            finish: "2023-08-08T06:24:32.532Z",
            type: 205
          }
        ]
      },
      {
        date: "2023-08-11T03:00:00.002Z",
        start: "2023-08-11T06:24:32.532Z",
        finish: "2023-08-11T14:58:32.532Z",
        description: "Sada mais cedo",
        breaks: [
          {
            start: "2023-08-11T09:24:32.532Z",
            finish: "2023-08-11T09:54:32.532Z",
            type: 206
          },
          {
            start: "2023-08-11T11:15:02.532Z",
            finish: "2023-08-11T11:29:32.532Z",
            type: 205
          }
        ]
      }
    ]
  },
  {
    agent: {
      firstName: "Jos",
      lastName: "Aultra",
      baseUserId: "jose.aultra"
    },
    period: [
      {
        date: "2023-08-09T03:00:00.002Z",
        start: "2023-08-09T06:24:32.532Z",
        finish: "2023-08-09T14:58:32.532Z",
        description: "Sada mais cedo",
        breaks: [
          {
            start: "2023-09-08T09:24:32.532Z",
            finish: "2023-09-08T09:54:32.532Z",
            type: 206
          },
          {
            start: "2023-09-08T11:15:02.532Z",
            finish: "2023-09-08T11:29:32.532Z",
            type: 205
          }
        ]
      }
    ]
  },
  {
    agent: {
      firstName: "Rinaldo",
      lastName: "Guilherme",
      baseUserId: "rinaldo.guilherme"
    },
    period: [
      {
        date: "2023-08-10T03:00:00.002Z",
        start: "2023-08-10T06:24:32.532Z",
        finish: "2023-08-10T14:58:32.532Z",
        description: "Sada mais cedo",
        breaks: [
          {
            start: "2023-09-08T09:24:32.532Z",
            finish: "2023-09-08T09:54:32.532Z",
            type: 206
          },
          {
            start: "2023-09-08T11:15:02.532Z",
            finish: "2023-09-08T11:29:32.532Z",
            type: 205
          }
        ]
      },
      {
        date: "2023-08-14T03:00:00.002Z",
        start: "2023-08-14T06:24:32.532Z",
        finish: "2023-08-14T14:58:32.532Z",
        description: "Sada mais cedo",
        breaks: [
          {
            start: "2023-09-08T09:24:32.532Z",
            finish: "2023-09-08T09:54:32.532Z",
            type: 206
          },
          {
            start: "2023-09-08T11:15:02.532Z",
            finish: "2023-09-08T11:29:32.532Z",
            type: 205
          }
        ]
      }
    ]
  }
];
tr.locale("pt-br");
const NY = {
  206: "Almoo",
  205: "Banheiro"
}, zY = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
], IY = ({
  data: s,
  lastSevenDays: u
}) => /* @__PURE__ */ ce.jsx("div", { className: "detailed-workday--period", children: u.map((h, m) => {
  const w = tr(h).format("DD [de] MMMM"), T = s.find(
    ({ date: H }) => tr(H).format("YYYY/MM/DD") === h.format("YYYY/MM/DD")
  );
  if (T === void 0)
    return /* @__PURE__ */ ce.jsx("div", { className: "day", children: /* @__PURE__ */ ce.jsx("span", { children: w }) }, m);
  const A = tr.utc(T.start).format("HH[h]mm"), F = tr.utc(T.finish).format("HH[h]mm");
  return /* @__PURE__ */ ce.jsxs("div", { className: "day", children: [
    /* @__PURE__ */ ce.jsx("span", { children: w }),
    /* @__PURE__ */ ce.jsx("span", { className: "service", children: "Servio" }),
    /* @__PURE__ */ ce.jsxs("span", { className: "service-time", children: [
      A,
      " - ",
      F
    ] }),
    /* @__PURE__ */ ce.jsxs("span", { className: "description", children: [
      T.description,
      "*"
    ] }),
    /* @__PURE__ */ ce.jsx("div", { className: "breaks", children: T.breaks.map((H, j) => {
      const V = tr.utc(H.start).format("HH[h]mm"), q = tr.utc(H.finish).format("HH[h]mm");
      return /* @__PURE__ */ ce.jsxs("div", { className: "break-item", children: [
        /* @__PURE__ */ ce.jsx("span", { className: "break-item--label", children: NY[String(H.type)] }),
        /* @__PURE__ */ ce.jsxs("span", { className: "break-item--content", children: [
          V,
          " - ",
          q
        ] })
      ] }, j);
    }) })
  ] }, m);
}) }), $j = () => {
  const s = Array.from({ length: 7 }).map(
    (u, h) => tr().clone().subtract(7 - h, "days")
  );
  return /* @__PURE__ */ ce.jsxs("div", { className: "detailed-workday container", children: [
    /* @__PURE__ */ ce.jsxs("header", { className: "detailed-workday--header container row spacing", children: [
      /* @__PURE__ */ ce.jsxs("div", { className: "group rounded-box", children: [
        /* @__PURE__ */ ce.jsx("label", { className: "bg-primary", children: "Filtro" }),
        /* @__PURE__ */ ce.jsx(Yy, { items: ["Semana", "Ms", "Ano"] })
      ] }),
      /* @__PURE__ */ ce.jsx("span", { children: "Intervalo de data: 08/08/2023 - 14/08/2023" })
    ] }),
    /* @__PURE__ */ ce.jsxs("div", { className: "detailed-workday--container", children: [
      /* @__PURE__ */ ce.jsxs("div", { className: "detailed-workday--item", children: [
        /* @__PURE__ */ ce.jsx("span", { className: "", style: { width: "10rem" } }),
        /* @__PURE__ */ ce.jsx("div", { className: "weekdays", children: s.map((u) => {
          const h = tr(u).day();
          return /* @__PURE__ */ ce.jsx("span", { className: "", children: zY[h] });
        }) })
      ] }),
      PY.map((u, h) => /* @__PURE__ */ ce.jsxs("div", { className: "detailed-workday--item", children: [
        /* @__PURE__ */ ce.jsx("span", { children: u.agent.firstName }),
        /* @__PURE__ */ ce.jsx(
          IY,
          {
            data: u.period,
            lastSevenDays: s
          },
          h
        )
      ] }, h))
    ] })
  ] });
}, qj = ({ logo: s, items: u }) => /* @__PURE__ */ ce.jsxs("header", { className: "header", children: [
  s,
  u
] }), FY = (s, u) => {
  var w, T, A, F;
  const m = s.currentTarget.childNodes[1].childNodes;
  switch (s.key) {
    case "ArrowDown": {
      if (u.current === m.length - 1)
        return;
      u.current += 1;
      const H = (T = (w = m[u.current]) == null ? void 0 : w.firstChild) == null ? void 0 : T.firstChild;
      H !== null && H.focus();
      break;
    }
    case "ArrowUp": {
      if (u.current === 2)
        return;
      u.current -= 1;
      const H = (F = (A = m[u.current]) == null ? void 0 : A.firstChild) == null ? void 0 : F.firstChild;
      H !== null && H.focus();
      break;
    }
    case " ": {
      const H = s.target;
      H instanceof HTMLAnchorElement && H.click();
    }
  }
}, AA = (s, u, h, m, w, T = 0, A, F) => {
  s.current === null || u.current === null || (m.route === h && s.current.classList.add("active"), s.current.classList.contains("active") && m.route !== h && s.current.classList.remove("active"), A || (u.current.innerHTML = `
      <div className="sidebar-tooltip-container">
        <span>${F(`sidebar.${m.label}`)}</span>
      </div>
    `, u.current.style.opacity = "1", u.current.style.top = `calc(48px * ${w + T})`), s.current.style.top = `calc(48px * ${w + T})`);
}, YY = (s, u, h, m, w, T, A) => {
  var F;
  {
    if (u.current === null || h.current === null)
      return;
    let H = -1;
    w || (h.current.innerHTML = "", h.current.style.opacity = "0"), T.forEach((j, V) => {
      s + j.route === m && (H = V, A !== null && V >= A && (H += T[A].submenus.length)), Object.hasOwnProperty.call(j, "submenus") && j.submenus.forEach((q, te) => {
        `${s}${j.route}${q.route}` === m && (A === V ? H = V + te + 1 : H = V);
      });
    }), (F = document.activeElement) == null || F.blur(), H > -1 && (u.current.style.top = `calc(48px * ${H})`, u.current.classList.add("active"));
  }
}, Zj = ({
  data: s,
  itemLink: u,
  onSettings: h,
  onLogout: m,
  prefix: w = "",
  pathname: T = ""
}) => {
  const A = mr(null), F = mr(null), H = mr(null), j = mr(3), [V, q] = fr(!1), [te, ae] = fr(null);
  return /* @__PURE__ */ ce.jsxs(
    "aside",
    {
      className: "sidebar closed",
      ref: A,
      onKeyDown: (se) => FY(se, j),
      children: [
        /* @__PURE__ */ ce.jsx(
          "button",
          {
            type: "button",
            className: "btn btn-square btn-ghost ring-info",
            onClick: () => {
              A.current !== null && (q((se) => !se), A.current.classList.toggle("closed"));
            },
            children: /* @__PURE__ */ ce.jsx(ma, { icon: "jam:menu", height: 32 })
          }
        ),
        /* @__PURE__ */ ce.jsxs(
          "ul",
          {
            className: "sidebar-container",
            onMouseLeave: () => YY(
              w,
              F,
              H,
              T,
              V,
              s,
              te
            ),
            children: [
              /* @__PURE__ */ ce.jsx("span", { ref: F, className: "sidebar-selector" }),
              /* @__PURE__ */ ce.jsx("div", { ref: H, className: "sidebar-tooltip" }),
              s.map((se, ue) => /* @__PURE__ */ ce.jsxs(cE, { children: [
                /* @__PURE__ */ ce.jsxs(
                  "li",
                  {
                    className: "sidebar-item",
                    onMouseEnter: () => AA(
                      F,
                      H,
                      T,
                      se,
                      te !== null && ue > te ? ue + s[te].submenus.length : ue,
                      0,
                      V,
                      nr
                    ),
                    onClick: () => {
                      se != null && se.submenus && ae(
                        (Ce) => Ce === ue ? null : ue
                      );
                    },
                    children: [
                      /* @__PURE__ */ ce.jsx("div", { className: "sidebar-item--icon", children: u({
                        icon: se.icon,
                        label: nr(`sidebar.${se.label}`),
                        route: se.route,
                        isOpen: V,
                        props: {
                          className: se != null && se.submenus ? "group" : "",
                          onClick: () => {
                            j.current = ue + 2, F.current && F.current.classList.toggle("active");
                          }
                        }
                      }) }),
                      (se == null ? void 0 : se.submenus) && /* @__PURE__ */ ce.jsxs("div", { className: "sidebar-item--submenu-handler", children: [
                        V && /* @__PURE__ */ ce.jsx("span", { className: "sidebar-item--indicator", children: se.submenus.length }),
                        /* @__PURE__ */ ce.jsx(
                          ma,
                          {
                            icon: "ic:round-arrow-right",
                            height: 24,
                            rotate: ue === te ? 45 : 0
                          }
                        )
                      ] })
                    ]
                  }
                ),
                (se == null ? void 0 : se.submenus) && ue === te && /* @__PURE__ */ ce.jsx("div", { className: "sidebar-submenu", children: se.submenus.map((Ce, Pe) => /* @__PURE__ */ ce.jsx(
                  "div",
                  {
                    className: "sidebar-submenu-item",
                    onMouseEnter: () => AA(
                      F,
                      H,
                      T,
                      Ce,
                      ue,
                      Pe + 1,
                      V,
                      nr
                    ),
                    children: u({
                      icon: Ce.icon,
                      label: nr(
                        `sidebar.${Ce.label}`
                      ),
                      route: `${se.route}${Ce.route}`,
                      isOpen: V,
                      props: { className: "" }
                    })
                  },
                  Ce.route
                )) })
              ] }, ue))
            ]
          }
        ),
        h && /* @__PURE__ */ ce.jsxs(
          "button",
          {
            type: "button",
            className: "sidebar-settings-action ring-info",
            onClick: h,
            children: [
              /* @__PURE__ */ ce.jsx(ma, { icon: "ph:gear-six-fill", height: 16 }),
              V && /* @__PURE__ */ ce.jsx("span", { children: nr("common.settings") })
            ]
          }
        ),
        m && /* @__PURE__ */ ce.jsxs(
          "button",
          {
            type: "button",
            className: "sidebar-exit-action ring-warning",
            onClick: m,
            children: [
              /* @__PURE__ */ ce.jsx(ma, { icon: "mingcute:exit-fill", height: 16 }),
              V && /* @__PURE__ */ ce.jsx("span", { children: nr("common.logout") })
            ]
          }
        )
      ]
    }
  );
};
var S1 = { exports: {} }, Oi = {}, Sy = { exports: {} }, Vw = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var EA;
function HY() {
  return EA || (EA = 1, function(s) {
    function u(We, pt) {
      var ye = We.length;
      We.push(pt);
      e:
        for (; 0 < ye; ) {
          var je = ye - 1 >>> 1, Qe = We[je];
          if (0 < w(Qe, pt))
            We[je] = pt, We[ye] = Qe, ye = je;
          else
            break e;
        }
    }
    function h(We) {
      return We.length === 0 ? null : We[0];
    }
    function m(We) {
      if (We.length === 0)
        return null;
      var pt = We[0], ye = We.pop();
      if (ye !== pt) {
        We[0] = ye;
        e:
          for (var je = 0, Qe = We.length, kt = Qe >>> 1; je < kt; ) {
            var mt = 2 * (je + 1) - 1, Pt = We[mt], st = mt + 1, Nt = We[st];
            if (0 > w(Pt, ye))
              st < Qe && 0 > w(Nt, Pt) ? (We[je] = Nt, We[st] = ye, je = st) : (We[je] = Pt, We[mt] = ye, je = mt);
            else if (st < Qe && 0 > w(Nt, ye))
              We[je] = Nt, We[st] = ye, je = st;
            else
              break e;
          }
      }
      return pt;
    }
    function w(We, pt) {
      var ye = We.sortIndex - pt.sortIndex;
      return ye !== 0 ? ye : We.id - pt.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var T = performance;
      s.unstable_now = function() {
        return T.now();
      };
    } else {
      var A = Date, F = A.now();
      s.unstable_now = function() {
        return A.now() - F;
      };
    }
    var H = [], j = [], V = 1, q = null, te = 3, ae = !1, se = !1, ue = !1, Ce = typeof setTimeout == "function" ? setTimeout : null, Pe = typeof clearTimeout == "function" ? clearTimeout : null, K = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function we(We) {
      for (var pt = h(j); pt !== null; ) {
        if (pt.callback === null)
          m(j);
        else if (pt.startTime <= We)
          m(j), pt.sortIndex = pt.expirationTime, u(H, pt);
        else
          break;
        pt = h(j);
      }
    }
    function Ee(We) {
      if (ue = !1, we(We), !se)
        if (h(H) !== null)
          se = !0, It(re);
        else {
          var pt = h(j);
          pt !== null && Jt(Ee, pt.startTime - We);
        }
    }
    function re(We, pt) {
      se = !1, ue && (ue = !1, Pe(Je), Je = -1), ae = !0;
      var ye = te;
      try {
        for (we(pt), q = h(H); q !== null && (!(q.expirationTime > pt) || We && !it()); ) {
          var je = q.callback;
          if (typeof je == "function") {
            q.callback = null, te = q.priorityLevel;
            var Qe = je(q.expirationTime <= pt);
            pt = s.unstable_now(), typeof Qe == "function" ? q.callback = Qe : q === h(H) && m(H), we(pt);
          } else
            m(H);
          q = h(H);
        }
        if (q !== null)
          var kt = !0;
        else {
          var mt = h(j);
          mt !== null && Jt(Ee, mt.startTime - pt), kt = !1;
        }
        return kt;
      } finally {
        q = null, te = ye, ae = !1;
      }
    }
    var me = !1, Me = null, Je = -1, Ve = 5, Xe = -1;
    function it() {
      return !(s.unstable_now() - Xe < Ve);
    }
    function ht() {
      if (Me !== null) {
        var We = s.unstable_now();
        Xe = We;
        var pt = !0;
        try {
          pt = Me(!0, We);
        } finally {
          pt ? Ke() : (me = !1, Me = null);
        }
      } else
        me = !1;
    }
    var Ke;
    if (typeof K == "function")
      Ke = function() {
        K(ht);
      };
    else if (typeof MessageChannel < "u") {
      var Ze = new MessageChannel(), Tt = Ze.port2;
      Ze.port1.onmessage = ht, Ke = function() {
        Tt.postMessage(null);
      };
    } else
      Ke = function() {
        Ce(ht, 0);
      };
    function It(We) {
      Me = We, me || (me = !0, Ke());
    }
    function Jt(We, pt) {
      Je = Ce(function() {
        We(s.unstable_now());
      }, pt);
    }
    s.unstable_IdlePriority = 5, s.unstable_ImmediatePriority = 1, s.unstable_LowPriority = 4, s.unstable_NormalPriority = 3, s.unstable_Profiling = null, s.unstable_UserBlockingPriority = 2, s.unstable_cancelCallback = function(We) {
      We.callback = null;
    }, s.unstable_continueExecution = function() {
      se || ae || (se = !0, It(re));
    }, s.unstable_forceFrameRate = function(We) {
      0 > We || 125 < We ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Ve = 0 < We ? Math.floor(1e3 / We) : 5;
    }, s.unstable_getCurrentPriorityLevel = function() {
      return te;
    }, s.unstable_getFirstCallbackNode = function() {
      return h(H);
    }, s.unstable_next = function(We) {
      switch (te) {
        case 1:
        case 2:
        case 3:
          var pt = 3;
          break;
        default:
          pt = te;
      }
      var ye = te;
      te = pt;
      try {
        return We();
      } finally {
        te = ye;
      }
    }, s.unstable_pauseExecution = function() {
    }, s.unstable_requestPaint = function() {
    }, s.unstable_runWithPriority = function(We, pt) {
      switch (We) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          We = 3;
      }
      var ye = te;
      te = We;
      try {
        return pt();
      } finally {
        te = ye;
      }
    }, s.unstable_scheduleCallback = function(We, pt, ye) {
      var je = s.unstable_now();
      switch (typeof ye == "object" && ye !== null ? (ye = ye.delay, ye = typeof ye == "number" && 0 < ye ? je + ye : je) : ye = je, We) {
        case 1:
          var Qe = -1;
          break;
        case 2:
          Qe = 250;
          break;
        case 5:
          Qe = 1073741823;
          break;
        case 4:
          Qe = 1e4;
          break;
        default:
          Qe = 5e3;
      }
      return Qe = ye + Qe, We = { id: V++, callback: pt, priorityLevel: We, startTime: ye, expirationTime: Qe, sortIndex: -1 }, ye > je ? (We.sortIndex = ye, u(j, We), h(H) === null && We === h(j) && (ue ? (Pe(Je), Je = -1) : ue = !0, Jt(Ee, ye - je))) : (We.sortIndex = Qe, u(H, We), se || ae || (se = !0, It(re))), We;
    }, s.unstable_shouldYield = it, s.unstable_wrapCallback = function(We) {
      var pt = te;
      return function() {
        var ye = te;
        te = pt;
        try {
          return We.apply(this, arguments);
        } finally {
          te = ye;
        }
      };
    };
  }(Vw)), Vw;
}
var Gw = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var RA;
function jY() {
  return RA || (RA = 1, function(s) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var u = !1, h = !1, m = 5;
      function w(et, Lt) {
        var nn = et.length;
        et.push(Lt), F(et, Lt, nn);
      }
      function T(et) {
        return et.length === 0 ? null : et[0];
      }
      function A(et) {
        if (et.length === 0)
          return null;
        var Lt = et[0], nn = et.pop();
        return nn !== Lt && (et[0] = nn, H(et, nn, 0)), Lt;
      }
      function F(et, Lt, nn) {
        for (var bn = nn; bn > 0; ) {
          var Bn = bn - 1 >>> 1, vr = et[Bn];
          if (j(vr, Lt) > 0)
            et[Bn] = Lt, et[bn] = vr, bn = Bn;
          else
            return;
        }
      }
      function H(et, Lt, nn) {
        for (var bn = nn, Bn = et.length, vr = Bn >>> 1; bn < vr; ) {
          var $n = (bn + 1) * 2 - 1, aa = et[$n], Ln = $n + 1, yr = et[Ln];
          if (j(aa, Lt) < 0)
            Ln < Bn && j(yr, aa) < 0 ? (et[bn] = yr, et[Ln] = Lt, bn = Ln) : (et[bn] = aa, et[$n] = Lt, bn = $n);
          else if (Ln < Bn && j(yr, Lt) < 0)
            et[bn] = yr, et[Ln] = Lt, bn = Ln;
          else
            return;
        }
      }
      function j(et, Lt) {
        var nn = et.sortIndex - Lt.sortIndex;
        return nn !== 0 ? nn : et.id - Lt.id;
      }
      var V = 1, q = 2, te = 3, ae = 4, se = 5;
      function ue(et, Lt) {
      }
      var Ce = typeof performance == "object" && typeof performance.now == "function";
      if (Ce) {
        var Pe = performance;
        s.unstable_now = function() {
          return Pe.now();
        };
      } else {
        var K = Date, we = K.now();
        s.unstable_now = function() {
          return K.now() - we;
        };
      }
      var Ee = 1073741823, re = -1, me = 250, Me = 5e3, Je = 1e4, Ve = Ee, Xe = [], it = [], ht = 1, Ke = null, Ze = te, Tt = !1, It = !1, Jt = !1, We = typeof setTimeout == "function" ? setTimeout : null, pt = typeof clearTimeout == "function" ? clearTimeout : null, ye = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function je(et) {
        for (var Lt = T(it); Lt !== null; ) {
          if (Lt.callback === null)
            A(it);
          else if (Lt.startTime <= et)
            A(it), Lt.sortIndex = Lt.expirationTime, w(Xe, Lt);
          else
            return;
          Lt = T(it);
        }
      }
      function Qe(et) {
        if (Jt = !1, je(et), !It)
          if (T(Xe) !== null)
            It = !0, na(kt);
          else {
            var Lt = T(it);
            Lt !== null && sr(Qe, Lt.startTime - et);
          }
      }
      function kt(et, Lt) {
        It = !1, Jt && (Jt = !1, ra()), Tt = !0;
        var nn = Ze;
        try {
          var bn;
          if (!h)
            return mt(et, Lt);
        } finally {
          Ke = null, Ze = nn, Tt = !1;
        }
      }
      function mt(et, Lt) {
        var nn = Lt;
        for (je(nn), Ke = T(Xe); Ke !== null && !u && !(Ke.expirationTime > nn && (!et || Za())); ) {
          var bn = Ke.callback;
          if (typeof bn == "function") {
            Ke.callback = null, Ze = Ke.priorityLevel;
            var Bn = Ke.expirationTime <= nn, vr = bn(Bn);
            nn = s.unstable_now(), typeof vr == "function" ? Ke.callback = vr : Ke === T(Xe) && A(Xe), je(nn);
          } else
            A(Xe);
          Ke = T(Xe);
        }
        if (Ke !== null)
          return !0;
        var $n = T(it);
        return $n !== null && sr(Qe, $n.startTime - nn), !1;
      }
      function Pt(et, Lt) {
        switch (et) {
          case V:
          case q:
          case te:
          case ae:
          case se:
            break;
          default:
            et = te;
        }
        var nn = Ze;
        Ze = et;
        try {
          return Lt();
        } finally {
          Ze = nn;
        }
      }
      function st(et) {
        var Lt;
        switch (Ze) {
          case V:
          case q:
          case te:
            Lt = te;
            break;
          default:
            Lt = Ze;
            break;
        }
        var nn = Ze;
        Ze = Lt;
        try {
          return et();
        } finally {
          Ze = nn;
        }
      }
      function Nt(et) {
        var Lt = Ze;
        return function() {
          var nn = Ze;
          Ze = Lt;
          try {
            return et.apply(this, arguments);
          } finally {
            Ze = nn;
          }
        };
      }
      function Et(et, Lt, nn) {
        var bn = s.unstable_now(), Bn;
        if (typeof nn == "object" && nn !== null) {
          var vr = nn.delay;
          typeof vr == "number" && vr > 0 ? Bn = bn + vr : Bn = bn;
        } else
          Bn = bn;
        var $n;
        switch (et) {
          case V:
            $n = re;
            break;
          case q:
            $n = me;
            break;
          case se:
            $n = Ve;
            break;
          case ae:
            $n = Je;
            break;
          case te:
          default:
            $n = Me;
            break;
        }
        var aa = Bn + $n, Ln = {
          id: ht++,
          callback: Lt,
          priorityLevel: et,
          startTime: Bn,
          expirationTime: aa,
          sortIndex: -1
        };
        return Bn > bn ? (Ln.sortIndex = Bn, w(it, Ln), T(Xe) === null && Ln === T(it) && (Jt ? ra() : Jt = !0, sr(Qe, Bn - bn))) : (Ln.sortIndex = aa, w(Xe, Ln), !It && !Tt && (It = !0, na(kt))), Ln;
      }
      function Ht() {
      }
      function Wt() {
        !It && !Tt && (It = !0, na(kt));
      }
      function mn() {
        return T(Xe);
      }
      function qe(et) {
        et.callback = null;
      }
      function pn() {
        return Ze;
      }
      var jn = !1, ir = null, Dr = -1, Mr = m, ta = -1;
      function Za() {
        var et = s.unstable_now() - ta;
        return !(et < Mr);
      }
      function _i() {
      }
      function di(et) {
        if (et < 0 || et > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        et > 0 ? Mr = Math.floor(1e3 / et) : Mr = m;
      }
      var Qa = function() {
        if (ir !== null) {
          var et = s.unstable_now();
          ta = et;
          var Lt = !0, nn = !0;
          try {
            nn = ir(Lt, et);
          } finally {
            nn ? ya() : (jn = !1, ir = null);
          }
        } else
          jn = !1;
      }, ya;
      if (typeof ye == "function")
        ya = function() {
          ye(Qa);
        };
      else if (typeof MessageChannel < "u") {
        var fi = new MessageChannel(), xa = fi.port2;
        fi.port1.onmessage = Qa, ya = function() {
          xa.postMessage(null);
        };
      } else
        ya = function() {
          We(Qa, 0);
        };
      function na(et) {
        ir = et, jn || (jn = !0, ya());
      }
      function sr(et, Lt) {
        Dr = We(function() {
          et(s.unstable_now());
        }, Lt);
      }
      function ra() {
        pt(Dr), Dr = -1;
      }
      var Pi = _i, Ka = null;
      s.unstable_IdlePriority = se, s.unstable_ImmediatePriority = V, s.unstable_LowPriority = ae, s.unstable_NormalPriority = te, s.unstable_Profiling = Ka, s.unstable_UserBlockingPriority = q, s.unstable_cancelCallback = qe, s.unstable_continueExecution = Wt, s.unstable_forceFrameRate = di, s.unstable_getCurrentPriorityLevel = pn, s.unstable_getFirstCallbackNode = mn, s.unstable_next = st, s.unstable_pauseExecution = Ht, s.unstable_requestPaint = Pi, s.unstable_runWithPriority = Pt, s.unstable_scheduleCallback = Et, s.unstable_shouldYield = Za, s.unstable_wrapCallback = Nt, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(Gw)), Gw;
}
var LA;
function SR() {
  return LA || (LA = 1, process.env.NODE_ENV === "production" ? Sy.exports = HY() : Sy.exports = jY()), Sy.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var OA;
function BY() {
  if (OA)
    return Oi;
  OA = 1;
  var s = va, u = SR();
  function h(i) {
    for (var l = "https://reactjs.org/docs/error-decoder.html?invariant=" + i, v = 1; v < arguments.length; v++)
      l += "&args[]=" + encodeURIComponent(arguments[v]);
    return "Minified React error #" + i + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var m = /* @__PURE__ */ new Set(), w = {};
  function T(i, l) {
    A(i, l), A(i + "Capture", l);
  }
  function A(i, l) {
    for (w[i] = l, i = 0; i < l.length; i++)
      m.add(l[i]);
  }
  var F = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), H = Object.prototype.hasOwnProperty, j = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, V = {}, q = {};
  function te(i) {
    return H.call(q, i) ? !0 : H.call(V, i) ? !1 : j.test(i) ? q[i] = !0 : (V[i] = !0, !1);
  }
  function ae(i, l, v, k) {
    if (v !== null && v.type === 0)
      return !1;
    switch (typeof l) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return k ? !1 : v !== null ? !v.acceptsBooleans : (i = i.toLowerCase().slice(0, 5), i !== "data-" && i !== "aria-");
      default:
        return !1;
    }
  }
  function se(i, l, v, k) {
    if (l === null || typeof l > "u" || ae(i, l, v, k))
      return !0;
    if (k)
      return !1;
    if (v !== null)
      switch (v.type) {
        case 3:
          return !l;
        case 4:
          return l === !1;
        case 5:
          return isNaN(l);
        case 6:
          return isNaN(l) || 1 > l;
      }
    return !1;
  }
  function ue(i, l, v, k, D, z, $) {
    this.acceptsBooleans = l === 2 || l === 3 || l === 4, this.attributeName = k, this.attributeNamespace = D, this.mustUseProperty = v, this.propertyName = i, this.type = l, this.sanitizeURL = z, this.removeEmptyString = $;
  }
  var Ce = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(i) {
    Ce[i] = new ue(i, 0, !1, i, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(i) {
    var l = i[0];
    Ce[l] = new ue(l, 1, !1, i[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(i) {
    Ce[i] = new ue(i, 2, !1, i.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(i) {
    Ce[i] = new ue(i, 2, !1, i, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(i) {
    Ce[i] = new ue(i, 3, !1, i.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(i) {
    Ce[i] = new ue(i, 3, !0, i, null, !1, !1);
  }), ["capture", "download"].forEach(function(i) {
    Ce[i] = new ue(i, 4, !1, i, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(i) {
    Ce[i] = new ue(i, 6, !1, i, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(i) {
    Ce[i] = new ue(i, 5, !1, i.toLowerCase(), null, !1, !1);
  });
  var Pe = /[\-:]([a-z])/g;
  function K(i) {
    return i[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(i) {
    var l = i.replace(
      Pe,
      K
    );
    Ce[l] = new ue(l, 1, !1, i, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(i) {
    var l = i.replace(Pe, K);
    Ce[l] = new ue(l, 1, !1, i, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(i) {
    var l = i.replace(Pe, K);
    Ce[l] = new ue(l, 1, !1, i, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(i) {
    Ce[i] = new ue(i, 1, !1, i.toLowerCase(), null, !1, !1);
  }), Ce.xlinkHref = new ue("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(i) {
    Ce[i] = new ue(i, 1, !1, i.toLowerCase(), null, !0, !0);
  });
  function we(i, l, v, k) {
    var D = Ce.hasOwnProperty(l) ? Ce[l] : null;
    (D !== null ? D.type !== 0 : k || !(2 < l.length) || l[0] !== "o" && l[0] !== "O" || l[1] !== "n" && l[1] !== "N") && (se(l, v, D, k) && (v = null), k || D === null ? te(l) && (v === null ? i.removeAttribute(l) : i.setAttribute(l, "" + v)) : D.mustUseProperty ? i[D.propertyName] = v === null ? D.type === 3 ? !1 : "" : v : (l = D.attributeName, k = D.attributeNamespace, v === null ? i.removeAttribute(l) : (D = D.type, v = D === 3 || D === 4 && v === !0 ? "" : "" + v, k ? i.setAttributeNS(k, l, v) : i.setAttribute(l, v))));
  }
  var Ee = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, re = Symbol.for("react.element"), me = Symbol.for("react.portal"), Me = Symbol.for("react.fragment"), Je = Symbol.for("react.strict_mode"), Ve = Symbol.for("react.profiler"), Xe = Symbol.for("react.provider"), it = Symbol.for("react.context"), ht = Symbol.for("react.forward_ref"), Ke = Symbol.for("react.suspense"), Ze = Symbol.for("react.suspense_list"), Tt = Symbol.for("react.memo"), It = Symbol.for("react.lazy"), Jt = Symbol.for("react.offscreen"), We = Symbol.iterator;
  function pt(i) {
    return i === null || typeof i != "object" ? null : (i = We && i[We] || i["@@iterator"], typeof i == "function" ? i : null);
  }
  var ye = Object.assign, je;
  function Qe(i) {
    if (je === void 0)
      try {
        throw Error();
      } catch (v) {
        var l = v.stack.trim().match(/\n( *(at )?)/);
        je = l && l[1] || "";
      }
    return `
` + je + i;
  }
  var kt = !1;
  function mt(i, l) {
    if (!i || kt)
      return "";
    kt = !0;
    var v = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (l)
        if (l = function() {
          throw Error();
        }, Object.defineProperty(l.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(l, []);
          } catch (Re) {
            var k = Re;
          }
          Reflect.construct(i, [], l);
        } else {
          try {
            l.call();
          } catch (Re) {
            k = Re;
          }
          i.call(l.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Re) {
          k = Re;
        }
        i();
      }
    } catch (Re) {
      if (Re && k && typeof Re.stack == "string") {
        for (var D = Re.stack.split(`
`), z = k.stack.split(`
`), $ = D.length - 1, ie = z.length - 1; 1 <= $ && 0 <= ie && D[$] !== z[ie]; )
          ie--;
        for (; 1 <= $ && 0 <= ie; $--, ie--)
          if (D[$] !== z[ie]) {
            if ($ !== 1 || ie !== 1)
              do
                if ($--, ie--, 0 > ie || D[$] !== z[ie]) {
                  var de = `
` + D[$].replace(" at new ", " at ");
                  return i.displayName && de.includes("<anonymous>") && (de = de.replace("<anonymous>", i.displayName)), de;
                }
              while (1 <= $ && 0 <= ie);
            break;
          }
      }
    } finally {
      kt = !1, Error.prepareStackTrace = v;
    }
    return (i = i ? i.displayName || i.name : "") ? Qe(i) : "";
  }
  function Pt(i) {
    switch (i.tag) {
      case 5:
        return Qe(i.type);
      case 16:
        return Qe("Lazy");
      case 13:
        return Qe("Suspense");
      case 19:
        return Qe("SuspenseList");
      case 0:
      case 2:
      case 15:
        return i = mt(i.type, !1), i;
      case 11:
        return i = mt(i.type.render, !1), i;
      case 1:
        return i = mt(i.type, !0), i;
      default:
        return "";
    }
  }
  function st(i) {
    if (i == null)
      return null;
    if (typeof i == "function")
      return i.displayName || i.name || null;
    if (typeof i == "string")
      return i;
    switch (i) {
      case Me:
        return "Fragment";
      case me:
        return "Portal";
      case Ve:
        return "Profiler";
      case Je:
        return "StrictMode";
      case Ke:
        return "Suspense";
      case Ze:
        return "SuspenseList";
    }
    if (typeof i == "object")
      switch (i.$$typeof) {
        case it:
          return (i.displayName || "Context") + ".Consumer";
        case Xe:
          return (i._context.displayName || "Context") + ".Provider";
        case ht:
          var l = i.render;
          return i = i.displayName, i || (i = l.displayName || l.name || "", i = i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef"), i;
        case Tt:
          return l = i.displayName || null, l !== null ? l : st(i.type) || "Memo";
        case It:
          l = i._payload, i = i._init;
          try {
            return st(i(l));
          } catch {
          }
      }
    return null;
  }
  function Nt(i) {
    var l = i.type;
    switch (i.tag) {
      case 24:
        return "Cache";
      case 9:
        return (l.displayName || "Context") + ".Consumer";
      case 10:
        return (l._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return i = l.render, i = i.displayName || i.name || "", l.displayName || (i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return l;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return st(l);
      case 8:
        return l === Je ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof l == "function")
          return l.displayName || l.name || null;
        if (typeof l == "string")
          return l;
    }
    return null;
  }
  function Et(i) {
    switch (typeof i) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return i;
      case "object":
        return i;
      default:
        return "";
    }
  }
  function Ht(i) {
    var l = i.type;
    return (i = i.nodeName) && i.toLowerCase() === "input" && (l === "checkbox" || l === "radio");
  }
  function Wt(i) {
    var l = Ht(i) ? "checked" : "value", v = Object.getOwnPropertyDescriptor(i.constructor.prototype, l), k = "" + i[l];
    if (!i.hasOwnProperty(l) && typeof v < "u" && typeof v.get == "function" && typeof v.set == "function") {
      var D = v.get, z = v.set;
      return Object.defineProperty(i, l, { configurable: !0, get: function() {
        return D.call(this);
      }, set: function($) {
        k = "" + $, z.call(this, $);
      } }), Object.defineProperty(i, l, { enumerable: v.enumerable }), { getValue: function() {
        return k;
      }, setValue: function($) {
        k = "" + $;
      }, stopTracking: function() {
        i._valueTracker = null, delete i[l];
      } };
    }
  }
  function mn(i) {
    i._valueTracker || (i._valueTracker = Wt(i));
  }
  function qe(i) {
    if (!i)
      return !1;
    var l = i._valueTracker;
    if (!l)
      return !0;
    var v = l.getValue(), k = "";
    return i && (k = Ht(i) ? i.checked ? "true" : "false" : i.value), i = k, i !== v ? (l.setValue(i), !0) : !1;
  }
  function pn(i) {
    if (i = i || (typeof document < "u" ? document : void 0), typeof i > "u")
      return null;
    try {
      return i.activeElement || i.body;
    } catch {
      return i.body;
    }
  }
  function jn(i, l) {
    var v = l.checked;
    return ye({}, l, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: v ?? i._wrapperState.initialChecked });
  }
  function ir(i, l) {
    var v = l.defaultValue == null ? "" : l.defaultValue, k = l.checked != null ? l.checked : l.defaultChecked;
    v = Et(l.value != null ? l.value : v), i._wrapperState = { initialChecked: k, initialValue: v, controlled: l.type === "checkbox" || l.type === "radio" ? l.checked != null : l.value != null };
  }
  function Dr(i, l) {
    l = l.checked, l != null && we(i, "checked", l, !1);
  }
  function Mr(i, l) {
    Dr(i, l);
    var v = Et(l.value), k = l.type;
    if (v != null)
      k === "number" ? (v === 0 && i.value === "" || i.value != v) && (i.value = "" + v) : i.value !== "" + v && (i.value = "" + v);
    else if (k === "submit" || k === "reset") {
      i.removeAttribute("value");
      return;
    }
    l.hasOwnProperty("value") ? Za(i, l.type, v) : l.hasOwnProperty("defaultValue") && Za(i, l.type, Et(l.defaultValue)), l.checked == null && l.defaultChecked != null && (i.defaultChecked = !!l.defaultChecked);
  }
  function ta(i, l, v) {
    if (l.hasOwnProperty("value") || l.hasOwnProperty("defaultValue")) {
      var k = l.type;
      if (!(k !== "submit" && k !== "reset" || l.value !== void 0 && l.value !== null))
        return;
      l = "" + i._wrapperState.initialValue, v || l === i.value || (i.value = l), i.defaultValue = l;
    }
    v = i.name, v !== "" && (i.name = ""), i.defaultChecked = !!i._wrapperState.initialChecked, v !== "" && (i.name = v);
  }
  function Za(i, l, v) {
    (l !== "number" || pn(i.ownerDocument) !== i) && (v == null ? i.defaultValue = "" + i._wrapperState.initialValue : i.defaultValue !== "" + v && (i.defaultValue = "" + v));
  }
  var _i = Array.isArray;
  function di(i, l, v, k) {
    if (i = i.options, l) {
      l = {};
      for (var D = 0; D < v.length; D++)
        l["$" + v[D]] = !0;
      for (v = 0; v < i.length; v++)
        D = l.hasOwnProperty("$" + i[v].value), i[v].selected !== D && (i[v].selected = D), D && k && (i[v].defaultSelected = !0);
    } else {
      for (v = "" + Et(v), l = null, D = 0; D < i.length; D++) {
        if (i[D].value === v) {
          i[D].selected = !0, k && (i[D].defaultSelected = !0);
          return;
        }
        l !== null || i[D].disabled || (l = i[D]);
      }
      l !== null && (l.selected = !0);
    }
  }
  function Qa(i, l) {
    if (l.dangerouslySetInnerHTML != null)
      throw Error(h(91));
    return ye({}, l, { value: void 0, defaultValue: void 0, children: "" + i._wrapperState.initialValue });
  }
  function ya(i, l) {
    var v = l.value;
    if (v == null) {
      if (v = l.children, l = l.defaultValue, v != null) {
        if (l != null)
          throw Error(h(92));
        if (_i(v)) {
          if (1 < v.length)
            throw Error(h(93));
          v = v[0];
        }
        l = v;
      }
      l == null && (l = ""), v = l;
    }
    i._wrapperState = { initialValue: Et(v) };
  }
  function fi(i, l) {
    var v = Et(l.value), k = Et(l.defaultValue);
    v != null && (v = "" + v, v !== i.value && (i.value = v), l.defaultValue == null && i.defaultValue !== v && (i.defaultValue = v)), k != null && (i.defaultValue = "" + k);
  }
  function xa(i) {
    var l = i.textContent;
    l === i._wrapperState.initialValue && l !== "" && l !== null && (i.value = l);
  }
  function na(i) {
    switch (i) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function sr(i, l) {
    return i == null || i === "http://www.w3.org/1999/xhtml" ? na(l) : i === "http://www.w3.org/2000/svg" && l === "foreignObject" ? "http://www.w3.org/1999/xhtml" : i;
  }
  var ra, Pi = function(i) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(l, v, k, D) {
      MSApp.execUnsafeLocalFunction(function() {
        return i(l, v, k, D);
      });
    } : i;
  }(function(i, l) {
    if (i.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in i)
      i.innerHTML = l;
    else {
      for (ra = ra || document.createElement("div"), ra.innerHTML = "<svg>" + l.valueOf().toString() + "</svg>", l = ra.firstChild; i.firstChild; )
        i.removeChild(i.firstChild);
      for (; l.firstChild; )
        i.appendChild(l.firstChild);
    }
  });
  function Ka(i, l) {
    if (l) {
      var v = i.firstChild;
      if (v && v === i.lastChild && v.nodeType === 3) {
        v.nodeValue = l;
        return;
      }
    }
    i.textContent = l;
  }
  var et = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Lt = ["Webkit", "ms", "Moz", "O"];
  Object.keys(et).forEach(function(i) {
    Lt.forEach(function(l) {
      l = l + i.charAt(0).toUpperCase() + i.substring(1), et[l] = et[i];
    });
  });
  function nn(i, l, v) {
    return l == null || typeof l == "boolean" || l === "" ? "" : v || typeof l != "number" || l === 0 || et.hasOwnProperty(i) && et[i] ? ("" + l).trim() : l + "px";
  }
  function bn(i, l) {
    i = i.style;
    for (var v in l)
      if (l.hasOwnProperty(v)) {
        var k = v.indexOf("--") === 0, D = nn(v, l[v], k);
        v === "float" && (v = "cssFloat"), k ? i.setProperty(v, D) : i[v] = D;
      }
  }
  var Bn = ye({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function vr(i, l) {
    if (l) {
      if (Bn[i] && (l.children != null || l.dangerouslySetInnerHTML != null))
        throw Error(h(137, i));
      if (l.dangerouslySetInnerHTML != null) {
        if (l.children != null)
          throw Error(h(60));
        if (typeof l.dangerouslySetInnerHTML != "object" || !("__html" in l.dangerouslySetInnerHTML))
          throw Error(h(61));
      }
      if (l.style != null && typeof l.style != "object")
        throw Error(h(62));
    }
  }
  function $n(i, l) {
    if (i.indexOf("-") === -1)
      return typeof l.is == "string";
    switch (i) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var aa = null;
  function Ln(i) {
    return i = i.target || i.srcElement || window, i.correspondingUseElement && (i = i.correspondingUseElement), i.nodeType === 3 ? i.parentNode : i;
  }
  var yr = null, kn = null, Cn = null;
  function cs(i) {
    if (i = Zu(i)) {
      if (typeof yr != "function")
        throw Error(h(280));
      var l = i.stateNode;
      l && (l = _t(l), yr(i.stateNode, i.type, l));
    }
  }
  function ds(i) {
    kn ? Cn ? Cn.push(i) : Cn = [i] : kn = i;
  }
  function fs() {
    if (kn) {
      var i = kn, l = Cn;
      if (Cn = kn = null, cs(i), l)
        for (i = 0; i < l.length; i++)
          cs(l[i]);
    }
  }
  function Vs(i, l) {
    return i(l);
  }
  function Ol() {
  }
  var hs = !1;
  function Gs(i, l, v) {
    if (hs)
      return i(l, v);
    hs = !0;
    try {
      return Vs(i, l, v);
    } finally {
      hs = !1, (kn !== null || Cn !== null) && (Ol(), fs());
    }
  }
  function ps(i, l) {
    var v = i.stateNode;
    if (v === null)
      return null;
    var k = _t(v);
    if (k === null)
      return null;
    v = k[l];
    e:
      switch (l) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (k = !k.disabled) || (i = i.type, k = !(i === "button" || i === "input" || i === "select" || i === "textarea")), i = !k;
          break e;
        default:
          i = !1;
      }
    if (i)
      return null;
    if (v && typeof v != "function")
      throw Error(h(231, l, typeof v));
    return v;
  }
  var $s = !1;
  if (F)
    try {
      var Ma = {};
      Object.defineProperty(Ma, "passive", { get: function() {
        $s = !0;
      } }), window.addEventListener("test", Ma, Ma), window.removeEventListener("test", Ma, Ma);
    } catch {
      $s = !1;
    }
  function Ni(i, l, v, k, D, z, $, ie, de) {
    var Re = Array.prototype.slice.call(arguments, 3);
    try {
      l.apply(v, Re);
    } catch (He) {
      this.onError(He);
    }
  }
  var jr = !1, ba = null, ia = !1, le = null, Ye = { onError: function(i) {
    jr = !0, ba = i;
  } };
  function tt(i, l, v, k, D, z, $, ie, de) {
    jr = !1, ba = null, Ni.apply(Ye, arguments);
  }
  function Dt(i, l, v, k, D, z, $, ie, de) {
    if (tt.apply(this, arguments), jr) {
      if (jr) {
        var Re = ba;
        jr = !1, ba = null;
      } else
        throw Error(h(198));
      ia || (ia = !0, le = Re);
    }
  }
  function qt(i) {
    var l = i, v = i;
    if (i.alternate)
      for (; l.return; )
        l = l.return;
    else {
      i = l;
      do
        l = i, l.flags & 4098 && (v = l.return), i = l.return;
      while (i);
    }
    return l.tag === 3 ? v : null;
  }
  function cn(i) {
    if (i.tag === 13) {
      var l = i.memoizedState;
      if (l === null && (i = i.alternate, i !== null && (l = i.memoizedState)), l !== null)
        return l.dehydrated;
    }
    return null;
  }
  function Zt(i) {
    if (qt(i) !== i)
      throw Error(h(188));
  }
  function Mt(i) {
    var l = i.alternate;
    if (!l) {
      if (l = qt(i), l === null)
        throw Error(h(188));
      return l !== i ? null : i;
    }
    for (var v = i, k = l; ; ) {
      var D = v.return;
      if (D === null)
        break;
      var z = D.alternate;
      if (z === null) {
        if (k = D.return, k !== null) {
          v = k;
          continue;
        }
        break;
      }
      if (D.child === z.child) {
        for (z = D.child; z; ) {
          if (z === v)
            return Zt(D), i;
          if (z === k)
            return Zt(D), l;
          z = z.sibling;
        }
        throw Error(h(188));
      }
      if (v.return !== k.return)
        v = D, k = z;
      else {
        for (var $ = !1, ie = D.child; ie; ) {
          if (ie === v) {
            $ = !0, v = D, k = z;
            break;
          }
          if (ie === k) {
            $ = !0, k = D, v = z;
            break;
          }
          ie = ie.sibling;
        }
        if (!$) {
          for (ie = z.child; ie; ) {
            if (ie === v) {
              $ = !0, v = z, k = D;
              break;
            }
            if (ie === k) {
              $ = !0, k = z, v = D;
              break;
            }
            ie = ie.sibling;
          }
          if (!$)
            throw Error(h(189));
        }
      }
      if (v.alternate !== k)
        throw Error(h(190));
    }
    if (v.tag !== 3)
      throw Error(h(188));
    return v.stateNode.current === v ? i : l;
  }
  function or(i) {
    return i = Mt(i), i !== null ? Yn(i) : null;
  }
  function Yn(i) {
    if (i.tag === 5 || i.tag === 6)
      return i;
    for (i = i.child; i !== null; ) {
      var l = Yn(i);
      if (l !== null)
        return l;
      i = i.sibling;
    }
    return null;
  }
  var W = u.unstable_scheduleCallback, t = u.unstable_cancelCallback, n = u.unstable_shouldYield, a = u.unstable_requestPaint, o = u.unstable_now, d = u.unstable_getCurrentPriorityLevel, f = u.unstable_ImmediatePriority, p = u.unstable_UserBlockingPriority, y = u.unstable_NormalPriority, S = u.unstable_LowPriority, C = u.unstable_IdlePriority, E = null, L = null;
  function M(i) {
    if (L && typeof L.onCommitFiberRoot == "function")
      try {
        L.onCommitFiberRoot(E, i, void 0, (i.current.flags & 128) === 128);
      } catch {
      }
  }
  var P = Math.clz32 ? Math.clz32 : G, I = Math.log, B = Math.LN2;
  function G(i) {
    return i >>>= 0, i === 0 ? 32 : 31 - (I(i) / B | 0) | 0;
  }
  var Z = 64, b = 4194304;
  function O(i) {
    switch (i & -i) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return i & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return i;
    }
  }
  function N(i, l) {
    var v = i.pendingLanes;
    if (v === 0)
      return 0;
    var k = 0, D = i.suspendedLanes, z = i.pingedLanes, $ = v & 268435455;
    if ($ !== 0) {
      var ie = $ & ~D;
      ie !== 0 ? k = O(ie) : (z &= $, z !== 0 && (k = O(z)));
    } else
      $ = v & ~D, $ !== 0 ? k = O($) : z !== 0 && (k = O(z));
    if (k === 0)
      return 0;
    if (l !== 0 && l !== k && !(l & D) && (D = k & -k, z = l & -l, D >= z || D === 16 && (z & 4194240) !== 0))
      return l;
    if (k & 4 && (k |= v & 16), l = i.entangledLanes, l !== 0)
      for (i = i.entanglements, l &= k; 0 < l; )
        v = 31 - P(l), D = 1 << v, k |= i[v], l &= ~D;
    return k;
  }
  function X(i, l) {
    switch (i) {
      case 1:
      case 2:
      case 4:
        return l + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Q(i, l) {
    for (var v = i.suspendedLanes, k = i.pingedLanes, D = i.expirationTimes, z = i.pendingLanes; 0 < z; ) {
      var $ = 31 - P(z), ie = 1 << $, de = D[$];
      de === -1 ? (!(ie & v) || ie & k) && (D[$] = X(ie, l)) : de <= l && (i.expiredLanes |= ie), z &= ~ie;
    }
  }
  function ee(i) {
    return i = i.pendingLanes & -1073741825, i !== 0 ? i : i & 1073741824 ? 1073741824 : 0;
  }
  function oe() {
    var i = Z;
    return Z <<= 1, !(Z & 4194240) && (Z = 64), i;
  }
  function fe(i) {
    for (var l = [], v = 0; 31 > v; v++)
      l.push(i);
    return l;
  }
  function ke(i, l, v) {
    i.pendingLanes |= l, l !== 536870912 && (i.suspendedLanes = 0, i.pingedLanes = 0), i = i.eventTimes, l = 31 - P(l), i[l] = v;
  }
  function _e(i, l) {
    var v = i.pendingLanes & ~l;
    i.pendingLanes = l, i.suspendedLanes = 0, i.pingedLanes = 0, i.expiredLanes &= l, i.mutableReadLanes &= l, i.entangledLanes &= l, l = i.entanglements;
    var k = i.eventTimes;
    for (i = i.expirationTimes; 0 < v; ) {
      var D = 31 - P(v), z = 1 << D;
      l[D] = 0, k[D] = -1, i[D] = -1, v &= ~z;
    }
  }
  function Le(i, l) {
    var v = i.entangledLanes |= l;
    for (i = i.entanglements; v; ) {
      var k = 31 - P(v), D = 1 << k;
      D & l | i[k] & l && (i[k] |= l), v &= ~D;
    }
  }
  var Ie = 0;
  function at(i) {
    return i &= -i, 1 < i ? 4 < i ? i & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var Qt, Kt, xt, On, zn, vt = !1, Br = [], Dn = null, sa = null, oa = null, xr = /* @__PURE__ */ new Map(), ln = /* @__PURE__ */ new Map(), wn = [], cx = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function zi(i, l) {
    switch (i) {
      case "focusin":
      case "focusout":
        Dn = null;
        break;
      case "dragenter":
      case "dragleave":
        sa = null;
        break;
      case "mouseover":
      case "mouseout":
        oa = null;
        break;
      case "pointerover":
      case "pointerout":
        xr.delete(l.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        ln.delete(l.pointerId);
    }
  }
  function la(i, l, v, k, D, z) {
    return i === null || i.nativeEvent !== z ? (i = { blockedOn: l, domEventName: v, eventSystemFlags: k, nativeEvent: z, targetContainers: [D] }, l !== null && (l = Zu(l), l !== null && Kt(l)), i) : (i.eventSystemFlags |= k, l = i.targetContainers, D !== null && l.indexOf(D) === -1 && l.push(D), i);
  }
  function qs(i, l, v, k, D) {
    switch (l) {
      case "focusin":
        return Dn = la(Dn, i, l, v, k, D), !0;
      case "dragenter":
        return sa = la(sa, i, l, v, k, D), !0;
      case "mouseover":
        return oa = la(oa, i, l, v, k, D), !0;
      case "pointerover":
        var z = D.pointerId;
        return xr.set(z, la(xr.get(z) || null, i, l, v, k, D)), !0;
      case "gotpointercapture":
        return z = D.pointerId, ln.set(z, la(ln.get(z) || null, i, l, v, k, D)), !0;
    }
    return !1;
  }
  function Tg(i) {
    var l = pi(i.target);
    if (l !== null) {
      var v = qt(l);
      if (v !== null) {
        if (l = v.tag, l === 13) {
          if (l = cn(v), l !== null) {
            i.blockedOn = l, zn(i.priority, function() {
              xt(v);
            });
            return;
          }
        } else if (l === 3 && v.stateNode.current.memoizedState.isDehydrated) {
          i.blockedOn = v.tag === 3 ? v.stateNode.containerInfo : null;
          return;
        }
      }
    }
    i.blockedOn = null;
  }
  function Dl(i) {
    if (i.blockedOn !== null)
      return !1;
    for (var l = i.targetContainers; 0 < l.length; ) {
      var v = Xc(i.domEventName, i.eventSystemFlags, l[0], i.nativeEvent);
      if (v === null) {
        v = i.nativeEvent;
        var k = new v.constructor(v.type, v);
        aa = k, v.target.dispatchEvent(k), aa = null;
      } else
        return l = Zu(v), l !== null && Kt(l), i.blockedOn = v, !1;
      l.shift();
    }
    return !0;
  }
  function Wf(i, l, v) {
    Dl(i) && v.delete(l);
  }
  function Ag() {
    vt = !1, Dn !== null && Dl(Dn) && (Dn = null), sa !== null && Dl(sa) && (sa = null), oa !== null && Dl(oa) && (oa = null), xr.forEach(Wf), ln.forEach(Wf);
  }
  function _u(i, l) {
    i.blockedOn === l && (i.blockedOn = null, vt || (vt = !0, u.unstable_scheduleCallback(u.unstable_NormalPriority, Ag)));
  }
  function Pu(i) {
    function l(D) {
      return _u(D, i);
    }
    if (0 < Br.length) {
      _u(Br[0], i);
      for (var v = 1; v < Br.length; v++) {
        var k = Br[v];
        k.blockedOn === i && (k.blockedOn = null);
      }
    }
    for (Dn !== null && _u(Dn, i), sa !== null && _u(sa, i), oa !== null && _u(oa, i), xr.forEach(l), ln.forEach(l), v = 0; v < wn.length; v++)
      k = wn[v], k.blockedOn === i && (k.blockedOn = null);
    for (; 0 < wn.length && (v = wn[0], v.blockedOn === null); )
      Tg(v), v.blockedOn === null && wn.shift();
  }
  var Ml = Ee.ReactCurrentBatchConfig, Po = !0;
  function Eg(i, l, v, k) {
    var D = Ie, z = Ml.transition;
    Ml.transition = null;
    try {
      Ie = 1, Uc(i, l, v, k);
    } finally {
      Ie = D, Ml.transition = z;
    }
  }
  function Wc(i, l, v, k) {
    var D = Ie, z = Ml.transition;
    Ml.transition = null;
    try {
      Ie = 4, Uc(i, l, v, k);
    } finally {
      Ie = D, Ml.transition = z;
    }
  }
  function Uc(i, l, v, k) {
    if (Po) {
      var D = Xc(i, l, v, k);
      if (D === null)
        rd(i, l, k, Nu, v), zi(i, k);
      else if (qs(D, i, l, v, k))
        k.stopPropagation();
      else if (zi(i, k), l & 4 && -1 < cx.indexOf(i)) {
        for (; D !== null; ) {
          var z = Zu(D);
          if (z !== null && Qt(z), z = Xc(i, l, v, k), z === null && rd(i, l, k, Nu, v), z === D)
            break;
          D = z;
        }
        D !== null && k.stopPropagation();
      } else
        rd(i, l, k, null, v);
    }
  }
  var Nu = null;
  function Xc(i, l, v, k) {
    if (Nu = null, i = Ln(k), i = pi(i), i !== null)
      if (l = qt(i), l === null)
        i = null;
      else if (v = l.tag, v === 13) {
        if (i = cn(l), i !== null)
          return i;
        i = null;
      } else if (v === 3) {
        if (l.stateNode.current.memoizedState.isDehydrated)
          return l.tag === 3 ? l.stateNode.containerInfo : null;
        i = null;
      } else
        l !== i && (i = null);
    return Nu = i, null;
  }
  function Uf(i) {
    switch (i) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (d()) {
          case f:
            return 1;
          case p:
            return 4;
          case y:
          case S:
            return 16;
          case C:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var gs = null, zu = null, Iu = null;
  function Xf() {
    if (Iu)
      return Iu;
    var i, l = zu, v = l.length, k, D = "value" in gs ? gs.value : gs.textContent, z = D.length;
    for (i = 0; i < v && l[i] === D[i]; i++)
      ;
    var $ = v - i;
    for (k = 1; k <= $ && l[v - k] === D[z - k]; k++)
      ;
    return Iu = D.slice(i, 1 < k ? 1 - k : void 0);
  }
  function _l(i) {
    var l = i.keyCode;
    return "charCode" in i ? (i = i.charCode, i === 0 && l === 13 && (i = 13)) : i = l, i === 10 && (i = 13), 32 <= i || i === 13 ? i : 0;
  }
  function Fu() {
    return !0;
  }
  function Rg() {
    return !1;
  }
  function Ja(i) {
    function l(v, k, D, z, $) {
      this._reactName = v, this._targetInst = D, this.type = k, this.nativeEvent = z, this.target = $, this.currentTarget = null;
      for (var ie in i)
        i.hasOwnProperty(ie) && (v = i[ie], this[ie] = v ? v(z) : z[ie]);
      return this.isDefaultPrevented = (z.defaultPrevented != null ? z.defaultPrevented : z.returnValue === !1) ? Fu : Rg, this.isPropagationStopped = Rg, this;
    }
    return ye(l.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var v = this.nativeEvent;
      v && (v.preventDefault ? v.preventDefault() : typeof v.returnValue != "unknown" && (v.returnValue = !1), this.isDefaultPrevented = Fu);
    }, stopPropagation: function() {
      var v = this.nativeEvent;
      v && (v.stopPropagation ? v.stopPropagation() : typeof v.cancelBubble != "unknown" && (v.cancelBubble = !0), this.isPropagationStopped = Fu);
    }, persist: function() {
    }, isPersistent: Fu }), l;
  }
  var Zs = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(i) {
    return i.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Vc = Ja(Zs), Pl = ye({}, Zs, { view: 0, detail: 0 }), Lg = Ja(Pl), Gc, Vf, Yu, _r = ye({}, Pl, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Zf, button: 0, buttons: 0, relatedTarget: function(i) {
    return i.relatedTarget === void 0 ? i.fromElement === i.srcElement ? i.toElement : i.fromElement : i.relatedTarget;
  }, movementX: function(i) {
    return "movementX" in i ? i.movementX : (i !== Yu && (Yu && i.type === "mousemove" ? (Gc = i.screenX - Yu.screenX, Vf = i.screenY - Yu.screenY) : Vf = Gc = 0, Yu = i), Gc);
  }, movementY: function(i) {
    return "movementY" in i ? i.movementY : Vf;
  } }), $c = Ja(_r), Og = ye({}, _r, { dataTransfer: 0 }), Dg = Ja(Og), dx = ye({}, Pl, { relatedTarget: 0 }), Qs = Ja(dx), Gf = ye({}, Zs, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Mg = Ja(Gf), fx = ye({}, Zs, { clipboardData: function(i) {
    return "clipboardData" in i ? i.clipboardData : window.clipboardData;
  } }), hx = Ja(fx), px = ye({}, Zs, { data: 0 }), $f = Ja(px), qf = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, _g = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Pg = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Ng(i) {
    var l = this.nativeEvent;
    return l.getModifierState ? l.getModifierState(i) : (i = Pg[i]) ? !!l[i] : !1;
  }
  function Zf() {
    return Ng;
  }
  var ms = ye({}, Pl, { key: function(i) {
    if (i.key) {
      var l = qf[i.key] || i.key;
      if (l !== "Unidentified")
        return l;
    }
    return i.type === "keypress" ? (i = _l(i), i === 13 ? "Enter" : String.fromCharCode(i)) : i.type === "keydown" || i.type === "keyup" ? _g[i.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Zf, charCode: function(i) {
    return i.type === "keypress" ? _l(i) : 0;
  }, keyCode: function(i) {
    return i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
  }, which: function(i) {
    return i.type === "keypress" ? _l(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
  } }), gx = Ja(ms), Qf = ye({}, _r, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), qc = Ja(Qf), Kf = ye({}, Pl, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Zf }), mx = Ja(Kf), Zc = ye({}, Zs, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), zg = Ja(Zc), _a = ye({}, _r, {
    deltaX: function(i) {
      return "deltaX" in i ? i.deltaX : "wheelDeltaX" in i ? -i.wheelDeltaX : 0;
    },
    deltaY: function(i) {
      return "deltaY" in i ? i.deltaY : "wheelDeltaY" in i ? -i.wheelDeltaY : "wheelDelta" in i ? -i.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), vs = Ja(_a), br = [9, 13, 27, 32], Ii = F && "CompositionEvent" in window, No = null;
  F && "documentMode" in document && (No = document.documentMode);
  var Qc = F && "TextEvent" in window && !No, Ig = F && (!Ii || No && 8 < No && 11 >= No), Nl = String.fromCharCode(32), Fg = !1;
  function Yg(i, l) {
    switch (i) {
      case "keyup":
        return br.indexOf(l.keyCode) !== -1;
      case "keydown":
        return l.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Kc(i) {
    return i = i.detail, typeof i == "object" && "data" in i ? i.data : null;
  }
  var zl = !1;
  function vx(i, l) {
    switch (i) {
      case "compositionend":
        return Kc(l);
      case "keypress":
        return l.which !== 32 ? null : (Fg = !0, Nl);
      case "textInput":
        return i = l.data, i === Nl && Fg ? null : i;
      default:
        return null;
    }
  }
  function yx(i, l) {
    if (zl)
      return i === "compositionend" || !Ii && Yg(i, l) ? (i = Xf(), Iu = zu = gs = null, zl = !1, i) : null;
    switch (i) {
      case "paste":
        return null;
      case "keypress":
        if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) {
          if (l.char && 1 < l.char.length)
            return l.char;
          if (l.which)
            return String.fromCharCode(l.which);
        }
        return null;
      case "compositionend":
        return Ig && l.locale !== "ko" ? null : l.data;
      default:
        return null;
    }
  }
  var Hg = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function jg(i) {
    var l = i && i.nodeName && i.nodeName.toLowerCase();
    return l === "input" ? !!Hg[i.type] : l === "textarea";
  }
  function Bg(i, l, v, k) {
    ds(k), l = Gu(l, "onChange"), 0 < l.length && (v = new Vc("onChange", "change", null, v, k), i.push({ event: v, listeners: l }));
  }
  var Hu = null, Il = null;
  function Fl(i) {
    nd(i, 0);
  }
  function Yl(i) {
    var l = jl(i);
    if (qe(l))
      return i;
  }
  function Wg(i, l) {
    if (i === "change")
      return l;
  }
  var Jf = !1;
  if (F) {
    var eh;
    if (F) {
      var th = "oninput" in document;
      if (!th) {
        var Ug = document.createElement("div");
        Ug.setAttribute("oninput", "return;"), th = typeof Ug.oninput == "function";
      }
      eh = th;
    } else
      eh = !1;
    Jf = eh && (!document.documentMode || 9 < document.documentMode);
  }
  function Xg() {
    Hu && (Hu.detachEvent("onpropertychange", Vg), Il = Hu = null);
  }
  function Vg(i) {
    if (i.propertyName === "value" && Yl(Il)) {
      var l = [];
      Bg(l, Il, i, Ln(i)), Gs(Fl, l);
    }
  }
  function xx(i, l, v) {
    i === "focusin" ? (Xg(), Hu = l, Il = v, Hu.attachEvent("onpropertychange", Vg)) : i === "focusout" && Xg();
  }
  function bx(i) {
    if (i === "selectionchange" || i === "keyup" || i === "keydown")
      return Yl(Il);
  }
  function wx(i, l) {
    if (i === "click")
      return Yl(l);
  }
  function Gg(i, l) {
    if (i === "input" || i === "change")
      return Yl(l);
  }
  function Sx(i, l) {
    return i === l && (i !== 0 || 1 / i === 1 / l) || i !== i && l !== l;
  }
  var hi = typeof Object.is == "function" ? Object.is : Sx;
  function ju(i, l) {
    if (hi(i, l))
      return !0;
    if (typeof i != "object" || i === null || typeof l != "object" || l === null)
      return !1;
    var v = Object.keys(i), k = Object.keys(l);
    if (v.length !== k.length)
      return !1;
    for (k = 0; k < v.length; k++) {
      var D = v[k];
      if (!H.call(l, D) || !hi(i[D], l[D]))
        return !1;
    }
    return !0;
  }
  function $g(i) {
    for (; i && i.firstChild; )
      i = i.firstChild;
    return i;
  }
  function qg(i, l) {
    var v = $g(i);
    i = 0;
    for (var k; v; ) {
      if (v.nodeType === 3) {
        if (k = i + v.textContent.length, i <= l && k >= l)
          return { node: v, offset: l - i };
        i = k;
      }
      e: {
        for (; v; ) {
          if (v.nextSibling) {
            v = v.nextSibling;
            break e;
          }
          v = v.parentNode;
        }
        v = void 0;
      }
      v = $g(v);
    }
  }
  function Zg(i, l) {
    return i && l ? i === l ? !0 : i && i.nodeType === 3 ? !1 : l && l.nodeType === 3 ? Zg(i, l.parentNode) : "contains" in i ? i.contains(l) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(l) & 16) : !1 : !1;
  }
  function Jc() {
    for (var i = window, l = pn(); l instanceof i.HTMLIFrameElement; ) {
      try {
        var v = typeof l.contentWindow.location.href == "string";
      } catch {
        v = !1;
      }
      if (v)
        i = l.contentWindow;
      else
        break;
      l = pn(i.document);
    }
    return l;
  }
  function ys(i) {
    var l = i && i.nodeName && i.nodeName.toLowerCase();
    return l && (l === "input" && (i.type === "text" || i.type === "search" || i.type === "tel" || i.type === "url" || i.type === "password") || l === "textarea" || i.contentEditable === "true");
  }
  function ed(i) {
    var l = Jc(), v = i.focusedElem, k = i.selectionRange;
    if (l !== v && v && v.ownerDocument && Zg(v.ownerDocument.documentElement, v)) {
      if (k !== null && ys(v)) {
        if (l = k.start, i = k.end, i === void 0 && (i = l), "selectionStart" in v)
          v.selectionStart = l, v.selectionEnd = Math.min(i, v.value.length);
        else if (i = (l = v.ownerDocument || document) && l.defaultView || window, i.getSelection) {
          i = i.getSelection();
          var D = v.textContent.length, z = Math.min(k.start, D);
          k = k.end === void 0 ? z : Math.min(k.end, D), !i.extend && z > k && (D = k, k = z, z = D), D = qg(v, z);
          var $ = qg(
            v,
            k
          );
          D && $ && (i.rangeCount !== 1 || i.anchorNode !== D.node || i.anchorOffset !== D.offset || i.focusNode !== $.node || i.focusOffset !== $.offset) && (l = l.createRange(), l.setStart(D.node, D.offset), i.removeAllRanges(), z > k ? (i.addRange(l), i.extend($.node, $.offset)) : (l.setEnd($.node, $.offset), i.addRange(l)));
        }
      }
      for (l = [], i = v; i = i.parentNode; )
        i.nodeType === 1 && l.push({ element: i, left: i.scrollLeft, top: i.scrollTop });
      for (typeof v.focus == "function" && v.focus(), v = 0; v < l.length; v++)
        i = l[v], i.element.scrollLeft = i.left, i.element.scrollTop = i.top;
    }
  }
  var Qg = F && "documentMode" in document && 11 >= document.documentMode, Fi = null, nh = null, Bu = null, rh = !1;
  function Kg(i, l, v) {
    var k = v.window === v ? v.document : v.nodeType === 9 ? v : v.ownerDocument;
    rh || Fi == null || Fi !== pn(k) || (k = Fi, "selectionStart" in k && ys(k) ? k = { start: k.selectionStart, end: k.selectionEnd } : (k = (k.ownerDocument && k.ownerDocument.defaultView || window).getSelection(), k = { anchorNode: k.anchorNode, anchorOffset: k.anchorOffset, focusNode: k.focusNode, focusOffset: k.focusOffset }), Bu && ju(Bu, k) || (Bu = k, k = Gu(nh, "onSelect"), 0 < k.length && (l = new Vc("onSelect", "select", null, l, v), i.push({ event: l, listeners: k }), l.target = Fi)));
  }
  function td(i, l) {
    var v = {};
    return v[i.toLowerCase()] = l.toLowerCase(), v["Webkit" + i] = "webkit" + l, v["Moz" + i] = "moz" + l, v;
  }
  var zo = { animationend: td("Animation", "AnimationEnd"), animationiteration: td("Animation", "AnimationIteration"), animationstart: td("Animation", "AnimationStart"), transitionend: td("Transition", "TransitionEnd") }, ah = {}, ih = {};
  F && (ih = document.createElement("div").style, "AnimationEvent" in window || (delete zo.animationend.animation, delete zo.animationiteration.animation, delete zo.animationstart.animation), "TransitionEvent" in window || delete zo.transitionend.transition);
  function Pr(i) {
    if (ah[i])
      return ah[i];
    if (!zo[i])
      return i;
    var l = zo[i], v;
    for (v in l)
      if (l.hasOwnProperty(v) && v in ih)
        return ah[i] = l[v];
    return i;
  }
  var sh = Pr("animationend"), Jg = Pr("animationiteration"), em = Pr("animationstart"), tm = Pr("transitionend"), nm = /* @__PURE__ */ new Map(), rm = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function xs(i, l) {
    nm.set(i, l), T(l, [i]);
  }
  for (var Wu = 0; Wu < rm.length; Wu++) {
    var Io = rm[Wu], kx = Io.toLowerCase(), Uu = Io[0].toUpperCase() + Io.slice(1);
    xs(kx, "on" + Uu);
  }
  xs(sh, "onAnimationEnd"), xs(Jg, "onAnimationIteration"), xs(em, "onAnimationStart"), xs("dblclick", "onDoubleClick"), xs("focusin", "onFocus"), xs("focusout", "onBlur"), xs(tm, "onTransitionEnd"), A("onMouseEnter", ["mouseout", "mouseover"]), A("onMouseLeave", ["mouseout", "mouseover"]), A("onPointerEnter", ["pointerout", "pointerover"]), A("onPointerLeave", ["pointerout", "pointerover"]), T("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), T("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), T("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), T("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), T("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), T("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Xu = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Cx = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xu));
  function am(i, l, v) {
    var k = i.type || "unknown-event";
    i.currentTarget = v, Dt(k, l, void 0, i), i.currentTarget = null;
  }
  function nd(i, l) {
    l = (l & 4) !== 0;
    for (var v = 0; v < i.length; v++) {
      var k = i[v], D = k.event;
      k = k.listeners;
      e: {
        var z = void 0;
        if (l)
          for (var $ = k.length - 1; 0 <= $; $--) {
            var ie = k[$], de = ie.instance, Re = ie.currentTarget;
            if (ie = ie.listener, de !== z && D.isPropagationStopped())
              break e;
            am(D, ie, Re), z = de;
          }
        else
          for ($ = 0; $ < k.length; $++) {
            if (ie = k[$], de = ie.instance, Re = ie.currentTarget, ie = ie.listener, de !== z && D.isPropagationStopped())
              break e;
            am(D, ie, Re), z = de;
          }
      }
    }
    if (ia)
      throw i = le, ia = !1, le = null, i;
  }
  function In(i, l) {
    var v = l[hh];
    v === void 0 && (v = l[hh] = /* @__PURE__ */ new Set());
    var k = i + "__bubble";
    v.has(k) || (im(l, i, 2, !1), v.add(k));
  }
  function Ks(i, l, v) {
    var k = 0;
    l && (k |= 4), im(v, i, k, l);
  }
  var bs = "_reactListening" + Math.random().toString(36).slice(2);
  function Hl(i) {
    if (!i[bs]) {
      i[bs] = !0, m.forEach(function(v) {
        v !== "selectionchange" && (Cx.has(v) || Ks(v, !1, i), Ks(v, !0, i));
      });
      var l = i.nodeType === 9 ? i : i.ownerDocument;
      l === null || l[bs] || (l[bs] = !0, Ks("selectionchange", !1, l));
    }
  }
  function im(i, l, v, k) {
    switch (Uf(l)) {
      case 1:
        var D = Eg;
        break;
      case 4:
        D = Wc;
        break;
      default:
        D = Uc;
    }
    v = D.bind(null, l, v, i), D = void 0, !$s || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (D = !0), k ? D !== void 0 ? i.addEventListener(l, v, { capture: !0, passive: D }) : i.addEventListener(l, v, !0) : D !== void 0 ? i.addEventListener(l, v, { passive: D }) : i.addEventListener(l, v, !1);
  }
  function rd(i, l, v, k, D) {
    var z = k;
    if (!(l & 1) && !(l & 2) && k !== null)
      e:
        for (; ; ) {
          if (k === null)
            return;
          var $ = k.tag;
          if ($ === 3 || $ === 4) {
            var ie = k.stateNode.containerInfo;
            if (ie === D || ie.nodeType === 8 && ie.parentNode === D)
              break;
            if ($ === 4)
              for ($ = k.return; $ !== null; ) {
                var de = $.tag;
                if ((de === 3 || de === 4) && (de = $.stateNode.containerInfo, de === D || de.nodeType === 8 && de.parentNode === D))
                  return;
                $ = $.return;
              }
            for (; ie !== null; ) {
              if ($ = pi(ie), $ === null)
                return;
              if (de = $.tag, de === 5 || de === 6) {
                k = z = $;
                continue e;
              }
              ie = ie.parentNode;
            }
          }
          k = k.return;
        }
    Gs(function() {
      var Re = z, He = Ln(v), Be = [];
      e: {
        var Fe = nm.get(i);
        if (Fe !== void 0) {
          var lt = Vc, bt = i;
          switch (i) {
            case "keypress":
              if (_l(v) === 0)
                break e;
            case "keydown":
            case "keyup":
              lt = gx;
              break;
            case "focusin":
              bt = "focus", lt = Qs;
              break;
            case "focusout":
              bt = "blur", lt = Qs;
              break;
            case "beforeblur":
            case "afterblur":
              lt = Qs;
              break;
            case "click":
              if (v.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              lt = $c;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              lt = Dg;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              lt = mx;
              break;
            case sh:
            case Jg:
            case em:
              lt = Mg;
              break;
            case tm:
              lt = zg;
              break;
            case "scroll":
              lt = Lg;
              break;
            case "wheel":
              lt = vs;
              break;
            case "copy":
            case "cut":
            case "paste":
              lt = hx;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              lt = qc;
          }
          var Ct = (l & 4) !== 0, pr = !Ct && i === "scroll", ve = Ct ? Fe !== null ? Fe + "Capture" : null : Fe;
          Ct = [];
          for (var pe = Re, Se; pe !== null; ) {
            Se = pe;
            var $e = Se.stateNode;
            if (Se.tag === 5 && $e !== null && (Se = $e, ve !== null && ($e = ps(pe, ve), $e != null && Ct.push(Vu(pe, $e, Se)))), pr)
              break;
            pe = pe.return;
          }
          0 < Ct.length && (Fe = new lt(Fe, bt, null, v, He), Be.push({ event: Fe, listeners: Ct }));
        }
      }
      if (!(l & 7)) {
        e: {
          if (Fe = i === "mouseover" || i === "pointerover", lt = i === "mouseout" || i === "pointerout", Fe && v !== aa && (bt = v.relatedTarget || v.fromElement) && (pi(bt) || bt[ws]))
            break e;
          if ((lt || Fe) && (Fe = He.window === He ? He : (Fe = He.ownerDocument) ? Fe.defaultView || Fe.parentWindow : window, lt ? (bt = v.relatedTarget || v.toElement, lt = Re, bt = bt ? pi(bt) : null, bt !== null && (pr = qt(bt), bt !== pr || bt.tag !== 5 && bt.tag !== 6) && (bt = null)) : (lt = null, bt = Re), lt !== bt)) {
            if (Ct = $c, $e = "onMouseLeave", ve = "onMouseEnter", pe = "mouse", (i === "pointerout" || i === "pointerover") && (Ct = qc, $e = "onPointerLeave", ve = "onPointerEnter", pe = "pointer"), pr = lt == null ? Fe : jl(lt), Se = bt == null ? Fe : jl(bt), Fe = new Ct($e, pe + "leave", lt, v, He), Fe.target = pr, Fe.relatedTarget = Se, $e = null, pi(He) === Re && (Ct = new Ct(ve, pe + "enter", bt, v, He), Ct.target = Se, Ct.relatedTarget = pr, $e = Ct), pr = $e, lt && bt)
              t: {
                for (Ct = lt, ve = bt, pe = 0, Se = Ct; Se; Se = Fo(Se))
                  pe++;
                for (Se = 0, $e = ve; $e; $e = Fo($e))
                  Se++;
                for (; 0 < pe - Se; )
                  Ct = Fo(Ct), pe--;
                for (; 0 < Se - pe; )
                  ve = Fo(ve), Se--;
                for (; pe--; ) {
                  if (Ct === ve || ve !== null && Ct === ve.alternate)
                    break t;
                  Ct = Fo(Ct), ve = Fo(ve);
                }
                Ct = null;
              }
            else
              Ct = null;
            lt !== null && oh(Be, Fe, lt, Ct, !1), bt !== null && pr !== null && oh(Be, pr, bt, Ct, !0);
          }
        }
        e: {
          if (Fe = Re ? jl(Re) : window, lt = Fe.nodeName && Fe.nodeName.toLowerCase(), lt === "select" || lt === "input" && Fe.type === "file")
            var At = Wg;
          else if (jg(Fe))
            if (Jf)
              At = Gg;
            else {
              At = bx;
              var wt = xx;
            }
          else
            (lt = Fe.nodeName) && lt.toLowerCase() === "input" && (Fe.type === "checkbox" || Fe.type === "radio") && (At = wx);
          if (At && (At = At(i, Re))) {
            Bg(Be, At, v, He);
            break e;
          }
          wt && wt(i, Fe, Re), i === "focusout" && (wt = Fe._wrapperState) && wt.controlled && Fe.type === "number" && Za(Fe, "number", Fe.value);
        }
        switch (wt = Re ? jl(Re) : window, i) {
          case "focusin":
            (jg(wt) || wt.contentEditable === "true") && (Fi = wt, nh = Re, Bu = null);
            break;
          case "focusout":
            Bu = nh = Fi = null;
            break;
          case "mousedown":
            rh = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            rh = !1, Kg(Be, v, He);
            break;
          case "selectionchange":
            if (Qg)
              break;
          case "keydown":
          case "keyup":
            Kg(Be, v, He);
        }
        var Ot;
        if (Ii)
          e: {
            switch (i) {
              case "compositionstart":
                var Vt = "onCompositionStart";
                break e;
              case "compositionend":
                Vt = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Vt = "onCompositionUpdate";
                break e;
            }
            Vt = void 0;
          }
        else
          zl ? Yg(i, v) && (Vt = "onCompositionEnd") : i === "keydown" && v.keyCode === 229 && (Vt = "onCompositionStart");
        Vt && (Ig && v.locale !== "ko" && (zl || Vt !== "onCompositionStart" ? Vt === "onCompositionEnd" && zl && (Ot = Xf()) : (gs = He, zu = "value" in gs ? gs.value : gs.textContent, zl = !0)), wt = Gu(Re, Vt), 0 < wt.length && (Vt = new $f(Vt, i, null, v, He), Be.push({ event: Vt, listeners: wt }), Ot ? Vt.data = Ot : (Ot = Kc(v), Ot !== null && (Vt.data = Ot)))), (Ot = Qc ? vx(i, v) : yx(i, v)) && (Re = Gu(Re, "onBeforeInput"), 0 < Re.length && (He = new $f("onBeforeInput", "beforeinput", null, v, He), Be.push({ event: He, listeners: Re }), He.data = Ot));
      }
      nd(Be, l);
    });
  }
  function Vu(i, l, v) {
    return { instance: i, listener: l, currentTarget: v };
  }
  function Gu(i, l) {
    for (var v = l + "Capture", k = []; i !== null; ) {
      var D = i, z = D.stateNode;
      D.tag === 5 && z !== null && (D = z, z = ps(i, v), z != null && k.unshift(Vu(i, z, D)), z = ps(i, l), z != null && k.push(Vu(i, z, D))), i = i.return;
    }
    return k;
  }
  function Fo(i) {
    if (i === null)
      return null;
    do
      i = i.return;
    while (i && i.tag !== 5);
    return i || null;
  }
  function oh(i, l, v, k, D) {
    for (var z = l._reactName, $ = []; v !== null && v !== k; ) {
      var ie = v, de = ie.alternate, Re = ie.stateNode;
      if (de !== null && de === k)
        break;
      ie.tag === 5 && Re !== null && (ie = Re, D ? (de = ps(v, z), de != null && $.unshift(Vu(v, de, ie))) : D || (de = ps(v, z), de != null && $.push(Vu(v, de, ie)))), v = v.return;
    }
    $.length !== 0 && i.push({ event: l, listeners: $ });
  }
  var lh = /\r\n?/g, Tx = /\u0000|\uFFFD/g;
  function uh(i) {
    return (typeof i == "string" ? i : "" + i).replace(lh, `
`).replace(Tx, "");
  }
  function ad(i, l, v) {
    if (l = uh(l), uh(i) !== l && v)
      throw Error(h(425));
  }
  function id() {
  }
  var ch = null, Yo = null;
  function $u(i, l) {
    return i === "textarea" || i === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null;
  }
  var Ho = typeof setTimeout == "function" ? setTimeout : void 0, sm = typeof clearTimeout == "function" ? clearTimeout : void 0, dh = typeof Promise == "function" ? Promise : void 0, fh = typeof queueMicrotask == "function" ? queueMicrotask : typeof dh < "u" ? function(i) {
    return dh.resolve(null).then(i).catch(Ax);
  } : Ho;
  function Ax(i) {
    setTimeout(function() {
      throw i;
    });
  }
  function Js(i, l) {
    var v = l, k = 0;
    do {
      var D = v.nextSibling;
      if (i.removeChild(v), D && D.nodeType === 8)
        if (v = D.data, v === "/$") {
          if (k === 0) {
            i.removeChild(D), Pu(l);
            return;
          }
          k--;
        } else
          v !== "$" && v !== "$?" && v !== "$!" || k++;
      v = D;
    } while (v);
    Pu(l);
  }
  function Yi(i) {
    for (; i != null; i = i.nextSibling) {
      var l = i.nodeType;
      if (l === 1 || l === 3)
        break;
      if (l === 8) {
        if (l = i.data, l === "$" || l === "$!" || l === "$?")
          break;
        if (l === "/$")
          return null;
      }
    }
    return i;
  }
  function qu(i) {
    i = i.previousSibling;
    for (var l = 0; i; ) {
      if (i.nodeType === 8) {
        var v = i.data;
        if (v === "$" || v === "$!" || v === "$?") {
          if (l === 0)
            return i;
          l--;
        } else
          v === "/$" && l++;
      }
      i = i.previousSibling;
    }
    return null;
  }
  var eo = Math.random().toString(36).slice(2), Gi = "__reactFiber$" + eo, jo = "__reactProps$" + eo, ws = "__reactContainer$" + eo, hh = "__reactEvents$" + eo, Ex = "__reactListeners$" + eo, ph = "__reactHandles$" + eo;
  function pi(i) {
    var l = i[Gi];
    if (l)
      return l;
    for (var v = i.parentNode; v; ) {
      if (l = v[ws] || v[Gi]) {
        if (v = l.alternate, l.child !== null || v !== null && v.child !== null)
          for (i = qu(i); i !== null; ) {
            if (v = i[Gi])
              return v;
            i = qu(i);
          }
        return l;
      }
      i = v, v = i.parentNode;
    }
    return null;
  }
  function Zu(i) {
    return i = i[Gi] || i[ws], !i || i.tag !== 5 && i.tag !== 6 && i.tag !== 13 && i.tag !== 3 ? null : i;
  }
  function jl(i) {
    if (i.tag === 5 || i.tag === 6)
      return i.stateNode;
    throw Error(h(33));
  }
  function _t(i) {
    return i[jo] || null;
  }
  var to = [], Wn = -1;
  function en(i) {
    return { current: i };
  }
  function Sn(i) {
    0 > Wn || (i.current = to[Wn], to[Wn] = null, Wn--);
  }
  function Tn(i, l) {
    Wn++, to[Wn] = i.current, i.current = l;
  }
  var $i = {}, Xt = en($i), lr = en(!1), Pa = $i;
  function gi(i, l) {
    var v = i.type.contextTypes;
    if (!v)
      return $i;
    var k = i.stateNode;
    if (k && k.__reactInternalMemoizedUnmaskedChildContext === l)
      return k.__reactInternalMemoizedMaskedChildContext;
    var D = {}, z;
    for (z in v)
      D[z] = l[z];
    return k && (i = i.stateNode, i.__reactInternalMemoizedUnmaskedChildContext = l, i.__reactInternalMemoizedMaskedChildContext = D), D;
  }
  function qn(i) {
    return i = i.childContextTypes, i != null;
  }
  function mi() {
    Sn(lr), Sn(Xt);
  }
  function no(i, l, v) {
    if (Xt.current !== $i)
      throw Error(h(168));
    Tn(Xt, l), Tn(lr, v);
  }
  function Qu(i, l, v) {
    var k = i.stateNode;
    if (l = l.childContextTypes, typeof k.getChildContext != "function")
      return v;
    k = k.getChildContext();
    for (var D in k)
      if (!(D in l))
        throw Error(h(108, Nt(i) || "Unknown", D));
    return ye({}, v, k);
  }
  function sd(i) {
    return i = (i = i.stateNode) && i.__reactInternalMemoizedMergedChildContext || $i, Pa = Xt.current, Tn(Xt, i), Tn(lr, lr.current), !0;
  }
  function om(i, l, v) {
    var k = i.stateNode;
    if (!k)
      throw Error(h(169));
    v ? (i = Qu(i, l, Pa), k.__reactInternalMemoizedMergedChildContext = i, Sn(lr), Sn(Xt), Tn(Xt, i)) : Sn(lr), Tn(lr, v);
  }
  var ei = null, Nr = !1, Ku = !1;
  function gh(i) {
    ei === null ? ei = [i] : ei.push(i);
  }
  function mh(i) {
    Nr = !0, gh(i);
  }
  function Na() {
    if (!Ku && ei !== null) {
      Ku = !0;
      var i = 0, l = Ie;
      try {
        var v = ei;
        for (Ie = 1; i < v.length; i++) {
          var k = v[i];
          do
            k = k(!0);
          while (k !== null);
        }
        ei = null, Nr = !1;
      } catch (D) {
        throw ei !== null && (ei = ei.slice(i + 1)), W(f, Na), D;
      } finally {
        Ie = l, Ku = !1;
      }
    }
    return null;
  }
  var ro = [], za = 0, Bo = null, Bl = 0, Ia = [], ua = 0, vi = null, Wr = 1, Ss = "";
  function ti(i, l) {
    ro[za++] = Bl, ro[za++] = Bo, Bo = i, Bl = l;
  }
  function vh(i, l, v) {
    Ia[ua++] = Wr, Ia[ua++] = Ss, Ia[ua++] = vi, vi = i;
    var k = Wr;
    i = Ss;
    var D = 32 - P(k) - 1;
    k &= ~(1 << D), v += 1;
    var z = 32 - P(l) + D;
    if (30 < z) {
      var $ = D - D % 5;
      z = (k & (1 << $) - 1).toString(32), k >>= $, D -= $, Wr = 1 << 32 - P(l) + D | v << D | k, Ss = z + i;
    } else
      Wr = 1 << z | v << D | k, Ss = i;
  }
  function od(i) {
    i.return !== null && (ti(i, 1), vh(i, 1, 0));
  }
  function yh(i) {
    for (; i === Bo; )
      Bo = ro[--za], ro[za] = null, Bl = ro[--za], ro[za] = null;
    for (; i === vi; )
      vi = Ia[--ua], Ia[ua] = null, Ss = Ia[--ua], Ia[ua] = null, Wr = Ia[--ua], Ia[ua] = null;
  }
  var ni = null, Fa = null, Un = !1, yi = null;
  function xh(i, l) {
    var v = Ci(5, null, null, 0);
    v.elementType = "DELETED", v.stateNode = l, v.return = i, l = i.deletions, l === null ? (i.deletions = [v], i.flags |= 16) : l.push(v);
  }
  function lm(i, l) {
    switch (i.tag) {
      case 5:
        var v = i.type;
        return l = l.nodeType !== 1 || v.toLowerCase() !== l.nodeName.toLowerCase() ? null : l, l !== null ? (i.stateNode = l, ni = i, Fa = Yi(l.firstChild), !0) : !1;
      case 6:
        return l = i.pendingProps === "" || l.nodeType !== 3 ? null : l, l !== null ? (i.stateNode = l, ni = i, Fa = null, !0) : !1;
      case 13:
        return l = l.nodeType !== 8 ? null : l, l !== null ? (v = vi !== null ? { id: Wr, overflow: Ss } : null, i.memoizedState = { dehydrated: l, treeContext: v, retryLane: 1073741824 }, v = Ci(18, null, null, 0), v.stateNode = l, v.return = i, i.child = v, ni = i, Fa = null, !0) : !1;
      default:
        return !1;
    }
  }
  function ld(i) {
    return (i.mode & 1) !== 0 && (i.flags & 128) === 0;
  }
  function ud(i) {
    if (Un) {
      var l = Fa;
      if (l) {
        var v = l;
        if (!lm(i, l)) {
          if (ld(i))
            throw Error(h(418));
          l = Yi(v.nextSibling);
          var k = ni;
          l && lm(i, l) ? xh(k, v) : (i.flags = i.flags & -4097 | 2, Un = !1, ni = i);
        }
      } else {
        if (ld(i))
          throw Error(h(418));
        i.flags = i.flags & -4097 | 2, Un = !1, ni = i;
      }
    }
  }
  function um(i) {
    for (i = i.return; i !== null && i.tag !== 5 && i.tag !== 3 && i.tag !== 13; )
      i = i.return;
    ni = i;
  }
  function cd(i) {
    if (i !== ni)
      return !1;
    if (!Un)
      return um(i), Un = !0, !1;
    var l;
    if ((l = i.tag !== 3) && !(l = i.tag !== 5) && (l = i.type, l = l !== "head" && l !== "body" && !$u(i.type, i.memoizedProps)), l && (l = Fa)) {
      if (ld(i))
        throw cm(), Error(h(418));
      for (; l; )
        xh(i, l), l = Yi(l.nextSibling);
    }
    if (um(i), i.tag === 13) {
      if (i = i.memoizedState, i = i !== null ? i.dehydrated : null, !i)
        throw Error(h(317));
      e: {
        for (i = i.nextSibling, l = 0; i; ) {
          if (i.nodeType === 8) {
            var v = i.data;
            if (v === "/$") {
              if (l === 0) {
                Fa = Yi(i.nextSibling);
                break e;
              }
              l--;
            } else
              v !== "$" && v !== "$!" && v !== "$?" || l++;
          }
          i = i.nextSibling;
        }
        Fa = null;
      }
    } else
      Fa = ni ? Yi(i.stateNode.nextSibling) : null;
    return !0;
  }
  function cm() {
    for (var i = Fa; i; )
      i = Yi(i.nextSibling);
  }
  function Qn() {
    Fa = ni = null, Un = !1;
  }
  function bh(i) {
    yi === null ? yi = [i] : yi.push(i);
  }
  var dd = Ee.ReactCurrentBatchConfig;
  function ri(i, l) {
    if (i && i.defaultProps) {
      l = ye({}, l), i = i.defaultProps;
      for (var v in i)
        l[v] === void 0 && (l[v] = i[v]);
      return l;
    }
    return l;
  }
  var qi = en(null), fd = null, ao = null, wh = null;
  function Sh() {
    wh = ao = fd = null;
  }
  function io(i) {
    var l = qi.current;
    Sn(qi), i._currentValue = l;
  }
  function zr(i, l, v) {
    for (; i !== null; ) {
      var k = i.alternate;
      if ((i.childLanes & l) !== l ? (i.childLanes |= l, k !== null && (k.childLanes |= l)) : k !== null && (k.childLanes & l) !== l && (k.childLanes |= l), i === v)
        break;
      i = i.return;
    }
  }
  function nt(i, l) {
    fd = i, wh = ao = null, i = i.dependencies, i !== null && i.firstContext !== null && (i.lanes & l && (wr = !0), i.firstContext = null);
  }
  function hr(i) {
    var l = i._currentValue;
    if (wh !== i)
      if (i = { context: i, memoizedValue: l, next: null }, ao === null) {
        if (fd === null)
          throw Error(h(308));
        ao = i, fd.dependencies = { lanes: 0, firstContext: i };
      } else
        ao = ao.next = i;
    return l;
  }
  var Ur = null;
  function kh(i) {
    Ur === null ? Ur = [i] : Ur.push(i);
  }
  function dm(i, l, v, k) {
    var D = l.interleaved;
    return D === null ? (v.next = v, kh(l)) : (v.next = D.next, D.next = v), l.interleaved = v, ks(i, k);
  }
  function ks(i, l) {
    i.lanes |= l;
    var v = i.alternate;
    for (v !== null && (v.lanes |= l), v = i, i = i.return; i !== null; )
      i.childLanes |= l, v = i.alternate, v !== null && (v.childLanes |= l), v = i, i = i.return;
    return v.tag === 3 ? v.stateNode : null;
  }
  var so = !1;
  function Ch(i) {
    i.updateQueue = { baseState: i.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Cr(i, l) {
    i = i.updateQueue, l.updateQueue === i && (l.updateQueue = { baseState: i.baseState, firstBaseUpdate: i.firstBaseUpdate, lastBaseUpdate: i.lastBaseUpdate, shared: i.shared, effects: i.effects });
  }
  function Cs(i, l) {
    return { eventTime: i, lane: l, tag: 0, payload: null, callback: null, next: null };
  }
  function oo(i, l, v) {
    var k = i.updateQueue;
    if (k === null)
      return null;
    if (k = k.shared, sn & 2) {
      var D = k.pending;
      return D === null ? l.next = l : (l.next = D.next, D.next = l), k.pending = l, ks(i, v);
    }
    return D = k.interleaved, D === null ? (l.next = l, kh(k)) : (l.next = D.next, D.next = l), k.interleaved = l, ks(i, v);
  }
  function hd(i, l, v) {
    if (l = l.updateQueue, l !== null && (l = l.shared, (v & 4194240) !== 0)) {
      var k = l.lanes;
      k &= i.pendingLanes, v |= k, l.lanes = v, Le(i, v);
    }
  }
  function Th(i, l) {
    var v = i.updateQueue, k = i.alternate;
    if (k !== null && (k = k.updateQueue, v === k)) {
      var D = null, z = null;
      if (v = v.firstBaseUpdate, v !== null) {
        do {
          var $ = { eventTime: v.eventTime, lane: v.lane, tag: v.tag, payload: v.payload, callback: v.callback, next: null };
          z === null ? D = z = $ : z = z.next = $, v = v.next;
        } while (v !== null);
        z === null ? D = z = l : z = z.next = l;
      } else
        D = z = l;
      v = { baseState: k.baseState, firstBaseUpdate: D, lastBaseUpdate: z, shared: k.shared, effects: k.effects }, i.updateQueue = v;
      return;
    }
    i = v.lastBaseUpdate, i === null ? v.firstBaseUpdate = l : i.next = l, v.lastBaseUpdate = l;
  }
  function lo(i, l, v, k) {
    var D = i.updateQueue;
    so = !1;
    var z = D.firstBaseUpdate, $ = D.lastBaseUpdate, ie = D.shared.pending;
    if (ie !== null) {
      D.shared.pending = null;
      var de = ie, Re = de.next;
      de.next = null, $ === null ? z = Re : $.next = Re, $ = de;
      var He = i.alternate;
      He !== null && (He = He.updateQueue, ie = He.lastBaseUpdate, ie !== $ && (ie === null ? He.firstBaseUpdate = Re : ie.next = Re, He.lastBaseUpdate = de));
    }
    if (z !== null) {
      var Be = D.baseState;
      $ = 0, He = Re = de = null, ie = z;
      do {
        var Fe = ie.lane, lt = ie.eventTime;
        if ((k & Fe) === Fe) {
          He !== null && (He = He.next = {
            eventTime: lt,
            lane: 0,
            tag: ie.tag,
            payload: ie.payload,
            callback: ie.callback,
            next: null
          });
          e: {
            var bt = i, Ct = ie;
            switch (Fe = l, lt = v, Ct.tag) {
              case 1:
                if (bt = Ct.payload, typeof bt == "function") {
                  Be = bt.call(lt, Be, Fe);
                  break e;
                }
                Be = bt;
                break e;
              case 3:
                bt.flags = bt.flags & -65537 | 128;
              case 0:
                if (bt = Ct.payload, Fe = typeof bt == "function" ? bt.call(lt, Be, Fe) : bt, Fe == null)
                  break e;
                Be = ye({}, Be, Fe);
                break e;
              case 2:
                so = !0;
            }
          }
          ie.callback !== null && ie.lane !== 0 && (i.flags |= 64, Fe = D.effects, Fe === null ? D.effects = [ie] : Fe.push(ie));
        } else
          lt = { eventTime: lt, lane: Fe, tag: ie.tag, payload: ie.payload, callback: ie.callback, next: null }, He === null ? (Re = He = lt, de = Be) : He = He.next = lt, $ |= Fe;
        if (ie = ie.next, ie === null) {
          if (ie = D.shared.pending, ie === null)
            break;
          Fe = ie, ie = Fe.next, Fe.next = null, D.lastBaseUpdate = Fe, D.shared.pending = null;
        }
      } while (1);
      if (He === null && (de = Be), D.baseState = de, D.firstBaseUpdate = Re, D.lastBaseUpdate = He, l = D.shared.interleaved, l !== null) {
        D = l;
        do
          $ |= D.lane, D = D.next;
        while (D !== l);
      } else
        z === null && (D.shared.lanes = 0);
      Rs |= $, i.lanes = $, i.memoizedState = Be;
    }
  }
  function Wo(i, l, v) {
    if (i = l.effects, l.effects = null, i !== null)
      for (l = 0; l < i.length; l++) {
        var k = i[l], D = k.callback;
        if (D !== null) {
          if (k.callback = null, k = v, typeof D != "function")
            throw Error(h(191, D));
          D.call(k);
        }
      }
  }
  var fm = new s.Component().refs;
  function Ah(i, l, v, k) {
    l = i.memoizedState, v = v(k, l), v = v == null ? l : ye({}, l, v), i.memoizedState = v, i.lanes === 0 && (i.updateQueue.baseState = v);
  }
  var pd = { isMounted: function(i) {
    return (i = i._reactInternals) ? qt(i) === i : !1;
  }, enqueueSetState: function(i, l, v) {
    i = i._reactInternals;
    var k = ha(), D = Sr(i), z = Cs(k, D);
    z.payload = l, v != null && (z.callback = v), l = oo(i, z, D), l !== null && (pa(l, i, D, k), hd(l, i, D));
  }, enqueueReplaceState: function(i, l, v) {
    i = i._reactInternals;
    var k = ha(), D = Sr(i), z = Cs(k, D);
    z.tag = 1, z.payload = l, v != null && (z.callback = v), l = oo(i, z, D), l !== null && (pa(l, i, D, k), hd(l, i, D));
  }, enqueueForceUpdate: function(i, l) {
    i = i._reactInternals;
    var v = ha(), k = Sr(i), D = Cs(v, k);
    D.tag = 2, l != null && (D.callback = l), l = oo(i, D, k), l !== null && (pa(l, i, k, v), hd(l, i, k));
  } };
  function hm(i, l, v, k, D, z, $) {
    return i = i.stateNode, typeof i.shouldComponentUpdate == "function" ? i.shouldComponentUpdate(k, z, $) : l.prototype && l.prototype.isPureReactComponent ? !ju(v, k) || !ju(D, z) : !0;
  }
  function pm(i, l, v) {
    var k = !1, D = $i, z = l.contextType;
    return typeof z == "object" && z !== null ? z = hr(z) : (D = qn(l) ? Pa : Xt.current, k = l.contextTypes, z = (k = k != null) ? gi(i, D) : $i), l = new l(v, z), i.memoizedState = l.state !== null && l.state !== void 0 ? l.state : null, l.updater = pd, i.stateNode = l, l._reactInternals = i, k && (i = i.stateNode, i.__reactInternalMemoizedUnmaskedChildContext = D, i.__reactInternalMemoizedMaskedChildContext = z), l;
  }
  function gm(i, l, v, k) {
    i = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(v, k), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(v, k), l.state !== i && pd.enqueueReplaceState(l, l.state, null);
  }
  function gd(i, l, v, k) {
    var D = i.stateNode;
    D.props = v, D.state = i.memoizedState, D.refs = fm, Ch(i);
    var z = l.contextType;
    typeof z == "object" && z !== null ? D.context = hr(z) : (z = qn(l) ? Pa : Xt.current, D.context = gi(i, z)), D.state = i.memoizedState, z = l.getDerivedStateFromProps, typeof z == "function" && (Ah(i, l, z, v), D.state = i.memoizedState), typeof l.getDerivedStateFromProps == "function" || typeof D.getSnapshotBeforeUpdate == "function" || typeof D.UNSAFE_componentWillMount != "function" && typeof D.componentWillMount != "function" || (l = D.state, typeof D.componentWillMount == "function" && D.componentWillMount(), typeof D.UNSAFE_componentWillMount == "function" && D.UNSAFE_componentWillMount(), l !== D.state && pd.enqueueReplaceState(D, D.state, null), lo(i, v, D, k), D.state = i.memoizedState), typeof D.componentDidMount == "function" && (i.flags |= 4194308);
  }
  function Wl(i, l, v) {
    if (i = v.ref, i !== null && typeof i != "function" && typeof i != "object") {
      if (v._owner) {
        if (v = v._owner, v) {
          if (v.tag !== 1)
            throw Error(h(309));
          var k = v.stateNode;
        }
        if (!k)
          throw Error(h(147, i));
        var D = k, z = "" + i;
        return l !== null && l.ref !== null && typeof l.ref == "function" && l.ref._stringRef === z ? l.ref : (l = function($) {
          var ie = D.refs;
          ie === fm && (ie = D.refs = {}), $ === null ? delete ie[z] : ie[z] = $;
        }, l._stringRef = z, l);
      }
      if (typeof i != "string")
        throw Error(h(284));
      if (!v._owner)
        throw Error(h(290, i));
    }
    return i;
  }
  function md(i, l) {
    throw i = Object.prototype.toString.call(l), Error(h(31, i === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : i));
  }
  function mm(i) {
    var l = i._init;
    return l(i._payload);
  }
  function vm(i) {
    function l(ve, pe) {
      if (i) {
        var Se = ve.deletions;
        Se === null ? (ve.deletions = [pe], ve.flags |= 16) : Se.push(pe);
      }
    }
    function v(ve, pe) {
      if (!i)
        return null;
      for (; pe !== null; )
        l(ve, pe), pe = pe.sibling;
      return null;
    }
    function k(ve, pe) {
      for (ve = /* @__PURE__ */ new Map(); pe !== null; )
        pe.key !== null ? ve.set(pe.key, pe) : ve.set(pe.index, pe), pe = pe.sibling;
      return ve;
    }
    function D(ve, pe) {
      return ve = vo(ve, pe), ve.index = 0, ve.sibling = null, ve;
    }
    function z(ve, pe, Se) {
      return ve.index = Se, i ? (Se = ve.alternate, Se !== null ? (Se = Se.index, Se < pe ? (ve.flags |= 2, pe) : Se) : (ve.flags |= 2, pe)) : (ve.flags |= 1048576, pe);
    }
    function $(ve) {
      return i && ve.alternate === null && (ve.flags |= 2), ve;
    }
    function ie(ve, pe, Se, $e) {
      return pe === null || pe.tag !== 6 ? (pe = vc(Se, ve.mode, $e), pe.return = ve, pe) : (pe = D(pe, Se), pe.return = ve, pe);
    }
    function de(ve, pe, Se, $e) {
      var At = Se.type;
      return At === Me ? He(ve, pe, Se.props.children, $e, Se.key) : pe !== null && (pe.elementType === At || typeof At == "object" && At !== null && At.$$typeof === It && mm(At) === pe.type) ? ($e = D(pe, Se.props), $e.ref = Wl(ve, pe, Se), $e.return = ve, $e) : ($e = $d(Se.type, Se.key, Se.props, null, ve.mode, $e), $e.ref = Wl(ve, pe, Se), $e.return = ve, $e);
    }
    function Re(ve, pe, Se, $e) {
      return pe === null || pe.tag !== 4 || pe.stateNode.containerInfo !== Se.containerInfo || pe.stateNode.implementation !== Se.implementation ? (pe = ll(Se, ve.mode, $e), pe.return = ve, pe) : (pe = D(pe, Se.children || []), pe.return = ve, pe);
    }
    function He(ve, pe, Se, $e, At) {
      return pe === null || pe.tag !== 7 ? (pe = ol(Se, ve.mode, $e, At), pe.return = ve, pe) : (pe = D(pe, Se), pe.return = ve, pe);
    }
    function Be(ve, pe, Se) {
      if (typeof pe == "string" && pe !== "" || typeof pe == "number")
        return pe = vc("" + pe, ve.mode, Se), pe.return = ve, pe;
      if (typeof pe == "object" && pe !== null) {
        switch (pe.$$typeof) {
          case re:
            return Se = $d(pe.type, pe.key, pe.props, null, ve.mode, Se), Se.ref = Wl(ve, null, pe), Se.return = ve, Se;
          case me:
            return pe = ll(pe, ve.mode, Se), pe.return = ve, pe;
          case It:
            var $e = pe._init;
            return Be(ve, $e(pe._payload), Se);
        }
        if (_i(pe) || pt(pe))
          return pe = ol(pe, ve.mode, Se, null), pe.return = ve, pe;
        md(ve, pe);
      }
      return null;
    }
    function Fe(ve, pe, Se, $e) {
      var At = pe !== null ? pe.key : null;
      if (typeof Se == "string" && Se !== "" || typeof Se == "number")
        return At !== null ? null : ie(ve, pe, "" + Se, $e);
      if (typeof Se == "object" && Se !== null) {
        switch (Se.$$typeof) {
          case re:
            return Se.key === At ? de(ve, pe, Se, $e) : null;
          case me:
            return Se.key === At ? Re(ve, pe, Se, $e) : null;
          case It:
            return At = Se._init, Fe(
              ve,
              pe,
              At(Se._payload),
              $e
            );
        }
        if (_i(Se) || pt(Se))
          return At !== null ? null : He(ve, pe, Se, $e, null);
        md(ve, Se);
      }
      return null;
    }
    function lt(ve, pe, Se, $e, At) {
      if (typeof $e == "string" && $e !== "" || typeof $e == "number")
        return ve = ve.get(Se) || null, ie(pe, ve, "" + $e, At);
      if (typeof $e == "object" && $e !== null) {
        switch ($e.$$typeof) {
          case re:
            return ve = ve.get($e.key === null ? Se : $e.key) || null, de(pe, ve, $e, At);
          case me:
            return ve = ve.get($e.key === null ? Se : $e.key) || null, Re(pe, ve, $e, At);
          case It:
            var wt = $e._init;
            return lt(ve, pe, Se, wt($e._payload), At);
        }
        if (_i($e) || pt($e))
          return ve = ve.get(Se) || null, He(pe, ve, $e, At, null);
        md(pe, $e);
      }
      return null;
    }
    function bt(ve, pe, Se, $e) {
      for (var At = null, wt = null, Ot = pe, Vt = pe = 0, Yr = null; Ot !== null && Vt < Se.length; Vt++) {
        Ot.index > Vt ? (Yr = Ot, Ot = null) : Yr = Ot.sibling;
        var gn = Fe(ve, Ot, Se[Vt], $e);
        if (gn === null) {
          Ot === null && (Ot = Yr);
          break;
        }
        i && Ot && gn.alternate === null && l(ve, Ot), pe = z(gn, pe, Vt), wt === null ? At = gn : wt.sibling = gn, wt = gn, Ot = Yr;
      }
      if (Vt === Se.length)
        return v(ve, Ot), Un && ti(ve, Vt), At;
      if (Ot === null) {
        for (; Vt < Se.length; Vt++)
          Ot = Be(ve, Se[Vt], $e), Ot !== null && (pe = z(Ot, pe, Vt), wt === null ? At = Ot : wt.sibling = Ot, wt = Ot);
        return Un && ti(ve, Vt), At;
      }
      for (Ot = k(ve, Ot); Vt < Se.length; Vt++)
        Yr = lt(Ot, ve, Vt, Se[Vt], $e), Yr !== null && (i && Yr.alternate !== null && Ot.delete(Yr.key === null ? Vt : Yr.key), pe = z(Yr, pe, Vt), wt === null ? At = Yr : wt.sibling = Yr, wt = Yr);
      return i && Ot.forEach(function(yo) {
        return l(ve, yo);
      }), Un && ti(ve, Vt), At;
    }
    function Ct(ve, pe, Se, $e) {
      var At = pt(Se);
      if (typeof At != "function")
        throw Error(h(150));
      if (Se = At.call(Se), Se == null)
        throw Error(h(151));
      for (var wt = At = null, Ot = pe, Vt = pe = 0, Yr = null, gn = Se.next(); Ot !== null && !gn.done; Vt++, gn = Se.next()) {
        Ot.index > Vt ? (Yr = Ot, Ot = null) : Yr = Ot.sibling;
        var yo = Fe(ve, Ot, gn.value, $e);
        if (yo === null) {
          Ot === null && (Ot = Yr);
          break;
        }
        i && Ot && yo.alternate === null && l(ve, Ot), pe = z(yo, pe, Vt), wt === null ? At = yo : wt.sibling = yo, wt = yo, Ot = Yr;
      }
      if (gn.done)
        return v(
          ve,
          Ot
        ), Un && ti(ve, Vt), At;
      if (Ot === null) {
        for (; !gn.done; Vt++, gn = Se.next())
          gn = Be(ve, gn.value, $e), gn !== null && (pe = z(gn, pe, Vt), wt === null ? At = gn : wt.sibling = gn, wt = gn);
        return Un && ti(ve, Vt), At;
      }
      for (Ot = k(ve, Ot); !gn.done; Vt++, gn = Se.next())
        gn = lt(Ot, ve, Vt, gn.value, $e), gn !== null && (i && gn.alternate !== null && Ot.delete(gn.key === null ? Vt : gn.key), pe = z(gn, pe, Vt), wt === null ? At = gn : wt.sibling = gn, wt = gn);
      return i && Ot.forEach(function(Gx) {
        return l(ve, Gx);
      }), Un && ti(ve, Vt), At;
    }
    function pr(ve, pe, Se, $e) {
      if (typeof Se == "object" && Se !== null && Se.type === Me && Se.key === null && (Se = Se.props.children), typeof Se == "object" && Se !== null) {
        switch (Se.$$typeof) {
          case re:
            e: {
              for (var At = Se.key, wt = pe; wt !== null; ) {
                if (wt.key === At) {
                  if (At = Se.type, At === Me) {
                    if (wt.tag === 7) {
                      v(ve, wt.sibling), pe = D(wt, Se.props.children), pe.return = ve, ve = pe;
                      break e;
                    }
                  } else if (wt.elementType === At || typeof At == "object" && At !== null && At.$$typeof === It && mm(At) === wt.type) {
                    v(ve, wt.sibling), pe = D(wt, Se.props), pe.ref = Wl(ve, wt, Se), pe.return = ve, ve = pe;
                    break e;
                  }
                  v(ve, wt);
                  break;
                } else
                  l(ve, wt);
                wt = wt.sibling;
              }
              Se.type === Me ? (pe = ol(Se.props.children, ve.mode, $e, Se.key), pe.return = ve, ve = pe) : ($e = $d(Se.type, Se.key, Se.props, null, ve.mode, $e), $e.ref = Wl(ve, pe, Se), $e.return = ve, ve = $e);
            }
            return $(ve);
          case me:
            e: {
              for (wt = Se.key; pe !== null; ) {
                if (pe.key === wt)
                  if (pe.tag === 4 && pe.stateNode.containerInfo === Se.containerInfo && pe.stateNode.implementation === Se.implementation) {
                    v(ve, pe.sibling), pe = D(pe, Se.children || []), pe.return = ve, ve = pe;
                    break e;
                  } else {
                    v(ve, pe);
                    break;
                  }
                else
                  l(ve, pe);
                pe = pe.sibling;
              }
              pe = ll(Se, ve.mode, $e), pe.return = ve, ve = pe;
            }
            return $(ve);
          case It:
            return wt = Se._init, pr(ve, pe, wt(Se._payload), $e);
        }
        if (_i(Se))
          return bt(ve, pe, Se, $e);
        if (pt(Se))
          return Ct(ve, pe, Se, $e);
        md(ve, Se);
      }
      return typeof Se == "string" && Se !== "" || typeof Se == "number" ? (Se = "" + Se, pe !== null && pe.tag === 6 ? (v(ve, pe.sibling), pe = D(pe, Se), pe.return = ve, ve = pe) : (v(ve, pe), pe = vc(Se, ve.mode, $e), pe.return = ve, ve = pe), $(ve)) : v(ve, pe);
    }
    return pr;
  }
  var Ul = vm(!0), ym = vm(!1), Ju = {}, Hi = en(Ju), ec = en(Ju), Xl = en(Ju);
  function Uo(i) {
    if (i === Ju)
      throw Error(h(174));
    return i;
  }
  function Eh(i, l) {
    switch (Tn(Xl, l), Tn(ec, i), Tn(Hi, Ju), i = l.nodeType, i) {
      case 9:
      case 11:
        l = (l = l.documentElement) ? l.namespaceURI : sr(null, "");
        break;
      default:
        i = i === 8 ? l.parentNode : l, l = i.namespaceURI || null, i = i.tagName, l = sr(l, i);
    }
    Sn(Hi), Tn(Hi, l);
  }
  function uo() {
    Sn(Hi), Sn(ec), Sn(Xl);
  }
  function Ft(i) {
    Uo(Xl.current);
    var l = Uo(Hi.current), v = sr(l, i.type);
    l !== v && (Tn(ec, i), Tn(Hi, v));
  }
  function rn(i) {
    ec.current === i && (Sn(Hi), Sn(ec));
  }
  var jt = en(0);
  function Kn(i) {
    for (var l = i; l !== null; ) {
      if (l.tag === 13) {
        var v = l.memoizedState;
        if (v !== null && (v = v.dehydrated, v === null || v.data === "$?" || v.data === "$!"))
          return l;
      } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
        if (l.flags & 128)
          return l;
      } else if (l.child !== null) {
        l.child.return = l, l = l.child;
        continue;
      }
      if (l === i)
        break;
      for (; l.sibling === null; ) {
        if (l.return === null || l.return === i)
          return null;
        l = l.return;
      }
      l.sibling.return = l.return, l = l.sibling;
    }
    return null;
  }
  var xi = [];
  function vd() {
    for (var i = 0; i < xi.length; i++)
      xi[i]._workInProgressVersionPrimary = null;
    xi.length = 0;
  }
  var yd = Ee.ReactCurrentDispatcher, Rh = Ee.ReactCurrentBatchConfig, Xo = 0, Xn = null, Ne = null, dn = null, Bt = !1, Zi = !1, ai = 0, Vo = 0;
  function Vn() {
    throw Error(h(321));
  }
  function Go(i, l) {
    if (l === null)
      return !1;
    for (var v = 0; v < l.length && v < i.length; v++)
      if (!hi(i[v], l[v]))
        return !1;
    return !0;
  }
  function co(i, l, v, k, D, z) {
    if (Xo = z, Xn = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, yd.current = i === null || i.memoizedState === null ? Lx : Ox, i = v(k, D), Zi) {
      z = 0;
      do {
        if (Zi = !1, ai = 0, 25 <= z)
          throw Error(h(301));
        z += 1, dn = Ne = null, l.updateQueue = null, yd.current = Oh, i = v(k, D);
      } while (Zi);
    }
    if (yd.current = Pd, l = Ne !== null && Ne.next !== null, Xo = 0, dn = Ne = Xn = null, Bt = !1, l)
      throw Error(h(300));
    return i;
  }
  function $o() {
    var i = ai !== 0;
    return ai = 0, i;
  }
  function bi() {
    var i = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return dn === null ? Xn.memoizedState = dn = i : dn = dn.next = i, dn;
  }
  function Ya() {
    if (Ne === null) {
      var i = Xn.alternate;
      i = i !== null ? i.memoizedState : null;
    } else
      i = Ne.next;
    var l = dn === null ? Xn.memoizedState : dn.next;
    if (l !== null)
      dn = l, Ne = i;
    else {
      if (i === null)
        throw Error(h(310));
      Ne = i, i = { memoizedState: Ne.memoizedState, baseState: Ne.baseState, baseQueue: Ne.baseQueue, queue: Ne.queue, next: null }, dn === null ? Xn.memoizedState = dn = i : dn = dn.next = i;
    }
    return dn;
  }
  function qo(i, l) {
    return typeof l == "function" ? l(i) : l;
  }
  function tc(i) {
    var l = Ya(), v = l.queue;
    if (v === null)
      throw Error(h(311));
    v.lastRenderedReducer = i;
    var k = Ne, D = k.baseQueue, z = v.pending;
    if (z !== null) {
      if (D !== null) {
        var $ = D.next;
        D.next = z.next, z.next = $;
      }
      k.baseQueue = D = z, v.pending = null;
    }
    if (D !== null) {
      z = D.next, k = k.baseState;
      var ie = $ = null, de = null, Re = z;
      do {
        var He = Re.lane;
        if ((Xo & He) === He)
          de !== null && (de = de.next = { lane: 0, action: Re.action, hasEagerState: Re.hasEagerState, eagerState: Re.eagerState, next: null }), k = Re.hasEagerState ? Re.eagerState : i(k, Re.action);
        else {
          var Be = {
            lane: He,
            action: Re.action,
            hasEagerState: Re.hasEagerState,
            eagerState: Re.eagerState,
            next: null
          };
          de === null ? (ie = de = Be, $ = k) : de = de.next = Be, Xn.lanes |= He, Rs |= He;
        }
        Re = Re.next;
      } while (Re !== null && Re !== z);
      de === null ? $ = k : de.next = ie, hi(k, l.memoizedState) || (wr = !0), l.memoizedState = k, l.baseState = $, l.baseQueue = de, v.lastRenderedState = k;
    }
    if (i = v.interleaved, i !== null) {
      D = i;
      do
        z = D.lane, Xn.lanes |= z, Rs |= z, D = D.next;
      while (D !== i);
    } else
      D === null && (v.lanes = 0);
    return [l.memoizedState, v.dispatch];
  }
  function nc(i) {
    var l = Ya(), v = l.queue;
    if (v === null)
      throw Error(h(311));
    v.lastRenderedReducer = i;
    var k = v.dispatch, D = v.pending, z = l.memoizedState;
    if (D !== null) {
      v.pending = null;
      var $ = D = D.next;
      do
        z = i(z, $.action), $ = $.next;
      while ($ !== D);
      hi(z, l.memoizedState) || (wr = !0), l.memoizedState = z, l.baseQueue === null && (l.baseState = z), v.lastRenderedState = z;
    }
    return [z, k];
  }
  function xd() {
  }
  function bd(i, l) {
    var v = Xn, k = Ya(), D = l(), z = !hi(k.memoizedState, D);
    if (z && (k.memoizedState = D, wr = !0), k = k.queue, rc(kd.bind(null, v, k, i), [i]), k.getSnapshot !== l || z || dn !== null && dn.memoizedState.tag & 1) {
      if (v.flags |= 2048, Zo(9, Sd.bind(null, v, k, D, l), void 0, null), Jn === null)
        throw Error(h(349));
      Xo & 30 || wd(v, l, D);
    }
    return D;
  }
  function wd(i, l, v) {
    i.flags |= 16384, i = { getSnapshot: l, value: v }, l = Xn.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, Xn.updateQueue = l, l.stores = [i]) : (v = l.stores, v === null ? l.stores = [i] : v.push(i));
  }
  function Sd(i, l, v, k) {
    l.value = v, l.getSnapshot = k, Cd(l) && Td(i);
  }
  function kd(i, l, v) {
    return v(function() {
      Cd(l) && Td(i);
    });
  }
  function Cd(i) {
    var l = i.getSnapshot;
    i = i.value;
    try {
      var v = l();
      return !hi(i, v);
    } catch {
      return !0;
    }
  }
  function Td(i) {
    var l = ks(i, 1);
    l !== null && pa(l, i, 1, -1);
  }
  function Ad(i) {
    var l = bi();
    return typeof i == "function" && (i = i()), l.memoizedState = l.baseState = i, i = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: qo, lastRenderedState: i }, l.queue = i, i = i.dispatch = _d.bind(null, Xn, i), [l.memoizedState, i];
  }
  function Zo(i, l, v, k) {
    return i = { tag: i, create: l, destroy: v, deps: k, next: null }, l = Xn.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, Xn.updateQueue = l, l.lastEffect = i.next = i) : (v = l.lastEffect, v === null ? l.lastEffect = i.next = i : (k = v.next, v.next = i, i.next = k, l.lastEffect = i)), i;
  }
  function Ed() {
    return Ya().memoizedState;
  }
  function Qo(i, l, v, k) {
    var D = bi();
    Xn.flags |= i, D.memoizedState = Zo(1 | l, v, void 0, k === void 0 ? null : k);
  }
  function Ts(i, l, v, k) {
    var D = Ya();
    k = k === void 0 ? null : k;
    var z = void 0;
    if (Ne !== null) {
      var $ = Ne.memoizedState;
      if (z = $.destroy, k !== null && Go(k, $.deps)) {
        D.memoizedState = Zo(l, v, z, k);
        return;
      }
    }
    Xn.flags |= i, D.memoizedState = Zo(1 | l, v, z, k);
  }
  function Rd(i, l) {
    return Qo(8390656, 8, i, l);
  }
  function rc(i, l) {
    return Ts(2048, 8, i, l);
  }
  function Ld(i, l) {
    return Ts(4, 2, i, l);
  }
  function Od(i, l) {
    return Ts(4, 4, i, l);
  }
  function Lh(i, l) {
    if (typeof l == "function")
      return i = i(), l(i), function() {
        l(null);
      };
    if (l != null)
      return i = i(), l.current = i, function() {
        l.current = null;
      };
  }
  function Vl(i, l, v) {
    return v = v != null ? v.concat([i]) : null, Ts(4, 4, Lh.bind(null, l, i), v);
  }
  function Dd() {
  }
  function Gl(i, l) {
    var v = Ya();
    l = l === void 0 ? null : l;
    var k = v.memoizedState;
    return k !== null && l !== null && Go(l, k[1]) ? k[0] : (v.memoizedState = [i, l], i);
  }
  function fo(i, l) {
    var v = Ya();
    l = l === void 0 ? null : l;
    var k = v.memoizedState;
    return k !== null && l !== null && Go(l, k[1]) ? k[0] : (i = i(), v.memoizedState = [i, l], i);
  }
  function Ha(i, l, v) {
    return Xo & 21 ? (hi(v, l) || (v = oe(), Xn.lanes |= v, Rs |= v, i.baseState = !0), l) : (i.baseState && (i.baseState = !1, wr = !0), i.memoizedState = v);
  }
  function Rx(i, l) {
    var v = Ie;
    Ie = v !== 0 && 4 > v ? v : 4, i(!0);
    var k = Rh.transition;
    Rh.transition = {};
    try {
      i(!1), l();
    } finally {
      Ie = v, Rh.transition = k;
    }
  }
  function Fn() {
    return Ya().memoizedState;
  }
  function Md(i, l, v) {
    var k = Sr(i);
    if (v = { lane: k, action: v, hasEagerState: !1, eagerState: null, next: null }, $l(i))
      ac(l, v);
    else if (v = dm(i, l, v, k), v !== null) {
      var D = ha();
      pa(v, i, k, D), xm(v, l, k);
    }
  }
  function _d(i, l, v) {
    var k = Sr(i), D = { lane: k, action: v, hasEagerState: !1, eagerState: null, next: null };
    if ($l(i))
      ac(l, D);
    else {
      var z = i.alternate;
      if (i.lanes === 0 && (z === null || z.lanes === 0) && (z = l.lastRenderedReducer, z !== null))
        try {
          var $ = l.lastRenderedState, ie = z($, v);
          if (D.hasEagerState = !0, D.eagerState = ie, hi(ie, $)) {
            var de = l.interleaved;
            de === null ? (D.next = D, kh(l)) : (D.next = de.next, de.next = D), l.interleaved = D;
            return;
          }
        } catch {
        } finally {
        }
      v = dm(i, l, D, k), v !== null && (D = ha(), pa(v, i, k, D), xm(v, l, k));
    }
  }
  function $l(i) {
    var l = i.alternate;
    return i === Xn || l !== null && l === Xn;
  }
  function ac(i, l) {
    Zi = Bt = !0;
    var v = i.pending;
    v === null ? l.next = l : (l.next = v.next, v.next = l), i.pending = l;
  }
  function xm(i, l, v) {
    if (v & 4194240) {
      var k = l.lanes;
      k &= i.pendingLanes, v |= k, l.lanes = v, Le(i, v);
    }
  }
  var Pd = { readContext: hr, useCallback: Vn, useContext: Vn, useEffect: Vn, useImperativeHandle: Vn, useInsertionEffect: Vn, useLayoutEffect: Vn, useMemo: Vn, useReducer: Vn, useRef: Vn, useState: Vn, useDebugValue: Vn, useDeferredValue: Vn, useTransition: Vn, useMutableSource: Vn, useSyncExternalStore: Vn, useId: Vn, unstable_isNewReconciler: !1 }, Lx = { readContext: hr, useCallback: function(i, l) {
    return bi().memoizedState = [i, l === void 0 ? null : l], i;
  }, useContext: hr, useEffect: Rd, useImperativeHandle: function(i, l, v) {
    return v = v != null ? v.concat([i]) : null, Qo(
      4194308,
      4,
      Lh.bind(null, l, i),
      v
    );
  }, useLayoutEffect: function(i, l) {
    return Qo(4194308, 4, i, l);
  }, useInsertionEffect: function(i, l) {
    return Qo(4, 2, i, l);
  }, useMemo: function(i, l) {
    var v = bi();
    return l = l === void 0 ? null : l, i = i(), v.memoizedState = [i, l], i;
  }, useReducer: function(i, l, v) {
    var k = bi();
    return l = v !== void 0 ? v(l) : l, k.memoizedState = k.baseState = l, i = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: i, lastRenderedState: l }, k.queue = i, i = i.dispatch = Md.bind(null, Xn, i), [k.memoizedState, i];
  }, useRef: function(i) {
    var l = bi();
    return i = { current: i }, l.memoizedState = i;
  }, useState: Ad, useDebugValue: Dd, useDeferredValue: function(i) {
    return bi().memoizedState = i;
  }, useTransition: function() {
    var i = Ad(!1), l = i[0];
    return i = Rx.bind(null, i[1]), bi().memoizedState = i, [l, i];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(i, l, v) {
    var k = Xn, D = bi();
    if (Un) {
      if (v === void 0)
        throw Error(h(407));
      v = v();
    } else {
      if (v = l(), Jn === null)
        throw Error(h(349));
      Xo & 30 || wd(k, l, v);
    }
    D.memoizedState = v;
    var z = { value: v, getSnapshot: l };
    return D.queue = z, Rd(kd.bind(
      null,
      k,
      z,
      i
    ), [i]), k.flags |= 2048, Zo(9, Sd.bind(null, k, z, v, l), void 0, null), v;
  }, useId: function() {
    var i = bi(), l = Jn.identifierPrefix;
    if (Un) {
      var v = Ss, k = Wr;
      v = (k & ~(1 << 32 - P(k) - 1)).toString(32) + v, l = ":" + l + "R" + v, v = ai++, 0 < v && (l += "H" + v.toString(32)), l += ":";
    } else
      v = Vo++, l = ":" + l + "r" + v.toString(32) + ":";
    return i.memoizedState = l;
  }, unstable_isNewReconciler: !1 }, Ox = {
    readContext: hr,
    useCallback: Gl,
    useContext: hr,
    useEffect: rc,
    useImperativeHandle: Vl,
    useInsertionEffect: Ld,
    useLayoutEffect: Od,
    useMemo: fo,
    useReducer: tc,
    useRef: Ed,
    useState: function() {
      return tc(qo);
    },
    useDebugValue: Dd,
    useDeferredValue: function(i) {
      var l = Ya();
      return Ha(l, Ne.memoizedState, i);
    },
    useTransition: function() {
      var i = tc(qo)[0], l = Ya().memoizedState;
      return [i, l];
    },
    useMutableSource: xd,
    useSyncExternalStore: bd,
    useId: Fn,
    unstable_isNewReconciler: !1
  }, Oh = { readContext: hr, useCallback: Gl, useContext: hr, useEffect: rc, useImperativeHandle: Vl, useInsertionEffect: Ld, useLayoutEffect: Od, useMemo: fo, useReducer: nc, useRef: Ed, useState: function() {
    return nc(qo);
  }, useDebugValue: Dd, useDeferredValue: function(i) {
    var l = Ya();
    return Ne === null ? l.memoizedState = i : Ha(l, Ne.memoizedState, i);
  }, useTransition: function() {
    var i = nc(qo)[0], l = Ya().memoizedState;
    return [i, l];
  }, useMutableSource: xd, useSyncExternalStore: bd, useId: Fn, unstable_isNewReconciler: !1 };
  function ql(i, l) {
    try {
      var v = "", k = l;
      do
        v += Pt(k), k = k.return;
      while (k);
      var D = v;
    } catch (z) {
      D = `
Error generating stack: ` + z.message + `
` + z.stack;
    }
    return { value: i, source: l, stack: D, digest: null };
  }
  function ic(i, l, v) {
    return { value: i, source: null, stack: v ?? null, digest: l ?? null };
  }
  function Nd(i, l) {
    try {
      console.error(l.value);
    } catch (v) {
      setTimeout(function() {
        throw v;
      });
    }
  }
  var Dx = typeof WeakMap == "function" ? WeakMap : Map;
  function bm(i, l, v) {
    v = Cs(-1, v), v.tag = 3, v.payload = { element: null };
    var k = l.value;
    return v.callback = function() {
      Bd || (Bd = !0, nl = k), Nd(i, l);
    }, v;
  }
  function sc(i, l, v) {
    v = Cs(-1, v), v.tag = 3;
    var k = i.type.getDerivedStateFromError;
    if (typeof k == "function") {
      var D = l.value;
      v.payload = function() {
        return k(D);
      }, v.callback = function() {
        Nd(i, l);
      };
    }
    var z = i.stateNode;
    return z !== null && typeof z.componentDidCatch == "function" && (v.callback = function() {
      Nd(i, l), typeof k != "function" && (Ji === null ? Ji = /* @__PURE__ */ new Set([this]) : Ji.add(this));
      var $ = l.stack;
      this.componentDidCatch(l.value, { componentStack: $ !== null ? $ : "" });
    }), v;
  }
  function wm(i, l, v) {
    var k = i.pingCache;
    if (k === null) {
      k = i.pingCache = new Dx();
      var D = /* @__PURE__ */ new Set();
      k.set(l, D);
    } else
      D = k.get(l), D === void 0 && (D = /* @__PURE__ */ new Set(), k.set(l, D));
    D.has(v) || (D.add(v), i = Fx.bind(null, i, l, v), l.then(i, i));
  }
  function Dh(i) {
    do {
      var l;
      if ((l = i.tag === 13) && (l = i.memoizedState, l = l !== null ? l.dehydrated !== null : !0), l)
        return i;
      i = i.return;
    } while (i !== null);
    return null;
  }
  function Mh(i, l, v, k, D) {
    return i.mode & 1 ? (i.flags |= 65536, i.lanes = D, i) : (i === l ? i.flags |= 65536 : (i.flags |= 128, v.flags |= 131072, v.flags &= -52805, v.tag === 1 && (v.alternate === null ? v.tag = 17 : (l = Cs(-1, 1), l.tag = 2, oo(v, l, 1))), v.lanes |= 1), i);
  }
  var Mx = Ee.ReactCurrentOwner, wr = !1;
  function Tr(i, l, v, k) {
    l.child = i === null ? ym(l, null, v, k) : Ul(l, i.child, v, k);
  }
  function ho(i, l, v, k, D) {
    v = v.render;
    var z = l.ref;
    return nt(l, D), k = co(i, l, v, k, z, D), v = $o(), i !== null && !wr ? (l.updateQueue = i.updateQueue, l.flags &= -2053, i.lanes &= ~D, Xr(i, l, D)) : (Un && v && od(l), l.flags |= 1, Tr(i, l, k, D), l.child);
  }
  function zd(i, l, v, k, D) {
    if (i === null) {
      var z = v.type;
      return typeof z == "function" && !Qh(z) && z.defaultProps === void 0 && v.compare === null && v.defaultProps === void 0 ? (l.tag = 15, l.type = z, ja(i, l, z, k, D)) : (i = $d(v.type, null, k, l, l.mode, D), i.ref = l.ref, i.return = l, l.child = i);
    }
    if (z = i.child, !(i.lanes & D)) {
      var $ = z.memoizedProps;
      if (v = v.compare, v = v !== null ? v : ju, v($, k) && i.ref === l.ref)
        return Xr(i, l, D);
    }
    return l.flags |= 1, i = vo(z, k), i.ref = l.ref, i.return = l, l.child = i;
  }
  function ja(i, l, v, k, D) {
    if (i !== null) {
      var z = i.memoizedProps;
      if (ju(z, k) && i.ref === l.ref)
        if (wr = !1, l.pendingProps = k = z, (i.lanes & D) !== 0)
          i.flags & 131072 && (wr = !0);
        else
          return l.lanes = i.lanes, Xr(i, l, D);
    }
    return Zl(i, l, v, k, D);
  }
  function Ko(i, l, v) {
    var k = l.pendingProps, D = k.children, z = i !== null ? i.memoizedState : null;
    if (k.mode === "hidden")
      if (!(l.mode & 1))
        l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Tn(nu, ii), ii |= v;
      else {
        if (!(v & 1073741824))
          return i = z !== null ? z.baseLanes | v : v, l.lanes = l.childLanes = 1073741824, l.memoizedState = { baseLanes: i, cachePool: null, transitions: null }, l.updateQueue = null, Tn(nu, ii), ii |= i, null;
        l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, k = z !== null ? z.baseLanes : v, Tn(nu, ii), ii |= k;
      }
    else
      z !== null ? (k = z.baseLanes | v, l.memoizedState = null) : k = v, Tn(nu, ii), ii |= k;
    return Tr(i, l, D, v), l.child;
  }
  function tn(i, l) {
    var v = l.ref;
    (i === null && v !== null || i !== null && i.ref !== v) && (l.flags |= 512, l.flags |= 2097152);
  }
  function Zl(i, l, v, k, D) {
    var z = qn(v) ? Pa : Xt.current;
    return z = gi(l, z), nt(l, D), v = co(i, l, v, k, z, D), k = $o(), i !== null && !wr ? (l.updateQueue = i.updateQueue, l.flags &= -2053, i.lanes &= ~D, Xr(i, l, D)) : (Un && k && od(l), l.flags |= 1, Tr(i, l, v, D), l.child);
  }
  function _h(i, l, v, k, D) {
    if (qn(v)) {
      var z = !0;
      sd(l);
    } else
      z = !1;
    if (nt(l, D), l.stateNode === null)
      ca(i, l), pm(l, v, k), gd(l, v, k, D), k = !0;
    else if (i === null) {
      var $ = l.stateNode, ie = l.memoizedProps;
      $.props = ie;
      var de = $.context, Re = v.contextType;
      typeof Re == "object" && Re !== null ? Re = hr(Re) : (Re = qn(v) ? Pa : Xt.current, Re = gi(l, Re));
      var He = v.getDerivedStateFromProps, Be = typeof He == "function" || typeof $.getSnapshotBeforeUpdate == "function";
      Be || typeof $.UNSAFE_componentWillReceiveProps != "function" && typeof $.componentWillReceiveProps != "function" || (ie !== k || de !== Re) && gm(l, $, k, Re), so = !1;
      var Fe = l.memoizedState;
      $.state = Fe, lo(l, k, $, D), de = l.memoizedState, ie !== k || Fe !== de || lr.current || so ? (typeof He == "function" && (Ah(l, v, He, k), de = l.memoizedState), (ie = so || hm(l, v, ie, k, Fe, de, Re)) ? (Be || typeof $.UNSAFE_componentWillMount != "function" && typeof $.componentWillMount != "function" || (typeof $.componentWillMount == "function" && $.componentWillMount(), typeof $.UNSAFE_componentWillMount == "function" && $.UNSAFE_componentWillMount()), typeof $.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof $.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = k, l.memoizedState = de), $.props = k, $.state = de, $.context = Re, k = ie) : (typeof $.componentDidMount == "function" && (l.flags |= 4194308), k = !1);
    } else {
      $ = l.stateNode, Cr(i, l), ie = l.memoizedProps, Re = l.type === l.elementType ? ie : ri(l.type, ie), $.props = Re, Be = l.pendingProps, Fe = $.context, de = v.contextType, typeof de == "object" && de !== null ? de = hr(de) : (de = qn(v) ? Pa : Xt.current, de = gi(l, de));
      var lt = v.getDerivedStateFromProps;
      (He = typeof lt == "function" || typeof $.getSnapshotBeforeUpdate == "function") || typeof $.UNSAFE_componentWillReceiveProps != "function" && typeof $.componentWillReceiveProps != "function" || (ie !== Be || Fe !== de) && gm(l, $, k, de), so = !1, Fe = l.memoizedState, $.state = Fe, lo(l, k, $, D);
      var bt = l.memoizedState;
      ie !== Be || Fe !== bt || lr.current || so ? (typeof lt == "function" && (Ah(l, v, lt, k), bt = l.memoizedState), (Re = so || hm(l, v, Re, k, Fe, bt, de) || !1) ? (He || typeof $.UNSAFE_componentWillUpdate != "function" && typeof $.componentWillUpdate != "function" || (typeof $.componentWillUpdate == "function" && $.componentWillUpdate(k, bt, de), typeof $.UNSAFE_componentWillUpdate == "function" && $.UNSAFE_componentWillUpdate(k, bt, de)), typeof $.componentDidUpdate == "function" && (l.flags |= 4), typeof $.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof $.componentDidUpdate != "function" || ie === i.memoizedProps && Fe === i.memoizedState || (l.flags |= 4), typeof $.getSnapshotBeforeUpdate != "function" || ie === i.memoizedProps && Fe === i.memoizedState || (l.flags |= 1024), l.memoizedProps = k, l.memoizedState = bt), $.props = k, $.state = bt, $.context = de, k = Re) : (typeof $.componentDidUpdate != "function" || ie === i.memoizedProps && Fe === i.memoizedState || (l.flags |= 4), typeof $.getSnapshotBeforeUpdate != "function" || ie === i.memoizedProps && Fe === i.memoizedState || (l.flags |= 1024), k = !1);
    }
    return Sm(i, l, v, k, z, D);
  }
  function Sm(i, l, v, k, D, z) {
    tn(i, l);
    var $ = (l.flags & 128) !== 0;
    if (!k && !$)
      return D && om(l, v, !1), Xr(i, l, z);
    k = l.stateNode, Mx.current = l;
    var ie = $ && typeof v.getDerivedStateFromError != "function" ? null : k.render();
    return l.flags |= 1, i !== null && $ ? (l.child = Ul(l, i.child, null, z), l.child = Ul(l, null, ie, z)) : Tr(i, l, ie, z), l.memoizedState = k.state, D && om(l, v, !0), l.child;
  }
  function km(i) {
    var l = i.stateNode;
    l.pendingContext ? no(i, l.pendingContext, l.pendingContext !== l.context) : l.context && no(i, l.context, !1), Eh(i, l.containerInfo);
  }
  function Id(i, l, v, k, D) {
    return Qn(), bh(D), l.flags |= 256, Tr(i, l, v, k), l.child;
  }
  var Jo = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Ph(i) {
    return { baseLanes: i, cachePool: null, transitions: null };
  }
  function Nh(i, l, v) {
    var k = l.pendingProps, D = jt.current, z = !1, $ = (l.flags & 128) !== 0, ie;
    if ((ie = $) || (ie = i !== null && i.memoizedState === null ? !1 : (D & 2) !== 0), ie ? (z = !0, l.flags &= -129) : (i === null || i.memoizedState !== null) && (D |= 1), Tn(jt, D & 1), i === null)
      return ud(l), i = l.memoizedState, i !== null && (i = i.dehydrated, i !== null) ? (l.mode & 1 ? i.data === "$!" ? l.lanes = 8 : l.lanes = 1073741824 : l.lanes = 1, null) : ($ = k.children, i = k.fallback, z ? (k = l.mode, z = l.child, $ = { mode: "hidden", children: $ }, !(k & 1) && z !== null ? (z.childLanes = 0, z.pendingProps = $) : z = mc($, k, 0, null), i = ol(i, k, v, null), z.return = l, i.return = l, z.sibling = i, l.child = z, l.child.memoizedState = Ph(v), l.memoizedState = Jo, i) : zh(l, $));
    if (D = i.memoizedState, D !== null && (ie = D.dehydrated, ie !== null))
      return _x(i, l, $, k, ie, D, v);
    if (z) {
      z = k.fallback, $ = l.mode, D = i.child, ie = D.sibling;
      var de = { mode: "hidden", children: k.children };
      return !($ & 1) && l.child !== D ? (k = l.child, k.childLanes = 0, k.pendingProps = de, l.deletions = null) : (k = vo(D, de), k.subtreeFlags = D.subtreeFlags & 14680064), ie !== null ? z = vo(ie, z) : (z = ol(z, $, v, null), z.flags |= 2), z.return = l, k.return = l, k.sibling = z, l.child = k, k = z, z = l.child, $ = i.child.memoizedState, $ = $ === null ? Ph(v) : { baseLanes: $.baseLanes | v, cachePool: null, transitions: $.transitions }, z.memoizedState = $, z.childLanes = i.childLanes & ~v, l.memoizedState = Jo, k;
    }
    return z = i.child, i = z.sibling, k = vo(z, { mode: "visible", children: k.children }), !(l.mode & 1) && (k.lanes = v), k.return = l, k.sibling = null, i !== null && (v = l.deletions, v === null ? (l.deletions = [i], l.flags |= 16) : v.push(i)), l.child = k, l.memoizedState = null, k;
  }
  function zh(i, l) {
    return l = mc({ mode: "visible", children: l }, i.mode, 0, null), l.return = i, i.child = l;
  }
  function Ql(i, l, v, k) {
    return k !== null && bh(k), Ul(l, i.child, null, v), i = zh(l, l.pendingProps.children), i.flags |= 2, l.memoizedState = null, i;
  }
  function _x(i, l, v, k, D, z, $) {
    if (v)
      return l.flags & 256 ? (l.flags &= -257, k = ic(Error(h(422))), Ql(i, l, $, k)) : l.memoizedState !== null ? (l.child = i.child, l.flags |= 128, null) : (z = k.fallback, D = l.mode, k = mc({ mode: "visible", children: k.children }, D, 0, null), z = ol(z, D, $, null), z.flags |= 2, k.return = l, z.return = l, k.sibling = z, l.child = k, l.mode & 1 && Ul(l, i.child, null, $), l.child.memoizedState = Ph($), l.memoizedState = Jo, z);
    if (!(l.mode & 1))
      return Ql(i, l, $, null);
    if (D.data === "$!") {
      if (k = D.nextSibling && D.nextSibling.dataset, k)
        var ie = k.dgst;
      return k = ie, z = Error(h(419)), k = ic(z, k, void 0), Ql(i, l, $, k);
    }
    if (ie = ($ & i.childLanes) !== 0, wr || ie) {
      if (k = Jn, k !== null) {
        switch ($ & -$) {
          case 4:
            D = 2;
            break;
          case 16:
            D = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            D = 32;
            break;
          case 536870912:
            D = 268435456;
            break;
          default:
            D = 0;
        }
        D = D & (k.suspendedLanes | $) ? 0 : D, D !== 0 && D !== z.retryLane && (z.retryLane = D, ks(i, D), pa(k, i, D, -1));
      }
      return $h(), k = ic(Error(h(421))), Ql(i, l, $, k);
    }
    return D.data === "$?" ? (l.flags |= 128, l.child = i.child, l = Yx.bind(null, i), D._reactRetry = l, null) : (i = z.treeContext, Fa = Yi(D.nextSibling), ni = l, Un = !0, yi = null, i !== null && (Ia[ua++] = Wr, Ia[ua++] = Ss, Ia[ua++] = vi, Wr = i.id, Ss = i.overflow, vi = l), l = zh(l, k.children), l.flags |= 4096, l);
  }
  function Ih(i, l, v) {
    i.lanes |= l;
    var k = i.alternate;
    k !== null && (k.lanes |= l), zr(i.return, l, v);
  }
  function Fd(i, l, v, k, D) {
    var z = i.memoizedState;
    z === null ? i.memoizedState = { isBackwards: l, rendering: null, renderingStartTime: 0, last: k, tail: v, tailMode: D } : (z.isBackwards = l, z.rendering = null, z.renderingStartTime = 0, z.last = k, z.tail = v, z.tailMode = D);
  }
  function Fh(i, l, v) {
    var k = l.pendingProps, D = k.revealOrder, z = k.tail;
    if (Tr(i, l, k.children, v), k = jt.current, k & 2)
      k = k & 1 | 2, l.flags |= 128;
    else {
      if (i !== null && i.flags & 128)
        e:
          for (i = l.child; i !== null; ) {
            if (i.tag === 13)
              i.memoizedState !== null && Ih(i, v, l);
            else if (i.tag === 19)
              Ih(i, v, l);
            else if (i.child !== null) {
              i.child.return = i, i = i.child;
              continue;
            }
            if (i === l)
              break e;
            for (; i.sibling === null; ) {
              if (i.return === null || i.return === l)
                break e;
              i = i.return;
            }
            i.sibling.return = i.return, i = i.sibling;
          }
      k &= 1;
    }
    if (Tn(jt, k), !(l.mode & 1))
      l.memoizedState = null;
    else
      switch (D) {
        case "forwards":
          for (v = l.child, D = null; v !== null; )
            i = v.alternate, i !== null && Kn(i) === null && (D = v), v = v.sibling;
          v = D, v === null ? (D = l.child, l.child = null) : (D = v.sibling, v.sibling = null), Fd(l, !1, D, v, z);
          break;
        case "backwards":
          for (v = null, D = l.child, l.child = null; D !== null; ) {
            if (i = D.alternate, i !== null && Kn(i) === null) {
              l.child = D;
              break;
            }
            i = D.sibling, D.sibling = v, v = D, D = i;
          }
          Fd(l, !0, v, null, z);
          break;
        case "together":
          Fd(l, !1, null, null, void 0);
          break;
        default:
          l.memoizedState = null;
      }
    return l.child;
  }
  function ca(i, l) {
    !(l.mode & 1) && i !== null && (i.alternate = null, l.alternate = null, l.flags |= 2);
  }
  function Xr(i, l, v) {
    if (i !== null && (l.dependencies = i.dependencies), Rs |= l.lanes, !(v & l.childLanes))
      return null;
    if (i !== null && l.child !== i.child)
      throw Error(h(153));
    if (l.child !== null) {
      for (i = l.child, v = vo(i, i.pendingProps), l.child = v, v.return = l; i.sibling !== null; )
        i = i.sibling, v = v.sibling = vo(i, i.pendingProps), v.return = l;
      v.sibling = null;
    }
    return l.child;
  }
  function As(i, l, v) {
    switch (l.tag) {
      case 3:
        km(l), Qn();
        break;
      case 5:
        Ft(l);
        break;
      case 1:
        qn(l.type) && sd(l);
        break;
      case 4:
        Eh(l, l.stateNode.containerInfo);
        break;
      case 10:
        var k = l.type._context, D = l.memoizedProps.value;
        Tn(qi, k._currentValue), k._currentValue = D;
        break;
      case 13:
        if (k = l.memoizedState, k !== null)
          return k.dehydrated !== null ? (Tn(jt, jt.current & 1), l.flags |= 128, null) : v & l.child.childLanes ? Nh(i, l, v) : (Tn(jt, jt.current & 1), i = Xr(i, l, v), i !== null ? i.sibling : null);
        Tn(jt, jt.current & 1);
        break;
      case 19:
        if (k = (v & l.childLanes) !== 0, i.flags & 128) {
          if (k)
            return Fh(i, l, v);
          l.flags |= 128;
        }
        if (D = l.memoizedState, D !== null && (D.rendering = null, D.tail = null, D.lastEffect = null), Tn(jt, jt.current), k)
          break;
        return null;
      case 22:
      case 23:
        return l.lanes = 0, Ko(i, l, v);
    }
    return Xr(i, l, v);
  }
  var oc, el, wi, Ar;
  oc = function(i, l) {
    for (var v = l.child; v !== null; ) {
      if (v.tag === 5 || v.tag === 6)
        i.appendChild(v.stateNode);
      else if (v.tag !== 4 && v.child !== null) {
        v.child.return = v, v = v.child;
        continue;
      }
      if (v === l)
        break;
      for (; v.sibling === null; ) {
        if (v.return === null || v.return === l)
          return;
        v = v.return;
      }
      v.sibling.return = v.return, v = v.sibling;
    }
  }, el = function() {
  }, wi = function(i, l, v, k) {
    var D = i.memoizedProps;
    if (D !== k) {
      i = l.stateNode, Uo(Hi.current);
      var z = null;
      switch (v) {
        case "input":
          D = jn(i, D), k = jn(i, k), z = [];
          break;
        case "select":
          D = ye({}, D, { value: void 0 }), k = ye({}, k, { value: void 0 }), z = [];
          break;
        case "textarea":
          D = Qa(i, D), k = Qa(i, k), z = [];
          break;
        default:
          typeof D.onClick != "function" && typeof k.onClick == "function" && (i.onclick = id);
      }
      vr(v, k);
      var $;
      v = null;
      for (Re in D)
        if (!k.hasOwnProperty(Re) && D.hasOwnProperty(Re) && D[Re] != null)
          if (Re === "style") {
            var ie = D[Re];
            for ($ in ie)
              ie.hasOwnProperty($) && (v || (v = {}), v[$] = "");
          } else
            Re !== "dangerouslySetInnerHTML" && Re !== "children" && Re !== "suppressContentEditableWarning" && Re !== "suppressHydrationWarning" && Re !== "autoFocus" && (w.hasOwnProperty(Re) ? z || (z = []) : (z = z || []).push(Re, null));
      for (Re in k) {
        var de = k[Re];
        if (ie = D != null ? D[Re] : void 0, k.hasOwnProperty(Re) && de !== ie && (de != null || ie != null))
          if (Re === "style")
            if (ie) {
              for ($ in ie)
                !ie.hasOwnProperty($) || de && de.hasOwnProperty($) || (v || (v = {}), v[$] = "");
              for ($ in de)
                de.hasOwnProperty($) && ie[$] !== de[$] && (v || (v = {}), v[$] = de[$]);
            } else
              v || (z || (z = []), z.push(
                Re,
                v
              )), v = de;
          else
            Re === "dangerouslySetInnerHTML" ? (de = de ? de.__html : void 0, ie = ie ? ie.__html : void 0, de != null && ie !== de && (z = z || []).push(Re, de)) : Re === "children" ? typeof de != "string" && typeof de != "number" || (z = z || []).push(Re, "" + de) : Re !== "suppressContentEditableWarning" && Re !== "suppressHydrationWarning" && (w.hasOwnProperty(Re) ? (de != null && Re === "onScroll" && In("scroll", i), z || ie === de || (z = [])) : (z = z || []).push(Re, de));
      }
      v && (z = z || []).push("style", v);
      var Re = z;
      (l.updateQueue = Re) && (l.flags |= 4);
    }
  }, Ar = function(i, l, v, k) {
    v !== k && (l.flags |= 4);
  };
  function lc(i, l) {
    if (!Un)
      switch (i.tailMode) {
        case "hidden":
          l = i.tail;
          for (var v = null; l !== null; )
            l.alternate !== null && (v = l), l = l.sibling;
          v === null ? i.tail = null : v.sibling = null;
          break;
        case "collapsed":
          v = i.tail;
          for (var k = null; v !== null; )
            v.alternate !== null && (k = v), v = v.sibling;
          k === null ? l || i.tail === null ? i.tail = null : i.tail.sibling = null : k.sibling = null;
      }
  }
  function da(i) {
    var l = i.alternate !== null && i.alternate.child === i.child, v = 0, k = 0;
    if (l)
      for (var D = i.child; D !== null; )
        v |= D.lanes | D.childLanes, k |= D.subtreeFlags & 14680064, k |= D.flags & 14680064, D.return = i, D = D.sibling;
    else
      for (D = i.child; D !== null; )
        v |= D.lanes | D.childLanes, k |= D.subtreeFlags, k |= D.flags, D.return = i, D = D.sibling;
    return i.subtreeFlags |= k, i.childLanes = v, l;
  }
  function Px(i, l, v) {
    var k = l.pendingProps;
    switch (yh(l), l.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return da(l), null;
      case 1:
        return qn(l.type) && mi(), da(l), null;
      case 3:
        return k = l.stateNode, uo(), Sn(lr), Sn(Xt), vd(), k.pendingContext && (k.context = k.pendingContext, k.pendingContext = null), (i === null || i.child === null) && (cd(l) ? l.flags |= 4 : i === null || i.memoizedState.isDehydrated && !(l.flags & 256) || (l.flags |= 1024, yi !== null && (gc(yi), yi = null))), el(i, l), da(l), null;
      case 5:
        rn(l);
        var D = Uo(Xl.current);
        if (v = l.type, i !== null && l.stateNode != null)
          wi(i, l, v, k, D), i.ref !== l.ref && (l.flags |= 512, l.flags |= 2097152);
        else {
          if (!k) {
            if (l.stateNode === null)
              throw Error(h(166));
            return da(l), null;
          }
          if (i = Uo(Hi.current), cd(l)) {
            k = l.stateNode, v = l.type;
            var z = l.memoizedProps;
            switch (k[Gi] = l, k[jo] = z, i = (l.mode & 1) !== 0, v) {
              case "dialog":
                In("cancel", k), In("close", k);
                break;
              case "iframe":
              case "object":
              case "embed":
                In("load", k);
                break;
              case "video":
              case "audio":
                for (D = 0; D < Xu.length; D++)
                  In(Xu[D], k);
                break;
              case "source":
                In("error", k);
                break;
              case "img":
              case "image":
              case "link":
                In(
                  "error",
                  k
                ), In("load", k);
                break;
              case "details":
                In("toggle", k);
                break;
              case "input":
                ir(k, z), In("invalid", k);
                break;
              case "select":
                k._wrapperState = { wasMultiple: !!z.multiple }, In("invalid", k);
                break;
              case "textarea":
                ya(k, z), In("invalid", k);
            }
            vr(v, z), D = null;
            for (var $ in z)
              if (z.hasOwnProperty($)) {
                var ie = z[$];
                $ === "children" ? typeof ie == "string" ? k.textContent !== ie && (z.suppressHydrationWarning !== !0 && ad(k.textContent, ie, i), D = ["children", ie]) : typeof ie == "number" && k.textContent !== "" + ie && (z.suppressHydrationWarning !== !0 && ad(
                  k.textContent,
                  ie,
                  i
                ), D = ["children", "" + ie]) : w.hasOwnProperty($) && ie != null && $ === "onScroll" && In("scroll", k);
              }
            switch (v) {
              case "input":
                mn(k), ta(k, z, !0);
                break;
              case "textarea":
                mn(k), xa(k);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof z.onClick == "function" && (k.onclick = id);
            }
            k = D, l.updateQueue = k, k !== null && (l.flags |= 4);
          } else {
            $ = D.nodeType === 9 ? D : D.ownerDocument, i === "http://www.w3.org/1999/xhtml" && (i = na(v)), i === "http://www.w3.org/1999/xhtml" ? v === "script" ? (i = $.createElement("div"), i.innerHTML = "<script><\/script>", i = i.removeChild(i.firstChild)) : typeof k.is == "string" ? i = $.createElement(v, { is: k.is }) : (i = $.createElement(v), v === "select" && ($ = i, k.multiple ? $.multiple = !0 : k.size && ($.size = k.size))) : i = $.createElementNS(i, v), i[Gi] = l, i[jo] = k, oc(i, l, !1, !1), l.stateNode = i;
            e: {
              switch ($ = $n(v, k), v) {
                case "dialog":
                  In("cancel", i), In("close", i), D = k;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  In("load", i), D = k;
                  break;
                case "video":
                case "audio":
                  for (D = 0; D < Xu.length; D++)
                    In(Xu[D], i);
                  D = k;
                  break;
                case "source":
                  In("error", i), D = k;
                  break;
                case "img":
                case "image":
                case "link":
                  In(
                    "error",
                    i
                  ), In("load", i), D = k;
                  break;
                case "details":
                  In("toggle", i), D = k;
                  break;
                case "input":
                  ir(i, k), D = jn(i, k), In("invalid", i);
                  break;
                case "option":
                  D = k;
                  break;
                case "select":
                  i._wrapperState = { wasMultiple: !!k.multiple }, D = ye({}, k, { value: void 0 }), In("invalid", i);
                  break;
                case "textarea":
                  ya(i, k), D = Qa(i, k), In("invalid", i);
                  break;
                default:
                  D = k;
              }
              vr(v, D), ie = D;
              for (z in ie)
                if (ie.hasOwnProperty(z)) {
                  var de = ie[z];
                  z === "style" ? bn(i, de) : z === "dangerouslySetInnerHTML" ? (de = de ? de.__html : void 0, de != null && Pi(i, de)) : z === "children" ? typeof de == "string" ? (v !== "textarea" || de !== "") && Ka(i, de) : typeof de == "number" && Ka(i, "" + de) : z !== "suppressContentEditableWarning" && z !== "suppressHydrationWarning" && z !== "autoFocus" && (w.hasOwnProperty(z) ? de != null && z === "onScroll" && In("scroll", i) : de != null && we(i, z, de, $));
                }
              switch (v) {
                case "input":
                  mn(i), ta(i, k, !1);
                  break;
                case "textarea":
                  mn(i), xa(i);
                  break;
                case "option":
                  k.value != null && i.setAttribute("value", "" + Et(k.value));
                  break;
                case "select":
                  i.multiple = !!k.multiple, z = k.value, z != null ? di(i, !!k.multiple, z, !1) : k.defaultValue != null && di(
                    i,
                    !!k.multiple,
                    k.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof D.onClick == "function" && (i.onclick = id);
              }
              switch (v) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k = !!k.autoFocus;
                  break e;
                case "img":
                  k = !0;
                  break e;
                default:
                  k = !1;
              }
            }
            k && (l.flags |= 4);
          }
          l.ref !== null && (l.flags |= 512, l.flags |= 2097152);
        }
        return da(l), null;
      case 6:
        if (i && l.stateNode != null)
          Ar(i, l, i.memoizedProps, k);
        else {
          if (typeof k != "string" && l.stateNode === null)
            throw Error(h(166));
          if (v = Uo(Xl.current), Uo(Hi.current), cd(l)) {
            if (k = l.stateNode, v = l.memoizedProps, k[Gi] = l, (z = k.nodeValue !== v) && (i = ni, i !== null))
              switch (i.tag) {
                case 3:
                  ad(k.nodeValue, v, (i.mode & 1) !== 0);
                  break;
                case 5:
                  i.memoizedProps.suppressHydrationWarning !== !0 && ad(k.nodeValue, v, (i.mode & 1) !== 0);
              }
            z && (l.flags |= 4);
          } else
            k = (v.nodeType === 9 ? v : v.ownerDocument).createTextNode(k), k[Gi] = l, l.stateNode = k;
        }
        return da(l), null;
      case 13:
        if (Sn(jt), k = l.memoizedState, i === null || i.memoizedState !== null && i.memoizedState.dehydrated !== null) {
          if (Un && Fa !== null && l.mode & 1 && !(l.flags & 128))
            cm(), Qn(), l.flags |= 98560, z = !1;
          else if (z = cd(l), k !== null && k.dehydrated !== null) {
            if (i === null) {
              if (!z)
                throw Error(h(318));
              if (z = l.memoizedState, z = z !== null ? z.dehydrated : null, !z)
                throw Error(h(317));
              z[Gi] = l;
            } else
              Qn(), !(l.flags & 128) && (l.memoizedState = null), l.flags |= 4;
            da(l), z = !1;
          } else
            yi !== null && (gc(yi), yi = null), z = !0;
          if (!z)
            return l.flags & 65536 ? l : null;
        }
        return l.flags & 128 ? (l.lanes = v, l) : (k = k !== null, k !== (i !== null && i.memoizedState !== null) && k && (l.child.flags |= 8192, l.mode & 1 && (i === null || jt.current & 1 ? Rr === 0 && (Rr = 3) : $h())), l.updateQueue !== null && (l.flags |= 4), da(l), null);
      case 4:
        return uo(), el(i, l), i === null && Hl(l.stateNode.containerInfo), da(l), null;
      case 10:
        return io(l.type._context), da(l), null;
      case 17:
        return qn(l.type) && mi(), da(l), null;
      case 19:
        if (Sn(jt), z = l.memoizedState, z === null)
          return da(l), null;
        if (k = (l.flags & 128) !== 0, $ = z.rendering, $ === null)
          if (k)
            lc(z, !1);
          else {
            if (Rr !== 0 || i !== null && i.flags & 128)
              for (i = l.child; i !== null; ) {
                if ($ = Kn(i), $ !== null) {
                  for (l.flags |= 128, lc(z, !1), k = $.updateQueue, k !== null && (l.updateQueue = k, l.flags |= 4), l.subtreeFlags = 0, k = v, v = l.child; v !== null; )
                    z = v, i = k, z.flags &= 14680066, $ = z.alternate, $ === null ? (z.childLanes = 0, z.lanes = i, z.child = null, z.subtreeFlags = 0, z.memoizedProps = null, z.memoizedState = null, z.updateQueue = null, z.dependencies = null, z.stateNode = null) : (z.childLanes = $.childLanes, z.lanes = $.lanes, z.child = $.child, z.subtreeFlags = 0, z.deletions = null, z.memoizedProps = $.memoizedProps, z.memoizedState = $.memoizedState, z.updateQueue = $.updateQueue, z.type = $.type, i = $.dependencies, z.dependencies = i === null ? null : { lanes: i.lanes, firstContext: i.firstContext }), v = v.sibling;
                  return Tn(jt, jt.current & 1 | 2), l.child;
                }
                i = i.sibling;
              }
            z.tail !== null && o() > au && (l.flags |= 128, k = !0, lc(z, !1), l.lanes = 4194304);
          }
        else {
          if (!k)
            if (i = Kn($), i !== null) {
              if (l.flags |= 128, k = !0, v = i.updateQueue, v !== null && (l.updateQueue = v, l.flags |= 4), lc(z, !0), z.tail === null && z.tailMode === "hidden" && !$.alternate && !Un)
                return da(l), null;
            } else
              2 * o() - z.renderingStartTime > au && v !== 1073741824 && (l.flags |= 128, k = !0, lc(z, !1), l.lanes = 4194304);
          z.isBackwards ? ($.sibling = l.child, l.child = $) : (v = z.last, v !== null ? v.sibling = $ : l.child = $, z.last = $);
        }
        return z.tail !== null ? (l = z.tail, z.rendering = l, z.tail = l.sibling, z.renderingStartTime = o(), l.sibling = null, v = jt.current, Tn(jt, k ? v & 1 | 2 : v & 1), l) : (da(l), null);
      case 22:
      case 23:
        return Gh(), k = l.memoizedState !== null, i !== null && i.memoizedState !== null !== k && (l.flags |= 8192), k && l.mode & 1 ? ii & 1073741824 && (da(l), l.subtreeFlags & 6 && (l.flags |= 8192)) : da(l), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(h(156, l.tag));
  }
  function Yh(i, l) {
    switch (yh(l), l.tag) {
      case 1:
        return qn(l.type) && mi(), i = l.flags, i & 65536 ? (l.flags = i & -65537 | 128, l) : null;
      case 3:
        return uo(), Sn(lr), Sn(Xt), vd(), i = l.flags, i & 65536 && !(i & 128) ? (l.flags = i & -65537 | 128, l) : null;
      case 5:
        return rn(l), null;
      case 13:
        if (Sn(jt), i = l.memoizedState, i !== null && i.dehydrated !== null) {
          if (l.alternate === null)
            throw Error(h(340));
          Qn();
        }
        return i = l.flags, i & 65536 ? (l.flags = i & -65537 | 128, l) : null;
      case 19:
        return Sn(jt), null;
      case 4:
        return uo(), null;
      case 10:
        return io(l.type._context), null;
      case 22:
      case 23:
        return Gh(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var uc = !1, Er = !1, Cm = typeof WeakSet == "function" ? WeakSet : Set, gt = null;
  function Kl(i, l) {
    var v = i.ref;
    if (v !== null)
      if (typeof v == "function")
        try {
          v(null);
        } catch (k) {
          cr(i, l, k);
        }
      else
        v.current = null;
  }
  function cc(i, l, v) {
    try {
      v();
    } catch (k) {
      cr(i, l, k);
    }
  }
  var Tm = !1;
  function Am(i, l) {
    if (ch = Po, i = Jc(), ys(i)) {
      if ("selectionStart" in i)
        var v = { start: i.selectionStart, end: i.selectionEnd };
      else
        e: {
          v = (v = i.ownerDocument) && v.defaultView || window;
          var k = v.getSelection && v.getSelection();
          if (k && k.rangeCount !== 0) {
            v = k.anchorNode;
            var D = k.anchorOffset, z = k.focusNode;
            k = k.focusOffset;
            try {
              v.nodeType, z.nodeType;
            } catch {
              v = null;
              break e;
            }
            var $ = 0, ie = -1, de = -1, Re = 0, He = 0, Be = i, Fe = null;
            t:
              for (; ; ) {
                for (var lt; Be !== v || D !== 0 && Be.nodeType !== 3 || (ie = $ + D), Be !== z || k !== 0 && Be.nodeType !== 3 || (de = $ + k), Be.nodeType === 3 && ($ += Be.nodeValue.length), (lt = Be.firstChild) !== null; )
                  Fe = Be, Be = lt;
                for (; ; ) {
                  if (Be === i)
                    break t;
                  if (Fe === v && ++Re === D && (ie = $), Fe === z && ++He === k && (de = $), (lt = Be.nextSibling) !== null)
                    break;
                  Be = Fe, Fe = Be.parentNode;
                }
                Be = lt;
              }
            v = ie === -1 || de === -1 ? null : { start: ie, end: de };
          } else
            v = null;
        }
      v = v || { start: 0, end: 0 };
    } else
      v = null;
    for (Yo = { focusedElem: i, selectionRange: v }, Po = !1, gt = l; gt !== null; )
      if (l = gt, i = l.child, (l.subtreeFlags & 1028) !== 0 && i !== null)
        i.return = l, gt = i;
      else
        for (; gt !== null; ) {
          l = gt;
          try {
            var bt = l.alternate;
            if (l.flags & 1024)
              switch (l.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (bt !== null) {
                    var Ct = bt.memoizedProps, pr = bt.memoizedState, ve = l.stateNode, pe = ve.getSnapshotBeforeUpdate(l.elementType === l.type ? Ct : ri(l.type, Ct), pr);
                    ve.__reactInternalSnapshotBeforeUpdate = pe;
                  }
                  break;
                case 3:
                  var Se = l.stateNode.containerInfo;
                  Se.nodeType === 1 ? Se.textContent = "" : Se.nodeType === 9 && Se.documentElement && Se.removeChild(Se.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(h(163));
              }
          } catch ($e) {
            cr(l, l.return, $e);
          }
          if (i = l.sibling, i !== null) {
            i.return = l.return, gt = i;
            break;
          }
          gt = l.return;
        }
    return bt = Tm, Tm = !1, bt;
  }
  function dc(i, l, v) {
    var k = l.updateQueue;
    if (k = k !== null ? k.lastEffect : null, k !== null) {
      var D = k = k.next;
      do {
        if ((D.tag & i) === i) {
          var z = D.destroy;
          D.destroy = void 0, z !== void 0 && cc(l, v, z);
        }
        D = D.next;
      } while (D !== k);
    }
  }
  function fc(i, l) {
    if (l = l.updateQueue, l = l !== null ? l.lastEffect : null, l !== null) {
      var v = l = l.next;
      do {
        if ((v.tag & i) === i) {
          var k = v.create;
          v.destroy = k();
        }
        v = v.next;
      } while (v !== l);
    }
  }
  function Hh(i) {
    var l = i.ref;
    if (l !== null) {
      var v = i.stateNode;
      switch (i.tag) {
        case 5:
          i = v;
          break;
        default:
          i = v;
      }
      typeof l == "function" ? l(i) : l.current = i;
    }
  }
  function jh(i) {
    var l = i.alternate;
    l !== null && (i.alternate = null, jh(l)), i.child = null, i.deletions = null, i.sibling = null, i.tag === 5 && (l = i.stateNode, l !== null && (delete l[Gi], delete l[jo], delete l[hh], delete l[Ex], delete l[ph])), i.stateNode = null, i.return = null, i.dependencies = null, i.memoizedProps = null, i.memoizedState = null, i.pendingProps = null, i.stateNode = null, i.updateQueue = null;
  }
  function Em(i) {
    return i.tag === 5 || i.tag === 3 || i.tag === 4;
  }
  function Yd(i) {
    e:
      for (; ; ) {
        for (; i.sibling === null; ) {
          if (i.return === null || Em(i.return))
            return null;
          i = i.return;
        }
        for (i.sibling.return = i.return, i = i.sibling; i.tag !== 5 && i.tag !== 6 && i.tag !== 18; ) {
          if (i.flags & 2 || i.child === null || i.tag === 4)
            continue e;
          i.child.return = i, i = i.child;
        }
        if (!(i.flags & 2))
          return i.stateNode;
      }
  }
  function Jl(i, l, v) {
    var k = i.tag;
    if (k === 5 || k === 6)
      i = i.stateNode, l ? v.nodeType === 8 ? v.parentNode.insertBefore(i, l) : v.insertBefore(i, l) : (v.nodeType === 8 ? (l = v.parentNode, l.insertBefore(i, v)) : (l = v, l.appendChild(i)), v = v._reactRootContainer, v != null || l.onclick !== null || (l.onclick = id));
    else if (k !== 4 && (i = i.child, i !== null))
      for (Jl(i, l, v), i = i.sibling; i !== null; )
        Jl(i, l, v), i = i.sibling;
  }
  function Qi(i, l, v) {
    var k = i.tag;
    if (k === 5 || k === 6)
      i = i.stateNode, l ? v.insertBefore(i, l) : v.appendChild(i);
    else if (k !== 4 && (i = i.child, i !== null))
      for (Qi(i, l, v), i = i.sibling; i !== null; )
        Qi(i, l, v), i = i.sibling;
  }
  var Zn = null, Ir = !1;
  function Si(i, l, v) {
    for (v = v.child; v !== null; )
      eu(i, l, v), v = v.sibling;
  }
  function eu(i, l, v) {
    if (L && typeof L.onCommitFiberUnmount == "function")
      try {
        L.onCommitFiberUnmount(E, v);
      } catch {
      }
    switch (v.tag) {
      case 5:
        Er || Kl(v, l);
      case 6:
        var k = Zn, D = Ir;
        Zn = null, Si(i, l, v), Zn = k, Ir = D, Zn !== null && (Ir ? (i = Zn, v = v.stateNode, i.nodeType === 8 ? i.parentNode.removeChild(v) : i.removeChild(v)) : Zn.removeChild(v.stateNode));
        break;
      case 18:
        Zn !== null && (Ir ? (i = Zn, v = v.stateNode, i.nodeType === 8 ? Js(i.parentNode, v) : i.nodeType === 1 && Js(i, v), Pu(i)) : Js(Zn, v.stateNode));
        break;
      case 4:
        k = Zn, D = Ir, Zn = v.stateNode.containerInfo, Ir = !0, Si(i, l, v), Zn = k, Ir = D;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Er && (k = v.updateQueue, k !== null && (k = k.lastEffect, k !== null))) {
          D = k = k.next;
          do {
            var z = D, $ = z.destroy;
            z = z.tag, $ !== void 0 && (z & 2 || z & 4) && cc(v, l, $), D = D.next;
          } while (D !== k);
        }
        Si(i, l, v);
        break;
      case 1:
        if (!Er && (Kl(v, l), k = v.stateNode, typeof k.componentWillUnmount == "function"))
          try {
            k.props = v.memoizedProps, k.state = v.memoizedState, k.componentWillUnmount();
          } catch (ie) {
            cr(v, l, ie);
          }
        Si(i, l, v);
        break;
      case 21:
        Si(i, l, v);
        break;
      case 22:
        v.mode & 1 ? (Er = (k = Er) || v.memoizedState !== null, Si(i, l, v), Er = k) : Si(i, l, v);
        break;
      default:
        Si(i, l, v);
    }
  }
  function Es(i) {
    var l = i.updateQueue;
    if (l !== null) {
      i.updateQueue = null;
      var v = i.stateNode;
      v === null && (v = i.stateNode = new Cm()), l.forEach(function(k) {
        var D = Hx.bind(null, i, k);
        v.has(k) || (v.add(k), k.then(D, D));
      });
    }
  }
  function ji(i, l) {
    var v = l.deletions;
    if (v !== null)
      for (var k = 0; k < v.length; k++) {
        var D = v[k];
        try {
          var z = i, $ = l, ie = $;
          e:
            for (; ie !== null; ) {
              switch (ie.tag) {
                case 5:
                  Zn = ie.stateNode, Ir = !1;
                  break e;
                case 3:
                  Zn = ie.stateNode.containerInfo, Ir = !0;
                  break e;
                case 4:
                  Zn = ie.stateNode.containerInfo, Ir = !0;
                  break e;
              }
              ie = ie.return;
            }
          if (Zn === null)
            throw Error(h(160));
          eu(z, $, D), Zn = null, Ir = !1;
          var de = D.alternate;
          de !== null && (de.return = null), D.return = null;
        } catch (Re) {
          cr(D, l, Re);
        }
      }
    if (l.subtreeFlags & 12854)
      for (l = l.child; l !== null; )
        Rm(l, i), l = l.sibling;
  }
  function Rm(i, l) {
    var v = i.alternate, k = i.flags;
    switch (i.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (ji(l, i), Ki(i), k & 4) {
          try {
            dc(3, i, i.return), fc(3, i);
          } catch (Ct) {
            cr(i, i.return, Ct);
          }
          try {
            dc(5, i, i.return);
          } catch (Ct) {
            cr(i, i.return, Ct);
          }
        }
        break;
      case 1:
        ji(l, i), Ki(i), k & 512 && v !== null && Kl(v, v.return);
        break;
      case 5:
        if (ji(l, i), Ki(i), k & 512 && v !== null && Kl(v, v.return), i.flags & 32) {
          var D = i.stateNode;
          try {
            Ka(D, "");
          } catch (Ct) {
            cr(i, i.return, Ct);
          }
        }
        if (k & 4 && (D = i.stateNode, D != null)) {
          var z = i.memoizedProps, $ = v !== null ? v.memoizedProps : z, ie = i.type, de = i.updateQueue;
          if (i.updateQueue = null, de !== null)
            try {
              ie === "input" && z.type === "radio" && z.name != null && Dr(D, z), $n(ie, $);
              var Re = $n(ie, z);
              for ($ = 0; $ < de.length; $ += 2) {
                var He = de[$], Be = de[$ + 1];
                He === "style" ? bn(D, Be) : He === "dangerouslySetInnerHTML" ? Pi(D, Be) : He === "children" ? Ka(D, Be) : we(D, He, Be, Re);
              }
              switch (ie) {
                case "input":
                  Mr(D, z);
                  break;
                case "textarea":
                  fi(D, z);
                  break;
                case "select":
                  var Fe = D._wrapperState.wasMultiple;
                  D._wrapperState.wasMultiple = !!z.multiple;
                  var lt = z.value;
                  lt != null ? di(D, !!z.multiple, lt, !1) : Fe !== !!z.multiple && (z.defaultValue != null ? di(
                    D,
                    !!z.multiple,
                    z.defaultValue,
                    !0
                  ) : di(D, !!z.multiple, z.multiple ? [] : "", !1));
              }
              D[jo] = z;
            } catch (Ct) {
              cr(i, i.return, Ct);
            }
        }
        break;
      case 6:
        if (ji(l, i), Ki(i), k & 4) {
          if (i.stateNode === null)
            throw Error(h(162));
          D = i.stateNode, z = i.memoizedProps;
          try {
            D.nodeValue = z;
          } catch (Ct) {
            cr(i, i.return, Ct);
          }
        }
        break;
      case 3:
        if (ji(l, i), Ki(i), k & 4 && v !== null && v.memoizedState.isDehydrated)
          try {
            Pu(l.containerInfo);
          } catch (Ct) {
            cr(i, i.return, Ct);
          }
        break;
      case 4:
        ji(l, i), Ki(i);
        break;
      case 13:
        ji(l, i), Ki(i), D = i.child, D.flags & 8192 && (z = D.memoizedState !== null, D.stateNode.isHidden = z, !z || D.alternate !== null && D.alternate.memoizedState !== null || (Uh = o())), k & 4 && Es(i);
        break;
      case 22:
        if (He = v !== null && v.memoizedState !== null, i.mode & 1 ? (Er = (Re = Er) || He, ji(l, i), Er = Re) : ji(l, i), Ki(i), k & 8192) {
          if (Re = i.memoizedState !== null, (i.stateNode.isHidden = Re) && !He && i.mode & 1)
            for (gt = i, He = i.child; He !== null; ) {
              for (Be = gt = He; gt !== null; ) {
                switch (Fe = gt, lt = Fe.child, Fe.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    dc(4, Fe, Fe.return);
                    break;
                  case 1:
                    Kl(Fe, Fe.return);
                    var bt = Fe.stateNode;
                    if (typeof bt.componentWillUnmount == "function") {
                      k = Fe, v = Fe.return;
                      try {
                        l = k, bt.props = l.memoizedProps, bt.state = l.memoizedState, bt.componentWillUnmount();
                      } catch (Ct) {
                        cr(k, v, Ct);
                      }
                    }
                    break;
                  case 5:
                    Kl(Fe, Fe.return);
                    break;
                  case 22:
                    if (Fe.memoizedState !== null) {
                      Bh(Be);
                      continue;
                    }
                }
                lt !== null ? (lt.return = Fe, gt = lt) : Bh(Be);
              }
              He = He.sibling;
            }
          e:
            for (He = null, Be = i; ; ) {
              if (Be.tag === 5) {
                if (He === null) {
                  He = Be;
                  try {
                    D = Be.stateNode, Re ? (z = D.style, typeof z.setProperty == "function" ? z.setProperty("display", "none", "important") : z.display = "none") : (ie = Be.stateNode, de = Be.memoizedProps.style, $ = de != null && de.hasOwnProperty("display") ? de.display : null, ie.style.display = nn("display", $));
                  } catch (Ct) {
                    cr(i, i.return, Ct);
                  }
                }
              } else if (Be.tag === 6) {
                if (He === null)
                  try {
                    Be.stateNode.nodeValue = Re ? "" : Be.memoizedProps;
                  } catch (Ct) {
                    cr(i, i.return, Ct);
                  }
              } else if ((Be.tag !== 22 && Be.tag !== 23 || Be.memoizedState === null || Be === i) && Be.child !== null) {
                Be.child.return = Be, Be = Be.child;
                continue;
              }
              if (Be === i)
                break e;
              for (; Be.sibling === null; ) {
                if (Be.return === null || Be.return === i)
                  break e;
                He === Be && (He = null), Be = Be.return;
              }
              He === Be && (He = null), Be.sibling.return = Be.return, Be = Be.sibling;
            }
        }
        break;
      case 19:
        ji(l, i), Ki(i), k & 4 && Es(i);
        break;
      case 21:
        break;
      default:
        ji(
          l,
          i
        ), Ki(i);
    }
  }
  function Ki(i) {
    var l = i.flags;
    if (l & 2) {
      try {
        e: {
          for (var v = i.return; v !== null; ) {
            if (Em(v)) {
              var k = v;
              break e;
            }
            v = v.return;
          }
          throw Error(h(160));
        }
        switch (k.tag) {
          case 5:
            var D = k.stateNode;
            k.flags & 32 && (Ka(D, ""), k.flags &= -33);
            var z = Yd(i);
            Qi(i, z, D);
            break;
          case 3:
          case 4:
            var $ = k.stateNode.containerInfo, ie = Yd(i);
            Jl(i, ie, $);
            break;
          default:
            throw Error(h(161));
        }
      } catch (de) {
        cr(i, i.return, de);
      }
      i.flags &= -3;
    }
    l & 4096 && (i.flags &= -4097);
  }
  function Lm(i, l, v) {
    gt = i, tu(i);
  }
  function tu(i, l, v) {
    for (var k = (i.mode & 1) !== 0; gt !== null; ) {
      var D = gt, z = D.child;
      if (D.tag === 22 && k) {
        var $ = D.memoizedState !== null || uc;
        if (!$) {
          var ie = D.alternate, de = ie !== null && ie.memoizedState !== null || Er;
          ie = uc;
          var Re = Er;
          if (uc = $, (Er = de) && !Re)
            for (gt = D; gt !== null; )
              $ = gt, de = $.child, $.tag === 22 && $.memoizedState !== null ? Dm(D) : de !== null ? (de.return = $, gt = de) : Dm(D);
          for (; z !== null; )
            gt = z, tu(z), z = z.sibling;
          gt = D, uc = ie, Er = Re;
        }
        Om(i);
      } else
        D.subtreeFlags & 8772 && z !== null ? (z.return = D, gt = z) : Om(i);
    }
  }
  function Om(i) {
    for (; gt !== null; ) {
      var l = gt;
      if (l.flags & 8772) {
        var v = l.alternate;
        try {
          if (l.flags & 8772)
            switch (l.tag) {
              case 0:
              case 11:
              case 15:
                Er || fc(5, l);
                break;
              case 1:
                var k = l.stateNode;
                if (l.flags & 4 && !Er)
                  if (v === null)
                    k.componentDidMount();
                  else {
                    var D = l.elementType === l.type ? v.memoizedProps : ri(l.type, v.memoizedProps);
                    k.componentDidUpdate(D, v.memoizedState, k.__reactInternalSnapshotBeforeUpdate);
                  }
                var z = l.updateQueue;
                z !== null && Wo(l, z, k);
                break;
              case 3:
                var $ = l.updateQueue;
                if ($ !== null) {
                  if (v = null, l.child !== null)
                    switch (l.child.tag) {
                      case 5:
                        v = l.child.stateNode;
                        break;
                      case 1:
                        v = l.child.stateNode;
                    }
                  Wo(l, $, v);
                }
                break;
              case 5:
                var ie = l.stateNode;
                if (v === null && l.flags & 4) {
                  v = ie;
                  var de = l.memoizedProps;
                  switch (l.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      de.autoFocus && v.focus();
                      break;
                    case "img":
                      de.src && (v.src = de.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (l.memoizedState === null) {
                  var Re = l.alternate;
                  if (Re !== null) {
                    var He = Re.memoizedState;
                    if (He !== null) {
                      var Be = He.dehydrated;
                      Be !== null && Pu(Be);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(h(163));
            }
          Er || l.flags & 512 && Hh(l);
        } catch (Fe) {
          cr(l, l.return, Fe);
        }
      }
      if (l === i) {
        gt = null;
        break;
      }
      if (v = l.sibling, v !== null) {
        v.return = l.return, gt = v;
        break;
      }
      gt = l.return;
    }
  }
  function Bh(i) {
    for (; gt !== null; ) {
      var l = gt;
      if (l === i) {
        gt = null;
        break;
      }
      var v = l.sibling;
      if (v !== null) {
        v.return = l.return, gt = v;
        break;
      }
      gt = l.return;
    }
  }
  function Dm(i) {
    for (; gt !== null; ) {
      var l = gt;
      try {
        switch (l.tag) {
          case 0:
          case 11:
          case 15:
            var v = l.return;
            try {
              fc(4, l);
            } catch (de) {
              cr(l, v, de);
            }
            break;
          case 1:
            var k = l.stateNode;
            if (typeof k.componentDidMount == "function") {
              var D = l.return;
              try {
                k.componentDidMount();
              } catch (de) {
                cr(l, D, de);
              }
            }
            var z = l.return;
            try {
              Hh(l);
            } catch (de) {
              cr(l, z, de);
            }
            break;
          case 5:
            var $ = l.return;
            try {
              Hh(l);
            } catch (de) {
              cr(l, $, de);
            }
        }
      } catch (de) {
        cr(l, l.return, de);
      }
      if (l === i) {
        gt = null;
        break;
      }
      var ie = l.sibling;
      if (ie !== null) {
        ie.return = l.return, gt = ie;
        break;
      }
      gt = l.return;
    }
  }
  var Hd = Math.ceil, hc = Ee.ReactCurrentDispatcher, Wh = Ee.ReactCurrentOwner, fa = Ee.ReactCurrentBatchConfig, sn = 0, Jn = null, ur = null, Fr = 0, ii = 0, nu = en(0), Rr = 0, pc = null, Rs = 0, jd = 0, ru = 0, tl = null, wa = null, Uh = 0, au = 1 / 0, Ls = null, Bd = !1, nl = null, Ji = null, po = !1, go = null, Wd = 0, iu = 0, Ud = null, rl = -1, al = 0;
  function ha() {
    return sn & 6 ? o() : rl !== -1 ? rl : rl = o();
  }
  function Sr(i) {
    return i.mode & 1 ? sn & 2 && Fr !== 0 ? Fr & -Fr : dd.transition !== null ? (al === 0 && (al = oe()), al) : (i = Ie, i !== 0 || (i = window.event, i = i === void 0 ? 16 : Uf(i.type)), i) : 1;
  }
  function pa(i, l, v, k) {
    if (50 < iu)
      throw iu = 0, Ud = null, Error(h(185));
    ke(i, v, k), (!(sn & 2) || i !== Jn) && (i === Jn && (!(sn & 2) && (jd |= v), Rr === 4 && ki(i, Fr)), ga(i, k), v === 1 && sn === 0 && !(l.mode & 1) && (au = o() + 500, Nr && Na()));
  }
  function ga(i, l) {
    var v = i.callbackNode;
    Q(i, l);
    var k = N(i, i === Jn ? Fr : 0);
    if (k === 0)
      v !== null && t(v), i.callbackNode = null, i.callbackPriority = 0;
    else if (l = k & -k, i.callbackPriority !== l) {
      if (v != null && t(v), l === 1)
        i.tag === 0 ? mh(Mm.bind(null, i)) : gh(Mm.bind(null, i)), fh(function() {
          !(sn & 6) && Na();
        }), v = null;
      else {
        switch (at(k)) {
          case 1:
            v = f;
            break;
          case 4:
            v = p;
            break;
          case 16:
            v = y;
            break;
          case 536870912:
            v = C;
            break;
          default:
            v = y;
        }
        v = Zh(v, su.bind(null, i));
      }
      i.callbackPriority = l, i.callbackNode = v;
    }
  }
  function su(i, l) {
    if (rl = -1, al = 0, sn & 6)
      throw Error(h(327));
    var v = i.callbackNode;
    if (lu() && i.callbackNode !== v)
      return null;
    var k = N(i, i === Jn ? Fr : 0);
    if (k === 0)
      return null;
    if (k & 30 || k & i.expiredLanes || l)
      l = Vd(i, k);
    else {
      l = k;
      var D = sn;
      sn |= 2;
      var z = Xd();
      (Jn !== i || Fr !== l) && (Ls = null, au = o() + 500, il(i, l));
      do
        try {
          zx();
          break;
        } catch (ie) {
          _m(i, ie);
        }
      while (1);
      Sh(), hc.current = z, sn = D, ur !== null ? l = 0 : (Jn = null, Fr = 0, l = Rr);
    }
    if (l !== 0) {
      if (l === 2 && (D = ee(i), D !== 0 && (k = D, l = Xh(i, D))), l === 1)
        throw v = pc, il(i, 0), ki(i, k), ga(i, o()), v;
      if (l === 6)
        ki(i, k);
      else {
        if (D = i.current.alternate, !(k & 30) && !Vh(D) && (l = Vd(i, k), l === 2 && (z = ee(i), z !== 0 && (k = z, l = Xh(i, z))), l === 1))
          throw v = pc, il(i, 0), ki(i, k), ga(i, o()), v;
        switch (i.finishedWork = D, i.finishedLanes = k, l) {
          case 0:
          case 1:
            throw Error(h(345));
          case 2:
            sl(i, wa, Ls);
            break;
          case 3:
            if (ki(i, k), (k & 130023424) === k && (l = Uh + 500 - o(), 10 < l)) {
              if (N(i, 0) !== 0)
                break;
              if (D = i.suspendedLanes, (D & k) !== k) {
                ha(), i.pingedLanes |= i.suspendedLanes & D;
                break;
              }
              i.timeoutHandle = Ho(sl.bind(null, i, wa, Ls), l);
              break;
            }
            sl(i, wa, Ls);
            break;
          case 4:
            if (ki(i, k), (k & 4194240) === k)
              break;
            for (l = i.eventTimes, D = -1; 0 < k; ) {
              var $ = 31 - P(k);
              z = 1 << $, $ = l[$], $ > D && (D = $), k &= ~z;
            }
            if (k = D, k = o() - k, k = (120 > k ? 120 : 480 > k ? 480 : 1080 > k ? 1080 : 1920 > k ? 1920 : 3e3 > k ? 3e3 : 4320 > k ? 4320 : 1960 * Hd(k / 1960)) - k, 10 < k) {
              i.timeoutHandle = Ho(sl.bind(null, i, wa, Ls), k);
              break;
            }
            sl(i, wa, Ls);
            break;
          case 5:
            sl(i, wa, Ls);
            break;
          default:
            throw Error(h(329));
        }
      }
    }
    return ga(i, o()), i.callbackNode === v ? su.bind(null, i) : null;
  }
  function Xh(i, l) {
    var v = tl;
    return i.current.memoizedState.isDehydrated && (il(i, l).flags |= 256), i = Vd(i, l), i !== 2 && (l = wa, wa = v, l !== null && gc(l)), i;
  }
  function gc(i) {
    wa === null ? wa = i : wa.push.apply(wa, i);
  }
  function Vh(i) {
    for (var l = i; ; ) {
      if (l.flags & 16384) {
        var v = l.updateQueue;
        if (v !== null && (v = v.stores, v !== null))
          for (var k = 0; k < v.length; k++) {
            var D = v[k], z = D.getSnapshot;
            D = D.value;
            try {
              if (!hi(z(), D))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (v = l.child, l.subtreeFlags & 16384 && v !== null)
        v.return = l, l = v;
      else {
        if (l === i)
          break;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === i)
            return !0;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    }
    return !0;
  }
  function ki(i, l) {
    for (l &= ~ru, l &= ~jd, i.suspendedLanes |= l, i.pingedLanes &= ~l, i = i.expirationTimes; 0 < l; ) {
      var v = 31 - P(l), k = 1 << v;
      i[v] = -1, l &= ~k;
    }
  }
  function Mm(i) {
    if (sn & 6)
      throw Error(h(327));
    lu();
    var l = N(i, 0);
    if (!(l & 1))
      return ga(i, o()), null;
    var v = Vd(i, l);
    if (i.tag !== 0 && v === 2) {
      var k = ee(i);
      k !== 0 && (l = k, v = Xh(i, k));
    }
    if (v === 1)
      throw v = pc, il(i, 0), ki(i, l), ga(i, o()), v;
    if (v === 6)
      throw Error(h(345));
    return i.finishedWork = i.current.alternate, i.finishedLanes = l, sl(i, wa, Ls), ga(i, o()), null;
  }
  function ou(i, l) {
    var v = sn;
    sn |= 1;
    try {
      return i(l);
    } finally {
      sn = v, sn === 0 && (au = o() + 500, Nr && Na());
    }
  }
  function mo(i) {
    go !== null && go.tag === 0 && !(sn & 6) && lu();
    var l = sn;
    sn |= 1;
    var v = fa.transition, k = Ie;
    try {
      if (fa.transition = null, Ie = 1, i)
        return i();
    } finally {
      Ie = k, fa.transition = v, sn = l, !(sn & 6) && Na();
    }
  }
  function Gh() {
    ii = nu.current, Sn(nu);
  }
  function il(i, l) {
    i.finishedWork = null, i.finishedLanes = 0;
    var v = i.timeoutHandle;
    if (v !== -1 && (i.timeoutHandle = -1, sm(v)), ur !== null)
      for (v = ur.return; v !== null; ) {
        var k = v;
        switch (yh(k), k.tag) {
          case 1:
            k = k.type.childContextTypes, k != null && mi();
            break;
          case 3:
            uo(), Sn(lr), Sn(Xt), vd();
            break;
          case 5:
            rn(k);
            break;
          case 4:
            uo();
            break;
          case 13:
            Sn(jt);
            break;
          case 19:
            Sn(jt);
            break;
          case 10:
            io(k.type._context);
            break;
          case 22:
          case 23:
            Gh();
        }
        v = v.return;
      }
    if (Jn = i, ur = i = vo(i.current, null), Fr = ii = l, Rr = 0, pc = null, ru = jd = Rs = 0, wa = tl = null, Ur !== null) {
      for (l = 0; l < Ur.length; l++)
        if (v = Ur[l], k = v.interleaved, k !== null) {
          v.interleaved = null;
          var D = k.next, z = v.pending;
          if (z !== null) {
            var $ = z.next;
            z.next = D, k.next = $;
          }
          v.pending = k;
        }
      Ur = null;
    }
    return i;
  }
  function _m(i, l) {
    do {
      var v = ur;
      try {
        if (Sh(), yd.current = Pd, Bt) {
          for (var k = Xn.memoizedState; k !== null; ) {
            var D = k.queue;
            D !== null && (D.pending = null), k = k.next;
          }
          Bt = !1;
        }
        if (Xo = 0, dn = Ne = Xn = null, Zi = !1, ai = 0, Wh.current = null, v === null || v.return === null) {
          Rr = 1, pc = l, ur = null;
          break;
        }
        e: {
          var z = i, $ = v.return, ie = v, de = l;
          if (l = Fr, ie.flags |= 32768, de !== null && typeof de == "object" && typeof de.then == "function") {
            var Re = de, He = ie, Be = He.tag;
            if (!(He.mode & 1) && (Be === 0 || Be === 11 || Be === 15)) {
              var Fe = He.alternate;
              Fe ? (He.updateQueue = Fe.updateQueue, He.memoizedState = Fe.memoizedState, He.lanes = Fe.lanes) : (He.updateQueue = null, He.memoizedState = null);
            }
            var lt = Dh($);
            if (lt !== null) {
              lt.flags &= -257, Mh(lt, $, ie, z, l), lt.mode & 1 && wm(z, Re, l), l = lt, de = Re;
              var bt = l.updateQueue;
              if (bt === null) {
                var Ct = /* @__PURE__ */ new Set();
                Ct.add(de), l.updateQueue = Ct;
              } else
                bt.add(de);
              break e;
            } else {
              if (!(l & 1)) {
                wm(z, Re, l), $h();
                break e;
              }
              de = Error(h(426));
            }
          } else if (Un && ie.mode & 1) {
            var pr = Dh($);
            if (pr !== null) {
              !(pr.flags & 65536) && (pr.flags |= 256), Mh(pr, $, ie, z, l), bh(ql(de, ie));
              break e;
            }
          }
          z = de = ql(de, ie), Rr !== 4 && (Rr = 2), tl === null ? tl = [z] : tl.push(z), z = $;
          do {
            switch (z.tag) {
              case 3:
                z.flags |= 65536, l &= -l, z.lanes |= l;
                var ve = bm(z, de, l);
                Th(z, ve);
                break e;
              case 1:
                ie = de;
                var pe = z.type, Se = z.stateNode;
                if (!(z.flags & 128) && (typeof pe.getDerivedStateFromError == "function" || Se !== null && typeof Se.componentDidCatch == "function" && (Ji === null || !Ji.has(Se)))) {
                  z.flags |= 65536, l &= -l, z.lanes |= l;
                  var $e = sc(z, ie, l);
                  Th(z, $e);
                  break e;
                }
            }
            z = z.return;
          } while (z !== null);
        }
        qh(v);
      } catch (At) {
        l = At, ur === v && v !== null && (ur = v = v.return);
        continue;
      }
      break;
    } while (1);
  }
  function Xd() {
    var i = hc.current;
    return hc.current = Pd, i === null ? Pd : i;
  }
  function $h() {
    (Rr === 0 || Rr === 3 || Rr === 2) && (Rr = 4), Jn === null || !(Rs & 268435455) && !(jd & 268435455) || ki(Jn, Fr);
  }
  function Vd(i, l) {
    var v = sn;
    sn |= 2;
    var k = Xd();
    (Jn !== i || Fr !== l) && (Ls = null, il(i, l));
    do
      try {
        Nx();
        break;
      } catch (D) {
        _m(i, D);
      }
    while (1);
    if (Sh(), sn = v, hc.current = k, ur !== null)
      throw Error(h(261));
    return Jn = null, Fr = 0, Rr;
  }
  function Nx() {
    for (; ur !== null; )
      Pm(ur);
  }
  function zx() {
    for (; ur !== null && !n(); )
      Pm(ur);
  }
  function Pm(i) {
    var l = zm(i.alternate, i, ii);
    i.memoizedProps = i.pendingProps, l === null ? qh(i) : ur = l, Wh.current = null;
  }
  function qh(i) {
    var l = i;
    do {
      var v = l.alternate;
      if (i = l.return, l.flags & 32768) {
        if (v = Yh(v, l), v !== null) {
          v.flags &= 32767, ur = v;
          return;
        }
        if (i !== null)
          i.flags |= 32768, i.subtreeFlags = 0, i.deletions = null;
        else {
          Rr = 6, ur = null;
          return;
        }
      } else if (v = Px(v, l, ii), v !== null) {
        ur = v;
        return;
      }
      if (l = l.sibling, l !== null) {
        ur = l;
        return;
      }
      ur = l = i;
    } while (l !== null);
    Rr === 0 && (Rr = 5);
  }
  function sl(i, l, v) {
    var k = Ie, D = fa.transition;
    try {
      fa.transition = null, Ie = 1, Ix(i, l, v, k);
    } finally {
      fa.transition = D, Ie = k;
    }
    return null;
  }
  function Ix(i, l, v, k) {
    do
      lu();
    while (go !== null);
    if (sn & 6)
      throw Error(h(327));
    v = i.finishedWork;
    var D = i.finishedLanes;
    if (v === null)
      return null;
    if (i.finishedWork = null, i.finishedLanes = 0, v === i.current)
      throw Error(h(177));
    i.callbackNode = null, i.callbackPriority = 0;
    var z = v.lanes | v.childLanes;
    if (_e(i, z), i === Jn && (ur = Jn = null, Fr = 0), !(v.subtreeFlags & 2064) && !(v.flags & 2064) || po || (po = !0, Zh(y, function() {
      return lu(), null;
    })), z = (v.flags & 15990) !== 0, v.subtreeFlags & 15990 || z) {
      z = fa.transition, fa.transition = null;
      var $ = Ie;
      Ie = 1;
      var ie = sn;
      sn |= 4, Wh.current = null, Am(i, v), Rm(v, i), ed(Yo), Po = !!ch, Yo = ch = null, i.current = v, Lm(v), a(), sn = ie, Ie = $, fa.transition = z;
    } else
      i.current = v;
    if (po && (po = !1, go = i, Wd = D), z = i.pendingLanes, z === 0 && (Ji = null), M(v.stateNode), ga(i, o()), l !== null)
      for (k = i.onRecoverableError, v = 0; v < l.length; v++)
        D = l[v], k(D.value, { componentStack: D.stack, digest: D.digest });
    if (Bd)
      throw Bd = !1, i = nl, nl = null, i;
    return Wd & 1 && i.tag !== 0 && lu(), z = i.pendingLanes, z & 1 ? i === Ud ? iu++ : (iu = 0, Ud = i) : iu = 0, Na(), null;
  }
  function lu() {
    if (go !== null) {
      var i = at(Wd), l = fa.transition, v = Ie;
      try {
        if (fa.transition = null, Ie = 16 > i ? 16 : i, go === null)
          var k = !1;
        else {
          if (i = go, go = null, Wd = 0, sn & 6)
            throw Error(h(331));
          var D = sn;
          for (sn |= 4, gt = i.current; gt !== null; ) {
            var z = gt, $ = z.child;
            if (gt.flags & 16) {
              var ie = z.deletions;
              if (ie !== null) {
                for (var de = 0; de < ie.length; de++) {
                  var Re = ie[de];
                  for (gt = Re; gt !== null; ) {
                    var He = gt;
                    switch (He.tag) {
                      case 0:
                      case 11:
                      case 15:
                        dc(8, He, z);
                    }
                    var Be = He.child;
                    if (Be !== null)
                      Be.return = He, gt = Be;
                    else
                      for (; gt !== null; ) {
                        He = gt;
                        var Fe = He.sibling, lt = He.return;
                        if (jh(He), He === Re) {
                          gt = null;
                          break;
                        }
                        if (Fe !== null) {
                          Fe.return = lt, gt = Fe;
                          break;
                        }
                        gt = lt;
                      }
                  }
                }
                var bt = z.alternate;
                if (bt !== null) {
                  var Ct = bt.child;
                  if (Ct !== null) {
                    bt.child = null;
                    do {
                      var pr = Ct.sibling;
                      Ct.sibling = null, Ct = pr;
                    } while (Ct !== null);
                  }
                }
                gt = z;
              }
            }
            if (z.subtreeFlags & 2064 && $ !== null)
              $.return = z, gt = $;
            else
              e:
                for (; gt !== null; ) {
                  if (z = gt, z.flags & 2048)
                    switch (z.tag) {
                      case 0:
                      case 11:
                      case 15:
                        dc(9, z, z.return);
                    }
                  var ve = z.sibling;
                  if (ve !== null) {
                    ve.return = z.return, gt = ve;
                    break e;
                  }
                  gt = z.return;
                }
          }
          var pe = i.current;
          for (gt = pe; gt !== null; ) {
            $ = gt;
            var Se = $.child;
            if ($.subtreeFlags & 2064 && Se !== null)
              Se.return = $, gt = Se;
            else
              e:
                for ($ = pe; gt !== null; ) {
                  if (ie = gt, ie.flags & 2048)
                    try {
                      switch (ie.tag) {
                        case 0:
                        case 11:
                        case 15:
                          fc(9, ie);
                      }
                    } catch (At) {
                      cr(ie, ie.return, At);
                    }
                  if (ie === $) {
                    gt = null;
                    break e;
                  }
                  var $e = ie.sibling;
                  if ($e !== null) {
                    $e.return = ie.return, gt = $e;
                    break e;
                  }
                  gt = ie.return;
                }
          }
          if (sn = D, Na(), L && typeof L.onPostCommitFiberRoot == "function")
            try {
              L.onPostCommitFiberRoot(E, i);
            } catch {
            }
          k = !0;
        }
        return k;
      } finally {
        Ie = v, fa.transition = l;
      }
    }
    return !1;
  }
  function Nm(i, l, v) {
    l = ql(v, l), l = bm(i, l, 1), i = oo(i, l, 1), l = ha(), i !== null && (ke(i, 1, l), ga(i, l));
  }
  function cr(i, l, v) {
    if (i.tag === 3)
      Nm(i, i, v);
    else
      for (; l !== null; ) {
        if (l.tag === 3) {
          Nm(l, i, v);
          break;
        } else if (l.tag === 1) {
          var k = l.stateNode;
          if (typeof l.type.getDerivedStateFromError == "function" || typeof k.componentDidCatch == "function" && (Ji === null || !Ji.has(k))) {
            i = ql(v, i), i = sc(l, i, 1), l = oo(l, i, 1), i = ha(), l !== null && (ke(l, 1, i), ga(l, i));
            break;
          }
        }
        l = l.return;
      }
  }
  function Fx(i, l, v) {
    var k = i.pingCache;
    k !== null && k.delete(l), l = ha(), i.pingedLanes |= i.suspendedLanes & v, Jn === i && (Fr & v) === v && (Rr === 4 || Rr === 3 && (Fr & 130023424) === Fr && 500 > o() - Uh ? il(i, 0) : ru |= v), ga(i, l);
  }
  function Gd(i, l) {
    l === 0 && (i.mode & 1 ? (l = b, b <<= 1, !(b & 130023424) && (b = 4194304)) : l = 1);
    var v = ha();
    i = ks(i, l), i !== null && (ke(i, l, v), ga(i, v));
  }
  function Yx(i) {
    var l = i.memoizedState, v = 0;
    l !== null && (v = l.retryLane), Gd(i, v);
  }
  function Hx(i, l) {
    var v = 0;
    switch (i.tag) {
      case 13:
        var k = i.stateNode, D = i.memoizedState;
        D !== null && (v = D.retryLane);
        break;
      case 19:
        k = i.stateNode;
        break;
      default:
        throw Error(h(314));
    }
    k !== null && k.delete(l), Gd(i, v);
  }
  var zm;
  zm = function(i, l, v) {
    if (i !== null)
      if (i.memoizedProps !== l.pendingProps || lr.current)
        wr = !0;
      else {
        if (!(i.lanes & v) && !(l.flags & 128))
          return wr = !1, As(i, l, v);
        wr = !!(i.flags & 131072);
      }
    else
      wr = !1, Un && l.flags & 1048576 && vh(l, Bl, l.index);
    switch (l.lanes = 0, l.tag) {
      case 2:
        var k = l.type;
        ca(i, l), i = l.pendingProps;
        var D = gi(l, Xt.current);
        nt(l, v), D = co(null, l, k, i, D, v);
        var z = $o();
        return l.flags |= 1, typeof D == "object" && D !== null && typeof D.render == "function" && D.$$typeof === void 0 ? (l.tag = 1, l.memoizedState = null, l.updateQueue = null, qn(k) ? (z = !0, sd(l)) : z = !1, l.memoizedState = D.state !== null && D.state !== void 0 ? D.state : null, Ch(l), D.updater = pd, l.stateNode = D, D._reactInternals = l, gd(l, k, i, v), l = Sm(null, l, k, !0, z, v)) : (l.tag = 0, Un && z && od(l), Tr(null, l, D, v), l = l.child), l;
      case 16:
        k = l.elementType;
        e: {
          switch (ca(i, l), i = l.pendingProps, D = k._init, k = D(k._payload), l.type = k, D = l.tag = Bx(k), i = ri(k, i), D) {
            case 0:
              l = Zl(null, l, k, i, v);
              break e;
            case 1:
              l = _h(null, l, k, i, v);
              break e;
            case 11:
              l = ho(null, l, k, i, v);
              break e;
            case 14:
              l = zd(null, l, k, ri(k.type, i), v);
              break e;
          }
          throw Error(h(
            306,
            k,
            ""
          ));
        }
        return l;
      case 0:
        return k = l.type, D = l.pendingProps, D = l.elementType === k ? D : ri(k, D), Zl(i, l, k, D, v);
      case 1:
        return k = l.type, D = l.pendingProps, D = l.elementType === k ? D : ri(k, D), _h(i, l, k, D, v);
      case 3:
        e: {
          if (km(l), i === null)
            throw Error(h(387));
          k = l.pendingProps, z = l.memoizedState, D = z.element, Cr(i, l), lo(l, k, null, v);
          var $ = l.memoizedState;
          if (k = $.element, z.isDehydrated)
            if (z = { element: k, isDehydrated: !1, cache: $.cache, pendingSuspenseBoundaries: $.pendingSuspenseBoundaries, transitions: $.transitions }, l.updateQueue.baseState = z, l.memoizedState = z, l.flags & 256) {
              D = ql(Error(h(423)), l), l = Id(i, l, k, v, D);
              break e;
            } else if (k !== D) {
              D = ql(Error(h(424)), l), l = Id(i, l, k, v, D);
              break e;
            } else
              for (Fa = Yi(l.stateNode.containerInfo.firstChild), ni = l, Un = !0, yi = null, v = ym(l, null, k, v), l.child = v; v; )
                v.flags = v.flags & -3 | 4096, v = v.sibling;
          else {
            if (Qn(), k === D) {
              l = Xr(i, l, v);
              break e;
            }
            Tr(i, l, k, v);
          }
          l = l.child;
        }
        return l;
      case 5:
        return Ft(l), i === null && ud(l), k = l.type, D = l.pendingProps, z = i !== null ? i.memoizedProps : null, $ = D.children, $u(k, D) ? $ = null : z !== null && $u(k, z) && (l.flags |= 32), tn(i, l), Tr(i, l, $, v), l.child;
      case 6:
        return i === null && ud(l), null;
      case 13:
        return Nh(i, l, v);
      case 4:
        return Eh(l, l.stateNode.containerInfo), k = l.pendingProps, i === null ? l.child = Ul(l, null, k, v) : Tr(i, l, k, v), l.child;
      case 11:
        return k = l.type, D = l.pendingProps, D = l.elementType === k ? D : ri(k, D), ho(i, l, k, D, v);
      case 7:
        return Tr(i, l, l.pendingProps, v), l.child;
      case 8:
        return Tr(i, l, l.pendingProps.children, v), l.child;
      case 12:
        return Tr(i, l, l.pendingProps.children, v), l.child;
      case 10:
        e: {
          if (k = l.type._context, D = l.pendingProps, z = l.memoizedProps, $ = D.value, Tn(qi, k._currentValue), k._currentValue = $, z !== null)
            if (hi(z.value, $)) {
              if (z.children === D.children && !lr.current) {
                l = Xr(i, l, v);
                break e;
              }
            } else
              for (z = l.child, z !== null && (z.return = l); z !== null; ) {
                var ie = z.dependencies;
                if (ie !== null) {
                  $ = z.child;
                  for (var de = ie.firstContext; de !== null; ) {
                    if (de.context === k) {
                      if (z.tag === 1) {
                        de = Cs(-1, v & -v), de.tag = 2;
                        var Re = z.updateQueue;
                        if (Re !== null) {
                          Re = Re.shared;
                          var He = Re.pending;
                          He === null ? de.next = de : (de.next = He.next, He.next = de), Re.pending = de;
                        }
                      }
                      z.lanes |= v, de = z.alternate, de !== null && (de.lanes |= v), zr(
                        z.return,
                        v,
                        l
                      ), ie.lanes |= v;
                      break;
                    }
                    de = de.next;
                  }
                } else if (z.tag === 10)
                  $ = z.type === l.type ? null : z.child;
                else if (z.tag === 18) {
                  if ($ = z.return, $ === null)
                    throw Error(h(341));
                  $.lanes |= v, ie = $.alternate, ie !== null && (ie.lanes |= v), zr($, v, l), $ = z.sibling;
                } else
                  $ = z.child;
                if ($ !== null)
                  $.return = z;
                else
                  for ($ = z; $ !== null; ) {
                    if ($ === l) {
                      $ = null;
                      break;
                    }
                    if (z = $.sibling, z !== null) {
                      z.return = $.return, $ = z;
                      break;
                    }
                    $ = $.return;
                  }
                z = $;
              }
          Tr(i, l, D.children, v), l = l.child;
        }
        return l;
      case 9:
        return D = l.type, k = l.pendingProps.children, nt(l, v), D = hr(D), k = k(D), l.flags |= 1, Tr(i, l, k, v), l.child;
      case 14:
        return k = l.type, D = ri(k, l.pendingProps), D = ri(k.type, D), zd(i, l, k, D, v);
      case 15:
        return ja(i, l, l.type, l.pendingProps, v);
      case 17:
        return k = l.type, D = l.pendingProps, D = l.elementType === k ? D : ri(k, D), ca(i, l), l.tag = 1, qn(k) ? (i = !0, sd(l)) : i = !1, nt(l, v), pm(l, k, D), gd(l, k, D, v), Sm(null, l, k, !0, i, v);
      case 19:
        return Fh(i, l, v);
      case 22:
        return Ko(i, l, v);
    }
    throw Error(h(156, l.tag));
  };
  function Zh(i, l) {
    return W(i, l);
  }
  function jx(i, l, v, k) {
    this.tag = i, this.key = v, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = k, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Ci(i, l, v, k) {
    return new jx(i, l, v, k);
  }
  function Qh(i) {
    return i = i.prototype, !(!i || !i.isReactComponent);
  }
  function Bx(i) {
    if (typeof i == "function")
      return Qh(i) ? 1 : 0;
    if (i != null) {
      if (i = i.$$typeof, i === ht)
        return 11;
      if (i === Tt)
        return 14;
    }
    return 2;
  }
  function vo(i, l) {
    var v = i.alternate;
    return v === null ? (v = Ci(i.tag, l, i.key, i.mode), v.elementType = i.elementType, v.type = i.type, v.stateNode = i.stateNode, v.alternate = i, i.alternate = v) : (v.pendingProps = l, v.type = i.type, v.flags = 0, v.subtreeFlags = 0, v.deletions = null), v.flags = i.flags & 14680064, v.childLanes = i.childLanes, v.lanes = i.lanes, v.child = i.child, v.memoizedProps = i.memoizedProps, v.memoizedState = i.memoizedState, v.updateQueue = i.updateQueue, l = i.dependencies, v.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }, v.sibling = i.sibling, v.index = i.index, v.ref = i.ref, v;
  }
  function $d(i, l, v, k, D, z) {
    var $ = 2;
    if (k = i, typeof i == "function")
      Qh(i) && ($ = 1);
    else if (typeof i == "string")
      $ = 5;
    else
      e:
        switch (i) {
          case Me:
            return ol(v.children, D, z, l);
          case Je:
            $ = 8, D |= 8;
            break;
          case Ve:
            return i = Ci(12, v, l, D | 2), i.elementType = Ve, i.lanes = z, i;
          case Ke:
            return i = Ci(13, v, l, D), i.elementType = Ke, i.lanes = z, i;
          case Ze:
            return i = Ci(19, v, l, D), i.elementType = Ze, i.lanes = z, i;
          case Jt:
            return mc(v, D, z, l);
          default:
            if (typeof i == "object" && i !== null)
              switch (i.$$typeof) {
                case Xe:
                  $ = 10;
                  break e;
                case it:
                  $ = 9;
                  break e;
                case ht:
                  $ = 11;
                  break e;
                case Tt:
                  $ = 14;
                  break e;
                case It:
                  $ = 16, k = null;
                  break e;
              }
            throw Error(h(130, i == null ? i : typeof i, ""));
        }
    return l = Ci($, v, l, D), l.elementType = i, l.type = k, l.lanes = z, l;
  }
  function ol(i, l, v, k) {
    return i = Ci(7, i, k, l), i.lanes = v, i;
  }
  function mc(i, l, v, k) {
    return i = Ci(22, i, k, l), i.elementType = Jt, i.lanes = v, i.stateNode = { isHidden: !1 }, i;
  }
  function vc(i, l, v) {
    return i = Ci(6, i, null, l), i.lanes = v, i;
  }
  function ll(i, l, v) {
    return l = Ci(4, i.children !== null ? i.children : [], i.key, l), l.lanes = v, l.stateNode = { containerInfo: i.containerInfo, pendingChildren: null, implementation: i.implementation }, l;
  }
  function Wx(i, l, v, k, D) {
    this.tag = l, this.containerInfo = i, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = fe(0), this.expirationTimes = fe(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = fe(0), this.identifierPrefix = k, this.onRecoverableError = D, this.mutableSourceEagerHydrationData = null;
  }
  function qd(i, l, v, k, D, z, $, ie, de) {
    return i = new Wx(i, l, v, ie, de), l === 1 ? (l = 1, z === !0 && (l |= 8)) : l = 0, z = Ci(3, null, null, l), i.current = z, z.stateNode = i, z.memoizedState = { element: k, isDehydrated: v, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Ch(z), i;
  }
  function Im(i, l, v) {
    var k = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: me, key: k == null ? null : "" + k, children: i, containerInfo: l, implementation: v };
  }
  function Kh(i) {
    if (!i)
      return $i;
    i = i._reactInternals;
    e: {
      if (qt(i) !== i || i.tag !== 1)
        throw Error(h(170));
      var l = i;
      do {
        switch (l.tag) {
          case 3:
            l = l.stateNode.context;
            break e;
          case 1:
            if (qn(l.type)) {
              l = l.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        l = l.return;
      } while (l !== null);
      throw Error(h(171));
    }
    if (i.tag === 1) {
      var v = i.type;
      if (qn(v))
        return Qu(i, v, l);
    }
    return l;
  }
  function Fm(i, l, v, k, D, z, $, ie, de) {
    return i = qd(v, k, !0, i, D, z, $, ie, de), i.context = Kh(null), v = i.current, k = ha(), D = Sr(v), z = Cs(k, D), z.callback = l ?? null, oo(v, z, D), i.current.lanes = D, ke(i, D, k), ga(i, k), i;
  }
  function yc(i, l, v, k) {
    var D = l.current, z = ha(), $ = Sr(D);
    return v = Kh(v), l.context === null ? l.context = v : l.pendingContext = v, l = Cs(z, $), l.payload = { element: i }, k = k === void 0 ? null : k, k !== null && (l.callback = k), i = oo(D, l, $), i !== null && (pa(i, D, $, z), hd(i, D, $)), $;
  }
  function Zd(i) {
    if (i = i.current, !i.child)
      return null;
    switch (i.child.tag) {
      case 5:
        return i.child.stateNode;
      default:
        return i.child.stateNode;
    }
  }
  function Ym(i, l) {
    if (i = i.memoizedState, i !== null && i.dehydrated !== null) {
      var v = i.retryLane;
      i.retryLane = v !== 0 && v < l ? v : l;
    }
  }
  function Jh(i, l) {
    Ym(i, l), (i = i.alternate) && Ym(i, l);
  }
  function Hm() {
    return null;
  }
  var ep = typeof reportError == "function" ? reportError : function(i) {
    console.error(i);
  };
  function Qd(i) {
    this._internalRoot = i;
  }
  Os.prototype.render = Qd.prototype.render = function(i) {
    var l = this._internalRoot;
    if (l === null)
      throw Error(h(409));
    yc(i, l, null, null);
  }, Os.prototype.unmount = Qd.prototype.unmount = function() {
    var i = this._internalRoot;
    if (i !== null) {
      this._internalRoot = null;
      var l = i.containerInfo;
      mo(function() {
        yc(null, i, null, null);
      }), l[ws] = null;
    }
  };
  function Os(i) {
    this._internalRoot = i;
  }
  Os.prototype.unstable_scheduleHydration = function(i) {
    if (i) {
      var l = On();
      i = { blockedOn: null, target: i, priority: l };
      for (var v = 0; v < wn.length && l !== 0 && l < wn[v].priority; v++)
        ;
      wn.splice(v, 0, i), v === 0 && Tg(i);
    }
  };
  function tp(i) {
    return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11);
  }
  function Kd(i) {
    return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11 && (i.nodeType !== 8 || i.nodeValue !== " react-mount-point-unstable "));
  }
  function jm() {
  }
  function Ux(i, l, v, k, D) {
    if (D) {
      if (typeof k == "function") {
        var z = k;
        k = function() {
          var Re = Zd($);
          z.call(Re);
        };
      }
      var $ = Fm(l, k, i, 0, null, !1, !1, "", jm);
      return i._reactRootContainer = $, i[ws] = $.current, Hl(i.nodeType === 8 ? i.parentNode : i), mo(), $;
    }
    for (; D = i.lastChild; )
      i.removeChild(D);
    if (typeof k == "function") {
      var ie = k;
      k = function() {
        var Re = Zd(de);
        ie.call(Re);
      };
    }
    var de = qd(i, 0, !1, null, null, !1, !1, "", jm);
    return i._reactRootContainer = de, i[ws] = de.current, Hl(i.nodeType === 8 ? i.parentNode : i), mo(function() {
      yc(l, de, v, k);
    }), de;
  }
  function Jd(i, l, v, k, D) {
    var z = v._reactRootContainer;
    if (z) {
      var $ = z;
      if (typeof D == "function") {
        var ie = D;
        D = function() {
          var de = Zd($);
          ie.call(de);
        };
      }
      yc(l, $, i, D);
    } else
      $ = Ux(v, l, i, D, k);
    return Zd($);
  }
  Qt = function(i) {
    switch (i.tag) {
      case 3:
        var l = i.stateNode;
        if (l.current.memoizedState.isDehydrated) {
          var v = O(l.pendingLanes);
          v !== 0 && (Le(l, v | 1), ga(l, o()), !(sn & 6) && (au = o() + 500, Na()));
        }
        break;
      case 13:
        mo(function() {
          var k = ks(i, 1);
          if (k !== null) {
            var D = ha();
            pa(k, i, 1, D);
          }
        }), Jh(i, 1);
    }
  }, Kt = function(i) {
    if (i.tag === 13) {
      var l = ks(i, 134217728);
      if (l !== null) {
        var v = ha();
        pa(l, i, 134217728, v);
      }
      Jh(i, 134217728);
    }
  }, xt = function(i) {
    if (i.tag === 13) {
      var l = Sr(i), v = ks(i, l);
      if (v !== null) {
        var k = ha();
        pa(v, i, l, k);
      }
      Jh(i, l);
    }
  }, On = function() {
    return Ie;
  }, zn = function(i, l) {
    var v = Ie;
    try {
      return Ie = i, l();
    } finally {
      Ie = v;
    }
  }, yr = function(i, l, v) {
    switch (l) {
      case "input":
        if (Mr(i, v), l = v.name, v.type === "radio" && l != null) {
          for (v = i; v.parentNode; )
            v = v.parentNode;
          for (v = v.querySelectorAll("input[name=" + JSON.stringify("" + l) + '][type="radio"]'), l = 0; l < v.length; l++) {
            var k = v[l];
            if (k !== i && k.form === i.form) {
              var D = _t(k);
              if (!D)
                throw Error(h(90));
              qe(k), Mr(k, D);
            }
          }
        }
        break;
      case "textarea":
        fi(i, v);
        break;
      case "select":
        l = v.value, l != null && di(i, !!v.multiple, l, !1);
    }
  }, Vs = ou, Ol = mo;
  var Xx = { usingClientEntryPoint: !1, Events: [Zu, jl, _t, ds, fs, ou] }, uu = { findFiberByHostInstance: pi, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, Vx = { bundleType: uu.bundleType, version: uu.version, rendererPackageName: uu.rendererPackageName, rendererConfig: uu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Ee.ReactCurrentDispatcher, findHostInstanceByFiber: function(i) {
    return i = or(i), i === null ? null : i.stateNode;
  }, findFiberByHostInstance: uu.findFiberByHostInstance || Hm, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var ef = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!ef.isDisabled && ef.supportsFiber)
      try {
        E = ef.inject(Vx), L = ef;
      } catch {
      }
  }
  return Oi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Xx, Oi.createPortal = function(i, l) {
    var v = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!tp(l))
      throw Error(h(200));
    return Im(i, l, null, v);
  }, Oi.createRoot = function(i, l) {
    if (!tp(i))
      throw Error(h(299));
    var v = !1, k = "", D = ep;
    return l != null && (l.unstable_strictMode === !0 && (v = !0), l.identifierPrefix !== void 0 && (k = l.identifierPrefix), l.onRecoverableError !== void 0 && (D = l.onRecoverableError)), l = qd(i, 1, !1, null, null, v, !1, k, D), i[ws] = l.current, Hl(i.nodeType === 8 ? i.parentNode : i), new Qd(l);
  }, Oi.findDOMNode = function(i) {
    if (i == null)
      return null;
    if (i.nodeType === 1)
      return i;
    var l = i._reactInternals;
    if (l === void 0)
      throw typeof i.render == "function" ? Error(h(188)) : (i = Object.keys(i).join(","), Error(h(268, i)));
    return i = or(l), i = i === null ? null : i.stateNode, i;
  }, Oi.flushSync = function(i) {
    return mo(i);
  }, Oi.hydrate = function(i, l, v) {
    if (!Kd(l))
      throw Error(h(200));
    return Jd(null, i, l, !0, v);
  }, Oi.hydrateRoot = function(i, l, v) {
    if (!tp(i))
      throw Error(h(405));
    var k = v != null && v.hydratedSources || null, D = !1, z = "", $ = ep;
    if (v != null && (v.unstable_strictMode === !0 && (D = !0), v.identifierPrefix !== void 0 && (z = v.identifierPrefix), v.onRecoverableError !== void 0 && ($ = v.onRecoverableError)), l = Fm(l, null, i, 1, v ?? null, D, !1, z, $), i[ws] = l.current, Hl(i), k)
      for (i = 0; i < k.length; i++)
        v = k[i], D = v._getVersion, D = D(v._source), l.mutableSourceEagerHydrationData == null ? l.mutableSourceEagerHydrationData = [v, D] : l.mutableSourceEagerHydrationData.push(
          v,
          D
        );
    return new Os(l);
  }, Oi.render = function(i, l, v) {
    if (!Kd(l))
      throw Error(h(200));
    return Jd(null, i, l, !1, v);
  }, Oi.unmountComponentAtNode = function(i) {
    if (!Kd(i))
      throw Error(h(40));
    return i._reactRootContainer ? (mo(function() {
      Jd(null, null, i, !1, function() {
        i._reactRootContainer = null, i[ws] = null;
      });
    }), !0) : !1;
  }, Oi.unstable_batchedUpdates = ou, Oi.unstable_renderSubtreeIntoContainer = function(i, l, v, k) {
    if (!Kd(v))
      throw Error(h(200));
    if (i == null || i._reactInternals === void 0)
      throw Error(h(38));
    return Jd(i, l, v, !1, k);
  }, Oi.version = "18.2.0-next-9e3b772b8-20220608", Oi;
}
var Di = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var DA;
function WY() {
  return DA || (DA = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var s = va, u = SR(), h = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, m = !1;
    function w(e) {
      m = e;
    }
    function T(e) {
      if (!m) {
        for (var r = arguments.length, c = new Array(r > 1 ? r - 1 : 0), g = 1; g < r; g++)
          c[g - 1] = arguments[g];
        F("warn", e, c);
      }
    }
    function A(e) {
      if (!m) {
        for (var r = arguments.length, c = new Array(r > 1 ? r - 1 : 0), g = 1; g < r; g++)
          c[g - 1] = arguments[g];
        F("error", e, c);
      }
    }
    function F(e, r, c) {
      {
        var g = h.ReactDebugCurrentFrame, x = g.getStackAddendum();
        x !== "" && (r += "%s", c = c.concat([x]));
        var R = c.map(function(_) {
          return String(_);
        });
        R.unshift("Warning: " + r), Function.prototype.apply.call(console[e], console, R);
      }
    }
    var H = 0, j = 1, V = 2, q = 3, te = 4, ae = 5, se = 6, ue = 7, Ce = 8, Pe = 9, K = 10, we = 11, Ee = 12, re = 13, me = 14, Me = 15, Je = 16, Ve = 17, Xe = 18, it = 19, ht = 21, Ke = 22, Ze = 23, Tt = 24, It = 25, Jt = !0, We = !1, pt = !1, ye = !1, je = !1, Qe = !0, kt = !1, mt = !1, Pt = !0, st = !0, Nt = !0, Et = /* @__PURE__ */ new Set(), Ht = {}, Wt = {};
    function mn(e, r) {
      qe(e, r), qe(e + "Capture", r);
    }
    function qe(e, r) {
      Ht[e] && A("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", e), Ht[e] = r;
      {
        var c = e.toLowerCase();
        Wt[c] = e, e === "onDoubleClick" && (Wt.ondblclick = e);
      }
      for (var g = 0; g < r.length; g++)
        Et.add(r[g]);
    }
    var pn = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", jn = Object.prototype.hasOwnProperty;
    function ir(e) {
      {
        var r = typeof Symbol == "function" && Symbol.toStringTag, c = r && e[Symbol.toStringTag] || e.constructor.name || "Object";
        return c;
      }
    }
    function Dr(e) {
      try {
        return Mr(e), !1;
      } catch {
        return !0;
      }
    }
    function Mr(e) {
      return "" + e;
    }
    function ta(e, r) {
      if (Dr(e))
        return A("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", r, ir(e)), Mr(e);
    }
    function Za(e) {
      if (Dr(e))
        return A("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ir(e)), Mr(e);
    }
    function _i(e, r) {
      if (Dr(e))
        return A("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", r, ir(e)), Mr(e);
    }
    function di(e, r) {
      if (Dr(e))
        return A("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", r, ir(e)), Mr(e);
    }
    function Qa(e) {
      if (Dr(e))
        return A("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", ir(e)), Mr(e);
    }
    function ya(e) {
      if (Dr(e))
        return A("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", ir(e)), Mr(e);
    }
    var fi = 0, xa = 1, na = 2, sr = 3, ra = 4, Pi = 5, Ka = 6, et = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Lt = et + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", nn = new RegExp("^[" + et + "][" + Lt + "]*$"), bn = {}, Bn = {};
    function vr(e) {
      return jn.call(Bn, e) ? !0 : jn.call(bn, e) ? !1 : nn.test(e) ? (Bn[e] = !0, !0) : (bn[e] = !0, A("Invalid attribute name: `%s`", e), !1);
    }
    function $n(e, r, c) {
      return r !== null ? r.type === fi : c ? !1 : e.length > 2 && (e[0] === "o" || e[0] === "O") && (e[1] === "n" || e[1] === "N");
    }
    function aa(e, r, c, g) {
      if (c !== null && c.type === fi)
        return !1;
      switch (typeof r) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (g)
            return !1;
          if (c !== null)
            return !c.acceptsBooleans;
          var x = e.toLowerCase().slice(0, 5);
          return x !== "data-" && x !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Ln(e, r, c, g) {
      if (r === null || typeof r > "u" || aa(e, r, c, g))
        return !0;
      if (g)
        return !1;
      if (c !== null)
        switch (c.type) {
          case sr:
            return !r;
          case ra:
            return r === !1;
          case Pi:
            return isNaN(r);
          case Ka:
            return isNaN(r) || r < 1;
        }
      return !1;
    }
    function yr(e) {
      return Cn.hasOwnProperty(e) ? Cn[e] : null;
    }
    function kn(e, r, c, g, x, R, _) {
      this.acceptsBooleans = r === na || r === sr || r === ra, this.attributeName = g, this.attributeNamespace = x, this.mustUseProperty = c, this.propertyName = e, this.type = r, this.sanitizeURL = R, this.removeEmptyString = _;
    }
    var Cn = {}, cs = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    cs.forEach(function(e) {
      Cn[e] = new kn(
        e,
        fi,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
      var r = e[0], c = e[1];
      Cn[r] = new kn(
        r,
        xa,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
      Cn[e] = new kn(
        e,
        na,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
      Cn[e] = new kn(
        e,
        na,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(e) {
      Cn[e] = new kn(
        e,
        sr,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      Cn[e] = new kn(
        e,
        sr,
        !0,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      Cn[e] = new kn(
        e,
        ra,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      Cn[e] = new kn(
        e,
        Ka,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(e) {
      Cn[e] = new kn(
        e,
        Pi,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ds = /[\-\:]([a-z])/g, fs = function(e) {
      return e[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var r = e.replace(ds, fs);
      Cn[r] = new kn(
        r,
        xa,
        !1,
        // mustUseProperty
        e,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var r = e.replace(ds, fs);
      Cn[r] = new kn(
        r,
        xa,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var r = e.replace(ds, fs);
      Cn[r] = new kn(
        r,
        xa,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(e) {
      Cn[e] = new kn(
        e,
        xa,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Vs = "xlinkHref";
    Cn[Vs] = new kn(
      "xlinkHref",
      xa,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(e) {
      Cn[e] = new kn(
        e,
        xa,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Ol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, hs = !1;
    function Gs(e) {
      !hs && Ol.test(e) && (hs = !0, A("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(e)));
    }
    function ps(e, r, c, g) {
      if (g.mustUseProperty) {
        var x = g.propertyName;
        return e[x];
      } else {
        ta(c, r), g.sanitizeURL && Gs("" + c);
        var R = g.attributeName, _ = null;
        if (g.type === ra) {
          if (e.hasAttribute(R)) {
            var Y = e.getAttribute(R);
            return Y === "" ? !0 : Ln(r, c, g, !1) ? Y : Y === "" + c ? c : Y;
          }
        } else if (e.hasAttribute(R)) {
          if (Ln(r, c, g, !1))
            return e.getAttribute(R);
          if (g.type === sr)
            return c;
          _ = e.getAttribute(R);
        }
        return Ln(r, c, g, !1) ? _ === null ? c : _ : _ === "" + c ? c : _;
      }
    }
    function $s(e, r, c, g) {
      {
        if (!vr(r))
          return;
        if (!e.hasAttribute(r))
          return c === void 0 ? void 0 : null;
        var x = e.getAttribute(r);
        return ta(c, r), x === "" + c ? c : x;
      }
    }
    function Ma(e, r, c, g) {
      var x = yr(r);
      if (!$n(r, x, g)) {
        if (Ln(r, c, x, g) && (c = null), g || x === null) {
          if (vr(r)) {
            var R = r;
            c === null ? e.removeAttribute(R) : (ta(c, r), e.setAttribute(R, "" + c));
          }
          return;
        }
        var _ = x.mustUseProperty;
        if (_) {
          var Y = x.propertyName;
          if (c === null) {
            var U = x.type;
            e[Y] = U === sr ? !1 : "";
          } else
            e[Y] = c;
          return;
        }
        var J = x.attributeName, ne = x.attributeNamespace;
        if (c === null)
          e.removeAttribute(J);
        else {
          var ge = x.type, he;
          ge === sr || ge === ra && c === !0 ? he = "" : (ta(c, J), he = "" + c, x.sanitizeURL && Gs(he.toString())), ne ? e.setAttributeNS(ne, J, he) : e.setAttribute(J, he);
        }
      }
    }
    var Ni = Symbol.for("react.element"), jr = Symbol.for("react.portal"), ba = Symbol.for("react.fragment"), ia = Symbol.for("react.strict_mode"), le = Symbol.for("react.profiler"), Ye = Symbol.for("react.provider"), tt = Symbol.for("react.context"), Dt = Symbol.for("react.forward_ref"), qt = Symbol.for("react.suspense"), cn = Symbol.for("react.suspense_list"), Zt = Symbol.for("react.memo"), Mt = Symbol.for("react.lazy"), or = Symbol.for("react.scope"), Yn = Symbol.for("react.debug_trace_mode"), W = Symbol.for("react.offscreen"), t = Symbol.for("react.legacy_hidden"), n = Symbol.for("react.cache"), a = Symbol.for("react.tracing_marker"), o = Symbol.iterator, d = "@@iterator";
    function f(e) {
      if (e === null || typeof e != "object")
        return null;
      var r = o && e[o] || e[d];
      return typeof r == "function" ? r : null;
    }
    var p = Object.assign, y = 0, S, C, E, L, M, P, I;
    function B() {
    }
    B.__reactDisabledLog = !0;
    function G() {
      {
        if (y === 0) {
          S = console.log, C = console.info, E = console.warn, L = console.error, M = console.group, P = console.groupCollapsed, I = console.groupEnd;
          var e = {
            configurable: !0,
            enumerable: !0,
            value: B,
            writable: !0
          };
          Object.defineProperties(console, {
            info: e,
            log: e,
            warn: e,
            error: e,
            group: e,
            groupCollapsed: e,
            groupEnd: e
          });
        }
        y++;
      }
    }
    function Z() {
      {
        if (y--, y === 0) {
          var e = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: p({}, e, {
              value: S
            }),
            info: p({}, e, {
              value: C
            }),
            warn: p({}, e, {
              value: E
            }),
            error: p({}, e, {
              value: L
            }),
            group: p({}, e, {
              value: M
            }),
            groupCollapsed: p({}, e, {
              value: P
            }),
            groupEnd: p({}, e, {
              value: I
            })
          });
        }
        y < 0 && A("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var b = h.ReactCurrentDispatcher, O;
    function N(e, r, c) {
      {
        if (O === void 0)
          try {
            throw Error();
          } catch (x) {
            var g = x.stack.trim().match(/\n( *(at )?)/);
            O = g && g[1] || "";
          }
        return `
` + O + e;
      }
    }
    var X = !1, Q;
    {
      var ee = typeof WeakMap == "function" ? WeakMap : Map;
      Q = new ee();
    }
    function oe(e, r) {
      if (!e || X)
        return "";
      {
        var c = Q.get(e);
        if (c !== void 0)
          return c;
      }
      var g;
      X = !0;
      var x = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var R;
      R = b.current, b.current = null, G();
      try {
        if (r) {
          var _ = function() {
            throw Error();
          };
          if (Object.defineProperty(_.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(_, []);
            } catch (Ae) {
              g = Ae;
            }
            Reflect.construct(e, [], _);
          } else {
            try {
              _.call();
            } catch (Ae) {
              g = Ae;
            }
            e.call(_.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ae) {
            g = Ae;
          }
          e();
        }
      } catch (Ae) {
        if (Ae && g && typeof Ae.stack == "string") {
          for (var Y = Ae.stack.split(`
`), U = g.stack.split(`
`), J = Y.length - 1, ne = U.length - 1; J >= 1 && ne >= 0 && Y[J] !== U[ne]; )
            ne--;
          for (; J >= 1 && ne >= 0; J--, ne--)
            if (Y[J] !== U[ne]) {
              if (J !== 1 || ne !== 1)
                do
                  if (J--, ne--, ne < 0 || Y[J] !== U[ne]) {
                    var ge = `
` + Y[J].replace(" at new ", " at ");
                    return e.displayName && ge.includes("<anonymous>") && (ge = ge.replace("<anonymous>", e.displayName)), typeof e == "function" && Q.set(e, ge), ge;
                  }
                while (J >= 1 && ne >= 0);
              break;
            }
        }
      } finally {
        X = !1, b.current = R, Z(), Error.prepareStackTrace = x;
      }
      var he = e ? e.displayName || e.name : "", Te = he ? N(he) : "";
      return typeof e == "function" && Q.set(e, Te), Te;
    }
    function fe(e, r, c) {
      return oe(e, !0);
    }
    function ke(e, r, c) {
      return oe(e, !1);
    }
    function _e(e) {
      var r = e.prototype;
      return !!(r && r.isReactComponent);
    }
    function Le(e, r, c) {
      if (e == null)
        return "";
      if (typeof e == "function")
        return oe(e, _e(e));
      if (typeof e == "string")
        return N(e);
      switch (e) {
        case qt:
          return N("Suspense");
        case cn:
          return N("SuspenseList");
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case Dt:
            return ke(e.render);
          case Zt:
            return Le(e.type, r, c);
          case Mt: {
            var g = e, x = g._payload, R = g._init;
            try {
              return Le(R(x), r, c);
            } catch {
            }
          }
        }
      return "";
    }
    function Ie(e) {
      switch (e._debugOwner && e._debugOwner.type, e._debugSource, e.tag) {
        case ae:
          return N(e.type);
        case Je:
          return N("Lazy");
        case re:
          return N("Suspense");
        case it:
          return N("SuspenseList");
        case H:
        case V:
        case Me:
          return ke(e.type);
        case we:
          return ke(e.type.render);
        case j:
          return fe(e.type);
        default:
          return "";
      }
    }
    function at(e) {
      try {
        var r = "", c = e;
        do
          r += Ie(c), c = c.return;
        while (c);
        return r;
      } catch (g) {
        return `
Error generating stack: ` + g.message + `
` + g.stack;
      }
    }
    function Qt(e, r, c) {
      var g = e.displayName;
      if (g)
        return g;
      var x = r.displayName || r.name || "";
      return x !== "" ? c + "(" + x + ")" : c;
    }
    function Kt(e) {
      return e.displayName || "Context";
    }
    function xt(e) {
      if (e == null)
        return null;
      if (typeof e.tag == "number" && A("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof e == "function")
        return e.displayName || e.name || null;
      if (typeof e == "string")
        return e;
      switch (e) {
        case ba:
          return "Fragment";
        case jr:
          return "Portal";
        case le:
          return "Profiler";
        case ia:
          return "StrictMode";
        case qt:
          return "Suspense";
        case cn:
          return "SuspenseList";
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case tt:
            var r = e;
            return Kt(r) + ".Consumer";
          case Ye:
            var c = e;
            return Kt(c._context) + ".Provider";
          case Dt:
            return Qt(e, e.render, "ForwardRef");
          case Zt:
            var g = e.displayName || null;
            return g !== null ? g : xt(e.type) || "Memo";
          case Mt: {
            var x = e, R = x._payload, _ = x._init;
            try {
              return xt(_(R));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function On(e, r, c) {
      var g = r.displayName || r.name || "";
      return e.displayName || (g !== "" ? c + "(" + g + ")" : c);
    }
    function zn(e) {
      return e.displayName || "Context";
    }
    function vt(e) {
      var r = e.tag, c = e.type;
      switch (r) {
        case Tt:
          return "Cache";
        case Pe:
          var g = c;
          return zn(g) + ".Consumer";
        case K:
          var x = c;
          return zn(x._context) + ".Provider";
        case Xe:
          return "DehydratedFragment";
        case we:
          return On(c, c.render, "ForwardRef");
        case ue:
          return "Fragment";
        case ae:
          return c;
        case te:
          return "Portal";
        case q:
          return "Root";
        case se:
          return "Text";
        case Je:
          return xt(c);
        case Ce:
          return c === ia ? "StrictMode" : "Mode";
        case Ke:
          return "Offscreen";
        case Ee:
          return "Profiler";
        case ht:
          return "Scope";
        case re:
          return "Suspense";
        case it:
          return "SuspenseList";
        case It:
          return "TracingMarker";
        case j:
        case H:
        case Ve:
        case V:
        case me:
        case Me:
          if (typeof c == "function")
            return c.displayName || c.name || null;
          if (typeof c == "string")
            return c;
          break;
      }
      return null;
    }
    var Br = h.ReactDebugCurrentFrame, Dn = null, sa = !1;
    function oa() {
      {
        if (Dn === null)
          return null;
        var e = Dn._debugOwner;
        if (e !== null && typeof e < "u")
          return vt(e);
      }
      return null;
    }
    function xr() {
      return Dn === null ? "" : at(Dn);
    }
    function ln() {
      Br.getCurrentStack = null, Dn = null, sa = !1;
    }
    function wn(e) {
      Br.getCurrentStack = e === null ? null : xr, Dn = e, sa = !1;
    }
    function cx() {
      return Dn;
    }
    function zi(e) {
      sa = e;
    }
    function la(e) {
      return "" + e;
    }
    function qs(e) {
      switch (typeof e) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return e;
        case "object":
          return ya(e), e;
        default:
          return "";
      }
    }
    var Tg = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Dl(e, r) {
      Tg[r.type] || r.onChange || r.onInput || r.readOnly || r.disabled || r.value == null || A("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), r.onChange || r.readOnly || r.disabled || r.checked == null || A("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Wf(e) {
      var r = e.type, c = e.nodeName;
      return c && c.toLowerCase() === "input" && (r === "checkbox" || r === "radio");
    }
    function Ag(e) {
      return e._valueTracker;
    }
    function _u(e) {
      e._valueTracker = null;
    }
    function Pu(e) {
      var r = "";
      return e && (Wf(e) ? r = e.checked ? "true" : "false" : r = e.value), r;
    }
    function Ml(e) {
      var r = Wf(e) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(e.constructor.prototype, r);
      ya(e[r]);
      var g = "" + e[r];
      if (!(e.hasOwnProperty(r) || typeof c > "u" || typeof c.get != "function" || typeof c.set != "function")) {
        var x = c.get, R = c.set;
        Object.defineProperty(e, r, {
          configurable: !0,
          get: function() {
            return x.call(this);
          },
          set: function(Y) {
            ya(Y), g = "" + Y, R.call(this, Y);
          }
        }), Object.defineProperty(e, r, {
          enumerable: c.enumerable
        });
        var _ = {
          getValue: function() {
            return g;
          },
          setValue: function(Y) {
            ya(Y), g = "" + Y;
          },
          stopTracking: function() {
            _u(e), delete e[r];
          }
        };
        return _;
      }
    }
    function Po(e) {
      Ag(e) || (e._valueTracker = Ml(e));
    }
    function Eg(e) {
      if (!e)
        return !1;
      var r = Ag(e);
      if (!r)
        return !0;
      var c = r.getValue(), g = Pu(e);
      return g !== c ? (r.setValue(g), !0) : !1;
    }
    function Wc(e) {
      if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u")
        return null;
      try {
        return e.activeElement || e.body;
      } catch {
        return e.body;
      }
    }
    var Uc = !1, Nu = !1, Xc = !1, Uf = !1;
    function gs(e) {
      var r = e.type === "checkbox" || e.type === "radio";
      return r ? e.checked != null : e.value != null;
    }
    function zu(e, r) {
      var c = e, g = r.checked, x = p({}, r, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: g ?? c._wrapperState.initialChecked
      });
      return x;
    }
    function Iu(e, r) {
      Dl("input", r), r.checked !== void 0 && r.defaultChecked !== void 0 && !Nu && (A("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", oa() || "A component", r.type), Nu = !0), r.value !== void 0 && r.defaultValue !== void 0 && !Uc && (A("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", oa() || "A component", r.type), Uc = !0);
      var c = e, g = r.defaultValue == null ? "" : r.defaultValue;
      c._wrapperState = {
        initialChecked: r.checked != null ? r.checked : r.defaultChecked,
        initialValue: qs(r.value != null ? r.value : g),
        controlled: gs(r)
      };
    }
    function Xf(e, r) {
      var c = e, g = r.checked;
      g != null && Ma(c, "checked", g, !1);
    }
    function _l(e, r) {
      var c = e;
      {
        var g = gs(r);
        !c._wrapperState.controlled && g && !Uf && (A("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Uf = !0), c._wrapperState.controlled && !g && !Xc && (A("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Xc = !0);
      }
      Xf(e, r);
      var x = qs(r.value), R = r.type;
      if (x != null)
        R === "number" ? (x === 0 && c.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        c.value != x) && (c.value = la(x)) : c.value !== la(x) && (c.value = la(x));
      else if (R === "submit" || R === "reset") {
        c.removeAttribute("value");
        return;
      }
      r.hasOwnProperty("value") ? Zs(c, r.type, x) : r.hasOwnProperty("defaultValue") && Zs(c, r.type, qs(r.defaultValue)), r.checked == null && r.defaultChecked != null && (c.defaultChecked = !!r.defaultChecked);
    }
    function Fu(e, r, c) {
      var g = e;
      if (r.hasOwnProperty("value") || r.hasOwnProperty("defaultValue")) {
        var x = r.type, R = x === "submit" || x === "reset";
        if (R && (r.value === void 0 || r.value === null))
          return;
        var _ = la(g._wrapperState.initialValue);
        c || _ !== g.value && (g.value = _), g.defaultValue = _;
      }
      var Y = g.name;
      Y !== "" && (g.name = ""), g.defaultChecked = !g.defaultChecked, g.defaultChecked = !!g._wrapperState.initialChecked, Y !== "" && (g.name = Y);
    }
    function Rg(e, r) {
      var c = e;
      _l(c, r), Ja(c, r);
    }
    function Ja(e, r) {
      var c = r.name;
      if (r.type === "radio" && c != null) {
        for (var g = e; g.parentNode; )
          g = g.parentNode;
        ta(c, "name");
        for (var x = g.querySelectorAll("input[name=" + JSON.stringify("" + c) + '][type="radio"]'), R = 0; R < x.length; R++) {
          var _ = x[R];
          if (!(_ === e || _.form !== e.form)) {
            var Y = av(_);
            if (!Y)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            Eg(_), _l(_, Y);
          }
        }
      }
    }
    function Zs(e, r, c) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (r !== "number" || Wc(e.ownerDocument) !== e) && (c == null ? e.defaultValue = la(e._wrapperState.initialValue) : e.defaultValue !== la(c) && (e.defaultValue = la(c)));
    }
    var Vc = !1, Pl = !1, Lg = !1;
    function Gc(e, r) {
      r.value == null && (typeof r.children == "object" && r.children !== null ? s.Children.forEach(r.children, function(c) {
        c != null && (typeof c == "string" || typeof c == "number" || Pl || (Pl = !0, A("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : r.dangerouslySetInnerHTML != null && (Lg || (Lg = !0, A("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), r.selected != null && !Vc && (A("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Vc = !0);
    }
    function Vf(e, r) {
      r.value != null && e.setAttribute("value", la(qs(r.value)));
    }
    var Yu = Array.isArray;
    function _r(e) {
      return Yu(e);
    }
    var $c;
    $c = !1;
    function Og() {
      var e = oa();
      return e ? `

Check the render method of \`` + e + "`." : "";
    }
    var Dg = ["value", "defaultValue"];
    function dx(e) {
      {
        Dl("select", e);
        for (var r = 0; r < Dg.length; r++) {
          var c = Dg[r];
          if (e[c] != null) {
            var g = _r(e[c]);
            e.multiple && !g ? A("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", c, Og()) : !e.multiple && g && A("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", c, Og());
          }
        }
      }
    }
    function Qs(e, r, c, g) {
      var x = e.options;
      if (r) {
        for (var R = c, _ = {}, Y = 0; Y < R.length; Y++)
          _["$" + R[Y]] = !0;
        for (var U = 0; U < x.length; U++) {
          var J = _.hasOwnProperty("$" + x[U].value);
          x[U].selected !== J && (x[U].selected = J), J && g && (x[U].defaultSelected = !0);
        }
      } else {
        for (var ne = la(qs(c)), ge = null, he = 0; he < x.length; he++) {
          if (x[he].value === ne) {
            x[he].selected = !0, g && (x[he].defaultSelected = !0);
            return;
          }
          ge === null && !x[he].disabled && (ge = x[he]);
        }
        ge !== null && (ge.selected = !0);
      }
    }
    function Gf(e, r) {
      return p({}, r, {
        value: void 0
      });
    }
    function Mg(e, r) {
      var c = e;
      dx(r), c._wrapperState = {
        wasMultiple: !!r.multiple
      }, r.value !== void 0 && r.defaultValue !== void 0 && !$c && (A("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), $c = !0);
    }
    function fx(e, r) {
      var c = e;
      c.multiple = !!r.multiple;
      var g = r.value;
      g != null ? Qs(c, !!r.multiple, g, !1) : r.defaultValue != null && Qs(c, !!r.multiple, r.defaultValue, !0);
    }
    function hx(e, r) {
      var c = e, g = c._wrapperState.wasMultiple;
      c._wrapperState.wasMultiple = !!r.multiple;
      var x = r.value;
      x != null ? Qs(c, !!r.multiple, x, !1) : g !== !!r.multiple && (r.defaultValue != null ? Qs(c, !!r.multiple, r.defaultValue, !0) : Qs(c, !!r.multiple, r.multiple ? [] : "", !1));
    }
    function px(e, r) {
      var c = e, g = r.value;
      g != null && Qs(c, !!r.multiple, g, !1);
    }
    var $f = !1;
    function qf(e, r) {
      var c = e;
      if (r.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var g = p({}, r, {
        value: void 0,
        defaultValue: void 0,
        children: la(c._wrapperState.initialValue)
      });
      return g;
    }
    function _g(e, r) {
      var c = e;
      Dl("textarea", r), r.value !== void 0 && r.defaultValue !== void 0 && !$f && (A("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", oa() || "A component"), $f = !0);
      var g = r.value;
      if (g == null) {
        var x = r.children, R = r.defaultValue;
        if (x != null) {
          A("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (R != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (_r(x)) {
              if (x.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              x = x[0];
            }
            R = x;
          }
        }
        R == null && (R = ""), g = R;
      }
      c._wrapperState = {
        initialValue: qs(g)
      };
    }
    function Pg(e, r) {
      var c = e, g = qs(r.value), x = qs(r.defaultValue);
      if (g != null) {
        var R = la(g);
        R !== c.value && (c.value = R), r.defaultValue == null && c.defaultValue !== R && (c.defaultValue = R);
      }
      x != null && (c.defaultValue = la(x));
    }
    function Ng(e, r) {
      var c = e, g = c.textContent;
      g === c._wrapperState.initialValue && g !== "" && g !== null && (c.value = g);
    }
    function Zf(e, r) {
      Pg(e, r);
    }
    var ms = "http://www.w3.org/1999/xhtml", gx = "http://www.w3.org/1998/Math/MathML", Qf = "http://www.w3.org/2000/svg";
    function qc(e) {
      switch (e) {
        case "svg":
          return Qf;
        case "math":
          return gx;
        default:
          return ms;
      }
    }
    function Kf(e, r) {
      return e == null || e === ms ? qc(r) : e === Qf && r === "foreignObject" ? ms : e;
    }
    var mx = function(e) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(r, c, g, x) {
        MSApp.execUnsafeLocalFunction(function() {
          return e(r, c, g, x);
        });
      } : e;
    }, Zc, zg = mx(function(e, r) {
      if (e.namespaceURI === Qf && !("innerHTML" in e)) {
        Zc = Zc || document.createElement("div"), Zc.innerHTML = "<svg>" + r.valueOf().toString() + "</svg>";
        for (var c = Zc.firstChild; e.firstChild; )
          e.removeChild(e.firstChild);
        for (; c.firstChild; )
          e.appendChild(c.firstChild);
        return;
      }
      e.innerHTML = r;
    }), _a = 1, vs = 3, br = 8, Ii = 9, No = 11, Qc = function(e, r) {
      if (r) {
        var c = e.firstChild;
        if (c && c === e.lastChild && c.nodeType === vs) {
          c.nodeValue = r;
          return;
        }
      }
      e.textContent = r;
    }, Ig = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, Nl = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Fg(e, r) {
      return e + r.charAt(0).toUpperCase() + r.substring(1);
    }
    var Yg = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Nl).forEach(function(e) {
      Yg.forEach(function(r) {
        Nl[Fg(r, e)] = Nl[e];
      });
    });
    function Kc(e, r, c) {
      var g = r == null || typeof r == "boolean" || r === "";
      return g ? "" : !c && typeof r == "number" && r !== 0 && !(Nl.hasOwnProperty(e) && Nl[e]) ? r + "px" : (di(r, e), ("" + r).trim());
    }
    var zl = /([A-Z])/g, vx = /^ms-/;
    function yx(e) {
      return e.replace(zl, "-$1").toLowerCase().replace(vx, "-ms-");
    }
    var Hg = function() {
    };
    {
      var jg = /^(?:webkit|moz|o)[A-Z]/, Bg = /^-ms-/, Hu = /-(.)/g, Il = /;\s*$/, Fl = {}, Yl = {}, Wg = !1, Jf = !1, eh = function(e) {
        return e.replace(Hu, function(r, c) {
          return c.toUpperCase();
        });
      }, th = function(e) {
        Fl.hasOwnProperty(e) && Fl[e] || (Fl[e] = !0, A(
          "Unsupported style property %s. Did you mean %s?",
          e,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          eh(e.replace(Bg, "ms-"))
        ));
      }, Ug = function(e) {
        Fl.hasOwnProperty(e) && Fl[e] || (Fl[e] = !0, A("Unsupported vendor-prefixed style property %s. Did you mean %s?", e, e.charAt(0).toUpperCase() + e.slice(1)));
      }, Xg = function(e, r) {
        Yl.hasOwnProperty(r) && Yl[r] || (Yl[r] = !0, A(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, e, r.replace(Il, "")));
      }, Vg = function(e, r) {
        Wg || (Wg = !0, A("`NaN` is an invalid value for the `%s` css style property.", e));
      }, xx = function(e, r) {
        Jf || (Jf = !0, A("`Infinity` is an invalid value for the `%s` css style property.", e));
      };
      Hg = function(e, r) {
        e.indexOf("-") > -1 ? th(e) : jg.test(e) ? Ug(e) : Il.test(r) && Xg(e, r), typeof r == "number" && (isNaN(r) ? Vg(e, r) : isFinite(r) || xx(e, r));
      };
    }
    var bx = Hg;
    function wx(e) {
      {
        var r = "", c = "";
        for (var g in e)
          if (e.hasOwnProperty(g)) {
            var x = e[g];
            if (x != null) {
              var R = g.indexOf("--") === 0;
              r += c + (R ? g : yx(g)) + ":", r += Kc(g, x, R), c = ";";
            }
          }
        return r || null;
      }
    }
    function Gg(e, r) {
      var c = e.style;
      for (var g in r)
        if (r.hasOwnProperty(g)) {
          var x = g.indexOf("--") === 0;
          x || bx(g, r[g]);
          var R = Kc(g, r[g], x);
          g === "float" && (g = "cssFloat"), x ? c.setProperty(g, R) : c[g] = R;
        }
    }
    function Sx(e) {
      return e == null || typeof e == "boolean" || e === "";
    }
    function hi(e) {
      var r = {};
      for (var c in e)
        for (var g = Ig[c] || [c], x = 0; x < g.length; x++)
          r[g[x]] = c;
      return r;
    }
    function ju(e, r) {
      {
        if (!r)
          return;
        var c = hi(e), g = hi(r), x = {};
        for (var R in c) {
          var _ = c[R], Y = g[R];
          if (Y && _ !== Y) {
            var U = _ + "," + Y;
            if (x[U])
              continue;
            x[U] = !0, A("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", Sx(e[_]) ? "Removing" : "Updating", _, Y);
          }
        }
      }
    }
    var $g = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, qg = p({
      menuitem: !0
    }, $g), Zg = "__html";
    function Jc(e, r) {
      if (r) {
        if (qg[e] && (r.children != null || r.dangerouslySetInnerHTML != null))
          throw new Error(e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (r.dangerouslySetInnerHTML != null) {
          if (r.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof r.dangerouslySetInnerHTML != "object" || !(Zg in r.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!r.suppressContentEditableWarning && r.contentEditable && r.children != null && A("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), r.style != null && typeof r.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function ys(e, r) {
      if (e.indexOf("-") === -1)
        return typeof r.is == "string";
      switch (e) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var ed = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Qg = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Fi = {}, nh = new RegExp("^(aria)-[" + Lt + "]*$"), Bu = new RegExp("^(aria)[A-Z][" + Lt + "]*$");
    function rh(e, r) {
      {
        if (jn.call(Fi, r) && Fi[r])
          return !0;
        if (Bu.test(r)) {
          var c = "aria-" + r.slice(4).toLowerCase(), g = Qg.hasOwnProperty(c) ? c : null;
          if (g == null)
            return A("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", r), Fi[r] = !0, !0;
          if (r !== g)
            return A("Invalid ARIA attribute `%s`. Did you mean `%s`?", r, g), Fi[r] = !0, !0;
        }
        if (nh.test(r)) {
          var x = r.toLowerCase(), R = Qg.hasOwnProperty(x) ? x : null;
          if (R == null)
            return Fi[r] = !0, !1;
          if (r !== R)
            return A("Unknown ARIA attribute `%s`. Did you mean `%s`?", r, R), Fi[r] = !0, !0;
        }
      }
      return !0;
    }
    function Kg(e, r) {
      {
        var c = [];
        for (var g in r) {
          var x = rh(e, g);
          x || c.push(g);
        }
        var R = c.map(function(_) {
          return "`" + _ + "`";
        }).join(", ");
        c.length === 1 ? A("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", R, e) : c.length > 1 && A("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", R, e);
      }
    }
    function td(e, r) {
      ys(e, r) || Kg(e, r);
    }
    var zo = !1;
    function ah(e, r) {
      {
        if (e !== "input" && e !== "textarea" && e !== "select")
          return;
        r != null && r.value === null && !zo && (zo = !0, e === "select" && r.multiple ? A("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", e) : A("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", e));
      }
    }
    var ih = function() {
    };
    {
      var Pr = {}, sh = /^on./, Jg = /^on[^A-Z]/, em = new RegExp("^(aria)-[" + Lt + "]*$"), tm = new RegExp("^(aria)[A-Z][" + Lt + "]*$");
      ih = function(e, r, c, g) {
        if (jn.call(Pr, r) && Pr[r])
          return !0;
        var x = r.toLowerCase();
        if (x === "onfocusin" || x === "onfocusout")
          return A("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Pr[r] = !0, !0;
        if (g != null) {
          var R = g.registrationNameDependencies, _ = g.possibleRegistrationNames;
          if (R.hasOwnProperty(r))
            return !0;
          var Y = _.hasOwnProperty(x) ? _[x] : null;
          if (Y != null)
            return A("Invalid event handler property `%s`. Did you mean `%s`?", r, Y), Pr[r] = !0, !0;
          if (sh.test(r))
            return A("Unknown event handler property `%s`. It will be ignored.", r), Pr[r] = !0, !0;
        } else if (sh.test(r))
          return Jg.test(r) && A("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", r), Pr[r] = !0, !0;
        if (em.test(r) || tm.test(r))
          return !0;
        if (x === "innerhtml")
          return A("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Pr[r] = !0, !0;
        if (x === "aria")
          return A("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Pr[r] = !0, !0;
        if (x === "is" && c !== null && c !== void 0 && typeof c != "string")
          return A("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof c), Pr[r] = !0, !0;
        if (typeof c == "number" && isNaN(c))
          return A("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", r), Pr[r] = !0, !0;
        var U = yr(r), J = U !== null && U.type === fi;
        if (ed.hasOwnProperty(x)) {
          var ne = ed[x];
          if (ne !== r)
            return A("Invalid DOM property `%s`. Did you mean `%s`?", r, ne), Pr[r] = !0, !0;
        } else if (!J && r !== x)
          return A("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", r, x), Pr[r] = !0, !0;
        return typeof c == "boolean" && aa(r, c, U, !1) ? (c ? A('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', c, r, r, c, r) : A('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', c, r, r, c, r, r, r), Pr[r] = !0, !0) : J ? !0 : aa(r, c, U, !1) ? (Pr[r] = !0, !1) : ((c === "false" || c === "true") && U !== null && U.type === sr && (A("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", c, r, c === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', r, c), Pr[r] = !0), !0);
      };
    }
    var nm = function(e, r, c) {
      {
        var g = [];
        for (var x in r) {
          var R = ih(e, x, r[x], c);
          R || g.push(x);
        }
        var _ = g.map(function(Y) {
          return "`" + Y + "`";
        }).join(", ");
        g.length === 1 ? A("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", _, e) : g.length > 1 && A("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", _, e);
      }
    };
    function rm(e, r, c) {
      ys(e, r) || nm(e, r, c);
    }
    var xs = 1, Wu = 2, Io = 4, kx = xs | Wu | Io, Uu = null;
    function Xu(e) {
      Uu !== null && A("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Uu = e;
    }
    function Cx() {
      Uu === null && A("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Uu = null;
    }
    function am(e) {
      return e === Uu;
    }
    function nd(e) {
      var r = e.target || e.srcElement || window;
      return r.correspondingUseElement && (r = r.correspondingUseElement), r.nodeType === vs ? r.parentNode : r;
    }
    var In = null, Ks = null, bs = null;
    function Hl(e) {
      var r = fu(e);
      if (r) {
        if (typeof In != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var c = r.stateNode;
        if (c) {
          var g = av(c);
          In(r.stateNode, r.type, g);
        }
      }
    }
    function im(e) {
      In = e;
    }
    function rd(e) {
      Ks ? bs ? bs.push(e) : bs = [e] : Ks = e;
    }
    function Vu() {
      return Ks !== null || bs !== null;
    }
    function Gu() {
      if (Ks) {
        var e = Ks, r = bs;
        if (Ks = null, bs = null, Hl(e), r)
          for (var c = 0; c < r.length; c++)
            Hl(r[c]);
      }
    }
    var Fo = function(e, r) {
      return e(r);
    }, oh = function() {
    }, lh = !1;
    function Tx() {
      var e = Vu();
      e && (oh(), Gu());
    }
    function uh(e, r, c) {
      if (lh)
        return e(r, c);
      lh = !0;
      try {
        return Fo(e, r, c);
      } finally {
        lh = !1, Tx();
      }
    }
    function ad(e, r, c) {
      Fo = e, oh = c;
    }
    function id(e) {
      return e === "button" || e === "input" || e === "select" || e === "textarea";
    }
    function ch(e, r, c) {
      switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(c.disabled && id(r));
        default:
          return !1;
      }
    }
    function Yo(e, r) {
      var c = e.stateNode;
      if (c === null)
        return null;
      var g = av(c);
      if (g === null)
        return null;
      var x = g[r];
      if (ch(r, e.type, g))
        return null;
      if (x && typeof x != "function")
        throw new Error("Expected `" + r + "` listener to be a function, instead got a value of `" + typeof x + "` type.");
      return x;
    }
    var $u = !1;
    if (pn)
      try {
        var Ho = {};
        Object.defineProperty(Ho, "passive", {
          get: function() {
            $u = !0;
          }
        }), window.addEventListener("test", Ho, Ho), window.removeEventListener("test", Ho, Ho);
      } catch {
        $u = !1;
      }
    function sm(e, r, c, g, x, R, _, Y, U) {
      var J = Array.prototype.slice.call(arguments, 3);
      try {
        r.apply(c, J);
      } catch (ne) {
        this.onError(ne);
      }
    }
    var dh = sm;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var fh = document.createElement("react");
      dh = function(r, c, g, x, R, _, Y, U, J) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var ne = document.createEvent("Event"), ge = !1, he = !0, Te = window.event, Ae = Object.getOwnPropertyDescriptor(window, "event");
        function Oe() {
          fh.removeEventListener(De, zt, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Te);
        }
        var dt = Array.prototype.slice.call(arguments, 3);
        function zt() {
          ge = !0, Oe(), c.apply(g, dt), he = !1;
        }
        var Rt, hn = !1, on = !1;
        function xe(be) {
          if (Rt = be.error, hn = !0, Rt === null && be.colno === 0 && be.lineno === 0 && (on = !0), be.defaultPrevented && Rt != null && typeof Rt == "object")
            try {
              Rt._suppressLogging = !0;
            } catch {
            }
        }
        var De = "react-" + (r || "invokeguardedcallback");
        if (window.addEventListener("error", xe), fh.addEventListener(De, zt, !1), ne.initEvent(De, !1, !1), fh.dispatchEvent(ne), Ae && Object.defineProperty(window, "event", Ae), ge && he && (hn ? on && (Rt = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Rt = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Rt)), window.removeEventListener("error", xe), !ge)
          return Oe(), sm.apply(this, arguments);
      };
    }
    var Ax = dh, Js = !1, Yi = null, qu = !1, eo = null, Gi = {
      onError: function(e) {
        Js = !0, Yi = e;
      }
    };
    function jo(e, r, c, g, x, R, _, Y, U) {
      Js = !1, Yi = null, Ax.apply(Gi, arguments);
    }
    function ws(e, r, c, g, x, R, _, Y, U) {
      if (jo.apply(this, arguments), Js) {
        var J = ph();
        qu || (qu = !0, eo = J);
      }
    }
    function hh() {
      if (qu) {
        var e = eo;
        throw qu = !1, eo = null, e;
      }
    }
    function Ex() {
      return Js;
    }
    function ph() {
      if (Js) {
        var e = Yi;
        return Js = !1, Yi = null, e;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function pi(e) {
      return e._reactInternals;
    }
    function Zu(e) {
      return e._reactInternals !== void 0;
    }
    function jl(e, r) {
      e._reactInternals = r;
    }
    var _t = (
      /*                      */
      0
    ), to = (
      /*                */
      1
    ), Wn = (
      /*                    */
      2
    ), en = (
      /*                       */
      4
    ), Sn = (
      /*                */
      16
    ), Tn = (
      /*                 */
      32
    ), $i = (
      /*                     */
      64
    ), Xt = (
      /*                   */
      128
    ), lr = (
      /*            */
      256
    ), Pa = (
      /*                          */
      512
    ), gi = (
      /*                     */
      1024
    ), qn = (
      /*                      */
      2048
    ), mi = (
      /*                    */
      4096
    ), no = (
      /*                   */
      8192
    ), Qu = (
      /*             */
      16384
    ), sd = qn | en | $i | Pa | gi | Qu, om = (
      /*               */
      32767
    ), ei = (
      /*                   */
      32768
    ), Nr = (
      /*                */
      65536
    ), Ku = (
      /* */
      131072
    ), gh = (
      /*                       */
      1048576
    ), mh = (
      /*                    */
      2097152
    ), Na = (
      /*                 */
      4194304
    ), ro = (
      /*                */
      8388608
    ), za = (
      /*               */
      16777216
    ), Bo = (
      /*              */
      33554432
    ), Bl = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      en | gi | 0
    ), Ia = Wn | en | Sn | Tn | Pa | mi | no, ua = en | $i | Pa | no, vi = qn | Sn, Wr = Na | ro | mh, Ss = h.ReactCurrentOwner;
    function ti(e) {
      var r = e, c = e;
      if (e.alternate)
        for (; r.return; )
          r = r.return;
      else {
        var g = r;
        do
          r = g, (r.flags & (Wn | mi)) !== _t && (c = r.return), g = r.return;
        while (g);
      }
      return r.tag === q ? c : null;
    }
    function vh(e) {
      if (e.tag === re) {
        var r = e.memoizedState;
        if (r === null) {
          var c = e.alternate;
          c !== null && (r = c.memoizedState);
        }
        if (r !== null)
          return r.dehydrated;
      }
      return null;
    }
    function od(e) {
      return e.tag === q ? e.stateNode.containerInfo : null;
    }
    function yh(e) {
      return ti(e) === e;
    }
    function ni(e) {
      {
        var r = Ss.current;
        if (r !== null && r.tag === j) {
          var c = r, g = c.stateNode;
          g._warnedAboutRefsInRender || A("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", vt(c) || "A component"), g._warnedAboutRefsInRender = !0;
        }
      }
      var x = pi(e);
      return x ? ti(x) === x : !1;
    }
    function Fa(e) {
      if (ti(e) !== e)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Un(e) {
      var r = e.alternate;
      if (!r) {
        var c = ti(e);
        if (c === null)
          throw new Error("Unable to find node on an unmounted component.");
        return c !== e ? null : e;
      }
      for (var g = e, x = r; ; ) {
        var R = g.return;
        if (R === null)
          break;
        var _ = R.alternate;
        if (_ === null) {
          var Y = R.return;
          if (Y !== null) {
            g = x = Y;
            continue;
          }
          break;
        }
        if (R.child === _.child) {
          for (var U = R.child; U; ) {
            if (U === g)
              return Fa(R), e;
            if (U === x)
              return Fa(R), r;
            U = U.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (g.return !== x.return)
          g = R, x = _;
        else {
          for (var J = !1, ne = R.child; ne; ) {
            if (ne === g) {
              J = !0, g = R, x = _;
              break;
            }
            if (ne === x) {
              J = !0, x = R, g = _;
              break;
            }
            ne = ne.sibling;
          }
          if (!J) {
            for (ne = _.child; ne; ) {
              if (ne === g) {
                J = !0, g = _, x = R;
                break;
              }
              if (ne === x) {
                J = !0, x = _, g = R;
                break;
              }
              ne = ne.sibling;
            }
            if (!J)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (g.alternate !== x)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (g.tag !== q)
        throw new Error("Unable to find node on an unmounted component.");
      return g.stateNode.current === g ? e : r;
    }
    function yi(e) {
      var r = Un(e);
      return r !== null ? xh(r) : null;
    }
    function xh(e) {
      if (e.tag === ae || e.tag === se)
        return e;
      for (var r = e.child; r !== null; ) {
        var c = xh(r);
        if (c !== null)
          return c;
        r = r.sibling;
      }
      return null;
    }
    function lm(e) {
      var r = Un(e);
      return r !== null ? ld(r) : null;
    }
    function ld(e) {
      if (e.tag === ae || e.tag === se)
        return e;
      for (var r = e.child; r !== null; ) {
        if (r.tag !== te) {
          var c = ld(r);
          if (c !== null)
            return c;
        }
        r = r.sibling;
      }
      return null;
    }
    var ud = u.unstable_scheduleCallback, um = u.unstable_cancelCallback, cd = u.unstable_shouldYield, cm = u.unstable_requestPaint, Qn = u.unstable_now, bh = u.unstable_getCurrentPriorityLevel, dd = u.unstable_ImmediatePriority, ri = u.unstable_UserBlockingPriority, qi = u.unstable_NormalPriority, fd = u.unstable_LowPriority, ao = u.unstable_IdlePriority, wh = u.unstable_yieldValue, Sh = u.unstable_setDisableYieldValue, io = null, zr = null, nt = null, hr = !1, Ur = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function kh(e) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var r = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (r.isDisabled)
        return !0;
      if (!r.supportsFiber)
        return A("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        Pt && (e = p({}, e, {
          getLaneLabelMap: oo,
          injectProfilingHooks: Cs
        })), io = r.inject(e), zr = r;
      } catch (c) {
        A("React instrumentation encountered an error: %s.", c);
      }
      return !!r.checkDCE;
    }
    function dm(e, r) {
      if (zr && typeof zr.onScheduleFiberRoot == "function")
        try {
          zr.onScheduleFiberRoot(io, e, r);
        } catch (c) {
          hr || (hr = !0, A("React instrumentation encountered an error: %s", c));
        }
    }
    function ks(e, r) {
      if (zr && typeof zr.onCommitFiberRoot == "function")
        try {
          var c = (e.current.flags & Xt) === Xt;
          if (st) {
            var g;
            switch (r) {
              case ca:
                g = dd;
                break;
              case Xr:
                g = ri;
                break;
              case As:
                g = qi;
                break;
              case oc:
                g = ao;
                break;
              default:
                g = qi;
                break;
            }
            zr.onCommitFiberRoot(io, e, g, c);
          }
        } catch (x) {
          hr || (hr = !0, A("React instrumentation encountered an error: %s", x));
        }
    }
    function so(e) {
      if (zr && typeof zr.onPostCommitFiberRoot == "function")
        try {
          zr.onPostCommitFiberRoot(io, e);
        } catch (r) {
          hr || (hr = !0, A("React instrumentation encountered an error: %s", r));
        }
    }
    function Ch(e) {
      if (zr && typeof zr.onCommitFiberUnmount == "function")
        try {
          zr.onCommitFiberUnmount(io, e);
        } catch (r) {
          hr || (hr = !0, A("React instrumentation encountered an error: %s", r));
        }
    }
    function Cr(e) {
      if (typeof wh == "function" && (Sh(e), w(e)), zr && typeof zr.setStrictMode == "function")
        try {
          zr.setStrictMode(io, e);
        } catch (r) {
          hr || (hr = !0, A("React instrumentation encountered an error: %s", r));
        }
    }
    function Cs(e) {
      nt = e;
    }
    function oo() {
      {
        for (var e = /* @__PURE__ */ new Map(), r = 1, c = 0; c < Xn; c++) {
          var g = Rx(r);
          e.set(r, g), r *= 2;
        }
        return e;
      }
    }
    function hd(e) {
      nt !== null && typeof nt.markCommitStarted == "function" && nt.markCommitStarted(e);
    }
    function Th() {
      nt !== null && typeof nt.markCommitStopped == "function" && nt.markCommitStopped();
    }
    function lo(e) {
      nt !== null && typeof nt.markComponentRenderStarted == "function" && nt.markComponentRenderStarted(e);
    }
    function Wo() {
      nt !== null && typeof nt.markComponentRenderStopped == "function" && nt.markComponentRenderStopped();
    }
    function fm(e) {
      nt !== null && typeof nt.markComponentPassiveEffectMountStarted == "function" && nt.markComponentPassiveEffectMountStarted(e);
    }
    function Ah() {
      nt !== null && typeof nt.markComponentPassiveEffectMountStopped == "function" && nt.markComponentPassiveEffectMountStopped();
    }
    function pd(e) {
      nt !== null && typeof nt.markComponentPassiveEffectUnmountStarted == "function" && nt.markComponentPassiveEffectUnmountStarted(e);
    }
    function hm() {
      nt !== null && typeof nt.markComponentPassiveEffectUnmountStopped == "function" && nt.markComponentPassiveEffectUnmountStopped();
    }
    function pm(e) {
      nt !== null && typeof nt.markComponentLayoutEffectMountStarted == "function" && nt.markComponentLayoutEffectMountStarted(e);
    }
    function gm() {
      nt !== null && typeof nt.markComponentLayoutEffectMountStopped == "function" && nt.markComponentLayoutEffectMountStopped();
    }
    function gd(e) {
      nt !== null && typeof nt.markComponentLayoutEffectUnmountStarted == "function" && nt.markComponentLayoutEffectUnmountStarted(e);
    }
    function Wl() {
      nt !== null && typeof nt.markComponentLayoutEffectUnmountStopped == "function" && nt.markComponentLayoutEffectUnmountStopped();
    }
    function md(e, r, c) {
      nt !== null && typeof nt.markComponentErrored == "function" && nt.markComponentErrored(e, r, c);
    }
    function mm(e, r, c) {
      nt !== null && typeof nt.markComponentSuspended == "function" && nt.markComponentSuspended(e, r, c);
    }
    function vm(e) {
      nt !== null && typeof nt.markLayoutEffectsStarted == "function" && nt.markLayoutEffectsStarted(e);
    }
    function Ul() {
      nt !== null && typeof nt.markLayoutEffectsStopped == "function" && nt.markLayoutEffectsStopped();
    }
    function ym(e) {
      nt !== null && typeof nt.markPassiveEffectsStarted == "function" && nt.markPassiveEffectsStarted(e);
    }
    function Ju() {
      nt !== null && typeof nt.markPassiveEffectsStopped == "function" && nt.markPassiveEffectsStopped();
    }
    function Hi(e) {
      nt !== null && typeof nt.markRenderStarted == "function" && nt.markRenderStarted(e);
    }
    function ec() {
      nt !== null && typeof nt.markRenderYielded == "function" && nt.markRenderYielded();
    }
    function Xl() {
      nt !== null && typeof nt.markRenderStopped == "function" && nt.markRenderStopped();
    }
    function Uo(e) {
      nt !== null && typeof nt.markRenderScheduled == "function" && nt.markRenderScheduled(e);
    }
    function Eh(e, r) {
      nt !== null && typeof nt.markForceUpdateScheduled == "function" && nt.markForceUpdateScheduled(e, r);
    }
    function uo(e, r) {
      nt !== null && typeof nt.markStateUpdateScheduled == "function" && nt.markStateUpdateScheduled(e, r);
    }
    var Ft = (
      /*                         */
      0
    ), rn = (
      /*                 */
      1
    ), jt = (
      /*                    */
      2
    ), Kn = (
      /*               */
      8
    ), xi = (
      /*              */
      16
    ), vd = Math.clz32 ? Math.clz32 : Xo, yd = Math.log, Rh = Math.LN2;
    function Xo(e) {
      var r = e >>> 0;
      return r === 0 ? 32 : 31 - (yd(r) / Rh | 0) | 0;
    }
    var Xn = 31, Ne = (
      /*                        */
      0
    ), dn = (
      /*                          */
      0
    ), Bt = (
      /*                        */
      1
    ), Zi = (
      /*    */
      2
    ), ai = (
      /*             */
      4
    ), Vo = (
      /*            */
      8
    ), Vn = (
      /*                     */
      16
    ), Go = (
      /*                */
      32
    ), co = (
      /*                       */
      4194240
    ), $o = (
      /*                        */
      64
    ), bi = (
      /*                        */
      128
    ), Ya = (
      /*                        */
      256
    ), qo = (
      /*                        */
      512
    ), tc = (
      /*                        */
      1024
    ), nc = (
      /*                        */
      2048
    ), xd = (
      /*                        */
      4096
    ), bd = (
      /*                        */
      8192
    ), wd = (
      /*                        */
      16384
    ), Sd = (
      /*                       */
      32768
    ), kd = (
      /*                       */
      65536
    ), Cd = (
      /*                       */
      131072
    ), Td = (
      /*                       */
      262144
    ), Ad = (
      /*                       */
      524288
    ), Zo = (
      /*                       */
      1048576
    ), Ed = (
      /*                       */
      2097152
    ), Qo = (
      /*                            */
      130023424
    ), Ts = (
      /*                             */
      4194304
    ), Rd = (
      /*                             */
      8388608
    ), rc = (
      /*                             */
      16777216
    ), Ld = (
      /*                             */
      33554432
    ), Od = (
      /*                             */
      67108864
    ), Lh = Ts, Vl = (
      /*          */
      134217728
    ), Dd = (
      /*                          */
      268435455
    ), Gl = (
      /*               */
      268435456
    ), fo = (
      /*                        */
      536870912
    ), Ha = (
      /*                   */
      1073741824
    );
    function Rx(e) {
      {
        if (e & Bt)
          return "Sync";
        if (e & Zi)
          return "InputContinuousHydration";
        if (e & ai)
          return "InputContinuous";
        if (e & Vo)
          return "DefaultHydration";
        if (e & Vn)
          return "Default";
        if (e & Go)
          return "TransitionHydration";
        if (e & co)
          return "Transition";
        if (e & Qo)
          return "Retry";
        if (e & Vl)
          return "SelectiveHydration";
        if (e & Gl)
          return "IdleHydration";
        if (e & fo)
          return "Idle";
        if (e & Ha)
          return "Offscreen";
      }
    }
    var Fn = -1, Md = $o, _d = Ts;
    function $l(e) {
      switch (wr(e)) {
        case Bt:
          return Bt;
        case Zi:
          return Zi;
        case ai:
          return ai;
        case Vo:
          return Vo;
        case Vn:
          return Vn;
        case Go:
          return Go;
        case $o:
        case bi:
        case Ya:
        case qo:
        case tc:
        case nc:
        case xd:
        case bd:
        case wd:
        case Sd:
        case kd:
        case Cd:
        case Td:
        case Ad:
        case Zo:
        case Ed:
          return e & co;
        case Ts:
        case Rd:
        case rc:
        case Ld:
        case Od:
          return e & Qo;
        case Vl:
          return Vl;
        case Gl:
          return Gl;
        case fo:
          return fo;
        case Ha:
          return Ha;
        default:
          return A("Should have found matching lanes. This is a bug in React."), e;
      }
    }
    function ac(e, r) {
      var c = e.pendingLanes;
      if (c === Ne)
        return Ne;
      var g = Ne, x = e.suspendedLanes, R = e.pingedLanes, _ = c & Dd;
      if (_ !== Ne) {
        var Y = _ & ~x;
        if (Y !== Ne)
          g = $l(Y);
        else {
          var U = _ & R;
          U !== Ne && (g = $l(U));
        }
      } else {
        var J = c & ~x;
        J !== Ne ? g = $l(J) : R !== Ne && (g = $l(R));
      }
      if (g === Ne)
        return Ne;
      if (r !== Ne && r !== g && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (r & x) === Ne) {
        var ne = wr(g), ge = wr(r);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          ne >= ge || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          ne === Vn && (ge & co) !== Ne
        )
          return r;
      }
      (g & ai) !== Ne && (g |= c & Vn);
      var he = e.entangledLanes;
      if (he !== Ne)
        for (var Te = e.entanglements, Ae = g & he; Ae > 0; ) {
          var Oe = ho(Ae), dt = 1 << Oe;
          g |= Te[Oe], Ae &= ~dt;
        }
      return g;
    }
    function xm(e, r) {
      for (var c = e.eventTimes, g = Fn; r > 0; ) {
        var x = ho(r), R = 1 << x, _ = c[x];
        _ > g && (g = _), r &= ~R;
      }
      return g;
    }
    function Pd(e, r) {
      switch (e) {
        case Bt:
        case Zi:
        case ai:
          return r + 250;
        case Vo:
        case Vn:
        case Go:
        case $o:
        case bi:
        case Ya:
        case qo:
        case tc:
        case nc:
        case xd:
        case bd:
        case wd:
        case Sd:
        case kd:
        case Cd:
        case Td:
        case Ad:
        case Zo:
        case Ed:
          return r + 5e3;
        case Ts:
        case Rd:
        case rc:
        case Ld:
        case Od:
          return Fn;
        case Vl:
        case Gl:
        case fo:
        case Ha:
          return Fn;
        default:
          return A("Should have found matching lanes. This is a bug in React."), Fn;
      }
    }
    function Lx(e, r) {
      for (var c = e.pendingLanes, g = e.suspendedLanes, x = e.pingedLanes, R = e.expirationTimes, _ = c; _ > 0; ) {
        var Y = ho(_), U = 1 << Y, J = R[Y];
        J === Fn ? ((U & g) === Ne || (U & x) !== Ne) && (R[Y] = Pd(U, r)) : J <= r && (e.expiredLanes |= U), _ &= ~U;
      }
    }
    function Ox(e) {
      return $l(e.pendingLanes);
    }
    function Oh(e) {
      var r = e.pendingLanes & ~Ha;
      return r !== Ne ? r : r & Ha ? Ha : Ne;
    }
    function ql(e) {
      return (e & Bt) !== Ne;
    }
    function ic(e) {
      return (e & Dd) !== Ne;
    }
    function Nd(e) {
      return (e & Qo) === e;
    }
    function Dx(e) {
      var r = Bt | ai | Vn;
      return (e & r) === Ne;
    }
    function bm(e) {
      return (e & co) === e;
    }
    function sc(e, r) {
      var c = Zi | ai | Vo | Vn;
      return (r & c) !== Ne;
    }
    function wm(e, r) {
      return (r & e.expiredLanes) !== Ne;
    }
    function Dh(e) {
      return (e & co) !== Ne;
    }
    function Mh() {
      var e = Md;
      return Md <<= 1, (Md & co) === Ne && (Md = $o), e;
    }
    function Mx() {
      var e = _d;
      return _d <<= 1, (_d & Qo) === Ne && (_d = Ts), e;
    }
    function wr(e) {
      return e & -e;
    }
    function Tr(e) {
      return wr(e);
    }
    function ho(e) {
      return 31 - vd(e);
    }
    function zd(e) {
      return ho(e);
    }
    function ja(e, r) {
      return (e & r) !== Ne;
    }
    function Ko(e, r) {
      return (e & r) === r;
    }
    function tn(e, r) {
      return e | r;
    }
    function Zl(e, r) {
      return e & ~r;
    }
    function _h(e, r) {
      return e & r;
    }
    function Sm(e) {
      return e;
    }
    function km(e, r) {
      return e !== dn && e < r ? e : r;
    }
    function Id(e) {
      for (var r = [], c = 0; c < Xn; c++)
        r.push(e);
      return r;
    }
    function Jo(e, r, c) {
      e.pendingLanes |= r, r !== fo && (e.suspendedLanes = Ne, e.pingedLanes = Ne);
      var g = e.eventTimes, x = zd(r);
      g[x] = c;
    }
    function Ph(e, r) {
      e.suspendedLanes |= r, e.pingedLanes &= ~r;
      for (var c = e.expirationTimes, g = r; g > 0; ) {
        var x = ho(g), R = 1 << x;
        c[x] = Fn, g &= ~R;
      }
    }
    function Nh(e, r, c) {
      e.pingedLanes |= e.suspendedLanes & r;
    }
    function zh(e, r) {
      var c = e.pendingLanes & ~r;
      e.pendingLanes = r, e.suspendedLanes = Ne, e.pingedLanes = Ne, e.expiredLanes &= r, e.mutableReadLanes &= r, e.entangledLanes &= r;
      for (var g = e.entanglements, x = e.eventTimes, R = e.expirationTimes, _ = c; _ > 0; ) {
        var Y = ho(_), U = 1 << Y;
        g[Y] = Ne, x[Y] = Fn, R[Y] = Fn, _ &= ~U;
      }
    }
    function Ql(e, r) {
      for (var c = e.entangledLanes |= r, g = e.entanglements, x = c; x; ) {
        var R = ho(x), _ = 1 << R;
        // Is this one of the newly entangled lanes?
        _ & r | // Is this lane transitively entangled with the newly entangled lanes?
        g[R] & r && (g[R] |= r), x &= ~_;
      }
    }
    function _x(e, r) {
      var c = wr(r), g;
      switch (c) {
        case ai:
          g = Zi;
          break;
        case Vn:
          g = Vo;
          break;
        case $o:
        case bi:
        case Ya:
        case qo:
        case tc:
        case nc:
        case xd:
        case bd:
        case wd:
        case Sd:
        case kd:
        case Cd:
        case Td:
        case Ad:
        case Zo:
        case Ed:
        case Ts:
        case Rd:
        case rc:
        case Ld:
        case Od:
          g = Go;
          break;
        case fo:
          g = Gl;
          break;
        default:
          g = dn;
          break;
      }
      return (g & (e.suspendedLanes | r)) !== dn ? dn : g;
    }
    function Ih(e, r, c) {
      if (Ur)
        for (var g = e.pendingUpdatersLaneMap; c > 0; ) {
          var x = zd(c), R = 1 << x, _ = g[x];
          _.add(r), c &= ~R;
        }
    }
    function Fd(e, r) {
      if (Ur)
        for (var c = e.pendingUpdatersLaneMap, g = e.memoizedUpdaters; r > 0; ) {
          var x = zd(r), R = 1 << x, _ = c[x];
          _.size > 0 && (_.forEach(function(Y) {
            var U = Y.alternate;
            (U === null || !g.has(U)) && g.add(Y);
          }), _.clear()), r &= ~R;
        }
    }
    function Fh(e, r) {
      return null;
    }
    var ca = Bt, Xr = ai, As = Vn, oc = fo, el = dn;
    function wi() {
      return el;
    }
    function Ar(e) {
      el = e;
    }
    function lc(e, r) {
      var c = el;
      try {
        return el = e, r();
      } finally {
        el = c;
      }
    }
    function da(e, r) {
      return e !== 0 && e < r ? e : r;
    }
    function Px(e, r) {
      return e === 0 || e > r ? e : r;
    }
    function Yh(e, r) {
      return e !== 0 && e < r;
    }
    function uc(e) {
      var r = wr(e);
      return Yh(ca, r) ? Yh(Xr, r) ? ic(r) ? As : oc : Xr : ca;
    }
    function Er(e) {
      var r = e.current.memoizedState;
      return r.isDehydrated;
    }
    var Cm;
    function gt(e) {
      Cm = e;
    }
    function Kl(e) {
      Cm(e);
    }
    var cc;
    function Tm(e) {
      cc = e;
    }
    var Am;
    function dc(e) {
      Am = e;
    }
    var fc;
    function Hh(e) {
      fc = e;
    }
    var jh;
    function Em(e) {
      jh = e;
    }
    var Yd = !1, Jl = [], Qi = null, Zn = null, Ir = null, Si = /* @__PURE__ */ new Map(), eu = /* @__PURE__ */ new Map(), Es = [], ji = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function Rm(e) {
      return ji.indexOf(e) > -1;
    }
    function Ki(e, r, c, g, x) {
      return {
        blockedOn: e,
        domEventName: r,
        eventSystemFlags: c,
        nativeEvent: x,
        targetContainers: [g]
      };
    }
    function Lm(e, r) {
      switch (e) {
        case "focusin":
        case "focusout":
          Qi = null;
          break;
        case "dragenter":
        case "dragleave":
          Zn = null;
          break;
        case "mouseover":
        case "mouseout":
          Ir = null;
          break;
        case "pointerover":
        case "pointerout": {
          var c = r.pointerId;
          Si.delete(c);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var g = r.pointerId;
          eu.delete(g);
          break;
        }
      }
    }
    function tu(e, r, c, g, x, R) {
      if (e === null || e.nativeEvent !== R) {
        var _ = Ki(r, c, g, x, R);
        if (r !== null) {
          var Y = fu(r);
          Y !== null && cc(Y);
        }
        return _;
      }
      e.eventSystemFlags |= g;
      var U = e.targetContainers;
      return x !== null && U.indexOf(x) === -1 && U.push(x), e;
    }
    function Om(e, r, c, g, x) {
      switch (r) {
        case "focusin": {
          var R = x;
          return Qi = tu(Qi, e, r, c, g, R), !0;
        }
        case "dragenter": {
          var _ = x;
          return Zn = tu(Zn, e, r, c, g, _), !0;
        }
        case "mouseover": {
          var Y = x;
          return Ir = tu(Ir, e, r, c, g, Y), !0;
        }
        case "pointerover": {
          var U = x, J = U.pointerId;
          return Si.set(J, tu(Si.get(J) || null, e, r, c, g, U)), !0;
        }
        case "gotpointercapture": {
          var ne = x, ge = ne.pointerId;
          return eu.set(ge, tu(eu.get(ge) || null, e, r, c, g, ne)), !0;
        }
      }
      return !1;
    }
    function Bh(e) {
      var r = wc(e.target);
      if (r !== null) {
        var c = ti(r);
        if (c !== null) {
          var g = c.tag;
          if (g === re) {
            var x = vh(c);
            if (x !== null) {
              e.blockedOn = x, jh(e.priority, function() {
                Am(c);
              });
              return;
            }
          } else if (g === q) {
            var R = c.stateNode;
            if (Er(R)) {
              e.blockedOn = od(c);
              return;
            }
          }
        }
      }
      e.blockedOn = null;
    }
    function Dm(e) {
      for (var r = fc(), c = {
        blockedOn: null,
        target: e,
        priority: r
      }, g = 0; g < Es.length && Yh(r, Es[g].priority); g++)
        ;
      Es.splice(g, 0, c), g === 0 && Bh(c);
    }
    function Hd(e) {
      if (e.blockedOn !== null)
        return !1;
      for (var r = e.targetContainers; r.length > 0; ) {
        var c = r[0], g = tl(e.domEventName, e.eventSystemFlags, c, e.nativeEvent);
        if (g === null) {
          var x = e.nativeEvent, R = new x.constructor(x.type, x);
          Xu(R), x.target.dispatchEvent(R), Cx();
        } else {
          var _ = fu(g);
          return _ !== null && cc(_), e.blockedOn = g, !1;
        }
        r.shift();
      }
      return !0;
    }
    function hc(e, r, c) {
      Hd(e) && c.delete(r);
    }
    function Wh() {
      Yd = !1, Qi !== null && Hd(Qi) && (Qi = null), Zn !== null && Hd(Zn) && (Zn = null), Ir !== null && Hd(Ir) && (Ir = null), Si.forEach(hc), eu.forEach(hc);
    }
    function fa(e, r) {
      e.blockedOn === r && (e.blockedOn = null, Yd || (Yd = !0, u.unstable_scheduleCallback(u.unstable_NormalPriority, Wh)));
    }
    function sn(e) {
      if (Jl.length > 0) {
        fa(Jl[0], e);
        for (var r = 1; r < Jl.length; r++) {
          var c = Jl[r];
          c.blockedOn === e && (c.blockedOn = null);
        }
      }
      Qi !== null && fa(Qi, e), Zn !== null && fa(Zn, e), Ir !== null && fa(Ir, e);
      var g = function(Y) {
        return fa(Y, e);
      };
      Si.forEach(g), eu.forEach(g);
      for (var x = 0; x < Es.length; x++) {
        var R = Es[x];
        R.blockedOn === e && (R.blockedOn = null);
      }
      for (; Es.length > 0; ) {
        var _ = Es[0];
        if (_.blockedOn !== null)
          break;
        Bh(_), _.blockedOn === null && Es.shift();
      }
    }
    var Jn = h.ReactCurrentBatchConfig, ur = !0;
    function Fr(e) {
      ur = !!e;
    }
    function ii() {
      return ur;
    }
    function nu(e, r, c) {
      var g = wa(r), x;
      switch (g) {
        case ca:
          x = Rr;
          break;
        case Xr:
          x = pc;
          break;
        case As:
        default:
          x = Rs;
          break;
      }
      return x.bind(null, r, c, e);
    }
    function Rr(e, r, c, g) {
      var x = wi(), R = Jn.transition;
      Jn.transition = null;
      try {
        Ar(ca), Rs(e, r, c, g);
      } finally {
        Ar(x), Jn.transition = R;
      }
    }
    function pc(e, r, c, g) {
      var x = wi(), R = Jn.transition;
      Jn.transition = null;
      try {
        Ar(Xr), Rs(e, r, c, g);
      } finally {
        Ar(x), Jn.transition = R;
      }
    }
    function Rs(e, r, c, g) {
      ur && jd(e, r, c, g);
    }
    function jd(e, r, c, g) {
      var x = tl(e, r, c, g);
      if (x === null) {
        eb(e, r, g, ru, c), Lm(e, g);
        return;
      }
      if (Om(x, e, r, c, g)) {
        g.stopPropagation();
        return;
      }
      if (Lm(e, g), r & Io && Rm(e)) {
        for (; x !== null; ) {
          var R = fu(x);
          R !== null && Kl(R);
          var _ = tl(e, r, c, g);
          if (_ === null && eb(e, r, g, ru, c), _ === x)
            break;
          x = _;
        }
        x !== null && g.stopPropagation();
        return;
      }
      eb(e, r, g, null, c);
    }
    var ru = null;
    function tl(e, r, c, g) {
      ru = null;
      var x = nd(g), R = wc(x);
      if (R !== null) {
        var _ = ti(R);
        if (_ === null)
          R = null;
        else {
          var Y = _.tag;
          if (Y === re) {
            var U = vh(_);
            if (U !== null)
              return U;
            R = null;
          } else if (Y === q) {
            var J = _.stateNode;
            if (Er(J))
              return od(_);
            R = null;
          } else
            _ !== R && (R = null);
        }
      }
      return ru = R, null;
    }
    function wa(e) {
      switch (e) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return ca;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Xr;
        case "message": {
          var r = bh();
          switch (r) {
            case dd:
              return ca;
            case ri:
              return Xr;
            case qi:
            case fd:
              return As;
            case ao:
              return oc;
            default:
              return As;
          }
        }
        default:
          return As;
      }
    }
    function Uh(e, r, c) {
      return e.addEventListener(r, c, !1), c;
    }
    function au(e, r, c) {
      return e.addEventListener(r, c, !0), c;
    }
    function Ls(e, r, c, g) {
      return e.addEventListener(r, c, {
        capture: !0,
        passive: g
      }), c;
    }
    function Bd(e, r, c, g) {
      return e.addEventListener(r, c, {
        passive: g
      }), c;
    }
    var nl = null, Ji = null, po = null;
    function go(e) {
      return nl = e, Ji = Ud(), !0;
    }
    function Wd() {
      nl = null, Ji = null, po = null;
    }
    function iu() {
      if (po)
        return po;
      var e, r = Ji, c = r.length, g, x = Ud(), R = x.length;
      for (e = 0; e < c && r[e] === x[e]; e++)
        ;
      var _ = c - e;
      for (g = 1; g <= _ && r[c - g] === x[R - g]; g++)
        ;
      var Y = g > 1 ? 1 - g : void 0;
      return po = x.slice(e, Y), po;
    }
    function Ud() {
      return "value" in nl ? nl.value : nl.textContent;
    }
    function rl(e) {
      var r, c = e.keyCode;
      return "charCode" in e ? (r = e.charCode, r === 0 && c === 13 && (r = 13)) : r = c, r === 10 && (r = 13), r >= 32 || r === 13 ? r : 0;
    }
    function al() {
      return !0;
    }
    function ha() {
      return !1;
    }
    function Sr(e) {
      function r(c, g, x, R, _) {
        this._reactName = c, this._targetInst = x, this.type = g, this.nativeEvent = R, this.target = _, this.currentTarget = null;
        for (var Y in e)
          if (e.hasOwnProperty(Y)) {
            var U = e[Y];
            U ? this[Y] = U(R) : this[Y] = R[Y];
          }
        var J = R.defaultPrevented != null ? R.defaultPrevented : R.returnValue === !1;
        return J ? this.isDefaultPrevented = al : this.isDefaultPrevented = ha, this.isPropagationStopped = ha, this;
      }
      return p(r.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var c = this.nativeEvent;
          c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = al);
        },
        stopPropagation: function() {
          var c = this.nativeEvent;
          c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = al);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: al
      }), r;
    }
    var pa = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(e) {
        return e.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, ga = Sr(pa), su = p({}, pa, {
      view: 0,
      detail: 0
    }), Xh = Sr(su), gc, Vh, ki;
    function Mm(e) {
      e !== ki && (ki && e.type === "mousemove" ? (gc = e.screenX - ki.screenX, Vh = e.screenY - ki.screenY) : (gc = 0, Vh = 0), ki = e);
    }
    var ou = p({}, su, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Gd,
      button: 0,
      buttons: 0,
      relatedTarget: function(e) {
        return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
      },
      movementX: function(e) {
        return "movementX" in e ? e.movementX : (Mm(e), gc);
      },
      movementY: function(e) {
        return "movementY" in e ? e.movementY : Vh;
      }
    }), mo = Sr(ou), Gh = p({}, ou, {
      dataTransfer: 0
    }), il = Sr(Gh), _m = p({}, su, {
      relatedTarget: 0
    }), Xd = Sr(_m), $h = p({}, pa, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Vd = Sr($h), Nx = p({}, pa, {
      clipboardData: function(e) {
        return "clipboardData" in e ? e.clipboardData : window.clipboardData;
      }
    }), zx = Sr(Nx), Pm = p({}, pa, {
      data: 0
    }), qh = Sr(Pm), sl = qh, Ix = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, lu = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function Nm(e) {
      if (e.key) {
        var r = Ix[e.key] || e.key;
        if (r !== "Unidentified")
          return r;
      }
      if (e.type === "keypress") {
        var c = rl(e);
        return c === 13 ? "Enter" : String.fromCharCode(c);
      }
      return e.type === "keydown" || e.type === "keyup" ? lu[e.keyCode] || "Unidentified" : "";
    }
    var cr = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function Fx(e) {
      var r = this, c = r.nativeEvent;
      if (c.getModifierState)
        return c.getModifierState(e);
      var g = cr[e];
      return g ? !!c[g] : !1;
    }
    function Gd(e) {
      return Fx;
    }
    var Yx = p({}, su, {
      key: Nm,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Gd,
      // Legacy Interface
      charCode: function(e) {
        return e.type === "keypress" ? rl(e) : 0;
      },
      keyCode: function(e) {
        return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      },
      which: function(e) {
        return e.type === "keypress" ? rl(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      }
    }), Hx = Sr(Yx), zm = p({}, ou, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), Zh = Sr(zm), jx = p({}, su, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Gd
    }), Ci = Sr(jx), Qh = p({}, pa, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Bx = Sr(Qh), vo = p({}, ou, {
      deltaX: function(e) {
        return "deltaX" in e ? e.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in e ? -e.wheelDeltaX : 0
        );
      },
      deltaY: function(e) {
        return "deltaY" in e ? e.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in e ? -e.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in e ? -e.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), $d = Sr(vo), ol = [9, 13, 27, 32], mc = 229, vc = pn && "CompositionEvent" in window, ll = null;
    pn && "documentMode" in document && (ll = document.documentMode);
    var Wx = pn && "TextEvent" in window && !ll, qd = pn && (!vc || ll && ll > 8 && ll <= 11), Im = 32, Kh = String.fromCharCode(Im);
    function Fm() {
      mn("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), mn("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), mn("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), mn("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var yc = !1;
    function Zd(e) {
      return (e.ctrlKey || e.altKey || e.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(e.ctrlKey && e.altKey);
    }
    function Ym(e) {
      switch (e) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function Jh(e, r) {
      return e === "keydown" && r.keyCode === mc;
    }
    function Hm(e, r) {
      switch (e) {
        case "keyup":
          return ol.indexOf(r.keyCode) !== -1;
        case "keydown":
          return r.keyCode !== mc;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function ep(e) {
      var r = e.detail;
      return typeof r == "object" && "data" in r ? r.data : null;
    }
    function Qd(e) {
      return e.locale === "ko";
    }
    var Os = !1;
    function tp(e, r, c, g, x) {
      var R, _;
      if (vc ? R = Ym(r) : Os ? Hm(r, g) && (R = "onCompositionEnd") : Jh(r, g) && (R = "onCompositionStart"), !R)
        return null;
      qd && !Qd(g) && (!Os && R === "onCompositionStart" ? Os = go(x) : R === "onCompositionEnd" && Os && (_ = iu()));
      var Y = Xm(c, R);
      if (Y.length > 0) {
        var U = new qh(R, r, null, g, x);
        if (e.push({
          event: U,
          listeners: Y
        }), _)
          U.data = _;
        else {
          var J = ep(g);
          J !== null && (U.data = J);
        }
      }
    }
    function Kd(e, r) {
      switch (e) {
        case "compositionend":
          return ep(r);
        case "keypress":
          var c = r.which;
          return c !== Im ? null : (yc = !0, Kh);
        case "textInput":
          var g = r.data;
          return g === Kh && yc ? null : g;
        default:
          return null;
      }
    }
    function jm(e, r) {
      if (Os) {
        if (e === "compositionend" || !vc && Hm(e, r)) {
          var c = iu();
          return Wd(), Os = !1, c;
        }
        return null;
      }
      switch (e) {
        case "paste":
          return null;
        case "keypress":
          if (!Zd(r)) {
            if (r.char && r.char.length > 1)
              return r.char;
            if (r.which)
              return String.fromCharCode(r.which);
          }
          return null;
        case "compositionend":
          return qd && !Qd(r) ? null : r.data;
        default:
          return null;
      }
    }
    function Ux(e, r, c, g, x) {
      var R;
      if (Wx ? R = Kd(r, g) : R = jm(r, g), !R)
        return null;
      var _ = Xm(c, "onBeforeInput");
      if (_.length > 0) {
        var Y = new sl("onBeforeInput", "beforeinput", null, g, x);
        e.push({
          event: Y,
          listeners: _
        }), Y.data = R;
      }
    }
    function Jd(e, r, c, g, x, R, _) {
      tp(e, r, c, g, x), Ux(e, r, c, g, x);
    }
    var Xx = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function uu(e) {
      var r = e && e.nodeName && e.nodeName.toLowerCase();
      return r === "input" ? !!Xx[e.type] : r === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function Vx(e) {
      if (!pn)
        return !1;
      var r = "on" + e, c = r in document;
      if (!c) {
        var g = document.createElement("div");
        g.setAttribute(r, "return;"), c = typeof g[r] == "function";
      }
      return c;
    }
    function ef() {
      mn("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function i(e, r, c, g) {
      rd(g);
      var x = Xm(r, "onChange");
      if (x.length > 0) {
        var R = new ga("onChange", "change", null, c, g);
        e.push({
          event: R,
          listeners: x
        });
      }
    }
    var l = null, v = null;
    function k(e) {
      var r = e.nodeName && e.nodeName.toLowerCase();
      return r === "select" || r === "input" && e.type === "file";
    }
    function D(e) {
      var r = [];
      i(r, v, e, nd(e)), uh(z, r);
    }
    function z(e) {
      LS(e, 0);
    }
    function $(e) {
      var r = of(e);
      if (Eg(r))
        return e;
    }
    function ie(e, r) {
      if (e === "change")
        return r;
    }
    var de = !1;
    pn && (de = Vx("input") && (!document.documentMode || document.documentMode > 9));
    function Re(e, r) {
      l = e, v = r, l.attachEvent("onpropertychange", Be);
    }
    function He() {
      l && (l.detachEvent("onpropertychange", Be), l = null, v = null);
    }
    function Be(e) {
      e.propertyName === "value" && $(v) && D(e);
    }
    function Fe(e, r, c) {
      e === "focusin" ? (He(), Re(r, c)) : e === "focusout" && He();
    }
    function lt(e, r) {
      if (e === "selectionchange" || e === "keyup" || e === "keydown")
        return $(v);
    }
    function bt(e) {
      var r = e.nodeName;
      return r && r.toLowerCase() === "input" && (e.type === "checkbox" || e.type === "radio");
    }
    function Ct(e, r) {
      if (e === "click")
        return $(r);
    }
    function pr(e, r) {
      if (e === "input" || e === "change")
        return $(r);
    }
    function ve(e) {
      var r = e._wrapperState;
      !r || !r.controlled || e.type !== "number" || Zs(e, "number", e.value);
    }
    function pe(e, r, c, g, x, R, _) {
      var Y = c ? of(c) : window, U, J;
      if (k(Y) ? U = ie : uu(Y) ? de ? U = pr : (U = lt, J = Fe) : bt(Y) && (U = Ct), U) {
        var ne = U(r, c);
        if (ne) {
          i(e, ne, g, x);
          return;
        }
      }
      J && J(r, Y, c), r === "focusout" && ve(Y);
    }
    function Se() {
      qe("onMouseEnter", ["mouseout", "mouseover"]), qe("onMouseLeave", ["mouseout", "mouseover"]), qe("onPointerEnter", ["pointerout", "pointerover"]), qe("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function $e(e, r, c, g, x, R, _) {
      var Y = r === "mouseover" || r === "pointerover", U = r === "mouseout" || r === "pointerout";
      if (Y && !am(g)) {
        var J = g.relatedTarget || g.fromElement;
        if (J && (wc(J) || gp(J)))
          return;
      }
      if (!(!U && !Y)) {
        var ne;
        if (x.window === x)
          ne = x;
        else {
          var ge = x.ownerDocument;
          ge ? ne = ge.defaultView || ge.parentWindow : ne = window;
        }
        var he, Te;
        if (U) {
          var Ae = g.relatedTarget || g.toElement;
          if (he = c, Te = Ae ? wc(Ae) : null, Te !== null) {
            var Oe = ti(Te);
            (Te !== Oe || Te.tag !== ae && Te.tag !== se) && (Te = null);
          }
        } else
          he = null, Te = c;
        if (he !== Te) {
          var dt = mo, zt = "onMouseLeave", Rt = "onMouseEnter", hn = "mouse";
          (r === "pointerout" || r === "pointerover") && (dt = Zh, zt = "onPointerLeave", Rt = "onPointerEnter", hn = "pointer");
          var on = he == null ? ne : of(he), xe = Te == null ? ne : of(Te), De = new dt(zt, hn + "leave", he, g, x);
          De.target = on, De.relatedTarget = xe;
          var be = null, Ue = wc(x);
          if (Ue === c) {
            var ft = new dt(Rt, hn + "enter", Te, g, x);
            ft.target = xe, ft.relatedTarget = on, be = ft;
          }
          vL(e, De, be, he, Te);
        }
      }
    }
    function At(e, r) {
      return e === r && (e !== 0 || 1 / e === 1 / r) || e !== e && r !== r;
    }
    var wt = typeof Object.is == "function" ? Object.is : At;
    function Ot(e, r) {
      if (wt(e, r))
        return !0;
      if (typeof e != "object" || e === null || typeof r != "object" || r === null)
        return !1;
      var c = Object.keys(e), g = Object.keys(r);
      if (c.length !== g.length)
        return !1;
      for (var x = 0; x < c.length; x++) {
        var R = c[x];
        if (!jn.call(r, R) || !wt(e[R], r[R]))
          return !1;
      }
      return !0;
    }
    function Vt(e) {
      for (; e && e.firstChild; )
        e = e.firstChild;
      return e;
    }
    function Yr(e) {
      for (; e; ) {
        if (e.nextSibling)
          return e.nextSibling;
        e = e.parentNode;
      }
    }
    function gn(e, r) {
      for (var c = Vt(e), g = 0, x = 0; c; ) {
        if (c.nodeType === vs) {
          if (x = g + c.textContent.length, g <= r && x >= r)
            return {
              node: c,
              offset: r - g
            };
          g = x;
        }
        c = Vt(Yr(c));
      }
    }
    function yo(e) {
      var r = e.ownerDocument, c = r && r.defaultView || window, g = c.getSelection && c.getSelection();
      if (!g || g.rangeCount === 0)
        return null;
      var x = g.anchorNode, R = g.anchorOffset, _ = g.focusNode, Y = g.focusOffset;
      try {
        x.nodeType, _.nodeType;
      } catch {
        return null;
      }
      return Gx(e, x, R, _, Y);
    }
    function Gx(e, r, c, g, x) {
      var R = 0, _ = -1, Y = -1, U = 0, J = 0, ne = e, ge = null;
      e:
        for (; ; ) {
          for (var he = null; ne === r && (c === 0 || ne.nodeType === vs) && (_ = R + c), ne === g && (x === 0 || ne.nodeType === vs) && (Y = R + x), ne.nodeType === vs && (R += ne.nodeValue.length), (he = ne.firstChild) !== null; )
            ge = ne, ne = he;
          for (; ; ) {
            if (ne === e)
              break e;
            if (ge === r && ++U === c && (_ = R), ge === g && ++J === x && (Y = R), (he = ne.nextSibling) !== null)
              break;
            ne = ge, ge = ne.parentNode;
          }
          ne = he;
        }
      return _ === -1 || Y === -1 ? null : {
        start: _,
        end: Y
      };
    }
    function KR(e, r) {
      var c = e.ownerDocument || document, g = c && c.defaultView || window;
      if (g.getSelection) {
        var x = g.getSelection(), R = e.textContent.length, _ = Math.min(r.start, R), Y = r.end === void 0 ? _ : Math.min(r.end, R);
        if (!x.extend && _ > Y) {
          var U = Y;
          Y = _, _ = U;
        }
        var J = gn(e, _), ne = gn(e, Y);
        if (J && ne) {
          if (x.rangeCount === 1 && x.anchorNode === J.node && x.anchorOffset === J.offset && x.focusNode === ne.node && x.focusOffset === ne.offset)
            return;
          var ge = c.createRange();
          ge.setStart(J.node, J.offset), x.removeAllRanges(), _ > Y ? (x.addRange(ge), x.extend(ne.node, ne.offset)) : (ge.setEnd(ne.node, ne.offset), x.addRange(ge));
        }
      }
    }
    function vS(e) {
      return e && e.nodeType === vs;
    }
    function yS(e, r) {
      return !e || !r ? !1 : e === r ? !0 : vS(e) ? !1 : vS(r) ? yS(e, r.parentNode) : "contains" in e ? e.contains(r) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(r) & 16) : !1;
    }
    function JR(e) {
      return e && e.ownerDocument && yS(e.ownerDocument.documentElement, e);
    }
    function eL(e) {
      try {
        return typeof e.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function xS() {
      for (var e = window, r = Wc(); r instanceof e.HTMLIFrameElement; ) {
        if (eL(r))
          e = r.contentWindow;
        else
          return r;
        r = Wc(e.document);
      }
      return r;
    }
    function $x(e) {
      var r = e && e.nodeName && e.nodeName.toLowerCase();
      return r && (r === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || r === "textarea" || e.contentEditable === "true");
    }
    function tL() {
      var e = xS();
      return {
        focusedElem: e,
        selectionRange: $x(e) ? rL(e) : null
      };
    }
    function nL(e) {
      var r = xS(), c = e.focusedElem, g = e.selectionRange;
      if (r !== c && JR(c)) {
        g !== null && $x(c) && aL(c, g);
        for (var x = [], R = c; R = R.parentNode; )
          R.nodeType === _a && x.push({
            element: R,
            left: R.scrollLeft,
            top: R.scrollTop
          });
        typeof c.focus == "function" && c.focus();
        for (var _ = 0; _ < x.length; _++) {
          var Y = x[_];
          Y.element.scrollLeft = Y.left, Y.element.scrollTop = Y.top;
        }
      }
    }
    function rL(e) {
      var r;
      return "selectionStart" in e ? r = {
        start: e.selectionStart,
        end: e.selectionEnd
      } : r = yo(e), r || {
        start: 0,
        end: 0
      };
    }
    function aL(e, r) {
      var c = r.start, g = r.end;
      g === void 0 && (g = c), "selectionStart" in e ? (e.selectionStart = c, e.selectionEnd = Math.min(g, e.value.length)) : KR(e, r);
    }
    var iL = pn && "documentMode" in document && document.documentMode <= 11;
    function sL() {
      mn("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var tf = null, qx = null, np = null, Zx = !1;
    function oL(e) {
      if ("selectionStart" in e && $x(e))
        return {
          start: e.selectionStart,
          end: e.selectionEnd
        };
      var r = e.ownerDocument && e.ownerDocument.defaultView || window, c = r.getSelection();
      return {
        anchorNode: c.anchorNode,
        anchorOffset: c.anchorOffset,
        focusNode: c.focusNode,
        focusOffset: c.focusOffset
      };
    }
    function lL(e) {
      return e.window === e ? e.document : e.nodeType === Ii ? e : e.ownerDocument;
    }
    function bS(e, r, c) {
      var g = lL(c);
      if (!(Zx || tf == null || tf !== Wc(g))) {
        var x = oL(tf);
        if (!np || !Ot(np, x)) {
          np = x;
          var R = Xm(qx, "onSelect");
          if (R.length > 0) {
            var _ = new ga("onSelect", "select", null, r, c);
            e.push({
              event: _,
              listeners: R
            }), _.target = tf;
          }
        }
      }
    }
    function uL(e, r, c, g, x, R, _) {
      var Y = c ? of(c) : window;
      switch (r) {
        case "focusin":
          (uu(Y) || Y.contentEditable === "true") && (tf = Y, qx = c, np = null);
          break;
        case "focusout":
          tf = null, qx = null, np = null;
          break;
        case "mousedown":
          Zx = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Zx = !1, bS(e, g, x);
          break;
        case "selectionchange":
          if (iL)
            break;
        case "keydown":
        case "keyup":
          bS(e, g, x);
      }
    }
    function Bm(e, r) {
      var c = {};
      return c[e.toLowerCase()] = r.toLowerCase(), c["Webkit" + e] = "webkit" + r, c["Moz" + e] = "moz" + r, c;
    }
    var nf = {
      animationend: Bm("Animation", "AnimationEnd"),
      animationiteration: Bm("Animation", "AnimationIteration"),
      animationstart: Bm("Animation", "AnimationStart"),
      transitionend: Bm("Transition", "TransitionEnd")
    }, Qx = {}, wS = {};
    pn && (wS = document.createElement("div").style, "AnimationEvent" in window || (delete nf.animationend.animation, delete nf.animationiteration.animation, delete nf.animationstart.animation), "TransitionEvent" in window || delete nf.transitionend.transition);
    function Wm(e) {
      if (Qx[e])
        return Qx[e];
      if (!nf[e])
        return e;
      var r = nf[e];
      for (var c in r)
        if (r.hasOwnProperty(c) && c in wS)
          return Qx[e] = r[c];
      return e;
    }
    var SS = Wm("animationend"), kS = Wm("animationiteration"), CS = Wm("animationstart"), TS = Wm("transitionend"), AS = /* @__PURE__ */ new Map(), ES = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function cu(e, r) {
      AS.set(e, r), mn(r, [e]);
    }
    function cL() {
      for (var e = 0; e < ES.length; e++) {
        var r = ES[e], c = r.toLowerCase(), g = r[0].toUpperCase() + r.slice(1);
        cu(c, "on" + g);
      }
      cu(SS, "onAnimationEnd"), cu(kS, "onAnimationIteration"), cu(CS, "onAnimationStart"), cu("dblclick", "onDoubleClick"), cu("focusin", "onFocus"), cu("focusout", "onBlur"), cu(TS, "onTransitionEnd");
    }
    function dL(e, r, c, g, x, R, _) {
      var Y = AS.get(r);
      if (Y !== void 0) {
        var U = ga, J = r;
        switch (r) {
          case "keypress":
            if (rl(g) === 0)
              return;
          case "keydown":
          case "keyup":
            U = Hx;
            break;
          case "focusin":
            J = "focus", U = Xd;
            break;
          case "focusout":
            J = "blur", U = Xd;
            break;
          case "beforeblur":
          case "afterblur":
            U = Xd;
            break;
          case "click":
            if (g.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            U = mo;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            U = il;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            U = Ci;
            break;
          case SS:
          case kS:
          case CS:
            U = Vd;
            break;
          case TS:
            U = Bx;
            break;
          case "scroll":
            U = Xh;
            break;
          case "wheel":
            U = $d;
            break;
          case "copy":
          case "cut":
          case "paste":
            U = zx;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            U = Zh;
            break;
        }
        var ne = (R & Io) !== 0;
        {
          var ge = !ne && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          r === "scroll", he = gL(c, Y, g.type, ne, ge);
          if (he.length > 0) {
            var Te = new U(Y, J, null, g, x);
            e.push({
              event: Te,
              listeners: he
            });
          }
        }
      }
    }
    cL(), Se(), ef(), sL(), Fm();
    function fL(e, r, c, g, x, R, _) {
      dL(e, r, c, g, x, R);
      var Y = (R & kx) === 0;
      Y && ($e(e, r, c, g, x), pe(e, r, c, g, x), uL(e, r, c, g, x), Jd(e, r, c, g, x));
    }
    var rp = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], Kx = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(rp));
    function RS(e, r, c) {
      var g = e.type || "unknown-event";
      e.currentTarget = c, ws(g, r, void 0, e), e.currentTarget = null;
    }
    function hL(e, r, c) {
      var g;
      if (c)
        for (var x = r.length - 1; x >= 0; x--) {
          var R = r[x], _ = R.instance, Y = R.currentTarget, U = R.listener;
          if (_ !== g && e.isPropagationStopped())
            return;
          RS(e, U, Y), g = _;
        }
      else
        for (var J = 0; J < r.length; J++) {
          var ne = r[J], ge = ne.instance, he = ne.currentTarget, Te = ne.listener;
          if (ge !== g && e.isPropagationStopped())
            return;
          RS(e, Te, he), g = ge;
        }
    }
    function LS(e, r) {
      for (var c = (r & Io) !== 0, g = 0; g < e.length; g++) {
        var x = e[g], R = x.event, _ = x.listeners;
        hL(R, _, c);
      }
      hh();
    }
    function pL(e, r, c, g, x) {
      var R = nd(c), _ = [];
      fL(_, e, g, c, R, r), LS(_, r);
    }
    function er(e, r) {
      Kx.has(e) || A('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', e);
      var c = !1, g = UO(r), x = yL(e, c);
      g.has(x) || (OS(r, e, Wu, c), g.add(x));
    }
    function Jx(e, r, c) {
      Kx.has(e) && !r && A('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', e);
      var g = 0;
      r && (g |= Io), OS(c, e, g, r);
    }
    var Um = "_reactListening" + Math.random().toString(36).slice(2);
    function ap(e) {
      if (!e[Um]) {
        e[Um] = !0, Et.forEach(function(c) {
          c !== "selectionchange" && (Kx.has(c) || Jx(c, !1, e), Jx(c, !0, e));
        });
        var r = e.nodeType === Ii ? e : e.ownerDocument;
        r !== null && (r[Um] || (r[Um] = !0, Jx("selectionchange", !1, r)));
      }
    }
    function OS(e, r, c, g, x) {
      var R = nu(e, r, c), _ = void 0;
      $u && (r === "touchstart" || r === "touchmove" || r === "wheel") && (_ = !0), e = e, g ? _ !== void 0 ? Ls(e, r, R, _) : au(e, r, R) : _ !== void 0 ? Bd(e, r, R, _) : Uh(e, r, R);
    }
    function DS(e, r) {
      return e === r || e.nodeType === br && e.parentNode === r;
    }
    function eb(e, r, c, g, x) {
      var R = g;
      if (!(r & xs) && !(r & Wu)) {
        var _ = x;
        if (g !== null) {
          var Y = g;
          e:
            for (; ; ) {
              if (Y === null)
                return;
              var U = Y.tag;
              if (U === q || U === te) {
                var J = Y.stateNode.containerInfo;
                if (DS(J, _))
                  break;
                if (U === te)
                  for (var ne = Y.return; ne !== null; ) {
                    var ge = ne.tag;
                    if (ge === q || ge === te) {
                      var he = ne.stateNode.containerInfo;
                      if (DS(he, _))
                        return;
                    }
                    ne = ne.return;
                  }
                for (; J !== null; ) {
                  var Te = wc(J);
                  if (Te === null)
                    return;
                  var Ae = Te.tag;
                  if (Ae === ae || Ae === se) {
                    Y = R = Te;
                    continue e;
                  }
                  J = J.parentNode;
                }
              }
              Y = Y.return;
            }
        }
      }
      uh(function() {
        return pL(e, r, c, R);
      });
    }
    function ip(e, r, c) {
      return {
        instance: e,
        listener: r,
        currentTarget: c
      };
    }
    function gL(e, r, c, g, x, R) {
      for (var _ = r !== null ? r + "Capture" : null, Y = g ? _ : r, U = [], J = e, ne = null; J !== null; ) {
        var ge = J, he = ge.stateNode, Te = ge.tag;
        if (Te === ae && he !== null && (ne = he, Y !== null)) {
          var Ae = Yo(J, Y);
          Ae != null && U.push(ip(J, Ae, ne));
        }
        if (x)
          break;
        J = J.return;
      }
      return U;
    }
    function Xm(e, r) {
      for (var c = r + "Capture", g = [], x = e; x !== null; ) {
        var R = x, _ = R.stateNode, Y = R.tag;
        if (Y === ae && _ !== null) {
          var U = _, J = Yo(x, c);
          J != null && g.unshift(ip(x, J, U));
          var ne = Yo(x, r);
          ne != null && g.push(ip(x, ne, U));
        }
        x = x.return;
      }
      return g;
    }
    function rf(e) {
      if (e === null)
        return null;
      do
        e = e.return;
      while (e && e.tag !== ae);
      return e || null;
    }
    function mL(e, r) {
      for (var c = e, g = r, x = 0, R = c; R; R = rf(R))
        x++;
      for (var _ = 0, Y = g; Y; Y = rf(Y))
        _++;
      for (; x - _ > 0; )
        c = rf(c), x--;
      for (; _ - x > 0; )
        g = rf(g), _--;
      for (var U = x; U--; ) {
        if (c === g || g !== null && c === g.alternate)
          return c;
        c = rf(c), g = rf(g);
      }
      return null;
    }
    function MS(e, r, c, g, x) {
      for (var R = r._reactName, _ = [], Y = c; Y !== null && Y !== g; ) {
        var U = Y, J = U.alternate, ne = U.stateNode, ge = U.tag;
        if (J !== null && J === g)
          break;
        if (ge === ae && ne !== null) {
          var he = ne;
          if (x) {
            var Te = Yo(Y, R);
            Te != null && _.unshift(ip(Y, Te, he));
          } else if (!x) {
            var Ae = Yo(Y, R);
            Ae != null && _.push(ip(Y, Ae, he));
          }
        }
        Y = Y.return;
      }
      _.length !== 0 && e.push({
        event: r,
        listeners: _
      });
    }
    function vL(e, r, c, g, x) {
      var R = g && x ? mL(g, x) : null;
      g !== null && MS(e, r, g, R, !1), x !== null && c !== null && MS(e, c, x, R, !0);
    }
    function yL(e, r) {
      return e + "__" + (r ? "capture" : "bubble");
    }
    var Ti = !1, sp = "dangerouslySetInnerHTML", Vm = "suppressContentEditableWarning", du = "suppressHydrationWarning", _S = "autoFocus", xc = "children", bc = "style", Gm = "__html", tb, $m, op, PS, qm, NS, zS;
    tb = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, $m = function(e, r) {
      td(e, r), ah(e, r), rm(e, r, {
        registrationNameDependencies: Ht,
        possibleRegistrationNames: Wt
      });
    }, NS = pn && !document.documentMode, op = function(e, r, c) {
      if (!Ti) {
        var g = Zm(c), x = Zm(r);
        x !== g && (Ti = !0, A("Prop `%s` did not match. Server: %s Client: %s", e, JSON.stringify(x), JSON.stringify(g)));
      }
    }, PS = function(e) {
      if (!Ti) {
        Ti = !0;
        var r = [];
        e.forEach(function(c) {
          r.push(c);
        }), A("Extra attributes from the server: %s", r);
      }
    }, qm = function(e, r) {
      r === !1 ? A("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", e, e, e) : A("Expected `%s` listener to be a function, instead got a value of `%s` type.", e, typeof r);
    }, zS = function(e, r) {
      var c = e.namespaceURI === ms ? e.ownerDocument.createElement(e.tagName) : e.ownerDocument.createElementNS(e.namespaceURI, e.tagName);
      return c.innerHTML = r, c.innerHTML;
    };
    var xL = /\r\n?/g, bL = /\u0000|\uFFFD/g;
    function Zm(e) {
      Qa(e);
      var r = typeof e == "string" ? e : "" + e;
      return r.replace(xL, `
`).replace(bL, "");
    }
    function Qm(e, r, c, g) {
      var x = Zm(r), R = Zm(e);
      if (R !== x && (g && (Ti || (Ti = !0, A('Text content did not match. Server: "%s" Client: "%s"', R, x))), c && Jt))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function IS(e) {
      return e.nodeType === Ii ? e : e.ownerDocument;
    }
    function wL() {
    }
    function Km(e) {
      e.onclick = wL;
    }
    function SL(e, r, c, g, x) {
      for (var R in g)
        if (g.hasOwnProperty(R)) {
          var _ = g[R];
          if (R === bc)
            _ && Object.freeze(_), Gg(r, _);
          else if (R === sp) {
            var Y = _ ? _[Gm] : void 0;
            Y != null && zg(r, Y);
          } else if (R === xc)
            if (typeof _ == "string") {
              var U = e !== "textarea" || _ !== "";
              U && Qc(r, _);
            } else
              typeof _ == "number" && Qc(r, "" + _);
          else
            R === Vm || R === du || R === _S || (Ht.hasOwnProperty(R) ? _ != null && (typeof _ != "function" && qm(R, _), R === "onScroll" && er("scroll", r)) : _ != null && Ma(r, R, _, x));
        }
    }
    function kL(e, r, c, g) {
      for (var x = 0; x < r.length; x += 2) {
        var R = r[x], _ = r[x + 1];
        R === bc ? Gg(e, _) : R === sp ? zg(e, _) : R === xc ? Qc(e, _) : Ma(e, R, _, g);
      }
    }
    function CL(e, r, c, g) {
      var x, R = IS(c), _, Y = g;
      if (Y === ms && (Y = qc(e)), Y === ms) {
        if (x = ys(e, r), !x && e !== e.toLowerCase() && A("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", e), e === "script") {
          var U = R.createElement("div");
          U.innerHTML = "<script><\/script>";
          var J = U.firstChild;
          _ = U.removeChild(J);
        } else if (typeof r.is == "string")
          _ = R.createElement(e, {
            is: r.is
          });
        else if (_ = R.createElement(e), e === "select") {
          var ne = _;
          r.multiple ? ne.multiple = !0 : r.size && (ne.size = r.size);
        }
      } else
        _ = R.createElementNS(Y, e);
      return Y === ms && !x && Object.prototype.toString.call(_) === "[object HTMLUnknownElement]" && !jn.call(tb, e) && (tb[e] = !0, A("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", e)), _;
    }
    function TL(e, r) {
      return IS(r).createTextNode(e);
    }
    function AL(e, r, c, g) {
      var x = ys(r, c);
      $m(r, c);
      var R;
      switch (r) {
        case "dialog":
          er("cancel", e), er("close", e), R = c;
          break;
        case "iframe":
        case "object":
        case "embed":
          er("load", e), R = c;
          break;
        case "video":
        case "audio":
          for (var _ = 0; _ < rp.length; _++)
            er(rp[_], e);
          R = c;
          break;
        case "source":
          er("error", e), R = c;
          break;
        case "img":
        case "image":
        case "link":
          er("error", e), er("load", e), R = c;
          break;
        case "details":
          er("toggle", e), R = c;
          break;
        case "input":
          Iu(e, c), R = zu(e, c), er("invalid", e);
          break;
        case "option":
          Gc(e, c), R = c;
          break;
        case "select":
          Mg(e, c), R = Gf(e, c), er("invalid", e);
          break;
        case "textarea":
          _g(e, c), R = qf(e, c), er("invalid", e);
          break;
        default:
          R = c;
      }
      switch (Jc(r, R), SL(r, e, g, R, x), r) {
        case "input":
          Po(e), Fu(e, c, !1);
          break;
        case "textarea":
          Po(e), Ng(e);
          break;
        case "option":
          Vf(e, c);
          break;
        case "select":
          fx(e, c);
          break;
        default:
          typeof R.onClick == "function" && Km(e);
          break;
      }
    }
    function EL(e, r, c, g, x) {
      $m(r, g);
      var R = null, _, Y;
      switch (r) {
        case "input":
          _ = zu(e, c), Y = zu(e, g), R = [];
          break;
        case "select":
          _ = Gf(e, c), Y = Gf(e, g), R = [];
          break;
        case "textarea":
          _ = qf(e, c), Y = qf(e, g), R = [];
          break;
        default:
          _ = c, Y = g, typeof _.onClick != "function" && typeof Y.onClick == "function" && Km(e);
          break;
      }
      Jc(r, Y);
      var U, J, ne = null;
      for (U in _)
        if (!(Y.hasOwnProperty(U) || !_.hasOwnProperty(U) || _[U] == null))
          if (U === bc) {
            var ge = _[U];
            for (J in ge)
              ge.hasOwnProperty(J) && (ne || (ne = {}), ne[J] = "");
          } else
            U === sp || U === xc || U === Vm || U === du || U === _S || (Ht.hasOwnProperty(U) ? R || (R = []) : (R = R || []).push(U, null));
      for (U in Y) {
        var he = Y[U], Te = _ != null ? _[U] : void 0;
        if (!(!Y.hasOwnProperty(U) || he === Te || he == null && Te == null))
          if (U === bc)
            if (he && Object.freeze(he), Te) {
              for (J in Te)
                Te.hasOwnProperty(J) && (!he || !he.hasOwnProperty(J)) && (ne || (ne = {}), ne[J] = "");
              for (J in he)
                he.hasOwnProperty(J) && Te[J] !== he[J] && (ne || (ne = {}), ne[J] = he[J]);
            } else
              ne || (R || (R = []), R.push(U, ne)), ne = he;
          else if (U === sp) {
            var Ae = he ? he[Gm] : void 0, Oe = Te ? Te[Gm] : void 0;
            Ae != null && Oe !== Ae && (R = R || []).push(U, Ae);
          } else
            U === xc ? (typeof he == "string" || typeof he == "number") && (R = R || []).push(U, "" + he) : U === Vm || U === du || (Ht.hasOwnProperty(U) ? (he != null && (typeof he != "function" && qm(U, he), U === "onScroll" && er("scroll", e)), !R && Te !== he && (R = [])) : (R = R || []).push(U, he));
      }
      return ne && (ju(ne, Y[bc]), (R = R || []).push(bc, ne)), R;
    }
    function RL(e, r, c, g, x) {
      c === "input" && x.type === "radio" && x.name != null && Xf(e, x);
      var R = ys(c, g), _ = ys(c, x);
      switch (kL(e, r, R, _), c) {
        case "input":
          _l(e, x);
          break;
        case "textarea":
          Pg(e, x);
          break;
        case "select":
          hx(e, x);
          break;
      }
    }
    function LL(e) {
      {
        var r = e.toLowerCase();
        return ed.hasOwnProperty(r) && ed[r] || null;
      }
    }
    function OL(e, r, c, g, x, R, _) {
      var Y, U;
      switch (Y = ys(r, c), $m(r, c), r) {
        case "dialog":
          er("cancel", e), er("close", e);
          break;
        case "iframe":
        case "object":
        case "embed":
          er("load", e);
          break;
        case "video":
        case "audio":
          for (var J = 0; J < rp.length; J++)
            er(rp[J], e);
          break;
        case "source":
          er("error", e);
          break;
        case "img":
        case "image":
        case "link":
          er("error", e), er("load", e);
          break;
        case "details":
          er("toggle", e);
          break;
        case "input":
          Iu(e, c), er("invalid", e);
          break;
        case "option":
          Gc(e, c);
          break;
        case "select":
          Mg(e, c), er("invalid", e);
          break;
        case "textarea":
          _g(e, c), er("invalid", e);
          break;
      }
      Jc(r, c);
      {
        U = /* @__PURE__ */ new Set();
        for (var ne = e.attributes, ge = 0; ge < ne.length; ge++) {
          var he = ne[ge].name.toLowerCase();
          switch (he) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              U.add(ne[ge].name);
          }
        }
      }
      var Te = null;
      for (var Ae in c)
        if (c.hasOwnProperty(Ae)) {
          var Oe = c[Ae];
          if (Ae === xc)
            typeof Oe == "string" ? e.textContent !== Oe && (c[du] !== !0 && Qm(e.textContent, Oe, R, _), Te = [xc, Oe]) : typeof Oe == "number" && e.textContent !== "" + Oe && (c[du] !== !0 && Qm(e.textContent, Oe, R, _), Te = [xc, "" + Oe]);
          else if (Ht.hasOwnProperty(Ae))
            Oe != null && (typeof Oe != "function" && qm(Ae, Oe), Ae === "onScroll" && er("scroll", e));
          else if (_ && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof Y == "boolean") {
            var dt = void 0, zt = Y && kt ? null : yr(Ae);
            if (c[du] !== !0) {
              if (!(Ae === Vm || Ae === du || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              Ae === "value" || Ae === "checked" || Ae === "selected")) {
                if (Ae === sp) {
                  var Rt = e.innerHTML, hn = Oe ? Oe[Gm] : void 0;
                  if (hn != null) {
                    var on = zS(e, hn);
                    on !== Rt && op(Ae, Rt, on);
                  }
                } else if (Ae === bc) {
                  if (U.delete(Ae), NS) {
                    var xe = wx(Oe);
                    dt = e.getAttribute("style"), xe !== dt && op(Ae, dt, xe);
                  }
                } else if (Y && !kt)
                  U.delete(Ae.toLowerCase()), dt = $s(e, Ae, Oe), Oe !== dt && op(Ae, dt, Oe);
                else if (!$n(Ae, zt, Y) && !Ln(Ae, Oe, zt, Y)) {
                  var De = !1;
                  if (zt !== null)
                    U.delete(zt.attributeName), dt = ps(e, Ae, Oe, zt);
                  else {
                    var be = g;
                    if (be === ms && (be = qc(r)), be === ms)
                      U.delete(Ae.toLowerCase());
                    else {
                      var Ue = LL(Ae);
                      Ue !== null && Ue !== Ae && (De = !0, U.delete(Ue)), U.delete(Ae);
                    }
                    dt = $s(e, Ae, Oe);
                  }
                  var ft = kt;
                  !ft && Oe !== dt && !De && op(Ae, dt, Oe);
                }
              }
            }
          }
        }
      switch (_ && // $FlowFixMe - Should be inferred as not undefined.
      U.size > 0 && c[du] !== !0 && PS(U), r) {
        case "input":
          Po(e), Fu(e, c, !0);
          break;
        case "textarea":
          Po(e), Ng(e);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof c.onClick == "function" && Km(e);
          break;
      }
      return Te;
    }
    function DL(e, r, c) {
      var g = e.nodeValue !== r;
      return g;
    }
    function nb(e, r) {
      {
        if (Ti)
          return;
        Ti = !0, A("Did not expect server HTML to contain a <%s> in <%s>.", r.nodeName.toLowerCase(), e.nodeName.toLowerCase());
      }
    }
    function rb(e, r) {
      {
        if (Ti)
          return;
        Ti = !0, A('Did not expect server HTML to contain the text node "%s" in <%s>.', r.nodeValue, e.nodeName.toLowerCase());
      }
    }
    function ab(e, r, c) {
      {
        if (Ti)
          return;
        Ti = !0, A("Expected server HTML to contain a matching <%s> in <%s>.", r, e.nodeName.toLowerCase());
      }
    }
    function ib(e, r) {
      {
        if (r === "" || Ti)
          return;
        Ti = !0, A('Expected server HTML to contain a matching text node for "%s" in <%s>.', r, e.nodeName.toLowerCase());
      }
    }
    function ML(e, r, c) {
      switch (r) {
        case "input":
          Rg(e, c);
          return;
        case "textarea":
          Zf(e, c);
          return;
        case "select":
          px(e, c);
          return;
      }
    }
    var lp = function() {
    }, up = function() {
    };
    {
      var _L = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], FS = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], PL = FS.concat(["button"]), NL = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], YS = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      up = function(e, r) {
        var c = p({}, e || YS), g = {
          tag: r
        };
        return FS.indexOf(r) !== -1 && (c.aTagInScope = null, c.buttonTagInScope = null, c.nobrTagInScope = null), PL.indexOf(r) !== -1 && (c.pTagInButtonScope = null), _L.indexOf(r) !== -1 && r !== "address" && r !== "div" && r !== "p" && (c.listItemTagAutoclosing = null, c.dlItemTagAutoclosing = null), c.current = g, r === "form" && (c.formTag = g), r === "a" && (c.aTagInScope = g), r === "button" && (c.buttonTagInScope = g), r === "nobr" && (c.nobrTagInScope = g), r === "p" && (c.pTagInButtonScope = g), r === "li" && (c.listItemTagAutoclosing = g), (r === "dd" || r === "dt") && (c.dlItemTagAutoclosing = g), c;
      };
      var zL = function(e, r) {
        switch (r) {
          case "select":
            return e === "option" || e === "optgroup" || e === "#text";
          case "optgroup":
            return e === "option" || e === "#text";
          case "option":
            return e === "#text";
          case "tr":
            return e === "th" || e === "td" || e === "style" || e === "script" || e === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return e === "tr" || e === "style" || e === "script" || e === "template";
          case "colgroup":
            return e === "col" || e === "template";
          case "table":
            return e === "caption" || e === "colgroup" || e === "tbody" || e === "tfoot" || e === "thead" || e === "style" || e === "script" || e === "template";
          case "head":
            return e === "base" || e === "basefont" || e === "bgsound" || e === "link" || e === "meta" || e === "title" || e === "noscript" || e === "noframes" || e === "style" || e === "script" || e === "template";
          case "html":
            return e === "head" || e === "body" || e === "frameset";
          case "frameset":
            return e === "frame";
          case "#document":
            return e === "html";
        }
        switch (e) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return r !== "h1" && r !== "h2" && r !== "h3" && r !== "h4" && r !== "h5" && r !== "h6";
          case "rp":
          case "rt":
            return NL.indexOf(r) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return r == null;
        }
        return !0;
      }, IL = function(e, r) {
        switch (e) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return r.pTagInButtonScope;
          case "form":
            return r.formTag || r.pTagInButtonScope;
          case "li":
            return r.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return r.dlItemTagAutoclosing;
          case "button":
            return r.buttonTagInScope;
          case "a":
            return r.aTagInScope;
          case "nobr":
            return r.nobrTagInScope;
        }
        return null;
      }, HS = {};
      lp = function(e, r, c) {
        c = c || YS;
        var g = c.current, x = g && g.tag;
        r != null && (e != null && A("validateDOMNesting: when childText is passed, childTag should be null"), e = "#text");
        var R = zL(e, x) ? null : g, _ = R ? null : IL(e, c), Y = R || _;
        if (Y) {
          var U = Y.tag, J = !!R + "|" + e + "|" + U;
          if (!HS[J]) {
            HS[J] = !0;
            var ne = e, ge = "";
            if (e === "#text" ? /\S/.test(r) ? ne = "Text nodes" : (ne = "Whitespace text nodes", ge = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : ne = "<" + e + ">", R) {
              var he = "";
              U === "table" && e === "tr" && (he += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), A("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", ne, U, ge, he);
            } else
              A("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", ne, U);
          }
        }
      };
    }
    var Jm = "suppressHydrationWarning", ev = "$", tv = "/$", cp = "$?", dp = "$!", FL = "style", sb = null, ob = null;
    function YL(e) {
      var r, c, g = e.nodeType;
      switch (g) {
        case Ii:
        case No: {
          r = g === Ii ? "#document" : "#fragment";
          var x = e.documentElement;
          c = x ? x.namespaceURI : Kf(null, "");
          break;
        }
        default: {
          var R = g === br ? e.parentNode : e, _ = R.namespaceURI || null;
          r = R.tagName, c = Kf(_, r);
          break;
        }
      }
      {
        var Y = r.toLowerCase(), U = up(null, Y);
        return {
          namespace: c,
          ancestorInfo: U
        };
      }
    }
    function HL(e, r, c) {
      {
        var g = e, x = Kf(g.namespace, r), R = up(g.ancestorInfo, r);
        return {
          namespace: x,
          ancestorInfo: R
        };
      }
    }
    function Fj(e) {
      return e;
    }
    function jL(e) {
      sb = ii(), ob = tL();
      var r = null;
      return Fr(!1), r;
    }
    function BL(e) {
      nL(ob), Fr(sb), sb = null, ob = null;
    }
    function WL(e, r, c, g, x) {
      var R;
      {
        var _ = g;
        if (lp(e, null, _.ancestorInfo), typeof r.children == "string" || typeof r.children == "number") {
          var Y = "" + r.children, U = up(_.ancestorInfo, e);
          lp(null, Y, U);
        }
        R = _.namespace;
      }
      var J = CL(e, r, c, R);
      return pp(x, J), gb(J, r), J;
    }
    function UL(e, r) {
      e.appendChild(r);
    }
    function XL(e, r, c, g, x) {
      switch (AL(e, r, c, g), r) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!c.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function VL(e, r, c, g, x, R) {
      {
        var _ = R;
        if (typeof g.children != typeof c.children && (typeof g.children == "string" || typeof g.children == "number")) {
          var Y = "" + g.children, U = up(_.ancestorInfo, r);
          lp(null, Y, U);
        }
      }
      return EL(e, r, c, g);
    }
    function lb(e, r) {
      return e === "textarea" || e === "noscript" || typeof r.children == "string" || typeof r.children == "number" || typeof r.dangerouslySetInnerHTML == "object" && r.dangerouslySetInnerHTML !== null && r.dangerouslySetInnerHTML.__html != null;
    }
    function GL(e, r, c, g) {
      {
        var x = c;
        lp(null, e, x.ancestorInfo);
      }
      var R = TL(e, r);
      return pp(g, R), R;
    }
    function $L() {
      var e = window.event;
      return e === void 0 ? As : wa(e.type);
    }
    var ub = typeof setTimeout == "function" ? setTimeout : void 0, qL = typeof clearTimeout == "function" ? clearTimeout : void 0, cb = -1, jS = typeof Promise == "function" ? Promise : void 0, ZL = typeof queueMicrotask == "function" ? queueMicrotask : typeof jS < "u" ? function(e) {
      return jS.resolve(null).then(e).catch(QL);
    } : ub;
    function QL(e) {
      setTimeout(function() {
        throw e;
      });
    }
    function KL(e, r, c, g) {
      switch (r) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          c.autoFocus && e.focus();
          return;
        case "img": {
          c.src && (e.src = c.src);
          return;
        }
      }
    }
    function JL(e, r, c, g, x, R) {
      RL(e, r, c, g, x), gb(e, x);
    }
    function BS(e) {
      Qc(e, "");
    }
    function eO(e, r, c) {
      e.nodeValue = c;
    }
    function tO(e, r) {
      e.appendChild(r);
    }
    function nO(e, r) {
      var c;
      e.nodeType === br ? (c = e.parentNode, c.insertBefore(r, e)) : (c = e, c.appendChild(r));
      var g = e._reactRootContainer;
      g == null && c.onclick === null && Km(c);
    }
    function rO(e, r, c) {
      e.insertBefore(r, c);
    }
    function aO(e, r, c) {
      e.nodeType === br ? e.parentNode.insertBefore(r, c) : e.insertBefore(r, c);
    }
    function iO(e, r) {
      e.removeChild(r);
    }
    function sO(e, r) {
      e.nodeType === br ? e.parentNode.removeChild(r) : e.removeChild(r);
    }
    function db(e, r) {
      var c = r, g = 0;
      do {
        var x = c.nextSibling;
        if (e.removeChild(c), x && x.nodeType === br) {
          var R = x.data;
          if (R === tv)
            if (g === 0) {
              e.removeChild(x), sn(r);
              return;
            } else
              g--;
          else
            (R === ev || R === cp || R === dp) && g++;
        }
        c = x;
      } while (c);
      sn(r);
    }
    function oO(e, r) {
      e.nodeType === br ? db(e.parentNode, r) : e.nodeType === _a && db(e, r), sn(e);
    }
    function lO(e) {
      e = e;
      var r = e.style;
      typeof r.setProperty == "function" ? r.setProperty("display", "none", "important") : r.display = "none";
    }
    function uO(e) {
      e.nodeValue = "";
    }
    function cO(e, r) {
      e = e;
      var c = r[FL], g = c != null && c.hasOwnProperty("display") ? c.display : null;
      e.style.display = Kc("display", g);
    }
    function dO(e, r) {
      e.nodeValue = r;
    }
    function fO(e) {
      e.nodeType === _a ? e.textContent = "" : e.nodeType === Ii && e.documentElement && e.removeChild(e.documentElement);
    }
    function hO(e, r, c) {
      return e.nodeType !== _a || r.toLowerCase() !== e.nodeName.toLowerCase() ? null : e;
    }
    function pO(e, r) {
      return r === "" || e.nodeType !== vs ? null : e;
    }
    function gO(e) {
      return e.nodeType !== br ? null : e;
    }
    function WS(e) {
      return e.data === cp;
    }
    function fb(e) {
      return e.data === dp;
    }
    function mO(e) {
      var r = e.nextSibling && e.nextSibling.dataset, c, g, x;
      return r && (c = r.dgst, g = r.msg, x = r.stck), {
        message: g,
        digest: c,
        stack: x
      };
    }
    function vO(e, r) {
      e._reactRetry = r;
    }
    function nv(e) {
      for (; e != null; e = e.nextSibling) {
        var r = e.nodeType;
        if (r === _a || r === vs)
          break;
        if (r === br) {
          var c = e.data;
          if (c === ev || c === dp || c === cp)
            break;
          if (c === tv)
            return null;
        }
      }
      return e;
    }
    function fp(e) {
      return nv(e.nextSibling);
    }
    function yO(e) {
      return nv(e.firstChild);
    }
    function xO(e) {
      return nv(e.firstChild);
    }
    function bO(e) {
      return nv(e.nextSibling);
    }
    function wO(e, r, c, g, x, R, _) {
      pp(R, e), gb(e, c);
      var Y;
      {
        var U = x;
        Y = U.namespace;
      }
      var J = (R.mode & rn) !== Ft;
      return OL(e, r, c, Y, g, J, _);
    }
    function SO(e, r, c, g) {
      return pp(c, e), c.mode & rn, DL(e, r);
    }
    function kO(e, r) {
      pp(r, e);
    }
    function CO(e) {
      for (var r = e.nextSibling, c = 0; r; ) {
        if (r.nodeType === br) {
          var g = r.data;
          if (g === tv) {
            if (c === 0)
              return fp(r);
            c--;
          } else
            (g === ev || g === dp || g === cp) && c++;
        }
        r = r.nextSibling;
      }
      return null;
    }
    function US(e) {
      for (var r = e.previousSibling, c = 0; r; ) {
        if (r.nodeType === br) {
          var g = r.data;
          if (g === ev || g === dp || g === cp) {
            if (c === 0)
              return r;
            c--;
          } else
            g === tv && c++;
        }
        r = r.previousSibling;
      }
      return null;
    }
    function TO(e) {
      sn(e);
    }
    function AO(e) {
      sn(e);
    }
    function EO(e) {
      return e !== "head" && e !== "body";
    }
    function RO(e, r, c, g) {
      var x = !0;
      Qm(r.nodeValue, c, g, x);
    }
    function LO(e, r, c, g, x, R) {
      if (r[Jm] !== !0) {
        var _ = !0;
        Qm(g.nodeValue, x, R, _);
      }
    }
    function OO(e, r) {
      r.nodeType === _a ? nb(e, r) : r.nodeType === br || rb(e, r);
    }
    function DO(e, r) {
      {
        var c = e.parentNode;
        c !== null && (r.nodeType === _a ? nb(c, r) : r.nodeType === br || rb(c, r));
      }
    }
    function MO(e, r, c, g, x) {
      (x || r[Jm] !== !0) && (g.nodeType === _a ? nb(c, g) : g.nodeType === br || rb(c, g));
    }
    function _O(e, r, c) {
      ab(e, r);
    }
    function PO(e, r) {
      ib(e, r);
    }
    function NO(e, r, c) {
      {
        var g = e.parentNode;
        g !== null && ab(g, r);
      }
    }
    function zO(e, r) {
      {
        var c = e.parentNode;
        c !== null && ib(c, r);
      }
    }
    function IO(e, r, c, g, x, R) {
      (R || r[Jm] !== !0) && ab(c, g);
    }
    function FO(e, r, c, g, x) {
      (x || r[Jm] !== !0) && ib(c, g);
    }
    function YO(e) {
      A("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", e.nodeName.toLowerCase());
    }
    function HO(e) {
      ap(e);
    }
    var af = Math.random().toString(36).slice(2), sf = "__reactFiber$" + af, hb = "__reactProps$" + af, hp = "__reactContainer$" + af, pb = "__reactEvents$" + af, jO = "__reactListeners$" + af, BO = "__reactHandles$" + af;
    function WO(e) {
      delete e[sf], delete e[hb], delete e[pb], delete e[jO], delete e[BO];
    }
    function pp(e, r) {
      r[sf] = e;
    }
    function rv(e, r) {
      r[hp] = e;
    }
    function XS(e) {
      e[hp] = null;
    }
    function gp(e) {
      return !!e[hp];
    }
    function wc(e) {
      var r = e[sf];
      if (r)
        return r;
      for (var c = e.parentNode; c; ) {
        if (r = c[hp] || c[sf], r) {
          var g = r.alternate;
          if (r.child !== null || g !== null && g.child !== null)
            for (var x = US(e); x !== null; ) {
              var R = x[sf];
              if (R)
                return R;
              x = US(x);
            }
          return r;
        }
        e = c, c = e.parentNode;
      }
      return null;
    }
    function fu(e) {
      var r = e[sf] || e[hp];
      return r && (r.tag === ae || r.tag === se || r.tag === re || r.tag === q) ? r : null;
    }
    function of(e) {
      if (e.tag === ae || e.tag === se)
        return e.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function av(e) {
      return e[hb] || null;
    }
    function gb(e, r) {
      e[hb] = r;
    }
    function UO(e) {
      var r = e[pb];
      return r === void 0 && (r = e[pb] = /* @__PURE__ */ new Set()), r;
    }
    var VS = {}, GS = h.ReactDebugCurrentFrame;
    function iv(e) {
      if (e) {
        var r = e._owner, c = Le(e.type, e._source, r ? r.type : null);
        GS.setExtraStackFrame(c);
      } else
        GS.setExtraStackFrame(null);
    }
    function Ds(e, r, c, g, x) {
      {
        var R = Function.call.bind(jn);
        for (var _ in e)
          if (R(e, _)) {
            var Y = void 0;
            try {
              if (typeof e[_] != "function") {
                var U = Error((g || "React class") + ": " + c + " type `" + _ + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e[_] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw U.name = "Invariant Violation", U;
              }
              Y = e[_](r, _, g, c, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (J) {
              Y = J;
            }
            Y && !(Y instanceof Error) && (iv(x), A("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", g || "React class", c, _, typeof Y), iv(null)), Y instanceof Error && !(Y.message in VS) && (VS[Y.message] = !0, iv(x), A("Failed %s type: %s", c, Y.message), iv(null));
          }
      }
    }
    var mb = [], sv;
    sv = [];
    var ul = -1;
    function hu(e) {
      return {
        current: e
      };
    }
    function Ba(e, r) {
      if (ul < 0) {
        A("Unexpected pop.");
        return;
      }
      r !== sv[ul] && A("Unexpected Fiber popped."), e.current = mb[ul], mb[ul] = null, sv[ul] = null, ul--;
    }
    function Wa(e, r, c) {
      ul++, mb[ul] = e.current, sv[ul] = c, e.current = r;
    }
    var vb;
    vb = {};
    var Bi = {};
    Object.freeze(Bi);
    var cl = hu(Bi), xo = hu(!1), yb = Bi;
    function lf(e, r, c) {
      return c && bo(r) ? yb : cl.current;
    }
    function $S(e, r, c) {
      {
        var g = e.stateNode;
        g.__reactInternalMemoizedUnmaskedChildContext = r, g.__reactInternalMemoizedMaskedChildContext = c;
      }
    }
    function uf(e, r) {
      {
        var c = e.type, g = c.contextTypes;
        if (!g)
          return Bi;
        var x = e.stateNode;
        if (x && x.__reactInternalMemoizedUnmaskedChildContext === r)
          return x.__reactInternalMemoizedMaskedChildContext;
        var R = {};
        for (var _ in g)
          R[_] = r[_];
        {
          var Y = vt(e) || "Unknown";
          Ds(g, R, "context", Y);
        }
        return x && $S(e, r, R), R;
      }
    }
    function ov() {
      return xo.current;
    }
    function bo(e) {
      {
        var r = e.childContextTypes;
        return r != null;
      }
    }
    function lv(e) {
      Ba(xo, e), Ba(cl, e);
    }
    function xb(e) {
      Ba(xo, e), Ba(cl, e);
    }
    function qS(e, r, c) {
      {
        if (cl.current !== Bi)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Wa(cl, r, e), Wa(xo, c, e);
      }
    }
    function ZS(e, r, c) {
      {
        var g = e.stateNode, x = r.childContextTypes;
        if (typeof g.getChildContext != "function") {
          {
            var R = vt(e) || "Unknown";
            vb[R] || (vb[R] = !0, A("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", R, R));
          }
          return c;
        }
        var _ = g.getChildContext();
        for (var Y in _)
          if (!(Y in x))
            throw new Error((vt(e) || "Unknown") + '.getChildContext(): key "' + Y + '" is not defined in childContextTypes.');
        {
          var U = vt(e) || "Unknown";
          Ds(x, _, "child context", U);
        }
        return p({}, c, _);
      }
    }
    function uv(e) {
      {
        var r = e.stateNode, c = r && r.__reactInternalMemoizedMergedChildContext || Bi;
        return yb = cl.current, Wa(cl, c, e), Wa(xo, xo.current, e), !0;
      }
    }
    function QS(e, r, c) {
      {
        var g = e.stateNode;
        if (!g)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (c) {
          var x = ZS(e, r, yb);
          g.__reactInternalMemoizedMergedChildContext = x, Ba(xo, e), Ba(cl, e), Wa(cl, x, e), Wa(xo, c, e);
        } else
          Ba(xo, e), Wa(xo, c, e);
      }
    }
    function XO(e) {
      {
        if (!yh(e) || e.tag !== j)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var r = e;
        do {
          switch (r.tag) {
            case q:
              return r.stateNode.context;
            case j: {
              var c = r.type;
              if (bo(c))
                return r.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          r = r.return;
        } while (r !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var pu = 0, cv = 1, dl = null, bb = !1, wb = !1;
    function KS(e) {
      dl === null ? dl = [e] : dl.push(e);
    }
    function VO(e) {
      bb = !0, KS(e);
    }
    function JS() {
      bb && gu();
    }
    function gu() {
      if (!wb && dl !== null) {
        wb = !0;
        var e = 0, r = wi();
        try {
          var c = !0, g = dl;
          for (Ar(ca); e < g.length; e++) {
            var x = g[e];
            do
              x = x(c);
            while (x !== null);
          }
          dl = null, bb = !1;
        } catch (R) {
          throw dl !== null && (dl = dl.slice(e + 1)), ud(dd, gu), R;
        } finally {
          Ar(r), wb = !1;
        }
      }
      return null;
    }
    var cf = [], df = 0, dv = null, fv = 0, es = [], ts = 0, Sc = null, fl = 1, hl = "";
    function GO(e) {
      return Cc(), (e.flags & gh) !== _t;
    }
    function $O(e) {
      return Cc(), fv;
    }
    function qO() {
      var e = hl, r = fl, c = r & ~ZO(r);
      return c.toString(32) + e;
    }
    function kc(e, r) {
      Cc(), cf[df++] = fv, cf[df++] = dv, dv = e, fv = r;
    }
    function ek(e, r, c) {
      Cc(), es[ts++] = fl, es[ts++] = hl, es[ts++] = Sc, Sc = e;
      var g = fl, x = hl, R = hv(g) - 1, _ = g & ~(1 << R), Y = c + 1, U = hv(r) + R;
      if (U > 30) {
        var J = R - R % 5, ne = (1 << J) - 1, ge = (_ & ne).toString(32), he = _ >> J, Te = R - J, Ae = hv(r) + Te, Oe = Y << Te, dt = Oe | he, zt = ge + x;
        fl = 1 << Ae | dt, hl = zt;
      } else {
        var Rt = Y << R, hn = Rt | _, on = x;
        fl = 1 << U | hn, hl = on;
      }
    }
    function Sb(e) {
      Cc();
      var r = e.return;
      if (r !== null) {
        var c = 1, g = 0;
        kc(e, c), ek(e, c, g);
      }
    }
    function hv(e) {
      return 32 - vd(e);
    }
    function ZO(e) {
      return 1 << hv(e) - 1;
    }
    function kb(e) {
      for (; e === dv; )
        dv = cf[--df], cf[df] = null, fv = cf[--df], cf[df] = null;
      for (; e === Sc; )
        Sc = es[--ts], es[ts] = null, hl = es[--ts], es[ts] = null, fl = es[--ts], es[ts] = null;
    }
    function QO() {
      return Cc(), Sc !== null ? {
        id: fl,
        overflow: hl
      } : null;
    }
    function KO(e, r) {
      Cc(), es[ts++] = fl, es[ts++] = hl, es[ts++] = Sc, fl = r.id, hl = r.overflow, Sc = e;
    }
    function Cc() {
      ka() || A("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Sa = null, ns = null, Ms = !1, Tc = !1, mu = null;
    function JO() {
      Ms && A("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function tk() {
      Tc = !0;
    }
    function eD() {
      return Tc;
    }
    function tD(e) {
      var r = e.stateNode.containerInfo;
      return ns = xO(r), Sa = e, Ms = !0, mu = null, Tc = !1, !0;
    }
    function nD(e, r, c) {
      return ns = bO(r), Sa = e, Ms = !0, mu = null, Tc = !1, c !== null && KO(e, c), !0;
    }
    function nk(e, r) {
      switch (e.tag) {
        case q: {
          OO(e.stateNode.containerInfo, r);
          break;
        }
        case ae: {
          var c = (e.mode & rn) !== Ft;
          MO(
            e.type,
            e.memoizedProps,
            e.stateNode,
            r,
            // TODO: Delete this argument when we remove the legacy root API.
            c
          );
          break;
        }
        case re: {
          var g = e.memoizedState;
          g.dehydrated !== null && DO(g.dehydrated, r);
          break;
        }
      }
    }
    function rk(e, r) {
      nk(e, r);
      var c = i_();
      c.stateNode = r, c.return = e;
      var g = e.deletions;
      g === null ? (e.deletions = [c], e.flags |= Sn) : g.push(c);
    }
    function Cb(e, r) {
      {
        if (Tc)
          return;
        switch (e.tag) {
          case q: {
            var c = e.stateNode.containerInfo;
            switch (r.tag) {
              case ae:
                var g = r.type;
                r.pendingProps, _O(c, g);
                break;
              case se:
                var x = r.pendingProps;
                PO(c, x);
                break;
            }
            break;
          }
          case ae: {
            var R = e.type, _ = e.memoizedProps, Y = e.stateNode;
            switch (r.tag) {
              case ae: {
                var U = r.type, J = r.pendingProps, ne = (e.mode & rn) !== Ft;
                IO(
                  R,
                  _,
                  Y,
                  U,
                  J,
                  // TODO: Delete this argument when we remove the legacy root API.
                  ne
                );
                break;
              }
              case se: {
                var ge = r.pendingProps, he = (e.mode & rn) !== Ft;
                FO(
                  R,
                  _,
                  Y,
                  ge,
                  // TODO: Delete this argument when we remove the legacy root API.
                  he
                );
                break;
              }
            }
            break;
          }
          case re: {
            var Te = e.memoizedState, Ae = Te.dehydrated;
            if (Ae !== null)
              switch (r.tag) {
                case ae:
                  var Oe = r.type;
                  r.pendingProps, NO(Ae, Oe);
                  break;
                case se:
                  var dt = r.pendingProps;
                  zO(Ae, dt);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function ak(e, r) {
      r.flags = r.flags & ~mi | Wn, Cb(e, r);
    }
    function ik(e, r) {
      switch (e.tag) {
        case ae: {
          var c = e.type;
          e.pendingProps;
          var g = hO(r, c);
          return g !== null ? (e.stateNode = g, Sa = e, ns = yO(g), !0) : !1;
        }
        case se: {
          var x = e.pendingProps, R = pO(r, x);
          return R !== null ? (e.stateNode = R, Sa = e, ns = null, !0) : !1;
        }
        case re: {
          var _ = gO(r);
          if (_ !== null) {
            var Y = {
              dehydrated: _,
              treeContext: QO(),
              retryLane: Ha
            };
            e.memoizedState = Y;
            var U = s_(_);
            return U.return = e, e.child = U, Sa = e, ns = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function Tb(e) {
      return (e.mode & rn) !== Ft && (e.flags & Xt) === _t;
    }
    function Ab(e) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function Eb(e) {
      if (Ms) {
        var r = ns;
        if (!r) {
          Tb(e) && (Cb(Sa, e), Ab()), ak(Sa, e), Ms = !1, Sa = e;
          return;
        }
        var c = r;
        if (!ik(e, r)) {
          Tb(e) && (Cb(Sa, e), Ab()), r = fp(c);
          var g = Sa;
          if (!r || !ik(e, r)) {
            ak(Sa, e), Ms = !1, Sa = e;
            return;
          }
          rk(g, c);
        }
      }
    }
    function rD(e, r, c) {
      var g = e.stateNode, x = !Tc, R = wO(g, e.type, e.memoizedProps, r, c, e, x);
      return e.updateQueue = R, R !== null;
    }
    function aD(e) {
      var r = e.stateNode, c = e.memoizedProps, g = SO(r, c, e);
      if (g) {
        var x = Sa;
        if (x !== null)
          switch (x.tag) {
            case q: {
              var R = x.stateNode.containerInfo, _ = (x.mode & rn) !== Ft;
              RO(
                R,
                r,
                c,
                // TODO: Delete this argument when we remove the legacy root API.
                _
              );
              break;
            }
            case ae: {
              var Y = x.type, U = x.memoizedProps, J = x.stateNode, ne = (x.mode & rn) !== Ft;
              LO(
                Y,
                U,
                J,
                r,
                c,
                // TODO: Delete this argument when we remove the legacy root API.
                ne
              );
              break;
            }
          }
      }
      return g;
    }
    function iD(e) {
      var r = e.memoizedState, c = r !== null ? r.dehydrated : null;
      if (!c)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      kO(c, e);
    }
    function sD(e) {
      var r = e.memoizedState, c = r !== null ? r.dehydrated : null;
      if (!c)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return CO(c);
    }
    function sk(e) {
      for (var r = e.return; r !== null && r.tag !== ae && r.tag !== q && r.tag !== re; )
        r = r.return;
      Sa = r;
    }
    function pv(e) {
      if (e !== Sa)
        return !1;
      if (!Ms)
        return sk(e), Ms = !0, !1;
      if (e.tag !== q && (e.tag !== ae || EO(e.type) && !lb(e.type, e.memoizedProps))) {
        var r = ns;
        if (r)
          if (Tb(e))
            ok(e), Ab();
          else
            for (; r; )
              rk(e, r), r = fp(r);
      }
      return sk(e), e.tag === re ? ns = sD(e) : ns = Sa ? fp(e.stateNode) : null, !0;
    }
    function oD() {
      return Ms && ns !== null;
    }
    function ok(e) {
      for (var r = ns; r; )
        nk(e, r), r = fp(r);
    }
    function ff() {
      Sa = null, ns = null, Ms = !1, Tc = !1;
    }
    function lk() {
      mu !== null && (nT(mu), mu = null);
    }
    function ka() {
      return Ms;
    }
    function Rb(e) {
      mu === null ? mu = [e] : mu.push(e);
    }
    var lD = h.ReactCurrentBatchConfig, uD = null;
    function cD() {
      return lD.transition;
    }
    var _s = {
      recordUnsafeLifecycleWarnings: function(e, r) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(e, r) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var dD = function(e) {
        for (var r = null, c = e; c !== null; )
          c.mode & Kn && (r = c), c = c.return;
        return r;
      }, Ac = function(e) {
        var r = [];
        return e.forEach(function(c) {
          r.push(c);
        }), r.sort().join(", ");
      }, mp = [], vp = [], yp = [], xp = [], bp = [], wp = [], Ec = /* @__PURE__ */ new Set();
      _s.recordUnsafeLifecycleWarnings = function(e, r) {
        Ec.has(e.type) || (typeof r.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        r.componentWillMount.__suppressDeprecationWarning !== !0 && mp.push(e), e.mode & Kn && typeof r.UNSAFE_componentWillMount == "function" && vp.push(e), typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && yp.push(e), e.mode & Kn && typeof r.UNSAFE_componentWillReceiveProps == "function" && xp.push(e), typeof r.componentWillUpdate == "function" && r.componentWillUpdate.__suppressDeprecationWarning !== !0 && bp.push(e), e.mode & Kn && typeof r.UNSAFE_componentWillUpdate == "function" && wp.push(e));
      }, _s.flushPendingUnsafeLifecycleWarnings = function() {
        var e = /* @__PURE__ */ new Set();
        mp.length > 0 && (mp.forEach(function(he) {
          e.add(vt(he) || "Component"), Ec.add(he.type);
        }), mp = []);
        var r = /* @__PURE__ */ new Set();
        vp.length > 0 && (vp.forEach(function(he) {
          r.add(vt(he) || "Component"), Ec.add(he.type);
        }), vp = []);
        var c = /* @__PURE__ */ new Set();
        yp.length > 0 && (yp.forEach(function(he) {
          c.add(vt(he) || "Component"), Ec.add(he.type);
        }), yp = []);
        var g = /* @__PURE__ */ new Set();
        xp.length > 0 && (xp.forEach(function(he) {
          g.add(vt(he) || "Component"), Ec.add(he.type);
        }), xp = []);
        var x = /* @__PURE__ */ new Set();
        bp.length > 0 && (bp.forEach(function(he) {
          x.add(vt(he) || "Component"), Ec.add(he.type);
        }), bp = []);
        var R = /* @__PURE__ */ new Set();
        if (wp.length > 0 && (wp.forEach(function(he) {
          R.add(vt(he) || "Component"), Ec.add(he.type);
        }), wp = []), r.size > 0) {
          var _ = Ac(r);
          A(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, _);
        }
        if (g.size > 0) {
          var Y = Ac(g);
          A(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, Y);
        }
        if (R.size > 0) {
          var U = Ac(R);
          A(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, U);
        }
        if (e.size > 0) {
          var J = Ac(e);
          T(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, J);
        }
        if (c.size > 0) {
          var ne = Ac(c);
          T(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ne);
        }
        if (x.size > 0) {
          var ge = Ac(x);
          T(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ge);
        }
      };
      var gv = /* @__PURE__ */ new Map(), uk = /* @__PURE__ */ new Set();
      _s.recordLegacyContextWarning = function(e, r) {
        var c = dD(e);
        if (c === null) {
          A("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!uk.has(e.type)) {
          var g = gv.get(c);
          (e.type.contextTypes != null || e.type.childContextTypes != null || r !== null && typeof r.getChildContext == "function") && (g === void 0 && (g = [], gv.set(c, g)), g.push(e));
        }
      }, _s.flushLegacyContextWarning = function() {
        gv.forEach(function(e, r) {
          if (e.length !== 0) {
            var c = e[0], g = /* @__PURE__ */ new Set();
            e.forEach(function(R) {
              g.add(vt(R) || "Component"), uk.add(R.type);
            });
            var x = Ac(g);
            try {
              wn(c), A(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, x);
            } finally {
              ln();
            }
          }
        });
      }, _s.discardPendingWarnings = function() {
        mp = [], vp = [], yp = [], xp = [], bp = [], wp = [], gv = /* @__PURE__ */ new Map();
      };
    }
    function Ps(e, r) {
      if (e && e.defaultProps) {
        var c = p({}, r), g = e.defaultProps;
        for (var x in g)
          c[x] === void 0 && (c[x] = g[x]);
        return c;
      }
      return r;
    }
    var Lb = hu(null), Ob;
    Ob = {};
    var mv = null, hf = null, Db = null, vv = !1;
    function yv() {
      mv = null, hf = null, Db = null, vv = !1;
    }
    function ck() {
      vv = !0;
    }
    function dk() {
      vv = !1;
    }
    function fk(e, r, c) {
      Wa(Lb, r._currentValue, e), r._currentValue = c, r._currentRenderer !== void 0 && r._currentRenderer !== null && r._currentRenderer !== Ob && A("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), r._currentRenderer = Ob;
    }
    function Mb(e, r) {
      var c = Lb.current;
      Ba(Lb, r), e._currentValue = c;
    }
    function _b(e, r, c) {
      for (var g = e; g !== null; ) {
        var x = g.alternate;
        if (Ko(g.childLanes, r) ? x !== null && !Ko(x.childLanes, r) && (x.childLanes = tn(x.childLanes, r)) : (g.childLanes = tn(g.childLanes, r), x !== null && (x.childLanes = tn(x.childLanes, r))), g === c)
          break;
        g = g.return;
      }
      g !== c && A("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function fD(e, r, c) {
      hD(e, r, c);
    }
    function hD(e, r, c) {
      var g = e.child;
      for (g !== null && (g.return = e); g !== null; ) {
        var x = void 0, R = g.dependencies;
        if (R !== null) {
          x = g.child;
          for (var _ = R.firstContext; _ !== null; ) {
            if (_.context === r) {
              if (g.tag === j) {
                var Y = Tr(c), U = pl(Fn, Y);
                U.tag = bv;
                var J = g.updateQueue;
                if (J !== null) {
                  var ne = J.shared, ge = ne.pending;
                  ge === null ? U.next = U : (U.next = ge.next, ge.next = U), ne.pending = U;
                }
              }
              g.lanes = tn(g.lanes, c);
              var he = g.alternate;
              he !== null && (he.lanes = tn(he.lanes, c)), _b(g.return, c, e), R.lanes = tn(R.lanes, c);
              break;
            }
            _ = _.next;
          }
        } else if (g.tag === K)
          x = g.type === e.type ? null : g.child;
        else if (g.tag === Xe) {
          var Te = g.return;
          if (Te === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Te.lanes = tn(Te.lanes, c);
          var Ae = Te.alternate;
          Ae !== null && (Ae.lanes = tn(Ae.lanes, c)), _b(Te, c, e), x = g.sibling;
        } else
          x = g.child;
        if (x !== null)
          x.return = g;
        else
          for (x = g; x !== null; ) {
            if (x === e) {
              x = null;
              break;
            }
            var Oe = x.sibling;
            if (Oe !== null) {
              Oe.return = x.return, x = Oe;
              break;
            }
            x = x.return;
          }
        g = x;
      }
    }
    function pf(e, r) {
      mv = e, hf = null, Db = null;
      var c = e.dependencies;
      if (c !== null) {
        var g = c.firstContext;
        g !== null && (ja(c.lanes, r) && Np(), c.firstContext = null);
      }
    }
    function Hr(e) {
      vv && A("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var r = e._currentValue;
      if (Db !== e) {
        var c = {
          context: e,
          memoizedValue: r,
          next: null
        };
        if (hf === null) {
          if (mv === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          hf = c, mv.dependencies = {
            lanes: Ne,
            firstContext: c
          };
        } else
          hf = hf.next = c;
      }
      return r;
    }
    var Rc = null;
    function Pb(e) {
      Rc === null ? Rc = [e] : Rc.push(e);
    }
    function pD() {
      if (Rc !== null) {
        for (var e = 0; e < Rc.length; e++) {
          var r = Rc[e], c = r.interleaved;
          if (c !== null) {
            r.interleaved = null;
            var g = c.next, x = r.pending;
            if (x !== null) {
              var R = x.next;
              x.next = g, c.next = R;
            }
            r.pending = c;
          }
        }
        Rc = null;
      }
    }
    function hk(e, r, c, g) {
      var x = r.interleaved;
      return x === null ? (c.next = c, Pb(r)) : (c.next = x.next, x.next = c), r.interleaved = c, xv(e, g);
    }
    function gD(e, r, c, g) {
      var x = r.interleaved;
      x === null ? (c.next = c, Pb(r)) : (c.next = x.next, x.next = c), r.interleaved = c;
    }
    function mD(e, r, c, g) {
      var x = r.interleaved;
      return x === null ? (c.next = c, Pb(r)) : (c.next = x.next, x.next = c), r.interleaved = c, xv(e, g);
    }
    function Ai(e, r) {
      return xv(e, r);
    }
    var vD = xv;
    function xv(e, r) {
      e.lanes = tn(e.lanes, r);
      var c = e.alternate;
      c !== null && (c.lanes = tn(c.lanes, r)), c === null && (e.flags & (Wn | mi)) !== _t && pT(e);
      for (var g = e, x = e.return; x !== null; )
        x.childLanes = tn(x.childLanes, r), c = x.alternate, c !== null ? c.childLanes = tn(c.childLanes, r) : (x.flags & (Wn | mi)) !== _t && pT(e), g = x, x = x.return;
      if (g.tag === q) {
        var R = g.stateNode;
        return R;
      } else
        return null;
    }
    var pk = 0, gk = 1, bv = 2, Nb = 3, wv = !1, zb, Sv;
    zb = !1, Sv = null;
    function Ib(e) {
      var r = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Ne
        },
        effects: null
      };
      e.updateQueue = r;
    }
    function mk(e, r) {
      var c = r.updateQueue, g = e.updateQueue;
      if (c === g) {
        var x = {
          baseState: g.baseState,
          firstBaseUpdate: g.firstBaseUpdate,
          lastBaseUpdate: g.lastBaseUpdate,
          shared: g.shared,
          effects: g.effects
        };
        r.updateQueue = x;
      }
    }
    function pl(e, r) {
      var c = {
        eventTime: e,
        lane: r,
        tag: pk,
        payload: null,
        callback: null,
        next: null
      };
      return c;
    }
    function vu(e, r, c) {
      var g = e.updateQueue;
      if (g === null)
        return null;
      var x = g.shared;
      if (Sv === x && !zb && (A("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), zb = !0), v2()) {
        var R = x.pending;
        return R === null ? r.next = r : (r.next = R.next, R.next = r), x.pending = r, vD(e, c);
      } else
        return mD(e, x, r, c);
    }
    function kv(e, r, c) {
      var g = r.updateQueue;
      if (g !== null) {
        var x = g.shared;
        if (Dh(c)) {
          var R = x.lanes;
          R = _h(R, e.pendingLanes);
          var _ = tn(R, c);
          x.lanes = _, Ql(e, _);
        }
      }
    }
    function Fb(e, r) {
      var c = e.updateQueue, g = e.alternate;
      if (g !== null) {
        var x = g.updateQueue;
        if (c === x) {
          var R = null, _ = null, Y = c.firstBaseUpdate;
          if (Y !== null) {
            var U = Y;
            do {
              var J = {
                eventTime: U.eventTime,
                lane: U.lane,
                tag: U.tag,
                payload: U.payload,
                callback: U.callback,
                next: null
              };
              _ === null ? R = _ = J : (_.next = J, _ = J), U = U.next;
            } while (U !== null);
            _ === null ? R = _ = r : (_.next = r, _ = r);
          } else
            R = _ = r;
          c = {
            baseState: x.baseState,
            firstBaseUpdate: R,
            lastBaseUpdate: _,
            shared: x.shared,
            effects: x.effects
          }, e.updateQueue = c;
          return;
        }
      }
      var ne = c.lastBaseUpdate;
      ne === null ? c.firstBaseUpdate = r : ne.next = r, c.lastBaseUpdate = r;
    }
    function yD(e, r, c, g, x, R) {
      switch (c.tag) {
        case gk: {
          var _ = c.payload;
          if (typeof _ == "function") {
            ck();
            var Y = _.call(R, g, x);
            {
              if (e.mode & Kn) {
                Cr(!0);
                try {
                  _.call(R, g, x);
                } finally {
                  Cr(!1);
                }
              }
              dk();
            }
            return Y;
          }
          return _;
        }
        case Nb:
          e.flags = e.flags & ~Nr | Xt;
        case pk: {
          var U = c.payload, J;
          if (typeof U == "function") {
            ck(), J = U.call(R, g, x);
            {
              if (e.mode & Kn) {
                Cr(!0);
                try {
                  U.call(R, g, x);
                } finally {
                  Cr(!1);
                }
              }
              dk();
            }
          } else
            J = U;
          return J == null ? g : p({}, g, J);
        }
        case bv:
          return wv = !0, g;
      }
      return g;
    }
    function Cv(e, r, c, g) {
      var x = e.updateQueue;
      wv = !1, Sv = x.shared;
      var R = x.firstBaseUpdate, _ = x.lastBaseUpdate, Y = x.shared.pending;
      if (Y !== null) {
        x.shared.pending = null;
        var U = Y, J = U.next;
        U.next = null, _ === null ? R = J : _.next = J, _ = U;
        var ne = e.alternate;
        if (ne !== null) {
          var ge = ne.updateQueue, he = ge.lastBaseUpdate;
          he !== _ && (he === null ? ge.firstBaseUpdate = J : he.next = J, ge.lastBaseUpdate = U);
        }
      }
      if (R !== null) {
        var Te = x.baseState, Ae = Ne, Oe = null, dt = null, zt = null, Rt = R;
        do {
          var hn = Rt.lane, on = Rt.eventTime;
          if (Ko(g, hn)) {
            if (zt !== null) {
              var De = {
                eventTime: on,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: dn,
                tag: Rt.tag,
                payload: Rt.payload,
                callback: Rt.callback,
                next: null
              };
              zt = zt.next = De;
            }
            Te = yD(e, x, Rt, Te, r, c);
            var be = Rt.callback;
            if (be !== null && // If the update was already committed, we should not queue its
            // callback again.
            Rt.lane !== dn) {
              e.flags |= $i;
              var Ue = x.effects;
              Ue === null ? x.effects = [Rt] : Ue.push(Rt);
            }
          } else {
            var xe = {
              eventTime: on,
              lane: hn,
              tag: Rt.tag,
              payload: Rt.payload,
              callback: Rt.callback,
              next: null
            };
            zt === null ? (dt = zt = xe, Oe = Te) : zt = zt.next = xe, Ae = tn(Ae, hn);
          }
          if (Rt = Rt.next, Rt === null) {
            if (Y = x.shared.pending, Y === null)
              break;
            var ft = Y, ot = ft.next;
            ft.next = null, Rt = ot, x.lastBaseUpdate = ft, x.shared.pending = null;
          }
        } while (!0);
        zt === null && (Oe = Te), x.baseState = Oe, x.firstBaseUpdate = dt, x.lastBaseUpdate = zt;
        var Ut = x.shared.interleaved;
        if (Ut !== null) {
          var $t = Ut;
          do
            Ae = tn(Ae, $t.lane), $t = $t.next;
          while ($t !== Ut);
        } else
          R === null && (x.shared.lanes = Ne);
        Gp(Ae), e.lanes = Ae, e.memoizedState = Te;
      }
      Sv = null;
    }
    function xD(e, r) {
      if (typeof e != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + e));
      e.call(r);
    }
    function vk() {
      wv = !1;
    }
    function Tv() {
      return wv;
    }
    function yk(e, r, c) {
      var g = r.effects;
      if (r.effects = null, g !== null)
        for (var x = 0; x < g.length; x++) {
          var R = g[x], _ = R.callback;
          _ !== null && (R.callback = null, xD(_, c));
        }
    }
    var Yb = {}, xk = new s.Component().refs, Hb, jb, Bb, Wb, Ub, bk, Av, Xb, Vb, Gb;
    {
      Hb = /* @__PURE__ */ new Set(), jb = /* @__PURE__ */ new Set(), Bb = /* @__PURE__ */ new Set(), Wb = /* @__PURE__ */ new Set(), Xb = /* @__PURE__ */ new Set(), Ub = /* @__PURE__ */ new Set(), Vb = /* @__PURE__ */ new Set(), Gb = /* @__PURE__ */ new Set();
      var wk = /* @__PURE__ */ new Set();
      Av = function(e, r) {
        if (!(e === null || typeof e == "function")) {
          var c = r + "_" + e;
          wk.has(c) || (wk.add(c), A("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", r, e));
        }
      }, bk = function(e, r) {
        if (r === void 0) {
          var c = xt(e) || "Component";
          Ub.has(c) || (Ub.add(c), A("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", c));
        }
      }, Object.defineProperty(Yb, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(Yb);
    }
    function $b(e, r, c, g) {
      var x = e.memoizedState, R = c(g, x);
      {
        if (e.mode & Kn) {
          Cr(!0);
          try {
            R = c(g, x);
          } finally {
            Cr(!1);
          }
        }
        bk(r, R);
      }
      var _ = R == null ? x : p({}, x, R);
      if (e.memoizedState = _, e.lanes === Ne) {
        var Y = e.updateQueue;
        Y.baseState = _;
      }
    }
    var qb = {
      isMounted: ni,
      enqueueSetState: function(e, r, c) {
        var g = pi(e), x = li(), R = Tu(g), _ = pl(x, R);
        _.payload = r, c != null && (Av(c, "setState"), _.callback = c);
        var Y = vu(g, _, R);
        Y !== null && (Jr(Y, g, R, x), kv(Y, g, R)), uo(g, R);
      },
      enqueueReplaceState: function(e, r, c) {
        var g = pi(e), x = li(), R = Tu(g), _ = pl(x, R);
        _.tag = gk, _.payload = r, c != null && (Av(c, "replaceState"), _.callback = c);
        var Y = vu(g, _, R);
        Y !== null && (Jr(Y, g, R, x), kv(Y, g, R)), uo(g, R);
      },
      enqueueForceUpdate: function(e, r) {
        var c = pi(e), g = li(), x = Tu(c), R = pl(g, x);
        R.tag = bv, r != null && (Av(r, "forceUpdate"), R.callback = r);
        var _ = vu(c, R, x);
        _ !== null && (Jr(_, c, x, g), kv(_, c, x)), Eh(c, x);
      }
    };
    function Sk(e, r, c, g, x, R, _) {
      var Y = e.stateNode;
      if (typeof Y.shouldComponentUpdate == "function") {
        var U = Y.shouldComponentUpdate(g, R, _);
        {
          if (e.mode & Kn) {
            Cr(!0);
            try {
              U = Y.shouldComponentUpdate(g, R, _);
            } finally {
              Cr(!1);
            }
          }
          U === void 0 && A("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", xt(r) || "Component");
        }
        return U;
      }
      return r.prototype && r.prototype.isPureReactComponent ? !Ot(c, g) || !Ot(x, R) : !0;
    }
    function bD(e, r, c) {
      var g = e.stateNode;
      {
        var x = xt(r) || "Component", R = g.render;
        R || (r.prototype && typeof r.prototype.render == "function" ? A("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", x) : A("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", x)), g.getInitialState && !g.getInitialState.isReactClassApproved && !g.state && A("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", x), g.getDefaultProps && !g.getDefaultProps.isReactClassApproved && A("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", x), g.propTypes && A("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", x), g.contextType && A("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", x), g.contextTypes && A("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", x), r.contextType && r.contextTypes && !Vb.has(r) && (Vb.add(r), A("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", x)), typeof g.componentShouldUpdate == "function" && A("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", x), r.prototype && r.prototype.isPureReactComponent && typeof g.shouldComponentUpdate < "u" && A("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", xt(r) || "A pure component"), typeof g.componentDidUnmount == "function" && A("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", x), typeof g.componentDidReceiveProps == "function" && A("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", x), typeof g.componentWillRecieveProps == "function" && A("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", x), typeof g.UNSAFE_componentWillRecieveProps == "function" && A("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", x);
        var _ = g.props !== c;
        g.props !== void 0 && _ && A("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", x, x), g.defaultProps && A("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", x, x), typeof g.getSnapshotBeforeUpdate == "function" && typeof g.componentDidUpdate != "function" && !Bb.has(r) && (Bb.add(r), A("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", xt(r))), typeof g.getDerivedStateFromProps == "function" && A("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", x), typeof g.getDerivedStateFromError == "function" && A("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", x), typeof r.getSnapshotBeforeUpdate == "function" && A("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", x);
        var Y = g.state;
        Y && (typeof Y != "object" || _r(Y)) && A("%s.state: must be set to an object or null", x), typeof g.getChildContext == "function" && typeof r.childContextTypes != "object" && A("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", x);
      }
    }
    function kk(e, r) {
      r.updater = qb, e.stateNode = r, jl(r, e), r._reactInternalInstance = Yb;
    }
    function Ck(e, r, c) {
      var g = !1, x = Bi, R = Bi, _ = r.contextType;
      if ("contextType" in r) {
        var Y = (
          // Allow null for conditional declaration
          _ === null || _ !== void 0 && _.$$typeof === tt && _._context === void 0
        );
        if (!Y && !Gb.has(r)) {
          Gb.add(r);
          var U = "";
          _ === void 0 ? U = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof _ != "object" ? U = " However, it is set to a " + typeof _ + "." : _.$$typeof === Ye ? U = " Did you accidentally pass the Context.Provider instead?" : _._context !== void 0 ? U = " Did you accidentally pass the Context.Consumer instead?" : U = " However, it is set to an object with keys {" + Object.keys(_).join(", ") + "}.", A("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", xt(r) || "Component", U);
        }
      }
      if (typeof _ == "object" && _ !== null)
        R = Hr(_);
      else {
        x = lf(e, r, !0);
        var J = r.contextTypes;
        g = J != null, R = g ? uf(e, x) : Bi;
      }
      var ne = new r(c, R);
      if (e.mode & Kn) {
        Cr(!0);
        try {
          ne = new r(c, R);
        } finally {
          Cr(!1);
        }
      }
      var ge = e.memoizedState = ne.state !== null && ne.state !== void 0 ? ne.state : null;
      kk(e, ne);
      {
        if (typeof r.getDerivedStateFromProps == "function" && ge === null) {
          var he = xt(r) || "Component";
          jb.has(he) || (jb.add(he), A("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", he, ne.state === null ? "null" : "undefined", he));
        }
        if (typeof r.getDerivedStateFromProps == "function" || typeof ne.getSnapshotBeforeUpdate == "function") {
          var Te = null, Ae = null, Oe = null;
          if (typeof ne.componentWillMount == "function" && ne.componentWillMount.__suppressDeprecationWarning !== !0 ? Te = "componentWillMount" : typeof ne.UNSAFE_componentWillMount == "function" && (Te = "UNSAFE_componentWillMount"), typeof ne.componentWillReceiveProps == "function" && ne.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Ae = "componentWillReceiveProps" : typeof ne.UNSAFE_componentWillReceiveProps == "function" && (Ae = "UNSAFE_componentWillReceiveProps"), typeof ne.componentWillUpdate == "function" && ne.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Oe = "componentWillUpdate" : typeof ne.UNSAFE_componentWillUpdate == "function" && (Oe = "UNSAFE_componentWillUpdate"), Te !== null || Ae !== null || Oe !== null) {
            var dt = xt(r) || "Component", zt = typeof r.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Wb.has(dt) || (Wb.add(dt), A(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, dt, zt, Te !== null ? `
  ` + Te : "", Ae !== null ? `
  ` + Ae : "", Oe !== null ? `
  ` + Oe : ""));
          }
        }
      }
      return g && $S(e, x, R), ne;
    }
    function wD(e, r) {
      var c = r.state;
      typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), c !== r.state && (A("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", vt(e) || "Component"), qb.enqueueReplaceState(r, r.state, null));
    }
    function Tk(e, r, c, g) {
      var x = r.state;
      if (typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps(c, g), typeof r.UNSAFE_componentWillReceiveProps == "function" && r.UNSAFE_componentWillReceiveProps(c, g), r.state !== x) {
        {
          var R = vt(e) || "Component";
          Hb.has(R) || (Hb.add(R), A("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", R));
        }
        qb.enqueueReplaceState(r, r.state, null);
      }
    }
    function Zb(e, r, c, g) {
      bD(e, r, c);
      var x = e.stateNode;
      x.props = c, x.state = e.memoizedState, x.refs = xk, Ib(e);
      var R = r.contextType;
      if (typeof R == "object" && R !== null)
        x.context = Hr(R);
      else {
        var _ = lf(e, r, !0);
        x.context = uf(e, _);
      }
      {
        if (x.state === c) {
          var Y = xt(r) || "Component";
          Xb.has(Y) || (Xb.add(Y), A("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Y));
        }
        e.mode & Kn && _s.recordLegacyContextWarning(e, x), _s.recordUnsafeLifecycleWarnings(e, x);
      }
      x.state = e.memoizedState;
      var U = r.getDerivedStateFromProps;
      if (typeof U == "function" && ($b(e, r, U, c), x.state = e.memoizedState), typeof r.getDerivedStateFromProps != "function" && typeof x.getSnapshotBeforeUpdate != "function" && (typeof x.UNSAFE_componentWillMount == "function" || typeof x.componentWillMount == "function") && (wD(e, x), Cv(e, c, x, g), x.state = e.memoizedState), typeof x.componentDidMount == "function") {
        var J = en;
        J |= Na, (e.mode & xi) !== Ft && (J |= za), e.flags |= J;
      }
    }
    function SD(e, r, c, g) {
      var x = e.stateNode, R = e.memoizedProps;
      x.props = R;
      var _ = x.context, Y = r.contextType, U = Bi;
      if (typeof Y == "object" && Y !== null)
        U = Hr(Y);
      else {
        var J = lf(e, r, !0);
        U = uf(e, J);
      }
      var ne = r.getDerivedStateFromProps, ge = typeof ne == "function" || typeof x.getSnapshotBeforeUpdate == "function";
      !ge && (typeof x.UNSAFE_componentWillReceiveProps == "function" || typeof x.componentWillReceiveProps == "function") && (R !== c || _ !== U) && Tk(e, x, c, U), vk();
      var he = e.memoizedState, Te = x.state = he;
      if (Cv(e, c, x, g), Te = e.memoizedState, R === c && he === Te && !ov() && !Tv()) {
        if (typeof x.componentDidMount == "function") {
          var Ae = en;
          Ae |= Na, (e.mode & xi) !== Ft && (Ae |= za), e.flags |= Ae;
        }
        return !1;
      }
      typeof ne == "function" && ($b(e, r, ne, c), Te = e.memoizedState);
      var Oe = Tv() || Sk(e, r, R, c, he, Te, U);
      if (Oe) {
        if (!ge && (typeof x.UNSAFE_componentWillMount == "function" || typeof x.componentWillMount == "function") && (typeof x.componentWillMount == "function" && x.componentWillMount(), typeof x.UNSAFE_componentWillMount == "function" && x.UNSAFE_componentWillMount()), typeof x.componentDidMount == "function") {
          var dt = en;
          dt |= Na, (e.mode & xi) !== Ft && (dt |= za), e.flags |= dt;
        }
      } else {
        if (typeof x.componentDidMount == "function") {
          var zt = en;
          zt |= Na, (e.mode & xi) !== Ft && (zt |= za), e.flags |= zt;
        }
        e.memoizedProps = c, e.memoizedState = Te;
      }
      return x.props = c, x.state = Te, x.context = U, Oe;
    }
    function kD(e, r, c, g, x) {
      var R = r.stateNode;
      mk(e, r);
      var _ = r.memoizedProps, Y = r.type === r.elementType ? _ : Ps(r.type, _);
      R.props = Y;
      var U = r.pendingProps, J = R.context, ne = c.contextType, ge = Bi;
      if (typeof ne == "object" && ne !== null)
        ge = Hr(ne);
      else {
        var he = lf(r, c, !0);
        ge = uf(r, he);
      }
      var Te = c.getDerivedStateFromProps, Ae = typeof Te == "function" || typeof R.getSnapshotBeforeUpdate == "function";
      !Ae && (typeof R.UNSAFE_componentWillReceiveProps == "function" || typeof R.componentWillReceiveProps == "function") && (_ !== U || J !== ge) && Tk(r, R, g, ge), vk();
      var Oe = r.memoizedState, dt = R.state = Oe;
      if (Cv(r, g, R, x), dt = r.memoizedState, _ === U && Oe === dt && !ov() && !Tv() && !pt)
        return typeof R.componentDidUpdate == "function" && (_ !== e.memoizedProps || Oe !== e.memoizedState) && (r.flags |= en), typeof R.getSnapshotBeforeUpdate == "function" && (_ !== e.memoizedProps || Oe !== e.memoizedState) && (r.flags |= gi), !1;
      typeof Te == "function" && ($b(r, c, Te, g), dt = r.memoizedState);
      var zt = Tv() || Sk(r, c, Y, g, Oe, dt, ge) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      pt;
      return zt ? (!Ae && (typeof R.UNSAFE_componentWillUpdate == "function" || typeof R.componentWillUpdate == "function") && (typeof R.componentWillUpdate == "function" && R.componentWillUpdate(g, dt, ge), typeof R.UNSAFE_componentWillUpdate == "function" && R.UNSAFE_componentWillUpdate(g, dt, ge)), typeof R.componentDidUpdate == "function" && (r.flags |= en), typeof R.getSnapshotBeforeUpdate == "function" && (r.flags |= gi)) : (typeof R.componentDidUpdate == "function" && (_ !== e.memoizedProps || Oe !== e.memoizedState) && (r.flags |= en), typeof R.getSnapshotBeforeUpdate == "function" && (_ !== e.memoizedProps || Oe !== e.memoizedState) && (r.flags |= gi), r.memoizedProps = g, r.memoizedState = dt), R.props = g, R.state = dt, R.context = ge, zt;
    }
    var Qb, Kb, Jb, e0, t0, Ak = function(e, r) {
    };
    Qb = !1, Kb = !1, Jb = {}, e0 = {}, t0 = {}, Ak = function(e, r) {
      if (!(e === null || typeof e != "object") && !(!e._store || e._store.validated || e.key != null)) {
        if (typeof e._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        e._store.validated = !0;
        var c = vt(r) || "Component";
        e0[c] || (e0[c] = !0, A('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function Sp(e, r, c) {
      var g = c.ref;
      if (g !== null && typeof g != "function" && typeof g != "object") {
        if ((e.mode & Kn || mt) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(c._owner && c._self && c._owner.stateNode !== c._self)) {
          var x = vt(e) || "Component";
          Jb[x] || (A('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', g), Jb[x] = !0);
        }
        if (c._owner) {
          var R = c._owner, _;
          if (R) {
            var Y = R;
            if (Y.tag !== j)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            _ = Y.stateNode;
          }
          if (!_)
            throw new Error("Missing owner for string ref " + g + ". This error is likely caused by a bug in React. Please file an issue.");
          var U = _;
          _i(g, "ref");
          var J = "" + g;
          if (r !== null && r.ref !== null && typeof r.ref == "function" && r.ref._stringRef === J)
            return r.ref;
          var ne = function(ge) {
            var he = U.refs;
            he === xk && (he = U.refs = {}), ge === null ? delete he[J] : he[J] = ge;
          };
          return ne._stringRef = J, ne;
        } else {
          if (typeof g != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!c._owner)
            throw new Error("Element ref was specified as a string (" + g + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return g;
    }
    function Ev(e, r) {
      var c = Object.prototype.toString.call(r);
      throw new Error("Objects are not valid as a React child (found: " + (c === "[object Object]" ? "object with keys {" + Object.keys(r).join(", ") + "}" : c) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Rv(e) {
      {
        var r = vt(e) || "Component";
        if (t0[r])
          return;
        t0[r] = !0, A("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function Ek(e) {
      var r = e._payload, c = e._init;
      return c(r);
    }
    function Rk(e) {
      function r(xe, De) {
        if (e) {
          var be = xe.deletions;
          be === null ? (xe.deletions = [De], xe.flags |= Sn) : be.push(De);
        }
      }
      function c(xe, De) {
        if (!e)
          return null;
        for (var be = De; be !== null; )
          r(xe, be), be = be.sibling;
        return null;
      }
      function g(xe, De) {
        for (var be = /* @__PURE__ */ new Map(), Ue = De; Ue !== null; )
          Ue.key !== null ? be.set(Ue.key, Ue) : be.set(Ue.index, Ue), Ue = Ue.sibling;
        return be;
      }
      function x(xe, De) {
        var be = zc(xe, De);
        return be.index = 0, be.sibling = null, be;
      }
      function R(xe, De, be) {
        if (xe.index = be, !e)
          return xe.flags |= gh, De;
        var Ue = xe.alternate;
        if (Ue !== null) {
          var ft = Ue.index;
          return ft < De ? (xe.flags |= Wn, De) : ft;
        } else
          return xe.flags |= Wn, De;
      }
      function _(xe) {
        return e && xe.alternate === null && (xe.flags |= Wn), xe;
      }
      function Y(xe, De, be, Ue) {
        if (De === null || De.tag !== se) {
          var ft = Rw(be, xe.mode, Ue);
          return ft.return = xe, ft;
        } else {
          var ot = x(De, be);
          return ot.return = xe, ot;
        }
      }
      function U(xe, De, be, Ue) {
        var ft = be.type;
        if (ft === ba)
          return ne(xe, De, be.props.children, Ue, be.key);
        if (De !== null && (De.elementType === ft || // Keep this check inline so it only runs on the false path:
        yT(De, be) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof ft == "object" && ft !== null && ft.$$typeof === Mt && Ek(ft) === De.type)) {
          var ot = x(De, be.props);
          return ot.ref = Sp(xe, De, be), ot.return = xe, ot._debugSource = be._source, ot._debugOwner = be._owner, ot;
        }
        var Ut = Ew(be, xe.mode, Ue);
        return Ut.ref = Sp(xe, De, be), Ut.return = xe, Ut;
      }
      function J(xe, De, be, Ue) {
        if (De === null || De.tag !== te || De.stateNode.containerInfo !== be.containerInfo || De.stateNode.implementation !== be.implementation) {
          var ft = Lw(be, xe.mode, Ue);
          return ft.return = xe, ft;
        } else {
          var ot = x(De, be.children || []);
          return ot.return = xe, ot;
        }
      }
      function ne(xe, De, be, Ue, ft) {
        if (De === null || De.tag !== ue) {
          var ot = Eu(be, xe.mode, Ue, ft);
          return ot.return = xe, ot;
        } else {
          var Ut = x(De, be);
          return Ut.return = xe, Ut;
        }
      }
      function ge(xe, De, be) {
        if (typeof De == "string" && De !== "" || typeof De == "number") {
          var Ue = Rw("" + De, xe.mode, be);
          return Ue.return = xe, Ue;
        }
        if (typeof De == "object" && De !== null) {
          switch (De.$$typeof) {
            case Ni: {
              var ft = Ew(De, xe.mode, be);
              return ft.ref = Sp(xe, null, De), ft.return = xe, ft;
            }
            case jr: {
              var ot = Lw(De, xe.mode, be);
              return ot.return = xe, ot;
            }
            case Mt: {
              var Ut = De._payload, $t = De._init;
              return ge(xe, $t(Ut), be);
            }
          }
          if (_r(De) || f(De)) {
            var _n = Eu(De, xe.mode, be, null);
            return _n.return = xe, _n;
          }
          Ev(xe, De);
        }
        return typeof De == "function" && Rv(xe), null;
      }
      function he(xe, De, be, Ue) {
        var ft = De !== null ? De.key : null;
        if (typeof be == "string" && be !== "" || typeof be == "number")
          return ft !== null ? null : Y(xe, De, "" + be, Ue);
        if (typeof be == "object" && be !== null) {
          switch (be.$$typeof) {
            case Ni:
              return be.key === ft ? U(xe, De, be, Ue) : null;
            case jr:
              return be.key === ft ? J(xe, De, be, Ue) : null;
            case Mt: {
              var ot = be._payload, Ut = be._init;
              return he(xe, De, Ut(ot), Ue);
            }
          }
          if (_r(be) || f(be))
            return ft !== null ? null : ne(xe, De, be, Ue, null);
          Ev(xe, be);
        }
        return typeof be == "function" && Rv(xe), null;
      }
      function Te(xe, De, be, Ue, ft) {
        if (typeof Ue == "string" && Ue !== "" || typeof Ue == "number") {
          var ot = xe.get(be) || null;
          return Y(De, ot, "" + Ue, ft);
        }
        if (typeof Ue == "object" && Ue !== null) {
          switch (Ue.$$typeof) {
            case Ni: {
              var Ut = xe.get(Ue.key === null ? be : Ue.key) || null;
              return U(De, Ut, Ue, ft);
            }
            case jr: {
              var $t = xe.get(Ue.key === null ? be : Ue.key) || null;
              return J(De, $t, Ue, ft);
            }
            case Mt:
              var _n = Ue._payload, vn = Ue._init;
              return Te(xe, De, be, vn(_n), ft);
          }
          if (_r(Ue) || f(Ue)) {
            var Lr = xe.get(be) || null;
            return ne(De, Lr, Ue, ft, null);
          }
          Ev(De, Ue);
        }
        return typeof Ue == "function" && Rv(De), null;
      }
      function Ae(xe, De, be) {
        {
          if (typeof xe != "object" || xe === null)
            return De;
          switch (xe.$$typeof) {
            case Ni:
            case jr:
              Ak(xe, be);
              var Ue = xe.key;
              if (typeof Ue != "string")
                break;
              if (De === null) {
                De = /* @__PURE__ */ new Set(), De.add(Ue);
                break;
              }
              if (!De.has(Ue)) {
                De.add(Ue);
                break;
              }
              A("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", Ue);
              break;
            case Mt:
              var ft = xe._payload, ot = xe._init;
              Ae(ot(ft), De, be);
              break;
          }
        }
        return De;
      }
      function Oe(xe, De, be, Ue) {
        for (var ft = null, ot = 0; ot < be.length; ot++) {
          var Ut = be[ot];
          ft = Ae(Ut, ft, xe);
        }
        for (var $t = null, _n = null, vn = De, Lr = 0, yn = 0, kr = null; vn !== null && yn < be.length; yn++) {
          vn.index > yn ? (kr = vn, vn = null) : kr = vn.sibling;
          var Xa = he(xe, vn, be[yn], Ue);
          if (Xa === null) {
            vn === null && (vn = kr);
            break;
          }
          e && vn && Xa.alternate === null && r(xe, vn), Lr = R(Xa, Lr, yn), _n === null ? $t = Xa : _n.sibling = Xa, _n = Xa, vn = kr;
        }
        if (yn === be.length) {
          if (c(xe, vn), ka()) {
            var Oa = yn;
            kc(xe, Oa);
          }
          return $t;
        }
        if (vn === null) {
          for (; yn < be.length; yn++) {
            var Ui = ge(xe, be[yn], Ue);
            Ui !== null && (Lr = R(Ui, Lr, yn), _n === null ? $t = Ui : _n.sibling = Ui, _n = Ui);
          }
          if (ka()) {
            var ui = yn;
            kc(xe, ui);
          }
          return $t;
        }
        for (var ci = g(xe, vn); yn < be.length; yn++) {
          var Va = Te(ci, xe, yn, be[yn], Ue);
          Va !== null && (e && Va.alternate !== null && ci.delete(Va.key === null ? yn : Va.key), Lr = R(Va, Lr, yn), _n === null ? $t = Va : _n.sibling = Va, _n = Va);
        }
        if (e && ci.forEach(function(Df) {
          return r(xe, Df);
        }), ka()) {
          var bl = yn;
          kc(xe, bl);
        }
        return $t;
      }
      function dt(xe, De, be, Ue) {
        var ft = f(be);
        if (typeof ft != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          be[Symbol.toStringTag] === "Generator" && (Kb || A("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Kb = !0), be.entries === ft && (Qb || A("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Qb = !0);
          var ot = ft.call(be);
          if (ot)
            for (var Ut = null, $t = ot.next(); !$t.done; $t = ot.next()) {
              var _n = $t.value;
              Ut = Ae(_n, Ut, xe);
            }
        }
        var vn = ft.call(be);
        if (vn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Lr = null, yn = null, kr = De, Xa = 0, Oa = 0, Ui = null, ui = vn.next(); kr !== null && !ui.done; Oa++, ui = vn.next()) {
          kr.index > Oa ? (Ui = kr, kr = null) : Ui = kr.sibling;
          var ci = he(xe, kr, ui.value, Ue);
          if (ci === null) {
            kr === null && (kr = Ui);
            break;
          }
          e && kr && ci.alternate === null && r(xe, kr), Xa = R(ci, Xa, Oa), yn === null ? Lr = ci : yn.sibling = ci, yn = ci, kr = Ui;
        }
        if (ui.done) {
          if (c(xe, kr), ka()) {
            var Va = Oa;
            kc(xe, Va);
          }
          return Lr;
        }
        if (kr === null) {
          for (; !ui.done; Oa++, ui = vn.next()) {
            var bl = ge(xe, ui.value, Ue);
            bl !== null && (Xa = R(bl, Xa, Oa), yn === null ? Lr = bl : yn.sibling = bl, yn = bl);
          }
          if (ka()) {
            var Df = Oa;
            kc(xe, Df);
          }
          return Lr;
        }
        for (var Kp = g(xe, kr); !ui.done; Oa++, ui = vn.next()) {
          var Ro = Te(Kp, xe, Oa, ui.value, Ue);
          Ro !== null && (e && Ro.alternate !== null && Kp.delete(Ro.key === null ? Oa : Ro.key), Xa = R(Ro, Xa, Oa), yn === null ? Lr = Ro : yn.sibling = Ro, yn = Ro);
        }
        if (e && Kp.forEach(function(I_) {
          return r(xe, I_);
        }), ka()) {
          var z_ = Oa;
          kc(xe, z_);
        }
        return Lr;
      }
      function zt(xe, De, be, Ue) {
        if (De !== null && De.tag === se) {
          c(xe, De.sibling);
          var ft = x(De, be);
          return ft.return = xe, ft;
        }
        c(xe, De);
        var ot = Rw(be, xe.mode, Ue);
        return ot.return = xe, ot;
      }
      function Rt(xe, De, be, Ue) {
        for (var ft = be.key, ot = De; ot !== null; ) {
          if (ot.key === ft) {
            var Ut = be.type;
            if (Ut === ba) {
              if (ot.tag === ue) {
                c(xe, ot.sibling);
                var $t = x(ot, be.props.children);
                return $t.return = xe, $t._debugSource = be._source, $t._debugOwner = be._owner, $t;
              }
            } else if (ot.elementType === Ut || // Keep this check inline so it only runs on the false path:
            yT(ot, be) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Ut == "object" && Ut !== null && Ut.$$typeof === Mt && Ek(Ut) === ot.type) {
              c(xe, ot.sibling);
              var _n = x(ot, be.props);
              return _n.ref = Sp(xe, ot, be), _n.return = xe, _n._debugSource = be._source, _n._debugOwner = be._owner, _n;
            }
            c(xe, ot);
            break;
          } else
            r(xe, ot);
          ot = ot.sibling;
        }
        if (be.type === ba) {
          var vn = Eu(be.props.children, xe.mode, Ue, be.key);
          return vn.return = xe, vn;
        } else {
          var Lr = Ew(be, xe.mode, Ue);
          return Lr.ref = Sp(xe, De, be), Lr.return = xe, Lr;
        }
      }
      function hn(xe, De, be, Ue) {
        for (var ft = be.key, ot = De; ot !== null; ) {
          if (ot.key === ft)
            if (ot.tag === te && ot.stateNode.containerInfo === be.containerInfo && ot.stateNode.implementation === be.implementation) {
              c(xe, ot.sibling);
              var Ut = x(ot, be.children || []);
              return Ut.return = xe, Ut;
            } else {
              c(xe, ot);
              break;
            }
          else
            r(xe, ot);
          ot = ot.sibling;
        }
        var $t = Lw(be, xe.mode, Ue);
        return $t.return = xe, $t;
      }
      function on(xe, De, be, Ue) {
        var ft = typeof be == "object" && be !== null && be.type === ba && be.key === null;
        if (ft && (be = be.props.children), typeof be == "object" && be !== null) {
          switch (be.$$typeof) {
            case Ni:
              return _(Rt(xe, De, be, Ue));
            case jr:
              return _(hn(xe, De, be, Ue));
            case Mt:
              var ot = be._payload, Ut = be._init;
              return on(xe, De, Ut(ot), Ue);
          }
          if (_r(be))
            return Oe(xe, De, be, Ue);
          if (f(be))
            return dt(xe, De, be, Ue);
          Ev(xe, be);
        }
        return typeof be == "string" && be !== "" || typeof be == "number" ? _(zt(xe, De, "" + be, Ue)) : (typeof be == "function" && Rv(xe), c(xe, De));
      }
      return on;
    }
    var gf = Rk(!0), Lk = Rk(!1);
    function CD(e, r) {
      if (e !== null && r.child !== e.child)
        throw new Error("Resuming work not yet implemented.");
      if (r.child !== null) {
        var c = r.child, g = zc(c, c.pendingProps);
        for (r.child = g, g.return = r; c.sibling !== null; )
          c = c.sibling, g = g.sibling = zc(c, c.pendingProps), g.return = r;
        g.sibling = null;
      }
    }
    function TD(e, r) {
      for (var c = e.child; c !== null; )
        e_(c, r), c = c.sibling;
    }
    var kp = {}, yu = hu(kp), Cp = hu(kp), Lv = hu(kp);
    function Ov(e) {
      if (e === kp)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return e;
    }
    function Ok() {
      var e = Ov(Lv.current);
      return e;
    }
    function n0(e, r) {
      Wa(Lv, r, e), Wa(Cp, e, e), Wa(yu, kp, e);
      var c = YL(r);
      Ba(yu, e), Wa(yu, c, e);
    }
    function mf(e) {
      Ba(yu, e), Ba(Cp, e), Ba(Lv, e);
    }
    function r0() {
      var e = Ov(yu.current);
      return e;
    }
    function Dk(e) {
      Ov(Lv.current);
      var r = Ov(yu.current), c = HL(r, e.type);
      r !== c && (Wa(Cp, e, e), Wa(yu, c, e));
    }
    function a0(e) {
      Cp.current === e && (Ba(yu, e), Ba(Cp, e));
    }
    var AD = 0, Mk = 1, _k = 1, Tp = 2, Ns = hu(AD);
    function i0(e, r) {
      return (e & r) !== 0;
    }
    function vf(e) {
      return e & Mk;
    }
    function s0(e, r) {
      return e & Mk | r;
    }
    function ED(e, r) {
      return e | r;
    }
    function xu(e, r) {
      Wa(Ns, r, e);
    }
    function yf(e) {
      Ba(Ns, e);
    }
    function RD(e, r) {
      var c = e.memoizedState;
      return c !== null ? c.dehydrated !== null : (e.memoizedProps, !0);
    }
    function Dv(e) {
      for (var r = e; r !== null; ) {
        if (r.tag === re) {
          var c = r.memoizedState;
          if (c !== null) {
            var g = c.dehydrated;
            if (g === null || WS(g) || fb(g))
              return r;
          }
        } else if (r.tag === it && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        r.memoizedProps.revealOrder !== void 0) {
          var x = (r.flags & Xt) !== _t;
          if (x)
            return r;
        } else if (r.child !== null) {
          r.child.return = r, r = r.child;
          continue;
        }
        if (r === e)
          return null;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === e)
            return null;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
      return null;
    }
    var Ei = (
      /*   */
      0
    ), Vr = (
      /* */
      1
    ), wo = (
      /*  */
      2
    ), Gr = (
      /*    */
      4
    ), Ca = (
      /*   */
      8
    ), o0 = [];
    function l0() {
      for (var e = 0; e < o0.length; e++) {
        var r = o0[e];
        r._workInProgressVersionPrimary = null;
      }
      o0.length = 0;
    }
    function LD(e, r) {
      var c = r._getVersion, g = c(r._source);
      e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [r, g] : e.mutableSourceEagerHydrationData.push(r, g);
    }
    var ut = h.ReactCurrentDispatcher, Ap = h.ReactCurrentBatchConfig, u0, xf;
    u0 = /* @__PURE__ */ new Set();
    var Lc = Ne, Mn = null, $r = null, qr = null, Mv = !1, Ep = !1, Rp = 0, OD = 0, DD = 25, ze = null, rs = null, bu = -1, c0 = !1;
    function An() {
      {
        var e = ze;
        rs === null ? rs = [e] : rs.push(e);
      }
    }
    function rt() {
      {
        var e = ze;
        rs !== null && (bu++, rs[bu] !== e && MD(e));
      }
    }
    function bf(e) {
      e != null && !_r(e) && A("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", ze, typeof e);
    }
    function MD(e) {
      {
        var r = vt(Mn);
        if (!u0.has(r) && (u0.add(r), rs !== null)) {
          for (var c = "", g = 30, x = 0; x <= bu; x++) {
            for (var R = rs[x], _ = x === bu ? e : R, Y = x + 1 + ". " + R; Y.length < g; )
              Y += " ";
            Y += _ + `
`, c += Y;
          }
          A(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, r, c);
        }
      }
    }
    function Ua() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function d0(e, r) {
      if (c0)
        return !1;
      if (r === null)
        return A("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", ze), !1;
      e.length !== r.length && A(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, ze, "[" + r.join(", ") + "]", "[" + e.join(", ") + "]");
      for (var c = 0; c < r.length && c < e.length; c++)
        if (!wt(e[c], r[c]))
          return !1;
      return !0;
    }
    function wf(e, r, c, g, x, R) {
      Lc = R, Mn = r, rs = e !== null ? e._debugHookTypes : null, bu = -1, c0 = e !== null && e.type !== r.type, r.memoizedState = null, r.updateQueue = null, r.lanes = Ne, e !== null && e.memoizedState !== null ? ut.current = tC : rs !== null ? ut.current = eC : ut.current = Jk;
      var _ = c(g, x);
      if (Ep) {
        var Y = 0;
        do {
          if (Ep = !1, Rp = 0, Y >= DD)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          Y += 1, c0 = !1, $r = null, qr = null, r.updateQueue = null, bu = -1, ut.current = nC, _ = c(g, x);
        } while (Ep);
      }
      ut.current = Xv, r._debugHookTypes = rs;
      var U = $r !== null && $r.next !== null;
      if (Lc = Ne, Mn = null, $r = null, qr = null, ze = null, rs = null, bu = -1, e !== null && (e.flags & Wr) !== (r.flags & Wr) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (e.mode & rn) !== Ft && A("Internal React error: Expected static flag was missing. Please notify the React team."), Mv = !1, U)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return _;
    }
    function Sf() {
      var e = Rp !== 0;
      return Rp = 0, e;
    }
    function Pk(e, r, c) {
      r.updateQueue = e.updateQueue, (r.mode & xi) !== Ft ? r.flags &= ~(Bo | za | qn | en) : r.flags &= ~(qn | en), e.lanes = Zl(e.lanes, c);
    }
    function Nk() {
      if (ut.current = Xv, Mv) {
        for (var e = Mn.memoizedState; e !== null; ) {
          var r = e.queue;
          r !== null && (r.pending = null), e = e.next;
        }
        Mv = !1;
      }
      Lc = Ne, Mn = null, $r = null, qr = null, rs = null, bu = -1, ze = null, $k = !1, Ep = !1, Rp = 0;
    }
    function So() {
      var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return qr === null ? Mn.memoizedState = qr = e : qr = qr.next = e, qr;
    }
    function as() {
      var e;
      if ($r === null) {
        var r = Mn.alternate;
        r !== null ? e = r.memoizedState : e = null;
      } else
        e = $r.next;
      var c;
      if (qr === null ? c = Mn.memoizedState : c = qr.next, c !== null)
        qr = c, c = qr.next, $r = e;
      else {
        if (e === null)
          throw new Error("Rendered more hooks than during the previous render.");
        $r = e;
        var g = {
          memoizedState: $r.memoizedState,
          baseState: $r.baseState,
          baseQueue: $r.baseQueue,
          queue: $r.queue,
          next: null
        };
        qr === null ? Mn.memoizedState = qr = g : qr = qr.next = g;
      }
      return qr;
    }
    function zk() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function f0(e, r) {
      return typeof r == "function" ? r(e) : r;
    }
    function h0(e, r, c) {
      var g = So(), x;
      c !== void 0 ? x = c(r) : x = r, g.memoizedState = g.baseState = x;
      var R = {
        pending: null,
        interleaved: null,
        lanes: Ne,
        dispatch: null,
        lastRenderedReducer: e,
        lastRenderedState: x
      };
      g.queue = R;
      var _ = R.dispatch = zD.bind(null, Mn, R);
      return [g.memoizedState, _];
    }
    function p0(e, r, c) {
      var g = as(), x = g.queue;
      if (x === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      x.lastRenderedReducer = e;
      var R = $r, _ = R.baseQueue, Y = x.pending;
      if (Y !== null) {
        if (_ !== null) {
          var U = _.next, J = Y.next;
          _.next = J, Y.next = U;
        }
        R.baseQueue !== _ && A("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), R.baseQueue = _ = Y, x.pending = null;
      }
      if (_ !== null) {
        var ne = _.next, ge = R.baseState, he = null, Te = null, Ae = null, Oe = ne;
        do {
          var dt = Oe.lane;
          if (Ko(Lc, dt)) {
            if (Ae !== null) {
              var Rt = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: dn,
                action: Oe.action,
                hasEagerState: Oe.hasEagerState,
                eagerState: Oe.eagerState,
                next: null
              };
              Ae = Ae.next = Rt;
            }
            if (Oe.hasEagerState)
              ge = Oe.eagerState;
            else {
              var hn = Oe.action;
              ge = e(ge, hn);
            }
          } else {
            var zt = {
              lane: dt,
              action: Oe.action,
              hasEagerState: Oe.hasEagerState,
              eagerState: Oe.eagerState,
              next: null
            };
            Ae === null ? (Te = Ae = zt, he = ge) : Ae = Ae.next = zt, Mn.lanes = tn(Mn.lanes, dt), Gp(dt);
          }
          Oe = Oe.next;
        } while (Oe !== null && Oe !== ne);
        Ae === null ? he = ge : Ae.next = Te, wt(ge, g.memoizedState) || Np(), g.memoizedState = ge, g.baseState = he, g.baseQueue = Ae, x.lastRenderedState = ge;
      }
      var on = x.interleaved;
      if (on !== null) {
        var xe = on;
        do {
          var De = xe.lane;
          Mn.lanes = tn(Mn.lanes, De), Gp(De), xe = xe.next;
        } while (xe !== on);
      } else
        _ === null && (x.lanes = Ne);
      var be = x.dispatch;
      return [g.memoizedState, be];
    }
    function g0(e, r, c) {
      var g = as(), x = g.queue;
      if (x === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      x.lastRenderedReducer = e;
      var R = x.dispatch, _ = x.pending, Y = g.memoizedState;
      if (_ !== null) {
        x.pending = null;
        var U = _.next, J = U;
        do {
          var ne = J.action;
          Y = e(Y, ne), J = J.next;
        } while (J !== U);
        wt(Y, g.memoizedState) || Np(), g.memoizedState = Y, g.baseQueue === null && (g.baseState = Y), x.lastRenderedState = Y;
      }
      return [Y, R];
    }
    function Yj(e, r, c) {
    }
    function Hj(e, r, c) {
    }
    function m0(e, r, c) {
      var g = Mn, x = So(), R, _ = ka();
      if (_) {
        if (c === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        R = c(), xf || R !== c() && (A("The result of getServerSnapshot should be cached to avoid an infinite loop"), xf = !0);
      } else {
        if (R = r(), !xf) {
          var Y = r();
          wt(R, Y) || (A("The result of getSnapshot should be cached to avoid an infinite loop"), xf = !0);
        }
        var U = uy();
        if (U === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        sc(U, Lc) || Ik(g, r, R);
      }
      x.memoizedState = R;
      var J = {
        value: R,
        getSnapshot: r
      };
      return x.queue = J, Iv(Yk.bind(null, g, J, e), [e]), g.flags |= qn, Lp(Vr | Ca, Fk.bind(null, g, J, R, r), void 0, null), R;
    }
    function _v(e, r, c) {
      var g = Mn, x = as(), R = r();
      if (!xf) {
        var _ = r();
        wt(R, _) || (A("The result of getSnapshot should be cached to avoid an infinite loop"), xf = !0);
      }
      var Y = x.memoizedState, U = !wt(Y, R);
      U && (x.memoizedState = R, Np());
      var J = x.queue;
      if (Dp(Yk.bind(null, g, J, e), [e]), J.getSnapshot !== r || U || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      qr !== null && qr.memoizedState.tag & Vr) {
        g.flags |= qn, Lp(Vr | Ca, Fk.bind(null, g, J, R, r), void 0, null);
        var ne = uy();
        if (ne === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        sc(ne, Lc) || Ik(g, r, R);
      }
      return R;
    }
    function Ik(e, r, c) {
      e.flags |= Qu;
      var g = {
        getSnapshot: r,
        value: c
      }, x = Mn.updateQueue;
      if (x === null)
        x = zk(), Mn.updateQueue = x, x.stores = [g];
      else {
        var R = x.stores;
        R === null ? x.stores = [g] : R.push(g);
      }
    }
    function Fk(e, r, c, g) {
      r.value = c, r.getSnapshot = g, Hk(r) && jk(e);
    }
    function Yk(e, r, c) {
      var g = function() {
        Hk(r) && jk(e);
      };
      return c(g);
    }
    function Hk(e) {
      var r = e.getSnapshot, c = e.value;
      try {
        var g = r();
        return !wt(c, g);
      } catch {
        return !0;
      }
    }
    function jk(e) {
      var r = Ai(e, Bt);
      r !== null && Jr(r, e, Bt, Fn);
    }
    function Pv(e) {
      var r = So();
      typeof e == "function" && (e = e()), r.memoizedState = r.baseState = e;
      var c = {
        pending: null,
        interleaved: null,
        lanes: Ne,
        dispatch: null,
        lastRenderedReducer: f0,
        lastRenderedState: e
      };
      r.queue = c;
      var g = c.dispatch = ID.bind(null, Mn, c);
      return [r.memoizedState, g];
    }
    function v0(e) {
      return p0(f0);
    }
    function y0(e) {
      return g0(f0);
    }
    function Lp(e, r, c, g) {
      var x = {
        tag: e,
        create: r,
        destroy: c,
        deps: g,
        // Circular
        next: null
      }, R = Mn.updateQueue;
      if (R === null)
        R = zk(), Mn.updateQueue = R, R.lastEffect = x.next = x;
      else {
        var _ = R.lastEffect;
        if (_ === null)
          R.lastEffect = x.next = x;
        else {
          var Y = _.next;
          _.next = x, x.next = Y, R.lastEffect = x;
        }
      }
      return x;
    }
    function x0(e) {
      var r = So();
      {
        var c = {
          current: e
        };
        return r.memoizedState = c, c;
      }
    }
    function Nv(e) {
      var r = as();
      return r.memoizedState;
    }
    function Op(e, r, c, g) {
      var x = So(), R = g === void 0 ? null : g;
      Mn.flags |= e, x.memoizedState = Lp(Vr | r, c, void 0, R);
    }
    function zv(e, r, c, g) {
      var x = as(), R = g === void 0 ? null : g, _ = void 0;
      if ($r !== null) {
        var Y = $r.memoizedState;
        if (_ = Y.destroy, R !== null) {
          var U = Y.deps;
          if (d0(R, U)) {
            x.memoizedState = Lp(r, c, _, R);
            return;
          }
        }
      }
      Mn.flags |= e, x.memoizedState = Lp(Vr | r, c, _, R);
    }
    function Iv(e, r) {
      return (Mn.mode & xi) !== Ft ? Op(Bo | qn | ro, Ca, e, r) : Op(qn | ro, Ca, e, r);
    }
    function Dp(e, r) {
      return zv(qn, Ca, e, r);
    }
    function b0(e, r) {
      return Op(en, wo, e, r);
    }
    function Fv(e, r) {
      return zv(en, wo, e, r);
    }
    function w0(e, r) {
      var c = en;
      return c |= Na, (Mn.mode & xi) !== Ft && (c |= za), Op(c, Gr, e, r);
    }
    function Yv(e, r) {
      return zv(en, Gr, e, r);
    }
    function Bk(e, r) {
      if (typeof r == "function") {
        var c = r, g = e();
        return c(g), function() {
          c(null);
        };
      } else if (r != null) {
        var x = r;
        x.hasOwnProperty("current") || A("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(x).join(", ") + "}");
        var R = e();
        return x.current = R, function() {
          x.current = null;
        };
      }
    }
    function S0(e, r, c) {
      typeof r != "function" && A("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", r !== null ? typeof r : "null");
      var g = c != null ? c.concat([e]) : null, x = en;
      return x |= Na, (Mn.mode & xi) !== Ft && (x |= za), Op(x, Gr, Bk.bind(null, r, e), g);
    }
    function Hv(e, r, c) {
      typeof r != "function" && A("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", r !== null ? typeof r : "null");
      var g = c != null ? c.concat([e]) : null;
      return zv(en, Gr, Bk.bind(null, r, e), g);
    }
    function _D(e, r) {
    }
    var jv = _D;
    function k0(e, r) {
      var c = So(), g = r === void 0 ? null : r;
      return c.memoizedState = [e, g], e;
    }
    function Bv(e, r) {
      var c = as(), g = r === void 0 ? null : r, x = c.memoizedState;
      if (x !== null && g !== null) {
        var R = x[1];
        if (d0(g, R))
          return x[0];
      }
      return c.memoizedState = [e, g], e;
    }
    function C0(e, r) {
      var c = So(), g = r === void 0 ? null : r, x = e();
      return c.memoizedState = [x, g], x;
    }
    function Wv(e, r) {
      var c = as(), g = r === void 0 ? null : r, x = c.memoizedState;
      if (x !== null && g !== null) {
        var R = x[1];
        if (d0(g, R))
          return x[0];
      }
      var _ = e();
      return c.memoizedState = [_, g], _;
    }
    function T0(e) {
      var r = So();
      return r.memoizedState = e, e;
    }
    function Wk(e) {
      var r = as(), c = $r, g = c.memoizedState;
      return Xk(r, g, e);
    }
    function Uk(e) {
      var r = as();
      if ($r === null)
        return r.memoizedState = e, e;
      var c = $r.memoizedState;
      return Xk(r, c, e);
    }
    function Xk(e, r, c) {
      var g = !Dx(Lc);
      if (g) {
        if (!wt(c, r)) {
          var x = Mh();
          Mn.lanes = tn(Mn.lanes, x), Gp(x), e.baseState = !0;
        }
        return r;
      } else
        return e.baseState && (e.baseState = !1, Np()), e.memoizedState = c, c;
    }
    function PD(e, r, c) {
      var g = wi();
      Ar(da(g, Xr)), e(!0);
      var x = Ap.transition;
      Ap.transition = {};
      var R = Ap.transition;
      Ap.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        e(!1), r();
      } finally {
        if (Ar(g), Ap.transition = x, x === null && R._updatedFibers) {
          var _ = R._updatedFibers.size;
          _ > 10 && T("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), R._updatedFibers.clear();
        }
      }
    }
    function A0() {
      var e = Pv(!1), r = e[0], c = e[1], g = PD.bind(null, c), x = So();
      return x.memoizedState = g, [r, g];
    }
    function Vk() {
      var e = v0(), r = e[0], c = as(), g = c.memoizedState;
      return [r, g];
    }
    function Gk() {
      var e = y0(), r = e[0], c = as(), g = c.memoizedState;
      return [r, g];
    }
    var $k = !1;
    function ND() {
      return $k;
    }
    function E0() {
      var e = So(), r = uy(), c = r.identifierPrefix, g;
      if (ka()) {
        var x = qO();
        g = ":" + c + "R" + x;
        var R = Rp++;
        R > 0 && (g += "H" + R.toString(32)), g += ":";
      } else {
        var _ = OD++;
        g = ":" + c + "r" + _.toString(32) + ":";
      }
      return e.memoizedState = g, g;
    }
    function Uv() {
      var e = as(), r = e.memoizedState;
      return r;
    }
    function zD(e, r, c) {
      typeof arguments[3] == "function" && A("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var g = Tu(e), x = {
        lane: g,
        action: c,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (qk(e))
        Zk(r, x);
      else {
        var R = hk(e, r, x, g);
        if (R !== null) {
          var _ = li();
          Jr(R, e, g, _), Qk(R, r, g);
        }
      }
      Kk(e, g);
    }
    function ID(e, r, c) {
      typeof arguments[3] == "function" && A("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var g = Tu(e), x = {
        lane: g,
        action: c,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (qk(e))
        Zk(r, x);
      else {
        var R = e.alternate;
        if (e.lanes === Ne && (R === null || R.lanes === Ne)) {
          var _ = r.lastRenderedReducer;
          if (_ !== null) {
            var Y;
            Y = ut.current, ut.current = zs;
            try {
              var U = r.lastRenderedState, J = _(U, c);
              if (x.hasEagerState = !0, x.eagerState = J, wt(J, U)) {
                gD(e, r, x, g);
                return;
              }
            } catch {
            } finally {
              ut.current = Y;
            }
          }
        }
        var ne = hk(e, r, x, g);
        if (ne !== null) {
          var ge = li();
          Jr(ne, e, g, ge), Qk(ne, r, g);
        }
      }
      Kk(e, g);
    }
    function qk(e) {
      var r = e.alternate;
      return e === Mn || r !== null && r === Mn;
    }
    function Zk(e, r) {
      Ep = Mv = !0;
      var c = e.pending;
      c === null ? r.next = r : (r.next = c.next, c.next = r), e.pending = r;
    }
    function Qk(e, r, c) {
      if (Dh(c)) {
        var g = r.lanes;
        g = _h(g, e.pendingLanes);
        var x = tn(g, c);
        r.lanes = x, Ql(e, x);
      }
    }
    function Kk(e, r, c) {
      uo(e, r);
    }
    var Xv = {
      readContext: Hr,
      useCallback: Ua,
      useContext: Ua,
      useEffect: Ua,
      useImperativeHandle: Ua,
      useInsertionEffect: Ua,
      useLayoutEffect: Ua,
      useMemo: Ua,
      useReducer: Ua,
      useRef: Ua,
      useState: Ua,
      useDebugValue: Ua,
      useDeferredValue: Ua,
      useTransition: Ua,
      useMutableSource: Ua,
      useSyncExternalStore: Ua,
      useId: Ua,
      unstable_isNewReconciler: We
    }, Jk = null, eC = null, tC = null, nC = null, ko = null, zs = null, Vv = null;
    {
      var R0 = function() {
        A("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Gt = function() {
        A("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      Jk = {
        readContext: function(e) {
          return Hr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", An(), bf(r), k0(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", An(), Hr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", An(), bf(r), Iv(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", An(), bf(c), S0(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", An(), bf(r), b0(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", An(), bf(r), w0(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", An(), bf(r);
          var c = ut.current;
          ut.current = ko;
          try {
            return C0(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", An();
          var g = ut.current;
          ut.current = ko;
          try {
            return h0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", An(), x0(e);
        },
        useState: function(e) {
          ze = "useState", An();
          var r = ut.current;
          ut.current = ko;
          try {
            return Pv(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", An(), void 0;
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", An(), T0(e);
        },
        useTransition: function() {
          return ze = "useTransition", An(), A0();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", An(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", An(), m0(e, r, c);
        },
        useId: function() {
          return ze = "useId", An(), E0();
        },
        unstable_isNewReconciler: We
      }, eC = {
        readContext: function(e) {
          return Hr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", rt(), k0(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", rt(), Hr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", rt(), Iv(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", rt(), S0(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", rt(), b0(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", rt(), w0(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", rt();
          var c = ut.current;
          ut.current = ko;
          try {
            return C0(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", rt();
          var g = ut.current;
          ut.current = ko;
          try {
            return h0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", rt(), x0(e);
        },
        useState: function(e) {
          ze = "useState", rt();
          var r = ut.current;
          ut.current = ko;
          try {
            return Pv(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", rt(), void 0;
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", rt(), T0(e);
        },
        useTransition: function() {
          return ze = "useTransition", rt(), A0();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", rt(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", rt(), m0(e, r, c);
        },
        useId: function() {
          return ze = "useId", rt(), E0();
        },
        unstable_isNewReconciler: We
      }, tC = {
        readContext: function(e) {
          return Hr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", rt(), Bv(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", rt(), Hr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", rt(), Dp(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", rt(), Hv(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", rt(), Fv(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", rt(), Yv(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", rt();
          var c = ut.current;
          ut.current = zs;
          try {
            return Wv(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", rt();
          var g = ut.current;
          ut.current = zs;
          try {
            return p0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", rt(), Nv();
        },
        useState: function(e) {
          ze = "useState", rt();
          var r = ut.current;
          ut.current = zs;
          try {
            return v0(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", rt(), jv();
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", rt(), Wk(e);
        },
        useTransition: function() {
          return ze = "useTransition", rt(), Vk();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", rt(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", rt(), _v(e, r);
        },
        useId: function() {
          return ze = "useId", rt(), Uv();
        },
        unstable_isNewReconciler: We
      }, nC = {
        readContext: function(e) {
          return Hr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", rt(), Bv(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", rt(), Hr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", rt(), Dp(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", rt(), Hv(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", rt(), Fv(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", rt(), Yv(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", rt();
          var c = ut.current;
          ut.current = Vv;
          try {
            return Wv(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", rt();
          var g = ut.current;
          ut.current = Vv;
          try {
            return g0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", rt(), Nv();
        },
        useState: function(e) {
          ze = "useState", rt();
          var r = ut.current;
          ut.current = Vv;
          try {
            return y0(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", rt(), jv();
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", rt(), Uk(e);
        },
        useTransition: function() {
          return ze = "useTransition", rt(), Gk();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", rt(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", rt(), _v(e, r);
        },
        useId: function() {
          return ze = "useId", rt(), Uv();
        },
        unstable_isNewReconciler: We
      }, ko = {
        readContext: function(e) {
          return R0(), Hr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", Gt(), An(), k0(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", Gt(), An(), Hr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", Gt(), An(), Iv(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", Gt(), An(), S0(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", Gt(), An(), b0(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", Gt(), An(), w0(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", Gt(), An();
          var c = ut.current;
          ut.current = ko;
          try {
            return C0(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", Gt(), An();
          var g = ut.current;
          ut.current = ko;
          try {
            return h0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", Gt(), An(), x0(e);
        },
        useState: function(e) {
          ze = "useState", Gt(), An();
          var r = ut.current;
          ut.current = ko;
          try {
            return Pv(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", Gt(), An(), void 0;
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", Gt(), An(), T0(e);
        },
        useTransition: function() {
          return ze = "useTransition", Gt(), An(), A0();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", Gt(), An(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", Gt(), An(), m0(e, r, c);
        },
        useId: function() {
          return ze = "useId", Gt(), An(), E0();
        },
        unstable_isNewReconciler: We
      }, zs = {
        readContext: function(e) {
          return R0(), Hr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", Gt(), rt(), Bv(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", Gt(), rt(), Hr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", Gt(), rt(), Dp(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", Gt(), rt(), Hv(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", Gt(), rt(), Fv(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", Gt(), rt(), Yv(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", Gt(), rt();
          var c = ut.current;
          ut.current = zs;
          try {
            return Wv(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", Gt(), rt();
          var g = ut.current;
          ut.current = zs;
          try {
            return p0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", Gt(), rt(), Nv();
        },
        useState: function(e) {
          ze = "useState", Gt(), rt();
          var r = ut.current;
          ut.current = zs;
          try {
            return v0(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", Gt(), rt(), jv();
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", Gt(), rt(), Wk(e);
        },
        useTransition: function() {
          return ze = "useTransition", Gt(), rt(), Vk();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", Gt(), rt(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", Gt(), rt(), _v(e, r);
        },
        useId: function() {
          return ze = "useId", Gt(), rt(), Uv();
        },
        unstable_isNewReconciler: We
      }, Vv = {
        readContext: function(e) {
          return R0(), Hr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", Gt(), rt(), Bv(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", Gt(), rt(), Hr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", Gt(), rt(), Dp(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", Gt(), rt(), Hv(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", Gt(), rt(), Fv(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", Gt(), rt(), Yv(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", Gt(), rt();
          var c = ut.current;
          ut.current = zs;
          try {
            return Wv(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", Gt(), rt();
          var g = ut.current;
          ut.current = zs;
          try {
            return g0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", Gt(), rt(), Nv();
        },
        useState: function(e) {
          ze = "useState", Gt(), rt();
          var r = ut.current;
          ut.current = zs;
          try {
            return y0(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", Gt(), rt(), jv();
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", Gt(), rt(), Uk(e);
        },
        useTransition: function() {
          return ze = "useTransition", Gt(), rt(), Gk();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", Gt(), rt(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", Gt(), rt(), _v(e, r);
        },
        useId: function() {
          return ze = "useId", Gt(), rt(), Uv();
        },
        unstable_isNewReconciler: We
      };
    }
    var wu = u.unstable_now, rC = 0, Gv = -1, Mp = -1, $v = -1, L0 = !1, qv = !1;
    function aC() {
      return L0;
    }
    function FD() {
      qv = !0;
    }
    function YD() {
      L0 = !1, qv = !1;
    }
    function HD() {
      L0 = qv, qv = !1;
    }
    function iC() {
      return rC;
    }
    function sC() {
      rC = wu();
    }
    function O0(e) {
      Mp = wu(), e.actualStartTime < 0 && (e.actualStartTime = wu());
    }
    function oC(e) {
      Mp = -1;
    }
    function Zv(e, r) {
      if (Mp >= 0) {
        var c = wu() - Mp;
        e.actualDuration += c, r && (e.selfBaseDuration = c), Mp = -1;
      }
    }
    function Co(e) {
      if (Gv >= 0) {
        var r = wu() - Gv;
        Gv = -1;
        for (var c = e.return; c !== null; ) {
          switch (c.tag) {
            case q:
              var g = c.stateNode;
              g.effectDuration += r;
              return;
            case Ee:
              var x = c.stateNode;
              x.effectDuration += r;
              return;
          }
          c = c.return;
        }
      }
    }
    function D0(e) {
      if ($v >= 0) {
        var r = wu() - $v;
        $v = -1;
        for (var c = e.return; c !== null; ) {
          switch (c.tag) {
            case q:
              var g = c.stateNode;
              g !== null && (g.passiveEffectDuration += r);
              return;
            case Ee:
              var x = c.stateNode;
              x !== null && (x.passiveEffectDuration += r);
              return;
          }
          c = c.return;
        }
      }
    }
    function To() {
      Gv = wu();
    }
    function M0() {
      $v = wu();
    }
    function _0(e) {
      for (var r = e.child; r; )
        e.actualDuration += r.actualDuration, r = r.sibling;
    }
    function Oc(e, r) {
      return {
        value: e,
        source: r,
        stack: at(r),
        digest: null
      };
    }
    function P0(e, r, c) {
      return {
        value: e,
        source: null,
        stack: c ?? null,
        digest: r ?? null
      };
    }
    function jD(e, r) {
      return !0;
    }
    function N0(e, r) {
      try {
        var c = jD(e, r);
        if (c === !1)
          return;
        var g = r.value, x = r.source, R = r.stack, _ = R !== null ? R : "";
        if (g != null && g._suppressLogging) {
          if (e.tag === j)
            return;
          console.error(g);
        }
        var Y = x ? vt(x) : null, U = Y ? "The above error occurred in the <" + Y + "> component:" : "The above error occurred in one of your React components:", J;
        if (e.tag === q)
          J = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var ne = vt(e) || "Anonymous";
          J = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + ne + ".");
        }
        var ge = U + `
` + _ + `

` + ("" + J);
        console.error(ge);
      } catch (he) {
        setTimeout(function() {
          throw he;
        });
      }
    }
    var BD = typeof WeakMap == "function" ? WeakMap : Map;
    function lC(e, r, c) {
      var g = pl(Fn, c);
      g.tag = Nb, g.payload = {
        element: null
      };
      var x = r.value;
      return g.callback = function() {
        P2(x), N0(e, r);
      }, g;
    }
    function z0(e, r, c) {
      var g = pl(Fn, c);
      g.tag = Nb;
      var x = e.type.getDerivedStateFromError;
      if (typeof x == "function") {
        var R = r.value;
        g.payload = function() {
          return x(R);
        }, g.callback = function() {
          xT(e), N0(e, r);
        };
      }
      var _ = e.stateNode;
      return _ !== null && typeof _.componentDidCatch == "function" && (g.callback = function() {
        xT(e), N0(e, r), typeof x != "function" && M2(this);
        var U = r.value, J = r.stack;
        this.componentDidCatch(U, {
          componentStack: J !== null ? J : ""
        }), typeof x != "function" && (ja(e.lanes, Bt) || A("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", vt(e) || "Unknown"));
      }), g;
    }
    function uC(e, r, c) {
      var g = e.pingCache, x;
      if (g === null ? (g = e.pingCache = new BD(), x = /* @__PURE__ */ new Set(), g.set(r, x)) : (x = g.get(r), x === void 0 && (x = /* @__PURE__ */ new Set(), g.set(r, x))), !x.has(c)) {
        x.add(c);
        var R = N2.bind(null, e, r, c);
        Ur && $p(e, c), r.then(R, R);
      }
    }
    function WD(e, r, c, g) {
      var x = e.updateQueue;
      if (x === null) {
        var R = /* @__PURE__ */ new Set();
        R.add(c), e.updateQueue = R;
      } else
        x.add(c);
    }
    function UD(e, r) {
      var c = e.tag;
      if ((e.mode & rn) === Ft && (c === H || c === we || c === Me)) {
        var g = e.alternate;
        g ? (e.updateQueue = g.updateQueue, e.memoizedState = g.memoizedState, e.lanes = g.lanes) : (e.updateQueue = null, e.memoizedState = null);
      }
    }
    function cC(e) {
      var r = e;
      do {
        if (r.tag === re && RD(r))
          return r;
        r = r.return;
      } while (r !== null);
      return null;
    }
    function dC(e, r, c, g, x) {
      if ((e.mode & rn) === Ft) {
        if (e === r)
          e.flags |= Nr;
        else {
          if (e.flags |= Xt, c.flags |= Ku, c.flags &= ~(sd | ei), c.tag === j) {
            var R = c.alternate;
            if (R === null)
              c.tag = Ve;
            else {
              var _ = pl(Fn, Bt);
              _.tag = bv, vu(c, _, Bt);
            }
          }
          c.lanes = tn(c.lanes, Bt);
        }
        return e;
      }
      return e.flags |= Nr, e.lanes = x, e;
    }
    function XD(e, r, c, g, x) {
      if (c.flags |= ei, Ur && $p(e, x), g !== null && typeof g == "object" && typeof g.then == "function") {
        var R = g;
        UD(c), ka() && c.mode & rn && tk();
        var _ = cC(r);
        if (_ !== null) {
          _.flags &= ~lr, dC(_, r, c, e, x), _.mode & rn && uC(e, R, x), WD(_, e, R);
          return;
        } else {
          if (!ql(x)) {
            uC(e, R, x), gw();
            return;
          }
          var Y = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          g = Y;
        }
      } else if (ka() && c.mode & rn) {
        tk();
        var U = cC(r);
        if (U !== null) {
          (U.flags & Nr) === _t && (U.flags |= lr), dC(U, r, c, e, x), Rb(Oc(g, c));
          return;
        }
      }
      g = Oc(g, c), C2(g);
      var J = r;
      do {
        switch (J.tag) {
          case q: {
            var ne = g;
            J.flags |= Nr;
            var ge = Tr(x);
            J.lanes = tn(J.lanes, ge);
            var he = lC(J, ne, ge);
            Fb(J, he);
            return;
          }
          case j:
            var Te = g, Ae = J.type, Oe = J.stateNode;
            if ((J.flags & Xt) === _t && (typeof Ae.getDerivedStateFromError == "function" || Oe !== null && typeof Oe.componentDidCatch == "function" && !cT(Oe))) {
              J.flags |= Nr;
              var dt = Tr(x);
              J.lanes = tn(J.lanes, dt);
              var zt = z0(J, Te, dt);
              Fb(J, zt);
              return;
            }
            break;
        }
        J = J.return;
      } while (J !== null);
    }
    function VD() {
      return null;
    }
    var _p = h.ReactCurrentOwner, Is = !1, I0, Pp, F0, Y0, H0, Dc, j0, Qv;
    I0 = {}, Pp = {}, F0 = {}, Y0 = {}, H0 = {}, Dc = !1, j0 = {}, Qv = {};
    function si(e, r, c, g) {
      e === null ? r.child = Lk(r, null, c, g) : r.child = gf(r, e.child, c, g);
    }
    function GD(e, r, c, g) {
      r.child = gf(r, e.child, null, g), r.child = gf(r, null, c, g);
    }
    function fC(e, r, c, g, x) {
      if (r.type !== r.elementType) {
        var R = c.propTypes;
        R && Ds(
          R,
          g,
          // Resolved props
          "prop",
          xt(c)
        );
      }
      var _ = c.render, Y = r.ref, U, J;
      pf(r, x), lo(r);
      {
        if (_p.current = r, zi(!0), U = wf(e, r, _, g, Y, x), J = Sf(), r.mode & Kn) {
          Cr(!0);
          try {
            U = wf(e, r, _, g, Y, x), J = Sf();
          } finally {
            Cr(!1);
          }
        }
        zi(!1);
      }
      return Wo(), e !== null && !Is ? (Pk(e, r, x), gl(e, r, x)) : (ka() && J && Sb(r), r.flags |= to, si(e, r, U, x), r.child);
    }
    function hC(e, r, c, g, x) {
      if (e === null) {
        var R = c.type;
        if (K2(R) && c.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        c.defaultProps === void 0) {
          var _ = R;
          return _ = Of(R), r.tag = Me, r.type = _, U0(r, R), pC(e, r, _, g, x);
        }
        {
          var Y = R.propTypes;
          Y && Ds(
            Y,
            g,
            // Resolved props
            "prop",
            xt(R)
          );
        }
        var U = Aw(c.type, null, g, r, r.mode, x);
        return U.ref = r.ref, U.return = r, r.child = U, U;
      }
      {
        var J = c.type, ne = J.propTypes;
        ne && Ds(
          ne,
          g,
          // Resolved props
          "prop",
          xt(J)
        );
      }
      var ge = e.child, he = Z0(e, x);
      if (!he) {
        var Te = ge.memoizedProps, Ae = c.compare;
        if (Ae = Ae !== null ? Ae : Ot, Ae(Te, g) && e.ref === r.ref)
          return gl(e, r, x);
      }
      r.flags |= to;
      var Oe = zc(ge, g);
      return Oe.ref = r.ref, Oe.return = r, r.child = Oe, Oe;
    }
    function pC(e, r, c, g, x) {
      if (r.type !== r.elementType) {
        var R = r.elementType;
        if (R.$$typeof === Mt) {
          var _ = R, Y = _._payload, U = _._init;
          try {
            R = U(Y);
          } catch {
            R = null;
          }
          var J = R && R.propTypes;
          J && Ds(
            J,
            g,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            xt(R)
          );
        }
      }
      if (e !== null) {
        var ne = e.memoizedProps;
        if (Ot(ne, g) && e.ref === r.ref && // Prevent bailout if the implementation changed due to hot reload.
        r.type === e.type)
          if (Is = !1, r.pendingProps = g = ne, Z0(e, x))
            (e.flags & Ku) !== _t && (Is = !0);
          else
            return r.lanes = e.lanes, gl(e, r, x);
      }
      return B0(e, r, c, g, x);
    }
    function gC(e, r, c) {
      var g = r.pendingProps, x = g.children, R = e !== null ? e.memoizedState : null;
      if (g.mode === "hidden" || ye)
        if ((r.mode & rn) === Ft) {
          var _ = {
            baseLanes: Ne,
            cachePool: null,
            transitions: null
          };
          r.memoizedState = _, cy(r, c);
        } else if (ja(c, Ha)) {
          var ge = {
            baseLanes: Ne,
            cachePool: null,
            transitions: null
          };
          r.memoizedState = ge;
          var he = R !== null ? R.baseLanes : c;
          cy(r, he);
        } else {
          var Y = null, U;
          if (R !== null) {
            var J = R.baseLanes;
            U = tn(J, c);
          } else
            U = c;
          r.lanes = r.childLanes = Ha;
          var ne = {
            baseLanes: U,
            cachePool: Y,
            transitions: null
          };
          return r.memoizedState = ne, r.updateQueue = null, cy(r, U), null;
        }
      else {
        var Te;
        R !== null ? (Te = tn(R.baseLanes, c), r.memoizedState = null) : Te = c, cy(r, Te);
      }
      return si(e, r, x, c), r.child;
    }
    function $D(e, r, c) {
      var g = r.pendingProps;
      return si(e, r, g, c), r.child;
    }
    function qD(e, r, c) {
      var g = r.pendingProps.children;
      return si(e, r, g, c), r.child;
    }
    function ZD(e, r, c) {
      {
        r.flags |= en;
        {
          var g = r.stateNode;
          g.effectDuration = 0, g.passiveEffectDuration = 0;
        }
      }
      var x = r.pendingProps, R = x.children;
      return si(e, r, R, c), r.child;
    }
    function mC(e, r) {
      var c = r.ref;
      (e === null && c !== null || e !== null && e.ref !== c) && (r.flags |= Pa, r.flags |= mh);
    }
    function B0(e, r, c, g, x) {
      if (r.type !== r.elementType) {
        var R = c.propTypes;
        R && Ds(
          R,
          g,
          // Resolved props
          "prop",
          xt(c)
        );
      }
      var _;
      {
        var Y = lf(r, c, !0);
        _ = uf(r, Y);
      }
      var U, J;
      pf(r, x), lo(r);
      {
        if (_p.current = r, zi(!0), U = wf(e, r, c, g, _, x), J = Sf(), r.mode & Kn) {
          Cr(!0);
          try {
            U = wf(e, r, c, g, _, x), J = Sf();
          } finally {
            Cr(!1);
          }
        }
        zi(!1);
      }
      return Wo(), e !== null && !Is ? (Pk(e, r, x), gl(e, r, x)) : (ka() && J && Sb(r), r.flags |= to, si(e, r, U, x), r.child);
    }
    function vC(e, r, c, g, x) {
      {
        switch (h_(r)) {
          case !1: {
            var R = r.stateNode, _ = r.type, Y = new _(r.memoizedProps, R.context), U = Y.state;
            R.updater.enqueueSetState(R, U, null);
            break;
          }
          case !0: {
            r.flags |= Xt, r.flags |= Nr;
            var J = new Error("Simulated error coming from DevTools"), ne = Tr(x);
            r.lanes = tn(r.lanes, ne);
            var ge = z0(r, Oc(J, r), ne);
            Fb(r, ge);
            break;
          }
        }
        if (r.type !== r.elementType) {
          var he = c.propTypes;
          he && Ds(
            he,
            g,
            // Resolved props
            "prop",
            xt(c)
          );
        }
      }
      var Te;
      bo(c) ? (Te = !0, uv(r)) : Te = !1, pf(r, x);
      var Ae = r.stateNode, Oe;
      Ae === null ? (Jv(e, r), Ck(r, c, g), Zb(r, c, g, x), Oe = !0) : e === null ? Oe = SD(r, c, g, x) : Oe = kD(e, r, c, g, x);
      var dt = W0(e, r, c, Oe, Te, x);
      {
        var zt = r.stateNode;
        Oe && zt.props !== g && (Dc || A("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", vt(r) || "a component"), Dc = !0);
      }
      return dt;
    }
    function W0(e, r, c, g, x, R) {
      mC(e, r);
      var _ = (r.flags & Xt) !== _t;
      if (!g && !_)
        return x && QS(r, c, !1), gl(e, r, R);
      var Y = r.stateNode;
      _p.current = r;
      var U;
      if (_ && typeof c.getDerivedStateFromError != "function")
        U = null, oC();
      else {
        lo(r);
        {
          if (zi(!0), U = Y.render(), r.mode & Kn) {
            Cr(!0);
            try {
              Y.render();
            } finally {
              Cr(!1);
            }
          }
          zi(!1);
        }
        Wo();
      }
      return r.flags |= to, e !== null && _ ? GD(e, r, U, R) : si(e, r, U, R), r.memoizedState = Y.state, x && QS(r, c, !0), r.child;
    }
    function yC(e) {
      var r = e.stateNode;
      r.pendingContext ? qS(e, r.pendingContext, r.pendingContext !== r.context) : r.context && qS(e, r.context, !1), n0(e, r.containerInfo);
    }
    function QD(e, r, c) {
      if (yC(r), e === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var g = r.pendingProps, x = r.memoizedState, R = x.element;
      mk(e, r), Cv(r, g, null, c);
      var _ = r.memoizedState;
      r.stateNode;
      var Y = _.element;
      if (x.isDehydrated) {
        var U = {
          element: Y,
          isDehydrated: !1,
          cache: _.cache,
          pendingSuspenseBoundaries: _.pendingSuspenseBoundaries,
          transitions: _.transitions
        }, J = r.updateQueue;
        if (J.baseState = U, r.memoizedState = U, r.flags & lr) {
          var ne = Oc(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), r);
          return xC(e, r, Y, c, ne);
        } else if (Y !== R) {
          var ge = Oc(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), r);
          return xC(e, r, Y, c, ge);
        } else {
          tD(r);
          var he = Lk(r, null, Y, c);
          r.child = he;
          for (var Te = he; Te; )
            Te.flags = Te.flags & ~Wn | mi, Te = Te.sibling;
        }
      } else {
        if (ff(), Y === R)
          return gl(e, r, c);
        si(e, r, Y, c);
      }
      return r.child;
    }
    function xC(e, r, c, g, x) {
      return ff(), Rb(x), r.flags |= lr, si(e, r, c, g), r.child;
    }
    function KD(e, r, c) {
      Dk(r), e === null && Eb(r);
      var g = r.type, x = r.pendingProps, R = e !== null ? e.memoizedProps : null, _ = x.children, Y = lb(g, x);
      return Y ? _ = null : R !== null && lb(g, R) && (r.flags |= Tn), mC(e, r), si(e, r, _, c), r.child;
    }
    function JD(e, r) {
      return e === null && Eb(r), null;
    }
    function eM(e, r, c, g) {
      Jv(e, r);
      var x = r.pendingProps, R = c, _ = R._payload, Y = R._init, U = Y(_);
      r.type = U;
      var J = r.tag = J2(U), ne = Ps(U, x), ge;
      switch (J) {
        case H:
          return U0(r, U), r.type = U = Of(U), ge = B0(null, r, U, ne, g), ge;
        case j:
          return r.type = U = bw(U), ge = vC(null, r, U, ne, g), ge;
        case we:
          return r.type = U = ww(U), ge = fC(null, r, U, ne, g), ge;
        case me: {
          if (r.type !== r.elementType) {
            var he = U.propTypes;
            he && Ds(
              he,
              ne,
              // Resolved for outer only
              "prop",
              xt(U)
            );
          }
          return ge = hC(
            null,
            r,
            U,
            Ps(U.type, ne),
            // The inner type can have defaults too
            g
          ), ge;
        }
      }
      var Te = "";
      throw U !== null && typeof U == "object" && U.$$typeof === Mt && (Te = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + U + ". " + ("Lazy element type must resolve to a class or function." + Te));
    }
    function tM(e, r, c, g, x) {
      Jv(e, r), r.tag = j;
      var R;
      return bo(c) ? (R = !0, uv(r)) : R = !1, pf(r, x), Ck(r, c, g), Zb(r, c, g, x), W0(null, r, c, !0, R, x);
    }
    function nM(e, r, c, g) {
      Jv(e, r);
      var x = r.pendingProps, R;
      {
        var _ = lf(r, c, !1);
        R = uf(r, _);
      }
      pf(r, g);
      var Y, U;
      lo(r);
      {
        if (c.prototype && typeof c.prototype.render == "function") {
          var J = xt(c) || "Unknown";
          I0[J] || (A("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", J, J), I0[J] = !0);
        }
        r.mode & Kn && _s.recordLegacyContextWarning(r, null), zi(!0), _p.current = r, Y = wf(null, r, c, x, R, g), U = Sf(), zi(!1);
      }
      if (Wo(), r.flags |= to, typeof Y == "object" && Y !== null && typeof Y.render == "function" && Y.$$typeof === void 0) {
        var ne = xt(c) || "Unknown";
        Pp[ne] || (A("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ne, ne, ne), Pp[ne] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof Y == "object" && Y !== null && typeof Y.render == "function" && Y.$$typeof === void 0
      ) {
        {
          var ge = xt(c) || "Unknown";
          Pp[ge] || (A("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ge, ge, ge), Pp[ge] = !0);
        }
        r.tag = j, r.memoizedState = null, r.updateQueue = null;
        var he = !1;
        return bo(c) ? (he = !0, uv(r)) : he = !1, r.memoizedState = Y.state !== null && Y.state !== void 0 ? Y.state : null, Ib(r), kk(r, Y), Zb(r, c, x, g), W0(null, r, c, !0, he, g);
      } else {
        if (r.tag = H, r.mode & Kn) {
          Cr(!0);
          try {
            Y = wf(null, r, c, x, R, g), U = Sf();
          } finally {
            Cr(!1);
          }
        }
        return ka() && U && Sb(r), si(null, r, Y, g), U0(r, c), r.child;
      }
    }
    function U0(e, r) {
      {
        if (r && r.childContextTypes && A("%s(...): childContextTypes cannot be defined on a function component.", r.displayName || r.name || "Component"), e.ref !== null) {
          var c = "", g = oa();
          g && (c += `

Check the render method of \`` + g + "`.");
          var x = g || "", R = e._debugSource;
          R && (x = R.fileName + ":" + R.lineNumber), H0[x] || (H0[x] = !0, A("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", c));
        }
        if (typeof r.getDerivedStateFromProps == "function") {
          var _ = xt(r) || "Unknown";
          Y0[_] || (A("%s: Function components do not support getDerivedStateFromProps.", _), Y0[_] = !0);
        }
        if (typeof r.contextType == "object" && r.contextType !== null) {
          var Y = xt(r) || "Unknown";
          F0[Y] || (A("%s: Function components do not support contextType.", Y), F0[Y] = !0);
        }
      }
    }
    var X0 = {
      dehydrated: null,
      treeContext: null,
      retryLane: dn
    };
    function V0(e) {
      return {
        baseLanes: e,
        cachePool: VD(),
        transitions: null
      };
    }
    function rM(e, r) {
      var c = null;
      return {
        baseLanes: tn(e.baseLanes, r),
        cachePool: c,
        transitions: e.transitions
      };
    }
    function aM(e, r, c, g) {
      if (r !== null) {
        var x = r.memoizedState;
        if (x === null)
          return !1;
      }
      return i0(e, Tp);
    }
    function iM(e, r) {
      return Zl(e.childLanes, r);
    }
    function bC(e, r, c) {
      var g = r.pendingProps;
      p_(r) && (r.flags |= Xt);
      var x = Ns.current, R = !1, _ = (r.flags & Xt) !== _t;
      if (_ || aM(x, e) ? (R = !0, r.flags &= ~Xt) : (e === null || e.memoizedState !== null) && (x = ED(x, _k)), x = vf(x), xu(r, x), e === null) {
        Eb(r);
        var Y = r.memoizedState;
        if (Y !== null) {
          var U = Y.dehydrated;
          if (U !== null)
            return cM(r, U);
        }
        var J = g.children, ne = g.fallback;
        if (R) {
          var ge = sM(r, J, ne, c), he = r.child;
          return he.memoizedState = V0(c), r.memoizedState = X0, ge;
        } else
          return G0(r, J);
      } else {
        var Te = e.memoizedState;
        if (Te !== null) {
          var Ae = Te.dehydrated;
          if (Ae !== null)
            return dM(e, r, _, g, Ae, Te, c);
        }
        if (R) {
          var Oe = g.fallback, dt = g.children, zt = lM(e, r, dt, Oe, c), Rt = r.child, hn = e.child.memoizedState;
          return Rt.memoizedState = hn === null ? V0(c) : rM(hn, c), Rt.childLanes = iM(e, c), r.memoizedState = X0, zt;
        } else {
          var on = g.children, xe = oM(e, r, on, c);
          return r.memoizedState = null, xe;
        }
      }
    }
    function G0(e, r, c) {
      var g = e.mode, x = {
        mode: "visible",
        children: r
      }, R = $0(x, g);
      return R.return = e, e.child = R, R;
    }
    function sM(e, r, c, g) {
      var x = e.mode, R = e.child, _ = {
        mode: "hidden",
        children: r
      }, Y, U;
      return (x & rn) === Ft && R !== null ? (Y = R, Y.childLanes = Ne, Y.pendingProps = _, e.mode & jt && (Y.actualDuration = 0, Y.actualStartTime = -1, Y.selfBaseDuration = 0, Y.treeBaseDuration = 0), U = Eu(c, x, g, null)) : (Y = $0(_, x), U = Eu(c, x, g, null)), Y.return = e, U.return = e, Y.sibling = U, e.child = Y, U;
    }
    function $0(e, r, c) {
      return wT(e, r, Ne, null);
    }
    function wC(e, r) {
      return zc(e, r);
    }
    function oM(e, r, c, g) {
      var x = e.child, R = x.sibling, _ = wC(x, {
        mode: "visible",
        children: c
      });
      if ((r.mode & rn) === Ft && (_.lanes = g), _.return = r, _.sibling = null, R !== null) {
        var Y = r.deletions;
        Y === null ? (r.deletions = [R], r.flags |= Sn) : Y.push(R);
      }
      return r.child = _, _;
    }
    function lM(e, r, c, g, x) {
      var R = r.mode, _ = e.child, Y = _.sibling, U = {
        mode: "hidden",
        children: c
      }, J;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (R & rn) === Ft && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        r.child !== _
      ) {
        var ne = r.child;
        J = ne, J.childLanes = Ne, J.pendingProps = U, r.mode & jt && (J.actualDuration = 0, J.actualStartTime = -1, J.selfBaseDuration = _.selfBaseDuration, J.treeBaseDuration = _.treeBaseDuration), r.deletions = null;
      } else
        J = wC(_, U), J.subtreeFlags = _.subtreeFlags & Wr;
      var ge;
      return Y !== null ? ge = zc(Y, g) : (ge = Eu(g, R, x, null), ge.flags |= Wn), ge.return = r, J.return = r, J.sibling = ge, r.child = J, ge;
    }
    function Kv(e, r, c, g) {
      g !== null && Rb(g), gf(r, e.child, null, c);
      var x = r.pendingProps, R = x.children, _ = G0(r, R);
      return _.flags |= Wn, r.memoizedState = null, _;
    }
    function uM(e, r, c, g, x) {
      var R = r.mode, _ = {
        mode: "visible",
        children: c
      }, Y = $0(_, R), U = Eu(g, R, x, null);
      return U.flags |= Wn, Y.return = r, U.return = r, Y.sibling = U, r.child = Y, (r.mode & rn) !== Ft && gf(r, e.child, null, x), U;
    }
    function cM(e, r, c) {
      return (e.mode & rn) === Ft ? (A("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), e.lanes = Bt) : fb(r) ? e.lanes = Vo : e.lanes = Ha, null;
    }
    function dM(e, r, c, g, x, R, _) {
      if (c)
        if (r.flags & lr) {
          r.flags &= ~lr;
          var xe = P0(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return Kv(e, r, _, xe);
        } else {
          if (r.memoizedState !== null)
            return r.child = e.child, r.flags |= Xt, null;
          var De = g.children, be = g.fallback, Ue = uM(e, r, De, be, _), ft = r.child;
          return ft.memoizedState = V0(_), r.memoizedState = X0, Ue;
        }
      else {
        if (JO(), (r.mode & rn) === Ft)
          return Kv(
            e,
            r,
            _,
            // TODO: When we delete legacy mode, we should make this error argument
            // required  every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (fb(x)) {
          var Y, U, J;
          {
            var ne = mO(x);
            Y = ne.digest, U = ne.message, J = ne.stack;
          }
          var ge;
          U ? ge = new Error(U) : ge = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var he = P0(ge, Y, J);
          return Kv(e, r, _, he);
        }
        var Te = ja(_, e.childLanes);
        if (Is || Te) {
          var Ae = uy();
          if (Ae !== null) {
            var Oe = _x(Ae, _);
            if (Oe !== dn && Oe !== R.retryLane) {
              R.retryLane = Oe;
              var dt = Fn;
              Ai(e, Oe), Jr(Ae, e, Oe, dt);
            }
          }
          gw();
          var zt = P0(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return Kv(e, r, _, zt);
        } else if (WS(x)) {
          r.flags |= Xt, r.child = e.child;
          var Rt = z2.bind(null, e);
          return vO(x, Rt), null;
        } else {
          nD(r, x, R.treeContext);
          var hn = g.children, on = G0(r, hn);
          return on.flags |= mi, on;
        }
      }
    }
    function SC(e, r, c) {
      e.lanes = tn(e.lanes, r);
      var g = e.alternate;
      g !== null && (g.lanes = tn(g.lanes, r)), _b(e.return, r, c);
    }
    function fM(e, r, c) {
      for (var g = r; g !== null; ) {
        if (g.tag === re) {
          var x = g.memoizedState;
          x !== null && SC(g, c, e);
        } else if (g.tag === it)
          SC(g, c, e);
        else if (g.child !== null) {
          g.child.return = g, g = g.child;
          continue;
        }
        if (g === e)
          return;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === e)
            return;
          g = g.return;
        }
        g.sibling.return = g.return, g = g.sibling;
      }
    }
    function hM(e) {
      for (var r = e, c = null; r !== null; ) {
        var g = r.alternate;
        g !== null && Dv(g) === null && (c = r), r = r.sibling;
      }
      return c;
    }
    function pM(e) {
      if (e !== void 0 && e !== "forwards" && e !== "backwards" && e !== "together" && !j0[e])
        if (j0[e] = !0, typeof e == "string")
          switch (e.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              A('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', e, e.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              A('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', e, e.toLowerCase());
              break;
            }
            default:
              A('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
              break;
          }
        else
          A('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
    }
    function gM(e, r) {
      e !== void 0 && !Qv[e] && (e !== "collapsed" && e !== "hidden" ? (Qv[e] = !0, A('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', e)) : r !== "forwards" && r !== "backwards" && (Qv[e] = !0, A('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', e)));
    }
    function kC(e, r) {
      {
        var c = _r(e), g = !c && typeof f(e) == "function";
        if (c || g) {
          var x = c ? "array" : "iterable";
          return A("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", x, r, x), !1;
        }
      }
      return !0;
    }
    function mM(e, r) {
      if ((r === "forwards" || r === "backwards") && e !== void 0 && e !== null && e !== !1)
        if (_r(e)) {
          for (var c = 0; c < e.length; c++)
            if (!kC(e[c], c))
              return;
        } else {
          var g = f(e);
          if (typeof g == "function") {
            var x = g.call(e);
            if (x)
              for (var R = x.next(), _ = 0; !R.done; R = x.next()) {
                if (!kC(R.value, _))
                  return;
                _++;
              }
          } else
            A('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', r);
        }
    }
    function q0(e, r, c, g, x) {
      var R = e.memoizedState;
      R === null ? e.memoizedState = {
        isBackwards: r,
        rendering: null,
        renderingStartTime: 0,
        last: g,
        tail: c,
        tailMode: x
      } : (R.isBackwards = r, R.rendering = null, R.renderingStartTime = 0, R.last = g, R.tail = c, R.tailMode = x);
    }
    function CC(e, r, c) {
      var g = r.pendingProps, x = g.revealOrder, R = g.tail, _ = g.children;
      pM(x), gM(R, x), mM(_, x), si(e, r, _, c);
      var Y = Ns.current, U = i0(Y, Tp);
      if (U)
        Y = s0(Y, Tp), r.flags |= Xt;
      else {
        var J = e !== null && (e.flags & Xt) !== _t;
        J && fM(r, r.child, c), Y = vf(Y);
      }
      if (xu(r, Y), (r.mode & rn) === Ft)
        r.memoizedState = null;
      else
        switch (x) {
          case "forwards": {
            var ne = hM(r.child), ge;
            ne === null ? (ge = r.child, r.child = null) : (ge = ne.sibling, ne.sibling = null), q0(
              r,
              !1,
              // isBackwards
              ge,
              ne,
              R
            );
            break;
          }
          case "backwards": {
            var he = null, Te = r.child;
            for (r.child = null; Te !== null; ) {
              var Ae = Te.alternate;
              if (Ae !== null && Dv(Ae) === null) {
                r.child = Te;
                break;
              }
              var Oe = Te.sibling;
              Te.sibling = he, he = Te, Te = Oe;
            }
            q0(
              r,
              !0,
              // isBackwards
              he,
              null,
              // last
              R
            );
            break;
          }
          case "together": {
            q0(
              r,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            r.memoizedState = null;
        }
      return r.child;
    }
    function vM(e, r, c) {
      n0(r, r.stateNode.containerInfo);
      var g = r.pendingProps;
      return e === null ? r.child = gf(r, null, g, c) : si(e, r, g, c), r.child;
    }
    var TC = !1;
    function yM(e, r, c) {
      var g = r.type, x = g._context, R = r.pendingProps, _ = r.memoizedProps, Y = R.value;
      {
        "value" in R || TC || (TC = !0, A("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var U = r.type.propTypes;
        U && Ds(U, R, "prop", "Context.Provider");
      }
      if (fk(r, x, Y), _ !== null) {
        var J = _.value;
        if (wt(J, Y)) {
          if (_.children === R.children && !ov())
            return gl(e, r, c);
        } else
          fD(r, x, c);
      }
      var ne = R.children;
      return si(e, r, ne, c), r.child;
    }
    var AC = !1;
    function xM(e, r, c) {
      var g = r.type;
      g._context === void 0 ? g !== g.Consumer && (AC || (AC = !0, A("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : g = g._context;
      var x = r.pendingProps, R = x.children;
      typeof R != "function" && A("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), pf(r, c);
      var _ = Hr(g);
      lo(r);
      var Y;
      return _p.current = r, zi(!0), Y = R(_), zi(!1), Wo(), r.flags |= to, si(e, r, Y, c), r.child;
    }
    function Np() {
      Is = !0;
    }
    function Jv(e, r) {
      (r.mode & rn) === Ft && e !== null && (e.alternate = null, r.alternate = null, r.flags |= Wn);
    }
    function gl(e, r, c) {
      return e !== null && (r.dependencies = e.dependencies), oC(), Gp(r.lanes), ja(c, r.childLanes) ? (CD(e, r), r.child) : null;
    }
    function bM(e, r, c) {
      {
        var g = r.return;
        if (g === null)
          throw new Error("Cannot swap the root fiber.");
        if (e.alternate = null, r.alternate = null, c.index = r.index, c.sibling = r.sibling, c.return = r.return, c.ref = r.ref, r === g.child)
          g.child = c;
        else {
          var x = g.child;
          if (x === null)
            throw new Error("Expected parent to have a child.");
          for (; x.sibling !== r; )
            if (x = x.sibling, x === null)
              throw new Error("Expected to find the previous sibling.");
          x.sibling = c;
        }
        var R = g.deletions;
        return R === null ? (g.deletions = [e], g.flags |= Sn) : R.push(e), c.flags |= Wn, c;
      }
    }
    function Z0(e, r) {
      var c = e.lanes;
      return !!ja(c, r);
    }
    function wM(e, r, c) {
      switch (r.tag) {
        case q:
          yC(r), r.stateNode, ff();
          break;
        case ae:
          Dk(r);
          break;
        case j: {
          var g = r.type;
          bo(g) && uv(r);
          break;
        }
        case te:
          n0(r, r.stateNode.containerInfo);
          break;
        case K: {
          var x = r.memoizedProps.value, R = r.type._context;
          fk(r, R, x);
          break;
        }
        case Ee:
          {
            var _ = ja(c, r.childLanes);
            _ && (r.flags |= en);
            {
              var Y = r.stateNode;
              Y.effectDuration = 0, Y.passiveEffectDuration = 0;
            }
          }
          break;
        case re: {
          var U = r.memoizedState;
          if (U !== null) {
            if (U.dehydrated !== null)
              return xu(r, vf(Ns.current)), r.flags |= Xt, null;
            var J = r.child, ne = J.childLanes;
            if (ja(c, ne))
              return bC(e, r, c);
            xu(r, vf(Ns.current));
            var ge = gl(e, r, c);
            return ge !== null ? ge.sibling : null;
          } else
            xu(r, vf(Ns.current));
          break;
        }
        case it: {
          var he = (e.flags & Xt) !== _t, Te = ja(c, r.childLanes);
          if (he) {
            if (Te)
              return CC(e, r, c);
            r.flags |= Xt;
          }
          var Ae = r.memoizedState;
          if (Ae !== null && (Ae.rendering = null, Ae.tail = null, Ae.lastEffect = null), xu(r, Ns.current), Te)
            break;
          return null;
        }
        case Ke:
        case Ze:
          return r.lanes = Ne, gC(e, r, c);
      }
      return gl(e, r, c);
    }
    function EC(e, r, c) {
      if (r._debugNeedsRemount && e !== null)
        return bM(e, r, Aw(r.type, r.key, r.pendingProps, r._debugOwner || null, r.mode, r.lanes));
      if (e !== null) {
        var g = e.memoizedProps, x = r.pendingProps;
        if (g !== x || ov() || // Force a re-render if the implementation changed due to hot reload:
        r.type !== e.type)
          Is = !0;
        else {
          var R = Z0(e, c);
          if (!R && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (r.flags & Xt) === _t)
            return Is = !1, wM(e, r, c);
          (e.flags & Ku) !== _t ? Is = !0 : Is = !1;
        }
      } else if (Is = !1, ka() && GO(r)) {
        var _ = r.index, Y = $O();
        ek(r, Y, _);
      }
      switch (r.lanes = Ne, r.tag) {
        case V:
          return nM(e, r, r.type, c);
        case Je: {
          var U = r.elementType;
          return eM(e, r, U, c);
        }
        case H: {
          var J = r.type, ne = r.pendingProps, ge = r.elementType === J ? ne : Ps(J, ne);
          return B0(e, r, J, ge, c);
        }
        case j: {
          var he = r.type, Te = r.pendingProps, Ae = r.elementType === he ? Te : Ps(he, Te);
          return vC(e, r, he, Ae, c);
        }
        case q:
          return QD(e, r, c);
        case ae:
          return KD(e, r, c);
        case se:
          return JD(e, r);
        case re:
          return bC(e, r, c);
        case te:
          return vM(e, r, c);
        case we: {
          var Oe = r.type, dt = r.pendingProps, zt = r.elementType === Oe ? dt : Ps(Oe, dt);
          return fC(e, r, Oe, zt, c);
        }
        case ue:
          return $D(e, r, c);
        case Ce:
          return qD(e, r, c);
        case Ee:
          return ZD(e, r, c);
        case K:
          return yM(e, r, c);
        case Pe:
          return xM(e, r, c);
        case me: {
          var Rt = r.type, hn = r.pendingProps, on = Ps(Rt, hn);
          if (r.type !== r.elementType) {
            var xe = Rt.propTypes;
            xe && Ds(
              xe,
              on,
              // Resolved for outer only
              "prop",
              xt(Rt)
            );
          }
          return on = Ps(Rt.type, on), hC(e, r, Rt, on, c);
        }
        case Me:
          return pC(e, r, r.type, r.pendingProps, c);
        case Ve: {
          var De = r.type, be = r.pendingProps, Ue = r.elementType === De ? be : Ps(De, be);
          return tM(e, r, De, Ue, c);
        }
        case it:
          return CC(e, r, c);
        case ht:
          break;
        case Ke:
          return gC(e, r, c);
      }
      throw new Error("Unknown unit of work tag (" + r.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function kf(e) {
      e.flags |= en;
    }
    function RC(e) {
      e.flags |= Pa, e.flags |= mh;
    }
    var LC, Q0, OC, DC;
    LC = function(e, r, c, g) {
      for (var x = r.child; x !== null; ) {
        if (x.tag === ae || x.tag === se)
          UL(e, x.stateNode);
        else if (x.tag !== te) {
          if (x.child !== null) {
            x.child.return = x, x = x.child;
            continue;
          }
        }
        if (x === r)
          return;
        for (; x.sibling === null; ) {
          if (x.return === null || x.return === r)
            return;
          x = x.return;
        }
        x.sibling.return = x.return, x = x.sibling;
      }
    }, Q0 = function(e, r) {
    }, OC = function(e, r, c, g, x) {
      var R = e.memoizedProps;
      if (R !== g) {
        var _ = r.stateNode, Y = r0(), U = VL(_, c, R, g, x, Y);
        r.updateQueue = U, U && kf(r);
      }
    }, DC = function(e, r, c, g) {
      c !== g && kf(r);
    };
    function zp(e, r) {
      if (!ka())
        switch (e.tailMode) {
          case "hidden": {
            for (var c = e.tail, g = null; c !== null; )
              c.alternate !== null && (g = c), c = c.sibling;
            g === null ? e.tail = null : g.sibling = null;
            break;
          }
          case "collapsed": {
            for (var x = e.tail, R = null; x !== null; )
              x.alternate !== null && (R = x), x = x.sibling;
            R === null ? !r && e.tail !== null ? e.tail.sibling = null : e.tail = null : R.sibling = null;
            break;
          }
        }
    }
    function Ta(e) {
      var r = e.alternate !== null && e.alternate.child === e.child, c = Ne, g = _t;
      if (r) {
        if ((e.mode & jt) !== Ft) {
          for (var U = e.selfBaseDuration, J = e.child; J !== null; )
            c = tn(c, tn(J.lanes, J.childLanes)), g |= J.subtreeFlags & Wr, g |= J.flags & Wr, U += J.treeBaseDuration, J = J.sibling;
          e.treeBaseDuration = U;
        } else
          for (var ne = e.child; ne !== null; )
            c = tn(c, tn(ne.lanes, ne.childLanes)), g |= ne.subtreeFlags & Wr, g |= ne.flags & Wr, ne.return = e, ne = ne.sibling;
        e.subtreeFlags |= g;
      } else {
        if ((e.mode & jt) !== Ft) {
          for (var x = e.actualDuration, R = e.selfBaseDuration, _ = e.child; _ !== null; )
            c = tn(c, tn(_.lanes, _.childLanes)), g |= _.subtreeFlags, g |= _.flags, x += _.actualDuration, R += _.treeBaseDuration, _ = _.sibling;
          e.actualDuration = x, e.treeBaseDuration = R;
        } else
          for (var Y = e.child; Y !== null; )
            c = tn(c, tn(Y.lanes, Y.childLanes)), g |= Y.subtreeFlags, g |= Y.flags, Y.return = e, Y = Y.sibling;
        e.subtreeFlags |= g;
      }
      return e.childLanes = c, r;
    }
    function SM(e, r, c) {
      if (oD() && (r.mode & rn) !== Ft && (r.flags & Xt) === _t)
        return ok(r), ff(), r.flags |= lr | ei | Nr, !1;
      var g = pv(r);
      if (c !== null && c.dehydrated !== null)
        if (e === null) {
          if (!g)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (iD(r), Ta(r), (r.mode & jt) !== Ft) {
            var x = c !== null;
            if (x) {
              var R = r.child;
              R !== null && (r.treeBaseDuration -= R.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (ff(), (r.flags & Xt) === _t && (r.memoizedState = null), r.flags |= en, Ta(r), (r.mode & jt) !== Ft) {
            var _ = c !== null;
            if (_) {
              var Y = r.child;
              Y !== null && (r.treeBaseDuration -= Y.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return lk(), !0;
    }
    function MC(e, r, c) {
      var g = r.pendingProps;
      switch (kb(r), r.tag) {
        case V:
        case Je:
        case Me:
        case H:
        case we:
        case ue:
        case Ce:
        case Ee:
        case Pe:
        case me:
          return Ta(r), null;
        case j: {
          var x = r.type;
          return bo(x) && lv(r), Ta(r), null;
        }
        case q: {
          var R = r.stateNode;
          if (mf(r), xb(r), l0(), R.pendingContext && (R.context = R.pendingContext, R.pendingContext = null), e === null || e.child === null) {
            var _ = pv(r);
            if (_)
              kf(r);
            else if (e !== null) {
              var Y = e.memoizedState;
              // Check if this is a client root
              (!Y.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (r.flags & lr) !== _t) && (r.flags |= gi, lk());
            }
          }
          return Q0(e, r), Ta(r), null;
        }
        case ae: {
          a0(r);
          var U = Ok(), J = r.type;
          if (e !== null && r.stateNode != null)
            OC(e, r, J, g, U), e.ref !== r.ref && RC(r);
          else {
            if (!g) {
              if (r.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Ta(r), null;
            }
            var ne = r0(), ge = pv(r);
            if (ge)
              rD(r, U, ne) && kf(r);
            else {
              var he = WL(J, g, U, ne, r);
              LC(he, r, !1, !1), r.stateNode = he, XL(he, J, g, U) && kf(r);
            }
            r.ref !== null && RC(r);
          }
          return Ta(r), null;
        }
        case se: {
          var Te = g;
          if (e && r.stateNode != null) {
            var Ae = e.memoizedProps;
            DC(e, r, Ae, Te);
          } else {
            if (typeof Te != "string" && r.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Oe = Ok(), dt = r0(), zt = pv(r);
            zt ? aD(r) && kf(r) : r.stateNode = GL(Te, Oe, dt, r);
          }
          return Ta(r), null;
        }
        case re: {
          yf(r);
          var Rt = r.memoizedState;
          if (e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
            var hn = SM(e, r, Rt);
            if (!hn)
              return r.flags & Nr ? r : null;
          }
          if ((r.flags & Xt) !== _t)
            return r.lanes = c, (r.mode & jt) !== Ft && _0(r), r;
          var on = Rt !== null, xe = e !== null && e.memoizedState !== null;
          if (on !== xe && on) {
            var De = r.child;
            if (De.flags |= no, (r.mode & rn) !== Ft) {
              var be = e === null && (r.memoizedProps.unstable_avoidThisFallback !== !0 || !je);
              be || i0(Ns.current, _k) ? k2() : gw();
            }
          }
          var Ue = r.updateQueue;
          if (Ue !== null && (r.flags |= en), Ta(r), (r.mode & jt) !== Ft && on) {
            var ft = r.child;
            ft !== null && (r.treeBaseDuration -= ft.treeBaseDuration);
          }
          return null;
        }
        case te:
          return mf(r), Q0(e, r), e === null && HO(r.stateNode.containerInfo), Ta(r), null;
        case K:
          var ot = r.type._context;
          return Mb(ot, r), Ta(r), null;
        case Ve: {
          var Ut = r.type;
          return bo(Ut) && lv(r), Ta(r), null;
        }
        case it: {
          yf(r);
          var $t = r.memoizedState;
          if ($t === null)
            return Ta(r), null;
          var _n = (r.flags & Xt) !== _t, vn = $t.rendering;
          if (vn === null)
            if (_n)
              zp($t, !1);
            else {
              var Lr = T2() && (e === null || (e.flags & Xt) === _t);
              if (!Lr)
                for (var yn = r.child; yn !== null; ) {
                  var kr = Dv(yn);
                  if (kr !== null) {
                    _n = !0, r.flags |= Xt, zp($t, !1);
                    var Xa = kr.updateQueue;
                    return Xa !== null && (r.updateQueue = Xa, r.flags |= en), r.subtreeFlags = _t, TD(r, c), xu(r, s0(Ns.current, Tp)), r.child;
                  }
                  yn = yn.sibling;
                }
              $t.tail !== null && Qn() > JC() && (r.flags |= Xt, _n = !0, zp($t, !1), r.lanes = Lh);
            }
          else {
            if (!_n) {
              var Oa = Dv(vn);
              if (Oa !== null) {
                r.flags |= Xt, _n = !0;
                var Ui = Oa.updateQueue;
                if (Ui !== null && (r.updateQueue = Ui, r.flags |= en), zp($t, !0), $t.tail === null && $t.tailMode === "hidden" && !vn.alternate && !ka())
                  return Ta(r), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                Qn() * 2 - $t.renderingStartTime > JC() && c !== Ha && (r.flags |= Xt, _n = !0, zp($t, !1), r.lanes = Lh);
            }
            if ($t.isBackwards)
              vn.sibling = r.child, r.child = vn;
            else {
              var ui = $t.last;
              ui !== null ? ui.sibling = vn : r.child = vn, $t.last = vn;
            }
          }
          if ($t.tail !== null) {
            var ci = $t.tail;
            $t.rendering = ci, $t.tail = ci.sibling, $t.renderingStartTime = Qn(), ci.sibling = null;
            var Va = Ns.current;
            return _n ? Va = s0(Va, Tp) : Va = vf(Va), xu(r, Va), ci;
          }
          return Ta(r), null;
        }
        case ht:
          break;
        case Ke:
        case Ze: {
          pw(r);
          var bl = r.memoizedState, Df = bl !== null;
          if (e !== null) {
            var Kp = e.memoizedState, Ro = Kp !== null;
            Ro !== Df && // LegacyHidden doesn't do any hiding  it only pre-renders.
            !ye && (r.flags |= no);
          }
          return !Df || (r.mode & rn) === Ft ? Ta(r) : ja(Eo, Ha) && (Ta(r), r.subtreeFlags & (Wn | en) && (r.flags |= no)), null;
        }
        case Tt:
          return null;
        case It:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + r.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function kM(e, r, c) {
      switch (kb(r), r.tag) {
        case j: {
          var g = r.type;
          bo(g) && lv(r);
          var x = r.flags;
          return x & Nr ? (r.flags = x & ~Nr | Xt, (r.mode & jt) !== Ft && _0(r), r) : null;
        }
        case q: {
          r.stateNode, mf(r), xb(r), l0();
          var R = r.flags;
          return (R & Nr) !== _t && (R & Xt) === _t ? (r.flags = R & ~Nr | Xt, r) : null;
        }
        case ae:
          return a0(r), null;
        case re: {
          yf(r);
          var _ = r.memoizedState;
          if (_ !== null && _.dehydrated !== null) {
            if (r.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            ff();
          }
          var Y = r.flags;
          return Y & Nr ? (r.flags = Y & ~Nr | Xt, (r.mode & jt) !== Ft && _0(r), r) : null;
        }
        case it:
          return yf(r), null;
        case te:
          return mf(r), null;
        case K:
          var U = r.type._context;
          return Mb(U, r), null;
        case Ke:
        case Ze:
          return pw(r), null;
        case Tt:
          return null;
        default:
          return null;
      }
    }
    function _C(e, r, c) {
      switch (kb(r), r.tag) {
        case j: {
          var g = r.type.childContextTypes;
          g != null && lv(r);
          break;
        }
        case q: {
          r.stateNode, mf(r), xb(r), l0();
          break;
        }
        case ae: {
          a0(r);
          break;
        }
        case te:
          mf(r);
          break;
        case re:
          yf(r);
          break;
        case it:
          yf(r);
          break;
        case K:
          var x = r.type._context;
          Mb(x, r);
          break;
        case Ke:
        case Ze:
          pw(r);
          break;
      }
    }
    var PC = null;
    PC = /* @__PURE__ */ new Set();
    var ey = !1, Aa = !1, CM = typeof WeakSet == "function" ? WeakSet : Set, St = null, Cf = null, Tf = null;
    function TM(e) {
      jo(null, function() {
        throw e;
      }), ph();
    }
    var AM = function(e, r) {
      if (r.props = e.memoizedProps, r.state = e.memoizedState, e.mode & jt)
        try {
          To(), r.componentWillUnmount();
        } finally {
          Co(e);
        }
      else
        r.componentWillUnmount();
    };
    function NC(e, r) {
      try {
        Su(Gr, e);
      } catch (c) {
        Gn(e, r, c);
      }
    }
    function K0(e, r, c) {
      try {
        AM(e, c);
      } catch (g) {
        Gn(e, r, g);
      }
    }
    function EM(e, r, c) {
      try {
        c.componentDidMount();
      } catch (g) {
        Gn(e, r, g);
      }
    }
    function zC(e, r) {
      try {
        FC(e);
      } catch (c) {
        Gn(e, r, c);
      }
    }
    function Af(e, r) {
      var c = e.ref;
      if (c !== null)
        if (typeof c == "function") {
          var g;
          try {
            if (st && Nt && e.mode & jt)
              try {
                To(), g = c(null);
              } finally {
                Co(e);
              }
            else
              g = c(null);
          } catch (x) {
            Gn(e, r, x);
          }
          typeof g == "function" && A("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", vt(e));
        } else
          c.current = null;
    }
    function ty(e, r, c) {
      try {
        c();
      } catch (g) {
        Gn(e, r, g);
      }
    }
    var IC = !1;
    function RM(e, r) {
      jL(e.containerInfo), St = r, LM();
      var c = IC;
      return IC = !1, c;
    }
    function LM() {
      for (; St !== null; ) {
        var e = St, r = e.child;
        (e.subtreeFlags & Bl) !== _t && r !== null ? (r.return = e, St = r) : OM();
      }
    }
    function OM() {
      for (; St !== null; ) {
        var e = St;
        wn(e);
        try {
          DM(e);
        } catch (c) {
          Gn(e, e.return, c);
        }
        ln();
        var r = e.sibling;
        if (r !== null) {
          r.return = e.return, St = r;
          return;
        }
        St = e.return;
      }
    }
    function DM(e) {
      var r = e.alternate, c = e.flags;
      if ((c & gi) !== _t) {
        switch (wn(e), e.tag) {
          case H:
          case we:
          case Me:
            break;
          case j: {
            if (r !== null) {
              var g = r.memoizedProps, x = r.memoizedState, R = e.stateNode;
              e.type === e.elementType && !Dc && (R.props !== e.memoizedProps && A("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", vt(e) || "instance"), R.state !== e.memoizedState && A("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", vt(e) || "instance"));
              var _ = R.getSnapshotBeforeUpdate(e.elementType === e.type ? g : Ps(e.type, g), x);
              {
                var Y = PC;
                _ === void 0 && !Y.has(e.type) && (Y.add(e.type), A("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", vt(e)));
              }
              R.__reactInternalSnapshotBeforeUpdate = _;
            }
            break;
          }
          case q: {
            {
              var U = e.stateNode;
              fO(U.containerInfo);
            }
            break;
          }
          case ae:
          case se:
          case te:
          case Ve:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        ln();
      }
    }
    function Fs(e, r, c) {
      var g = r.updateQueue, x = g !== null ? g.lastEffect : null;
      if (x !== null) {
        var R = x.next, _ = R;
        do {
          if ((_.tag & e) === e) {
            var Y = _.destroy;
            _.destroy = void 0, Y !== void 0 && ((e & Ca) !== Ei ? pd(r) : (e & Gr) !== Ei && gd(r), (e & wo) !== Ei && qp(!0), ty(r, c, Y), (e & wo) !== Ei && qp(!1), (e & Ca) !== Ei ? hm() : (e & Gr) !== Ei && Wl());
          }
          _ = _.next;
        } while (_ !== R);
      }
    }
    function Su(e, r) {
      var c = r.updateQueue, g = c !== null ? c.lastEffect : null;
      if (g !== null) {
        var x = g.next, R = x;
        do {
          if ((R.tag & e) === e) {
            (e & Ca) !== Ei ? fm(r) : (e & Gr) !== Ei && pm(r);
            var _ = R.create;
            (e & wo) !== Ei && qp(!0), R.destroy = _(), (e & wo) !== Ei && qp(!1), (e & Ca) !== Ei ? Ah() : (e & Gr) !== Ei && gm();
            {
              var Y = R.destroy;
              if (Y !== void 0 && typeof Y != "function") {
                var U = void 0;
                (R.tag & Gr) !== _t ? U = "useLayoutEffect" : (R.tag & wo) !== _t ? U = "useInsertionEffect" : U = "useEffect";
                var J = void 0;
                Y === null ? J = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof Y.then == "function" ? J = `

It looks like you wrote ` + U + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + U + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : J = " You returned: " + Y, A("%s must not return anything besides a function, which is used for clean-up.%s", U, J);
              }
            }
          }
          R = R.next;
        } while (R !== x);
      }
    }
    function MM(e, r) {
      if ((r.flags & en) !== _t)
        switch (r.tag) {
          case Ee: {
            var c = r.stateNode.passiveEffectDuration, g = r.memoizedProps, x = g.id, R = g.onPostCommit, _ = iC(), Y = r.alternate === null ? "mount" : "update";
            aC() && (Y = "nested-update"), typeof R == "function" && R(x, Y, c, _);
            var U = r.return;
            e:
              for (; U !== null; ) {
                switch (U.tag) {
                  case q:
                    var J = U.stateNode;
                    J.passiveEffectDuration += c;
                    break e;
                  case Ee:
                    var ne = U.stateNode;
                    ne.passiveEffectDuration += c;
                    break e;
                }
                U = U.return;
              }
            break;
          }
        }
    }
    function _M(e, r, c, g) {
      if ((c.flags & ua) !== _t)
        switch (c.tag) {
          case H:
          case we:
          case Me: {
            if (!Aa)
              if (c.mode & jt)
                try {
                  To(), Su(Gr | Vr, c);
                } finally {
                  Co(c);
                }
              else
                Su(Gr | Vr, c);
            break;
          }
          case j: {
            var x = c.stateNode;
            if (c.flags & en && !Aa)
              if (r === null)
                if (c.type === c.elementType && !Dc && (x.props !== c.memoizedProps && A("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", vt(c) || "instance"), x.state !== c.memoizedState && A("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", vt(c) || "instance")), c.mode & jt)
                  try {
                    To(), x.componentDidMount();
                  } finally {
                    Co(c);
                  }
                else
                  x.componentDidMount();
              else {
                var R = c.elementType === c.type ? r.memoizedProps : Ps(c.type, r.memoizedProps), _ = r.memoizedState;
                if (c.type === c.elementType && !Dc && (x.props !== c.memoizedProps && A("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", vt(c) || "instance"), x.state !== c.memoizedState && A("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", vt(c) || "instance")), c.mode & jt)
                  try {
                    To(), x.componentDidUpdate(R, _, x.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Co(c);
                  }
                else
                  x.componentDidUpdate(R, _, x.__reactInternalSnapshotBeforeUpdate);
              }
            var Y = c.updateQueue;
            Y !== null && (c.type === c.elementType && !Dc && (x.props !== c.memoizedProps && A("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", vt(c) || "instance"), x.state !== c.memoizedState && A("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", vt(c) || "instance")), yk(c, Y, x));
            break;
          }
          case q: {
            var U = c.updateQueue;
            if (U !== null) {
              var J = null;
              if (c.child !== null)
                switch (c.child.tag) {
                  case ae:
                    J = c.child.stateNode;
                    break;
                  case j:
                    J = c.child.stateNode;
                    break;
                }
              yk(c, U, J);
            }
            break;
          }
          case ae: {
            var ne = c.stateNode;
            if (r === null && c.flags & en) {
              var ge = c.type, he = c.memoizedProps;
              KL(ne, ge, he);
            }
            break;
          }
          case se:
            break;
          case te:
            break;
          case Ee: {
            {
              var Te = c.memoizedProps, Ae = Te.onCommit, Oe = Te.onRender, dt = c.stateNode.effectDuration, zt = iC(), Rt = r === null ? "mount" : "update";
              aC() && (Rt = "nested-update"), typeof Oe == "function" && Oe(c.memoizedProps.id, Rt, c.actualDuration, c.treeBaseDuration, c.actualStartTime, zt);
              {
                typeof Ae == "function" && Ae(c.memoizedProps.id, Rt, dt, zt), O2(c);
                var hn = c.return;
                e:
                  for (; hn !== null; ) {
                    switch (hn.tag) {
                      case q:
                        var on = hn.stateNode;
                        on.effectDuration += dt;
                        break e;
                      case Ee:
                        var xe = hn.stateNode;
                        xe.effectDuration += dt;
                        break e;
                    }
                    hn = hn.return;
                  }
              }
            }
            break;
          }
          case re: {
            jM(e, c);
            break;
          }
          case it:
          case Ve:
          case ht:
          case Ke:
          case Ze:
          case It:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Aa || c.flags & Pa && FC(c);
    }
    function PM(e) {
      switch (e.tag) {
        case H:
        case we:
        case Me: {
          if (e.mode & jt)
            try {
              To(), NC(e, e.return);
            } finally {
              Co(e);
            }
          else
            NC(e, e.return);
          break;
        }
        case j: {
          var r = e.stateNode;
          typeof r.componentDidMount == "function" && EM(e, e.return, r), zC(e, e.return);
          break;
        }
        case ae: {
          zC(e, e.return);
          break;
        }
      }
    }
    function NM(e, r) {
      for (var c = null, g = e; ; ) {
        if (g.tag === ae) {
          if (c === null) {
            c = g;
            try {
              var x = g.stateNode;
              r ? lO(x) : cO(g.stateNode, g.memoizedProps);
            } catch (_) {
              Gn(e, e.return, _);
            }
          }
        } else if (g.tag === se) {
          if (c === null)
            try {
              var R = g.stateNode;
              r ? uO(R) : dO(R, g.memoizedProps);
            } catch (_) {
              Gn(e, e.return, _);
            }
        } else if (!((g.tag === Ke || g.tag === Ze) && g.memoizedState !== null && g !== e)) {
          if (g.child !== null) {
            g.child.return = g, g = g.child;
            continue;
          }
        }
        if (g === e)
          return;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === e)
            return;
          c === g && (c = null), g = g.return;
        }
        c === g && (c = null), g.sibling.return = g.return, g = g.sibling;
      }
    }
    function FC(e) {
      var r = e.ref;
      if (r !== null) {
        var c = e.stateNode, g;
        switch (e.tag) {
          case ae:
            g = c;
            break;
          default:
            g = c;
        }
        if (typeof r == "function") {
          var x;
          if (e.mode & jt)
            try {
              To(), x = r(g);
            } finally {
              Co(e);
            }
          else
            x = r(g);
          typeof x == "function" && A("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", vt(e));
        } else
          r.hasOwnProperty("current") || A("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", vt(e)), r.current = g;
      }
    }
    function zM(e) {
      var r = e.alternate;
      r !== null && (r.return = null), e.return = null;
    }
    function YC(e) {
      var r = e.alternate;
      r !== null && (e.alternate = null, YC(r));
      {
        if (e.child = null, e.deletions = null, e.sibling = null, e.tag === ae) {
          var c = e.stateNode;
          c !== null && WO(c);
        }
        e.stateNode = null, e._debugOwner = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
      }
    }
    function IM(e) {
      for (var r = e.return; r !== null; ) {
        if (HC(r))
          return r;
        r = r.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function HC(e) {
      return e.tag === ae || e.tag === q || e.tag === te;
    }
    function jC(e) {
      var r = e;
      e:
        for (; ; ) {
          for (; r.sibling === null; ) {
            if (r.return === null || HC(r.return))
              return null;
            r = r.return;
          }
          for (r.sibling.return = r.return, r = r.sibling; r.tag !== ae && r.tag !== se && r.tag !== Xe; ) {
            if (r.flags & Wn || r.child === null || r.tag === te)
              continue e;
            r.child.return = r, r = r.child;
          }
          if (!(r.flags & Wn))
            return r.stateNode;
        }
    }
    function FM(e) {
      var r = IM(e);
      switch (r.tag) {
        case ae: {
          var c = r.stateNode;
          r.flags & Tn && (BS(c), r.flags &= ~Tn);
          var g = jC(e);
          ew(e, g, c);
          break;
        }
        case q:
        case te: {
          var x = r.stateNode.containerInfo, R = jC(e);
          J0(e, R, x);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function J0(e, r, c) {
      var g = e.tag, x = g === ae || g === se;
      if (x) {
        var R = e.stateNode;
        r ? aO(c, R, r) : nO(c, R);
      } else if (g !== te) {
        var _ = e.child;
        if (_ !== null) {
          J0(_, r, c);
          for (var Y = _.sibling; Y !== null; )
            J0(Y, r, c), Y = Y.sibling;
        }
      }
    }
    function ew(e, r, c) {
      var g = e.tag, x = g === ae || g === se;
      if (x) {
        var R = e.stateNode;
        r ? rO(c, R, r) : tO(c, R);
      } else if (g !== te) {
        var _ = e.child;
        if (_ !== null) {
          ew(_, r, c);
          for (var Y = _.sibling; Y !== null; )
            ew(Y, r, c), Y = Y.sibling;
        }
      }
    }
    var Ea = null, Ys = !1;
    function YM(e, r, c) {
      {
        var g = r;
        e:
          for (; g !== null; ) {
            switch (g.tag) {
              case ae: {
                Ea = g.stateNode, Ys = !1;
                break e;
              }
              case q: {
                Ea = g.stateNode.containerInfo, Ys = !0;
                break e;
              }
              case te: {
                Ea = g.stateNode.containerInfo, Ys = !0;
                break e;
              }
            }
            g = g.return;
          }
        if (Ea === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        BC(e, r, c), Ea = null, Ys = !1;
      }
      zM(c);
    }
    function ku(e, r, c) {
      for (var g = c.child; g !== null; )
        BC(e, r, g), g = g.sibling;
    }
    function BC(e, r, c) {
      switch (Ch(c), c.tag) {
        case ae:
          Aa || Af(c, r);
        case se: {
          {
            var g = Ea, x = Ys;
            Ea = null, ku(e, r, c), Ea = g, Ys = x, Ea !== null && (Ys ? sO(Ea, c.stateNode) : iO(Ea, c.stateNode));
          }
          return;
        }
        case Xe: {
          Ea !== null && (Ys ? oO(Ea, c.stateNode) : db(Ea, c.stateNode));
          return;
        }
        case te: {
          {
            var R = Ea, _ = Ys;
            Ea = c.stateNode.containerInfo, Ys = !0, ku(e, r, c), Ea = R, Ys = _;
          }
          return;
        }
        case H:
        case we:
        case me:
        case Me: {
          if (!Aa) {
            var Y = c.updateQueue;
            if (Y !== null) {
              var U = Y.lastEffect;
              if (U !== null) {
                var J = U.next, ne = J;
                do {
                  var ge = ne, he = ge.destroy, Te = ge.tag;
                  he !== void 0 && ((Te & wo) !== Ei ? ty(c, r, he) : (Te & Gr) !== Ei && (gd(c), c.mode & jt ? (To(), ty(c, r, he), Co(c)) : ty(c, r, he), Wl())), ne = ne.next;
                } while (ne !== J);
              }
            }
          }
          ku(e, r, c);
          return;
        }
        case j: {
          if (!Aa) {
            Af(c, r);
            var Ae = c.stateNode;
            typeof Ae.componentWillUnmount == "function" && K0(c, r, Ae);
          }
          ku(e, r, c);
          return;
        }
        case ht: {
          ku(e, r, c);
          return;
        }
        case Ke: {
          if (
            // TODO: Remove this dead flag
            c.mode & rn
          ) {
            var Oe = Aa;
            Aa = Oe || c.memoizedState !== null, ku(e, r, c), Aa = Oe;
          } else
            ku(e, r, c);
          break;
        }
        default: {
          ku(e, r, c);
          return;
        }
      }
    }
    function HM(e) {
      e.memoizedState;
    }
    function jM(e, r) {
      var c = r.memoizedState;
      if (c === null) {
        var g = r.alternate;
        if (g !== null) {
          var x = g.memoizedState;
          if (x !== null) {
            var R = x.dehydrated;
            R !== null && AO(R);
          }
        }
      }
    }
    function WC(e) {
      var r = e.updateQueue;
      if (r !== null) {
        e.updateQueue = null;
        var c = e.stateNode;
        c === null && (c = e.stateNode = new CM()), r.forEach(function(g) {
          var x = I2.bind(null, e, g);
          if (!c.has(g)) {
            if (c.add(g), Ur)
              if (Cf !== null && Tf !== null)
                $p(Tf, Cf);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            g.then(x, x);
          }
        });
      }
    }
    function BM(e, r, c) {
      Cf = c, Tf = e, wn(r), UC(r, e), wn(r), Cf = null, Tf = null;
    }
    function Hs(e, r, c) {
      var g = r.deletions;
      if (g !== null)
        for (var x = 0; x < g.length; x++) {
          var R = g[x];
          try {
            YM(e, r, R);
          } catch (U) {
            Gn(R, r, U);
          }
        }
      var _ = cx();
      if (r.subtreeFlags & Ia)
        for (var Y = r.child; Y !== null; )
          wn(Y), UC(Y, e), Y = Y.sibling;
      wn(_);
    }
    function UC(e, r, c) {
      var g = e.alternate, x = e.flags;
      switch (e.tag) {
        case H:
        case we:
        case me:
        case Me: {
          if (Hs(r, e), Ao(e), x & en) {
            try {
              Fs(wo | Vr, e, e.return), Su(wo | Vr, e);
            } catch (Ut) {
              Gn(e, e.return, Ut);
            }
            if (e.mode & jt) {
              try {
                To(), Fs(Gr | Vr, e, e.return);
              } catch (Ut) {
                Gn(e, e.return, Ut);
              }
              Co(e);
            } else
              try {
                Fs(Gr | Vr, e, e.return);
              } catch (Ut) {
                Gn(e, e.return, Ut);
              }
          }
          return;
        }
        case j: {
          Hs(r, e), Ao(e), x & Pa && g !== null && Af(g, g.return);
          return;
        }
        case ae: {
          Hs(r, e), Ao(e), x & Pa && g !== null && Af(g, g.return);
          {
            if (e.flags & Tn) {
              var R = e.stateNode;
              try {
                BS(R);
              } catch (Ut) {
                Gn(e, e.return, Ut);
              }
            }
            if (x & en) {
              var _ = e.stateNode;
              if (_ != null) {
                var Y = e.memoizedProps, U = g !== null ? g.memoizedProps : Y, J = e.type, ne = e.updateQueue;
                if (e.updateQueue = null, ne !== null)
                  try {
                    JL(_, ne, J, U, Y, e);
                  } catch (Ut) {
                    Gn(e, e.return, Ut);
                  }
              }
            }
          }
          return;
        }
        case se: {
          if (Hs(r, e), Ao(e), x & en) {
            if (e.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var ge = e.stateNode, he = e.memoizedProps, Te = g !== null ? g.memoizedProps : he;
            try {
              eO(ge, Te, he);
            } catch (Ut) {
              Gn(e, e.return, Ut);
            }
          }
          return;
        }
        case q: {
          if (Hs(r, e), Ao(e), x & en && g !== null) {
            var Ae = g.memoizedState;
            if (Ae.isDehydrated)
              try {
                TO(r.containerInfo);
              } catch (Ut) {
                Gn(e, e.return, Ut);
              }
          }
          return;
        }
        case te: {
          Hs(r, e), Ao(e);
          return;
        }
        case re: {
          Hs(r, e), Ao(e);
          var Oe = e.child;
          if (Oe.flags & no) {
            var dt = Oe.stateNode, zt = Oe.memoizedState, Rt = zt !== null;
            if (dt.isHidden = Rt, Rt) {
              var hn = Oe.alternate !== null && Oe.alternate.memoizedState !== null;
              hn || S2();
            }
          }
          if (x & en) {
            try {
              HM(e);
            } catch (Ut) {
              Gn(e, e.return, Ut);
            }
            WC(e);
          }
          return;
        }
        case Ke: {
          var on = g !== null && g.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            e.mode & rn
          ) {
            var xe = Aa;
            Aa = xe || on, Hs(r, e), Aa = xe;
          } else
            Hs(r, e);
          if (Ao(e), x & no) {
            var De = e.stateNode, be = e.memoizedState, Ue = be !== null, ft = e;
            if (De.isHidden = Ue, Ue && !on && (ft.mode & rn) !== Ft) {
              St = ft;
              for (var ot = ft.child; ot !== null; )
                St = ot, UM(ot), ot = ot.sibling;
            }
            NM(ft, Ue);
          }
          return;
        }
        case it: {
          Hs(r, e), Ao(e), x & en && WC(e);
          return;
        }
        case ht:
          return;
        default: {
          Hs(r, e), Ao(e);
          return;
        }
      }
    }
    function Ao(e) {
      var r = e.flags;
      if (r & Wn) {
        try {
          FM(e);
        } catch (c) {
          Gn(e, e.return, c);
        }
        e.flags &= ~Wn;
      }
      r & mi && (e.flags &= ~mi);
    }
    function WM(e, r, c) {
      Cf = c, Tf = r, St = e, XC(e, r, c), Cf = null, Tf = null;
    }
    function XC(e, r, c) {
      for (var g = (e.mode & rn) !== Ft; St !== null; ) {
        var x = St, R = x.child;
        if (x.tag === Ke && g) {
          var _ = x.memoizedState !== null, Y = _ || ey;
          if (Y) {
            tw(e, r, c);
            continue;
          } else {
            var U = x.alternate, J = U !== null && U.memoizedState !== null, ne = J || Aa, ge = ey, he = Aa;
            ey = Y, Aa = ne, Aa && !he && (St = x, XM(x));
            for (var Te = R; Te !== null; )
              St = Te, XC(
                Te,
                // New root; bubble back up to here and stop.
                r,
                c
              ), Te = Te.sibling;
            St = x, ey = ge, Aa = he, tw(e, r, c);
            continue;
          }
        }
        (x.subtreeFlags & ua) !== _t && R !== null ? (R.return = x, St = R) : tw(e, r, c);
      }
    }
    function tw(e, r, c) {
      for (; St !== null; ) {
        var g = St;
        if ((g.flags & ua) !== _t) {
          var x = g.alternate;
          wn(g);
          try {
            _M(r, x, g, c);
          } catch (_) {
            Gn(g, g.return, _);
          }
          ln();
        }
        if (g === e) {
          St = null;
          return;
        }
        var R = g.sibling;
        if (R !== null) {
          R.return = g.return, St = R;
          return;
        }
        St = g.return;
      }
    }
    function UM(e) {
      for (; St !== null; ) {
        var r = St, c = r.child;
        switch (r.tag) {
          case H:
          case we:
          case me:
          case Me: {
            if (r.mode & jt)
              try {
                To(), Fs(Gr, r, r.return);
              } finally {
                Co(r);
              }
            else
              Fs(Gr, r, r.return);
            break;
          }
          case j: {
            Af(r, r.return);
            var g = r.stateNode;
            typeof g.componentWillUnmount == "function" && K0(r, r.return, g);
            break;
          }
          case ae: {
            Af(r, r.return);
            break;
          }
          case Ke: {
            var x = r.memoizedState !== null;
            if (x) {
              VC(e);
              continue;
            }
            break;
          }
        }
        c !== null ? (c.return = r, St = c) : VC(e);
      }
    }
    function VC(e) {
      for (; St !== null; ) {
        var r = St;
        if (r === e) {
          St = null;
          return;
        }
        var c = r.sibling;
        if (c !== null) {
          c.return = r.return, St = c;
          return;
        }
        St = r.return;
      }
    }
    function XM(e) {
      for (; St !== null; ) {
        var r = St, c = r.child;
        if (r.tag === Ke) {
          var g = r.memoizedState !== null;
          if (g) {
            GC(e);
            continue;
          }
        }
        c !== null ? (c.return = r, St = c) : GC(e);
      }
    }
    function GC(e) {
      for (; St !== null; ) {
        var r = St;
        wn(r);
        try {
          PM(r);
        } catch (g) {
          Gn(r, r.return, g);
        }
        if (ln(), r === e) {
          St = null;
          return;
        }
        var c = r.sibling;
        if (c !== null) {
          c.return = r.return, St = c;
          return;
        }
        St = r.return;
      }
    }
    function VM(e, r, c, g) {
      St = r, GM(r, e, c, g);
    }
    function GM(e, r, c, g) {
      for (; St !== null; ) {
        var x = St, R = x.child;
        (x.subtreeFlags & vi) !== _t && R !== null ? (R.return = x, St = R) : $M(e, r, c, g);
      }
    }
    function $M(e, r, c, g) {
      for (; St !== null; ) {
        var x = St;
        if ((x.flags & qn) !== _t) {
          wn(x);
          try {
            qM(r, x, c, g);
          } catch (_) {
            Gn(x, x.return, _);
          }
          ln();
        }
        if (x === e) {
          St = null;
          return;
        }
        var R = x.sibling;
        if (R !== null) {
          R.return = x.return, St = R;
          return;
        }
        St = x.return;
      }
    }
    function qM(e, r, c, g) {
      switch (r.tag) {
        case H:
        case we:
        case Me: {
          if (r.mode & jt) {
            M0();
            try {
              Su(Ca | Vr, r);
            } finally {
              D0(r);
            }
          } else
            Su(Ca | Vr, r);
          break;
        }
      }
    }
    function ZM(e) {
      St = e, QM();
    }
    function QM() {
      for (; St !== null; ) {
        var e = St, r = e.child;
        if ((St.flags & Sn) !== _t) {
          var c = e.deletions;
          if (c !== null) {
            for (var g = 0; g < c.length; g++) {
              var x = c[g];
              St = x, e2(x, e);
            }
            {
              var R = e.alternate;
              if (R !== null) {
                var _ = R.child;
                if (_ !== null) {
                  R.child = null;
                  do {
                    var Y = _.sibling;
                    _.sibling = null, _ = Y;
                  } while (_ !== null);
                }
              }
            }
            St = e;
          }
        }
        (e.subtreeFlags & vi) !== _t && r !== null ? (r.return = e, St = r) : KM();
      }
    }
    function KM() {
      for (; St !== null; ) {
        var e = St;
        (e.flags & qn) !== _t && (wn(e), JM(e), ln());
        var r = e.sibling;
        if (r !== null) {
          r.return = e.return, St = r;
          return;
        }
        St = e.return;
      }
    }
    function JM(e) {
      switch (e.tag) {
        case H:
        case we:
        case Me: {
          e.mode & jt ? (M0(), Fs(Ca | Vr, e, e.return), D0(e)) : Fs(Ca | Vr, e, e.return);
          break;
        }
      }
    }
    function e2(e, r) {
      for (; St !== null; ) {
        var c = St;
        wn(c), n2(c, r), ln();
        var g = c.child;
        g !== null ? (g.return = c, St = g) : t2(e);
      }
    }
    function t2(e) {
      for (; St !== null; ) {
        var r = St, c = r.sibling, g = r.return;
        if (YC(r), r === e) {
          St = null;
          return;
        }
        if (c !== null) {
          c.return = g, St = c;
          return;
        }
        St = g;
      }
    }
    function n2(e, r) {
      switch (e.tag) {
        case H:
        case we:
        case Me: {
          e.mode & jt ? (M0(), Fs(Ca, e, r), D0(e)) : Fs(Ca, e, r);
          break;
        }
      }
    }
    function r2(e) {
      switch (e.tag) {
        case H:
        case we:
        case Me: {
          try {
            Su(Gr | Vr, e);
          } catch (c) {
            Gn(e, e.return, c);
          }
          break;
        }
        case j: {
          var r = e.stateNode;
          try {
            r.componentDidMount();
          } catch (c) {
            Gn(e, e.return, c);
          }
          break;
        }
      }
    }
    function a2(e) {
      switch (e.tag) {
        case H:
        case we:
        case Me: {
          try {
            Su(Ca | Vr, e);
          } catch (r) {
            Gn(e, e.return, r);
          }
          break;
        }
      }
    }
    function i2(e) {
      switch (e.tag) {
        case H:
        case we:
        case Me: {
          try {
            Fs(Gr | Vr, e, e.return);
          } catch (c) {
            Gn(e, e.return, c);
          }
          break;
        }
        case j: {
          var r = e.stateNode;
          typeof r.componentWillUnmount == "function" && K0(e, e.return, r);
          break;
        }
      }
    }
    function s2(e) {
      switch (e.tag) {
        case H:
        case we:
        case Me:
          try {
            Fs(Ca | Vr, e, e.return);
          } catch (r) {
            Gn(e, e.return, r);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var Ip = Symbol.for;
      Ip("selector.component"), Ip("selector.has_pseudo_class"), Ip("selector.role"), Ip("selector.test_id"), Ip("selector.text");
    }
    var o2 = [];
    function l2() {
      o2.forEach(function(e) {
        return e();
      });
    }
    var u2 = h.ReactCurrentActQueue;
    function c2(e) {
      {
        var r = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), c = typeof jest < "u";
        return c && r !== !1;
      }
    }
    function $C() {
      {
        var e = (
          // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !e && u2.current !== null && A("The current testing environment is not configured to support act(...)"), e;
      }
    }
    var d2 = Math.ceil, nw = h.ReactCurrentDispatcher, rw = h.ReactCurrentOwner, Ra = h.ReactCurrentBatchConfig, js = h.ReactCurrentActQueue, Zr = (
      /*             */
      0
    ), qC = (
      /*               */
      1
    ), La = (
      /*                */
      2
    ), is = (
      /*                */
      4
    ), ml = 0, Fp = 1, Mc = 2, ny = 3, Yp = 4, ZC = 5, aw = 6, fn = Zr, oi = null, gr = null, Qr = Ne, Eo = Ne, iw = hu(Ne), Kr = ml, Hp = null, ry = Ne, jp = Ne, ay = Ne, Bp = null, Ri = null, sw = 0, QC = 500, KC = 1 / 0, f2 = 500, vl = null;
    function Wp() {
      KC = Qn() + f2;
    }
    function JC() {
      return KC;
    }
    var iy = !1, ow = null, Ef = null, _c = !1, Cu = null, Up = Ne, lw = [], uw = null, h2 = 50, Xp = 0, cw = null, dw = !1, sy = !1, p2 = 50, Rf = 0, oy = null, Vp = Fn, ly = Ne, eT = !1;
    function uy() {
      return oi;
    }
    function li() {
      return (fn & (La | is)) !== Zr ? Qn() : (Vp !== Fn || (Vp = Qn()), Vp);
    }
    function Tu(e) {
      var r = e.mode;
      if ((r & rn) === Ft)
        return Bt;
      if ((fn & La) !== Zr && Qr !== Ne)
        return Tr(Qr);
      var c = cD() !== uD;
      if (c) {
        if (Ra.transition !== null) {
          var g = Ra.transition;
          g._updatedFibers || (g._updatedFibers = /* @__PURE__ */ new Set()), g._updatedFibers.add(e);
        }
        return ly === dn && (ly = Mh()), ly;
      }
      var x = wi();
      if (x !== dn)
        return x;
      var R = $L();
      return R;
    }
    function g2(e) {
      var r = e.mode;
      return (r & rn) === Ft ? Bt : Mx();
    }
    function Jr(e, r, c, g) {
      Y2(), eT && A("useInsertionEffect must not schedule updates."), dw && (sy = !0), Jo(e, c, g), (fn & La) !== Ne && e === oi ? B2(r) : (Ur && Ih(e, r, c), W2(r), e === oi && ((fn & La) === Zr && (jp = tn(jp, c)), Kr === Yp && Au(e, Qr)), Li(e, g), c === Bt && fn === Zr && (r.mode & rn) === Ft && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !js.isBatchingLegacy && (Wp(), JS()));
    }
    function m2(e, r, c) {
      var g = e.current;
      g.lanes = r, Jo(e, r, c), Li(e, c);
    }
    function v2(e) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (fn & La) !== Zr
      );
    }
    function Li(e, r) {
      var c = e.callbackNode;
      Lx(e, r);
      var g = ac(e, e === oi ? Qr : Ne);
      if (g === Ne) {
        c !== null && mT(c), e.callbackNode = null, e.callbackPriority = dn;
        return;
      }
      var x = wr(g), R = e.callbackPriority;
      if (R === x && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(js.current !== null && c !== yw)) {
        c == null && R !== Bt && A("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      c != null && mT(c);
      var _;
      if (x === Bt)
        e.tag === pu ? (js.isBatchingLegacy !== null && (js.didScheduleLegacyUpdate = !0), VO(rT.bind(null, e))) : KS(rT.bind(null, e)), js.current !== null ? js.current.push(gu) : ZL(function() {
          (fn & (La | is)) === Zr && gu();
        }), _ = null;
      else {
        var Y;
        switch (uc(g)) {
          case ca:
            Y = dd;
            break;
          case Xr:
            Y = ri;
            break;
          case As:
            Y = qi;
            break;
          case oc:
            Y = ao;
            break;
          default:
            Y = qi;
            break;
        }
        _ = xw(Y, tT.bind(null, e));
      }
      e.callbackPriority = x, e.callbackNode = _;
    }
    function tT(e, r) {
      if (YD(), Vp = Fn, ly = Ne, (fn & (La | is)) !== Zr)
        throw new Error("Should not already be working.");
      var c = e.callbackNode, g = xl();
      if (g && e.callbackNode !== c)
        return null;
      var x = ac(e, e === oi ? Qr : Ne);
      if (x === Ne)
        return null;
      var R = !sc(e, x) && !wm(e, x) && !r, _ = R ? E2(e, x) : dy(e, x);
      if (_ !== ml) {
        if (_ === Mc) {
          var Y = Oh(e);
          Y !== Ne && (x = Y, _ = fw(e, Y));
        }
        if (_ === Fp) {
          var U = Hp;
          throw Pc(e, Ne), Au(e, x), Li(e, Qn()), U;
        }
        if (_ === aw)
          Au(e, x);
        else {
          var J = !sc(e, x), ne = e.current.alternate;
          if (J && !x2(ne)) {
            if (_ = dy(e, x), _ === Mc) {
              var ge = Oh(e);
              ge !== Ne && (x = ge, _ = fw(e, ge));
            }
            if (_ === Fp) {
              var he = Hp;
              throw Pc(e, Ne), Au(e, x), Li(e, Qn()), he;
            }
          }
          e.finishedWork = ne, e.finishedLanes = x, y2(e, _, x);
        }
      }
      return Li(e, Qn()), e.callbackNode === c ? tT.bind(null, e) : null;
    }
    function fw(e, r) {
      var c = Bp;
      if (Er(e)) {
        var g = Pc(e, r);
        g.flags |= lr, YO(e.containerInfo);
      }
      var x = dy(e, r);
      if (x !== Mc) {
        var R = Ri;
        Ri = c, R !== null && nT(R);
      }
      return x;
    }
    function nT(e) {
      Ri === null ? Ri = e : Ri.push.apply(Ri, e);
    }
    function y2(e, r, c) {
      switch (r) {
        case ml:
        case Fp:
          throw new Error("Root did not complete. This is a bug in React.");
        case Mc: {
          Nc(e, Ri, vl);
          break;
        }
        case ny: {
          if (Au(e, c), Nd(c) && // do not delay if we're inside an act() scope
          !vT()) {
            var g = sw + QC - Qn();
            if (g > 10) {
              var x = ac(e, Ne);
              if (x !== Ne)
                break;
              var R = e.suspendedLanes;
              if (!Ko(R, c)) {
                li(), Nh(e, R);
                break;
              }
              e.timeoutHandle = ub(Nc.bind(null, e, Ri, vl), g);
              break;
            }
          }
          Nc(e, Ri, vl);
          break;
        }
        case Yp: {
          if (Au(e, c), bm(c))
            break;
          if (!vT()) {
            var _ = xm(e, c), Y = _, U = Qn() - Y, J = F2(U) - U;
            if (J > 10) {
              e.timeoutHandle = ub(Nc.bind(null, e, Ri, vl), J);
              break;
            }
          }
          Nc(e, Ri, vl);
          break;
        }
        case ZC: {
          Nc(e, Ri, vl);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function x2(e) {
      for (var r = e; ; ) {
        if (r.flags & Qu) {
          var c = r.updateQueue;
          if (c !== null) {
            var g = c.stores;
            if (g !== null)
              for (var x = 0; x < g.length; x++) {
                var R = g[x], _ = R.getSnapshot, Y = R.value;
                try {
                  if (!wt(_(), Y))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var U = r.child;
        if (r.subtreeFlags & Qu && U !== null) {
          U.return = r, r = U;
          continue;
        }
        if (r === e)
          return !0;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === e)
            return !0;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
      return !0;
    }
    function Au(e, r) {
      r = Zl(r, ay), r = Zl(r, jp), Ph(e, r);
    }
    function rT(e) {
      if (HD(), (fn & (La | is)) !== Zr)
        throw new Error("Should not already be working.");
      xl();
      var r = ac(e, Ne);
      if (!ja(r, Bt))
        return Li(e, Qn()), null;
      var c = dy(e, r);
      if (e.tag !== pu && c === Mc) {
        var g = Oh(e);
        g !== Ne && (r = g, c = fw(e, g));
      }
      if (c === Fp) {
        var x = Hp;
        throw Pc(e, Ne), Au(e, r), Li(e, Qn()), x;
      }
      if (c === aw)
        throw new Error("Root did not complete. This is a bug in React.");
      var R = e.current.alternate;
      return e.finishedWork = R, e.finishedLanes = r, Nc(e, Ri, vl), Li(e, Qn()), null;
    }
    function b2(e, r) {
      r !== Ne && (Ql(e, tn(r, Bt)), Li(e, Qn()), (fn & (La | is)) === Zr && (Wp(), gu()));
    }
    function hw(e, r) {
      var c = fn;
      fn |= qC;
      try {
        return e(r);
      } finally {
        fn = c, fn === Zr && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !js.isBatchingLegacy && (Wp(), JS());
      }
    }
    function w2(e, r, c, g, x) {
      var R = wi(), _ = Ra.transition;
      try {
        return Ra.transition = null, Ar(ca), e(r, c, g, x);
      } finally {
        Ar(R), Ra.transition = _, fn === Zr && Wp();
      }
    }
    function yl(e) {
      Cu !== null && Cu.tag === pu && (fn & (La | is)) === Zr && xl();
      var r = fn;
      fn |= qC;
      var c = Ra.transition, g = wi();
      try {
        return Ra.transition = null, Ar(ca), e ? e() : void 0;
      } finally {
        Ar(g), Ra.transition = c, fn = r, (fn & (La | is)) === Zr && gu();
      }
    }
    function aT() {
      return (fn & (La | is)) !== Zr;
    }
    function cy(e, r) {
      Wa(iw, Eo, e), Eo = tn(Eo, r);
    }
    function pw(e) {
      Eo = iw.current, Ba(iw, e);
    }
    function Pc(e, r) {
      e.finishedWork = null, e.finishedLanes = Ne;
      var c = e.timeoutHandle;
      if (c !== cb && (e.timeoutHandle = cb, qL(c)), gr !== null)
        for (var g = gr.return; g !== null; ) {
          var x = g.alternate;
          _C(x, g), g = g.return;
        }
      oi = e;
      var R = zc(e.current, null);
      return gr = R, Qr = Eo = r, Kr = ml, Hp = null, ry = Ne, jp = Ne, ay = Ne, Bp = null, Ri = null, pD(), _s.discardPendingWarnings(), R;
    }
    function iT(e, r) {
      do {
        var c = gr;
        try {
          if (yv(), Nk(), ln(), rw.current = null, c === null || c.return === null) {
            Kr = Fp, Hp = r, gr = null;
            return;
          }
          if (st && c.mode & jt && Zv(c, !0), Pt)
            if (Wo(), r !== null && typeof r == "object" && typeof r.then == "function") {
              var g = r;
              mm(c, g, Qr);
            } else
              md(c, r, Qr);
          XD(e, c.return, c, r, Qr), uT(c);
        } catch (x) {
          r = x, gr === c && c !== null ? (c = c.return, gr = c) : c = gr;
          continue;
        }
        return;
      } while (!0);
    }
    function sT() {
      var e = nw.current;
      return nw.current = Xv, e === null ? Xv : e;
    }
    function oT(e) {
      nw.current = e;
    }
    function S2() {
      sw = Qn();
    }
    function Gp(e) {
      ry = tn(e, ry);
    }
    function k2() {
      Kr === ml && (Kr = ny);
    }
    function gw() {
      (Kr === ml || Kr === ny || Kr === Mc) && (Kr = Yp), oi !== null && (ic(ry) || ic(jp)) && Au(oi, Qr);
    }
    function C2(e) {
      Kr !== Yp && (Kr = Mc), Bp === null ? Bp = [e] : Bp.push(e);
    }
    function T2() {
      return Kr === ml;
    }
    function dy(e, r) {
      var c = fn;
      fn |= La;
      var g = sT();
      if (oi !== e || Qr !== r) {
        if (Ur) {
          var x = e.memoizedUpdaters;
          x.size > 0 && ($p(e, Qr), x.clear()), Fd(e, r);
        }
        vl = Fh(), Pc(e, r);
      }
      Hi(r);
      do
        try {
          A2();
          break;
        } catch (R) {
          iT(e, R);
        }
      while (!0);
      if (yv(), fn = c, oT(g), gr !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Xl(), oi = null, Qr = Ne, Kr;
    }
    function A2() {
      for (; gr !== null; )
        lT(gr);
    }
    function E2(e, r) {
      var c = fn;
      fn |= La;
      var g = sT();
      if (oi !== e || Qr !== r) {
        if (Ur) {
          var x = e.memoizedUpdaters;
          x.size > 0 && ($p(e, Qr), x.clear()), Fd(e, r);
        }
        vl = Fh(), Wp(), Pc(e, r);
      }
      Hi(r);
      do
        try {
          R2();
          break;
        } catch (R) {
          iT(e, R);
        }
      while (!0);
      return yv(), oT(g), fn = c, gr !== null ? (ec(), ml) : (Xl(), oi = null, Qr = Ne, Kr);
    }
    function R2() {
      for (; gr !== null && !cd(); )
        lT(gr);
    }
    function lT(e) {
      var r = e.alternate;
      wn(e);
      var c;
      (e.mode & jt) !== Ft ? (O0(e), c = mw(r, e, Eo), Zv(e, !0)) : c = mw(r, e, Eo), ln(), e.memoizedProps = e.pendingProps, c === null ? uT(e) : gr = c, rw.current = null;
    }
    function uT(e) {
      var r = e;
      do {
        var c = r.alternate, g = r.return;
        if ((r.flags & ei) === _t) {
          wn(r);
          var x = void 0;
          if ((r.mode & jt) === Ft ? x = MC(c, r, Eo) : (O0(r), x = MC(c, r, Eo), Zv(r, !1)), ln(), x !== null) {
            gr = x;
            return;
          }
        } else {
          var R = kM(c, r);
          if (R !== null) {
            R.flags &= om, gr = R;
            return;
          }
          if ((r.mode & jt) !== Ft) {
            Zv(r, !1);
            for (var _ = r.actualDuration, Y = r.child; Y !== null; )
              _ += Y.actualDuration, Y = Y.sibling;
            r.actualDuration = _;
          }
          if (g !== null)
            g.flags |= ei, g.subtreeFlags = _t, g.deletions = null;
          else {
            Kr = aw, gr = null;
            return;
          }
        }
        var U = r.sibling;
        if (U !== null) {
          gr = U;
          return;
        }
        r = g, gr = r;
      } while (r !== null);
      Kr === ml && (Kr = ZC);
    }
    function Nc(e, r, c) {
      var g = wi(), x = Ra.transition;
      try {
        Ra.transition = null, Ar(ca), L2(e, r, c, g);
      } finally {
        Ra.transition = x, Ar(g);
      }
      return null;
    }
    function L2(e, r, c, g) {
      do
        xl();
      while (Cu !== null);
      if (H2(), (fn & (La | is)) !== Zr)
        throw new Error("Should not already be working.");
      var x = e.finishedWork, R = e.finishedLanes;
      if (hd(R), x === null)
        return Th(), null;
      if (R === Ne && A("root.finishedLanes should not be empty during a commit. This is a bug in React."), e.finishedWork = null, e.finishedLanes = Ne, x === e.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      e.callbackNode = null, e.callbackPriority = dn;
      var _ = tn(x.lanes, x.childLanes);
      zh(e, _), e === oi && (oi = null, gr = null, Qr = Ne), ((x.subtreeFlags & vi) !== _t || (x.flags & vi) !== _t) && (_c || (_c = !0, uw = c, xw(qi, function() {
        return xl(), null;
      })));
      var Y = (x.subtreeFlags & (Bl | Ia | ua | vi)) !== _t, U = (x.flags & (Bl | Ia | ua | vi)) !== _t;
      if (Y || U) {
        var J = Ra.transition;
        Ra.transition = null;
        var ne = wi();
        Ar(ca);
        var ge = fn;
        fn |= is, rw.current = null, RM(e, x), sC(), BM(e, x, R), BL(e.containerInfo), e.current = x, vm(R), WM(x, e, R), Ul(), cm(), fn = ge, Ar(ne), Ra.transition = J;
      } else
        e.current = x, sC();
      var he = _c;
      if (_c ? (_c = !1, Cu = e, Up = R) : (Rf = 0, oy = null), _ = e.pendingLanes, _ === Ne && (Ef = null), he || hT(e.current, !1), ks(x.stateNode, g), Ur && e.memoizedUpdaters.clear(), l2(), Li(e, Qn()), r !== null)
        for (var Te = e.onRecoverableError, Ae = 0; Ae < r.length; Ae++) {
          var Oe = r[Ae], dt = Oe.stack, zt = Oe.digest;
          Te(Oe.value, {
            componentStack: dt,
            digest: zt
          });
        }
      if (iy) {
        iy = !1;
        var Rt = ow;
        throw ow = null, Rt;
      }
      return ja(Up, Bt) && e.tag !== pu && xl(), _ = e.pendingLanes, ja(_, Bt) ? (FD(), e === cw ? Xp++ : (Xp = 0, cw = e)) : Xp = 0, gu(), Th(), null;
    }
    function xl() {
      if (Cu !== null) {
        var e = uc(Up), r = Px(As, e), c = Ra.transition, g = wi();
        try {
          return Ra.transition = null, Ar(r), D2();
        } finally {
          Ar(g), Ra.transition = c;
        }
      }
      return !1;
    }
    function O2(e) {
      lw.push(e), _c || (_c = !0, xw(qi, function() {
        return xl(), null;
      }));
    }
    function D2() {
      if (Cu === null)
        return !1;
      var e = uw;
      uw = null;
      var r = Cu, c = Up;
      if (Cu = null, Up = Ne, (fn & (La | is)) !== Zr)
        throw new Error("Cannot flush passive effects while already rendering.");
      dw = !0, sy = !1, ym(c);
      var g = fn;
      fn |= is, ZM(r.current), VM(r, r.current, c, e);
      {
        var x = lw;
        lw = [];
        for (var R = 0; R < x.length; R++) {
          var _ = x[R];
          MM(r, _);
        }
      }
      Ju(), hT(r.current, !0), fn = g, gu(), sy ? r === oy ? Rf++ : (Rf = 0, oy = r) : Rf = 0, dw = !1, sy = !1, so(r);
      {
        var Y = r.current.stateNode;
        Y.effectDuration = 0, Y.passiveEffectDuration = 0;
      }
      return !0;
    }
    function cT(e) {
      return Ef !== null && Ef.has(e);
    }
    function M2(e) {
      Ef === null ? Ef = /* @__PURE__ */ new Set([e]) : Ef.add(e);
    }
    function _2(e) {
      iy || (iy = !0, ow = e);
    }
    var P2 = _2;
    function dT(e, r, c) {
      var g = Oc(c, r), x = lC(e, g, Bt), R = vu(e, x, Bt), _ = li();
      R !== null && (Jo(R, Bt, _), Li(R, _));
    }
    function Gn(e, r, c) {
      if (TM(c), qp(!1), e.tag === q) {
        dT(e, e, c);
        return;
      }
      var g = null;
      for (g = r; g !== null; ) {
        if (g.tag === q) {
          dT(g, e, c);
          return;
        } else if (g.tag === j) {
          var x = g.type, R = g.stateNode;
          if (typeof x.getDerivedStateFromError == "function" || typeof R.componentDidCatch == "function" && !cT(R)) {
            var _ = Oc(c, e), Y = z0(g, _, Bt), U = vu(g, Y, Bt), J = li();
            U !== null && (Jo(U, Bt, J), Li(U, J));
            return;
          }
        }
        g = g.return;
      }
      A(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, c);
    }
    function N2(e, r, c) {
      var g = e.pingCache;
      g !== null && g.delete(r);
      var x = li();
      Nh(e, c), U2(e), oi === e && Ko(Qr, c) && (Kr === Yp || Kr === ny && Nd(Qr) && Qn() - sw < QC ? Pc(e, Ne) : ay = tn(ay, c)), Li(e, x);
    }
    function fT(e, r) {
      r === dn && (r = g2(e));
      var c = li(), g = Ai(e, r);
      g !== null && (Jo(g, r, c), Li(g, c));
    }
    function z2(e) {
      var r = e.memoizedState, c = dn;
      r !== null && (c = r.retryLane), fT(e, c);
    }
    function I2(e, r) {
      var c = dn, g;
      switch (e.tag) {
        case re:
          g = e.stateNode;
          var x = e.memoizedState;
          x !== null && (c = x.retryLane);
          break;
        case it:
          g = e.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      g !== null && g.delete(r), fT(e, c);
    }
    function F2(e) {
      return e < 120 ? 120 : e < 480 ? 480 : e < 1080 ? 1080 : e < 1920 ? 1920 : e < 3e3 ? 3e3 : e < 4320 ? 4320 : d2(e / 1960) * 1960;
    }
    function Y2() {
      if (Xp > h2)
        throw Xp = 0, cw = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Rf > p2 && (Rf = 0, oy = null, A("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function H2() {
      _s.flushLegacyContextWarning(), _s.flushPendingUnsafeLifecycleWarnings();
    }
    function hT(e, r) {
      wn(e), fy(e, za, i2), r && fy(e, Bo, s2), fy(e, za, r2), r && fy(e, Bo, a2), ln();
    }
    function fy(e, r, c) {
      for (var g = e, x = null; g !== null; ) {
        var R = g.subtreeFlags & r;
        g !== x && g.child !== null && R !== _t ? g = g.child : ((g.flags & r) !== _t && c(g), g.sibling !== null ? g = g.sibling : g = x = g.return);
      }
    }
    var hy = null;
    function pT(e) {
      {
        if ((fn & La) !== Zr || !(e.mode & rn))
          return;
        var r = e.tag;
        if (r !== V && r !== q && r !== j && r !== H && r !== we && r !== me && r !== Me)
          return;
        var c = vt(e) || "ReactComponent";
        if (hy !== null) {
          if (hy.has(c))
            return;
          hy.add(c);
        } else
          hy = /* @__PURE__ */ new Set([c]);
        var g = Dn;
        try {
          wn(e), A("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          g ? wn(e) : ln();
        }
      }
    }
    var mw;
    {
      var j2 = null;
      mw = function(e, r, c) {
        var g = ST(j2, r);
        try {
          return EC(e, r, c);
        } catch (R) {
          if (eD() || R !== null && typeof R == "object" && typeof R.then == "function")
            throw R;
          if (yv(), Nk(), _C(e, r), ST(r, g), r.mode & jt && O0(r), jo(null, EC, null, e, r, c), Ex()) {
            var x = ph();
            typeof x == "object" && x !== null && x._suppressLogging && typeof R == "object" && R !== null && !R._suppressLogging && (R._suppressLogging = !0);
          }
          throw R;
        }
      };
    }
    var gT = !1, vw;
    vw = /* @__PURE__ */ new Set();
    function B2(e) {
      if (sa && !ND())
        switch (e.tag) {
          case H:
          case we:
          case Me: {
            var r = gr && vt(gr) || "Unknown", c = r;
            if (!vw.has(c)) {
              vw.add(c);
              var g = vt(e) || "Unknown";
              A("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", g, r, r);
            }
            break;
          }
          case j: {
            gT || (A("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), gT = !0);
            break;
          }
        }
    }
    function $p(e, r) {
      if (Ur) {
        var c = e.memoizedUpdaters;
        c.forEach(function(g) {
          Ih(e, g, r);
        });
      }
    }
    var yw = {};
    function xw(e, r) {
      {
        var c = js.current;
        return c !== null ? (c.push(r), yw) : ud(e, r);
      }
    }
    function mT(e) {
      if (e !== yw)
        return um(e);
    }
    function vT() {
      return js.current !== null;
    }
    function W2(e) {
      {
        if (e.mode & rn) {
          if (!$C())
            return;
        } else if (!c2() || fn !== Zr || e.tag !== H && e.tag !== we && e.tag !== Me)
          return;
        if (js.current === null) {
          var r = Dn;
          try {
            wn(e), A(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, vt(e));
          } finally {
            r ? wn(e) : ln();
          }
        }
      }
    }
    function U2(e) {
      e.tag !== pu && $C() && js.current === null && A(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function qp(e) {
      eT = e;
    }
    var ss = null, Lf = null, X2 = function(e) {
      ss = e;
    };
    function Of(e) {
      {
        if (ss === null)
          return e;
        var r = ss(e);
        return r === void 0 ? e : r.current;
      }
    }
    function bw(e) {
      return Of(e);
    }
    function ww(e) {
      {
        if (ss === null)
          return e;
        var r = ss(e);
        if (r === void 0) {
          if (e != null && typeof e.render == "function") {
            var c = Of(e.render);
            if (e.render !== c) {
              var g = {
                $$typeof: Dt,
                render: c
              };
              return e.displayName !== void 0 && (g.displayName = e.displayName), g;
            }
          }
          return e;
        }
        return r.current;
      }
    }
    function yT(e, r) {
      {
        if (ss === null)
          return !1;
        var c = e.elementType, g = r.type, x = !1, R = typeof g == "object" && g !== null ? g.$$typeof : null;
        switch (e.tag) {
          case j: {
            typeof g == "function" && (x = !0);
            break;
          }
          case H: {
            (typeof g == "function" || R === Mt) && (x = !0);
            break;
          }
          case we: {
            (R === Dt || R === Mt) && (x = !0);
            break;
          }
          case me:
          case Me: {
            (R === Zt || R === Mt) && (x = !0);
            break;
          }
          default:
            return !1;
        }
        if (x) {
          var _ = ss(c);
          if (_ !== void 0 && _ === ss(g))
            return !0;
        }
        return !1;
      }
    }
    function xT(e) {
      {
        if (ss === null || typeof WeakSet != "function")
          return;
        Lf === null && (Lf = /* @__PURE__ */ new WeakSet()), Lf.add(e);
      }
    }
    var V2 = function(e, r) {
      {
        if (ss === null)
          return;
        var c = r.staleFamilies, g = r.updatedFamilies;
        xl(), yl(function() {
          Sw(e.current, g, c);
        });
      }
    }, G2 = function(e, r) {
      {
        if (e.context !== Bi)
          return;
        xl(), yl(function() {
          Zp(r, e, null, null);
        });
      }
    };
    function Sw(e, r, c) {
      {
        var g = e.alternate, x = e.child, R = e.sibling, _ = e.tag, Y = e.type, U = null;
        switch (_) {
          case H:
          case Me:
          case j:
            U = Y;
            break;
          case we:
            U = Y.render;
            break;
        }
        if (ss === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var J = !1, ne = !1;
        if (U !== null) {
          var ge = ss(U);
          ge !== void 0 && (c.has(ge) ? ne = !0 : r.has(ge) && (_ === j ? ne = !0 : J = !0));
        }
        if (Lf !== null && (Lf.has(e) || g !== null && Lf.has(g)) && (ne = !0), ne && (e._debugNeedsRemount = !0), ne || J) {
          var he = Ai(e, Bt);
          he !== null && Jr(he, e, Bt, Fn);
        }
        x !== null && !ne && Sw(x, r, c), R !== null && Sw(R, r, c);
      }
    }
    var $2 = function(e, r) {
      {
        var c = /* @__PURE__ */ new Set(), g = new Set(r.map(function(x) {
          return x.current;
        }));
        return kw(e.current, g, c), c;
      }
    };
    function kw(e, r, c) {
      {
        var g = e.child, x = e.sibling, R = e.tag, _ = e.type, Y = null;
        switch (R) {
          case H:
          case Me:
          case j:
            Y = _;
            break;
          case we:
            Y = _.render;
            break;
        }
        var U = !1;
        Y !== null && r.has(Y) && (U = !0), U ? q2(e, c) : g !== null && kw(g, r, c), x !== null && kw(x, r, c);
      }
    }
    function q2(e, r) {
      {
        var c = Z2(e, r);
        if (c)
          return;
        for (var g = e; ; ) {
          switch (g.tag) {
            case ae:
              r.add(g.stateNode);
              return;
            case te:
              r.add(g.stateNode.containerInfo);
              return;
            case q:
              r.add(g.stateNode.containerInfo);
              return;
          }
          if (g.return === null)
            throw new Error("Expected to reach root first.");
          g = g.return;
        }
      }
    }
    function Z2(e, r) {
      for (var c = e, g = !1; ; ) {
        if (c.tag === ae)
          g = !0, r.add(c.stateNode);
        else if (c.child !== null) {
          c.child.return = c, c = c.child;
          continue;
        }
        if (c === e)
          return g;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === e)
            return g;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
      return !1;
    }
    var Cw;
    {
      Cw = !1;
      try {
        var bT = Object.preventExtensions({});
      } catch {
        Cw = !0;
      }
    }
    function Q2(e, r, c, g) {
      this.tag = e, this.key = c, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = r, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = g, this.flags = _t, this.subtreeFlags = _t, this.deletions = null, this.lanes = Ne, this.childLanes = Ne, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !Cw && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Wi = function(e, r, c, g) {
      return new Q2(e, r, c, g);
    };
    function Tw(e) {
      var r = e.prototype;
      return !!(r && r.isReactComponent);
    }
    function K2(e) {
      return typeof e == "function" && !Tw(e) && e.defaultProps === void 0;
    }
    function J2(e) {
      if (typeof e == "function")
        return Tw(e) ? j : H;
      if (e != null) {
        var r = e.$$typeof;
        if (r === Dt)
          return we;
        if (r === Zt)
          return me;
      }
      return V;
    }
    function zc(e, r) {
      var c = e.alternate;
      c === null ? (c = Wi(e.tag, r, e.key, e.mode), c.elementType = e.elementType, c.type = e.type, c.stateNode = e.stateNode, c._debugSource = e._debugSource, c._debugOwner = e._debugOwner, c._debugHookTypes = e._debugHookTypes, c.alternate = e, e.alternate = c) : (c.pendingProps = r, c.type = e.type, c.flags = _t, c.subtreeFlags = _t, c.deletions = null, c.actualDuration = 0, c.actualStartTime = -1), c.flags = e.flags & Wr, c.childLanes = e.childLanes, c.lanes = e.lanes, c.child = e.child, c.memoizedProps = e.memoizedProps, c.memoizedState = e.memoizedState, c.updateQueue = e.updateQueue;
      var g = e.dependencies;
      switch (c.dependencies = g === null ? null : {
        lanes: g.lanes,
        firstContext: g.firstContext
      }, c.sibling = e.sibling, c.index = e.index, c.ref = e.ref, c.selfBaseDuration = e.selfBaseDuration, c.treeBaseDuration = e.treeBaseDuration, c._debugNeedsRemount = e._debugNeedsRemount, c.tag) {
        case V:
        case H:
        case Me:
          c.type = Of(e.type);
          break;
        case j:
          c.type = bw(e.type);
          break;
        case we:
          c.type = ww(e.type);
          break;
      }
      return c;
    }
    function e_(e, r) {
      e.flags &= Wr | Wn;
      var c = e.alternate;
      if (c === null)
        e.childLanes = Ne, e.lanes = r, e.child = null, e.subtreeFlags = _t, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null, e.selfBaseDuration = 0, e.treeBaseDuration = 0;
      else {
        e.childLanes = c.childLanes, e.lanes = c.lanes, e.child = c.child, e.subtreeFlags = _t, e.deletions = null, e.memoizedProps = c.memoizedProps, e.memoizedState = c.memoizedState, e.updateQueue = c.updateQueue, e.type = c.type;
        var g = c.dependencies;
        e.dependencies = g === null ? null : {
          lanes: g.lanes,
          firstContext: g.firstContext
        }, e.selfBaseDuration = c.selfBaseDuration, e.treeBaseDuration = c.treeBaseDuration;
      }
      return e;
    }
    function t_(e, r, c) {
      var g;
      return e === cv ? (g = rn, r === !0 && (g |= Kn, g |= xi)) : g = Ft, Ur && (g |= jt), Wi(q, null, null, g);
    }
    function Aw(e, r, c, g, x, R) {
      var _ = V, Y = e;
      if (typeof e == "function")
        Tw(e) ? (_ = j, Y = bw(Y)) : Y = Of(Y);
      else if (typeof e == "string")
        _ = ae;
      else
        e:
          switch (e) {
            case ba:
              return Eu(c.children, x, R, r);
            case ia:
              _ = Ce, x |= Kn, (x & rn) !== Ft && (x |= xi);
              break;
            case le:
              return n_(c, x, R, r);
            case qt:
              return r_(c, x, R, r);
            case cn:
              return a_(c, x, R, r);
            case W:
              return wT(c, x, R, r);
            case t:
            case or:
            case n:
            case a:
            case Yn:
            default: {
              if (typeof e == "object" && e !== null)
                switch (e.$$typeof) {
                  case Ye:
                    _ = K;
                    break e;
                  case tt:
                    _ = Pe;
                    break e;
                  case Dt:
                    _ = we, Y = ww(Y);
                    break e;
                  case Zt:
                    _ = me;
                    break e;
                  case Mt:
                    _ = Je, Y = null;
                    break e;
                }
              var U = "";
              {
                (e === void 0 || typeof e == "object" && e !== null && Object.keys(e).length === 0) && (U += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var J = g ? vt(g) : null;
                J && (U += `

Check the render method of \`` + J + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (e == null ? e : typeof e) + "." + U));
            }
          }
      var ne = Wi(_, c, r, x);
      return ne.elementType = e, ne.type = Y, ne.lanes = R, ne._debugOwner = g, ne;
    }
    function Ew(e, r, c) {
      var g = null;
      g = e._owner;
      var x = e.type, R = e.key, _ = e.props, Y = Aw(x, R, _, g, r, c);
      return Y._debugSource = e._source, Y._debugOwner = e._owner, Y;
    }
    function Eu(e, r, c, g) {
      var x = Wi(ue, e, g, r);
      return x.lanes = c, x;
    }
    function n_(e, r, c, g) {
      typeof e.id != "string" && A('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof e.id);
      var x = Wi(Ee, e, g, r | jt);
      return x.elementType = le, x.lanes = c, x.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, x;
    }
    function r_(e, r, c, g) {
      var x = Wi(re, e, g, r);
      return x.elementType = qt, x.lanes = c, x;
    }
    function a_(e, r, c, g) {
      var x = Wi(it, e, g, r);
      return x.elementType = cn, x.lanes = c, x;
    }
    function wT(e, r, c, g) {
      var x = Wi(Ke, e, g, r);
      x.elementType = W, x.lanes = c;
      var R = {
        isHidden: !1
      };
      return x.stateNode = R, x;
    }
    function Rw(e, r, c) {
      var g = Wi(se, e, null, r);
      return g.lanes = c, g;
    }
    function i_() {
      var e = Wi(ae, null, null, Ft);
      return e.elementType = "DELETED", e;
    }
    function s_(e) {
      var r = Wi(Xe, null, null, Ft);
      return r.stateNode = e, r;
    }
    function Lw(e, r, c) {
      var g = e.children !== null ? e.children : [], x = Wi(te, g, e.key, r);
      return x.lanes = c, x.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: e.implementation
      }, x;
    }
    function ST(e, r) {
      return e === null && (e = Wi(V, null, null, Ft)), e.tag = r.tag, e.key = r.key, e.elementType = r.elementType, e.type = r.type, e.stateNode = r.stateNode, e.return = r.return, e.child = r.child, e.sibling = r.sibling, e.index = r.index, e.ref = r.ref, e.pendingProps = r.pendingProps, e.memoizedProps = r.memoizedProps, e.updateQueue = r.updateQueue, e.memoizedState = r.memoizedState, e.dependencies = r.dependencies, e.mode = r.mode, e.flags = r.flags, e.subtreeFlags = r.subtreeFlags, e.deletions = r.deletions, e.lanes = r.lanes, e.childLanes = r.childLanes, e.alternate = r.alternate, e.actualDuration = r.actualDuration, e.actualStartTime = r.actualStartTime, e.selfBaseDuration = r.selfBaseDuration, e.treeBaseDuration = r.treeBaseDuration, e._debugSource = r._debugSource, e._debugOwner = r._debugOwner, e._debugNeedsRemount = r._debugNeedsRemount, e._debugHookTypes = r._debugHookTypes, e;
    }
    function o_(e, r, c, g, x) {
      this.tag = r, this.containerInfo = e, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = cb, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = dn, this.eventTimes = Id(Ne), this.expirationTimes = Id(Fn), this.pendingLanes = Ne, this.suspendedLanes = Ne, this.pingedLanes = Ne, this.expiredLanes = Ne, this.mutableReadLanes = Ne, this.finishedLanes = Ne, this.entangledLanes = Ne, this.entanglements = Id(Ne), this.identifierPrefix = g, this.onRecoverableError = x, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var R = this.pendingUpdatersLaneMap = [], _ = 0; _ < Xn; _++)
          R.push(/* @__PURE__ */ new Set());
      }
      switch (r) {
        case cv:
          this._debugRootType = c ? "hydrateRoot()" : "createRoot()";
          break;
        case pu:
          this._debugRootType = c ? "hydrate()" : "render()";
          break;
      }
    }
    function kT(e, r, c, g, x, R, _, Y, U, J) {
      var ne = new o_(e, r, c, Y, U), ge = t_(r, R);
      ne.current = ge, ge.stateNode = ne;
      {
        var he = {
          element: g,
          isDehydrated: c,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        ge.memoizedState = he;
      }
      return Ib(ge), ne;
    }
    var Ow = "18.2.0";
    function l_(e, r, c) {
      var g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Za(g), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: jr,
        key: g == null ? null : "" + g,
        children: e,
        containerInfo: r,
        implementation: c
      };
    }
    var Dw, Mw;
    Dw = !1, Mw = {};
    function CT(e) {
      if (!e)
        return Bi;
      var r = pi(e), c = XO(r);
      if (r.tag === j) {
        var g = r.type;
        if (bo(g))
          return ZS(r, g, c);
      }
      return c;
    }
    function u_(e, r) {
      {
        var c = pi(e);
        if (c === void 0) {
          if (typeof e.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var g = Object.keys(e).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + g);
        }
        var x = yi(c);
        if (x === null)
          return null;
        if (x.mode & Kn) {
          var R = vt(c) || "Component";
          if (!Mw[R]) {
            Mw[R] = !0;
            var _ = Dn;
            try {
              wn(x), c.mode & Kn ? A("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", r, r, R) : A("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", r, r, R);
            } finally {
              _ ? wn(_) : ln();
            }
          }
        }
        return x.stateNode;
      }
    }
    function TT(e, r, c, g, x, R, _, Y) {
      var U = !1, J = null;
      return kT(e, r, U, J, c, g, x, R, _);
    }
    function AT(e, r, c, g, x, R, _, Y, U, J) {
      var ne = !0, ge = kT(c, g, ne, e, x, R, _, Y, U);
      ge.context = CT(null);
      var he = ge.current, Te = li(), Ae = Tu(he), Oe = pl(Te, Ae);
      return Oe.callback = r ?? null, vu(he, Oe, Ae), m2(ge, Ae, Te), ge;
    }
    function Zp(e, r, c, g) {
      dm(r, e);
      var x = r.current, R = li(), _ = Tu(x);
      Uo(_);
      var Y = CT(c);
      r.context === null ? r.context = Y : r.pendingContext = Y, sa && Dn !== null && !Dw && (Dw = !0, A(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, vt(Dn) || "Unknown"));
      var U = pl(R, _);
      U.payload = {
        element: e
      }, g = g === void 0 ? null : g, g !== null && (typeof g != "function" && A("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", g), U.callback = g);
      var J = vu(x, U, _);
      return J !== null && (Jr(J, x, _, R), kv(J, x, _)), _;
    }
    function py(e) {
      var r = e.current;
      if (!r.child)
        return null;
      switch (r.child.tag) {
        case ae:
          return r.child.stateNode;
        default:
          return r.child.stateNode;
      }
    }
    function c_(e) {
      switch (e.tag) {
        case q: {
          var r = e.stateNode;
          if (Er(r)) {
            var c = Ox(r);
            b2(r, c);
          }
          break;
        }
        case re: {
          yl(function() {
            var x = Ai(e, Bt);
            if (x !== null) {
              var R = li();
              Jr(x, e, Bt, R);
            }
          });
          var g = Bt;
          _w(e, g);
          break;
        }
      }
    }
    function ET(e, r) {
      var c = e.memoizedState;
      c !== null && c.dehydrated !== null && (c.retryLane = km(c.retryLane, r));
    }
    function _w(e, r) {
      ET(e, r);
      var c = e.alternate;
      c && ET(c, r);
    }
    function d_(e) {
      if (e.tag === re) {
        var r = Vl, c = Ai(e, r);
        if (c !== null) {
          var g = li();
          Jr(c, e, r, g);
        }
        _w(e, r);
      }
    }
    function f_(e) {
      if (e.tag === re) {
        var r = Tu(e), c = Ai(e, r);
        if (c !== null) {
          var g = li();
          Jr(c, e, r, g);
        }
        _w(e, r);
      }
    }
    function RT(e) {
      var r = lm(e);
      return r === null ? null : r.stateNode;
    }
    var LT = function(e) {
      return null;
    };
    function h_(e) {
      return LT(e);
    }
    var OT = function(e) {
      return !1;
    };
    function p_(e) {
      return OT(e);
    }
    var DT = null, MT = null, _T = null, PT = null, NT = null, zT = null, IT = null, FT = null, YT = null;
    {
      var HT = function(e, r, c) {
        var g = r[c], x = _r(e) ? e.slice() : p({}, e);
        return c + 1 === r.length ? (_r(x) ? x.splice(g, 1) : delete x[g], x) : (x[g] = HT(e[g], r, c + 1), x);
      }, jT = function(e, r) {
        return HT(e, r, 0);
      }, BT = function(e, r, c, g) {
        var x = r[g], R = _r(e) ? e.slice() : p({}, e);
        if (g + 1 === r.length) {
          var _ = c[g];
          R[_] = R[x], _r(R) ? R.splice(x, 1) : delete R[x];
        } else
          R[x] = BT(
            // $FlowFixMe number or string is fine here
            e[x],
            r,
            c,
            g + 1
          );
        return R;
      }, WT = function(e, r, c) {
        if (r.length !== c.length) {
          T("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var g = 0; g < c.length - 1; g++)
            if (r[g] !== c[g]) {
              T("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return BT(e, r, c, 0);
      }, UT = function(e, r, c, g) {
        if (c >= r.length)
          return g;
        var x = r[c], R = _r(e) ? e.slice() : p({}, e);
        return R[x] = UT(e[x], r, c + 1, g), R;
      }, XT = function(e, r, c) {
        return UT(e, r, 0, c);
      }, Pw = function(e, r) {
        for (var c = e.memoizedState; c !== null && r > 0; )
          c = c.next, r--;
        return c;
      };
      DT = function(e, r, c, g) {
        var x = Pw(e, r);
        if (x !== null) {
          var R = XT(x.memoizedState, c, g);
          x.memoizedState = R, x.baseState = R, e.memoizedProps = p({}, e.memoizedProps);
          var _ = Ai(e, Bt);
          _ !== null && Jr(_, e, Bt, Fn);
        }
      }, MT = function(e, r, c) {
        var g = Pw(e, r);
        if (g !== null) {
          var x = jT(g.memoizedState, c);
          g.memoizedState = x, g.baseState = x, e.memoizedProps = p({}, e.memoizedProps);
          var R = Ai(e, Bt);
          R !== null && Jr(R, e, Bt, Fn);
        }
      }, _T = function(e, r, c, g) {
        var x = Pw(e, r);
        if (x !== null) {
          var R = WT(x.memoizedState, c, g);
          x.memoizedState = R, x.baseState = R, e.memoizedProps = p({}, e.memoizedProps);
          var _ = Ai(e, Bt);
          _ !== null && Jr(_, e, Bt, Fn);
        }
      }, PT = function(e, r, c) {
        e.pendingProps = XT(e.memoizedProps, r, c), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var g = Ai(e, Bt);
        g !== null && Jr(g, e, Bt, Fn);
      }, NT = function(e, r) {
        e.pendingProps = jT(e.memoizedProps, r), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var c = Ai(e, Bt);
        c !== null && Jr(c, e, Bt, Fn);
      }, zT = function(e, r, c) {
        e.pendingProps = WT(e.memoizedProps, r, c), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var g = Ai(e, Bt);
        g !== null && Jr(g, e, Bt, Fn);
      }, IT = function(e) {
        var r = Ai(e, Bt);
        r !== null && Jr(r, e, Bt, Fn);
      }, FT = function(e) {
        LT = e;
      }, YT = function(e) {
        OT = e;
      };
    }
    function g_(e) {
      var r = yi(e);
      return r === null ? null : r.stateNode;
    }
    function m_(e) {
      return null;
    }
    function v_() {
      return Dn;
    }
    function y_(e) {
      var r = e.findFiberByHostInstance, c = h.ReactCurrentDispatcher;
      return kh({
        bundleType: e.bundleType,
        version: e.version,
        rendererPackageName: e.rendererPackageName,
        rendererConfig: e.rendererConfig,
        overrideHookState: DT,
        overrideHookStateDeletePath: MT,
        overrideHookStateRenamePath: _T,
        overrideProps: PT,
        overridePropsDeletePath: NT,
        overridePropsRenamePath: zT,
        setErrorHandler: FT,
        setSuspenseHandler: YT,
        scheduleUpdate: IT,
        currentDispatcherRef: c,
        findHostInstanceByFiber: g_,
        findFiberByHostInstance: r || m_,
        // React Refresh
        findHostInstancesForRefresh: $2,
        scheduleRefresh: V2,
        scheduleRoot: G2,
        setRefreshHandler: X2,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: v_,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: Ow
      });
    }
    var VT = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(e) {
      console.error(e);
    };
    function Nw(e) {
      this._internalRoot = e;
    }
    gy.prototype.render = Nw.prototype.render = function(e) {
      var r = this._internalRoot;
      if (r === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? A("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : my(arguments[1]) ? A("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && A("You passed a second argument to root.render(...) but it only accepts one argument.");
        var c = r.containerInfo;
        if (c.nodeType !== br) {
          var g = RT(r.current);
          g && g.parentNode !== c && A("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      Zp(e, r, null, null);
    }, gy.prototype.unmount = Nw.prototype.unmount = function() {
      typeof arguments[0] == "function" && A("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var e = this._internalRoot;
      if (e !== null) {
        this._internalRoot = null;
        var r = e.containerInfo;
        aT() && A("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), yl(function() {
          Zp(null, e, null, null);
        }), XS(r);
      }
    };
    function x_(e, r) {
      if (!my(e))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      GT(e);
      var c = !1, g = !1, x = "", R = VT;
      r != null && (r.hydrate ? T("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof r == "object" && r !== null && r.$$typeof === Ni && A(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), r.unstable_strictMode === !0 && (c = !0), r.identifierPrefix !== void 0 && (x = r.identifierPrefix), r.onRecoverableError !== void 0 && (R = r.onRecoverableError), r.transitionCallbacks !== void 0 && r.transitionCallbacks);
      var _ = TT(e, cv, null, c, g, x, R);
      rv(_.current, e);
      var Y = e.nodeType === br ? e.parentNode : e;
      return ap(Y), new Nw(_);
    }
    function gy(e) {
      this._internalRoot = e;
    }
    function b_(e) {
      e && Dm(e);
    }
    gy.prototype.unstable_scheduleHydration = b_;
    function w_(e, r, c) {
      if (!my(e))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      GT(e), r === void 0 && A("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var g = c ?? null, x = c != null && c.hydratedSources || null, R = !1, _ = !1, Y = "", U = VT;
      c != null && (c.unstable_strictMode === !0 && (R = !0), c.identifierPrefix !== void 0 && (Y = c.identifierPrefix), c.onRecoverableError !== void 0 && (U = c.onRecoverableError));
      var J = AT(r, null, e, cv, g, R, _, Y, U);
      if (rv(J.current, e), ap(e), x)
        for (var ne = 0; ne < x.length; ne++) {
          var ge = x[ne];
          LD(J, ge);
        }
      return new gy(J);
    }
    function my(e) {
      return !!(e && (e.nodeType === _a || e.nodeType === Ii || e.nodeType === No || !Qe));
    }
    function Qp(e) {
      return !!(e && (e.nodeType === _a || e.nodeType === Ii || e.nodeType === No || e.nodeType === br && e.nodeValue === " react-mount-point-unstable "));
    }
    function GT(e) {
      e.nodeType === _a && e.tagName && e.tagName.toUpperCase() === "BODY" && A("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), gp(e) && (e._reactRootContainer ? A("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : A("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var S_ = h.ReactCurrentOwner, $T;
    $T = function(e) {
      if (e._reactRootContainer && e.nodeType !== br) {
        var r = RT(e._reactRootContainer.current);
        r && r.parentNode !== e && A("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var c = !!e._reactRootContainer, g = zw(e), x = !!(g && fu(g));
      x && !c && A("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), e.nodeType === _a && e.tagName && e.tagName.toUpperCase() === "BODY" && A("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function zw(e) {
      return e ? e.nodeType === Ii ? e.documentElement : e.firstChild : null;
    }
    function qT() {
    }
    function k_(e, r, c, g, x) {
      if (x) {
        if (typeof g == "function") {
          var R = g;
          g = function() {
            var he = py(_);
            R.call(he);
          };
        }
        var _ = AT(
          r,
          g,
          e,
          pu,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          qT
        );
        e._reactRootContainer = _, rv(_.current, e);
        var Y = e.nodeType === br ? e.parentNode : e;
        return ap(Y), yl(), _;
      } else {
        for (var U; U = e.lastChild; )
          e.removeChild(U);
        if (typeof g == "function") {
          var J = g;
          g = function() {
            var he = py(ne);
            J.call(he);
          };
        }
        var ne = TT(
          e,
          pu,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          qT
        );
        e._reactRootContainer = ne, rv(ne.current, e);
        var ge = e.nodeType === br ? e.parentNode : e;
        return ap(ge), yl(function() {
          Zp(r, ne, c, g);
        }), ne;
      }
    }
    function C_(e, r) {
      e !== null && typeof e != "function" && A("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", r, e);
    }
    function vy(e, r, c, g, x) {
      $T(c), C_(x === void 0 ? null : x, "render");
      var R = c._reactRootContainer, _;
      if (!R)
        _ = k_(c, r, e, x, g);
      else {
        if (_ = R, typeof x == "function") {
          var Y = x;
          x = function() {
            var U = py(_);
            Y.call(U);
          };
        }
        Zp(r, _, e, x);
      }
      return py(_);
    }
    function T_(e) {
      {
        var r = S_.current;
        if (r !== null && r.stateNode !== null) {
          var c = r.stateNode._warnedAboutRefsInRender;
          c || A("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", xt(r.type) || "A component"), r.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return e == null ? null : e.nodeType === _a ? e : u_(e, "findDOMNode");
    }
    function A_(e, r, c) {
      if (A("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Qp(r))
        throw new Error("Target container is not a DOM element.");
      {
        var g = gp(r) && r._reactRootContainer === void 0;
        g && A("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return vy(null, e, r, !0, c);
    }
    function E_(e, r, c) {
      if (A("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Qp(r))
        throw new Error("Target container is not a DOM element.");
      {
        var g = gp(r) && r._reactRootContainer === void 0;
        g && A("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return vy(null, e, r, !1, c);
    }
    function R_(e, r, c, g) {
      if (A("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Qp(c))
        throw new Error("Target container is not a DOM element.");
      if (e == null || !Zu(e))
        throw new Error("parentComponent must be a valid React Component");
      return vy(e, r, c, !1, g);
    }
    function L_(e) {
      if (!Qp(e))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var r = gp(e) && e._reactRootContainer === void 0;
        r && A("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (e._reactRootContainer) {
        {
          var c = zw(e), g = c && !fu(c);
          g && A("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return yl(function() {
          vy(null, null, e, !1, function() {
            e._reactRootContainer = null, XS(e);
          });
        }), !0;
      } else {
        {
          var x = zw(e), R = !!(x && fu(x)), _ = e.nodeType === _a && Qp(e.parentNode) && !!e.parentNode._reactRootContainer;
          R && A("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", _ ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    gt(c_), Tm(d_), dc(f_), Hh(wi), Em(lc), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && A("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), im(ML), ad(hw, w2, yl);
    function O_(e, r) {
      var c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!my(r))
        throw new Error("Target container is not a DOM element.");
      return l_(e, r, null, c);
    }
    function D_(e, r, c, g) {
      return R_(e, r, c, g);
    }
    var Iw = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [fu, of, av, rd, Gu, hw]
    };
    function M_(e, r) {
      return Iw.usingClientEntryPoint || A('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), x_(e, r);
    }
    function __(e, r, c) {
      return Iw.usingClientEntryPoint || A('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), w_(e, r, c);
    }
    function P_(e) {
      return aT() && A("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), yl(e);
    }
    var N_ = y_({
      findFiberByHostInstance: wc,
      bundleType: 1,
      version: Ow,
      rendererPackageName: "react-dom"
    });
    if (!N_ && pn && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var ZT = window.location.protocol;
      /^(https?|file):$/.test(ZT) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (ZT === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    Di.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Iw, Di.createPortal = O_, Di.createRoot = M_, Di.findDOMNode = T_, Di.flushSync = P_, Di.hydrate = A_, Di.hydrateRoot = __, Di.render = E_, Di.unmountComponentAtNode = L_, Di.unstable_batchedUpdates = hw, Di.unstable_renderSubtreeIntoContainer = D_, Di.version = Ow, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Di;
}
function kR() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(kR);
    } catch (s) {
      console.error(s);
    }
  }
}
process.env.NODE_ENV === "production" ? (kR(), S1.exports = BY()) : S1.exports = WY();
var UY = S1.exports;
const dg = /^[a-z0-9]+(-[a-z0-9]+)*$/, lx = (s, u, h, m = "") => {
  const w = s.split(":");
  if (s.slice(0, 1) === "@") {
    if (w.length < 2 || w.length > 3)
      return null;
    m = w.shift().slice(1);
  }
  if (w.length > 3 || !w.length)
    return null;
  if (w.length > 1) {
    const F = w.pop(), H = w.pop(), j = {
      // Allow provider without '@': "provider:prefix:name"
      provider: w.length > 0 ? w[0] : m,
      prefix: H,
      name: F
    };
    return u && !Dy(j) ? null : j;
  }
  const T = w[0], A = T.split("-");
  if (A.length > 1) {
    const F = {
      provider: m,
      prefix: A.shift(),
      name: A.join("-")
    };
    return u && !Dy(F) ? null : F;
  }
  if (h && m === "") {
    const F = {
      provider: m,
      prefix: "",
      name: T
    };
    return u && !Dy(F, h) ? null : F;
  }
  return null;
}, Dy = (s, u) => s ? !!((s.provider === "" || s.provider.match(dg)) && (u && s.prefix === "" || s.prefix.match(dg)) && s.name.match(dg)) : !1, CR = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), Vy = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), lS = Object.freeze({
  ...CR,
  ...Vy
}), k1 = Object.freeze({
  ...lS,
  body: "",
  hidden: !1
});
function XY(s, u) {
  const h = {};
  !s.hFlip != !u.hFlip && (h.hFlip = !0), !s.vFlip != !u.vFlip && (h.vFlip = !0);
  const m = ((s.rotate || 0) + (u.rotate || 0)) % 4;
  return m && (h.rotate = m), h;
}
function MA(s, u) {
  const h = XY(s, u);
  for (const m in k1)
    m in Vy ? m in s && !(m in h) && (h[m] = Vy[m]) : m in u ? h[m] = u[m] : m in s && (h[m] = s[m]);
  return h;
}
function VY(s, u) {
  const h = s.icons, m = s.aliases || /* @__PURE__ */ Object.create(null), w = /* @__PURE__ */ Object.create(null);
  function T(A) {
    if (h[A])
      return w[A] = [];
    if (!(A in w)) {
      w[A] = null;
      const F = m[A] && m[A].parent, H = F && T(F);
      H && (w[A] = [F].concat(H));
    }
    return w[A];
  }
  return (u || Object.keys(h).concat(Object.keys(m))).forEach(T), w;
}
function GY(s, u, h) {
  const m = s.icons, w = s.aliases || /* @__PURE__ */ Object.create(null);
  let T = {};
  function A(F) {
    T = MA(
      m[F] || w[F],
      T
    );
  }
  return A(u), h.forEach(A), MA(s, T);
}
function TR(s, u) {
  const h = [];
  if (typeof s != "object" || typeof s.icons != "object")
    return h;
  s.not_found instanceof Array && s.not_found.forEach((w) => {
    u(w, null), h.push(w);
  });
  const m = VY(s);
  for (const w in m) {
    const T = m[w];
    T && (u(w, GY(s, w, T)), h.push(w));
  }
  return h;
}
const $Y = {
  provider: "",
  aliases: {},
  not_found: {},
  ...CR
};
function $w(s, u) {
  for (const h in u)
    if (h in s && typeof s[h] != typeof u[h])
      return !1;
  return !0;
}
function AR(s) {
  if (typeof s != "object" || s === null)
    return null;
  const u = s;
  if (typeof u.prefix != "string" || !s.icons || typeof s.icons != "object" || !$w(s, $Y))
    return null;
  const h = u.icons;
  for (const w in h) {
    const T = h[w];
    if (!w.match(dg) || typeof T.body != "string" || !$w(
      T,
      k1
    ))
      return null;
  }
  const m = u.aliases || /* @__PURE__ */ Object.create(null);
  for (const w in m) {
    const T = m[w], A = T.parent;
    if (!w.match(dg) || typeof A != "string" || !h[A] && !m[A] || !$w(
      T,
      k1
    ))
      return null;
  }
  return u;
}
const _A = /* @__PURE__ */ Object.create(null);
function qY(s, u) {
  return {
    provider: s,
    prefix: u,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function jc(s, u) {
  const h = _A[s] || (_A[s] = /* @__PURE__ */ Object.create(null));
  return h[u] || (h[u] = qY(s, u));
}
function uS(s, u) {
  return AR(u) ? TR(u, (h, m) => {
    m ? s.icons[h] = m : s.missing.add(h);
  }) : [];
}
function ZY(s, u, h) {
  try {
    if (typeof h.body == "string")
      return s.icons[u] = { ...h }, !0;
  } catch {
  }
  return !1;
}
let xg = !1;
function ER(s) {
  return typeof s == "boolean" && (xg = s), xg;
}
function QY(s) {
  const u = typeof s == "string" ? lx(s, !0, xg) : s;
  if (u) {
    const h = jc(u.provider, u.prefix), m = u.name;
    return h.icons[m] || (h.missing.has(m) ? null : void 0);
  }
}
function KY(s, u) {
  const h = lx(s, !0, xg);
  if (!h)
    return !1;
  const m = jc(h.provider, h.prefix);
  return ZY(m, h.name, u);
}
function JY(s, u) {
  if (typeof s != "object")
    return !1;
  if (typeof u != "string" && (u = s.provider || ""), xg && !u && !s.prefix) {
    let w = !1;
    return AR(s) && (s.prefix = "", TR(s, (T, A) => {
      A && KY(T, A) && (w = !0);
    })), w;
  }
  const h = s.prefix;
  if (!Dy({
    provider: u,
    prefix: h,
    name: "a"
  }))
    return !1;
  const m = jc(u, h);
  return !!uS(m, s);
}
const RR = Object.freeze({
  width: null,
  height: null
}), LR = Object.freeze({
  // Dimensions
  ...RR,
  // Transformations
  ...Vy
}), eH = /(-?[0-9.]*[0-9]+[0-9.]*)/g, tH = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function PA(s, u, h) {
  if (u === 1)
    return s;
  if (h = h || 100, typeof s == "number")
    return Math.ceil(s * u * h) / h;
  if (typeof s != "string")
    return s;
  const m = s.split(eH);
  if (m === null || !m.length)
    return s;
  const w = [];
  let T = m.shift(), A = tH.test(T);
  for (; ; ) {
    if (A) {
      const F = parseFloat(T);
      isNaN(F) ? w.push(T) : w.push(Math.ceil(F * u * h) / h);
    } else
      w.push(T);
    if (T = m.shift(), T === void 0)
      return w.join("");
    A = !A;
  }
}
const nH = (s) => s === "unset" || s === "undefined" || s === "none";
function rH(s, u) {
  const h = {
    ...lS,
    ...s
  }, m = {
    ...LR,
    ...u
  }, w = {
    left: h.left,
    top: h.top,
    width: h.width,
    height: h.height
  };
  let T = h.body;
  [h, m].forEach((se) => {
    const ue = [], Ce = se.hFlip, Pe = se.vFlip;
    let K = se.rotate;
    Ce ? Pe ? K += 2 : (ue.push(
      "translate(" + (w.width + w.left).toString() + " " + (0 - w.top).toString() + ")"
    ), ue.push("scale(-1 1)"), w.top = w.left = 0) : Pe && (ue.push(
      "translate(" + (0 - w.left).toString() + " " + (w.height + w.top).toString() + ")"
    ), ue.push("scale(1 -1)"), w.top = w.left = 0);
    let we;
    switch (K < 0 && (K -= Math.floor(K / 4) * 4), K = K % 4, K) {
      case 1:
        we = w.height / 2 + w.top, ue.unshift(
          "rotate(90 " + we.toString() + " " + we.toString() + ")"
        );
        break;
      case 2:
        ue.unshift(
          "rotate(180 " + (w.width / 2 + w.left).toString() + " " + (w.height / 2 + w.top).toString() + ")"
        );
        break;
      case 3:
        we = w.width / 2 + w.left, ue.unshift(
          "rotate(-90 " + we.toString() + " " + we.toString() + ")"
        );
        break;
    }
    K % 2 === 1 && (w.left !== w.top && (we = w.left, w.left = w.top, w.top = we), w.width !== w.height && (we = w.width, w.width = w.height, w.height = we)), ue.length && (T = '<g transform="' + ue.join(" ") + '">' + T + "</g>");
  });
  const A = m.width, F = m.height, H = w.width, j = w.height;
  let V, q;
  A === null ? (q = F === null ? "1em" : F === "auto" ? j : F, V = PA(q, H / j)) : (V = A === "auto" ? H : A, q = F === null ? PA(V, j / H) : F === "auto" ? j : F);
  const te = {}, ae = (se, ue) => {
    nH(ue) || (te[se] = ue.toString());
  };
  return ae("width", V), ae("height", q), te.viewBox = w.left.toString() + " " + w.top.toString() + " " + H.toString() + " " + j.toString(), {
    attributes: te,
    body: T
  };
}
const aH = /\sid="(\S+)"/g, iH = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let sH = 0;
function oH(s, u = iH) {
  const h = [];
  let m;
  for (; m = aH.exec(s); )
    h.push(m[1]);
  if (!h.length)
    return s;
  const w = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return h.forEach((T) => {
    const A = typeof u == "function" ? u(T) : u + (sH++).toString(), F = T.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    s = s.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + F + ')([")]|\\.[a-z])', "g"),
      "$1" + A + w + "$3"
    );
  }), s = s.replace(new RegExp(w, "g"), ""), s;
}
const C1 = /* @__PURE__ */ Object.create(null);
function lH(s, u) {
  C1[s] = u;
}
function T1(s) {
  return C1[s] || C1[""];
}
function cS(s) {
  let u;
  if (typeof s.resources == "string")
    u = [s.resources];
  else if (u = s.resources, !(u instanceof Array) || !u.length)
    return null;
  return {
    // API hosts
    resources: u,
    // Root path
    path: s.path || "/",
    // URL length limit
    maxURL: s.maxURL || 500,
    // Timeout before next host is used.
    rotate: s.rotate || 750,
    // Timeout before failing query.
    timeout: s.timeout || 5e3,
    // Randomise default API end point.
    random: s.random === !0,
    // Start index
    index: s.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: s.dataAfterTimeout !== !1
  };
}
const dS = /* @__PURE__ */ Object.create(null), ig = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], My = [];
for (; ig.length > 0; )
  ig.length === 1 || Math.random() > 0.5 ? My.push(ig.shift()) : My.push(ig.pop());
dS[""] = cS({
  resources: ["https://api.iconify.design"].concat(My)
});
function uH(s, u) {
  const h = cS(u);
  return h === null ? !1 : (dS[s] = h, !0);
}
function fS(s) {
  return dS[s];
}
const cH = () => {
  let s;
  try {
    if (s = fetch, typeof s == "function")
      return s;
  } catch {
  }
};
let NA = cH();
function dH(s, u) {
  const h = fS(s);
  if (!h)
    return 0;
  let m;
  if (!h.maxURL)
    m = 0;
  else {
    let w = 0;
    h.resources.forEach((A) => {
      w = Math.max(w, A.length);
    });
    const T = u + ".json?icons=";
    m = h.maxURL - w - h.path.length - T.length;
  }
  return m;
}
function fH(s) {
  return s === 404;
}
const hH = (s, u, h) => {
  const m = [], w = dH(s, u), T = "icons";
  let A = {
    type: T,
    provider: s,
    prefix: u,
    icons: []
  }, F = 0;
  return h.forEach((H, j) => {
    F += H.length + 1, F >= w && j > 0 && (m.push(A), A = {
      type: T,
      provider: s,
      prefix: u,
      icons: []
    }, F = H.length), A.icons.push(H);
  }), m.push(A), m;
};
function pH(s) {
  if (typeof s == "string") {
    const u = fS(s);
    if (u)
      return u.path;
  }
  return "/";
}
const gH = (s, u, h) => {
  if (!NA) {
    h("abort", 424);
    return;
  }
  let m = pH(u.provider);
  switch (u.type) {
    case "icons": {
      const T = u.prefix, F = u.icons.join(","), H = new URLSearchParams({
        icons: F
      });
      m += T + ".json?" + H.toString();
      break;
    }
    case "custom": {
      const T = u.uri;
      m += T.slice(0, 1) === "/" ? T.slice(1) : T;
      break;
    }
    default:
      h("abort", 400);
      return;
  }
  let w = 503;
  NA(s + m).then((T) => {
    const A = T.status;
    if (A !== 200) {
      setTimeout(() => {
        h(fH(A) ? "abort" : "next", A);
      });
      return;
    }
    return w = 501, T.json();
  }).then((T) => {
    if (typeof T != "object" || T === null) {
      setTimeout(() => {
        T === 404 ? h("abort", T) : h("next", w);
      });
      return;
    }
    setTimeout(() => {
      h("success", T);
    });
  }).catch(() => {
    h("next", w);
  });
}, mH = {
  prepare: hH,
  send: gH
};
function vH(s) {
  const u = {
    loaded: [],
    missing: [],
    pending: []
  }, h = /* @__PURE__ */ Object.create(null);
  s.sort((w, T) => w.provider !== T.provider ? w.provider.localeCompare(T.provider) : w.prefix !== T.prefix ? w.prefix.localeCompare(T.prefix) : w.name.localeCompare(T.name));
  let m = {
    provider: "",
    prefix: "",
    name: ""
  };
  return s.forEach((w) => {
    if (m.name === w.name && m.prefix === w.prefix && m.provider === w.provider)
      return;
    m = w;
    const T = w.provider, A = w.prefix, F = w.name, H = h[T] || (h[T] = /* @__PURE__ */ Object.create(null)), j = H[A] || (H[A] = jc(T, A));
    let V;
    F in j.icons ? V = u.loaded : A === "" || j.missing.has(F) ? V = u.missing : V = u.pending;
    const q = {
      provider: T,
      prefix: A,
      name: F
    };
    V.push(q);
  }), u;
}
function OR(s, u) {
  s.forEach((h) => {
    const m = h.loaderCallbacks;
    m && (h.loaderCallbacks = m.filter((w) => w.id !== u));
  });
}
function yH(s) {
  s.pendingCallbacksFlag || (s.pendingCallbacksFlag = !0, setTimeout(() => {
    s.pendingCallbacksFlag = !1;
    const u = s.loaderCallbacks ? s.loaderCallbacks.slice(0) : [];
    if (!u.length)
      return;
    let h = !1;
    const m = s.provider, w = s.prefix;
    u.forEach((T) => {
      const A = T.icons, F = A.pending.length;
      A.pending = A.pending.filter((H) => {
        if (H.prefix !== w)
          return !0;
        const j = H.name;
        if (s.icons[j])
          A.loaded.push({
            provider: m,
            prefix: w,
            name: j
          });
        else if (s.missing.has(j))
          A.missing.push({
            provider: m,
            prefix: w,
            name: j
          });
        else
          return h = !0, !0;
        return !1;
      }), A.pending.length !== F && (h || OR([s], T.id), T.callback(
        A.loaded.slice(0),
        A.missing.slice(0),
        A.pending.slice(0),
        T.abort
      ));
    });
  }));
}
let xH = 0;
function bH(s, u, h) {
  const m = xH++, w = OR.bind(null, h, m);
  if (!u.pending.length)
    return w;
  const T = {
    id: m,
    icons: u,
    callback: s,
    abort: w
  };
  return h.forEach((A) => {
    (A.loaderCallbacks || (A.loaderCallbacks = [])).push(T);
  }), w;
}
function wH(s, u = !0, h = !1) {
  const m = [];
  return s.forEach((w) => {
    const T = typeof w == "string" ? lx(w, u, h) : w;
    T && m.push(T);
  }), m;
}
var SH = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function kH(s, u, h, m) {
  const w = s.resources.length, T = s.random ? Math.floor(Math.random() * w) : s.index;
  let A;
  if (s.random) {
    let me = s.resources.slice(0);
    for (A = []; me.length > 1; ) {
      const Me = Math.floor(Math.random() * me.length);
      A.push(me[Me]), me = me.slice(0, Me).concat(me.slice(Me + 1));
    }
    A = A.concat(me);
  } else
    A = s.resources.slice(T).concat(s.resources.slice(0, T));
  const F = Date.now();
  let H = "pending", j = 0, V, q = null, te = [], ae = [];
  typeof m == "function" && ae.push(m);
  function se() {
    q && (clearTimeout(q), q = null);
  }
  function ue() {
    H === "pending" && (H = "aborted"), se(), te.forEach((me) => {
      me.status === "pending" && (me.status = "aborted");
    }), te = [];
  }
  function Ce(me, Me) {
    Me && (ae = []), typeof me == "function" && ae.push(me);
  }
  function Pe() {
    return {
      startTime: F,
      payload: u,
      status: H,
      queriesSent: j,
      queriesPending: te.length,
      subscribe: Ce,
      abort: ue
    };
  }
  function K() {
    H = "failed", ae.forEach((me) => {
      me(void 0, V);
    });
  }
  function we() {
    te.forEach((me) => {
      me.status === "pending" && (me.status = "aborted");
    }), te = [];
  }
  function Ee(me, Me, Je) {
    const Ve = Me !== "success";
    switch (te = te.filter((Xe) => Xe !== me), H) {
      case "pending":
        break;
      case "failed":
        if (Ve || !s.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (Me === "abort") {
      V = Je, K();
      return;
    }
    if (Ve) {
      V = Je, te.length || (A.length ? re() : K());
      return;
    }
    if (se(), we(), !s.random) {
      const Xe = s.resources.indexOf(me.resource);
      Xe !== -1 && Xe !== s.index && (s.index = Xe);
    }
    H = "completed", ae.forEach((Xe) => {
      Xe(Je);
    });
  }
  function re() {
    if (H !== "pending")
      return;
    se();
    const me = A.shift();
    if (me === void 0) {
      if (te.length) {
        q = setTimeout(() => {
          se(), H === "pending" && (we(), K());
        }, s.timeout);
        return;
      }
      K();
      return;
    }
    const Me = {
      status: "pending",
      resource: me,
      callback: (Je, Ve) => {
        Ee(Me, Je, Ve);
      }
    };
    te.push(Me), j++, q = setTimeout(re, s.rotate), h(me, u, Me.callback);
  }
  return setTimeout(re), Pe;
}
function DR(s) {
  const u = {
    ...SH,
    ...s
  };
  let h = [];
  function m() {
    h = h.filter((F) => F().status === "pending");
  }
  function w(F, H, j) {
    const V = kH(
      u,
      F,
      H,
      (q, te) => {
        m(), j && j(q, te);
      }
    );
    return h.push(V), V;
  }
  function T(F) {
    return h.find((H) => F(H)) || null;
  }
  return {
    query: w,
    find: T,
    setIndex: (F) => {
      u.index = F;
    },
    getIndex: () => u.index,
    cleanup: m
  };
}
function zA() {
}
const qw = /* @__PURE__ */ Object.create(null);
function CH(s) {
  if (!qw[s]) {
    const u = fS(s);
    if (!u)
      return;
    const h = DR(u), m = {
      config: u,
      redundancy: h
    };
    qw[s] = m;
  }
  return qw[s];
}
function TH(s, u, h) {
  let m, w;
  if (typeof s == "string") {
    const T = T1(s);
    if (!T)
      return h(void 0, 424), zA;
    w = T.send;
    const A = CH(s);
    A && (m = A.redundancy);
  } else {
    const T = cS(s);
    if (T) {
      m = DR(T);
      const A = s.resources ? s.resources[0] : "", F = T1(A);
      F && (w = F.send);
    }
  }
  return !m || !w ? (h(void 0, 424), zA) : m.query(u, w, h)().abort;
}
const IA = "iconify2", bg = "iconify", MR = bg + "-count", FA = bg + "-version", _R = 36e5, AH = 168;
function A1(s, u) {
  try {
    return s.getItem(u);
  } catch {
  }
}
function hS(s, u, h) {
  try {
    return s.setItem(u, h), !0;
  } catch {
  }
}
function YA(s, u) {
  try {
    s.removeItem(u);
  } catch {
  }
}
function E1(s, u) {
  return hS(s, MR, u.toString());
}
function R1(s) {
  return parseInt(A1(s, MR)) || 0;
}
const ux = {
  local: !0,
  session: !0
}, PR = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let pS = !1;
function EH(s) {
  pS = s;
}
let ky = typeof window > "u" ? {} : window;
function NR(s) {
  const u = s + "Storage";
  try {
    if (ky && ky[u] && typeof ky[u].length == "number")
      return ky[u];
  } catch {
  }
  ux[s] = !1;
}
function zR(s, u) {
  const h = NR(s);
  if (!h)
    return;
  const m = A1(h, FA);
  if (m !== IA) {
    if (m) {
      const F = R1(h);
      for (let H = 0; H < F; H++)
        YA(h, bg + H.toString());
    }
    hS(h, FA, IA), E1(h, 0);
    return;
  }
  const w = Math.floor(Date.now() / _R) - AH, T = (F) => {
    const H = bg + F.toString(), j = A1(h, H);
    if (typeof j == "string") {
      try {
        const V = JSON.parse(j);
        if (typeof V == "object" && typeof V.cached == "number" && V.cached > w && typeof V.provider == "string" && typeof V.data == "object" && typeof V.data.prefix == "string" && // Valid item: run callback
        u(V, F))
          return !0;
      } catch {
      }
      YA(h, H);
    }
  };
  let A = R1(h);
  for (let F = A - 1; F >= 0; F--)
    T(F) || (F === A - 1 ? (A--, E1(h, A)) : PR[s].add(F));
}
function IR() {
  if (!pS) {
    EH(!0);
    for (const s in ux)
      zR(s, (u) => {
        const h = u.data, m = u.provider, w = h.prefix, T = jc(
          m,
          w
        );
        if (!uS(T, h).length)
          return !1;
        const A = h.lastModified || -1;
        return T.lastModifiedCached = T.lastModifiedCached ? Math.min(T.lastModifiedCached, A) : A, !0;
      });
  }
}
function RH(s, u) {
  const h = s.lastModifiedCached;
  if (
    // Matches or newer
    h && h >= u
  )
    return h === u;
  if (s.lastModifiedCached = u, h)
    for (const m in ux)
      zR(m, (w) => {
        const T = w.data;
        return w.provider !== s.provider || T.prefix !== s.prefix || T.lastModified === u;
      });
  return !0;
}
function LH(s, u) {
  pS || IR();
  function h(m) {
    let w;
    if (!ux[m] || !(w = NR(m)))
      return;
    const T = PR[m];
    let A;
    if (T.size)
      T.delete(A = Array.from(T).shift());
    else if (A = R1(w), !E1(w, A + 1))
      return;
    const F = {
      cached: Math.floor(Date.now() / _R),
      provider: s.provider,
      data: u
    };
    return hS(
      w,
      bg + A.toString(),
      JSON.stringify(F)
    );
  }
  u.lastModified && !RH(s, u.lastModified) || Object.keys(u.icons).length && (u.not_found && (u = Object.assign({}, u), delete u.not_found), h("local") || h("session"));
}
function HA() {
}
function OH(s) {
  s.iconsLoaderFlag || (s.iconsLoaderFlag = !0, setTimeout(() => {
    s.iconsLoaderFlag = !1, yH(s);
  }));
}
function DH(s, u) {
  s.iconsToLoad ? s.iconsToLoad = s.iconsToLoad.concat(u).sort() : s.iconsToLoad = u, s.iconsQueueFlag || (s.iconsQueueFlag = !0, setTimeout(() => {
    s.iconsQueueFlag = !1;
    const { provider: h, prefix: m } = s, w = s.iconsToLoad;
    delete s.iconsToLoad;
    let T;
    if (!w || !(T = T1(h)))
      return;
    T.prepare(h, m, w).forEach((F) => {
      TH(h, F, (H) => {
        if (typeof H != "object")
          F.icons.forEach((j) => {
            s.missing.add(j);
          });
        else
          try {
            const j = uS(
              s,
              H
            );
            if (!j.length)
              return;
            const V = s.pendingIcons;
            V && j.forEach((q) => {
              V.delete(q);
            }), LH(s, H);
          } catch (j) {
            console.error(j);
          }
        OH(s);
      });
    });
  }));
}
const MH = (s, u) => {
  const h = wH(s, !0, ER()), m = vH(h);
  if (!m.pending.length) {
    let H = !0;
    return u && setTimeout(() => {
      H && u(
        m.loaded,
        m.missing,
        m.pending,
        HA
      );
    }), () => {
      H = !1;
    };
  }
  const w = /* @__PURE__ */ Object.create(null), T = [];
  let A, F;
  return m.pending.forEach((H) => {
    const { provider: j, prefix: V } = H;
    if (V === F && j === A)
      return;
    A = j, F = V, T.push(jc(j, V));
    const q = w[j] || (w[j] = /* @__PURE__ */ Object.create(null));
    q[V] || (q[V] = []);
  }), m.pending.forEach((H) => {
    const { provider: j, prefix: V, name: q } = H, te = jc(j, V), ae = te.pendingIcons || (te.pendingIcons = /* @__PURE__ */ new Set());
    ae.has(q) || (ae.add(q), w[j][V].push(q));
  }), T.forEach((H) => {
    const { provider: j, prefix: V } = H;
    w[j][V].length && DH(H, w[j][V]);
  }), u ? bH(u, m, T) : HA;
};
function _H(s, u) {
  const h = {
    ...s
  };
  for (const m in u) {
    const w = u[m], T = typeof w;
    m in RR ? (w === null || w && (T === "string" || T === "number")) && (h[m] = w) : T === typeof h[m] && (h[m] = m === "rotate" ? w % 4 : w);
  }
  return h;
}
const PH = /[\s,]+/;
function NH(s, u) {
  u.split(PH).forEach((h) => {
    switch (h.trim()) {
      case "horizontal":
        s.hFlip = !0;
        break;
      case "vertical":
        s.vFlip = !0;
        break;
    }
  });
}
function zH(s, u = 0) {
  const h = s.replace(/^-?[0-9.]*/, "");
  function m(w) {
    for (; w < 0; )
      w += 4;
    return w % 4;
  }
  if (h === "") {
    const w = parseInt(s);
    return isNaN(w) ? 0 : m(w);
  } else if (h !== s) {
    let w = 0;
    switch (h) {
      case "%":
        w = 25;
        break;
      case "deg":
        w = 90;
    }
    if (w) {
      let T = parseFloat(s.slice(0, s.length - h.length));
      return isNaN(T) ? 0 : (T = T / w, T % 1 === 0 ? m(T) : 0);
    }
  }
  return u;
}
function IH(s, u) {
  let h = s.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const m in u)
    h += " " + m + '="' + u[m] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + h + ">" + s + "</svg>";
}
function FH(s) {
  return s.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function YH(s) {
  return "data:image/svg+xml," + FH(s);
}
function HH(s) {
  return 'url("' + YH(s) + '")';
}
let fg;
function jH() {
  try {
    fg = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (s) => s
    });
  } catch {
    fg = null;
  }
}
function BH(s) {
  return fg === void 0 && jH(), fg ? fg.createHTML(s) : s;
}
const FR = {
  ...LR,
  inline: !1
}, WH = {
  xmlns: "http://www.w3.org/2000/svg",
  xmlnsXlink: "http://www.w3.org/1999/xlink",
  "aria-hidden": !0,
  role: "img"
}, UH = {
  display: "inline-block"
}, L1 = {
  backgroundColor: "currentColor"
}, YR = {
  backgroundColor: "transparent"
}, jA = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
}, BA = {
  WebkitMask: L1,
  mask: L1,
  background: YR
};
for (const s in BA) {
  const u = BA[s];
  for (const h in jA)
    u[s + h] = jA[h];
}
const XH = {
  ...FR,
  inline: !0
};
function WA(s) {
  return s + (s.match(/^[-0-9.]+$/) ? "px" : "");
}
const VH = (s, u, h, m) => {
  const w = h ? XH : FR, T = _H(w, u), A = u.mode || "svg", F = {}, H = u.style || {}, j = {
    ...A === "svg" ? WH : {},
    ref: m
  };
  for (let Pe in u) {
    const K = u[Pe];
    if (K !== void 0)
      switch (Pe) {
        case "icon":
        case "style":
        case "children":
        case "onLoad":
        case "mode":
        case "_ref":
        case "_inline":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          T[Pe] = K === !0 || K === "true" || K === 1;
          break;
        case "flip":
          typeof K == "string" && NH(T, K);
          break;
        case "color":
          F.color = K;
          break;
        case "rotate":
          typeof K == "string" ? T[Pe] = zH(K) : typeof K == "number" && (T[Pe] = K);
          break;
        case "ariaHidden":
        case "aria-hidden":
          K !== !0 && K !== "true" && delete j["aria-hidden"];
          break;
        default:
          w[Pe] === void 0 && (j[Pe] = K);
      }
  }
  const V = rH(s, T), q = V.attributes;
  if (T.inline && (F.verticalAlign = "-0.125em"), A === "svg") {
    j.style = {
      ...F,
      ...H
    }, Object.assign(j, q);
    let Pe = 0, K = u.id;
    return typeof K == "string" && (K = K.replace(/-/g, "_")), j.dangerouslySetInnerHTML = {
      __html: BH(oH(V.body, K ? () => K + "ID" + Pe++ : "iconifyReact"))
    }, va.createElement("svg", j);
  }
  const { body: te, width: ae, height: se } = s, ue = A === "mask" || (A === "bg" ? !1 : te.indexOf("currentColor") !== -1), Ce = IH(te, {
    ...q,
    width: ae + "",
    height: se + ""
  });
  return j.style = {
    ...F,
    "--svg": HH(Ce),
    width: WA(q.width),
    height: WA(q.height),
    ...UH,
    ...ue ? L1 : YR,
    ...H
  }, va.createElement("span", j);
};
ER(!0);
lH("", mH);
if (typeof document < "u" && typeof window < "u") {
  IR();
  const s = window;
  if (s.IconifyPreload !== void 0) {
    const u = s.IconifyPreload, h = "Invalid IconifyPreload syntax.";
    typeof u == "object" && u !== null && (u instanceof Array ? u : [u]).forEach((m) => {
      try {
        // Check if item is an object and not null/array
        (typeof m != "object" || m === null || m instanceof Array || // Check for 'icons' and 'prefix'
        typeof m.icons != "object" || typeof m.prefix != "string" || // Add icon set
        !JY(m)) && console.error(h);
      } catch {
        console.error(h);
      }
    });
  }
  if (s.IconifyProviders !== void 0) {
    const u = s.IconifyProviders;
    if (typeof u == "object" && u !== null)
      for (let h in u) {
        const m = "IconifyProviders[" + h + "] is invalid.";
        try {
          const w = u[h];
          if (typeof w != "object" || !w || w.resources === void 0)
            continue;
          uH(h, w) || console.error(m);
        } catch {
          console.error(m);
        }
      }
  }
}
class HR extends va.Component {
  constructor(u) {
    super(u), this.state = {
      // Render placeholder before component is mounted
      icon: null
    };
  }
  /**
   * Abort loading icon
   */
  _abortLoading() {
    this._loading && (this._loading.abort(), this._loading = null);
  }
  /**
   * Update state
   */
  _setData(u) {
    this.state.icon !== u && this.setState({
      icon: u
    });
  }
  /**
   * Check if icon should be loaded
   */
  _checkIcon(u) {
    const h = this.state, m = this.props.icon;
    if (typeof m == "object" && m !== null && typeof m.body == "string") {
      this._icon = "", this._abortLoading(), (u || h.icon === null) && this._setData({
        data: m
      });
      return;
    }
    let w;
    if (typeof m != "string" || (w = lx(m, !1, !0)) === null) {
      this._abortLoading(), this._setData(null);
      return;
    }
    const T = QY(w);
    if (!T) {
      (!this._loading || this._loading.name !== m) && (this._abortLoading(), this._icon = "", this._setData(null), T !== null && (this._loading = {
        name: m,
        abort: MH([w], this._checkIcon.bind(this, !1))
      }));
      return;
    }
    if (this._icon !== m || h.icon === null) {
      this._abortLoading(), this._icon = m;
      const A = ["iconify"];
      w.prefix !== "" && A.push("iconify--" + w.prefix), w.provider !== "" && A.push("iconify--" + w.provider), this._setData({
        data: T,
        classes: A
      }), this.props.onLoad && this.props.onLoad(m);
    }
  }
  /**
   * Component mounted
   */
  componentDidMount() {
    this._checkIcon(!1);
  }
  /**
   * Component updated
   */
  componentDidUpdate(u) {
    u.icon !== this.props.icon && this._checkIcon(!0);
  }
  /**
   * Abort loading
   */
  componentWillUnmount() {
    this._abortLoading();
  }
  /**
   * Render
   */
  render() {
    const u = this.props, h = this.state.icon;
    if (h === null)
      return u.children ? u.children : va.createElement("span", {});
    let m = u;
    return h.classes && (m = {
      ...u,
      className: (typeof u.className == "string" ? u.className + " " : "") + h.classes.join(" ")
    }), VH({
      ...lS,
      ...h.data
    }, m, u._inline, u._ref);
  }
}
const jR = va.forwardRef(function(u, h) {
  const m = {
    ...u,
    _ref: h,
    _inline: !1
  };
  return va.createElement(HR, m);
});
va.forwardRef(function(u, h) {
  const m = {
    ...u,
    _ref: h,
    _inline: !0
  };
  return va.createElement(HR, m);
});
const UA = (s) => {
  let u;
  const h = /* @__PURE__ */ new Set(), m = (H, j) => {
    const V = typeof H == "function" ? H(u) : H;
    if (!Object.is(V, u)) {
      const q = u;
      u = j ?? typeof V != "object" ? V : Object.assign({}, u, V), h.forEach((te) => te(u, q));
    }
  }, w = () => u, F = { setState: m, getState: w, subscribe: (H) => (h.add(H), () => h.delete(H)), destroy: () => {
    h.clear();
  } };
  return u = s(m, w, F), F;
}, GH = (s) => s ? UA(s) : UA;
var O1 = { exports: {} }, Zw = {}, Cy = { exports: {} }, Qw = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XA;
function $H() {
  if (XA)
    return Qw;
  XA = 1;
  var s = va;
  function u(q, te) {
    return q === te && (q !== 0 || 1 / q === 1 / te) || q !== q && te !== te;
  }
  var h = typeof Object.is == "function" ? Object.is : u, m = s.useState, w = s.useEffect, T = s.useLayoutEffect, A = s.useDebugValue;
  function F(q, te) {
    var ae = te(), se = m({ inst: { value: ae, getSnapshot: te } }), ue = se[0].inst, Ce = se[1];
    return T(function() {
      ue.value = ae, ue.getSnapshot = te, H(ue) && Ce({ inst: ue });
    }, [q, ae, te]), w(function() {
      return H(ue) && Ce({ inst: ue }), q(function() {
        H(ue) && Ce({ inst: ue });
      });
    }, [q]), A(ae), ae;
  }
  function H(q) {
    var te = q.getSnapshot;
    q = q.value;
    try {
      var ae = te();
      return !h(q, ae);
    } catch {
      return !0;
    }
  }
  function j(q, te) {
    return te();
  }
  var V = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? j : F;
  return Qw.useSyncExternalStore = s.useSyncExternalStore !== void 0 ? s.useSyncExternalStore : V, Qw;
}
var Kw = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VA;
function qH() {
  return VA || (VA = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var s = va, u = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function h(we) {
      {
        for (var Ee = arguments.length, re = new Array(Ee > 1 ? Ee - 1 : 0), me = 1; me < Ee; me++)
          re[me - 1] = arguments[me];
        m("error", we, re);
      }
    }
    function m(we, Ee, re) {
      {
        var me = u.ReactDebugCurrentFrame, Me = me.getStackAddendum();
        Me !== "" && (Ee += "%s", re = re.concat([Me]));
        var Je = re.map(function(Ve) {
          return String(Ve);
        });
        Je.unshift("Warning: " + Ee), Function.prototype.apply.call(console[we], console, Je);
      }
    }
    function w(we, Ee) {
      return we === Ee && (we !== 0 || 1 / we === 1 / Ee) || we !== we && Ee !== Ee;
    }
    var T = typeof Object.is == "function" ? Object.is : w, A = s.useState, F = s.useEffect, H = s.useLayoutEffect, j = s.useDebugValue, V = !1, q = !1;
    function te(we, Ee, re) {
      V || s.startTransition !== void 0 && (V = !0, h("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var me = Ee();
      if (!q) {
        var Me = Ee();
        T(me, Me) || (h("The result of getSnapshot should be cached to avoid an infinite loop"), q = !0);
      }
      var Je = A({
        inst: {
          value: me,
          getSnapshot: Ee
        }
      }), Ve = Je[0].inst, Xe = Je[1];
      return H(function() {
        Ve.value = me, Ve.getSnapshot = Ee, ae(Ve) && Xe({
          inst: Ve
        });
      }, [we, me, Ee]), F(function() {
        ae(Ve) && Xe({
          inst: Ve
        });
        var it = function() {
          ae(Ve) && Xe({
            inst: Ve
          });
        };
        return we(it);
      }, [we]), j(me), me;
    }
    function ae(we) {
      var Ee = we.getSnapshot, re = we.value;
      try {
        var me = Ee();
        return !T(re, me);
      } catch {
        return !0;
      }
    }
    function se(we, Ee, re) {
      return Ee();
    }
    var ue = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Ce = !ue, Pe = Ce ? se : te, K = s.useSyncExternalStore !== void 0 ? s.useSyncExternalStore : Pe;
    Kw.useSyncExternalStore = K, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Kw;
}
var GA;
function BR() {
  return GA || (GA = 1, process.env.NODE_ENV === "production" ? Cy.exports = $H() : Cy.exports = qH()), Cy.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $A;
function ZH() {
  if ($A)
    return Zw;
  $A = 1;
  var s = va, u = BR();
  function h(j, V) {
    return j === V && (j !== 0 || 1 / j === 1 / V) || j !== j && V !== V;
  }
  var m = typeof Object.is == "function" ? Object.is : h, w = u.useSyncExternalStore, T = s.useRef, A = s.useEffect, F = s.useMemo, H = s.useDebugValue;
  return Zw.useSyncExternalStoreWithSelector = function(j, V, q, te, ae) {
    var se = T(null);
    if (se.current === null) {
      var ue = { hasValue: !1, value: null };
      se.current = ue;
    } else
      ue = se.current;
    se = F(function() {
      function Pe(me) {
        if (!K) {
          if (K = !0, we = me, me = te(me), ae !== void 0 && ue.hasValue) {
            var Me = ue.value;
            if (ae(Me, me))
              return Ee = Me;
          }
          return Ee = me;
        }
        if (Me = Ee, m(we, me))
          return Me;
        var Je = te(me);
        return ae !== void 0 && ae(Me, Je) ? Me : (we = me, Ee = Je);
      }
      var K = !1, we, Ee, re = q === void 0 ? null : q;
      return [function() {
        return Pe(V());
      }, re === null ? void 0 : function() {
        return Pe(re());
      }];
    }, [V, q, te, ae]);
    var Ce = w(j, se[0], se[1]);
    return A(function() {
      ue.hasValue = !0, ue.value = Ce;
    }, [Ce]), H(Ce), Ce;
  }, Zw;
}
var Jw = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qA;
function QH() {
  return qA || (qA = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var s = va, u = BR();
    function h(V, q) {
      return V === q && (V !== 0 || 1 / V === 1 / q) || V !== V && q !== q;
    }
    var m = typeof Object.is == "function" ? Object.is : h, w = u.useSyncExternalStore, T = s.useRef, A = s.useEffect, F = s.useMemo, H = s.useDebugValue;
    function j(V, q, te, ae, se) {
      var ue = T(null), Ce;
      ue.current === null ? (Ce = {
        hasValue: !1,
        value: null
      }, ue.current = Ce) : Ce = ue.current;
      var Pe = F(function() {
        var re = !1, me, Me, Je = function(ht) {
          if (!re) {
            re = !0, me = ht;
            var Ke = ae(ht);
            if (se !== void 0 && Ce.hasValue) {
              var Ze = Ce.value;
              if (se(Ze, Ke))
                return Me = Ze, Ze;
            }
            return Me = Ke, Ke;
          }
          var Tt = me, It = Me;
          if (m(Tt, ht))
            return It;
          var Jt = ae(ht);
          return se !== void 0 && se(It, Jt) ? It : (me = ht, Me = Jt, Jt);
        }, Ve = te === void 0 ? null : te, Xe = function() {
          return Je(q());
        }, it = Ve === null ? void 0 : function() {
          return Je(Ve());
        };
        return [Xe, it];
      }, [q, te, ae, se]), K = Pe[0], we = Pe[1], Ee = w(V, K, we);
      return A(function() {
        Ce.hasValue = !0, Ce.value = Ee;
      }, [Ee]), H(Ee), Ee;
    }
    Jw.useSyncExternalStoreWithSelector = j, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Jw;
}
process.env.NODE_ENV === "production" ? O1.exports = ZH() : O1.exports = QH();
var KH = O1.exports;
const JH = /* @__PURE__ */ Y_(KH), { useSyncExternalStoreWithSelector: ej } = JH;
function tj(s, u = s.getState, h) {
  const m = ej(
    s.subscribe,
    s.getState,
    s.getServerState || s.getState,
    u,
    h
  );
  return F_(m), m;
}
const ZA = (s) => {
  const u = typeof s == "function" ? GH(s) : s, h = (m, w) => tj(u, m, w);
  return Object.assign(h, u), h;
}, WR = (s) => s ? ZA(s) : ZA, UR = (s, u) => (...h) => Object.assign({}, s, u(...h)), XR = WR(
  UR(
    {
      currentOpen: []
    },
    (s, u) => ({
      openModal: (h) => {
        if (u().currentOpen.includes(h))
          return;
        const m = [...u().currentOpen, h];
        console.log("Updated openModal: ", m), s({ currentOpen: m });
      },
      closeModal: () => {
        const h = document.querySelector("#modal-root");
        h && (h.classList.add("closed"), setTimeout(() => {
          h.classList.remove("closed");
          const m = u().currentOpen.slice(
            0,
            u().currentOpen.length - 1
          );
          console.log("Updated openModal: ", m), s({ currentOpen: m });
        }, 190));
      },
      closeAllModals: () => {
        const h = document.querySelector("#modal-root");
        h && (h.classList.add("closed"), setTimeout(() => {
          h.classList.remove("closed"), s({ currentOpen: [] });
        }, 190));
      }
    })
  )
), nj = ({
  children: s,
  currentName: u,
  variant: h = "neutral",
  size: m = "normal",
  className: w = "",
  closeButton: T = !1,
  onClose: A = () => {
  }
}) => {
  const { currentOpen: F, closeModal: H } = XR(), j = document.querySelector("#modal-root"), V = mr(null);
  return Hf(() => {
    var q;
    F.length > 0 && V.current && (V.current.focus(), j.classList.add("shown")), (F.length === 0 || ((q = V.current) == null ? void 0 : q.childNodes.length) === 0) && j.classList.remove("shown");
  }, [F, j]), F.includes(u) && j ? UY.createPortal(
    /* @__PURE__ */ ce.jsxs(
      "div",
      {
        tabIndex: 0,
        ref: V,
        onKeyDown: (q) => {
          q.key === "Escape" && (A(), H());
        },
        className: "modal",
        children: [
          /* @__PURE__ */ ce.jsx(
            "div",
            {
              className: "modal-overlay",
              onClick: () => {
                A(), H();
              }
            }
          ),
          /* @__PURE__ */ ce.jsxs(
            "div",
            {
              className: `modal-body container rounded-box bg-${h} ${m} ${w}`,
              children: [
                T && /* @__PURE__ */ ce.jsx(
                  "button",
                  {
                    type: "button",
                    className: "close-btn",
                    onClick: () => {
                      A(), H();
                    },
                    children: /* @__PURE__ */ ce.jsx(jR, { icon: "mingcute:close-fill", height: 16 })
                  }
                ),
                s
              ]
            }
          )
        ]
      }
    ),
    j
  ) : null;
}, rj = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100], aj = ({
  children: s,
  data: u,
  itemsPerPage: h = 30
}) => {
  const m = Du(() => u.length, [u]), [w, T] = fr(1), [A, F] = fr(h), H = Du(() => u.slice(
    (w - 1) * A,
    w * A
  ), [u, w, A]);
  return /* @__PURE__ */ ce.jsxs(ce.Fragment, { children: [
    /* @__PURE__ */ ce.jsx("div", { className: "table-content custom-scroll", children: s({ data: H() }) }),
    /* @__PURE__ */ ce.jsxs("footer", { className: "table-footer", children: [
      /* @__PURE__ */ ce.jsx(
        "button",
        {
          className: "btn btn-icon btn-square btn-sm ring-info",
          title: "First Page",
          disabled: w === 1,
          onClick: () => T(1),
          children: /* @__PURE__ */ ce.jsx(ma, { hFlip: !0, icon: "ic:round-fast-forward" })
        }
      ),
      /* @__PURE__ */ ce.jsx(
        "button",
        {
          className: "btn btn-icon btn-square btn-sm ring-info",
          title: "Previous Page",
          disabled: w === 1,
          onClick: () => T((j) => j - 1),
          children: /* @__PURE__ */ ce.jsx(ma, { hFlip: !0, icon: "ic:round-skip-next" })
        }
      ),
      /* @__PURE__ */ ce.jsxs("span", { children: [
        nr("table.page"),
        " ",
        /* @__PURE__ */ ce.jsx("span", { className: "page", children: w }),
        " ",
        nr("table.of"),
        " ",
        /* @__PURE__ */ ce.jsx("span", { className: "page", children: Math.ceil(m() / A) })
      ] }),
      /* @__PURE__ */ ce.jsx(
        Yy,
        {
          items: rj,
          currentSelected: h,
          labelExtractor: (j) => `${nr("table.per-page")} ${j}`,
          keyExtractor: (j) => j,
          showQty: 3,
          position: "bottom",
          onChange: (j, V) => {
            const q = Math.ceil(m() / V), te = w * A, se = (w > q ? q * V : w * V) / te, ue = se !== 1 ? Math.floor(w / se) : w;
            w > q ? T(q) : T(ue < 1 ? 1 : ue), F(V);
          }
        }
      ),
      /* @__PURE__ */ ce.jsx(
        "button",
        {
          className: "btn btn-icon btn-square btn-sm ring-info",
          title: "Next Page",
          disabled: Math.ceil(m() / A) === w,
          onClick: () => T((j) => j + 1),
          children: /* @__PURE__ */ ce.jsx(ma, { icon: "ic:round-skip-next" })
        }
      ),
      /* @__PURE__ */ ce.jsx(
        "button",
        {
          className: "btn btn-icon btn-square btn-sm ring-info",
          disabled: Math.ceil(m() / A) === w,
          onClick: () => T(Math.ceil(m() / A)),
          title: "Last Page",
          children: /* @__PURE__ */ ce.jsx(ma, { icon: "ic:round-fast-forward" })
        }
      ),
      /* @__PURE__ */ ce.jsxs("span", { children: [
        m(),
        " ",
        nr("table.items")
      ] })
    ] })
  ] });
}, ij = (s) => {
  const [u, h] = fr(s ?? null), [m, w] = fr({
    top: (u == null ? void 0 : u.scrollTop) ?? 0,
    scrollHeight: (u == null ? void 0 : u.scrollHeight) ?? 0,
    height: (u == null ? void 0 : u.clientHeight) ?? 0
  });
  return Hf(() => {
    const T = () => {
      u && w({
        top: u.scrollTop,
        scrollHeight: u.scrollHeight,
        height: u.clientHeight
      });
    };
    if (u)
      return u == null || u.addEventListener("scroll", j1(T, 150)), () => {
        u == null || u.removeEventListener("scroll", T);
      };
  }, [u]), u ? { ...m, scrollTo: u.scrollTo, root: u, setRoot: h, changeScrollData: w } : {
    top: 0,
    scrollHeight: 0,
    height: 0,
    scrollTo: () => {
    },
    root: u,
    setRoot: h,
    changeScrollData: w
  };
}, sj = ({
  children: s,
  data: u,
  tableContainerRef: h
}) => {
  const { height: m, scrollHeight: w, top: T, root: A, setRoot: F, changeScrollData: H } = ij(h == null ? void 0 : h.current), j = mr(0), V = mr(j.current * 2), q = 40, te = Du(() => h.current === null ? 10 : Math.ceil(h.current.clientHeight / q), [h]);
  Hf(() => (A === null && F(h.current), j.current = te(), () => {
  }), [te, h, A, F, H]);
  const ae = Du(() => {
    let se = 0;
    return A === null ? [] : (j.current < 10 && (j.current = te() * 2), Math.ceil(m + T) === w && (V.current += j.current, A.scrollTo({
      top: j.current * q
    })), V.current > j.current * 3 && T > 0 && (se = V.current - j.current * 3), T === 0 && V.current > j.current * 3 && (V.current -= j.current, se = V.current - j.current * 3, A.scrollTo({
      top: j.current * q
    })), u.slice(se, V.current));
  }, [u, m, te, w, T, A, j]);
  return s({ data: ae() });
}, oj = {
  scroll: sj,
  pagination: aj
}, lj = ({
  mode: s,
  children: u,
  data: h
}) => {
  const m = mr(null), w = oj[s];
  return /* @__PURE__ */ ce.jsx("div", { className: `table-container ${s}`, ref: m, children: /* @__PURE__ */ ce.jsx(w, { tableContainerRef: m, data: h, children: u }) });
}, QA = [
  "info",
  "info-hover",
  "danger",
  "danger-hover",
  "warning",
  "warning-hover",
  "primary",
  "primary-hover",
  "secondary",
  "secondary-hover"
], uj = [
  "none",
  "greater",
  "greaterOrEqual",
  "lesser",
  "lesserOrEqual",
  "equal",
  "different"
], cj = {
  greater: "ic:round-greater-than",
  greaterOrEqual: "ic:round-greater-than-equal",
  lesser: "ic:round-less-than",
  lesserOrEqual: "ic:round-less-than-equal",
  different: "ic:round-not-equal",
  equal: "iconamoon:sign-equal-bold",
  none: "mdi:border-none-variant"
}, KA = uj.map((s) => ({
  type: s,
  icon: cj[s]
})), dj = ({
  closeModal: s,
  config: u,
  updateConfig: h,
  hidden: m,
  translationPrefix: w,
  translation: T
}) => {
  const [A, F] = fr(u), H = (j, V) => {
    F((q) => ({
      ...q,
      [j]: {
        ...q[j],
        ...V
      }
    }));
  };
  return /* @__PURE__ */ ce.jsxs(nj, { currentName: "table-config-modal", children: [
    /* @__PURE__ */ ce.jsx("div", { className: "table-config custom-scroll", children: Object.keys(A).map((j, V) => {
      if (m.includes(j))
        return null;
      const q = KA.findIndex(
        (ae) => ae.type === u[j].condition
      ), te = QA.findIndex(
        (ae) => ae === A[j].color
      );
      return /* @__PURE__ */ ce.jsxs(
        "div",
        {
          className: "container row row-selectable between-center" + (A[j].enabled ? "" : " row-disabled"),
          children: [
            /* @__PURE__ */ ce.jsxs("div", { className: "container row", style: { alignItems: "center" }, children: [
              /* @__PURE__ */ ce.jsx(
                "input",
                {
                  type: "checkbox",
                  name: j,
                  id: j,
                  checked: A[j].enabled,
                  className: "checkbox checkbox-base-200",
                  onChange: () => H(j, {
                    enabled: !A[j].enabled
                  })
                }
              ),
              /* @__PURE__ */ ce.jsx("label", { htmlFor: j, children: T ?? nr(
                `${w}.${T}.${j}`
              ) })
            ] }),
            /* @__PURE__ */ ce.jsx(
              Yy,
              {
                selected: q,
                selector: "type",
                style: { width: "24ch" },
                variant: "primary",
                keyExtractor: (ae) => /* @__PURE__ */ ce.jsxs("div", { className: "container row center", children: [
                  /* @__PURE__ */ ce.jsx(jR, { icon: ae.icon }),
                  /* @__PURE__ */ ce.jsx("span", { children: nr(`conditions.${ae.type}`) })
                ] }),
                items: KA,
                onChange: (ae, se) => {
                  H(j, {
                    condition: se == null ? void 0 : se.type
                  });
                },
                disabled: !A[j].enabled
              }
            ),
            /* @__PURE__ */ ce.jsx(
              "input",
              {
                type: "number",
                className: "input input-base-200",
                defaultValue: A[j].value,
                style: { color: "var(--text-content)" },
                placeholder: "Ex:. 200",
                onChange: (ae) => {
                  H(j, {
                    value: Number(ae.target.value)
                  });
                }
              }
            ),
            /* @__PURE__ */ ce.jsx(
              Yy,
              {
                selected: te,
                style: { width: "20ch" },
                variant: "neutral",
                items: QA,
                keyExtractor: (ae) => /* @__PURE__ */ ce.jsx(
                  "span",
                  {
                    style: {
                      position: "absolute",
                      width: "100%",
                      height: "100%",
                      top: 0,
                      left: 0,
                      backgroundColor: `var(--${ae})`
                    }
                  }
                ),
                onChange: (ae, se) => {
                  H(j, {
                    color: se
                  });
                },
                disabled: !A[j].enabled
              }
            )
          ]
        },
        V
      );
    }) }),
    /* @__PURE__ */ ce.jsx(
      "button",
      {
        className: "btn btn-primary ring-info",
        onClick: () => {
          h(A), s();
        },
        children: nr("common.save")
      }
    )
  ] });
}, JA = ({
  index: s,
  lastIndex: u,
  translation: h,
  translationPrefix: m,
  column: w,
  ordersType: T,
  orderedHeader: A,
  order: F,
  setOrder: H,
  tBodyRef: j,
  mousePosition: V
}) => /* @__PURE__ */ ce.jsx("th", { children: /* @__PURE__ */ ce.jsxs("div", { className: "table-column", children: [
  /* @__PURE__ */ ce.jsx("span", { children: h ?? nr(
    `${m}.${h}.${w}`
  ) }),
  /* @__PURE__ */ ce.jsxs("div", { className: "group-vertical rounded-box no-print", children: [
    /* @__PURE__ */ ce.jsx(
      "button",
      {
        className: `btn btn-square btn-xs ${T[F] === "asc" && A.current === w ? "active" : ""}`,
        onClick: () => {
          H(
            (q) => q === 1 && A.current === w ? 0 : 1
          ), A.current = w;
        },
        children: /* @__PURE__ */ ce.jsx(ma, { icon: "eva:arrow-up-fill" })
      }
    ),
    /* @__PURE__ */ ce.jsx(
      "button",
      {
        className: `btn btn-square btn-xs ${T[F] === "desc" && A.current === w ? "active" : ""}`,
        onClick: () => {
          H(
            (q) => q === 2 && A.current === w ? 0 : 2
          ), A.current = w;
        },
        children: /* @__PURE__ */ ce.jsx(ma, { icon: "eva:arrow-down-fill" })
      }
    )
  ] }),
  !u && /* @__PURE__ */ ce.jsxs(
    "button",
    {
      className: "handler",
      title: "Resize Column",
      onMouseDown: (q) => {
        V.current.startPosition = q.clientX;
      },
      onMouseMove: (q) => {
        var ue;
        if (j.current === null || V.current.startPosition === 0)
          return;
        V.current.currentPosition = q.clientX;
        const te = (ue = j.current.firstChild) == null ? void 0 : ue.childNodes[s];
        if (te === null)
          return;
        const ae = te.getBoundingClientRect().width, se = V.current.currentPosition - V.current.startPosition;
        te.style.width = `${ae + se}px`, V.current.startPosition = V.current.currentPosition;
      },
      onMouseUp: () => {
        V.current = {
          startPosition: 0,
          currentPosition: 0,
          endPosition: 0
        };
      },
      onMouseLeave: () => {
        V.current = {
          startPosition: 0,
          currentPosition: 0,
          endPosition: 0
        };
      },
      onClick: (q) => {
        var ae;
        if (q.detail < 2 || j.current === null)
          return;
        const te = (ae = j.current.firstChild) == null ? void 0 : ae.childNodes[s];
        te !== null && (te.style.width = "auto");
      },
      children: [
        /* @__PURE__ */ ce.jsx("span", {}),
        /* @__PURE__ */ ce.jsx("span", {})
      ]
    }
  )
] }) }), fj = (s, u, h = "asc") => {
  if (h === "default" || u === null)
    return s;
  const m = h === "asc" ? 1 : -1;
  return s.slice().sort((w, T) => {
    const A = w[u], F = T[u];
    return A < F ? -1 * m : A > F ? 1 * m : 0;
  });
}, hj = (s, u) => {
  const h = {};
  return s.length === 0 || (console.log("Current items: ", s, u), Object.keys(s[0]).forEach((m) => {
    u.includes(m) || (h[m] = {
      enabled: !1,
      color: "info",
      value: 0,
      condition: "none"
    });
  })), h;
}, pj = (s, u, h) => {
  let m = 0;
  if (typeof h == "object")
    (h == null ? void 0 : h.length) > -1 ? m = h.length : m = Object.keys(h).length;
  else if (typeof h == "string") {
    const w = Number(h);
    isNaN(w) ? m = 0 : m = w;
  }
  switch (s) {
    case "none":
      return !0;
    case "greater":
      return m > u;
    case "greaterOrEqual":
      return m >= u;
    case "lesser":
      return m < u;
    case "lesserOrEqual":
      return m <= u;
    case "equal":
      return m === u;
    case "different":
      return m !== u;
    default:
      throw new Error("Invalid condition type");
  }
}, e1 = ["default", "asc", "desc"], Qj = ({
  headers: s,
  data: u,
  dataConfig: h,
  tableConfig: m,
  showObject: w,
  noWrap: T = !0,
  // headersConfig,
  action: A,
  loading: F = !1,
  translation: H,
  translationPrefix: j = "data",
  hideColumn: V = [],
  mode: q = "pagination"
}) => {
  const { closeModal: te, openModal: ae } = XR(), [se] = fr(q), [ue, Ce] = fr(0), Pe = mr(null), K = mr(null), we = mr({
    startPosition: 0,
    currentPosition: 0,
    endPosition: 0
  }), [Ee, re] = fr(
    m === void 0 ? hj(u, V) : m
  ), [me, Me] = fr(""), Je = Du(() => F ? [] : u.filter((Xe) => {
    if (me.trim() === "")
      return u;
    const it = me.toLowerCase().trim();
    return Object.entries(Xe).some(([Ke, Ze]) => {
      var Tt;
      return V.includes(Ke) || Ze === null ? !1 : typeof Ze == "object" && Object.hasOwnProperty.call(h, Ke) ? String(
        (Tt = h == null ? void 0 : h[Ke]) == null ? void 0 : Tt.call(h, Ze, Xe)
      ).toLowerCase().includes(it) : typeof Ze == "object" ? String(Object.values(Ze)[0]).toLowerCase().includes(it) : String(Ze).toLowerCase().includes(it);
    });
  }), [me, V, u, h, F]), Ve = Du(() => fj(Je(), Pe.current, e1[ue]), [ue, Je, Pe]);
  return /* @__PURE__ */ ce.jsxs("div", { className: "table-full", children: [
    /* @__PURE__ */ ce.jsxs("div", { className: "group rounded-box no-print", children: [
      /* @__PURE__ */ ce.jsx("label", { className: "bg-primary", htmlFor: "find-all-table", children: nr("common.search") }),
      /* @__PURE__ */ ce.jsx(
        "input",
        {
          className: "input input-neutral ring-info",
          id: "find-all-table",
          placeholder: "Filtrar por....",
          style: { flex: "1" },
          onChange: j1((Xe) => {
            Me(Xe.target.value);
          }, 300)
        }
      ),
      /* @__PURE__ */ ce.jsx(
        "button",
        {
          className: "btn btn-primary btn-icon",
          style: { flex: "0" },
          onClick: () => ae("table-config-modal"),
          children: /* @__PURE__ */ ce.jsx(ma, { icon: "mdi:gear" })
        }
      )
    ] }),
    /* @__PURE__ */ ce.jsx(lj, { mode: se, data: Ve(), children: ({ data: Xe }) => {
      let it = 0;
      return /* @__PURE__ */ ce.jsxs("table", { className: "table", children: [
        /* @__PURE__ */ ce.jsx("thead", { className: T ? "no-wrap" : "", children: F || Xe.length === 0 ? null : /* @__PURE__ */ ce.jsxs("tr", { children: [
          s && s.map((ht, Ke) => /* @__PURE__ */ ce.jsx(
            JA,
            {
              tBodyRef: K,
              mousePosition: we,
              lastIndex: Object.keys(Xe[0]).length - V.length === Ke,
              orderedHeader: Pe,
              order: ue,
              setOrder: Ce,
              column: ht,
              index: it - 1,
              ordersType: e1,
              translation: H,
              translationPrefix: j
            },
            Ke
          )),
          s === void 0 && Xe.length > 0 && Object.keys(Xe[0]).map((ht, Ke) => V.includes(ht) ? null : (it++, /* @__PURE__ */ ce.jsx(
            JA,
            {
              tBodyRef: K,
              mousePosition: we,
              lastIndex: Object.keys(Xe[0]).length - V.length === Ke,
              orderedHeader: Pe,
              order: ue,
              setOrder: Ce,
              column: ht,
              index: it - 1,
              ordersType: e1,
              translation: H,
              translationPrefix: j
            },
            Ke
          ))),
          F && /* @__PURE__ */ ce.jsx("th", {}),
          A && /* @__PURE__ */ ce.jsx("th", { children: nr("common.action") })
        ] }) }),
        /* @__PURE__ */ ce.jsxs("tbody", { ref: K, children: [
          F && /* @__PURE__ */ ce.jsxs(
            "span",
            {
              className: "subtitle",
              style: {
                margin: "auto",
                marginTop: "1rem",
                width: "fit-content"
              },
              children: [
                nr("common.loading"),
                "..."
              ]
            }
          ),
          !F && Xe.map((ht, Ke) => /* @__PURE__ */ ce.jsxs("tr", { tabIndex: 0, children: [
            Object.entries(ht).map(([Ze, Tt], It) => {
              var pt, ye, je, Qe;
              let Jt;
              if (V.includes(Ze))
                return null;
              const We = ((pt = Ee[Ze]) == null ? void 0 : pt.enabled) && pj(
                (ye = Ee[Ze]) == null ? void 0 : ye.condition,
                (je = Ee[Ze]) == null ? void 0 : je.value,
                Tt
              );
              return typeof Tt == "object" && (h == null ? void 0 : h[Ze]) === void 0 ? Tt != null && Tt.length ? Jt = Tt.length : Tt === null ? Jt = 0 : Jt = Object.values(Tt)[0] : Object.hasOwnProperty.call(h ?? {}, Ze) ? Jt = (Qe = h == null ? void 0 : h[Ze]) == null ? void 0 : Qe.call(
                h,
                Tt,
                ht
              ) : Jt = Tt, /* @__PURE__ */ ce.jsx(
                "td",
                {
                  title: "Click to copy",
                  style: { width: "auto" },
                  children: typeof Tt != "object" || !w ? We ? /* @__PURE__ */ ce.jsx(
                    "span",
                    {
                      className: "btn btn-xs no-bounce",
                      style: {
                        backgroundColor: `var(--${Ee[Ze].color})`,
                        width: "fit-content",
                        marginInline: "auto",
                        cursor: "unset"
                      },
                      children: Jt
                    }
                  ) : Jt : /* @__PURE__ */ ce.jsx("div", { className: "cell-container", children: /* @__PURE__ */ ce.jsxs("div", { className: "cell-container--header", children: [
                    Jt,
                    /* @__PURE__ */ ce.jsx(
                      "button",
                      {
                        className: "btn btn-primary btn-icon btn-xs btn-square",
                        onClick: (kt) => {
                          var st;
                          const mt = (st = kt.currentTarget.parentNode) == null ? void 0 : st.parentNode;
                          if (mt === null)
                            return;
                          if (mt.lastChild.className === "content") {
                            mt.removeChild(
                              mt.lastChild
                            );
                            return;
                          }
                          const Pt = document.createElement("ul");
                          Pt.className = "content", Object.entries(Tt).forEach(
                            ([Nt, Et]) => {
                              const Ht = document.createElement("li");
                              Ht.innerText = `${H ?? nr(
                                `data.${H}.${Nt}`
                              )}: ${Et}`, Pt.appendChild(Ht);
                            }
                          ), mt.appendChild(
                            Pt
                          );
                        },
                        children: /* @__PURE__ */ ce.jsx(ma, { icon: "eva:arrow-down-fill" })
                      }
                    )
                  ] }) })
                },
                It
              );
            }),
            A && A(ht, Ke)
          ] }, Ke))
        ] })
      ] });
    } }),
    !F && u.length > 0 && /* @__PURE__ */ ce.jsx(
      dj,
      {
        translation: H,
        translationPrefix: j,
        config: Ee,
        updateConfig: re,
        closeModal: te,
        hidden: V
      }
    )
  ] });
}, gj = {
  small: "4rem",
  medium: "6rem",
  large: "8rem"
}, Kj = WR(
  UR(
    {
      currentOpen: []
    },
    () => ({
      dispatch: (s) => {
        const u = document.querySelector("#toast-root"), h = document.createElement("div");
        h.className = "toast";
        const m = document.createElement("div");
        m.className = `toast-body shadow-md container rounded-box bg-${(s == null ? void 0 : s.variant) ?? "neutral"}`, h.append(m), h.style.setProperty(
          "--toast-size",
          `${gj[(s == null ? void 0 : s.size) ?? "small"]}`
        );
        const w = document.createElement("span");
        w.innerText = s.message;
        const T = document.createElement("button");
        T.className = "close-btn", T.innerText = "x", T.addEventListener("click", () => {
          h.classList.add("closed"), setTimeout(() => {
            h.remove();
          }, 200);
        });
        const A = document.createElement("div");
        A.className = "fill-bar", A.style.setProperty(
          "--fill-color",
          `var(--${(s == null ? void 0 : s.type) ?? "info"})`
        ), setTimeout(() => {
          h.classList.add("closed");
        }, 2.8 * 1e3), setTimeout(() => {
          h.remove();
        }, 3 * 1e3), m.append(w, T, A), u == null || u.appendChild(h);
      }
    })
  )
), Jj = hE, eB = fP;
var VR = {}, D1 = { exports: {} };
/*!
 * ApexCharts v3.42.0
 * (c) 2018-2023 ApexCharts
 * Released under the MIT License.
 */
(function(s, u) {
  function h(W, t) {
    var n = Object.keys(W);
    if (Object.getOwnPropertySymbols) {
      var a = Object.getOwnPropertySymbols(W);
      t && (a = a.filter(function(o) {
        return Object.getOwnPropertyDescriptor(W, o).enumerable;
      })), n.push.apply(n, a);
    }
    return n;
  }
  function m(W) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t] != null ? arguments[t] : {};
      t % 2 ? h(Object(n), !0).forEach(function(a) {
        H(W, a, n[a]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(W, Object.getOwnPropertyDescriptors(n)) : h(Object(n)).forEach(function(a) {
        Object.defineProperty(W, a, Object.getOwnPropertyDescriptor(n, a));
      });
    }
    return W;
  }
  function w(W) {
    return w = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t;
    } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, w(W);
  }
  function T(W, t) {
    if (!(W instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  function A(W, t) {
    for (var n = 0; n < t.length; n++) {
      var a = t[n];
      a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(W, a.key, a);
    }
  }
  function F(W, t, n) {
    return t && A(W.prototype, t), n && A(W, n), W;
  }
  function H(W, t, n) {
    return t in W ? Object.defineProperty(W, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : W[t] = n, W;
  }
  function j(W, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    W.prototype = Object.create(t && t.prototype, { constructor: { value: W, writable: !0, configurable: !0 } }), t && q(W, t);
  }
  function V(W) {
    return V = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, V(W);
  }
  function q(W, t) {
    return q = Object.setPrototypeOf || function(n, a) {
      return n.__proto__ = a, n;
    }, q(W, t);
  }
  function te(W, t) {
    if (t && (typeof t == "object" || typeof t == "function"))
      return t;
    if (t !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return function(n) {
      if (n === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return n;
    }(W);
  }
  function ae(W) {
    var t = function() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }();
    return function() {
      var n, a = V(W);
      if (t) {
        var o = V(this).constructor;
        n = Reflect.construct(a, arguments, o);
      } else
        n = a.apply(this, arguments);
      return te(this, n);
    };
  }
  function se(W, t) {
    return function(n) {
      if (Array.isArray(n))
        return n;
    }(W) || function(n, a) {
      var o = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
      if (o != null) {
        var d, f, p = [], y = !0, S = !1;
        try {
          for (o = o.call(n); !(y = (d = o.next()).done) && (p.push(d.value), !a || p.length !== a); y = !0)
            ;
        } catch (C) {
          S = !0, f = C;
        } finally {
          try {
            y || o.return == null || o.return();
          } finally {
            if (S)
              throw f;
          }
        }
        return p;
      }
    }(W, t) || Ce(W, t) || function() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }();
  }
  function ue(W) {
    return function(t) {
      if (Array.isArray(t))
        return Pe(t);
    }(W) || function(t) {
      if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
        return Array.from(t);
    }(W) || Ce(W) || function() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }();
  }
  function Ce(W, t) {
    if (W) {
      if (typeof W == "string")
        return Pe(W, t);
      var n = Object.prototype.toString.call(W).slice(8, -1);
      return n === "Object" && W.constructor && (n = W.constructor.name), n === "Map" || n === "Set" ? Array.from(W) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Pe(W, t) : void 0;
    }
  }
  function Pe(W, t) {
    (t == null || t > W.length) && (t = W.length);
    for (var n = 0, a = new Array(t); n < t; n++)
      a[n] = W[n];
    return a;
  }
  var K = function() {
    function W() {
      T(this, W);
    }
    return F(W, [{ key: "shadeRGBColor", value: function(t, n) {
      var a = n.split(","), o = t < 0 ? 0 : 255, d = t < 0 ? -1 * t : t, f = parseInt(a[0].slice(4), 10), p = parseInt(a[1], 10), y = parseInt(a[2], 10);
      return "rgb(" + (Math.round((o - f) * d) + f) + "," + (Math.round((o - p) * d) + p) + "," + (Math.round((o - y) * d) + y) + ")";
    } }, { key: "shadeHexColor", value: function(t, n) {
      var a = parseInt(n.slice(1), 16), o = t < 0 ? 0 : 255, d = t < 0 ? -1 * t : t, f = a >> 16, p = a >> 8 & 255, y = 255 & a;
      return "#" + (16777216 + 65536 * (Math.round((o - f) * d) + f) + 256 * (Math.round((o - p) * d) + p) + (Math.round((o - y) * d) + y)).toString(16).slice(1);
    } }, { key: "shadeColor", value: function(t, n) {
      return W.isColorHex(n) ? this.shadeHexColor(t, n) : this.shadeRGBColor(t, n);
    } }], [{ key: "bind", value: function(t, n) {
      return function() {
        return t.apply(n, arguments);
      };
    } }, { key: "isObject", value: function(t) {
      return t && w(t) === "object" && !Array.isArray(t) && t != null;
    } }, { key: "is", value: function(t, n) {
      return Object.prototype.toString.call(n) === "[object " + t + "]";
    } }, { key: "listToArray", value: function(t) {
      var n, a = [];
      for (n = 0; n < t.length; n++)
        a[n] = t[n];
      return a;
    } }, { key: "extend", value: function(t, n) {
      var a = this;
      typeof Object.assign != "function" && (Object.assign = function(d) {
        if (d == null)
          throw new TypeError("Cannot convert undefined or null to object");
        for (var f = Object(d), p = 1; p < arguments.length; p++) {
          var y = arguments[p];
          if (y != null)
            for (var S in y)
              y.hasOwnProperty(S) && (f[S] = y[S]);
        }
        return f;
      });
      var o = Object.assign({}, t);
      return this.isObject(t) && this.isObject(n) && Object.keys(n).forEach(function(d) {
        a.isObject(n[d]) && d in t ? o[d] = a.extend(t[d], n[d]) : Object.assign(o, H({}, d, n[d]));
      }), o;
    } }, { key: "extendArray", value: function(t, n) {
      var a = [];
      return t.map(function(o) {
        a.push(W.extend(n, o));
      }), t = a;
    } }, { key: "monthMod", value: function(t) {
      return t % 12;
    } }, { key: "clone", value: function(t) {
      if (W.is("Array", t)) {
        for (var n = [], a = 0; a < t.length; a++)
          n[a] = this.clone(t[a]);
        return n;
      }
      if (W.is("Null", t))
        return null;
      if (W.is("Date", t))
        return t;
      if (w(t) === "object") {
        var o = {};
        for (var d in t)
          t.hasOwnProperty(d) && (o[d] = this.clone(t[d]));
        return o;
      }
      return t;
    } }, { key: "log10", value: function(t) {
      return Math.log(t) / Math.LN10;
    } }, { key: "roundToBase10", value: function(t) {
      return Math.pow(10, Math.floor(Math.log10(t)));
    } }, { key: "roundToBase", value: function(t, n) {
      return Math.pow(n, Math.floor(Math.log(t) / Math.log(n)));
    } }, { key: "parseNumber", value: function(t) {
      return t === null ? t : parseFloat(t);
    } }, { key: "stripNumber", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
      return parseFloat(t.toPrecision(n));
    } }, { key: "randomId", value: function() {
      return (Math.random() + 1).toString(36).substring(4);
    } }, { key: "noExponents", value: function(t) {
      var n = String(t).split(/[eE]/);
      if (n.length === 1)
        return n[0];
      var a = "", o = t < 0 ? "-" : "", d = n[0].replace(".", ""), f = Number(n[1]) + 1;
      if (f < 0) {
        for (a = o + "0."; f++; )
          a += "0";
        return a + d.replace(/^-/, "");
      }
      for (f -= d.length; f--; )
        a += "0";
      return d + a;
    } }, { key: "getDimensions", value: function(t) {
      var n = getComputedStyle(t, null), a = t.clientHeight, o = t.clientWidth;
      return a -= parseFloat(n.paddingTop) + parseFloat(n.paddingBottom), [o -= parseFloat(n.paddingLeft) + parseFloat(n.paddingRight), a];
    } }, { key: "getBoundingClientRect", value: function(t) {
      var n = t.getBoundingClientRect();
      return { top: n.top, right: n.right, bottom: n.bottom, left: n.left, width: t.clientWidth, height: t.clientHeight, x: n.left, y: n.top };
    } }, { key: "getLargestStringFromArr", value: function(t) {
      return t.reduce(function(n, a) {
        return Array.isArray(a) && (a = a.reduce(function(o, d) {
          return o.length > d.length ? o : d;
        })), n.length > a.length ? n : a;
      }, 0);
    } }, { key: "hexToRgba", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "#999999", n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.6;
      t.substring(0, 1) !== "#" && (t = "#999999");
      var a = t.replace("#", "");
      a = a.match(new RegExp("(.{" + a.length / 3 + "})", "g"));
      for (var o = 0; o < a.length; o++)
        a[o] = parseInt(a[o].length === 1 ? a[o] + a[o] : a[o], 16);
      return n !== void 0 && a.push(n), "rgba(" + a.join(",") + ")";
    } }, { key: "getOpacityFromRGBA", value: function(t) {
      return parseFloat(t.replace(/^.*,(.+)\)/, "$1"));
    } }, { key: "rgb2hex", value: function(t) {
      return (t = t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && t.length === 4 ? "#" + ("0" + parseInt(t[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t[3], 10).toString(16)).slice(-2) : "";
    } }, { key: "isColorHex", value: function(t) {
      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t);
    } }, { key: "getPolygonPos", value: function(t, n) {
      for (var a = [], o = 2 * Math.PI / n, d = 0; d < n; d++) {
        var f = {};
        f.x = t * Math.sin(d * o), f.y = -t * Math.cos(d * o), a.push(f);
      }
      return a;
    } }, { key: "polarToCartesian", value: function(t, n, a, o) {
      var d = (o - 90) * Math.PI / 180;
      return { x: t + a * Math.cos(d), y: n + a * Math.sin(d) };
    } }, { key: "escapeString", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x", a = t.toString().slice();
      return a = a.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, n);
    } }, { key: "negToZero", value: function(t) {
      return t < 0 ? 0 : t;
    } }, { key: "moveIndexInArray", value: function(t, n, a) {
      if (a >= t.length)
        for (var o = a - t.length + 1; o--; )
          t.push(void 0);
      return t.splice(a, 0, t.splice(n, 1)[0]), t;
    } }, { key: "extractNumber", value: function(t) {
      return parseFloat(t.replace(/[^\d.]*/g, ""));
    } }, { key: "findAncestor", value: function(t, n) {
      for (; (t = t.parentElement) && !t.classList.contains(n); )
        ;
      return t;
    } }, { key: "setELstyles", value: function(t, n) {
      for (var a in n)
        n.hasOwnProperty(a) && (t.style.key = n[a]);
    } }, { key: "isNumber", value: function(t) {
      return !isNaN(t) && parseFloat(Number(t)) === t && !isNaN(parseInt(t, 10));
    } }, { key: "isFloat", value: function(t) {
      return Number(t) === t && t % 1 != 0;
    } }, { key: "isSafari", value: function() {
      return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    } }, { key: "isFirefox", value: function() {
      return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
    } }, { key: "isIE11", value: function() {
      if (window.navigator.userAgent.indexOf("MSIE") !== -1 || window.navigator.appVersion.indexOf("Trident/") > -1)
        return !0;
    } }, { key: "isIE", value: function() {
      var t = window.navigator.userAgent, n = t.indexOf("MSIE ");
      if (n > 0)
        return parseInt(t.substring(n + 5, t.indexOf(".", n)), 10);
      if (t.indexOf("Trident/") > 0) {
        var a = t.indexOf("rv:");
        return parseInt(t.substring(a + 3, t.indexOf(".", a)), 10);
      }
      var o = t.indexOf("Edge/");
      return o > 0 && parseInt(t.substring(o + 5, t.indexOf(".", o)), 10);
    } }]), W;
  }(), we = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w, this.setEasingFunctions();
    }
    return F(W, [{ key: "setEasingFunctions", value: function() {
      var t;
      if (!this.w.globals.easing) {
        switch (this.w.config.chart.animations.easing) {
          case "linear":
            t = "-";
            break;
          case "easein":
            t = "<";
            break;
          case "easeout":
            t = ">";
            break;
          case "easeinout":
          default:
            t = "<>";
            break;
          case "swing":
            t = function(n) {
              var a = 1.70158;
              return (n -= 1) * n * ((a + 1) * n + a) + 1;
            };
            break;
          case "bounce":
            t = function(n) {
              return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375;
            };
            break;
          case "elastic":
            t = function(n) {
              return n === !!n ? n : Math.pow(2, -10 * n) * Math.sin((n - 0.075) * (2 * Math.PI) / 0.3) + 1;
            };
        }
        this.w.globals.easing = t;
      }
    } }, { key: "animateLine", value: function(t, n, a, o) {
      t.attr(n).animate(o).attr(a);
    } }, { key: "animateMarker", value: function(t, n, a, o, d, f) {
      n || (n = 0), t.attr({ r: n, width: n, height: n }).animate(o, d).attr({ r: a, width: a.width, height: a.height }).afterAll(function() {
        f();
      });
    } }, { key: "animateCircle", value: function(t, n, a, o, d) {
      t.attr({ r: n.r, cx: n.cx, cy: n.cy }).animate(o, d).attr({ r: a.r, cx: a.cx, cy: a.cy });
    } }, { key: "animateRect", value: function(t, n, a, o, d) {
      t.attr(n).animate(o).attr(a).afterAll(function() {
        return d();
      });
    } }, { key: "animatePathsGradually", value: function(t) {
      var n = t.el, a = t.realIndex, o = t.j, d = t.fill, f = t.pathFrom, p = t.pathTo, y = t.speed, S = t.delay, C = this.w, E = 0;
      C.config.chart.animations.animateGradually.enabled && (E = C.config.chart.animations.animateGradually.delay), C.config.chart.animations.dynamicAnimation.enabled && C.globals.dataChanged && C.config.chart.type !== "bar" && (E = 0), this.morphSVG(n, a, o, C.config.chart.type !== "line" || C.globals.comboCharts ? d : "stroke", f, p, y, S * E);
    } }, { key: "showDelayedElements", value: function() {
      this.w.globals.delayedElements.forEach(function(t) {
        var n = t.el;
        n.classList.remove("apexcharts-element-hidden"), n.classList.add("apexcharts-hidden-element-shown");
      });
    } }, { key: "animationCompleted", value: function(t) {
      var n = this.w;
      n.globals.animationEnded || (n.globals.animationEnded = !0, this.showDelayedElements(), typeof n.config.chart.events.animationEnd == "function" && n.config.chart.events.animationEnd(this.ctx, { el: t, w: n }));
    } }, { key: "morphSVG", value: function(t, n, a, o, d, f, p, y) {
      var S = this, C = this.w;
      d || (d = t.attr("pathFrom")), f || (f = t.attr("pathTo"));
      var E = function(L) {
        return C.config.chart.type === "radar" && (p = 1), "M 0 ".concat(C.globals.gridHeight);
      };
      (!d || d.indexOf("undefined") > -1 || d.indexOf("NaN") > -1) && (d = E()), (!f || f.indexOf("undefined") > -1 || f.indexOf("NaN") > -1) && (f = E()), C.globals.shouldAnimate || (p = 1), t.plot(d).animate(1, C.globals.easing, y).plot(d).animate(p, C.globals.easing, y).plot(f).afterAll(function() {
        K.isNumber(a) ? a === C.globals.series[C.globals.maxValsInArrayIndex].length - 2 && C.globals.shouldAnimate && S.animationCompleted(t) : o !== "none" && C.globals.shouldAnimate && (!C.globals.comboCharts && n === C.globals.series.length - 1 || C.globals.comboCharts) && S.animationCompleted(t), S.showDelayedElements();
      });
    } }]), W;
  }(), Ee = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "getDefaultFilter", value: function(t, n) {
      var a = this.w;
      t.unfilter(!0), new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"), a.config.states.normal.filter !== "none" ? this.applyFilter(t, n, a.config.states.normal.filter.type, a.config.states.normal.filter.value) : a.config.chart.dropShadow.enabled && this.dropShadow(t, a.config.chart.dropShadow, n);
    } }, { key: "addNormalFilter", value: function(t, n) {
      var a = this.w;
      a.config.chart.dropShadow.enabled && !t.node.classList.contains("apexcharts-marker") && this.dropShadow(t, a.config.chart.dropShadow, n);
    } }, { key: "addLightenFilter", value: function(t, n, a) {
      var o = this, d = this.w, f = a.intensity;
      t.unfilter(!0), new window.SVG.Filter(), t.filter(function(p) {
        var y = d.config.chart.dropShadow;
        (y.enabled ? o.addShadow(p, n, y) : p).componentTransfer({ rgb: { type: "linear", slope: 1.5, intercept: f } });
      }), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node);
    } }, { key: "addDarkenFilter", value: function(t, n, a) {
      var o = this, d = this.w, f = a.intensity;
      t.unfilter(!0), new window.SVG.Filter(), t.filter(function(p) {
        var y = d.config.chart.dropShadow;
        (y.enabled ? o.addShadow(p, n, y) : p).componentTransfer({ rgb: { type: "linear", slope: f } });
      }), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node);
    } }, { key: "applyFilter", value: function(t, n, a) {
      var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.5;
      switch (a) {
        case "none":
          this.addNormalFilter(t, n);
          break;
        case "lighten":
          this.addLightenFilter(t, n, { intensity: o });
          break;
        case "darken":
          this.addDarkenFilter(t, n, { intensity: o });
      }
    } }, { key: "addShadow", value: function(t, n, a) {
      var o = a.blur, d = a.top, f = a.left, p = a.color, y = a.opacity, S = t.flood(Array.isArray(p) ? p[n] : p, y).composite(t.sourceAlpha, "in").offset(f, d).gaussianBlur(o).merge(t.source);
      return t.blend(t.source, S);
    } }, { key: "dropShadow", value: function(t, n) {
      var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, o = n.top, d = n.left, f = n.blur, p = n.color, y = n.opacity, S = n.noUserSpaceOnUse, C = this.w;
      return t.unfilter(!0), K.isIE() && C.config.chart.type === "radialBar" || (p = Array.isArray(p) ? p[a] : p, t.filter(function(E) {
        var L = null;
        L = K.isSafari() || K.isFirefox() || K.isIE() ? E.flood(p, y).composite(E.sourceAlpha, "in").offset(d, o).gaussianBlur(f) : E.flood(p, y).composite(E.sourceAlpha, "in").offset(d, o).gaussianBlur(f).merge(E.source), E.blend(E.source, L);
      }), S || t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)), t;
    } }, { key: "setSelectionFilter", value: function(t, n, a) {
      var o = this.w;
      if (o.globals.selectedDataPoints[n] !== void 0 && o.globals.selectedDataPoints[n].indexOf(a) > -1) {
        t.node.setAttribute("selected", !0);
        var d = o.config.states.active.filter;
        d !== "none" && this.applyFilter(t, n, d.type, d.value);
      }
    } }, { key: "_scaleFilterSize", value: function(t) {
      (function(n) {
        for (var a in n)
          n.hasOwnProperty(a) && t.setAttribute(a, n[a]);
      })({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
    } }]), W;
  }(), re = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "roundPathCorners", value: function(t, n) {
      function a(ee, oe, fe) {
        var ke = oe.x - ee.x, _e = oe.y - ee.y, Le = Math.sqrt(ke * ke + _e * _e);
        return o(ee, oe, Math.min(1, fe / Le));
      }
      function o(ee, oe, fe) {
        return { x: ee.x + (oe.x - ee.x) * fe, y: ee.y + (oe.y - ee.y) * fe };
      }
      function d(ee, oe) {
        ee.length > 2 && (ee[ee.length - 2] = oe.x, ee[ee.length - 1] = oe.y);
      }
      function f(ee) {
        return { x: parseFloat(ee[ee.length - 2]), y: parseFloat(ee[ee.length - 1]) };
      }
      t.indexOf("NaN") > -1 && (t = "");
      var p = t.split(/[,\s]/).reduce(function(ee, oe) {
        var fe = oe.match("([a-zA-Z])(.+)");
        return fe ? (ee.push(fe[1]), ee.push(fe[2])) : ee.push(oe), ee;
      }, []).reduce(function(ee, oe) {
        return parseFloat(oe) == oe && ee.length ? ee[ee.length - 1].push(oe) : ee.push([oe]), ee;
      }, []), y = [];
      if (p.length > 1) {
        var S = f(p[0]), C = null;
        p[p.length - 1][0] == "Z" && p[0].length > 2 && (C = ["L", S.x, S.y], p[p.length - 1] = C), y.push(p[0]);
        for (var E = 1; E < p.length; E++) {
          var L = y[y.length - 1], M = p[E], P = M == C ? p[1] : p[E + 1];
          if (P && L && L.length > 2 && M[0] == "L" && P.length > 2 && P[0] == "L") {
            var I, B, G = f(L), Z = f(M), b = f(P);
            I = a(Z, G, n), B = a(Z, b, n), d(M, I), M.origPoint = Z, y.push(M);
            var O = o(I, Z, 0.5), N = o(Z, B, 0.5), X = ["C", O.x, O.y, N.x, N.y, B.x, B.y];
            X.origPoint = Z, y.push(X);
          } else
            y.push(M);
        }
        if (C) {
          var Q = f(y[y.length - 1]);
          y.push(["Z"]), d(y[0], Q);
        }
      } else
        y = p;
      return y.reduce(function(ee, oe) {
        return ee + oe.join(" ") + " ";
      }, "");
    } }, { key: "drawLine", value: function(t, n, a, o) {
      var d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "#a8a8a8", f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0, p = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, y = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "butt";
      return this.w.globals.dom.Paper.line().attr({ x1: t, y1: n, x2: a, y2: o, stroke: d, "stroke-dasharray": f, "stroke-width": p, "stroke-linecap": y });
    } }, { key: "drawRect", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "#fefefe", p = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1, y = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null, S = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : null, C = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 0, E = this.w.globals.dom.Paper.rect();
      return E.attr({ x: t, y: n, width: a > 0 ? a : 0, height: o > 0 ? o : 0, rx: d, ry: d, opacity: p, "stroke-width": y !== null ? y : 0, stroke: S !== null ? S : "none", "stroke-dasharray": C }), E.node.setAttribute("fill", f), E;
    } }, { key: "drawPolygon", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "#e1e1e1", a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "none";
      return this.w.globals.dom.Paper.polygon(t).attr({ fill: o, stroke: n, "stroke-width": a });
    } }, { key: "drawCircle", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      t < 0 && (t = 0);
      var a = this.w.globals.dom.Paper.circle(2 * t);
      return n !== null && a.attr(n), a;
    } }, { key: "drawPath", value: function(t) {
      var n = t.d, a = n === void 0 ? "" : n, o = t.stroke, d = o === void 0 ? "#a8a8a8" : o, f = t.strokeWidth, p = f === void 0 ? 1 : f, y = t.fill, S = t.fillOpacity, C = S === void 0 ? 1 : S, E = t.strokeOpacity, L = E === void 0 ? 1 : E, M = t.classes, P = t.strokeLinecap, I = P === void 0 ? null : P, B = t.strokeDashArray, G = B === void 0 ? 0 : B, Z = this.w;
      return I === null && (I = Z.config.stroke.lineCap), (a.indexOf("undefined") > -1 || a.indexOf("NaN") > -1) && (a = "M 0 ".concat(Z.globals.gridHeight)), Z.globals.dom.Paper.path(a).attr({ fill: y, "fill-opacity": C, stroke: d, "stroke-opacity": L, "stroke-linecap": I, "stroke-width": p, "stroke-dasharray": G, class: M });
    } }, { key: "group", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, n = this.w.globals.dom.Paper.group();
      return t !== null && n.attr(t), n;
    } }, { key: "move", value: function(t, n) {
      var a = ["M", t, n].join(" ");
      return a;
    } }, { key: "line", value: function(t, n) {
      var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, o = null;
      return a === null ? o = [" L", t, n].join(" ") : a === "H" ? o = [" H", t].join(" ") : a === "V" && (o = [" V", n].join(" ")), o;
    } }, { key: "curve", value: function(t, n, a, o, d, f) {
      var p = ["C", t, n, a, o, d, f].join(" ");
      return p;
    } }, { key: "quadraticCurve", value: function(t, n, a, o) {
      return ["Q", t, n, a, o].join(" ");
    } }, { key: "arc", value: function(t, n, a, o, d, f, p) {
      var y = "A";
      arguments.length > 7 && arguments[7] !== void 0 && arguments[7] && (y = "a");
      var S = [y, t, n, a, o, d, f, p].join(" ");
      return S;
    } }, { key: "renderPaths", value: function(t) {
      var n, a = t.j, o = t.realIndex, d = t.pathFrom, f = t.pathTo, p = t.stroke, y = t.strokeWidth, S = t.strokeLinecap, C = t.fill, E = t.animationDelay, L = t.initialSpeed, M = t.dataChangeSpeed, P = t.className, I = t.shouldClipToGrid, B = I === void 0 || I, G = t.bindEventsOnPaths, Z = G === void 0 || G, b = t.drawShadow, O = b === void 0 || b, N = this.w, X = new Ee(this.ctx), Q = new we(this.ctx), ee = this.w.config.chart.animations.enabled, oe = ee && this.w.config.chart.animations.dynamicAnimation.enabled, fe = !!(ee && !N.globals.resized || oe && N.globals.dataChanged && N.globals.shouldAnimate);
      fe ? n = d : (n = f, N.globals.animationEnded = !0);
      var ke = N.config.stroke.dashArray, _e = 0;
      _e = Array.isArray(ke) ? ke[o] : N.config.stroke.dashArray;
      var Le = this.drawPath({ d: n, stroke: p, strokeWidth: y, fill: C, fillOpacity: 1, classes: P, strokeLinecap: S, strokeDashArray: _e });
      if (Le.attr("index", o), B && Le.attr({ "clip-path": "url(#gridRectMask".concat(N.globals.cuid, ")") }), N.config.states.normal.filter.type !== "none")
        X.getDefaultFilter(Le, o);
      else if (N.config.chart.dropShadow.enabled && O && (!N.config.chart.dropShadow.enabledOnSeries || N.config.chart.dropShadow.enabledOnSeries && N.config.chart.dropShadow.enabledOnSeries.indexOf(o) !== -1)) {
        var Ie = N.config.chart.dropShadow;
        X.dropShadow(Le, Ie, o);
      }
      Z && (Le.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, Le)), Le.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, Le)), Le.node.addEventListener("mousedown", this.pathMouseDown.bind(this, Le))), Le.attr({ pathTo: f, pathFrom: d });
      var at = { el: Le, j: a, realIndex: o, pathFrom: d, pathTo: f, fill: C, strokeWidth: y, delay: E };
      return !ee || N.globals.resized || N.globals.dataChanged ? !N.globals.resized && N.globals.dataChanged || Q.showDelayedElements() : Q.animatePathsGradually(m(m({}, at), {}, { speed: L })), N.globals.dataChanged && oe && fe && Q.animatePathsGradually(m(m({}, at), {}, { speed: M })), Le;
    } }, { key: "drawPattern", value: function(t, n, a) {
      var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "#a8a8a8", d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
      return this.w.globals.dom.Paper.pattern(n, a, function(f) {
        t === "horizontalLines" ? f.line(0, 0, a, 0).stroke({ color: o, width: d + 1 }) : t === "verticalLines" ? f.line(0, 0, 0, n).stroke({ color: o, width: d + 1 }) : t === "slantedLines" ? f.line(0, 0, n, a).stroke({ color: o, width: d }) : t === "squares" ? f.rect(n, a).fill("none").stroke({ color: o, width: d }) : t === "circles" && f.circle(n).fill("none").stroke({ color: o, width: d });
      });
    } }, { key: "drawGradient", value: function(t, n, a, o, d) {
      var f, p = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, y = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, S = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null, C = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 0, E = this.w;
      n.length < 9 && n.indexOf("#") === 0 && (n = K.hexToRgba(n, o)), a.length < 9 && a.indexOf("#") === 0 && (a = K.hexToRgba(a, d));
      var L = 0, M = 1, P = 1, I = null;
      y !== null && (L = y[0] !== void 0 ? y[0] / 100 : 0, M = y[1] !== void 0 ? y[1] / 100 : 1, P = y[2] !== void 0 ? y[2] / 100 : 1, I = y[3] !== void 0 ? y[3] / 100 : null);
      var B = !(E.config.chart.type !== "donut" && E.config.chart.type !== "pie" && E.config.chart.type !== "polarArea" && E.config.chart.type !== "bubble");
      if (f = S === null || S.length === 0 ? E.globals.dom.Paper.gradient(B ? "radial" : "linear", function(b) {
        b.at(L, n, o), b.at(M, a, d), b.at(P, a, d), I !== null && b.at(I, n, o);
      }) : E.globals.dom.Paper.gradient(B ? "radial" : "linear", function(b) {
        (Array.isArray(S[C]) ? S[C] : S).forEach(function(O) {
          b.at(O.offset / 100, O.color, O.opacity);
        });
      }), B) {
        var G = E.globals.gridWidth / 2, Z = E.globals.gridHeight / 2;
        E.config.chart.type !== "bubble" ? f.attr({ gradientUnits: "userSpaceOnUse", cx: G, cy: Z, r: p }) : f.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
      } else
        t === "vertical" ? f.from(0, 0).to(0, 1) : t === "diagonal" ? f.from(0, 0).to(1, 1) : t === "horizontal" ? f.from(0, 1).to(1, 1) : t === "diagonal2" && f.from(1, 0).to(0, 1);
      return f;
    } }, { key: "getTextBasedOnMaxWidth", value: function(t) {
      var n = t.text, a = t.maxWidth, o = t.fontSize, d = t.fontFamily, f = this.getTextRects(n, o, d), p = f.width / n.length, y = Math.floor(a / p);
      return a < f.width ? n.slice(0, y - 3) + "..." : n;
    } }, { key: "drawText", value: function(t) {
      var n = this, a = t.x, o = t.y, d = t.text, f = t.textAnchor, p = t.fontSize, y = t.fontFamily, S = t.fontWeight, C = t.foreColor, E = t.opacity, L = t.maxWidth, M = t.cssClass, P = M === void 0 ? "" : M, I = t.isPlainText, B = I === void 0 || I, G = this.w;
      d === void 0 && (d = "");
      var Z = d;
      f || (f = "start"), C && C.length || (C = G.config.chart.foreColor), y = y || G.config.chart.fontFamily, S = S || "regular";
      var b, O = { maxWidth: L, fontSize: p = p || "11px", fontFamily: y };
      return Array.isArray(d) ? b = G.globals.dom.Paper.text(function(N) {
        for (var X = 0; X < d.length; X++)
          Z = d[X], L && (Z = n.getTextBasedOnMaxWidth(m({ text: d[X] }, O))), X === 0 ? N.tspan(Z) : N.tspan(Z).newLine();
      }) : (L && (Z = this.getTextBasedOnMaxWidth(m({ text: d }, O))), b = B ? G.globals.dom.Paper.plain(d) : G.globals.dom.Paper.text(function(N) {
        return N.tspan(Z);
      })), b.attr({ x: a, y: o, "text-anchor": f, "dominant-baseline": "auto", "font-size": p, "font-family": y, "font-weight": S, fill: C, class: "apexcharts-text " + P }), b.node.style.fontFamily = y, b.node.style.opacity = E, b;
    } }, { key: "drawMarker", value: function(t, n, a) {
      t = t || 0;
      var o = a.pSize || 0, d = null;
      if (a.shape === "square" || a.shape === "rect") {
        var f = a.pRadius === void 0 ? o / 2 : a.pRadius;
        n !== null && o || (o = 0, f = 0);
        var p = 1.2 * o + f, y = this.drawRect(p, p, p, p, f);
        y.attr({ x: t - p / 2, y: n - p / 2, cx: t, cy: n, class: a.class ? a.class : "", fill: a.pointFillColor, "fill-opacity": a.pointFillOpacity ? a.pointFillOpacity : 1, stroke: a.pointStrokeColor, "stroke-width": a.pointStrokeWidth ? a.pointStrokeWidth : 0, "stroke-opacity": a.pointStrokeOpacity ? a.pointStrokeOpacity : 1 }), d = y;
      } else
        a.shape !== "circle" && a.shape || (K.isNumber(n) || (o = 0, n = 0), d = this.drawCircle(o, { cx: t, cy: n, class: a.class ? a.class : "", stroke: a.pointStrokeColor, fill: a.pointFillColor, "fill-opacity": a.pointFillOpacity ? a.pointFillOpacity : 1, "stroke-width": a.pointStrokeWidth ? a.pointStrokeWidth : 0, "stroke-opacity": a.pointStrokeOpacity ? a.pointStrokeOpacity : 1 }));
      return d;
    } }, { key: "pathMouseEnter", value: function(t, n) {
      var a = this.w, o = new Ee(this.ctx), d = parseInt(t.node.getAttribute("index"), 10), f = parseInt(t.node.getAttribute("j"), 10);
      if (typeof a.config.chart.events.dataPointMouseEnter == "function" && a.config.chart.events.dataPointMouseEnter(n, this.ctx, { seriesIndex: d, dataPointIndex: f, w: a }), this.ctx.events.fireEvent("dataPointMouseEnter", [n, this.ctx, { seriesIndex: d, dataPointIndex: f, w: a }]), (a.config.states.active.filter.type === "none" || t.node.getAttribute("selected") !== "true") && a.config.states.hover.filter.type !== "none" && !a.globals.isTouchDevice) {
        var p = a.config.states.hover.filter;
        o.applyFilter(t, d, p.type, p.value);
      }
    } }, { key: "pathMouseLeave", value: function(t, n) {
      var a = this.w, o = new Ee(this.ctx), d = parseInt(t.node.getAttribute("index"), 10), f = parseInt(t.node.getAttribute("j"), 10);
      typeof a.config.chart.events.dataPointMouseLeave == "function" && a.config.chart.events.dataPointMouseLeave(n, this.ctx, { seriesIndex: d, dataPointIndex: f, w: a }), this.ctx.events.fireEvent("dataPointMouseLeave", [n, this.ctx, { seriesIndex: d, dataPointIndex: f, w: a }]), a.config.states.active.filter.type !== "none" && t.node.getAttribute("selected") === "true" || a.config.states.hover.filter.type !== "none" && o.getDefaultFilter(t, d);
    } }, { key: "pathMouseDown", value: function(t, n) {
      var a = this.w, o = new Ee(this.ctx), d = parseInt(t.node.getAttribute("index"), 10), f = parseInt(t.node.getAttribute("j"), 10), p = "false";
      if (t.node.getAttribute("selected") === "true") {
        if (t.node.setAttribute("selected", "false"), a.globals.selectedDataPoints[d].indexOf(f) > -1) {
          var y = a.globals.selectedDataPoints[d].indexOf(f);
          a.globals.selectedDataPoints[d].splice(y, 1);
        }
      } else {
        if (!a.config.states.active.allowMultipleDataPointsSelection && a.globals.selectedDataPoints.length > 0) {
          a.globals.selectedDataPoints = [];
          var S = a.globals.dom.Paper.select(".apexcharts-series path").members, C = a.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members, E = function(P) {
            Array.prototype.forEach.call(P, function(I) {
              I.node.setAttribute("selected", "false"), o.getDefaultFilter(I, d);
            });
          };
          E(S), E(C);
        }
        t.node.setAttribute("selected", "true"), p = "true", a.globals.selectedDataPoints[d] === void 0 && (a.globals.selectedDataPoints[d] = []), a.globals.selectedDataPoints[d].push(f);
      }
      if (p === "true") {
        var L = a.config.states.active.filter;
        if (L !== "none")
          o.applyFilter(t, d, L.type, L.value);
        else if (a.config.states.hover.filter !== "none" && !a.globals.isTouchDevice) {
          var M = a.config.states.hover.filter;
          o.applyFilter(t, d, M.type, M.value);
        }
      } else
        a.config.states.active.filter.type !== "none" && (a.config.states.hover.filter.type === "none" || a.globals.isTouchDevice ? o.getDefaultFilter(t, d) : (M = a.config.states.hover.filter, o.applyFilter(t, d, M.type, M.value)));
      typeof a.config.chart.events.dataPointSelection == "function" && a.config.chart.events.dataPointSelection(n, this.ctx, { selectedDataPoints: a.globals.selectedDataPoints, seriesIndex: d, dataPointIndex: f, w: a }), n && this.ctx.events.fireEvent("dataPointSelection", [n, this.ctx, { selectedDataPoints: a.globals.selectedDataPoints, seriesIndex: d, dataPointIndex: f, w: a }]);
    } }, { key: "rotateAroundCenter", value: function(t) {
      var n = {};
      return t && typeof t.getBBox == "function" && (n = t.getBBox()), { x: n.x + n.width / 2, y: n.y + n.height / 2 };
    } }, { key: "getTextRects", value: function(t, n, a, o) {
      var d = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], f = this.w, p = this.drawText({ x: -200, y: -200, text: t, textAnchor: "start", fontSize: n, fontFamily: a, foreColor: "#fff", opacity: 0 });
      o && p.attr("transform", o), f.globals.dom.Paper.add(p);
      var y = p.bbox();
      return d || (y = p.node.getBoundingClientRect()), p.remove(), { width: y.width, height: y.height };
    } }, { key: "placeTextWithEllipsis", value: function(t, n, a) {
      if (typeof t.getComputedTextLength == "function" && (t.textContent = n, n.length > 0 && t.getComputedTextLength() >= a / 1.1)) {
        for (var o = n.length - 3; o > 0; o -= 3)
          if (t.getSubStringLength(0, o) <= a / 1.1)
            return void (t.textContent = n.substring(0, o) + "...");
        t.textContent = ".";
      }
    } }], [{ key: "setAttrs", value: function(t, n) {
      for (var a in n)
        n.hasOwnProperty(a) && t.setAttribute(a, n[a]);
    } }]), W;
  }(), me = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "getStackedSeriesTotals", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = this.w, a = [];
      if (n.globals.series.length === 0)
        return a;
      for (var o = 0; o < n.globals.series[n.globals.maxValsInArrayIndex].length; o++) {
        for (var d = 0, f = 0; f < n.globals.series.length; f++)
          n.globals.series[f][o] !== void 0 && t.indexOf(f) === -1 && (d += n.globals.series[f][o]);
        a.push(d);
      }
      return a;
    } }, { key: "getSeriesTotalByIndex", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return t === null ? this.w.config.series.reduce(function(n, a) {
        return n + a;
      }, 0) : this.w.globals.series[t].reduce(function(n, a) {
        return n + a;
      }, 0);
    } }, { key: "isSeriesNull", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return (t === null ? this.w.config.series.filter(function(n) {
        return n !== null;
      }) : this.w.config.series[t].data.filter(function(n) {
        return n !== null;
      })).length === 0;
    } }, { key: "seriesHaveSameValues", value: function(t) {
      return this.w.globals.series[t].every(function(n, a, o) {
        return n === o[0];
      });
    } }, { key: "getCategoryLabels", value: function(t) {
      var n = this.w, a = t.slice();
      return n.config.xaxis.convertedCatToNumeric && (a = t.map(function(o, d) {
        return n.config.xaxis.labels.formatter(o - n.globals.minX + 1);
      })), a;
    } }, { key: "getLargestSeries", value: function() {
      var t = this.w;
      t.globals.maxValsInArrayIndex = t.globals.series.map(function(n) {
        return n.length;
      }).indexOf(Math.max.apply(Math, t.globals.series.map(function(n) {
        return n.length;
      })));
    } }, { key: "getLargestMarkerSize", value: function() {
      var t = this.w, n = 0;
      return t.globals.markers.size.forEach(function(a) {
        n = Math.max(n, a);
      }), t.config.markers.discrete && t.config.markers.discrete.length && t.config.markers.discrete.forEach(function(a) {
        n = Math.max(n, a.size);
      }), n > 0 && (n += t.config.markers.hover.sizeOffset + 1), t.globals.markers.largestSize = n, n;
    } }, { key: "getSeriesTotals", value: function() {
      var t = this.w;
      t.globals.seriesTotals = t.globals.series.map(function(n, a) {
        var o = 0;
        if (Array.isArray(n))
          for (var d = 0; d < n.length; d++)
            o += n[d];
        else
          o += n;
        return o;
      });
    } }, { key: "getSeriesTotalsXRange", value: function(t, n) {
      var a = this.w;
      return a.globals.series.map(function(o, d) {
        for (var f = 0, p = 0; p < o.length; p++)
          a.globals.seriesX[d][p] > t && a.globals.seriesX[d][p] < n && (f += o[p]);
        return f;
      });
    } }, { key: "getPercentSeries", value: function() {
      var t = this.w;
      t.globals.seriesPercent = t.globals.series.map(function(n, a) {
        var o = [];
        if (Array.isArray(n))
          for (var d = 0; d < n.length; d++) {
            var f = t.globals.stackedSeriesTotals[d], p = 0;
            f && (p = 100 * n[d] / f), o.push(p);
          }
        else {
          var y = 100 * n / t.globals.seriesTotals.reduce(function(S, C) {
            return S + C;
          }, 0);
          o.push(y);
        }
        return o;
      });
    } }, { key: "getCalculatedRatios", value: function() {
      var t, n, a, o, d = this.w.globals, f = [], p = 0, y = [], S = 0.1, C = 0;
      if (d.yRange = [], d.isMultipleYAxis)
        for (var E = 0; E < d.minYArr.length; E++)
          d.yRange.push(Math.abs(d.minYArr[E] - d.maxYArr[E])), y.push(0);
      else
        d.yRange.push(Math.abs(d.minY - d.maxY));
      d.xRange = Math.abs(d.maxX - d.minX), d.zRange = Math.abs(d.maxZ - d.minZ);
      for (var L = 0; L < d.yRange.length; L++)
        f.push(d.yRange[L] / d.gridHeight);
      if (n = d.xRange / d.gridWidth, a = Math.abs(d.initialMaxX - d.initialMinX) / d.gridWidth, t = d.yRange / d.gridWidth, o = d.xRange / d.gridHeight, (p = d.zRange / d.gridHeight * 16) || (p = 1), d.minY !== Number.MIN_VALUE && Math.abs(d.minY) !== 0 && (d.hasNegs = !0), d.isMultipleYAxis) {
        y = [];
        for (var M = 0; M < f.length; M++)
          y.push(-d.minYArr[M] / f[M]);
      } else
        y.push(-d.minY / f[0]), d.minY !== Number.MIN_VALUE && Math.abs(d.minY) !== 0 && (S = -d.minY / t, C = d.minX / n);
      return { yRatio: f, invertedYRatio: t, zRatio: p, xRatio: n, initialXRatio: a, invertedXRatio: o, baseLineInvertedY: S, baseLineY: y, baseLineX: C };
    } }, { key: "getLogSeries", value: function(t) {
      var n = this, a = this.w;
      return a.globals.seriesLog = t.map(function(o, d) {
        return a.config.yaxis[d] && a.config.yaxis[d].logarithmic ? o.map(function(f) {
          return f === null ? null : n.getLogVal(a.config.yaxis[d].logBase, f, d);
        }) : o;
      }), a.globals.invalidLogScale ? t : a.globals.seriesLog;
    } }, { key: "getBaseLog", value: function(t, n) {
      return Math.log(n) / Math.log(t);
    } }, { key: "getLogVal", value: function(t, n, a) {
      if (n === 0)
        return 0;
      var o = this.w, d = o.globals.minYArr[a] === 0 ? -1 : this.getBaseLog(t, o.globals.minYArr[a]), f = (o.globals.maxYArr[a] === 0 ? 0 : this.getBaseLog(t, o.globals.maxYArr[a])) - d;
      return n < 1 ? n / f : (this.getBaseLog(t, n) - d) / f;
    } }, { key: "getLogYRatios", value: function(t) {
      var n = this, a = this.w, o = this.w.globals;
      return o.yLogRatio = t.slice(), o.logYRange = o.yRange.map(function(d, f) {
        if (a.config.yaxis[f] && n.w.config.yaxis[f].logarithmic) {
          var p, y = -Number.MAX_VALUE, S = Number.MIN_VALUE;
          return o.seriesLog.forEach(function(C, E) {
            C.forEach(function(L) {
              a.config.yaxis[E] && a.config.yaxis[E].logarithmic && (y = Math.max(L, y), S = Math.min(L, S));
            });
          }), p = Math.pow(o.yRange[f], Math.abs(S - y) / o.yRange[f]), o.yLogRatio[f] = p / o.gridHeight, p;
        }
      }), o.invalidLogScale ? t.slice() : o.yLogRatio;
    } }], [{ key: "checkComboSeries", value: function(t) {
      var n = !1, a = 0, o = 0;
      return t.length && t[0].type !== void 0 && t.forEach(function(d) {
        d.type !== "bar" && d.type !== "column" && d.type !== "candlestick" && d.type !== "boxPlot" || a++, d.type !== void 0 && o++;
      }), o > 0 && (n = !0), { comboBarCount: a, comboCharts: n };
    } }, { key: "extendArrayProps", value: function(t, n, a) {
      return n.yaxis && (n = t.extendYAxis(n, a)), n.annotations && (n.annotations.yaxis && (n = t.extendYAxisAnnotations(n)), n.annotations.xaxis && (n = t.extendXAxisAnnotations(n)), n.annotations.points && (n = t.extendPointAnnotations(n))), n;
    } }]), W;
  }(), Me = function() {
    function W(t) {
      T(this, W), this.w = t.w, this.annoCtx = t;
    }
    return F(W, [{ key: "setOrientations", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, a = this.w;
      if (t.label.orientation === "vertical") {
        var o = n !== null ? n : 0, d = a.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(o, "']"));
        if (d !== null) {
          var f = d.getBoundingClientRect();
          d.setAttribute("x", parseFloat(d.getAttribute("x")) - f.height + 4), t.label.position === "top" ? d.setAttribute("y", parseFloat(d.getAttribute("y")) + f.width) : d.setAttribute("y", parseFloat(d.getAttribute("y")) - f.width);
          var p = this.annoCtx.graphics.rotateAroundCenter(d), y = p.x, S = p.y;
          d.setAttribute("transform", "rotate(-90 ".concat(y, " ").concat(S, ")"));
        }
      }
    } }, { key: "addBackgroundToAnno", value: function(t, n) {
      var a = this.w;
      if (!t || n.label.text === void 0 || n.label.text !== void 0 && !String(n.label.text).trim())
        return null;
      var o = a.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), d = t.getBoundingClientRect(), f = n.label.style.padding.left, p = n.label.style.padding.right, y = n.label.style.padding.top, S = n.label.style.padding.bottom;
      n.label.orientation === "vertical" && (y = n.label.style.padding.left, S = n.label.style.padding.right, f = n.label.style.padding.top, p = n.label.style.padding.bottom);
      var C = d.left - o.left - f, E = d.top - o.top - y, L = this.annoCtx.graphics.drawRect(C - a.globals.barPadForNumericAxis, E, d.width + f + p, d.height + y + S, n.label.borderRadius, n.label.style.background, 1, n.label.borderWidth, n.label.borderColor, 0);
      return n.id && L.node.classList.add(n.id), L;
    } }, { key: "annotationsBackground", value: function() {
      var t = this, n = this.w, a = function(o, d, f) {
        var p = n.globals.dom.baseEl.querySelector(".apexcharts-".concat(f, "-annotations .apexcharts-").concat(f, "-annotation-label[rel='").concat(d, "']"));
        if (p) {
          var y = p.parentNode, S = t.addBackgroundToAnno(p, o);
          S && (y.insertBefore(S.node, p), o.label.mouseEnter && S.node.addEventListener("mouseenter", o.label.mouseEnter.bind(t, o)), o.label.mouseLeave && S.node.addEventListener("mouseleave", o.label.mouseLeave.bind(t, o)), o.label.click && S.node.addEventListener("click", o.label.click.bind(t, o)));
        }
      };
      n.config.annotations.xaxis.map(function(o, d) {
        a(o, d, "xaxis");
      }), n.config.annotations.yaxis.map(function(o, d) {
        a(o, d, "yaxis");
      }), n.config.annotations.points.map(function(o, d) {
        a(o, d, "point");
      });
    } }, { key: "getY1Y2", value: function(t, n) {
      var a, o = t === "y1" ? n.y : n.y2, d = this.w;
      if (this.annoCtx.invertAxis) {
        var f = d.globals.labels.indexOf(o);
        d.config.xaxis.convertedCatToNumeric && (f = d.globals.categoryLabels.indexOf(o));
        var p = d.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (f + 1) + ")");
        p && (a = parseFloat(p.getAttribute("y")));
      } else {
        var y;
        d.config.yaxis[n.yAxisIndex].logarithmic ? y = (o = new me(this.annoCtx.ctx).getLogVal(o, n.yAxisIndex)) / d.globals.yLogRatio[n.yAxisIndex] : y = (o - d.globals.minYArr[n.yAxisIndex]) / (d.globals.yRange[n.yAxisIndex] / d.globals.gridHeight), a = d.globals.gridHeight - y, !n.marker || n.y !== void 0 && n.y !== null || (a = 0), d.config.yaxis[n.yAxisIndex] && d.config.yaxis[n.yAxisIndex].reversed && (a = y);
      }
      return typeof o == "string" && o.indexOf("px") > -1 && (a = parseFloat(o)), a;
    } }, { key: "getX1X2", value: function(t, n) {
      var a = this.w, o = this.annoCtx.invertAxis ? a.globals.minY : a.globals.minX, d = this.annoCtx.invertAxis ? a.globals.maxY : a.globals.maxX, f = this.annoCtx.invertAxis ? a.globals.yRange[0] : a.globals.xRange, p = (n.x - o) / (f / a.globals.gridWidth);
      this.annoCtx.inversedReversedAxis && (p = (d - n.x) / (f / a.globals.gridWidth)), a.config.xaxis.type !== "category" && !a.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || a.globals.dataFormatXNumeric || (p = this.getStringX(n.x));
      var y = (n.x2 - o) / (f / a.globals.gridWidth);
      return this.annoCtx.inversedReversedAxis && (y = (d - n.x2) / (f / a.globals.gridWidth)), a.config.xaxis.type !== "category" && !a.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || a.globals.dataFormatXNumeric || (y = this.getStringX(n.x2)), n.x !== void 0 && n.x !== null || !n.marker || (p = a.globals.gridWidth), t === "x1" && typeof n.x == "string" && n.x.indexOf("px") > -1 && (p = parseFloat(n.x)), t === "x2" && typeof n.x2 == "string" && n.x2.indexOf("px") > -1 && (y = parseFloat(n.x2)), t === "x1" ? p : y;
    } }, { key: "getStringX", value: function(t) {
      var n = this.w, a = t;
      n.config.xaxis.convertedCatToNumeric && n.globals.categoryLabels.length && (t = n.globals.categoryLabels.indexOf(t) + 1);
      var o = n.globals.labels.indexOf(t), d = n.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (o + 1) + ")");
      return d && (a = parseFloat(d.getAttribute("x"))), a;
    } }]), W;
  }(), Je = function() {
    function W(t) {
      T(this, W), this.w = t.w, this.annoCtx = t, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new Me(this.annoCtx);
    }
    return F(W, [{ key: "addXaxisAnnotation", value: function(t, n, a) {
      var o, d = this.w, f = this.helpers.getX1X2("x1", t), p = t.label.text, y = t.strokeDashArray;
      if (K.isNumber(f)) {
        if (t.x2 === null || t.x2 === void 0) {
          var S = this.annoCtx.graphics.drawLine(f + t.offsetX, 0 + t.offsetY, f + t.offsetX, d.globals.gridHeight + t.offsetY, t.borderColor, y, t.borderWidth);
          n.appendChild(S.node), t.id && S.node.classList.add(t.id);
        } else {
          if ((o = this.helpers.getX1X2("x2", t)) < f) {
            var C = f;
            f = o, o = C;
          }
          var E = this.annoCtx.graphics.drawRect(f + t.offsetX, 0 + t.offsetY, o - f, d.globals.gridHeight + t.offsetY, 0, t.fillColor, t.opacity, 1, t.borderColor, y);
          E.node.classList.add("apexcharts-annotation-rect"), E.attr("clip-path", "url(#gridRectMask".concat(d.globals.cuid, ")")), n.appendChild(E.node), t.id && E.node.classList.add(t.id);
        }
        var L = this.annoCtx.graphics.getTextRects(p, parseFloat(t.label.style.fontSize)), M = t.label.position === "top" ? 4 : t.label.position === "center" ? d.globals.gridHeight / 2 + (t.label.orientation === "vertical" ? L.width / 2 : 0) : d.globals.gridHeight, P = this.annoCtx.graphics.drawText({ x: f + t.label.offsetX, y: M + t.label.offsetY - (t.label.orientation === "vertical" ? t.label.position === "top" ? L.width / 2 - 12 : -L.width / 2 : 0), text: p, textAnchor: t.label.textAnchor, fontSize: t.label.style.fontSize, fontFamily: t.label.style.fontFamily, fontWeight: t.label.style.fontWeight, foreColor: t.label.style.color, cssClass: "apexcharts-xaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "") });
        P.attr({ rel: a }), n.appendChild(P.node), this.annoCtx.helpers.setOrientations(t, a);
      }
    } }, { key: "drawXAxisAnnotations", value: function() {
      var t = this, n = this.w, a = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
      return n.config.annotations.xaxis.map(function(o, d) {
        t.addXaxisAnnotation(o, a.node, d);
      }), a;
    } }]), W;
  }(), Ve = function() {
    function W(t) {
      T(this, W), this.w = t.w, this.annoCtx = t, this.helpers = new Me(this.annoCtx);
    }
    return F(W, [{ key: "addYaxisAnnotation", value: function(t, n, a) {
      var o, d = this.w, f = t.strokeDashArray, p = this.helpers.getY1Y2("y1", t), y = t.label.text;
      if (t.y2 === null || t.y2 === void 0) {
        var S = this.annoCtx.graphics.drawLine(0 + t.offsetX, p + t.offsetY, this._getYAxisAnnotationWidth(t), p + t.offsetY, t.borderColor, f, t.borderWidth);
        n.appendChild(S.node), t.id && S.node.classList.add(t.id);
      } else {
        if ((o = this.helpers.getY1Y2("y2", t)) > p) {
          var C = p;
          p = o, o = C;
        }
        var E = this.annoCtx.graphics.drawRect(0 + t.offsetX, o + t.offsetY, this._getYAxisAnnotationWidth(t), p - o, 0, t.fillColor, t.opacity, 1, t.borderColor, f);
        E.node.classList.add("apexcharts-annotation-rect"), E.attr("clip-path", "url(#gridRectMask".concat(d.globals.cuid, ")")), n.appendChild(E.node), t.id && E.node.classList.add(t.id);
      }
      var L = t.label.position === "right" ? d.globals.gridWidth : t.label.position === "center" ? d.globals.gridWidth / 2 : 0, M = this.annoCtx.graphics.drawText({ x: L + t.label.offsetX, y: (o ?? p) + t.label.offsetY - 3, text: y, textAnchor: t.label.textAnchor, fontSize: t.label.style.fontSize, fontFamily: t.label.style.fontFamily, fontWeight: t.label.style.fontWeight, foreColor: t.label.style.color, cssClass: "apexcharts-yaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "") });
      M.attr({ rel: a }), n.appendChild(M.node);
    } }, { key: "_getYAxisAnnotationWidth", value: function(t) {
      var n = this.w;
      return n.globals.gridWidth, (t.width.indexOf("%") > -1 ? n.globals.gridWidth * parseInt(t.width, 10) / 100 : parseInt(t.width, 10)) + t.offsetX;
    } }, { key: "drawYAxisAnnotations", value: function() {
      var t = this, n = this.w, a = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
      return n.config.annotations.yaxis.map(function(o, d) {
        t.addYaxisAnnotation(o, a.node, d);
      }), a;
    } }]), W;
  }(), Xe = function() {
    function W(t) {
      T(this, W), this.w = t.w, this.annoCtx = t, this.helpers = new Me(this.annoCtx);
    }
    return F(W, [{ key: "addPointAnnotation", value: function(t, n, a) {
      this.w;
      var o = this.helpers.getX1X2("x1", t), d = this.helpers.getY1Y2("y1", t);
      if (K.isNumber(o)) {
        var f = { pSize: t.marker.size, pointStrokeWidth: t.marker.strokeWidth, pointFillColor: t.marker.fillColor, pointStrokeColor: t.marker.strokeColor, shape: t.marker.shape, pRadius: t.marker.radius, class: "apexcharts-point-annotation-marker ".concat(t.marker.cssClass, " ").concat(t.id ? t.id : "") }, p = this.annoCtx.graphics.drawMarker(o + t.marker.offsetX, d + t.marker.offsetY, f);
        n.appendChild(p.node);
        var y = t.label.text ? t.label.text : "", S = this.annoCtx.graphics.drawText({ x: o + t.label.offsetX, y: d + t.label.offsetY - t.marker.size - parseFloat(t.label.style.fontSize) / 1.6, text: y, textAnchor: t.label.textAnchor, fontSize: t.label.style.fontSize, fontFamily: t.label.style.fontFamily, fontWeight: t.label.style.fontWeight, foreColor: t.label.style.color, cssClass: "apexcharts-point-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "") });
        if (S.attr({ rel: a }), n.appendChild(S.node), t.customSVG.SVG) {
          var C = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + t.customSVG.cssClass });
          C.attr({ transform: "translate(".concat(o + t.customSVG.offsetX, ", ").concat(d + t.customSVG.offsetY, ")") }), C.node.innerHTML = t.customSVG.SVG, n.appendChild(C.node);
        }
        if (t.image.path) {
          var E = t.image.width ? t.image.width : 20, L = t.image.height ? t.image.height : 20;
          p = this.annoCtx.addImage({ x: o + t.image.offsetX - E / 2, y: d + t.image.offsetY - L / 2, width: E, height: L, path: t.image.path, appendTo: ".apexcharts-point-annotations" });
        }
        t.mouseEnter && p.node.addEventListener("mouseenter", t.mouseEnter.bind(this, t)), t.mouseLeave && p.node.addEventListener("mouseleave", t.mouseLeave.bind(this, t)), t.click && p.node.addEventListener("click", t.click.bind(this, t));
      }
    } }, { key: "drawPointAnnotations", value: function() {
      var t = this, n = this.w, a = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
      return n.config.annotations.points.map(function(o, d) {
        t.addPointAnnotation(o, a.node, d);
      }), a;
    } }]), W;
  }(), it = { name: "en", options: { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", exportToCSV: "Download CSV", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } } }, ht = function() {
    function W() {
      T(this, W), this.yAxis = { show: !0, showAlways: !1, showForNullSeries: !0, seriesName: void 0, opposite: !1, reversed: !1, logarithmic: !1, logBase: 10, tickAmount: void 0, forceNiceScale: !1, max: void 0, min: void 0, floating: !1, decimalsInFloat: void 0, labels: { show: !0, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, formatter: void 0 }, axisBorder: { show: !1, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: !1, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: -90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, tooltip: { enabled: !1, offsetX: 0 }, crosshairs: { show: !0, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: void 0, x: 0, y: null, yAxisIndex: 0, seriesIndex: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, radius: 2, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 }, image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: void 0, y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: "100%", yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: void 0, x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: "", textAnchor: "start", foreColor: void 0, fontSize: "13px", fontFamily: void 0, fontWeight: 400, appendTo: ".apexcharts-annotations", backgroundColor: "transparent", borderColor: "#c2c2c2", borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
    }
    return F(W, [{ key: "init", value: function() {
      return { annotations: { yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: !0, easing: "easeinout", speed: 800, animateGradually: { delay: 150, enabled: !0 }, dynamicAnimation: { enabled: !0, speed: 350 } }, background: "transparent", locales: [it], defaultLocale: "en", dropShadow: { enabled: !1, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.35 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, mouseLeave: void 0, xAxisLabelClick: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, beforeResetZoom: void 0, zoomed: void 0, scrolled: void 0, brushScrolled: void 0 }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, redrawOnParentResize: !0, redrawOnWindowResize: !0, id: void 0, group: void 0, offsetX: 0, offsetY: 0, selection: { enabled: !1, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: !1 }, brush: { enabled: !1, autoScaleYaxis: !0, target: void 0, targets: void 0 }, stacked: !1, stackType: "normal", toolbar: { show: !0, offsetX: 0, offsetY: 0, tools: { download: !0, selection: !0, zoom: !0, zoomin: !0, zoomout: !0, pan: !0, reset: !0, customIcons: [] }, export: { csv: { filename: void 0, columnDelimiter: ",", headerCategory: "category", headerValue: "value", dateFormatter: function(t) {
        return new Date(t).toDateString();
      } }, png: { filename: void 0 }, svg: { filename: void 0 } }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: !0, type: "x", autoScaleYaxis: !1, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { area: { fillTo: "origin" }, bar: { horizontal: !1, columnWidth: "70%", barHeight: "70%", distributed: !1, borderRadius: 0, borderRadiusApplication: "around", borderRadiusWhenStacked: "last", rangeBarOverlap: !0, rangeBarGroupRows: !1, hideZeroBarsWhenGrouped: !1, isDumbbell: !1, dumbbellColors: void 0, isFunnel: !1, isFunnel3d: !0, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: "top", maxItems: 100, hideOverflowingLabels: !0, orientation: "horizontal", total: { enabled: !1, formatter: void 0, offsetX: 0, offsetY: 0, style: { color: "#373d3f", fontSize: "12px", fontFamily: void 0, fontWeight: 600 } } } }, bubble: { zScaling: !0, minBubbleRadius: void 0, maxBubbleRadius: void 0 }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: !0 } }, boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } }, heatmap: { radius: 2, enableShades: !0, shadeIntensity: 0.5, reverseNegativeShade: !1, distributed: !1, useFillColorAsStroke: !1, colorScale: { inverse: !1, ranges: [], min: void 0, max: void 0 } }, treemap: { enableShades: !0, shadeIntensity: 0.5, distributed: !1, reverseNegativeShade: !1, useFillColorAsStroke: !1, dataLabels: { format: "scale" }, colorScale: { inverse: !1, ranges: [], min: void 0, max: void 0 } }, radialBar: { inverseOrder: !1, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: !0, position: "front", dropShadow: { enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: !0, startAngle: void 0, endAngle: void 0, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: !0, name: { show: !0, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter: function(t) {
        return t;
      } }, value: { show: !0, fontSize: "14px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter: function(t) {
        return t + "%";
      } }, total: { show: !1, label: "Total", fontSize: "16px", fontWeight: 600, fontFamily: void 0, color: void 0, formatter: function(t) {
        return t.globals.seriesTotals.reduce(function(n, a) {
          return n + a;
        }, 0) / t.globals.series.length + "%";
      } } } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: !0, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: !1, name: { show: !0, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter: function(t) {
        return t;
      } }, value: { show: !0, fontSize: "20px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter: function(t) {
        return t;
      } }, total: { show: !1, showAlways: !1, label: "Total", fontSize: "16px", fontWeight: 400, fontFamily: void 0, color: void 0, formatter: function(t) {
        return t.globals.seriesTotals.reduce(function(n, a) {
          return n + a;
        }, 0);
      } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: "#e8e8e8" }, spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: !0, enabledOnSeries: void 0, formatter: function(t) {
        return t !== null ? t : "";
      }, textAnchor: "middle", distributed: !1, offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0 }, background: { enabled: !0, foreColor: "#fff", borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: "#fff", dropShadow: { enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, dropShadow: { enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: !0, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 }, grid: { show: !0, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: !1 } }, yaxis: { lines: { show: !0 } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: !0, showForSingleSeries: !1, showForNullSeries: !0, showForZeroSeries: !0, floating: !1, position: "bottom", horizontalAlign: "center", inverseOrder: !1, fontSize: "12px", fontFamily: void 0, fontWeight: 400, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 4, customLegendItems: [], labels: { colors: void 0, useSeriesColors: !1 }, markers: { width: 12, height: 12, strokeWidth: 0, fillColors: void 0, strokeColor: "#fff", radius: 12, customHTML: void 0, offsetX: 0, offsetY: 0, onClick: void 0 }, itemMargin: { horizontal: 5, vertical: 2 }, onItemClick: { toggleDataSeries: !0 }, onItemHover: { highlightDataSeries: !0 } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: "circle", width: 8, height: 8, radius: 2, offsetX: 0, offsetY: 0, onClick: void 0, onDblClick: void 0, showNullDataPoints: !0, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "14px", fontFamily: void 0 } }, responsive: [], series: void 0, states: { normal: { filter: { type: "none", value: 0 } }, hover: { filter: { type: "lighten", value: 0.1 } }, active: { allowMultipleDataPointsSelection: !1, filter: { type: "darken", value: 0.5 } } }, title: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 0, floating: !1, style: { fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 30, floating: !1, style: { fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0 } }, stroke: { show: !0, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: !0, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] } } }, tooltip: { enabled: !0, enabledOnSeries: void 0, shared: !0, followCursor: !1, intersect: !1, inverseOrder: !1, custom: void 0, fillSeriesColor: !1, theme: "light", cssClass: "", style: { fontSize: "12px", fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: !1 }, x: { show: !0, format: "dd MMM", formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(t) {
        return t ? t + ": " : "";
      } } }, z: { formatter: void 0, title: "Size: " }, marker: { show: !0, fillColors: void 0 }, items: { display: "flex" }, fixed: { enabled: !1, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], convertedCatToNumeric: !1, offsetX: 0, offsetY: 0, overwriteCategories: void 0, labels: { show: !0, rotate: -45, rotateAlways: !1, hideOverlappingLabels: !0, trim: !1, minHeight: void 0, maxHeight: 120, showDuplicates: !0, style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeUTC: !0, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss", second: "HH:mm:ss" } }, group: { groups: [], style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" } }, axisBorder: { show: !0, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: !0, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 }, tickAmount: void 0, tickPlacement: "on", min: void 0, max: void 0, range: void 0, floating: !1, decimalsInFloat: void 0, position: "bottom", title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, crosshairs: { show: !0, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: !1, left: 0, top: 0, blur: 1, opacity: 0.4 } }, tooltip: { enabled: !0, offsetY: 0, formatter: void 0, style: { fontSize: "12px", fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: "light", palette: "palette1", monochrome: { enabled: !1, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
    } }]), W;
  }(), Ke = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w, this.graphics = new re(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new Me(this), this.xAxisAnnotations = new Je(this), this.yAxisAnnotations = new Ve(this), this.pointsAnnotations = new Xe(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
    }
    return F(W, [{ key: "drawAxesAnnotations", value: function() {
      var t = this.w;
      if (t.globals.axisCharts) {
        for (var n = this.yAxisAnnotations.drawYAxisAnnotations(), a = this.xAxisAnnotations.drawXAxisAnnotations(), o = this.pointsAnnotations.drawPointAnnotations(), d = t.config.chart.animations.enabled, f = [n, a, o], p = [a.node, n.node, o.node], y = 0; y < 3; y++)
          t.globals.dom.elGraphical.add(f[y]), !d || t.globals.resized || t.globals.dataChanged || t.config.chart.type !== "scatter" && t.config.chart.type !== "bubble" && t.globals.dataPoints > 1 && p[y].classList.add("apexcharts-element-hidden"), t.globals.delayedElements.push({ el: p[y], index: 0 });
        this.helpers.annotationsBackground();
      }
    } }, { key: "drawImageAnnos", value: function() {
      var t = this;
      this.w.config.annotations.images.map(function(n, a) {
        t.addImage(n, a);
      });
    } }, { key: "drawTextAnnos", value: function() {
      var t = this;
      this.w.config.annotations.texts.map(function(n, a) {
        t.addText(n, a);
      });
    } }, { key: "addXaxisAnnotation", value: function(t, n, a) {
      this.xAxisAnnotations.addXaxisAnnotation(t, n, a);
    } }, { key: "addYaxisAnnotation", value: function(t, n, a) {
      this.yAxisAnnotations.addYaxisAnnotation(t, n, a);
    } }, { key: "addPointAnnotation", value: function(t, n, a) {
      this.pointsAnnotations.addPointAnnotation(t, n, a);
    } }, { key: "addText", value: function(t, n) {
      var a = t.x, o = t.y, d = t.text, f = t.textAnchor, p = t.foreColor, y = t.fontSize, S = t.fontFamily, C = t.fontWeight, E = t.cssClass, L = t.backgroundColor, M = t.borderWidth, P = t.strokeDashArray, I = t.borderRadius, B = t.borderColor, G = t.appendTo, Z = G === void 0 ? ".apexcharts-annotations" : G, b = t.paddingLeft, O = b === void 0 ? 4 : b, N = t.paddingRight, X = N === void 0 ? 4 : N, Q = t.paddingBottom, ee = Q === void 0 ? 2 : Q, oe = t.paddingTop, fe = oe === void 0 ? 2 : oe, ke = this.w, _e = this.graphics.drawText({ x: a, y: o, text: d, textAnchor: f || "start", fontSize: y || "12px", fontWeight: C || "regular", fontFamily: S || ke.config.chart.fontFamily, foreColor: p || ke.config.chart.foreColor, cssClass: E }), Le = ke.globals.dom.baseEl.querySelector(Z);
      Le && Le.appendChild(_e.node);
      var Ie = _e.bbox();
      if (d) {
        var at = this.graphics.drawRect(Ie.x - O, Ie.y - fe, Ie.width + O + X, Ie.height + ee + fe, I, L || "transparent", 1, M, B, P);
        Le.insertBefore(at.node, _e.node);
      }
    } }, { key: "addImage", value: function(t, n) {
      var a = this.w, o = t.path, d = t.x, f = d === void 0 ? 0 : d, p = t.y, y = p === void 0 ? 0 : p, S = t.width, C = S === void 0 ? 20 : S, E = t.height, L = E === void 0 ? 20 : E, M = t.appendTo, P = M === void 0 ? ".apexcharts-annotations" : M, I = a.globals.dom.Paper.image(o);
      I.size(C, L).move(f, y);
      var B = a.globals.dom.baseEl.querySelector(P);
      return B && B.appendChild(I.node), I;
    } }, { key: "addXaxisAnnotationExternal", value: function(t, n, a) {
      return this.addAnnotationExternal({ params: t, pushToMemory: n, context: a, type: "xaxis", contextMethod: a.addXaxisAnnotation }), a;
    } }, { key: "addYaxisAnnotationExternal", value: function(t, n, a) {
      return this.addAnnotationExternal({ params: t, pushToMemory: n, context: a, type: "yaxis", contextMethod: a.addYaxisAnnotation }), a;
    } }, { key: "addPointAnnotationExternal", value: function(t, n, a) {
      return this.invertAxis === void 0 && (this.invertAxis = a.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: t, pushToMemory: n, context: a, type: "point", contextMethod: a.addPointAnnotation }), a;
    } }, { key: "addAnnotationExternal", value: function(t) {
      var n = t.params, a = t.pushToMemory, o = t.context, d = t.type, f = t.contextMethod, p = o, y = p.w, S = y.globals.dom.baseEl.querySelector(".apexcharts-".concat(d, "-annotations")), C = S.childNodes.length + 1, E = new ht(), L = Object.assign({}, d === "xaxis" ? E.xAxisAnnotation : d === "yaxis" ? E.yAxisAnnotation : E.pointAnnotation), M = K.extend(L, n);
      switch (d) {
        case "xaxis":
          this.addXaxisAnnotation(M, S, C);
          break;
        case "yaxis":
          this.addYaxisAnnotation(M, S, C);
          break;
        case "point":
          this.addPointAnnotation(M, S, C);
      }
      var P = y.globals.dom.baseEl.querySelector(".apexcharts-".concat(d, "-annotations .apexcharts-").concat(d, "-annotation-label[rel='").concat(C, "']")), I = this.helpers.addBackgroundToAnno(P, M);
      return I && S.insertBefore(I.node, P), a && y.globals.memory.methodsToExec.push({ context: p, id: M.id ? M.id : K.randomId(), method: f, label: "addAnnotation", params: n }), o;
    } }, { key: "clearAnnotations", value: function(t) {
      var n = t.w, a = n.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
      n.globals.memory.methodsToExec.map(function(o, d) {
        o.label !== "addText" && o.label !== "addAnnotation" || n.globals.memory.methodsToExec.splice(d, 1);
      }), a = K.listToArray(a), Array.prototype.forEach.call(a, function(o) {
        for (; o.firstChild; )
          o.removeChild(o.firstChild);
      });
    } }, { key: "removeAnnotation", value: function(t, n) {
      var a = t.w, o = a.globals.dom.baseEl.querySelectorAll(".".concat(n));
      o && (a.globals.memory.methodsToExec.map(function(d, f) {
        d.id === n && a.globals.memory.methodsToExec.splice(f, 1);
      }), Array.prototype.forEach.call(o, function(d) {
        d.parentElement.removeChild(d);
      }));
    } }]), W;
  }(), Ze = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    }
    return F(W, [{ key: "isValidDate", value: function(t) {
      return !isNaN(this.parseDate(t));
    } }, { key: "getTimeStamp", value: function(t) {
      return Date.parse(t) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toISOString().substr(0, 25)).getTime() : new Date(t).getTime() : t;
    } }, { key: "getDate", value: function(t) {
      return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toUTCString()) : new Date(t);
    } }, { key: "parseDate", value: function(t) {
      var n = Date.parse(t);
      if (!isNaN(n))
        return this.getTimeStamp(t);
      var a = Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
      return a = this.getTimeStamp(a);
    } }, { key: "parseDateWithTimezone", value: function(t) {
      return Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
    } }, { key: "formatDate", value: function(t, n) {
      var a = this.w.globals.locale, o = this.w.config.xaxis.labels.datetimeUTC, d = ["\0"].concat(ue(a.months)), f = [""].concat(ue(a.shortMonths)), p = [""].concat(ue(a.days)), y = [""].concat(ue(a.shortDays));
      function S(ee, oe) {
        var fe = ee + "";
        for (oe = oe || 2; fe.length < oe; )
          fe = "0" + fe;
        return fe;
      }
      var C = o ? t.getUTCFullYear() : t.getFullYear();
      n = (n = (n = n.replace(/(^|[^\\])yyyy+/g, "$1" + C)).replace(/(^|[^\\])yy/g, "$1" + C.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + C);
      var E = (o ? t.getUTCMonth() : t.getMonth()) + 1;
      n = (n = (n = (n = n.replace(/(^|[^\\])MMMM+/g, "$1" + d[0])).replace(/(^|[^\\])MMM/g, "$1" + f[0])).replace(/(^|[^\\])MM/g, "$1" + S(E))).replace(/(^|[^\\])M/g, "$1" + E);
      var L = o ? t.getUTCDate() : t.getDate();
      n = (n = (n = (n = n.replace(/(^|[^\\])dddd+/g, "$1" + p[0])).replace(/(^|[^\\])ddd/g, "$1" + y[0])).replace(/(^|[^\\])dd/g, "$1" + S(L))).replace(/(^|[^\\])d/g, "$1" + L);
      var M = o ? t.getUTCHours() : t.getHours(), P = M > 12 ? M - 12 : M === 0 ? 12 : M;
      n = (n = (n = (n = n.replace(/(^|[^\\])HH+/g, "$1" + S(M))).replace(/(^|[^\\])H/g, "$1" + M)).replace(/(^|[^\\])hh+/g, "$1" + S(P))).replace(/(^|[^\\])h/g, "$1" + P);
      var I = o ? t.getUTCMinutes() : t.getMinutes();
      n = (n = n.replace(/(^|[^\\])mm+/g, "$1" + S(I))).replace(/(^|[^\\])m/g, "$1" + I);
      var B = o ? t.getUTCSeconds() : t.getSeconds();
      n = (n = n.replace(/(^|[^\\])ss+/g, "$1" + S(B))).replace(/(^|[^\\])s/g, "$1" + B);
      var G = o ? t.getUTCMilliseconds() : t.getMilliseconds();
      n = n.replace(/(^|[^\\])fff+/g, "$1" + S(G, 3)), G = Math.round(G / 10), n = n.replace(/(^|[^\\])ff/g, "$1" + S(G)), G = Math.round(G / 10);
      var Z = M < 12 ? "AM" : "PM";
      n = (n = (n = n.replace(/(^|[^\\])f/g, "$1" + G)).replace(/(^|[^\\])TT+/g, "$1" + Z)).replace(/(^|[^\\])T/g, "$1" + Z.charAt(0));
      var b = Z.toLowerCase();
      n = (n = n.replace(/(^|[^\\])tt+/g, "$1" + b)).replace(/(^|[^\\])t/g, "$1" + b.charAt(0));
      var O = -t.getTimezoneOffset(), N = o || !O ? "Z" : O > 0 ? "+" : "-";
      if (!o) {
        var X = (O = Math.abs(O)) % 60;
        N += S(Math.floor(O / 60)) + ":" + S(X);
      }
      n = n.replace(/(^|[^\\])K/g, "$1" + N);
      var Q = (o ? t.getUTCDay() : t.getDay()) + 1;
      return n = (n = (n = (n = (n = n.replace(new RegExp(p[0], "g"), p[Q])).replace(new RegExp(y[0], "g"), y[Q])).replace(new RegExp(d[0], "g"), d[E])).replace(new RegExp(f[0], "g"), f[E])).replace(/\\(.)/g, "$1");
    } }, { key: "getTimeUnitsfromTimestamp", value: function(t, n, a) {
      var o = this.w;
      o.config.xaxis.min !== void 0 && (t = o.config.xaxis.min), o.config.xaxis.max !== void 0 && (n = o.config.xaxis.max);
      var d = this.getDate(t), f = this.getDate(n), p = this.formatDate(d, "yyyy MM dd HH mm ss fff").split(" "), y = this.formatDate(f, "yyyy MM dd HH mm ss fff").split(" ");
      return { minMillisecond: parseInt(p[6], 10), maxMillisecond: parseInt(y[6], 10), minSecond: parseInt(p[5], 10), maxSecond: parseInt(y[5], 10), minMinute: parseInt(p[4], 10), maxMinute: parseInt(y[4], 10), minHour: parseInt(p[3], 10), maxHour: parseInt(y[3], 10), minDate: parseInt(p[2], 10), maxDate: parseInt(y[2], 10), minMonth: parseInt(p[1], 10) - 1, maxMonth: parseInt(y[1], 10) - 1, minYear: parseInt(p[0], 10), maxYear: parseInt(y[0], 10) };
    } }, { key: "isLeapYear", value: function(t) {
      return t % 4 == 0 && t % 100 != 0 || t % 400 == 0;
    } }, { key: "calculcateLastDaysOfMonth", value: function(t, n, a) {
      return this.determineDaysOfMonths(t, n) - a;
    } }, { key: "determineDaysOfYear", value: function(t) {
      var n = 365;
      return this.isLeapYear(t) && (n = 366), n;
    } }, { key: "determineRemainingDaysOfYear", value: function(t, n, a) {
      var o = this.daysCntOfYear[n] + a;
      return n > 1 && this.isLeapYear() && o++, o;
    } }, { key: "determineDaysOfMonths", value: function(t, n) {
      var a = 30;
      switch (t = K.monthMod(t), !0) {
        case this.months30.indexOf(t) > -1:
          t === 2 && (a = this.isLeapYear(n) ? 29 : 28);
          break;
        case this.months31.indexOf(t) > -1:
        default:
          a = 31;
      }
      return a;
    } }]), W;
  }(), Tt = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w, this.tooltipKeyFormat = "dd MMM";
    }
    return F(W, [{ key: "xLabelFormat", value: function(t, n, a, o) {
      var d = this.w;
      if (d.config.xaxis.type === "datetime" && d.config.xaxis.labels.formatter === void 0 && d.config.tooltip.x.formatter === void 0) {
        var f = new Ze(this.ctx);
        return f.formatDate(f.getDate(n), d.config.tooltip.x.format);
      }
      return t(n, a, o);
    } }, { key: "defaultGeneralFormatter", value: function(t) {
      return Array.isArray(t) ? t.map(function(n) {
        return n;
      }) : t;
    } }, { key: "defaultYFormatter", value: function(t, n, a) {
      var o = this.w;
      return K.isNumber(t) && (t = o.globals.yValueDecimal !== 0 ? t.toFixed(n.decimalsInFloat !== void 0 ? n.decimalsInFloat : o.globals.yValueDecimal) : o.globals.maxYArr[a] - o.globals.minYArr[a] < 5 ? t.toFixed(1) : t.toFixed(0)), t;
    } }, { key: "setLabelFormatters", value: function() {
      var t = this, n = this.w;
      return n.globals.xaxisTooltipFormatter = function(a) {
        return t.defaultGeneralFormatter(a);
      }, n.globals.ttKeyFormatter = function(a) {
        return t.defaultGeneralFormatter(a);
      }, n.globals.ttZFormatter = function(a) {
        return a;
      }, n.globals.legendFormatter = function(a) {
        return t.defaultGeneralFormatter(a);
      }, n.config.xaxis.labels.formatter !== void 0 ? n.globals.xLabelFormatter = n.config.xaxis.labels.formatter : n.globals.xLabelFormatter = function(a) {
        if (K.isNumber(a)) {
          if (!n.config.xaxis.convertedCatToNumeric && n.config.xaxis.type === "numeric") {
            if (K.isNumber(n.config.xaxis.decimalsInFloat))
              return a.toFixed(n.config.xaxis.decimalsInFloat);
            var o = n.globals.maxX - n.globals.minX;
            return o > 0 && o < 100 ? a.toFixed(1) : a.toFixed(0);
          }
          return n.globals.isBarHorizontal && n.globals.maxY - n.globals.minYArr < 4 ? a.toFixed(1) : a.toFixed(0);
        }
        return a;
      }, typeof n.config.tooltip.x.formatter == "function" ? n.globals.ttKeyFormatter = n.config.tooltip.x.formatter : n.globals.ttKeyFormatter = n.globals.xLabelFormatter, typeof n.config.xaxis.tooltip.formatter == "function" && (n.globals.xaxisTooltipFormatter = n.config.xaxis.tooltip.formatter), (Array.isArray(n.config.tooltip.y) || n.config.tooltip.y.formatter !== void 0) && (n.globals.ttVal = n.config.tooltip.y), n.config.tooltip.z.formatter !== void 0 && (n.globals.ttZFormatter = n.config.tooltip.z.formatter), n.config.legend.formatter !== void 0 && (n.globals.legendFormatter = n.config.legend.formatter), n.config.yaxis.forEach(function(a, o) {
        a.labels.formatter !== void 0 ? n.globals.yLabelFormatters[o] = a.labels.formatter : n.globals.yLabelFormatters[o] = function(d) {
          return n.globals.xyCharts ? Array.isArray(d) ? d.map(function(f) {
            return t.defaultYFormatter(f, a, o);
          }) : t.defaultYFormatter(d, a, o) : d;
        };
      }), n.globals;
    } }, { key: "heatmapLabelFormatters", value: function() {
      var t = this.w;
      if (t.config.chart.type === "heatmap") {
        t.globals.yAxisScale[0].result = t.globals.seriesNames.slice();
        var n = t.globals.seriesNames.reduce(function(a, o) {
          return a.length > o.length ? a : o;
        }, 0);
        t.globals.yAxisScale[0].niceMax = n, t.globals.yAxisScale[0].niceMin = n;
      }
    } }]), W;
  }(), It = function(W) {
    var t, n = W.isTimeline, a = W.ctx, o = W.seriesIndex, d = W.dataPointIndex, f = W.y1, p = W.y2, y = W.w, S = y.globals.seriesRangeStart[o][d], C = y.globals.seriesRangeEnd[o][d], E = y.globals.labels[d], L = y.config.series[o].name ? y.config.series[o].name : "", M = y.globals.ttKeyFormatter, P = y.config.tooltip.y.title.formatter, I = { w: y, seriesIndex: o, dataPointIndex: d, start: S, end: C };
    typeof P == "function" && (L = P(L, I)), (t = y.config.series[o].data[d]) !== null && t !== void 0 && t.x && (E = y.config.series[o].data[d].x), n || y.config.xaxis.type === "datetime" && (E = new Tt(a).xLabelFormat(y.globals.ttKeyFormatter, E, E, { i: void 0, dateFormatter: new Ze(a).formatDate, w: y })), typeof M == "function" && (E = M(E, I)), Number.isFinite(f) && Number.isFinite(p) && (S = f, C = p);
    var B = "", G = "", Z = y.globals.colors[o];
    if (y.config.tooltip.x.formatter === void 0)
      if (y.config.xaxis.type === "datetime") {
        var b = new Ze(a);
        B = b.formatDate(b.getDate(S), y.config.tooltip.x.format), G = b.formatDate(b.getDate(C), y.config.tooltip.x.format);
      } else
        B = S, G = C;
    else
      B = y.config.tooltip.x.formatter(S), G = y.config.tooltip.x.formatter(C);
    return { start: S, end: C, startVal: B, endVal: G, ylabel: E, color: Z, seriesName: L };
  }, Jt = function(W) {
    var t = W.color, n = W.seriesName, a = W.ylabel, o = W.start, d = W.end, f = W.seriesIndex, p = W.dataPointIndex, y = W.ctx.tooltip.tooltipLabels.getFormatters(f);
    o = y.yLbFormatter(o), d = y.yLbFormatter(d);
    var S = y.yLbFormatter(W.w.globals.series[f][p]), C = `<span class="value start-value">
  `.concat(o, `
  </span> <span class="separator">-</span> <span class="value end-value">
  `).concat(d, `
  </span>`);
    return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + t + '">' + (n || "") + '</span></div><div> <span class="category">' + a + ": </span> " + (W.w.globals.comboCharts ? W.w.config.series[f].type === "rangeArea" || W.w.config.series[f].type === "rangeBar" ? C : "<span>".concat(S, "</span>") : C) + " </div></div>";
  }, We = function() {
    function W(t) {
      T(this, W), this.opts = t;
    }
    return F(W, [{ key: "hideYAxis", value: function() {
      this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0;
    } }, { key: "line", value: function() {
      return { chart: { animations: { easing: "swing" } }, dataLabels: { enabled: !1 }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "sparkline", value: function(t) {
      return this.hideYAxis(), K.extend(t, { grid: { show: !1, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: !1 }, xaxis: { labels: { show: !1 }, tooltip: { enabled: !1 }, axisBorder: { show: !1 }, axisTicks: { show: !1 } }, chart: { toolbar: { show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !1 } });
    } }, { key: "bar", value: function() {
      return { chart: { stacked: !1, animations: { easing: "swing" } }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] }, background: { enabled: !1 } }, stroke: { width: 0, lineCap: "round" }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square", radius: 2, size: 8 } }, tooltip: { shared: !1, intersect: !0 }, xaxis: { tooltip: { enabled: !1 }, tickPlacement: "between", crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: !1 }, stroke: { width: 0 } } } };
    } }, { key: "funnel", value: function() {
      return this.hideYAxis(), m(m({}, this.bar()), {}, { chart: { animations: { easing: "linear", speed: 800, animateGradually: { enabled: !1 } } }, plotOptions: { bar: { horizontal: !0, borderRadiusApplication: "around", borderRadius: 0, dataLabels: { position: "center" } } }, grid: { show: !1, padding: { left: 0, right: 0 } }, xaxis: { labels: { show: !1 }, tooltip: { enabled: !1 }, axisBorder: { show: !1 }, axisTicks: { show: !1 } } });
    } }, { key: "candlestick", value: function() {
      var t = this;
      return { stroke: { width: 1, colors: ["#333"] }, fill: { opacity: 1 }, dataLabels: { enabled: !1 }, tooltip: { shared: !0, custom: function(n) {
        var a = n.seriesIndex, o = n.dataPointIndex, d = n.w;
        return t._getBoxTooltip(d, a, o, ["Open", "High", "", "Low", "Close"], "candlestick");
      } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "boxPlot", value: function() {
      var t = this;
      return { chart: { animations: { dynamicAnimation: { enabled: !1 } } }, stroke: { width: 1, colors: ["#24292e"] }, dataLabels: { enabled: !1 }, tooltip: { shared: !0, custom: function(n) {
        var a = n.seriesIndex, o = n.dataPointIndex, d = n.w;
        return t._getBoxTooltip(d, a, o, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
      } }, markers: { size: 5, strokeWidth: 1, strokeColors: "#111" }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "rangeBar", value: function() {
      return { chart: { animations: { animateGradually: !1 } }, stroke: { width: 0, lineCap: "square" }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } }, dataLabels: { enabled: !1, formatter: function(t, n) {
        n.ctx;
        var a = n.seriesIndex, o = n.dataPointIndex, d = n.w, f = function() {
          var p = d.globals.seriesRangeStart[a][o];
          return d.globals.seriesRangeEnd[a][o] - p;
        };
        return d.globals.comboCharts ? d.config.series[a].type === "rangeBar" || d.config.series[a].type === "rangeArea" ? f() : t : f();
      }, background: { enabled: !1 }, style: { colors: ["#fff"] } }, markers: { size: 10 }, tooltip: { shared: !1, followCursor: !0, custom: function(t) {
        return t.w.config.plotOptions && t.w.config.plotOptions.bar && t.w.config.plotOptions.bar.horizontal ? function(n) {
          var a = It(m(m({}, n), {}, { isTimeline: !0 })), o = a.color, d = a.seriesName, f = a.ylabel, p = a.startVal, y = a.endVal;
          return Jt(m(m({}, n), {}, { color: o, seriesName: d, ylabel: f, start: p, end: y }));
        }(t) : function(n) {
          var a = It(n), o = a.color, d = a.seriesName, f = a.ylabel, p = a.start, y = a.end;
          return Jt(m(m({}, n), {}, { color: o, seriesName: d, ylabel: f, start: p, end: y }));
        }(t);
      } }, xaxis: { tickPlacement: "between", tooltip: { enabled: !1 }, crosshairs: { stroke: { width: 0 } } } };
    } }, { key: "dumbbell", value: function(t) {
      var n, a;
      return (n = t.plotOptions.bar) !== null && n !== void 0 && n.barHeight || (t.plotOptions.bar.barHeight = 2), (a = t.plotOptions.bar) !== null && a !== void 0 && a.columnWidth || (t.plotOptions.bar.columnWidth = 2), t;
    } }, { key: "area", value: function() {
      return { stroke: { width: 4, fill: { type: "solid", gradient: { inverseColors: !1, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } } }, fill: { type: "gradient", gradient: { inverseColors: !1, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: !1 } };
    } }, { key: "rangeArea", value: function() {
      return { stroke: { curve: "straight", width: 0 }, fill: { type: "solid", opacity: 0.6 }, markers: { size: 0 }, states: { hover: { filter: { type: "none" } }, active: { filter: { type: "none" } } }, tooltip: { intersect: !1, shared: !0, followCursor: !0, custom: function(t) {
        return function(n) {
          var a = It(n), o = a.color, d = a.seriesName, f = a.ylabel, p = a.start, y = a.end;
          return Jt(m(m({}, n), {}, { color: o, seriesName: d, ylabel: f, start: p, end: y }));
        }(t);
      } } };
    } }, { key: "brush", value: function(t) {
      return K.extend(t, { chart: { toolbar: { autoSelected: "selection", show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !1 }, stroke: { width: 1 }, tooltip: { enabled: !1 }, xaxis: { tooltip: { enabled: !1 } } });
    } }, { key: "stacked100", value: function(t) {
      t.dataLabels = t.dataLabels || {}, t.dataLabels.formatter = t.dataLabels.formatter || void 0;
      var n = t.dataLabels.formatter;
      return t.yaxis.forEach(function(a, o) {
        t.yaxis[o].min = 0, t.yaxis[o].max = 100;
      }), t.chart.type === "bar" && (t.dataLabels.formatter = n || function(a) {
        return typeof a == "number" && a ? a.toFixed(0) + "%" : a;
      }), t;
    } }, { key: "stackedBars", value: function() {
      var t = this.bar();
      return m(m({}, t), {}, { plotOptions: m(m({}, t.plotOptions), {}, { bar: m(m({}, t.plotOptions.bar), {}, { borderRadiusApplication: "end", borderRadiusWhenStacked: "last" }) }) });
    } }, { key: "convertCatToNumeric", value: function(t) {
      return t.xaxis.convertedCatToNumeric = !0, t;
    } }, { key: "convertCatToNumericXaxis", value: function(t, n, a) {
      t.xaxis.type = "numeric", t.xaxis.labels = t.xaxis.labels || {}, t.xaxis.labels.formatter = t.xaxis.labels.formatter || function(f) {
        return K.isNumber(f) ? Math.floor(f) : f;
      };
      var o = t.xaxis.labels.formatter, d = t.xaxis.categories && t.xaxis.categories.length ? t.xaxis.categories : t.labels;
      return a && a.length && (d = a.map(function(f) {
        return Array.isArray(f) ? f : String(f);
      })), d && d.length && (t.xaxis.labels.formatter = function(f) {
        return K.isNumber(f) ? o(d[Math.floor(f) - 1]) : o(f);
      }), t.xaxis.categories = [], t.labels = [], t.xaxis.tickAmount = t.xaxis.tickAmount || "dataPoints", t;
    } }, { key: "bubble", value: function() {
      return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: !1, intersect: !0 }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: !0, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
    } }, { key: "scatter", value: function() {
      return { dataLabels: { enabled: !1 }, tooltip: { shared: !1, intersect: !0 }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
    } }, { key: "heatmap", value: function() {
      return { chart: { stacked: !1 }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: !0, marker: { show: !1 }, x: { show: !1 } }, legend: { position: "top", markers: { shape: "square", size: 10, offsetY: 2 } }, grid: { padding: { right: 20 } } };
    } }, { key: "treemap", value: function() {
      return { chart: { zoom: { enabled: !1 } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } }, stroke: { show: !0, width: 2, colors: ["#fff"] }, legend: { show: !1 }, fill: { gradient: { stops: [0, 100] } }, tooltip: { followCursor: !0, x: { show: !1 } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: !1 }, tooltip: { enabled: !1 } } };
    } }, { key: "pie", value: function() {
      return { chart: { toolbar: { show: !1 } }, plotOptions: { pie: { donut: { labels: { show: !1 } } } }, dataLabels: { formatter: function(t) {
        return t.toFixed(1) + "%";
      }, style: { colors: ["#fff"] }, background: { enabled: !1 }, dropShadow: { enabled: !0 } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" } };
    } }, { key: "donut", value: function() {
      return { chart: { toolbar: { show: !1 } }, dataLabels: { formatter: function(t) {
        return t.toFixed(1) + "%";
      }, style: { colors: ["#fff"] }, background: { enabled: !1 }, dropShadow: { enabled: !0 } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" } };
    } }, { key: "polarArea", value: function() {
      return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6, { chart: { toolbar: { show: !1 } }, dataLabels: { formatter: function(t) {
        return t.toFixed(1) + "%";
      }, enabled: !1 }, stroke: { show: !0, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" } };
    } }, { key: "radar", value: function() {
      return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: !1, style: { fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 3, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: !1, intersect: !0, followCursor: !0 }, grid: { show: !1 }, xaxis: { labels: { formatter: function(t) {
        return t;
      }, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, tooltip: { enabled: !1 }, crosshairs: { show: !1 } } };
    } }, { key: "radialBar", value: function() {
      return { chart: { animations: { dynamicAnimation: { enabled: !0, speed: 800 } }, toolbar: { show: !1 } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: !1, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: !1, position: "right" }, tooltip: { enabled: !1, fillSeriesColor: !0 } };
    } }, { key: "_getBoxTooltip", value: function(t, n, a, o, d) {
      var f = t.globals.seriesCandleO[n][a], p = t.globals.seriesCandleH[n][a], y = t.globals.seriesCandleM[n][a], S = t.globals.seriesCandleL[n][a], C = t.globals.seriesCandleC[n][a];
      return t.config.series[n].type && t.config.series[n].type !== d ? `<div class="apexcharts-custom-tooltip">
          `.concat(t.config.series[n].name ? t.config.series[n].name : "series-" + (n + 1), ": <strong>").concat(t.globals.series[n][a], `</strong>
        </div>`) : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t.config.chart.type, '">') + "<div>".concat(o[0], ': <span class="value">') + f + "</span></div>" + "<div>".concat(o[1], ': <span class="value">') + p + "</span></div>" + (y ? "<div>".concat(o[2], ': <span class="value">') + y + "</span></div>" : "") + "<div>".concat(o[3], ': <span class="value">') + S + "</span></div>" + "<div>".concat(o[4], ': <span class="value">') + C + "</span></div></div>";
    } }]), W;
  }(), pt = function() {
    function W(t) {
      T(this, W), this.opts = t;
    }
    return F(W, [{ key: "init", value: function(t) {
      var n = t.responsiveOverride, a = this.opts, o = new ht(), d = new We(a);
      this.chartType = a.chart.type, a = this.extendYAxis(a), a = this.extendAnnotations(a);
      var f = o.init(), p = {};
      if (a && w(a) === "object") {
        var y, S, C, E, L, M, P, I, B = {};
        B = ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(a.chart.type) !== -1 ? d[a.chart.type]() : d.line(), (y = a.plotOptions) !== null && y !== void 0 && (S = y.bar) !== null && S !== void 0 && S.isFunnel && (B = d.funnel()), a.chart.stacked && a.chart.type === "bar" && (B = d.stackedBars()), (C = a.chart.brush) !== null && C !== void 0 && C.enabled && (B = d.brush(B)), a.chart.stacked && a.chart.stackType === "100%" && (a = d.stacked100(a)), (E = a.plotOptions) !== null && E !== void 0 && (L = E.bar) !== null && L !== void 0 && L.isDumbbell && (a = d.dumbbell(a)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(a), a.xaxis = a.xaxis || window.Apex.xaxis || {}, n || (a.xaxis.convertedCatToNumeric = !1), ((M = (a = this.checkForCatToNumericXAxis(this.chartType, B, a)).chart.sparkline) !== null && M !== void 0 && M.enabled || (P = window.Apex.chart) !== null && P !== void 0 && (I = P.sparkline) !== null && I !== void 0 && I.enabled) && (B = d.sparkline(B)), p = K.extend(f, B);
      }
      var G = K.extend(p, window.Apex);
      return f = K.extend(G, a), f = this.handleUserInputErrors(f);
    } }, { key: "checkForCatToNumericXAxis", value: function(t, n, a) {
      var o, d, f = new We(a), p = (t === "bar" || t === "boxPlot") && ((o = a.plotOptions) === null || o === void 0 || (d = o.bar) === null || d === void 0 ? void 0 : d.horizontal), y = t === "pie" || t === "polarArea" || t === "donut" || t === "radar" || t === "radialBar" || t === "heatmap", S = a.xaxis.type !== "datetime" && a.xaxis.type !== "numeric", C = a.xaxis.tickPlacement ? a.xaxis.tickPlacement : n.xaxis && n.xaxis.tickPlacement;
      return p || y || !S || C === "between" || (a = f.convertCatToNumeric(a)), a;
    } }, { key: "extendYAxis", value: function(t, n) {
      var a = new ht();
      (t.yaxis === void 0 || !t.yaxis || Array.isArray(t.yaxis) && t.yaxis.length === 0) && (t.yaxis = {}), t.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t.yaxis = K.extend(t.yaxis, window.Apex.yaxis)), t.yaxis.constructor !== Array ? t.yaxis = [K.extend(a.yAxis, t.yaxis)] : t.yaxis = K.extendArray(t.yaxis, a.yAxis);
      var o = !1;
      t.yaxis.forEach(function(f) {
        f.logarithmic && (o = !0);
      });
      var d = t.series;
      return n && !d && (d = n.config.series), o && d.length !== t.yaxis.length && d.length && (t.yaxis = d.map(function(f, p) {
        if (f.name || (d[p].name = "series-".concat(p + 1)), t.yaxis[p])
          return t.yaxis[p].seriesName = d[p].name, t.yaxis[p];
        var y = K.extend(a.yAxis, t.yaxis[0]);
        return y.show = !1, y;
      })), o && d.length > 1 && d.length !== t.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes. Please make sure to equalize both."), t;
    } }, { key: "extendAnnotations", value: function(t) {
      return t.annotations === void 0 && (t.annotations = {}, t.annotations.yaxis = [], t.annotations.xaxis = [], t.annotations.points = []), t = this.extendYAxisAnnotations(t), t = this.extendXAxisAnnotations(t), t = this.extendPointAnnotations(t);
    } }, { key: "extendYAxisAnnotations", value: function(t) {
      var n = new ht();
      return t.annotations.yaxis = K.extendArray(t.annotations.yaxis !== void 0 ? t.annotations.yaxis : [], n.yAxisAnnotation), t;
    } }, { key: "extendXAxisAnnotations", value: function(t) {
      var n = new ht();
      return t.annotations.xaxis = K.extendArray(t.annotations.xaxis !== void 0 ? t.annotations.xaxis : [], n.xAxisAnnotation), t;
    } }, { key: "extendPointAnnotations", value: function(t) {
      var n = new ht();
      return t.annotations.points = K.extendArray(t.annotations.points !== void 0 ? t.annotations.points : [], n.pointAnnotation), t;
    } }, { key: "checkForDarkTheme", value: function(t) {
      t.theme && t.theme.mode === "dark" && (t.tooltip || (t.tooltip = {}), t.tooltip.theme !== "light" && (t.tooltip.theme = "dark"), t.chart.foreColor || (t.chart.foreColor = "#f6f7f8"), t.chart.background || (t.chart.background = "#424242"), t.theme.palette || (t.theme.palette = "palette4"));
    } }, { key: "handleUserInputErrors", value: function(t) {
      var n = t;
      if (n.tooltip.shared && n.tooltip.intersect)
        throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
      if (n.chart.type === "bar" && n.plotOptions.bar.horizontal) {
        if (n.yaxis.length > 1)
          throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
        n.yaxis[0].reversed && (n.yaxis[0].opposite = !0), n.xaxis.tooltip.enabled = !1, n.yaxis[0].tooltip.enabled = !1, n.chart.zoom.enabled = !1;
      }
      return n.chart.type !== "bar" && n.chart.type !== "rangeBar" || n.tooltip.shared && n.xaxis.crosshairs.width === "barWidth" && n.series.length > 1 && (n.xaxis.crosshairs.width = "tickWidth"), n.chart.type !== "candlestick" && n.chart.type !== "boxPlot" || n.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(n.chart.type, " chart is not supported.")), n.yaxis[0].reversed = !1), n;
    } }]), W;
  }(), ye = function() {
    function W() {
      T(this, W);
    }
    return F(W, [{ key: "initGlobalVars", value: function(t) {
      t.series = [], t.seriesCandleO = [], t.seriesCandleH = [], t.seriesCandleM = [], t.seriesCandleL = [], t.seriesCandleC = [], t.seriesRangeStart = [], t.seriesRangeEnd = [], t.seriesRange = [], t.seriesPercent = [], t.seriesGoals = [], t.seriesX = [], t.seriesZ = [], t.seriesNames = [], t.seriesTotals = [], t.seriesLog = [], t.seriesColors = [], t.stackedSeriesTotals = [], t.seriesXvalues = [], t.seriesYvalues = [], t.labels = [], t.hasXaxisGroups = !1, t.groups = [], t.hasSeriesGroups = !1, t.seriesGroups = [], t.categoryLabels = [], t.timescaleLabels = [], t.noLabelsProvided = !1, t.resizeTimer = null, t.selectionResizeTimer = null, t.delayedElements = [], t.pointsArray = [], t.dataLabelsRects = [], t.isXNumeric = !1, t.skipLastTimelinelabel = !1, t.skipFirstTimelinelabel = !1, t.isDataXYZ = !1, t.isMultiLineX = !1, t.isMultipleYAxis = !1, t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE, t.minYArr = [], t.maxYArr = [], t.maxX = -Number.MAX_VALUE, t.minX = Number.MAX_VALUE, t.initialMaxX = -Number.MAX_VALUE, t.initialMinX = Number.MAX_VALUE, t.maxDate = 0, t.minDate = Number.MAX_VALUE, t.minZ = Number.MAX_VALUE, t.maxZ = -Number.MAX_VALUE, t.minXDiff = Number.MAX_VALUE, t.yAxisScale = [], t.xAxisScale = null, t.xAxisTicksPositions = [], t.yLabelsCoords = [], t.yTitleCoords = [], t.barPadForNumericAxis = 0, t.padHorizontal = 0, t.xRange = 0, t.yRange = [], t.zRange = 0, t.dataPoints = 0, t.xTickAmount = 0;
    } }, { key: "globalVars", value: function(t) {
      return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: t.markers.size, largestSize: 0 }, animationEnded: !1, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: !1, isExecCalled: !1, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: !1, allSeriesCollapsed: !1, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: !1, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], goldenPadding: 35, invalidLogScale: !1, ignoreYAxisIndexes: [], yAxisSameScaleIndices: [], maxValsInArrayIndex: 0, radialSize: 0, selection: void 0, zoomEnabled: t.chart.toolbar.autoSelected === "zoom" && t.chart.toolbar.tools.zoom && t.chart.zoom.enabled, panEnabled: t.chart.toolbar.autoSelected === "pan" && t.chart.toolbar.tools.pan, selectionEnabled: t.chart.toolbar.autoSelected === "selection" && t.chart.toolbar.tools.selection, yaxis: null, mousedown: !1, lastClientPosition: {}, visibleXRange: void 0, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: !1, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: !0, skipLastTimelinelabel: !1, skipFirstTimelinelabel: !1, delayedElements: [], axisCharts: !0, isDataXYZ: !1, resized: !1, resizeTimer: null, comboCharts: !1, dataChanged: !1, previousPaths: [], allSeriesHasEqualX: !0, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: !1, easing: null, zoomed: !1, gridWidth: 0, gridHeight: 0, rotateXLabels: !1, defaultLabels: !1, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null };
    } }, { key: "init", value: function(t) {
      var n = this.globalVars(t);
      return this.initGlobalVars(n), n.initialConfig = K.extend({}, t), n.initialSeries = K.clone(t.series), n.lastXAxis = K.clone(n.initialConfig.xaxis), n.lastYAxis = K.clone(n.initialConfig.yaxis), n;
    } }]), W;
  }(), je = function() {
    function W(t) {
      T(this, W), this.opts = t;
    }
    return F(W, [{ key: "init", value: function() {
      var t = new pt(this.opts).init({ responsiveOverride: !1 });
      return { config: t, globals: new ye().init(t) };
    } }]), W;
  }(), Qe = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w, this.opts = null, this.seriesIndex = 0;
    }
    return F(W, [{ key: "clippedImgArea", value: function(t) {
      var n = this.w, a = n.config, o = parseInt(n.globals.gridWidth, 10), d = parseInt(n.globals.gridHeight, 10), f = o > d ? o : d, p = t.image, y = 0, S = 0;
      t.width === void 0 && t.height === void 0 ? a.fill.image.width !== void 0 && a.fill.image.height !== void 0 ? (y = a.fill.image.width + 1, S = a.fill.image.height) : (y = f + 1, S = f) : (y = t.width, S = t.height);
      var C = document.createElementNS(n.globals.SVGNS, "pattern");
      re.setAttrs(C, { id: t.patternID, patternUnits: t.patternUnits ? t.patternUnits : "userSpaceOnUse", width: y + "px", height: S + "px" });
      var E = document.createElementNS(n.globals.SVGNS, "image");
      C.appendChild(E), E.setAttributeNS(window.SVG.xlink, "href", p), re.setAttrs(E, { x: 0, y: 0, preserveAspectRatio: "none", width: y + "px", height: S + "px" }), E.style.opacity = t.opacity, n.globals.dom.elDefs.node.appendChild(C);
    } }, { key: "getSeriesIndex", value: function(t) {
      var n = this.w, a = n.config.chart.type;
      return (a === "bar" || a === "rangeBar") && n.config.plotOptions.bar.distributed || a === "heatmap" || a === "treemap" ? this.seriesIndex = t.seriesNumber : this.seriesIndex = t.seriesNumber % n.globals.series.length, this.seriesIndex;
    } }, { key: "fillPath", value: function(t) {
      var n = this.w;
      this.opts = t;
      var a, o, d, f = this.w.config;
      this.seriesIndex = this.getSeriesIndex(t);
      var p = this.getFillColors()[this.seriesIndex];
      n.globals.seriesColors[this.seriesIndex] !== void 0 && (p = n.globals.seriesColors[this.seriesIndex]), typeof p == "function" && (p = p({ seriesIndex: this.seriesIndex, dataPointIndex: t.dataPointIndex, value: t.value, w: n }));
      var y = t.fillType ? t.fillType : this.getFillType(this.seriesIndex), S = Array.isArray(f.fill.opacity) ? f.fill.opacity[this.seriesIndex] : f.fill.opacity;
      t.color && (p = t.color);
      var C = p;
      if (p.indexOf("rgb") === -1 ? p.length < 9 && (C = K.hexToRgba(p, S)) : p.indexOf("rgba") > -1 && (S = K.getOpacityFromRGBA(p)), t.opacity && (S = t.opacity), y === "pattern" && (o = this.handlePatternFill({ fillConfig: t.fillConfig, patternFill: o, fillColor: p, fillOpacity: S, defaultColor: C })), y === "gradient" && (d = this.handleGradientFill({ fillConfig: t.fillConfig, fillColor: p, fillOpacity: S, i: this.seriesIndex })), y === "image") {
        var E = f.fill.image.src, L = t.patternID ? t.patternID : "";
        this.clippedImgArea({ opacity: S, image: Array.isArray(E) ? t.seriesNumber < E.length ? E[t.seriesNumber] : E[0] : E, width: t.width ? t.width : void 0, height: t.height ? t.height : void 0, patternUnits: t.patternUnits, patternID: "pattern".concat(n.globals.cuid).concat(t.seriesNumber + 1).concat(L) }), a = "url(#pattern".concat(n.globals.cuid).concat(t.seriesNumber + 1).concat(L, ")");
      } else
        a = y === "gradient" ? d : y === "pattern" ? o : C;
      return t.solid && (a = C), a;
    } }, { key: "getFillType", value: function(t) {
      var n = this.w;
      return Array.isArray(n.config.fill.type) ? n.config.fill.type[t] : n.config.fill.type;
    } }, { key: "getFillColors", value: function() {
      var t = this.w, n = t.config, a = this.opts, o = [];
      return t.globals.comboCharts ? t.config.series[this.seriesIndex].type === "line" ? Array.isArray(t.globals.stroke.colors) ? o = t.globals.stroke.colors : o.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? o = t.globals.fill.colors : o.push(t.globals.fill.colors) : n.chart.type === "line" ? Array.isArray(t.globals.stroke.colors) ? o = t.globals.stroke.colors : o.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? o = t.globals.fill.colors : o.push(t.globals.fill.colors), a.fillColors !== void 0 && (o = [], Array.isArray(a.fillColors) ? o = a.fillColors.slice() : o.push(a.fillColors)), o;
    } }, { key: "handlePatternFill", value: function(t) {
      var n = t.fillConfig, a = t.patternFill, o = t.fillColor, d = t.fillOpacity, f = t.defaultColor, p = this.w.config.fill;
      n && (p = n);
      var y = this.opts, S = new re(this.ctx), C = Array.isArray(p.pattern.strokeWidth) ? p.pattern.strokeWidth[this.seriesIndex] : p.pattern.strokeWidth, E = o;
      return Array.isArray(p.pattern.style) ? a = p.pattern.style[y.seriesNumber] !== void 0 ? S.drawPattern(p.pattern.style[y.seriesNumber], p.pattern.width, p.pattern.height, E, C, d) : f : a = S.drawPattern(p.pattern.style, p.pattern.width, p.pattern.height, E, C, d), a;
    } }, { key: "handleGradientFill", value: function(t) {
      var n = t.fillColor, a = t.fillOpacity, o = t.fillConfig, d = t.i, f = this.w.config.fill;
      o && (f = m(m({}, f), o));
      var p, y = this.opts, S = new re(this.ctx), C = new K(), E = f.gradient.type, L = n, M = f.gradient.opacityFrom === void 0 ? a : Array.isArray(f.gradient.opacityFrom) ? f.gradient.opacityFrom[d] : f.gradient.opacityFrom;
      L.indexOf("rgba") > -1 && (M = K.getOpacityFromRGBA(L));
      var P = f.gradient.opacityTo === void 0 ? a : Array.isArray(f.gradient.opacityTo) ? f.gradient.opacityTo[d] : f.gradient.opacityTo;
      if (f.gradient.gradientToColors === void 0 || f.gradient.gradientToColors.length === 0)
        p = f.gradient.shade === "dark" ? C.shadeColor(-1 * parseFloat(f.gradient.shadeIntensity), n.indexOf("rgb") > -1 ? K.rgb2hex(n) : n) : C.shadeColor(parseFloat(f.gradient.shadeIntensity), n.indexOf("rgb") > -1 ? K.rgb2hex(n) : n);
      else if (f.gradient.gradientToColors[y.seriesNumber]) {
        var I = f.gradient.gradientToColors[y.seriesNumber];
        p = I, I.indexOf("rgba") > -1 && (P = K.getOpacityFromRGBA(I));
      } else
        p = n;
      if (f.gradient.gradientFrom && (L = f.gradient.gradientFrom), f.gradient.gradientTo && (p = f.gradient.gradientTo), f.gradient.inverseColors) {
        var B = L;
        L = p, p = B;
      }
      return L.indexOf("rgb") > -1 && (L = K.rgb2hex(L)), p.indexOf("rgb") > -1 && (p = K.rgb2hex(p)), S.drawGradient(E, L, p, M, P, y.size, f.gradient.stops, f.gradient.colorStops, d);
    } }]), W;
  }(), kt = function() {
    function W(t, n) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "setGlobalMarkerSize", value: function() {
      var t = this.w;
      if (t.globals.markers.size = Array.isArray(t.config.markers.size) ? t.config.markers.size : [t.config.markers.size], t.globals.markers.size.length > 0) {
        if (t.globals.markers.size.length < t.globals.series.length + 1)
          for (var n = 0; n <= t.globals.series.length; n++)
            t.globals.markers.size[n] === void 0 && t.globals.markers.size.push(t.globals.markers.size[0]);
      } else
        t.globals.markers.size = t.config.series.map(function(a) {
          return t.config.markers.size;
        });
    } }, { key: "plotChartMarkers", value: function(t, n, a, o) {
      var d, f = arguments.length > 4 && arguments[4] !== void 0 && arguments[4], p = this.w, y = n, S = t, C = null, E = new re(this.ctx), L = p.config.markers.discrete && p.config.markers.discrete.length;
      if ((p.globals.markers.size[n] > 0 || f || L) && (C = E.group({ class: f || L ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(p.globals.cuid, ")")), Array.isArray(S.x))
        for (var M = 0; M < S.x.length; M++) {
          var P = a;
          a === 1 && M === 0 && (P = 0), a === 1 && M === 1 && (P = 1);
          var I = "apexcharts-marker";
          if (p.config.chart.type !== "line" && p.config.chart.type !== "area" || p.globals.comboCharts || p.config.tooltip.intersect || (I += " no-pointer-events"), (Array.isArray(p.config.markers.size) ? p.globals.markers.size[n] > 0 : p.config.markers.size > 0) || f || L) {
            K.isNumber(S.y[M]) ? I += " w".concat(K.randomId()) : I = "apexcharts-nullpoint";
            var B = this.getMarkerConfig({ cssClass: I, seriesIndex: n, dataPointIndex: P });
            p.config.series[y].data[P] && (p.config.series[y].data[P].fillColor && (B.pointFillColor = p.config.series[y].data[P].fillColor), p.config.series[y].data[P].strokeColor && (B.pointStrokeColor = p.config.series[y].data[P].strokeColor)), o && (B.pSize = o), (S.x[M] < 0 || S.x[M] > p.globals.gridWidth || S.y[M] < 0 || S.y[M] > p.globals.gridHeight) && (B.pSize = 0), (d = E.drawMarker(S.x[M], S.y[M], B)).attr("rel", P), d.attr("j", P), d.attr("index", n), d.node.setAttribute("default-marker-size", B.pSize), new Ee(this.ctx).setSelectionFilter(d, n, P), this.addEvents(d), C && C.add(d);
          } else
            p.globals.pointsArray[n] === void 0 && (p.globals.pointsArray[n] = []), p.globals.pointsArray[n].push([S.x[M], S.y[M]]);
        }
      return C;
    } }, { key: "getMarkerConfig", value: function(t) {
      var n = t.cssClass, a = t.seriesIndex, o = t.dataPointIndex, d = o === void 0 ? null : o, f = t.finishRadius, p = f === void 0 ? null : f, y = this.w, S = this.getMarkerStyle(a), C = y.globals.markers.size[a], E = y.config.markers;
      return d !== null && E.discrete.length && E.discrete.map(function(L) {
        L.seriesIndex === a && L.dataPointIndex === d && (S.pointStrokeColor = L.strokeColor, S.pointFillColor = L.fillColor, C = L.size, S.pointShape = L.shape);
      }), { pSize: p === null ? C : p, pRadius: E.radius, width: Array.isArray(E.width) ? E.width[a] : E.width, height: Array.isArray(E.height) ? E.height[a] : E.height, pointStrokeWidth: Array.isArray(E.strokeWidth) ? E.strokeWidth[a] : E.strokeWidth, pointStrokeColor: S.pointStrokeColor, pointFillColor: S.pointFillColor, shape: S.pointShape || (Array.isArray(E.shape) ? E.shape[a] : E.shape), class: n, pointStrokeOpacity: Array.isArray(E.strokeOpacity) ? E.strokeOpacity[a] : E.strokeOpacity, pointStrokeDashArray: Array.isArray(E.strokeDashArray) ? E.strokeDashArray[a] : E.strokeDashArray, pointFillOpacity: Array.isArray(E.fillOpacity) ? E.fillOpacity[a] : E.fillOpacity, seriesIndex: a };
    } }, { key: "addEvents", value: function(t) {
      var n = this.w, a = new re(this.ctx);
      t.node.addEventListener("mouseenter", a.pathMouseEnter.bind(this.ctx, t)), t.node.addEventListener("mouseleave", a.pathMouseLeave.bind(this.ctx, t)), t.node.addEventListener("mousedown", a.pathMouseDown.bind(this.ctx, t)), t.node.addEventListener("click", n.config.markers.onClick), t.node.addEventListener("dblclick", n.config.markers.onDblClick), t.node.addEventListener("touchstart", a.pathMouseDown.bind(this.ctx, t), { passive: !0 });
    } }, { key: "getMarkerStyle", value: function(t) {
      var n = this.w, a = n.globals.markers.colors, o = n.config.markers.strokeColor || n.config.markers.strokeColors;
      return { pointStrokeColor: Array.isArray(o) ? o[t] : o, pointFillColor: Array.isArray(a) ? a[t] : a };
    } }]), W;
  }(), mt = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
    }
    return F(W, [{ key: "draw", value: function(t, n, a) {
      var o = this.w, d = new re(this.ctx), f = a.realIndex, p = a.pointsPos, y = a.zRatio, S = a.elParent, C = d.group({ class: "apexcharts-series-markers apexcharts-series-".concat(o.config.chart.type) });
      if (C.attr("clip-path", "url(#gridRectMarkerMask".concat(o.globals.cuid, ")")), Array.isArray(p.x))
        for (var E = 0; E < p.x.length; E++) {
          var L = n + 1, M = !0;
          n === 0 && E === 0 && (L = 0), n === 0 && E === 1 && (L = 1);
          var P = 0, I = o.globals.markers.size[f];
          if (y !== 1 / 0) {
            var B = o.config.plotOptions.bubble;
            I = o.globals.seriesZ[f][L], B.zScaling && (I /= y), B.minBubbleRadius && I < B.minBubbleRadius && (I = B.minBubbleRadius), B.maxBubbleRadius && I > B.maxBubbleRadius && (I = B.maxBubbleRadius);
          }
          o.config.chart.animations.enabled || (P = I);
          var G = p.x[E], Z = p.y[E];
          if (P = P || 0, Z !== null && o.globals.series[f][L] !== void 0 || (M = !1), M) {
            var b = this.drawPoint(G, Z, P, I, f, L, n);
            C.add(b);
          }
          S.add(C);
        }
    } }, { key: "drawPoint", value: function(t, n, a, o, d, f, p) {
      var y = this.w, S = d, C = new we(this.ctx), E = new Ee(this.ctx), L = new Qe(this.ctx), M = new kt(this.ctx), P = new re(this.ctx), I = M.getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: S, dataPointIndex: f, finishRadius: y.config.chart.type === "bubble" || y.globals.comboCharts && y.config.series[d] && y.config.series[d].type === "bubble" ? o : null });
      o = I.pSize;
      var B, G = L.fillPath({ seriesNumber: d, dataPointIndex: f, color: I.pointFillColor, patternUnits: "objectBoundingBox", value: y.globals.series[d][p] });
      if (I.shape === "circle" ? B = P.drawCircle(a) : I.shape !== "square" && I.shape !== "rect" || (B = P.drawRect(0, 0, I.width - I.pointStrokeWidth / 2, I.height - I.pointStrokeWidth / 2, I.pRadius)), y.config.series[S].data[f] && y.config.series[S].data[f].fillColor && (G = y.config.series[S].data[f].fillColor), B.attr({ x: t - I.width / 2 - I.pointStrokeWidth / 2, y: n - I.height / 2 - I.pointStrokeWidth / 2, cx: t, cy: n, fill: G, "fill-opacity": I.pointFillOpacity, stroke: I.pointStrokeColor, r: o, "stroke-width": I.pointStrokeWidth, "stroke-dasharray": I.pointStrokeDashArray, "stroke-opacity": I.pointStrokeOpacity }), y.config.chart.dropShadow.enabled) {
        var Z = y.config.chart.dropShadow;
        E.dropShadow(B, Z, d);
      }
      if (!this.initialAnim || y.globals.dataChanged || y.globals.resized)
        y.globals.animationEnded = !0;
      else {
        var b = y.config.chart.animations.speed;
        C.animateMarker(B, 0, I.shape === "circle" ? o : { width: I.width, height: I.height }, b, y.globals.easing, function() {
          window.setTimeout(function() {
            C.animationCompleted(B);
          }, 100);
        });
      }
      if (y.globals.dataChanged && I.shape === "circle")
        if (this.dynamicAnim) {
          var O, N, X, Q, ee = y.config.chart.animations.dynamicAnimation.speed;
          (Q = y.globals.previousPaths[d] && y.globals.previousPaths[d][p]) != null && (O = Q.x, N = Q.y, X = Q.r !== void 0 ? Q.r : o);
          for (var oe = 0; oe < y.globals.collapsedSeries.length; oe++)
            y.globals.collapsedSeries[oe].index === d && (ee = 1, o = 0);
          t === 0 && n === 0 && (o = 0), C.animateCircle(B, { cx: O, cy: N, r: X }, { cx: t, cy: n, r: o }, ee, y.globals.easing);
        } else
          B.attr({ r: o });
      return B.attr({ rel: f, j: f, index: d, "default-marker-size": o }), E.setSelectionFilter(B, d, f), M.addEvents(B), B.node.classList.add("apexcharts-marker"), B;
    } }, { key: "centerTextInBubble", value: function(t) {
      var n = this.w;
      return { y: t += parseInt(n.config.dataLabels.style.fontSize, 10) / 4 };
    } }]), W;
  }(), Pt = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "dataLabelsCorrection", value: function(t, n, a, o, d, f, p) {
      var y = this.w, S = !1, C = new re(this.ctx).getTextRects(a, p), E = C.width, L = C.height;
      n < 0 && (n = 0), n > y.globals.gridHeight + L && (n = y.globals.gridHeight + L / 2), y.globals.dataLabelsRects[o] === void 0 && (y.globals.dataLabelsRects[o] = []), y.globals.dataLabelsRects[o].push({ x: t, y: n, width: E, height: L });
      var M = y.globals.dataLabelsRects[o].length - 2, P = y.globals.lastDrawnDataLabelsIndexes[o] !== void 0 ? y.globals.lastDrawnDataLabelsIndexes[o][y.globals.lastDrawnDataLabelsIndexes[o].length - 1] : 0;
      if (y.globals.dataLabelsRects[o][M] !== void 0) {
        var I = y.globals.dataLabelsRects[o][P];
        (t > I.x + I.width + 2 || n > I.y + I.height + 2 || t + E < I.x) && (S = !0);
      }
      return (d === 0 || f) && (S = !0), { x: t, y: n, textRects: C, drawnextLabel: S };
    } }, { key: "drawDataLabel", value: function(t) {
      var n = this, a = t.type, o = t.pos, d = t.i, f = t.j, p = t.isRangeStart, y = t.strokeWidth, S = y === void 0 ? 2 : y, C = this.w, E = new re(this.ctx), L = C.config.dataLabels, M = 0, P = 0, I = f, B = null;
      if (!L.enabled || !Array.isArray(o.x))
        return B;
      B = E.group({ class: "apexcharts-data-labels" });
      for (var G = 0; G < o.x.length; G++)
        if (M = o.x[G] + L.offsetX, P = o.y[G] + L.offsetY + S, !isNaN(M)) {
          f === 1 && G === 0 && (I = 0), f === 1 && G === 1 && (I = 1);
          var Z = C.globals.series[d][I];
          a === "rangeArea" && (Z = p ? C.globals.seriesRangeStart[d][I] : C.globals.seriesRangeEnd[d][I]);
          var b = "", O = function(N) {
            return C.config.dataLabels.formatter(N, { ctx: n.ctx, seriesIndex: d, dataPointIndex: I, w: C });
          };
          C.config.chart.type === "bubble" ? (b = O(Z = C.globals.seriesZ[d][I]), P = o.y[G], P = new mt(this.ctx).centerTextInBubble(P, d, I).y) : Z !== void 0 && (b = O(Z)), this.plotDataLabelsText({ x: M, y: P, text: b, i: d, j: I, parent: B, offsetCorrection: !0, dataLabelsConfig: C.config.dataLabels });
        }
      return B;
    } }, { key: "plotDataLabelsText", value: function(t) {
      var n = this.w, a = new re(this.ctx), o = t.x, d = t.y, f = t.i, p = t.j, y = t.text, S = t.textAnchor, C = t.fontSize, E = t.parent, L = t.dataLabelsConfig, M = t.color, P = t.alwaysDrawDataLabel, I = t.offsetCorrection;
      if (!(Array.isArray(n.config.dataLabels.enabledOnSeries) && n.config.dataLabels.enabledOnSeries.indexOf(f) < 0)) {
        var B = { x: o, y: d, drawnextLabel: !0, textRects: null };
        I && (B = this.dataLabelsCorrection(o, d, y, f, p, P, parseInt(L.style.fontSize, 10))), n.globals.zoomed || (o = B.x, d = B.y), B.textRects && (o < -10 - B.textRects.width || o > n.globals.gridWidth + B.textRects.width + 10) && (y = "");
        var G = n.globals.dataLabels.style.colors[f];
        ((n.config.chart.type === "bar" || n.config.chart.type === "rangeBar") && n.config.plotOptions.bar.distributed || n.config.dataLabels.distributed) && (G = n.globals.dataLabels.style.colors[p]), typeof G == "function" && (G = G({ series: n.globals.series, seriesIndex: f, dataPointIndex: p, w: n })), M && (G = M);
        var Z = L.offsetX, b = L.offsetY;
        if (n.config.chart.type !== "bar" && n.config.chart.type !== "rangeBar" || (Z = 0, b = 0), B.drawnextLabel) {
          var O = a.drawText({ width: 100, height: parseInt(L.style.fontSize, 10), x: o + Z, y: d + b, foreColor: G, textAnchor: S || L.textAnchor, text: y, fontSize: C || L.style.fontSize, fontFamily: L.style.fontFamily, fontWeight: L.style.fontWeight || "normal" });
          if (O.attr({ class: "apexcharts-datalabel", cx: o, cy: d }), L.dropShadow.enabled) {
            var N = L.dropShadow;
            new Ee(this.ctx).dropShadow(O, N);
          }
          E.add(O), n.globals.lastDrawnDataLabelsIndexes[f] === void 0 && (n.globals.lastDrawnDataLabelsIndexes[f] = []), n.globals.lastDrawnDataLabelsIndexes[f].push(p);
        }
      }
    } }, { key: "addBackgroundToDataLabel", value: function(t, n) {
      var a = this.w, o = a.config.dataLabels.background, d = o.padding, f = o.padding / 2, p = n.width, y = n.height, S = new re(this.ctx).drawRect(n.x - d, n.y - f / 2, p + 2 * d, y + f, o.borderRadius, a.config.chart.background === "transparent" ? "#fff" : a.config.chart.background, o.opacity, o.borderWidth, o.borderColor);
      return o.dropShadow.enabled && new Ee(this.ctx).dropShadow(S, o.dropShadow), S;
    } }, { key: "dataLabelsBackground", value: function() {
      var t = this.w;
      if (t.config.chart.type !== "bubble")
        for (var n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), a = 0; a < n.length; a++) {
          var o = n[a], d = o.getBBox(), f = null;
          if (d.width && d.height && (f = this.addBackgroundToDataLabel(o, d)), f) {
            o.parentNode.insertBefore(f.node, o);
            var p = o.getAttribute("fill");
            t.config.chart.animations.enabled && !t.globals.resized && !t.globals.dataChanged ? f.animate().attr({ fill: p }) : f.attr({ fill: p }), o.setAttribute("fill", t.config.dataLabels.background.foreColor);
          }
        }
    } }, { key: "bringForward", value: function() {
      for (var t = this.w, n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), a = t.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), o = 0; o < n.length; o++)
        a && a.insertBefore(n[o], a.nextSibling);
    } }]), W;
  }(), st = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w, this.legendInactiveClass = "legend-mouseover-inactive";
    }
    return F(W, [{ key: "getAllSeriesEls", value: function() {
      return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
    } }, { key: "getSeriesByName", value: function(t) {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(K.escapeString(t), "']"));
    } }, { key: "isSeriesHidden", value: function(t) {
      var n = this.getSeriesByName(t), a = parseInt(n.getAttribute("data:realIndex"), 10);
      return { isHidden: n.classList.contains("apexcharts-series-collapsed"), realIndex: a };
    } }, { key: "addCollapsedClassToSeries", value: function(t, n) {
      var a = this.w;
      function o(d) {
        for (var f = 0; f < d.length; f++)
          d[f].index === n && t.node.classList.add("apexcharts-series-collapsed");
      }
      o(a.globals.collapsedSeries), o(a.globals.ancillaryCollapsedSeries);
    } }, { key: "toggleSeries", value: function(t) {
      var n = this.isSeriesHidden(t);
      return this.ctx.legend.legendHelpers.toggleDataSeries(n.realIndex, n.isHidden), n.isHidden;
    } }, { key: "showSeries", value: function(t) {
      var n = this.isSeriesHidden(t);
      n.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(n.realIndex, !0);
    } }, { key: "hideSeries", value: function(t) {
      var n = this.isSeriesHidden(t);
      n.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(n.realIndex, !1);
    } }, { key: "resetSeries", value: function() {
      var t = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], a = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], o = this.w, d = K.clone(o.globals.initialSeries);
      o.globals.previousPaths = [], a ? (o.globals.collapsedSeries = [], o.globals.ancillaryCollapsedSeries = [], o.globals.collapsedSeriesIndices = [], o.globals.ancillaryCollapsedSeriesIndices = []) : d = this.emptyCollapsedSeries(d), o.config.series = d, t && (n && (o.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(d, o.config.chart.animations.dynamicAnimation.enabled));
    } }, { key: "emptyCollapsedSeries", value: function(t) {
      for (var n = this.w, a = 0; a < t.length; a++)
        n.globals.collapsedSeriesIndices.indexOf(a) > -1 && (t[a].data = []);
      return t;
    } }, { key: "toggleSeriesOnHover", value: function(t, n) {
      var a = this.w;
      n || (n = t.target);
      var o = a.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
      if (t.type === "mousemove") {
        var d = parseInt(n.getAttribute("rel"), 10) - 1, f = null, p = null;
        a.globals.axisCharts || a.config.chart.type === "radialBar" ? a.globals.axisCharts ? (f = a.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(d, "']")), p = a.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(d, "']"))) : f = a.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(d + 1, "']")) : f = a.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(d + 1, "'] path"));
        for (var y = 0; y < o.length; y++)
          o[y].classList.add(this.legendInactiveClass);
        f !== null && (a.globals.axisCharts || f.parentNode.classList.remove(this.legendInactiveClass), f.classList.remove(this.legendInactiveClass), p !== null && p.classList.remove(this.legendInactiveClass));
      } else if (t.type === "mouseout")
        for (var S = 0; S < o.length; S++)
          o[S].classList.remove(this.legendInactiveClass);
    } }, { key: "highlightRangeInSeries", value: function(t, n) {
      var a = this, o = this.w, d = o.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), f = function(y) {
        for (var S = 0; S < d.length; S++)
          d[S].classList[y](a.legendInactiveClass);
      };
      if (t.type === "mousemove") {
        var p = parseInt(n.getAttribute("rel"), 10) - 1;
        f("add"), function(y) {
          for (var S = 0; S < d.length; S++) {
            var C = parseInt(d[S].getAttribute("val"), 10);
            C >= y.from && C <= y.to && d[S].classList.remove(a.legendInactiveClass);
          }
        }(o.config.plotOptions.heatmap.colorScale.ranges[p]);
      } else
        t.type === "mouseout" && f("remove");
    } }, { key: "getActiveConfigSeriesIndex", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "asc", n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], a = this.w, o = 0;
      if (a.config.series.length > 1) {
        for (var d = a.config.series.map(function(p, y) {
          return p.data && p.data.length > 0 && a.globals.collapsedSeriesIndices.indexOf(y) === -1 && (!a.globals.comboCharts || n.length === 0 || n.length && n.indexOf(a.config.series[y].type) > -1) ? y : -1;
        }), f = t === "asc" ? 0 : d.length - 1; t === "asc" ? f < d.length : f >= 0; t === "asc" ? f++ : f--)
          if (d[f] !== -1) {
            o = d[f];
            break;
          }
      }
      return o;
    } }, { key: "getBarSeriesIndices", value: function() {
      return this.w.globals.comboCharts ? this.w.config.series.map(function(t, n) {
        return t.type === "bar" || t.type === "column" ? n : -1;
      }).filter(function(t) {
        return t !== -1;
      }) : this.w.config.series.map(function(t, n) {
        return n;
      });
    } }, { key: "getPreviousPaths", value: function() {
      var t = this.w;
      function n(f, p, y) {
        for (var S = f[p].childNodes, C = { type: y, paths: [], realIndex: f[p].getAttribute("data:realIndex") }, E = 0; E < S.length; E++)
          if (S[E].hasAttribute("pathTo")) {
            var L = S[E].getAttribute("pathTo");
            C.paths.push({ d: L });
          }
        t.globals.previousPaths.push(C);
      }
      t.globals.previousPaths = [], ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function(f) {
        for (var p, y = (p = f, t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(p, "-series .apexcharts-series"))), S = 0; S < y.length; S++)
          n(y, S, f);
      }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
      var a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type, " .apexcharts-series"));
      if (a.length > 0)
        for (var o = function(f) {
          for (var p = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(f, "'] rect")), y = [], S = function(E) {
            var L = function(P) {
              return p[E].getAttribute(P);
            }, M = { x: parseFloat(L("x")), y: parseFloat(L("y")), width: parseFloat(L("width")), height: parseFloat(L("height")) };
            y.push({ rect: M, color: p[E].getAttribute("color") });
          }, C = 0; C < p.length; C++)
            S(C);
          t.globals.previousPaths.push(y);
        }, d = 0; d < a.length; d++)
          o(d);
      t.globals.axisCharts || (t.globals.previousPaths = t.globals.series);
    } }, { key: "handlePrevBubbleScatterPaths", value: function(t) {
      var n = this.w, a = n.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series"));
      if (a.length > 0)
        for (var o = 0; o < a.length; o++) {
          for (var d = n.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series[data\\:realIndex='").concat(o, "'] circle")), f = [], p = 0; p < d.length; p++)
            f.push({ x: d[p].getAttribute("cx"), y: d[p].getAttribute("cy"), r: d[p].getAttribute("r") });
          n.globals.previousPaths.push(f);
        }
    } }, { key: "clearPreviousPaths", value: function() {
      var t = this.w;
      t.globals.previousPaths = [], t.globals.allSeriesCollapsed = !1;
    } }, { key: "handleNoData", value: function() {
      var t = this.w, n = t.config.noData, a = new re(this.ctx), o = t.globals.svgWidth / 2, d = t.globals.svgHeight / 2, f = "middle";
      if (t.globals.noData = !0, t.globals.animationEnded = !0, n.align === "left" ? (o = 10, f = "start") : n.align === "right" && (o = t.globals.svgWidth - 10, f = "end"), n.verticalAlign === "top" ? d = 50 : n.verticalAlign === "bottom" && (d = t.globals.svgHeight - 50), o += n.offsetX, d = d + parseInt(n.style.fontSize, 10) + 2 + n.offsetY, n.text !== void 0 && n.text !== "") {
        var p = a.drawText({ x: o, y: d, text: n.text, textAnchor: f, fontSize: n.style.fontSize, fontFamily: n.style.fontFamily, foreColor: n.style.color, opacity: 1, class: "apexcharts-text-nodata" });
        t.globals.dom.Paper.add(p);
      }
    } }, { key: "setNullSeriesToZeroValues", value: function(t) {
      for (var n = this.w, a = 0; a < t.length; a++)
        if (t[a].length === 0)
          for (var o = 0; o < t[n.globals.maxValsInArrayIndex].length; o++)
            t[a].push(0);
      return t;
    } }, { key: "hasAllSeriesEqualX", value: function() {
      for (var t = !0, n = this.w, a = this.filteredSeriesX(), o = 0; o < a.length - 1; o++)
        if (a[o][0] !== a[o + 1][0]) {
          t = !1;
          break;
        }
      return n.globals.allSeriesHasEqualX = t, t;
    } }, { key: "filteredSeriesX", value: function() {
      var t = this.w.globals.seriesX.map(function(n) {
        return n.length > 0 ? n : [];
      });
      return t;
    } }]), W;
  }(), Nt = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new me(this.ctx);
    }
    return F(W, [{ key: "isMultiFormat", value: function() {
      return this.isFormatXY() || this.isFormat2DArray();
    } }, { key: "isFormatXY", value: function() {
      var t = this.w.config.series.slice(), n = new st(this.ctx);
      if (this.activeSeriesIndex = n.getActiveConfigSeriesIndex(), t[this.activeSeriesIndex].data !== void 0 && t[this.activeSeriesIndex].data.length > 0 && t[this.activeSeriesIndex].data[0] !== null && t[this.activeSeriesIndex].data[0].x !== void 0 && t[this.activeSeriesIndex].data[0] !== null)
        return !0;
    } }, { key: "isFormat2DArray", value: function() {
      var t = this.w.config.series.slice(), n = new st(this.ctx);
      if (this.activeSeriesIndex = n.getActiveConfigSeriesIndex(), t[this.activeSeriesIndex].data !== void 0 && t[this.activeSeriesIndex].data.length > 0 && t[this.activeSeriesIndex].data[0] !== void 0 && t[this.activeSeriesIndex].data[0] !== null && t[this.activeSeriesIndex].data[0].constructor === Array)
        return !0;
    } }, { key: "handleFormat2DArray", value: function(t, n) {
      for (var a = this.w.config, o = this.w.globals, d = a.chart.type === "boxPlot" || a.series[n].type === "boxPlot", f = 0; f < t[n].data.length; f++)
        if (t[n].data[f][1] !== void 0 && (Array.isArray(t[n].data[f][1]) && t[n].data[f][1].length === 4 && !d ? this.twoDSeries.push(K.parseNumber(t[n].data[f][1][3])) : t[n].data[f].length >= 5 ? this.twoDSeries.push(K.parseNumber(t[n].data[f][4])) : this.twoDSeries.push(K.parseNumber(t[n].data[f][1])), o.dataFormatXNumeric = !0), a.xaxis.type === "datetime") {
          var p = new Date(t[n].data[f][0]);
          p = new Date(p).getTime(), this.twoDSeriesX.push(p);
        } else
          this.twoDSeriesX.push(t[n].data[f][0]);
      for (var y = 0; y < t[n].data.length; y++)
        t[n].data[y][2] !== void 0 && (this.threeDSeries.push(t[n].data[y][2]), o.isDataXYZ = !0);
    } }, { key: "handleFormatXY", value: function(t, n) {
      var a = this.w.config, o = this.w.globals, d = new Ze(this.ctx), f = n;
      o.collapsedSeriesIndices.indexOf(n) > -1 && (f = this.activeSeriesIndex);
      for (var p = 0; p < t[n].data.length; p++)
        t[n].data[p].y !== void 0 && (Array.isArray(t[n].data[p].y) ? this.twoDSeries.push(K.parseNumber(t[n].data[p].y[t[n].data[p].y.length - 1])) : this.twoDSeries.push(K.parseNumber(t[n].data[p].y))), t[n].data[p].goals !== void 0 && Array.isArray(t[n].data[p].goals) ? (this.seriesGoals[n] === void 0 && (this.seriesGoals[n] = []), this.seriesGoals[n].push(t[n].data[p].goals)) : (this.seriesGoals[n] === void 0 && (this.seriesGoals[n] = []), this.seriesGoals[n].push(null));
      for (var y = 0; y < t[f].data.length; y++) {
        var S = typeof t[f].data[y].x == "string", C = Array.isArray(t[f].data[y].x), E = !C && !!d.isValidDate(t[f].data[y].x.toString());
        if (S || E)
          if (S || a.xaxis.convertedCatToNumeric) {
            var L = o.isBarHorizontal && o.isRangeData;
            a.xaxis.type !== "datetime" || L ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[f].data[y].x)) : this.twoDSeriesX.push(d.parseDate(t[f].data[y].x));
          } else
            a.xaxis.type === "datetime" ? this.twoDSeriesX.push(d.parseDate(t[f].data[y].x.toString())) : (o.dataFormatXNumeric = !0, o.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(t[f].data[y].x)));
        else
          C ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[f].data[y].x)) : (o.isXNumeric = !0, o.dataFormatXNumeric = !0, this.twoDSeriesX.push(t[f].data[y].x));
      }
      if (t[n].data[0] && t[n].data[0].z !== void 0) {
        for (var M = 0; M < t[n].data.length; M++)
          this.threeDSeries.push(t[n].data[M].z);
        o.isDataXYZ = !0;
      }
    } }, { key: "handleRangeData", value: function(t, n) {
      var a = this.w.globals, o = {};
      return this.isFormat2DArray() ? o = this.handleRangeDataFormat("array", t, n) : this.isFormatXY() && (o = this.handleRangeDataFormat("xy", t, n)), a.seriesRangeStart.push(o.start), a.seriesRangeEnd.push(o.end), a.seriesRange.push(o.rangeUniques), a.seriesRange.forEach(function(d, f) {
        d && d.forEach(function(p, y) {
          p.y.forEach(function(S, C) {
            for (var E = 0; E < p.y.length; E++)
              if (C !== E) {
                var L = S.y1, M = S.y2, P = p.y[E].y1;
                L <= p.y[E].y2 && P <= M && (p.overlaps.indexOf(S.rangeName) < 0 && p.overlaps.push(S.rangeName), p.overlaps.indexOf(p.y[E].rangeName) < 0 && p.overlaps.push(p.y[E].rangeName));
              }
          });
        });
      }), o;
    } }, { key: "handleCandleStickBoxData", value: function(t, n) {
      var a = this.w.globals, o = {};
      return this.isFormat2DArray() ? o = this.handleCandleStickBoxDataFormat("array", t, n) : this.isFormatXY() && (o = this.handleCandleStickBoxDataFormat("xy", t, n)), a.seriesCandleO[n] = o.o, a.seriesCandleH[n] = o.h, a.seriesCandleM[n] = o.m, a.seriesCandleL[n] = o.l, a.seriesCandleC[n] = o.c, o;
    } }, { key: "handleRangeDataFormat", value: function(t, n, a) {
      var o = [], d = [], f = n[a].data.filter(function(C, E, L) {
        return E === L.findIndex(function(M) {
          return M.x === C.x;
        });
      }).map(function(C, E) {
        return { x: C.x, overlaps: [], y: [] };
      });
      if (t === "array")
        for (var p = 0; p < n[a].data.length; p++)
          Array.isArray(n[a].data[p]) ? (o.push(n[a].data[p][1][0]), d.push(n[a].data[p][1][1])) : (o.push(n[a].data[p]), d.push(n[a].data[p]));
      else if (t === "xy")
        for (var y = function(C) {
          var E = Array.isArray(n[a].data[C].y), L = K.randomId(), M = n[a].data[C].x, P = { y1: E ? n[a].data[C].y[0] : n[a].data[C].y, y2: E ? n[a].data[C].y[1] : n[a].data[C].y, rangeName: L };
          n[a].data[C].rangeName = L;
          var I = f.findIndex(function(B) {
            return B.x === M;
          });
          f[I].y.push(P), o.push(P.y1), d.push(P.y2);
        }, S = 0; S < n[a].data.length; S++)
          y(S);
      return { start: o, end: d, rangeUniques: f };
    } }, { key: "handleCandleStickBoxDataFormat", value: function(t, n, a) {
      var o = this.w, d = o.config.chart.type === "boxPlot" || o.config.series[a].type === "boxPlot", f = [], p = [], y = [], S = [], C = [];
      if (t === "array")
        if (d && n[a].data[0].length === 6 || !d && n[a].data[0].length === 5)
          for (var E = 0; E < n[a].data.length; E++)
            f.push(n[a].data[E][1]), p.push(n[a].data[E][2]), d ? (y.push(n[a].data[E][3]), S.push(n[a].data[E][4]), C.push(n[a].data[E][5])) : (S.push(n[a].data[E][3]), C.push(n[a].data[E][4]));
        else
          for (var L = 0; L < n[a].data.length; L++)
            Array.isArray(n[a].data[L][1]) && (f.push(n[a].data[L][1][0]), p.push(n[a].data[L][1][1]), d ? (y.push(n[a].data[L][1][2]), S.push(n[a].data[L][1][3]), C.push(n[a].data[L][1][4])) : (S.push(n[a].data[L][1][2]), C.push(n[a].data[L][1][3])));
      else if (t === "xy")
        for (var M = 0; M < n[a].data.length; M++)
          Array.isArray(n[a].data[M].y) && (f.push(n[a].data[M].y[0]), p.push(n[a].data[M].y[1]), d ? (y.push(n[a].data[M].y[2]), S.push(n[a].data[M].y[3]), C.push(n[a].data[M].y[4])) : (S.push(n[a].data[M].y[2]), C.push(n[a].data[M].y[3])));
      return { o: f, h: p, m: y, l: S, c: C };
    } }, { key: "parseDataAxisCharts", value: function(t) {
      var n, a = this, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.ctx, d = this.w.config, f = this.w.globals, p = new Ze(o), y = d.labels.length > 0 ? d.labels.slice() : d.xaxis.categories.slice();
      if (f.isRangeBar = d.chart.type === "rangeBar" && f.isBarHorizontal, f.hasXaxisGroups = d.xaxis.type === "category" && d.xaxis.group.groups.length > 0, f.hasXaxisGroups && (f.groups = d.xaxis.group.groups), f.hasSeriesGroups = (n = t[0]) === null || n === void 0 ? void 0 : n.group, f.hasSeriesGroups) {
        var S = [], C = ue(new Set(t.map(function(P) {
          return P.group;
        })));
        t.forEach(function(P, I) {
          var B = C.indexOf(P.group);
          S[B] || (S[B] = []), S[B].push(P.name);
        }), f.seriesGroups = S;
      }
      for (var E = function() {
        for (var P = 0; P < y.length; P++)
          if (typeof y[P] == "string") {
            if (!p.isValidDate(y[P]))
              throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
            a.twoDSeriesX.push(p.parseDate(y[P]));
          } else
            a.twoDSeriesX.push(y[P]);
      }, L = 0; L < t.length; L++) {
        if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], t[L].data === void 0)
          return void console.error("It is a possibility that you may have not included 'data' property in series.");
        if (d.chart.type !== "rangeBar" && d.chart.type !== "rangeArea" && t[L].type !== "rangeBar" && t[L].type !== "rangeArea" || (f.isRangeData = !0, f.isComboCharts ? t[L].type !== "rangeBar" && t[L].type !== "rangeArea" || this.handleRangeData(t, L) : d.chart.type !== "rangeBar" && d.chart.type !== "rangeArea" || this.handleRangeData(t, L)), this.isMultiFormat())
          this.isFormat2DArray() ? this.handleFormat2DArray(t, L) : this.isFormatXY() && this.handleFormatXY(t, L), d.chart.type !== "candlestick" && t[L].type !== "candlestick" && d.chart.type !== "boxPlot" && t[L].type !== "boxPlot" || this.handleCandleStickBoxData(t, L), f.series.push(this.twoDSeries), f.labels.push(this.twoDSeriesX), f.seriesX.push(this.twoDSeriesX), f.seriesGoals = this.seriesGoals, L !== this.activeSeriesIndex || this.fallbackToCategory || (f.isXNumeric = !0);
        else {
          d.xaxis.type === "datetime" ? (f.isXNumeric = !0, E(), f.seriesX.push(this.twoDSeriesX)) : d.xaxis.type === "numeric" && (f.isXNumeric = !0, y.length > 0 && (this.twoDSeriesX = y, f.seriesX.push(this.twoDSeriesX))), f.labels.push(this.twoDSeriesX);
          var M = t[L].data.map(function(P) {
            return K.parseNumber(P);
          });
          f.series.push(M);
        }
        f.seriesZ.push(this.threeDSeries), t[L].name !== void 0 ? f.seriesNames.push(t[L].name) : f.seriesNames.push("series-" + parseInt(L + 1, 10)), t[L].color !== void 0 ? f.seriesColors.push(t[L].color) : f.seriesColors.push(void 0);
      }
      return this.w;
    } }, { key: "parseDataNonAxisCharts", value: function(t) {
      var n = this.w.globals, a = this.w.config;
      n.series = t.slice(), n.seriesNames = a.labels.slice();
      for (var o = 0; o < n.series.length; o++)
        n.seriesNames[o] === void 0 && n.seriesNames.push("series-" + (o + 1));
      return this.w;
    } }, { key: "handleExternalLabelsData", value: function(t) {
      var n = this.w.config, a = this.w.globals;
      n.xaxis.categories.length > 0 ? a.labels = n.xaxis.categories : n.labels.length > 0 ? a.labels = n.labels.slice() : this.fallbackToCategory ? (a.labels = a.labels[0], a.seriesRange.length && (a.seriesRange.map(function(o) {
        o.forEach(function(d) {
          a.labels.indexOf(d.x) < 0 && d.x && a.labels.push(d.x);
        });
      }), a.labels = Array.from(new Set(a.labels.map(JSON.stringify)), JSON.parse)), n.xaxis.convertedCatToNumeric && (new We(n).convertCatToNumericXaxis(n, this.ctx, a.seriesX[0]), this._generateExternalLabels(t))) : this._generateExternalLabels(t);
    } }, { key: "_generateExternalLabels", value: function(t) {
      var n = this.w.globals, a = this.w.config, o = [];
      if (n.axisCharts) {
        if (n.series.length > 0)
          if (this.isFormatXY())
            for (var d = a.series.map(function(E, L) {
              return E.data.filter(function(M, P, I) {
                return I.findIndex(function(B) {
                  return B.x === M.x;
                }) === P;
              });
            }), f = d.reduce(function(E, L, M, P) {
              return P[E].length > L.length ? E : M;
            }, 0), p = 0; p < d[f].length; p++)
              o.push(p + 1);
          else
            for (var y = 0; y < n.series[n.maxValsInArrayIndex].length; y++)
              o.push(y + 1);
        n.seriesX = [];
        for (var S = 0; S < t.length; S++)
          n.seriesX.push(o);
        this.w.globals.isBarHorizontal || (n.isXNumeric = !0);
      }
      if (o.length === 0) {
        o = n.axisCharts ? [] : n.series.map(function(E, L) {
          return L + 1;
        });
        for (var C = 0; C < t.length; C++)
          n.seriesX.push(o);
      }
      n.labels = o, a.xaxis.convertedCatToNumeric && (n.categoryLabels = o.map(function(E) {
        return a.xaxis.labels.formatter(E);
      })), n.noLabelsProvided = !0;
    } }, { key: "parseData", value: function(t) {
      var n = this.w, a = n.config, o = n.globals;
      if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), o.axisCharts ? (this.parseDataAxisCharts(t), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(t), a.chart.stacked) {
        var d = new st(this.ctx);
        o.series = d.setNullSeriesToZeroValues(o.series);
      }
      this.coreUtils.getSeriesTotals(), o.axisCharts && (o.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals()), this.coreUtils.getPercentSeries(), o.dataFormatXNumeric || o.isXNumeric && (a.xaxis.type !== "numeric" || a.labels.length !== 0 || a.xaxis.categories.length !== 0) || this.handleExternalLabelsData(t);
      for (var f = this.coreUtils.getCategoryLabels(o.labels), p = 0; p < f.length; p++)
        if (Array.isArray(f[p])) {
          o.isMultiLineX = !0;
          break;
        }
    } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
      var t = this, n = this.w;
      n.globals.ignoreYAxisIndexes = n.globals.collapsedSeries.map(function(a, o) {
        if (t.w.globals.isMultipleYAxis && !n.config.chart.stacked)
          return a.index;
      });
    } }]), W;
  }(), Et = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "getLabel", value: function(t, n, a, o) {
      var d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "12px", p = !(arguments.length > 6 && arguments[6] !== void 0) || arguments[6], y = this.w, S = t[o] === void 0 ? "" : t[o], C = S, E = y.globals.xLabelFormatter, L = y.config.xaxis.labels.formatter, M = !1, P = new Tt(this.ctx), I = S;
      p && (C = P.xLabelFormat(E, S, I, { i: o, dateFormatter: new Ze(this.ctx).formatDate, w: y }), L !== void 0 && (C = L(S, t[o], { i: o, dateFormatter: new Ze(this.ctx).formatDate, w: y })));
      var B, G;
      n.length > 0 ? (B = n[o].unit, G = null, n.forEach(function(N) {
        N.unit === "month" ? G = "year" : N.unit === "day" ? G = "month" : N.unit === "hour" ? G = "day" : N.unit === "minute" && (G = "hour");
      }), M = G === B, a = n[o].position, C = n[o].value) : y.config.xaxis.type === "datetime" && L === void 0 && (C = ""), C === void 0 && (C = ""), C = Array.isArray(C) ? C : C.toString();
      var Z = new re(this.ctx), b = {};
      b = y.globals.rotateXLabels && p ? Z.getTextRects(C, parseInt(f, 10), null, "rotate(".concat(y.config.xaxis.labels.rotate, " 0 0)"), !1) : Z.getTextRects(C, parseInt(f, 10));
      var O = !y.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
      return !Array.isArray(C) && (C.indexOf("NaN") === 0 || C.toLowerCase().indexOf("invalid") === 0 || C.toLowerCase().indexOf("infinity") >= 0 || d.indexOf(C) >= 0 && O) && (C = ""), { x: a, text: C, textRect: b, isBold: M };
    } }, { key: "checkLabelBasedOnTickamount", value: function(t, n, a) {
      var o = this.w, d = o.config.xaxis.tickAmount;
      return d === "dataPoints" && (d = Math.round(o.globals.gridWidth / 120)), d > a || t % Math.round(a / (d + 1)) == 0 || (n.text = ""), n;
    } }, { key: "checkForOverflowingLabels", value: function(t, n, a, o, d) {
      var f = this.w;
      if (t === 0 && f.globals.skipFirstTimelinelabel && (n.text = ""), t === a - 1 && f.globals.skipLastTimelinelabel && (n.text = ""), f.config.xaxis.labels.hideOverlappingLabels && o.length > 0) {
        var p = d[d.length - 1];
        n.x < p.textRect.width / (f.globals.rotateXLabels ? Math.abs(f.config.xaxis.labels.rotate) / 12 : 1.01) + p.x && (n.text = "");
      }
      return n;
    } }, { key: "checkForReversedLabels", value: function(t, n) {
      var a = this.w;
      return a.config.yaxis[t] && a.config.yaxis[t].reversed && n.reverse(), n;
    } }, { key: "isYAxisHidden", value: function(t) {
      var n = this.w, a = new me(this.ctx);
      return !n.config.yaxis[t].show || !n.config.yaxis[t].showForNullSeries && a.isSeriesNull(t) && n.globals.collapsedSeriesIndices.indexOf(t) === -1;
    } }, { key: "getYAxisForeColor", value: function(t, n) {
      var a = this.w;
      return Array.isArray(t) && a.globals.yAxisScale[n] && this.ctx.theme.pushExtraColors(t, a.globals.yAxisScale[n].result.length, !1), t;
    } }, { key: "drawYAxisTicks", value: function(t, n, a, o, d, f, p) {
      var y = this.w, S = new re(this.ctx), C = y.globals.translateY;
      if (o.show && n > 0) {
        y.config.yaxis[d].opposite === !0 && (t += o.width);
        for (var E = n; E >= 0; E--) {
          var L = C + n / 10 + y.config.yaxis[d].labels.offsetY - 1;
          y.globals.isBarHorizontal && (L = f * E), y.config.chart.type === "heatmap" && (L += f / 2);
          var M = S.drawLine(t + a.offsetX - o.width + o.offsetX, L + o.offsetY, t + a.offsetX + o.offsetX, L + o.offsetY, o.color);
          p.add(M), C += f;
        }
      }
    } }]), W;
  }(), Ht = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "scaleSvgNode", value: function(t, n) {
      var a = parseFloat(t.getAttributeNS(null, "width")), o = parseFloat(t.getAttributeNS(null, "height"));
      t.setAttributeNS(null, "width", a * n), t.setAttributeNS(null, "height", o * n), t.setAttributeNS(null, "viewBox", "0 0 " + a + " " + o);
    } }, { key: "fixSvgStringForIe11", value: function(t) {
      if (!K.isIE11())
        return t.replace(/&nbsp;/g, "&#160;");
      var n = 0, a = t.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function(o) {
        return ++n === 2 ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : o;
      });
      return a = (a = a.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1");
    } }, { key: "getSvgString", value: function(t) {
      t == null && (t = 1);
      var n = this.w.globals.dom.Paper.svg();
      if (t !== 1) {
        var a = this.w.globals.dom.Paper.node.cloneNode(!0);
        this.scaleSvgNode(a, t), n = new XMLSerializer().serializeToString(a);
      }
      return this.fixSvgStringForIe11(n);
    } }, { key: "cleanup", value: function() {
      var t = this.w, n = t.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"), a = t.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"), o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
      Array.prototype.forEach.call(o, function(d) {
        d.setAttribute("width", 0);
      }), n && n[0] && (n[0].setAttribute("x", -500), n[0].setAttribute("x1", -500), n[0].setAttribute("x2", -500)), a && a[0] && (a[0].setAttribute("y", -100), a[0].setAttribute("y1", -100), a[0].setAttribute("y2", -100));
    } }, { key: "svgUrl", value: function() {
      this.cleanup();
      var t = this.getSvgString(), n = new Blob([t], { type: "image/svg+xml;charset=utf-8" });
      return URL.createObjectURL(n);
    } }, { key: "dataURI", value: function(t) {
      var n = this;
      return new Promise(function(a) {
        var o = n.w, d = t ? t.scale || t.width / o.globals.svgWidth : 1;
        n.cleanup();
        var f = document.createElement("canvas");
        f.width = o.globals.svgWidth * d, f.height = parseInt(o.globals.dom.elWrap.style.height, 10) * d;
        var p = o.config.chart.background === "transparent" ? "#fff" : o.config.chart.background, y = f.getContext("2d");
        y.fillStyle = p, y.fillRect(0, 0, f.width * d, f.height * d);
        var S = n.getSvgString(d);
        if (window.canvg && K.isIE11()) {
          var C = window.canvg.Canvg.fromString(y, S, { ignoreClear: !0, ignoreDimensions: !0 });
          C.start();
          var E = f.msToBlob();
          C.stop(), a({ blob: E });
        } else {
          var L = "data:image/svg+xml," + encodeURIComponent(S), M = new Image();
          M.crossOrigin = "anonymous", M.onload = function() {
            if (y.drawImage(M, 0, 0), f.msToBlob) {
              var P = f.msToBlob();
              a({ blob: P });
            } else {
              var I = f.toDataURL("image/png");
              a({ imgURI: I });
            }
          }, M.src = L;
        }
      });
    } }, { key: "exportToSVG", value: function() {
      this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg");
    } }, { key: "exportToPng", value: function() {
      var t = this;
      this.dataURI().then(function(n) {
        var a = n.imgURI, o = n.blob;
        o ? navigator.msSaveOrOpenBlob(o, t.w.globals.chartID + ".png") : t.triggerDownload(a, t.w.config.chart.toolbar.export.png.filename, ".png");
      });
    } }, { key: "exportToCSV", value: function(t) {
      var n = this, a = t.series, o = t.fileName, d = t.columnDelimiter, f = d === void 0 ? "," : d, p = t.lineDelimiter, y = p === void 0 ? `
` : p, S = this.w;
      a || (a = S.config.series);
      var C = [], E = [], L = "", M = S.globals.series.map(function(b, O) {
        return S.globals.collapsedSeriesIndices.indexOf(O) === -1 ? b : [];
      }), P = Math.max.apply(Math, ue(a.map(function(b) {
        return b.data ? b.data.length : 0;
      }))), I = new Nt(this.ctx), B = new Et(this.ctx), G = function(b) {
        var O = "";
        if (S.globals.axisCharts) {
          if (S.config.xaxis.type === "category" || S.config.xaxis.convertedCatToNumeric)
            if (S.globals.isBarHorizontal) {
              var N = S.globals.yLabelFormatters[0], X = new st(n.ctx).getActiveConfigSeriesIndex();
              O = N(S.globals.labels[b], { seriesIndex: X, dataPointIndex: b, w: S });
            } else
              O = B.getLabel(S.globals.labels, S.globals.timescaleLabels, 0, b).text;
          S.config.xaxis.type === "datetime" && (S.config.xaxis.categories.length ? O = S.config.xaxis.categories[b] : S.config.labels.length && (O = S.config.labels[b]));
        } else
          O = S.config.labels[b];
        return Array.isArray(O) && (O = O.join(" ")), K.isNumber(O) ? O : O.split(f).join("");
      }, Z = function(b, O) {
        if (C.length && O === 0 && E.push(C.join(f)), b.data) {
          b.data = b.data.length && b.data || ue(Array(P)).map(function() {
            return "";
          });
          for (var N = 0; N < b.data.length; N++) {
            C = [];
            var X = G(N);
            if (X || (I.isFormatXY() ? X = a[O].data[N].x : I.isFormat2DArray() && (X = a[O].data[N] ? a[O].data[N][0] : "")), O === 0) {
              C.push((oe = X, S.config.xaxis.type === "datetime" && String(oe).length >= 10 ? S.config.chart.toolbar.export.csv.dateFormatter(X) : K.isNumber(X) ? X : X.split(f).join("")));
              for (var Q = 0; Q < S.globals.series.length; Q++) {
                var ee;
                I.isFormatXY() ? C.push((ee = a[Q].data[N]) === null || ee === void 0 ? void 0 : ee.y) : C.push(M[Q][N]);
              }
            }
            (S.config.chart.type === "candlestick" || b.type && b.type === "candlestick") && (C.pop(), C.push(S.globals.seriesCandleO[O][N]), C.push(S.globals.seriesCandleH[O][N]), C.push(S.globals.seriesCandleL[O][N]), C.push(S.globals.seriesCandleC[O][N])), (S.config.chart.type === "boxPlot" || b.type && b.type === "boxPlot") && (C.pop(), C.push(S.globals.seriesCandleO[O][N]), C.push(S.globals.seriesCandleH[O][N]), C.push(S.globals.seriesCandleM[O][N]), C.push(S.globals.seriesCandleL[O][N]), C.push(S.globals.seriesCandleC[O][N])), S.config.chart.type === "rangeBar" && (C.pop(), C.push(S.globals.seriesRangeStart[O][N]), C.push(S.globals.seriesRangeEnd[O][N])), C.length && E.push(C.join(f));
          }
        }
        var oe;
      };
      C.push(S.config.chart.toolbar.export.csv.headerCategory), S.config.chart.type === "boxPlot" ? (C.push("minimum"), C.push("q1"), C.push("median"), C.push("q3"), C.push("maximum")) : S.config.chart.type === "candlestick" ? (C.push("open"), C.push("high"), C.push("low"), C.push("close")) : S.config.chart.type === "rangeBar" ? (C.push("minimum"), C.push("maximum")) : a.map(function(b, O) {
        var N = (b.name ? b.name : "series-".concat(O)) + "";
        S.globals.axisCharts && C.push(N.split(f).join("") ? N.split(f).join("") : "series-".concat(O));
      }), S.globals.axisCharts || (C.push(S.config.chart.toolbar.export.csv.headerValue), E.push(C.join(f))), a.map(function(b, O) {
        S.globals.axisCharts ? Z(b, O) : ((C = []).push(S.globals.labels[O].split(f).join("")), C.push(M[O]), E.push(C.join(f)));
      }), L += E.join(y), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + L), o || S.config.chart.toolbar.export.csv.filename, ".csv");
    } }, { key: "triggerDownload", value: function(t, n, a) {
      var o = document.createElement("a");
      o.href = t, o.download = (n || this.w.globals.chartID) + a, document.body.appendChild(o), o.click(), document.body.removeChild(o);
    } }]), W;
  }(), Wt = function() {
    function W(t, n) {
      T(this, W), this.ctx = t, this.elgrid = n, this.w = t.w;
      var a = this.w;
      this.axesUtils = new Et(t), this.xaxisLabels = a.globals.labels.slice(), a.globals.timescaleLabels.length > 0 && !a.globals.isBarHorizontal && (this.xaxisLabels = a.globals.timescaleLabels.slice()), a.config.xaxis.overwriteCategories && (this.xaxisLabels = a.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], a.config.xaxis.position === "top" ? this.offY = 0 : this.offY = a.globals.gridHeight + 1, this.offY = this.offY + a.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = a.config.chart.type === "bar" && a.config.plotOptions.bar.horizontal, this.xaxisFontSize = a.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = a.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = a.config.xaxis.labels.style.colors, this.xaxisBorderWidth = a.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = a.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = a.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = a.config.xaxis.axisBorder.height, this.yaxis = a.config.yaxis[0];
    }
    return F(W, [{ key: "drawXaxis", value: function() {
      var t = this.w, n = new re(this.ctx), a = n.group({ class: "apexcharts-xaxis", transform: "translate(".concat(t.config.xaxis.offsetX, ", ").concat(t.config.xaxis.offsetY, ")") }), o = n.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(t.globals.translateXAxisX, ", ").concat(t.globals.translateXAxisY, ")") });
      a.add(o);
      for (var d = [], f = 0; f < this.xaxisLabels.length; f++)
        d.push(this.xaxisLabels[f]);
      if (this.drawXAxisLabelAndGroup(!0, n, o, d, t.globals.isXNumeric, function(P, I) {
        return I;
      }), t.globals.hasXaxisGroups) {
        var p = t.globals.groups;
        d = [];
        for (var y = 0; y < p.length; y++)
          d.push(p[y].title);
        var S = {};
        t.config.xaxis.group.style && (S.xaxisFontSize = t.config.xaxis.group.style.fontSize, S.xaxisFontFamily = t.config.xaxis.group.style.fontFamily, S.xaxisForeColors = t.config.xaxis.group.style.colors, S.fontWeight = t.config.xaxis.group.style.fontWeight, S.cssClass = t.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(!1, n, o, d, !1, function(P, I) {
          return p[P].cols * I;
        }, S);
      }
      if (t.config.xaxis.title.text !== void 0) {
        var C = n.group({ class: "apexcharts-xaxis-title" }), E = n.drawText({ x: t.globals.gridWidth / 2 + t.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + (t.config.xaxis.position === "bottom" ? t.globals.xAxisLabelsHeight : -t.globals.xAxisLabelsHeight - 10) + t.config.xaxis.title.offsetY, text: t.config.xaxis.title.text, textAnchor: "middle", fontSize: t.config.xaxis.title.style.fontSize, fontFamily: t.config.xaxis.title.style.fontFamily, fontWeight: t.config.xaxis.title.style.fontWeight, foreColor: t.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + t.config.xaxis.title.style.cssClass });
        C.add(E), a.add(C);
      }
      if (t.config.xaxis.axisBorder.show) {
        var L = t.globals.barPadForNumericAxis, M = n.drawLine(t.globals.padHorizontal + t.config.xaxis.axisBorder.offsetX - L, this.offY, this.xaxisBorderWidth + L, this.offY, t.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
        this.elgrid && this.elgrid.elGridBorders && t.config.grid.show ? this.elgrid.elGridBorders.add(M) : a.add(M);
      }
      return a;
    } }, { key: "drawXAxisLabelAndGroup", value: function(t, n, a, o, d, f) {
      var p, y = this, S = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : {}, C = [], E = [], L = this.w, M = S.xaxisFontSize || this.xaxisFontSize, P = S.xaxisFontFamily || this.xaxisFontFamily, I = S.xaxisForeColors || this.xaxisForeColors, B = S.fontWeight || L.config.xaxis.labels.style.fontWeight, G = S.cssClass || L.config.xaxis.labels.style.cssClass, Z = L.globals.padHorizontal, b = o.length, O = L.config.xaxis.type === "category" ? L.globals.dataPoints : b;
      if (O === 0 && b > O && (O = b), d) {
        var N = O > 1 ? O - 1 : O;
        p = L.globals.gridWidth / N, Z = Z + f(0, p) / 2 + L.config.xaxis.labels.offsetX;
      } else
        p = L.globals.gridWidth / O, Z = Z + f(0, p) + L.config.xaxis.labels.offsetX;
      for (var X = function(ee) {
        var oe = Z - f(ee, p) / 2 + L.config.xaxis.labels.offsetX;
        ee === 0 && b === 1 && p / 2 === Z && O === 1 && (oe = L.globals.gridWidth / 2);
        var fe = y.axesUtils.getLabel(o, L.globals.timescaleLabels, oe, ee, C, M, t), ke = 28;
        if (L.globals.rotateXLabels && t && (ke = 22), L.config.xaxis.title.text && L.config.xaxis.position === "top" && (ke += parseFloat(L.config.xaxis.title.style.fontSize) + 2), t || (ke = ke + parseFloat(M) + (L.globals.xAxisLabelsHeight - L.globals.xAxisGroupLabelsHeight) + (L.globals.rotateXLabels ? 10 : 0)), fe = L.config.xaxis.tickAmount !== void 0 && L.config.xaxis.tickAmount !== "dataPoints" && L.config.xaxis.type !== "datetime" ? y.axesUtils.checkLabelBasedOnTickamount(ee, fe, b) : y.axesUtils.checkForOverflowingLabels(ee, fe, b, C, E), L.config.xaxis.labels.show) {
          var _e = n.drawText({ x: fe.x, y: y.offY + L.config.xaxis.labels.offsetY + ke - (L.config.xaxis.position === "top" ? L.globals.xAxisHeight + L.config.xaxis.axisTicks.height - 2 : 0), text: fe.text, textAnchor: "middle", fontWeight: fe.isBold ? 600 : B, fontSize: M, fontFamily: P, foreColor: Array.isArray(I) ? t && L.config.xaxis.convertedCatToNumeric ? I[L.globals.minX + ee - 1] : I[ee] : I, isPlainText: !1, cssClass: (t ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + G });
          if (a.add(_e), _e.on("click", function(Ie) {
            if (typeof L.config.chart.events.xAxisLabelClick == "function") {
              var at = Object.assign({}, L, { labelIndex: ee });
              L.config.chart.events.xAxisLabelClick(Ie, y.ctx, at);
            }
          }), t) {
            var Le = document.createElementNS(L.globals.SVGNS, "title");
            Le.textContent = Array.isArray(fe.text) ? fe.text.join(" ") : fe.text, _e.node.appendChild(Le), fe.text !== "" && (C.push(fe.text), E.push(fe));
          }
        }
        ee < b - 1 && (Z += f(ee + 1, p));
      }, Q = 0; Q <= b - 1; Q++)
        X(Q);
    } }, { key: "drawXaxisInversed", value: function(t) {
      var n, a, o = this, d = this.w, f = new re(this.ctx), p = d.config.yaxis[0].opposite ? d.globals.translateYAxisX[t] : 0, y = f.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: t }), S = f.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + p + ", 0)" });
      y.add(S);
      var C = [];
      if (d.config.yaxis[t].show)
        for (var E = 0; E < this.xaxisLabels.length; E++)
          C.push(this.xaxisLabels[E]);
      n = d.globals.gridHeight / C.length, a = -n / 2.2;
      var L = d.globals.yLabelFormatters[0], M = d.config.yaxis[0].labels;
      if (M.show)
        for (var P = function(N) {
          var X = C[N] === void 0 ? "" : C[N];
          X = L(X, { seriesIndex: t, dataPointIndex: N, w: d });
          var Q = o.axesUtils.getYAxisForeColor(M.style.colors, t), ee = 0;
          Array.isArray(X) && (ee = X.length / 2 * parseInt(M.style.fontSize, 10));
          var oe = M.offsetX - 15, fe = "end";
          o.yaxis.opposite && (fe = "start"), d.config.yaxis[0].labels.align === "left" ? (oe = M.offsetX, fe = "start") : d.config.yaxis[0].labels.align === "center" ? (oe = M.offsetX, fe = "middle") : d.config.yaxis[0].labels.align === "right" && (fe = "end");
          var ke = f.drawText({ x: oe, y: a + n + M.offsetY - ee, text: X, textAnchor: fe, foreColor: Array.isArray(Q) ? Q[N] : Q, fontSize: M.style.fontSize, fontFamily: M.style.fontFamily, fontWeight: M.style.fontWeight, isPlainText: !1, cssClass: "apexcharts-yaxis-label " + M.style.cssClass, maxWidth: M.maxWidth });
          S.add(ke), ke.on("click", function(Ie) {
            if (typeof d.config.chart.events.xAxisLabelClick == "function") {
              var at = Object.assign({}, d, { labelIndex: N });
              d.config.chart.events.xAxisLabelClick(Ie, o.ctx, at);
            }
          });
          var _e = document.createElementNS(d.globals.SVGNS, "title");
          if (_e.textContent = Array.isArray(X) ? X.join(" ") : X, ke.node.appendChild(_e), d.config.yaxis[t].labels.rotate !== 0) {
            var Le = f.rotateAroundCenter(ke.node);
            ke.node.setAttribute("transform", "rotate(".concat(d.config.yaxis[t].labels.rotate, " 0 ").concat(Le.y, ")"));
          }
          a += n;
        }, I = 0; I <= C.length - 1; I++)
          P(I);
      if (d.config.yaxis[0].title.text !== void 0) {
        var B = f.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + p + ", 0)" }), G = f.drawText({ x: d.config.yaxis[0].title.offsetX, y: d.globals.gridHeight / 2 + d.config.yaxis[0].title.offsetY, text: d.config.yaxis[0].title.text, textAnchor: "middle", foreColor: d.config.yaxis[0].title.style.color, fontSize: d.config.yaxis[0].title.style.fontSize, fontWeight: d.config.yaxis[0].title.style.fontWeight, fontFamily: d.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + d.config.yaxis[0].title.style.cssClass });
        B.add(G), y.add(B);
      }
      var Z = 0;
      this.isCategoryBarHorizontal && d.config.yaxis[0].opposite && (Z = d.globals.gridWidth);
      var b = d.config.xaxis.axisBorder;
      if (b.show) {
        var O = f.drawLine(d.globals.padHorizontal + b.offsetX + Z, 1 + b.offsetY, d.globals.padHorizontal + b.offsetX + Z, d.globals.gridHeight + b.offsetY, b.color, 0);
        this.elgrid && this.elgrid.elGridBorders && d.config.grid.show ? this.elgrid.elGridBorders.add(O) : y.add(O);
      }
      return d.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(Z, C.length, d.config.yaxis[0].axisBorder, d.config.yaxis[0].axisTicks, 0, n, y), y;
    } }, { key: "drawXaxisTicks", value: function(t, n, a) {
      var o = this.w, d = t;
      if (!(t < 0 || t - 2 > o.globals.gridWidth)) {
        var f = this.offY + o.config.xaxis.axisTicks.offsetY;
        if (n = n + f + o.config.xaxis.axisTicks.height, o.config.xaxis.position === "top" && (n = f - o.config.xaxis.axisTicks.height), o.config.xaxis.axisTicks.show) {
          var p = new re(this.ctx).drawLine(t + o.config.xaxis.axisTicks.offsetX, f + o.config.xaxis.offsetY, d + o.config.xaxis.axisTicks.offsetX, n + o.config.xaxis.offsetY, o.config.xaxis.axisTicks.color);
          a.add(p), p.node.classList.add("apexcharts-xaxis-tick");
        }
      }
    } }, { key: "getXAxisTicksPositions", value: function() {
      var t = this.w, n = [], a = this.xaxisLabels.length, o = t.globals.padHorizontal;
      if (t.globals.timescaleLabels.length > 0)
        for (var d = 0; d < a; d++)
          o = this.xaxisLabels[d].position, n.push(o);
      else
        for (var f = a, p = 0; p < f; p++) {
          var y = f;
          t.globals.isXNumeric && t.config.chart.type !== "bar" && (y -= 1), o += t.globals.gridWidth / y, n.push(o);
        }
      return n;
    } }, { key: "xAxisLabelCorrections", value: function() {
      var t = this.w, n = new re(this.ctx), a = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), d = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), f = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
      if (t.globals.rotateXLabels || t.config.xaxis.labels.rotateAlways)
        for (var p = 0; p < o.length; p++) {
          var y = n.rotateAroundCenter(o[p]);
          y.y = y.y - 1, y.x = y.x + 1, o[p].setAttribute("transform", "rotate(".concat(t.config.xaxis.labels.rotate, " ").concat(y.x, " ").concat(y.y, ")")), o[p].setAttribute("text-anchor", "end"), a.setAttribute("transform", "translate(0, ".concat(-10, ")"));
          var S = o[p].childNodes;
          t.config.xaxis.labels.trim && Array.prototype.forEach.call(S, function(M) {
            n.placeTextWithEllipsis(M, M.textContent, t.globals.xAxisLabelsHeight - (t.config.legend.position === "bottom" ? 20 : 10));
          });
        }
      else
        (function() {
          for (var M = t.globals.gridWidth / (t.globals.labels.length + 1), P = 0; P < o.length; P++) {
            var I = o[P].childNodes;
            t.config.xaxis.labels.trim && t.config.xaxis.type !== "datetime" && Array.prototype.forEach.call(I, function(B) {
              n.placeTextWithEllipsis(B, B.textContent, M);
            });
          }
        })();
      if (d.length > 0) {
        var C = d[d.length - 1].getBBox(), E = d[0].getBBox();
        C.x < -20 && d[d.length - 1].parentNode.removeChild(d[d.length - 1]), E.x + E.width > t.globals.gridWidth && !t.globals.isBarHorizontal && d[0].parentNode.removeChild(d[0]);
        for (var L = 0; L < f.length; L++)
          n.placeTextWithEllipsis(f[L], f[L].textContent, t.config.yaxis[0].labels.maxWidth - (t.config.yaxis[0].title.text ? 2 * parseFloat(t.config.yaxis[0].title.style.fontSize) : 0) - 15);
      }
    } }]), W;
  }(), mn = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
      var n = this.w;
      this.xaxisLabels = n.globals.labels.slice(), this.axesUtils = new Et(t), this.isRangeBar = n.globals.seriesRange.length && n.globals.isBarHorizontal, n.globals.timescaleLabels.length > 0 && (this.xaxisLabels = n.globals.timescaleLabels.slice());
    }
    return F(W, [{ key: "drawGridArea", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, n = this.w, a = new re(this.ctx);
      t === null && (t = a.group({ class: "apexcharts-grid" }));
      var o = a.drawLine(n.globals.padHorizontal, 1, n.globals.padHorizontal, n.globals.gridHeight, "transparent"), d = a.drawLine(n.globals.padHorizontal, n.globals.gridHeight, n.globals.gridWidth, n.globals.gridHeight, "transparent");
      return t.add(d), t.add(o), t;
    } }, { key: "drawGrid", value: function() {
      var t = null;
      return this.w.globals.axisCharts && (t = this.renderGrid(), this.drawGridArea(t.el)), t;
    } }, { key: "createGridMask", value: function() {
      var t = this.w, n = t.globals, a = new re(this.ctx), o = Array.isArray(t.config.stroke.width) ? 0 : t.config.stroke.width;
      if (Array.isArray(t.config.stroke.width)) {
        var d = 0;
        t.config.stroke.width.forEach(function(E) {
          d = Math.max(d, E);
        }), o = d;
      }
      n.dom.elGridRectMask = document.createElementNS(n.SVGNS, "clipPath"), n.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(n.cuid)), n.dom.elGridRectMarkerMask = document.createElementNS(n.SVGNS, "clipPath"), n.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(n.cuid)), n.dom.elForecastMask = document.createElementNS(n.SVGNS, "clipPath"), n.dom.elForecastMask.setAttribute("id", "forecastMask".concat(n.cuid)), n.dom.elNonForecastMask = document.createElementNS(n.SVGNS, "clipPath"), n.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(n.cuid));
      var f = t.config.chart.type, p = 0, y = 0;
      (f === "bar" || f === "rangeBar" || f === "candlestick" || f === "boxPlot" || t.globals.comboBarCount > 0) && t.globals.isXNumeric && !t.globals.isBarHorizontal && (p = t.config.grid.padding.left, y = t.config.grid.padding.right, n.barPadForNumericAxis > p && (p = n.barPadForNumericAxis, y = n.barPadForNumericAxis)), n.dom.elGridRect = a.drawRect(-o / 2 - p - 2, -o / 2, n.gridWidth + o + y + p + 4, n.gridHeight + o, 0, "#fff");
      var S = t.globals.markers.largestSize + 1;
      n.dom.elGridRectMarker = a.drawRect(2 * -S, 2 * -S, n.gridWidth + 4 * S, n.gridHeight + 4 * S, 0, "#fff"), n.dom.elGridRectMask.appendChild(n.dom.elGridRect.node), n.dom.elGridRectMarkerMask.appendChild(n.dom.elGridRectMarker.node);
      var C = n.dom.baseEl.querySelector("defs");
      C.appendChild(n.dom.elGridRectMask), C.appendChild(n.dom.elForecastMask), C.appendChild(n.dom.elNonForecastMask), C.appendChild(n.dom.elGridRectMarkerMask);
    } }, { key: "_drawGridLines", value: function(t) {
      var n = t.i, a = t.x1, o = t.y1, d = t.x2, f = t.y2, p = t.xCount, y = t.parent, S = this.w;
      if (!(n === 0 && S.globals.skipFirstTimelinelabel || n === p - 1 && S.globals.skipLastTimelinelabel && !S.config.xaxis.labels.formatter || S.config.chart.type === "radar")) {
        S.config.grid.xaxis.lines.show && this._drawGridLine({ i: n, x1: a, y1: o, x2: d, y2: f, xCount: p, parent: y });
        var C = 0;
        if (S.globals.hasXaxisGroups && S.config.xaxis.tickPlacement === "between") {
          var E = S.globals.groups;
          if (E) {
            for (var L = 0, M = 0; L < n && M < E.length; M++)
              L += E[M].cols;
            L === n && (C = 0.6 * S.globals.xAxisLabelsHeight);
          }
        }
        new Wt(this.ctx).drawXaxisTicks(a, C, S.globals.dom.elGraphical);
      }
    } }, { key: "_drawGridLine", value: function(t) {
      var n = t.i, a = t.x1, o = t.y1, d = t.x2, f = t.y2, p = t.xCount, y = t.parent, S = this.w, C = !1, E = y.node.classList.contains("apexcharts-gridlines-horizontal"), L = S.config.grid.strokeDashArray, M = S.globals.barPadForNumericAxis;
      (o === 0 && f === 0 || a === 0 && d === 0) && (C = !0), o === S.globals.gridHeight && f === S.globals.gridHeight && (C = !0), !S.globals.isBarHorizontal || n !== 0 && n !== p - 1 || (C = !0);
      var P = new re(this).drawLine(a - (E ? M : 0), o, d + (E ? M : 0), f, S.config.grid.borderColor, L);
      P.node.classList.add("apexcharts-gridline"), C && S.config.grid.show ? this.elGridBorders.add(P) : y.add(P);
    } }, { key: "_drawGridBandRect", value: function(t) {
      var n = t.c, a = t.x1, o = t.y1, d = t.x2, f = t.y2, p = t.type, y = this.w, S = new re(this.ctx), C = y.globals.barPadForNumericAxis;
      if (p !== "column" || y.config.xaxis.type !== "datetime") {
        var E = y.config.grid[p].colors[n], L = S.drawRect(a - (p === "row" ? C : 0), o, d + (p === "row" ? 2 * C : 0), f, 0, E, y.config.grid[p].opacity);
        this.elg.add(L), L.attr("clip-path", "url(#gridRectMask".concat(y.globals.cuid, ")")), L.node.classList.add("apexcharts-grid-".concat(p));
      }
    } }, { key: "_drawXYLines", value: function(t) {
      var n = this, a = t.xCount, o = t.tickAmount, d = this.w;
      if (d.config.grid.xaxis.lines.show || d.config.xaxis.axisTicks.show) {
        var f, p = d.globals.padHorizontal, y = d.globals.gridHeight;
        d.globals.timescaleLabels.length ? function(P) {
          for (var I = P.xC, B = P.x1, G = P.y1, Z = P.x2, b = P.y2, O = 0; O < I; O++)
            B = n.xaxisLabels[O].position, Z = n.xaxisLabels[O].position, n._drawGridLines({ i: O, x1: B, y1: G, x2: Z, y2: b, xCount: a, parent: n.elgridLinesV });
        }({ xC: a, x1: p, y1: 0, x2: f, y2: y }) : (d.globals.isXNumeric && (a = d.globals.xAxisScale.result.length), function(P) {
          for (var I = P.xC, B = P.x1, G = P.y1, Z = P.x2, b = P.y2, O = 0; O < I + (d.globals.isXNumeric ? 0 : 1); O++)
            O === 0 && I === 1 && d.globals.dataPoints === 1 && (Z = B = d.globals.gridWidth / 2), n._drawGridLines({ i: O, x1: B, y1: G, x2: Z, y2: b, xCount: a, parent: n.elgridLinesV }), Z = B += d.globals.gridWidth / (d.globals.isXNumeric ? I - 1 : I);
        }({ xC: a, x1: p, y1: 0, x2: f, y2: y }));
      }
      if (d.config.grid.yaxis.lines.show) {
        var S = 0, C = 0, E = d.globals.gridWidth, L = o + 1;
        this.isRangeBar && (L = d.globals.labels.length);
        for (var M = 0; M < L + (this.isRangeBar ? 1 : 0); M++)
          this._drawGridLine({ i: M, xCount: L + (this.isRangeBar ? 1 : 0), x1: 0, y1: S, x2: E, y2: C, parent: this.elgridLinesH }), C = S += d.globals.gridHeight / (this.isRangeBar ? L : o);
      }
    } }, { key: "_drawInvertedXYLines", value: function(t) {
      var n = t.xCount, a = this.w;
      if (a.config.grid.xaxis.lines.show || a.config.xaxis.axisTicks.show)
        for (var o, d = a.globals.padHorizontal, f = a.globals.gridHeight, p = 0; p < n + 1; p++)
          a.config.grid.xaxis.lines.show && this._drawGridLine({ i: p, xCount: n + 1, x1: d, y1: 0, x2: o, y2: f, parent: this.elgridLinesV }), new Wt(this.ctx).drawXaxisTicks(d, 0, a.globals.dom.elGraphical), o = d = d + a.globals.gridWidth / n + 0.3;
      if (a.config.grid.yaxis.lines.show)
        for (var y = 0, S = 0, C = a.globals.gridWidth, E = 0; E < a.globals.dataPoints + 1; E++)
          this._drawGridLine({ i: E, xCount: a.globals.dataPoints + 1, x1: 0, y1: y, x2: C, y2: S, parent: this.elgridLinesH }), S = y += a.globals.gridHeight / a.globals.dataPoints;
    } }, { key: "renderGrid", value: function() {
      var t = this.w, n = new re(this.ctx);
      this.elg = n.group({ class: "apexcharts-grid" }), this.elgridLinesH = n.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = n.group({ class: "apexcharts-gridlines-vertical" }), this.elGridBorders = n.group({ class: "apexcharts-grid-borders" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
      for (var a, o = t.globals.yAxisScale.length ? t.globals.yAxisScale[0].result.length - 1 : 5, d = 0; d < t.globals.series.length && (t.globals.yAxisScale[d] !== void 0 && (o = t.globals.yAxisScale[d].result.length - 1), !(o > 2)); d++)
        ;
      return !t.globals.isBarHorizontal || this.isRangeBar ? (a = this.xaxisLabels.length, this.isRangeBar && (a--, o = t.globals.labels.length, t.config.xaxis.tickAmount && t.config.xaxis.labels.formatter && (a = t.config.xaxis.tickAmount)), this._drawXYLines({ xCount: a, tickAmount: o })) : (a = o, o = t.globals.xTickAmount, this._drawInvertedXYLines({ xCount: a, tickAmount: o })), this.drawGridBands(a, o), { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: t.globals.gridWidth / a };
    } }, { key: "drawGridBands", value: function(t, n) {
      var a = this.w;
      if (a.config.grid.row.colors !== void 0 && a.config.grid.row.colors.length > 0)
        for (var o = 0, d = a.globals.gridHeight / n, f = a.globals.gridWidth, p = 0, y = 0; p < n; p++, y++)
          y >= a.config.grid.row.colors.length && (y = 0), this._drawGridBandRect({ c: y, x1: 0, y1: o, x2: f, y2: d, type: "row" }), o += a.globals.gridHeight / n;
      if (a.config.grid.column.colors !== void 0 && a.config.grid.column.colors.length > 0)
        for (var S = a.globals.isBarHorizontal || a.config.xaxis.type !== "category" && !a.config.xaxis.convertedCatToNumeric ? t : t - 1, C = a.globals.padHorizontal, E = a.globals.padHorizontal + a.globals.gridWidth / S, L = a.globals.gridHeight, M = 0, P = 0; M < t; M++, P++)
          P >= a.config.grid.column.colors.length && (P = 0), this._drawGridBandRect({ c: P, x1: C, y1: 0, x2: E, y2: L, type: "column" }), C += a.globals.gridWidth / S;
    } }]), W;
  }(), qe = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "niceScale", value: function(t, n) {
      var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, d = arguments.length > 4 ? arguments[4] : void 0, f = this.w, p = Math.abs(n - t);
      if ((a = this._adjustTicksForSmallRange(a, o, p)) === "dataPoints" && (a = f.globals.dataPoints - 1), t === Number.MIN_VALUE && n === 0 || !K.isNumber(t) && !K.isNumber(n) || t === Number.MIN_VALUE && n === -Number.MAX_VALUE)
        return t = 0, n = a, this.linearScale(t, n, a);
      t > n ? (console.warn("axis.min cannot be greater than axis.max"), n = t + 0.1) : t === n && (t = t === 0 ? 0 : t - 0.5, n = n === 0 ? 2 : n + 0.5);
      var y = [];
      p < 1 && d && (f.config.chart.type === "candlestick" || f.config.series[o].type === "candlestick" || f.config.chart.type === "boxPlot" || f.config.series[o].type === "boxPlot" || f.globals.isRangeData) && (n *= 1.01);
      var S = a + 1;
      S < 2 ? S = 2 : S > 2 && (S -= 2);
      var C = p / S, E = Math.floor(K.log10(C)), L = Math.pow(10, E), M = Math.round(C / L);
      M < 1 && (M = 1);
      var P = M * L, I = P * Math.floor(t / P), B = P * Math.ceil(n / P), G = I;
      if (d && p > 2) {
        for (; y.push(K.stripNumber(G, 7)), !((G += P) > B); )
          ;
        return { result: y, niceMin: y[0], niceMax: y[y.length - 1] };
      }
      var Z = t;
      (y = []).push(K.stripNumber(Z, 7));
      for (var b = Math.abs(n - t) / a, O = 0; O <= a; O++)
        Z += b, y.push(Z);
      return y[y.length - 2] >= n && y.pop(), { result: y, niceMin: y[0], niceMax: y[y.length - 1] };
    } }, { key: "linearScale", value: function(t, n) {
      var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, o = arguments.length > 3 ? arguments[3] : void 0, d = Math.abs(n - t);
      (a = this._adjustTicksForSmallRange(a, o, d)) === "dataPoints" && (a = this.w.globals.dataPoints - 1);
      var f = d / a;
      a === Number.MAX_VALUE && (a = 10, f = 1);
      for (var p = [], y = t; a >= 0; )
        p.push(y), y += f, a -= 1;
      return { result: p, niceMin: p[0], niceMax: p[p.length - 1] };
    } }, { key: "logarithmicScaleNice", value: function(t, n, a) {
      n <= 0 && (n = Math.max(t, a)), t <= 0 && (t = Math.min(n, a));
      for (var o = [], d = Math.ceil(Math.log(n) / Math.log(a) + 1), f = Math.floor(Math.log(t) / Math.log(a)); f < d; f++)
        o.push(Math.pow(a, f));
      return { result: o, niceMin: o[0], niceMax: o[o.length - 1] };
    } }, { key: "logarithmicScale", value: function(t, n, a) {
      n <= 0 && (n = Math.max(t, a)), t <= 0 && (t = Math.min(n, a));
      for (var o = [], d = Math.log(n) / Math.log(a), f = Math.log(t) / Math.log(a), p = d - f, y = Math.round(p), S = p / y, C = 0, E = f; C < y; C++, E += S)
        o.push(Math.pow(a, E));
      return o.push(Math.pow(a, d)), { result: o, niceMin: t, niceMax: n };
    } }, { key: "_adjustTicksForSmallRange", value: function(t, n, a) {
      var o = t;
      if (n !== void 0 && this.w.config.yaxis[n].labels.formatter && this.w.config.yaxis[n].tickAmount === void 0) {
        var d = Number(this.w.config.yaxis[n].labels.formatter(1));
        K.isNumber(d) && this.w.globals.yValueDecimal === 0 && (o = Math.ceil(a));
      }
      return o < t ? o : t;
    } }, { key: "setYScaleForIndex", value: function(t, n, a) {
      var o = this.w.globals, d = this.w.config, f = o.isBarHorizontal ? d.xaxis : d.yaxis[t];
      o.yAxisScale[t] === void 0 && (o.yAxisScale[t] = []);
      var p = Math.abs(a - n);
      if (f.logarithmic && p <= 5 && (o.invalidLogScale = !0), f.logarithmic && p > 5)
        o.allSeriesCollapsed = !1, o.yAxisScale[t] = this.logarithmicScale(n, a, f.logBase), o.yAxisScale[t] = f.forceNiceScale ? this.logarithmicScaleNice(n, a, f.logBase) : this.logarithmicScale(n, a, f.logBase);
      else if (a !== -Number.MAX_VALUE && K.isNumber(a))
        if (o.allSeriesCollapsed = !1, f.min === void 0 && f.max === void 0 || f.forceNiceScale) {
          var y = d.yaxis[t].max === void 0 && d.yaxis[t].min === void 0 || d.yaxis[t].forceNiceScale;
          o.yAxisScale[t] = this.niceScale(n, a, f.tickAmount ? f.tickAmount : p < 5 && p > 1 ? p + 1 : 5, t, y);
        } else
          o.yAxisScale[t] = this.linearScale(n, a, f.tickAmount, t);
      else
        o.yAxisScale[t] = this.linearScale(0, 5, 5);
    } }, { key: "setXScale", value: function(t, n) {
      var a = this.w, o = a.globals, d = a.config.xaxis, f = Math.abs(n - t);
      return n !== -Number.MAX_VALUE && K.isNumber(n) ? o.xAxisScale = this.linearScale(t, n, d.tickAmount ? d.tickAmount : f < 5 && f > 1 ? f + 1 : 5, 0) : o.xAxisScale = this.linearScale(0, 5, 5), o.xAxisScale;
    } }, { key: "setMultipleYScales", value: function() {
      var t = this, n = this.w.globals, a = this.w.config, o = n.minYArr.concat([]), d = n.maxYArr.concat([]), f = [];
      a.yaxis.forEach(function(p, y) {
        var S = y;
        a.series.forEach(function(L, M) {
          L.name === p.seriesName && (S = M, y !== M ? f.push({ index: M, similarIndex: y, alreadyExists: !0 }) : f.push({ index: M }));
        });
        var C = o[S], E = d[S];
        t.setYScaleForIndex(y, C, E);
      }), this.sameScaleInMultipleAxes(o, d, f);
    } }, { key: "sameScaleInMultipleAxes", value: function(t, n, a) {
      var o = this, d = this.w.config, f = this.w.globals, p = [];
      a.forEach(function(I) {
        I.alreadyExists && (p[I.index] === void 0 && (p[I.index] = []), p[I.index].push(I.index), p[I.index].push(I.similarIndex));
      }), f.yAxisSameScaleIndices = p, p.forEach(function(I, B) {
        p.forEach(function(G, Z) {
          var b, O;
          B !== Z && (b = I, O = G, b.filter(function(N) {
            return O.indexOf(N) !== -1;
          })).length > 0 && (p[B] = p[B].concat(p[Z]));
        });
      });
      var y = p.map(function(I) {
        return I.filter(function(B, G) {
          return I.indexOf(B) === G;
        });
      }).map(function(I) {
        return I.sort();
      });
      p = p.filter(function(I) {
        return !!I;
      });
      var S = y.slice(), C = S.map(function(I) {
        return JSON.stringify(I);
      });
      S = S.filter(function(I, B) {
        return C.indexOf(JSON.stringify(I)) === B;
      });
      var E = [], L = [];
      t.forEach(function(I, B) {
        S.forEach(function(G, Z) {
          G.indexOf(B) > -1 && (E[Z] === void 0 && (E[Z] = [], L[Z] = []), E[Z].push({ key: B, value: I }), L[Z].push({ key: B, value: n[B] }));
        });
      });
      var M = Array.apply(null, Array(S.length)).map(Number.prototype.valueOf, Number.MIN_VALUE), P = Array.apply(null, Array(S.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
      E.forEach(function(I, B) {
        I.forEach(function(G, Z) {
          M[B] = Math.min(G.value, M[B]);
        });
      }), L.forEach(function(I, B) {
        I.forEach(function(G, Z) {
          P[B] = Math.max(G.value, P[B]);
        });
      }), t.forEach(function(I, B) {
        L.forEach(function(G, Z) {
          var b = M[Z], O = P[Z];
          d.chart.stacked && (O = 0, G.forEach(function(N, X) {
            N.value !== -Number.MAX_VALUE && (O += N.value), b !== Number.MIN_VALUE && (b += E[Z][X].value);
          })), G.forEach(function(N, X) {
            G[X].key === B && (d.yaxis[B].min !== void 0 && (b = typeof d.yaxis[B].min == "function" ? d.yaxis[B].min(f.minY) : d.yaxis[B].min), d.yaxis[B].max !== void 0 && (O = typeof d.yaxis[B].max == "function" ? d.yaxis[B].max(f.maxY) : d.yaxis[B].max), o.setYScaleForIndex(B, b, O));
          });
        });
      });
    } }, { key: "autoScaleY", value: function(t, n, a) {
      t || (t = this);
      var o = t.w;
      if (o.globals.isMultipleYAxis || o.globals.collapsedSeries.length)
        return console.warn("autoScaleYaxis is not supported in a multi-yaxis chart."), n;
      var d = o.globals.seriesX[0], f = o.config.chart.stacked;
      return n.forEach(function(p, y) {
        for (var S = 0, C = 0; C < d.length; C++)
          if (d[C] >= a.xaxis.min) {
            S = C;
            break;
          }
        var E, L, M = o.globals.minYArr[y], P = o.globals.maxYArr[y], I = o.globals.stackedSeriesTotals;
        o.globals.series.forEach(function(B, G) {
          var Z = B[S];
          f ? (Z = I[S], E = L = Z, I.forEach(function(b, O) {
            d[O] <= a.xaxis.max && d[O] >= a.xaxis.min && (b > L && b !== null && (L = b), B[O] < E && B[O] !== null && (E = B[O]));
          })) : (E = L = Z, B.forEach(function(b, O) {
            if (d[O] <= a.xaxis.max && d[O] >= a.xaxis.min) {
              var N = b, X = b;
              o.globals.series.forEach(function(Q, ee) {
                b !== null && (N = Math.min(Q[O], N), X = Math.max(Q[O], X));
              }), X > L && X !== null && (L = X), N < E && N !== null && (E = N);
            }
          })), E === void 0 && L === void 0 && (E = M, L = P), L *= L < 0 ? 0.9 : 1.1, (E *= E < 0 ? 1.1 : 0.9) === 0 && L === 0 && (E = -1, L = 1), L < 0 && L < P && (L = P), E < 0 && E > M && (E = M), n.length > 1 ? (n[G].min = p.min === void 0 ? E : p.min, n[G].max = p.max === void 0 ? L : p.max) : (n[0].min = p.min === void 0 ? E : p.min, n[0].max = p.max === void 0 ? L : p.max);
        });
      }), n;
    } }]), W;
  }(), pn = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w, this.scales = new qe(t);
    }
    return F(W, [{ key: "init", value: function() {
      this.setYRange(), this.setXRange(), this.setZRange();
    } }, { key: "getMinYMaxY", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -Number.MAX_VALUE, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, d = this.w.config, f = this.w.globals, p = -Number.MAX_VALUE, y = Number.MIN_VALUE;
      o === null && (o = t + 1);
      var S = f.series, C = S, E = S;
      d.chart.type === "candlestick" ? (C = f.seriesCandleL, E = f.seriesCandleH) : d.chart.type === "boxPlot" ? (C = f.seriesCandleO, E = f.seriesCandleC) : f.isRangeData && (C = f.seriesRangeStart, E = f.seriesRangeEnd);
      for (var L = t; L < o; L++) {
        f.dataPoints = Math.max(f.dataPoints, S[L].length), f.categoryLabels.length && (f.dataPoints = f.categoryLabels.filter(function(I) {
          return I !== void 0;
        }).length), f.labels.length && d.xaxis.type !== "datetime" && f.series.reduce(function(I, B) {
          return I + B.length;
        }, 0) !== 0 && (f.dataPoints = Math.max(f.dataPoints, f.labels.length));
        for (var M = 0; M < f.series[L].length; M++) {
          var P = S[L][M];
          P !== null && K.isNumber(P) ? (E[L][M] !== void 0 && (p = Math.max(p, E[L][M]), n = Math.min(n, E[L][M])), C[L][M] !== void 0 && (n = Math.min(n, C[L][M]), a = Math.max(a, C[L][M])), this.w.config.chart.type !== "candlestick" && this.w.config.chart.type !== "boxPlot" && this.w.config.chart.type === "rangeArea" && this.w.config.chart.type === "rangeBar" || (this.w.config.chart.type !== "candlestick" && this.w.config.chart.type !== "boxPlot" || f.seriesCandleC[L][M] !== void 0 && (p = Math.max(p, f.seriesCandleO[L][M]), p = Math.max(p, f.seriesCandleH[L][M]), p = Math.max(p, f.seriesCandleL[L][M]), p = Math.max(p, f.seriesCandleC[L][M]), this.w.config.chart.type === "boxPlot" && (p = Math.max(p, f.seriesCandleM[L][M]))), !d.series[L].type || d.series[L].type === "candlestick" && d.series[L].type === "boxPlot" && d.series[L].type === "rangeArea" && d.series[L].type === "rangeBar" || (p = Math.max(p, f.series[L][M]), n = Math.min(n, f.series[L][M])), a = p), f.seriesGoals[L] && f.seriesGoals[L][M] && Array.isArray(f.seriesGoals[L][M]) && f.seriesGoals[L][M].forEach(function(I) {
            y !== Number.MIN_VALUE && (y = Math.min(y, I.value), n = y), p = Math.max(p, I.value), a = p;
          }), K.isFloat(P) && (P = K.noExponents(P), f.yValueDecimal = Math.max(f.yValueDecimal, P.toString().split(".")[1].length)), y > C[L][M] && C[L][M] < 0 && (y = C[L][M])) : f.hasNullValues = !0;
        }
      }
      return d.chart.type === "rangeBar" && f.seriesRangeStart.length && f.isBarHorizontal && (y = n), d.chart.type === "bar" && (y < 0 && p < 0 && (p = 0), y === Number.MIN_VALUE && (y = 0)), { minY: y, maxY: p, lowestY: n, highestY: a };
    } }, { key: "setYRange", value: function() {
      var t = this.w.globals, n = this.w.config;
      t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE;
      var a = Number.MAX_VALUE;
      if (t.isMultipleYAxis)
        for (var o = 0; o < t.series.length; o++) {
          var d = this.getMinYMaxY(o, a, null, o + 1);
          t.minYArr.push(d.minY), t.maxYArr.push(d.maxY), a = d.lowestY;
        }
      var f = this.getMinYMaxY(0, a, null, t.series.length);
      if (t.minY = f.minY, t.maxY = f.maxY, a = f.lowestY, n.chart.stacked && this._setStackedMinMax(), (n.chart.type === "line" || n.chart.type === "area" || n.chart.type === "candlestick" || n.chart.type === "boxPlot" || n.chart.type === "rangeBar" && !t.isBarHorizontal) && t.minY === Number.MIN_VALUE && a !== -Number.MAX_VALUE && a !== t.maxY) {
        var p = t.maxY - a;
        (a >= 0 && a <= 10 || n.yaxis[0].min !== void 0 || n.yaxis[0].max !== void 0) && (p = 0), t.minY = a - 5 * p / 100, a > 0 && t.minY < 0 && (t.minY = 0), t.maxY = t.maxY + 5 * p / 100;
      }
      return n.yaxis.forEach(function(y, S) {
        y.max !== void 0 && (typeof y.max == "number" ? t.maxYArr[S] = y.max : typeof y.max == "function" && (t.maxYArr[S] = y.max(t.isMultipleYAxis ? t.maxYArr[S] : t.maxY)), t.maxY = t.maxYArr[S]), y.min !== void 0 && (typeof y.min == "number" ? t.minYArr[S] = y.min : typeof y.min == "function" && (t.minYArr[S] = y.min(t.isMultipleYAxis ? t.minYArr[S] === Number.MIN_VALUE ? 0 : t.minYArr[S] : t.minY)), t.minY = t.minYArr[S]);
      }), t.isBarHorizontal && ["min", "max"].forEach(function(y) {
        n.xaxis[y] !== void 0 && typeof n.xaxis[y] == "number" && (y === "min" ? t.minY = n.xaxis[y] : t.maxY = n.xaxis[y]);
      }), t.isMultipleYAxis ? (this.scales.setMultipleYScales(), t.minY = a, t.yAxisScale.forEach(function(y, S) {
        t.minYArr[S] = y.niceMin, t.maxYArr[S] = y.niceMax;
      })) : (this.scales.setYScaleForIndex(0, t.minY, t.maxY), t.minY = t.yAxisScale[0].niceMin, t.maxY = t.yAxisScale[0].niceMax, t.minYArr[0] = t.yAxisScale[0].niceMin, t.maxYArr[0] = t.yAxisScale[0].niceMax), { minY: t.minY, maxY: t.maxY, minYArr: t.minYArr, maxYArr: t.maxYArr, yAxisScale: t.yAxisScale };
    } }, { key: "setXRange", value: function() {
      var t = this.w.globals, n = this.w.config, a = n.xaxis.type === "numeric" || n.xaxis.type === "datetime" || n.xaxis.type === "category" && !t.noLabelsProvided || t.noLabelsProvided || t.isXNumeric;
      if (t.isXNumeric && function() {
        for (var p = 0; p < t.series.length; p++)
          if (t.labels[p])
            for (var y = 0; y < t.labels[p].length; y++)
              t.labels[p][y] !== null && K.isNumber(t.labels[p][y]) && (t.maxX = Math.max(t.maxX, t.labels[p][y]), t.initialMaxX = Math.max(t.maxX, t.labels[p][y]), t.minX = Math.min(t.minX, t.labels[p][y]), t.initialMinX = Math.min(t.minX, t.labels[p][y]));
      }(), t.noLabelsProvided && n.xaxis.categories.length === 0 && (t.maxX = t.labels[t.labels.length - 1], t.initialMaxX = t.labels[t.labels.length - 1], t.minX = 1, t.initialMinX = 1), t.isXNumeric || t.noLabelsProvided || t.dataFormatXNumeric) {
        var o;
        if (n.xaxis.tickAmount === void 0 ? (o = Math.round(t.svgWidth / 150), n.xaxis.type === "numeric" && t.dataPoints < 30 && (o = t.dataPoints - 1), o > t.dataPoints && t.dataPoints !== 0 && (o = t.dataPoints - 1)) : n.xaxis.tickAmount === "dataPoints" ? (t.series.length > 1 && (o = t.series[t.maxValsInArrayIndex].length - 1), t.isXNumeric && (o = t.maxX - t.minX - 1)) : o = n.xaxis.tickAmount, t.xTickAmount = o, n.xaxis.max !== void 0 && typeof n.xaxis.max == "number" && (t.maxX = n.xaxis.max), n.xaxis.min !== void 0 && typeof n.xaxis.min == "number" && (t.minX = n.xaxis.min), n.xaxis.range !== void 0 && (t.minX = t.maxX - n.xaxis.range), t.minX !== Number.MAX_VALUE && t.maxX !== -Number.MAX_VALUE)
          if (n.xaxis.convertedCatToNumeric && !t.dataFormatXNumeric) {
            for (var d = [], f = t.minX - 1; f < t.maxX; f++)
              d.push(f + 1);
            t.xAxisScale = { result: d, niceMin: d[0], niceMax: d[d.length - 1] };
          } else
            t.xAxisScale = this.scales.setXScale(t.minX, t.maxX);
        else
          t.xAxisScale = this.scales.linearScale(1, o, o), t.noLabelsProvided && t.labels.length > 0 && (t.xAxisScale = this.scales.linearScale(1, t.labels.length, o - 1), t.seriesX = t.labels.slice());
        a && (t.labels = t.xAxisScale.result.slice());
      }
      return t.isBarHorizontal && t.labels.length && (t.xTickAmount = t.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: t.minX, maxX: t.maxX };
    } }, { key: "setZRange", value: function() {
      var t = this.w.globals;
      if (t.isDataXYZ) {
        for (var n = 0; n < t.series.length; n++)
          if (t.seriesZ[n] !== void 0)
            for (var a = 0; a < t.seriesZ[n].length; a++)
              t.seriesZ[n][a] !== null && K.isNumber(t.seriesZ[n][a]) && (t.maxZ = Math.max(t.maxZ, t.seriesZ[n][a]), t.minZ = Math.min(t.minZ, t.seriesZ[n][a]));
      }
    } }, { key: "_handleSingleDataPoint", value: function() {
      var t = this.w.globals, n = this.w.config;
      if (t.minX === t.maxX) {
        var a = new Ze(this.ctx);
        if (n.xaxis.type === "datetime") {
          var o = a.getDate(t.minX);
          n.xaxis.labels.datetimeUTC ? o.setUTCDate(o.getUTCDate() - 2) : o.setDate(o.getDate() - 2), t.minX = new Date(o).getTime();
          var d = a.getDate(t.maxX);
          n.xaxis.labels.datetimeUTC ? d.setUTCDate(d.getUTCDate() + 2) : d.setDate(d.getDate() + 2), t.maxX = new Date(d).getTime();
        } else
          (n.xaxis.type === "numeric" || n.xaxis.type === "category" && !t.noLabelsProvided) && (t.minX = t.minX - 2, t.initialMinX = t.minX, t.maxX = t.maxX + 2, t.initialMaxX = t.maxX);
      }
    } }, { key: "_getMinXDiff", value: function() {
      var t = this.w.globals;
      t.isXNumeric && t.seriesX.forEach(function(n, a) {
        n.length === 1 && n.push(t.seriesX[t.maxValsInArrayIndex][t.seriesX[t.maxValsInArrayIndex].length - 1]);
        var o = n.slice();
        o.sort(function(d, f) {
          return d - f;
        }), o.forEach(function(d, f) {
          if (f > 0) {
            var p = d - o[f - 1];
            p > 0 && (t.minXDiff = Math.min(p, t.minXDiff));
          }
        }), t.dataPoints !== 1 && t.minXDiff !== Number.MAX_VALUE || (t.minXDiff = 0.5);
      });
    } }, { key: "_setStackedMinMax", value: function() {
      var t = this, n = this.w.globals;
      if (n.series.length) {
        var a = n.seriesGroups;
        a.length || (a = [this.w.config.series.map(function(f) {
          return f.name;
        })]);
        var o = {}, d = {};
        a.forEach(function(f) {
          o[f] = [], d[f] = [], t.w.config.series.map(function(p, y) {
            return f.indexOf(p.name) > -1 ? y : null;
          }).filter(function(p) {
            return p !== null;
          }).forEach(function(p) {
            for (var y = 0; y < n.series[n.maxValsInArrayIndex].length; y++)
              o[f][y] === void 0 && (o[f][y] = 0, d[f][y] = 0), n.series[p][y] !== null && K.isNumber(n.series[p][y]) && (n.series[p][y] > 0 ? o[f][y] += parseFloat(n.series[p][y]) + 1e-4 : d[f][y] += parseFloat(n.series[p][y]));
          });
        }), Object.entries(o).forEach(function(f) {
          var p = se(f, 1)[0];
          o[p].forEach(function(y, S) {
            n.maxY = Math.max(n.maxY, o[p][S]), n.minY = Math.min(n.minY, d[p][S]);
          });
        });
      }
    } }]), W;
  }(), jn = function() {
    function W(t, n) {
      T(this, W), this.ctx = t, this.elgrid = n, this.w = t.w;
      var a = this.w;
      this.xaxisFontSize = a.config.xaxis.labels.style.fontSize, this.axisFontFamily = a.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = a.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = a.config.chart.type === "bar" && a.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, a.config.xaxis.position === "bottom" && (this.xAxisoffX = a.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new Et(t);
    }
    return F(W, [{ key: "drawYaxis", value: function(t) {
      var n = this, a = this.w, o = new re(this.ctx), d = a.config.yaxis[t].labels.style, f = d.fontSize, p = d.fontFamily, y = d.fontWeight, S = o.group({ class: "apexcharts-yaxis", rel: t, transform: "translate(" + a.globals.translateYAxisX[t] + ", 0)" });
      if (this.axesUtils.isYAxisHidden(t))
        return S;
      var C = o.group({ class: "apexcharts-yaxis-texts-g" });
      S.add(C);
      var E = a.globals.yAxisScale[t].result.length - 1, L = a.globals.gridHeight / E, M = a.globals.translateY, P = a.globals.yLabelFormatters[t], I = a.globals.yAxisScale[t].result.slice();
      I = this.axesUtils.checkForReversedLabels(t, I);
      var B = "";
      if (a.config.yaxis[t].labels.show)
        for (var G = function(oe) {
          var fe = I[oe];
          fe = P(fe, oe, a);
          var ke = a.config.yaxis[t].labels.padding;
          a.config.yaxis[t].opposite && a.config.yaxis.length !== 0 && (ke *= -1);
          var _e = "end";
          a.config.yaxis[t].opposite && (_e = "start"), a.config.yaxis[t].labels.align === "left" ? _e = "start" : a.config.yaxis[t].labels.align === "center" ? _e = "middle" : a.config.yaxis[t].labels.align === "right" && (_e = "end");
          var Le = n.axesUtils.getYAxisForeColor(d.colors, t), Ie = o.drawText({ x: ke, y: M + E / 10 + a.config.yaxis[t].labels.offsetY + 1, text: fe, textAnchor: _e, fontSize: f, fontFamily: p, fontWeight: y, maxWidth: a.config.yaxis[t].labels.maxWidth, foreColor: Array.isArray(Le) ? Le[oe] : Le, isPlainText: !1, cssClass: "apexcharts-yaxis-label " + d.cssClass });
          oe === E && (B = Ie), C.add(Ie);
          var at = document.createElementNS(a.globals.SVGNS, "title");
          if (at.textContent = Array.isArray(fe) ? fe.join(" ") : fe, Ie.node.appendChild(at), a.config.yaxis[t].labels.rotate !== 0) {
            var Qt = o.rotateAroundCenter(B.node), Kt = o.rotateAroundCenter(Ie.node);
            Ie.node.setAttribute("transform", "rotate(".concat(a.config.yaxis[t].labels.rotate, " ").concat(Qt.x, " ").concat(Kt.y, ")"));
          }
          M += L;
        }, Z = E; Z >= 0; Z--)
          G(Z);
      if (a.config.yaxis[t].title.text !== void 0) {
        var b = o.group({ class: "apexcharts-yaxis-title" }), O = 0;
        a.config.yaxis[t].opposite && (O = a.globals.translateYAxisX[t]);
        var N = o.drawText({ x: O, y: a.globals.gridHeight / 2 + a.globals.translateY + a.config.yaxis[t].title.offsetY, text: a.config.yaxis[t].title.text, textAnchor: "end", foreColor: a.config.yaxis[t].title.style.color, fontSize: a.config.yaxis[t].title.style.fontSize, fontWeight: a.config.yaxis[t].title.style.fontWeight, fontFamily: a.config.yaxis[t].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + a.config.yaxis[t].title.style.cssClass });
        b.add(N), S.add(b);
      }
      var X = a.config.yaxis[t].axisBorder, Q = 31 + X.offsetX;
      if (a.config.yaxis[t].opposite && (Q = -31 - X.offsetX), X.show) {
        var ee = o.drawLine(Q, a.globals.translateY + X.offsetY - 2, Q, a.globals.gridHeight + a.globals.translateY + X.offsetY + 2, X.color, 0, X.width);
        S.add(ee);
      }
      return a.config.yaxis[t].axisTicks.show && this.axesUtils.drawYAxisTicks(Q, E, X, a.config.yaxis[t].axisTicks, t, L, S), S;
    } }, { key: "drawYaxisInversed", value: function(t) {
      var n = this.w, a = new re(this.ctx), o = a.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), d = a.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(n.globals.translateXAxisX, ", ").concat(n.globals.translateXAxisY, ")") });
      o.add(d);
      var f = n.globals.yAxisScale[t].result.length - 1, p = n.globals.gridWidth / f + 0.1, y = p + n.config.xaxis.labels.offsetX, S = n.globals.xLabelFormatter, C = n.globals.yAxisScale[t].result.slice(), E = n.globals.timescaleLabels;
      E.length > 0 && (this.xaxisLabels = E.slice(), f = (C = E.slice()).length), C = this.axesUtils.checkForReversedLabels(t, C);
      var L = E.length;
      if (n.config.xaxis.labels.show)
        for (var M = L ? 0 : f; L ? M < L : M >= 0; L ? M++ : M--) {
          var P = C[M];
          P = S(P, M, n);
          var I = n.globals.gridWidth + n.globals.padHorizontal - (y - p + n.config.xaxis.labels.offsetX);
          if (E.length) {
            var B = this.axesUtils.getLabel(C, E, I, M, this.drawnLabels, this.xaxisFontSize);
            I = B.x, P = B.text, this.drawnLabels.push(B.text), M === 0 && n.globals.skipFirstTimelinelabel && (P = ""), M === C.length - 1 && n.globals.skipLastTimelinelabel && (P = "");
          }
          var G = a.drawText({ x: I, y: this.xAxisoffX + n.config.xaxis.labels.offsetY + 30 - (n.config.xaxis.position === "top" ? n.globals.xAxisHeight + n.config.xaxis.axisTicks.height - 2 : 0), text: P, textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: n.config.xaxis.labels.style.fontWeight, isPlainText: !1, cssClass: "apexcharts-xaxis-label " + n.config.xaxis.labels.style.cssClass });
          d.add(G), G.tspan(P);
          var Z = document.createElementNS(n.globals.SVGNS, "title");
          Z.textContent = P, G.node.appendChild(Z), y += p;
        }
      return this.inversedYAxisTitleText(o), this.inversedYAxisBorder(o), o;
    } }, { key: "inversedYAxisBorder", value: function(t) {
      var n = this.w, a = new re(this.ctx), o = n.config.xaxis.axisBorder;
      if (o.show) {
        var d = 0;
        n.config.chart.type === "bar" && n.globals.isXNumeric && (d -= 15);
        var f = a.drawLine(n.globals.padHorizontal + d + o.offsetX, this.xAxisoffX, n.globals.gridWidth, this.xAxisoffX, o.color, 0, o.height);
        this.elgrid && this.elgrid.elGridBorders && n.config.grid.show ? this.elgrid.elGridBorders.add(f) : t.add(f);
      }
    } }, { key: "inversedYAxisTitleText", value: function(t) {
      var n = this.w, a = new re(this.ctx);
      if (n.config.xaxis.title.text !== void 0) {
        var o = a.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), d = a.drawText({ x: n.globals.gridWidth / 2 + n.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(n.config.xaxis.title.style.fontSize) + n.config.xaxis.title.offsetY + 20, text: n.config.xaxis.title.text, textAnchor: "middle", fontSize: n.config.xaxis.title.style.fontSize, fontFamily: n.config.xaxis.title.style.fontFamily, fontWeight: n.config.xaxis.title.style.fontWeight, foreColor: n.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + n.config.xaxis.title.style.cssClass });
        o.add(d), t.add(o);
      }
    } }, { key: "yAxisTitleRotate", value: function(t, n) {
      var a = this.w, o = new re(this.ctx), d = { width: 0, height: 0 }, f = { width: 0, height: 0 }, p = a.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-texts-g"));
      p !== null && (d = p.getBoundingClientRect());
      var y = a.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-title text"));
      if (y !== null && (f = y.getBoundingClientRect()), y !== null) {
        var S = this.xPaddingForYAxisTitle(t, d, f, n);
        y.setAttribute("x", S.xPos - (n ? 10 : 0));
      }
      if (y !== null) {
        var C = o.rotateAroundCenter(y);
        y.setAttribute("transform", "rotate(".concat(n ? -1 * a.config.yaxis[t].title.rotate : a.config.yaxis[t].title.rotate, " ").concat(C.x, " ").concat(C.y, ")"));
      }
    } }, { key: "xPaddingForYAxisTitle", value: function(t, n, a, o) {
      var d = this.w, f = 0, p = 0, y = 10;
      return d.config.yaxis[t].title.text === void 0 || t < 0 ? { xPos: p, padd: 0 } : (o ? (p = n.width + d.config.yaxis[t].title.offsetX + a.width / 2 + y / 2, (f += 1) === 0 && (p -= y / 2)) : (p = -1 * n.width + d.config.yaxis[t].title.offsetX + y / 2 + a.width / 2, d.globals.isBarHorizontal && (y = 25, p = -1 * n.width - d.config.yaxis[t].title.offsetX - y)), { xPos: p, padd: y });
    } }, { key: "setYAxisXPosition", value: function(t, n) {
      var a = this.w, o = 0, d = 0, f = 18, p = 1;
      a.config.yaxis.length > 1 && (this.multipleYs = !0), a.config.yaxis.map(function(y, S) {
        var C = a.globals.ignoreYAxisIndexes.indexOf(S) > -1 || !y.show || y.floating || t[S].width === 0, E = t[S].width + n[S].width;
        y.opposite ? a.globals.isBarHorizontal ? (d = a.globals.gridWidth + a.globals.translateX - 1, a.globals.translateYAxisX[S] = d - y.labels.offsetX) : (d = a.globals.gridWidth + a.globals.translateX + p, C || (p = p + E + 20), a.globals.translateYAxisX[S] = d - y.labels.offsetX + 20) : (o = a.globals.translateX - f, C || (f = f + E + 20), a.globals.translateYAxisX[S] = o + y.labels.offsetX);
      });
    } }, { key: "setYAxisTextAlignments", value: function() {
      var t = this.w, n = t.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
      (n = K.listToArray(n)).forEach(function(a, o) {
        var d = t.config.yaxis[o];
        if (d && !d.floating && d.labels.align !== void 0) {
          var f = t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(o, "'] .apexcharts-yaxis-texts-g")), p = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(o, "'] .apexcharts-yaxis-label"));
          p = K.listToArray(p);
          var y = f.getBoundingClientRect();
          d.labels.align === "left" ? (p.forEach(function(S, C) {
            S.setAttribute("text-anchor", "start");
          }), d.opposite || f.setAttribute("transform", "translate(-".concat(y.width, ", 0)"))) : d.labels.align === "center" ? (p.forEach(function(S, C) {
            S.setAttribute("text-anchor", "middle");
          }), f.setAttribute("transform", "translate(".concat(y.width / 2 * (d.opposite ? 1 : -1), ", 0)"))) : d.labels.align === "right" && (p.forEach(function(S, C) {
            S.setAttribute("text-anchor", "end");
          }), d.opposite && f.setAttribute("transform", "translate(".concat(y.width, ", 0)")));
        }
      });
    } }]), W;
  }(), ir = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w, this.documentEvent = K.bind(this.documentEvent, this);
    }
    return F(W, [{ key: "addEventListener", value: function(t, n) {
      var a = this.w;
      a.globals.events.hasOwnProperty(t) ? a.globals.events[t].push(n) : a.globals.events[t] = [n];
    } }, { key: "removeEventListener", value: function(t, n) {
      var a = this.w;
      if (a.globals.events.hasOwnProperty(t)) {
        var o = a.globals.events[t].indexOf(n);
        o !== -1 && a.globals.events[t].splice(o, 1);
      }
    } }, { key: "fireEvent", value: function(t, n) {
      var a = this.w;
      if (a.globals.events.hasOwnProperty(t)) {
        n && n.length || (n = []);
        for (var o = a.globals.events[t], d = o.length, f = 0; f < d; f++)
          o[f].apply(null, n);
      }
    } }, { key: "setupEventHandlers", value: function() {
      var t = this, n = this.w, a = this.ctx, o = n.globals.dom.baseEl.querySelector(n.globals.chartClass);
      this.ctx.eventList.forEach(function(d) {
        o.addEventListener(d, function(f) {
          var p = Object.assign({}, n, { seriesIndex: n.globals.capturedSeriesIndex, dataPointIndex: n.globals.capturedDataPointIndex });
          f.type === "mousemove" || f.type === "touchmove" ? typeof n.config.chart.events.mouseMove == "function" && n.config.chart.events.mouseMove(f, a, p) : f.type === "mouseleave" || f.type === "touchleave" ? typeof n.config.chart.events.mouseLeave == "function" && n.config.chart.events.mouseLeave(f, a, p) : (f.type === "mouseup" && f.which === 1 || f.type === "touchend") && (typeof n.config.chart.events.click == "function" && n.config.chart.events.click(f, a, p), a.ctx.events.fireEvent("click", [f, a, p]));
        }, { capture: !1, passive: !0 });
      }), this.ctx.eventList.forEach(function(d) {
        n.globals.dom.baseEl.addEventListener(d, t.documentEvent, { passive: !0 });
      }), this.ctx.core.setupBrushHandler();
    } }, { key: "documentEvent", value: function(t) {
      var n = this.w, a = t.target.className;
      if (t.type === "click") {
        var o = n.globals.dom.baseEl.querySelector(".apexcharts-menu");
        o && o.classList.contains("apexcharts-menu-open") && a !== "apexcharts-menu-icon" && o.classList.remove("apexcharts-menu-open");
      }
      n.globals.clientX = t.type === "touchmove" ? t.touches[0].clientX : t.clientX, n.globals.clientY = t.type === "touchmove" ? t.touches[0].clientY : t.clientY;
    } }]), W;
  }(), Dr = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "setCurrentLocaleValues", value: function(t) {
      var n = this.w.config.chart.locales;
      window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (n = this.w.config.chart.locales.concat(window.Apex.chart.locales));
      var a = n.filter(function(d) {
        return d.name === t;
      })[0];
      if (!a)
        throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
      var o = K.extend(it, a);
      this.w.globals.locale = o.options;
    } }]), W;
  }(), Mr = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "drawAxis", value: function(t, n) {
      var a, o, d = this, f = this.w.globals, p = this.w.config, y = new Wt(this.ctx, n), S = new jn(this.ctx, n);
      f.axisCharts && t !== "radar" && (f.isBarHorizontal ? (o = S.drawYaxisInversed(0), a = y.drawXaxisInversed(0), f.dom.elGraphical.add(a), f.dom.elGraphical.add(o)) : (a = y.drawXaxis(), f.dom.elGraphical.add(a), p.yaxis.map(function(C, E) {
        if (f.ignoreYAxisIndexes.indexOf(E) === -1 && (o = S.drawYaxis(E), f.dom.Paper.add(o), d.w.config.grid.position === "back")) {
          var L = f.dom.Paper.children()[1];
          L.remove(), f.dom.Paper.add(L);
        }
      })));
    } }]), W;
  }(), ta = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "drawXCrosshairs", value: function() {
      var t = this.w, n = new re(this.ctx), a = new Ee(this.ctx), o = t.config.xaxis.crosshairs.fill.gradient, d = t.config.xaxis.crosshairs.dropShadow, f = t.config.xaxis.crosshairs.fill.type, p = o.colorFrom, y = o.colorTo, S = o.opacityFrom, C = o.opacityTo, E = o.stops, L = d.enabled, M = d.left, P = d.top, I = d.blur, B = d.color, G = d.opacity, Z = t.config.xaxis.crosshairs.fill.color;
      if (t.config.xaxis.crosshairs.show) {
        f === "gradient" && (Z = n.drawGradient("vertical", p, y, S, C, null, E, null));
        var b = n.drawRect();
        t.config.xaxis.crosshairs.width === 1 && (b = n.drawLine());
        var O = t.globals.gridHeight;
        (!K.isNumber(O) || O < 0) && (O = 0);
        var N = t.config.xaxis.crosshairs.width;
        (!K.isNumber(N) || N < 0) && (N = 0), b.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2: O, width: N, height: O, fill: Z, filter: "none", "fill-opacity": t.config.xaxis.crosshairs.opacity, stroke: t.config.xaxis.crosshairs.stroke.color, "stroke-width": t.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": t.config.xaxis.crosshairs.stroke.dashArray }), L && (b = a.dropShadow(b, { left: M, top: P, blur: I, color: B, opacity: G })), t.globals.dom.elGraphical.add(b);
      }
    } }, { key: "drawYCrosshairs", value: function() {
      var t = this.w, n = new re(this.ctx), a = t.config.yaxis[0].crosshairs, o = t.globals.barPadForNumericAxis;
      if (t.config.yaxis[0].crosshairs.show) {
        var d = n.drawLine(-o, 0, t.globals.gridWidth + o, 0, a.stroke.color, a.stroke.dashArray, a.stroke.width);
        d.attr({ class: "apexcharts-ycrosshairs" }), t.globals.dom.elGraphical.add(d);
      }
      var f = n.drawLine(-o, 0, t.globals.gridWidth + o, 0, a.stroke.color, 0, 0);
      f.attr({ class: "apexcharts-ycrosshairs-hidden" }), t.globals.dom.elGraphical.add(f);
    } }]), W;
  }(), Za = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "checkResponsiveConfig", value: function(t) {
      var n = this, a = this.w, o = a.config;
      if (o.responsive.length !== 0) {
        var d = o.responsive.slice();
        d.sort(function(S, C) {
          return S.breakpoint > C.breakpoint ? 1 : C.breakpoint > S.breakpoint ? -1 : 0;
        }).reverse();
        var f = new pt({}), p = function() {
          var S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, C = d[0].breakpoint, E = window.innerWidth > 0 ? window.innerWidth : screen.width;
          if (E > C) {
            var L = me.extendArrayProps(f, a.globals.initialConfig, a);
            S = K.extend(L, S), S = K.extend(a.config, S), n.overrideResponsiveOptions(S);
          } else
            for (var M = 0; M < d.length; M++)
              E < d[M].breakpoint && (S = me.extendArrayProps(f, d[M].options, a), S = K.extend(a.config, S), n.overrideResponsiveOptions(S));
        };
        if (t) {
          var y = me.extendArrayProps(f, t, a);
          y = K.extend(a.config, y), p(y = K.extend(y, t));
        } else
          p({});
      }
    } }, { key: "overrideResponsiveOptions", value: function(t) {
      var n = new pt(t).init({ responsiveOverride: !0 });
      this.w.config = n;
    } }]), W;
  }(), _i = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.colors = [], this.w = t.w;
      var n = this.w;
      this.isColorFn = !1, this.isHeatmapDistributed = n.config.chart.type === "treemap" && n.config.plotOptions.treemap.distributed || n.config.chart.type === "heatmap" && n.config.plotOptions.heatmap.distributed, this.isBarDistributed = n.config.plotOptions.bar.distributed && (n.config.chart.type === "bar" || n.config.chart.type === "rangeBar");
    }
    return F(W, [{ key: "init", value: function() {
      this.setDefaultColors();
    } }, { key: "setDefaultColors", value: function() {
      var t, n = this, a = this.w, o = new K();
      if (a.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(a.config.theme.mode)), a.config.colors === void 0 || ((t = a.config.colors) === null || t === void 0 ? void 0 : t.length) === 0 ? a.globals.colors = this.predefined() : (a.globals.colors = a.config.colors, Array.isArray(a.config.colors) && a.config.colors.length > 0 && typeof a.config.colors[0] == "function" && (a.globals.colors = a.config.series.map(function(P, I) {
        var B = a.config.colors[I];
        return B || (B = a.config.colors[0]), typeof B == "function" ? (n.isColorFn = !0, B({ value: a.globals.axisCharts ? a.globals.series[I][0] ? a.globals.series[I][0] : 0 : a.globals.series[I], seriesIndex: I, dataPointIndex: I, w: a })) : B;
      }))), a.globals.seriesColors.map(function(P, I) {
        P && (a.globals.colors[I] = P);
      }), a.config.theme.monochrome.enabled) {
        var d = [], f = a.globals.series.length;
        (this.isBarDistributed || this.isHeatmapDistributed) && (f = a.globals.series[0].length * a.globals.series.length);
        for (var p = a.config.theme.monochrome.color, y = 1 / (f / a.config.theme.monochrome.shadeIntensity), S = a.config.theme.monochrome.shadeTo, C = 0, E = 0; E < f; E++) {
          var L = void 0;
          S === "dark" ? (L = o.shadeColor(-1 * C, p), C += y) : (L = o.shadeColor(C, p), C += y), d.push(L);
        }
        a.globals.colors = d.slice();
      }
      var M = a.globals.colors.slice();
      this.pushExtraColors(a.globals.colors), ["fill", "stroke"].forEach(function(P) {
        a.config[P].colors === void 0 ? a.globals[P].colors = n.isColorFn ? a.config.colors : M : a.globals[P].colors = a.config[P].colors.slice(), n.pushExtraColors(a.globals[P].colors);
      }), a.config.dataLabels.style.colors === void 0 ? a.globals.dataLabels.style.colors = M : a.globals.dataLabels.style.colors = a.config.dataLabels.style.colors.slice(), this.pushExtraColors(a.globals.dataLabels.style.colors, 50), a.config.plotOptions.radar.polygons.fill.colors === void 0 ? a.globals.radarPolygons.fill.colors = [a.config.theme.mode === "dark" ? "#424242" : "none"] : a.globals.radarPolygons.fill.colors = a.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(a.globals.radarPolygons.fill.colors, 20), a.config.markers.colors === void 0 ? a.globals.markers.colors = M : a.globals.markers.colors = a.config.markers.colors.slice(), this.pushExtraColors(a.globals.markers.colors);
    } }, { key: "pushExtraColors", value: function(t, n) {
      var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, o = this.w, d = n || o.globals.series.length;
      if (a === null && (a = this.isBarDistributed || this.isHeatmapDistributed || o.config.chart.type === "heatmap" && o.config.plotOptions.heatmap.colorScale.inverse), a && o.globals.series.length && (d = o.globals.series[o.globals.maxValsInArrayIndex].length * o.globals.series.length), t.length < d)
        for (var f = d - t.length, p = 0; p < f; p++)
          t.push(t[p]);
    } }, { key: "updateThemeOptions", value: function(t) {
      t.chart = t.chart || {}, t.tooltip = t.tooltip || {};
      var n = t.theme.mode || "light", a = t.theme.palette ? t.theme.palette : n === "dark" ? "palette4" : "palette1", o = t.chart.foreColor ? t.chart.foreColor : n === "dark" ? "#f6f7f8" : "#373d3f";
      return t.tooltip.theme = n, t.chart.foreColor = o, t.theme.palette = a, t;
    } }, { key: "predefined", value: function() {
      switch (this.w.config.theme.palette) {
        case "palette1":
        default:
          this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
          break;
        case "palette2":
          this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
          break;
        case "palette3":
          this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
          break;
        case "palette4":
          this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
          break;
        case "palette5":
          this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
          break;
        case "palette6":
          this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
          break;
        case "palette7":
          this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
          break;
        case "palette8":
          this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
          break;
        case "palette9":
          this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
          break;
        case "palette10":
          this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"];
      }
      return this.colors;
    } }]), W;
  }(), di = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "draw", value: function() {
      this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
    } }, { key: "drawTitleSubtitle", value: function(t) {
      var n = this.w, a = t === "title" ? n.config.title : n.config.subtitle, o = n.globals.svgWidth / 2, d = a.offsetY, f = "middle";
      if (a.align === "left" ? (o = 10, f = "start") : a.align === "right" && (o = n.globals.svgWidth - 10, f = "end"), o += a.offsetX, d = d + parseInt(a.style.fontSize, 10) + a.margin / 2, a.text !== void 0) {
        var p = new re(this.ctx).drawText({ x: o, y: d, text: a.text, textAnchor: f, fontSize: a.style.fontSize, fontFamily: a.style.fontFamily, fontWeight: a.style.fontWeight, foreColor: a.style.color, opacity: 1 });
        p.node.setAttribute("class", "apexcharts-".concat(t, "-text")), n.globals.dom.Paper.add(p);
      }
    } }]), W;
  }(), Qa = function() {
    function W(t) {
      T(this, W), this.w = t.w, this.dCtx = t;
    }
    return F(W, [{ key: "getTitleSubtitleCoords", value: function(t) {
      var n = this.w, a = 0, o = 0, d = t === "title" ? n.config.title.floating : n.config.subtitle.floating, f = n.globals.dom.baseEl.querySelector(".apexcharts-".concat(t, "-text"));
      if (f !== null && !d) {
        var p = f.getBoundingClientRect();
        a = p.width, o = n.globals.axisCharts ? p.height + 5 : p.height;
      }
      return { width: a, height: o };
    } }, { key: "getLegendsRect", value: function() {
      var t = this.w, n = t.globals.dom.elLegendWrap;
      t.config.legend.height || t.config.legend.position !== "top" && t.config.legend.position !== "bottom" || (n.style.maxHeight = t.globals.svgHeight / 2 + "px");
      var a = Object.assign({}, K.getBoundingClientRect(n));
      return n !== null && !t.config.legend.floating && t.config.legend.show ? this.dCtx.lgRect = { x: a.x, y: a.y, height: a.height, width: a.height === 0 ? 0 : a.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, t.config.legend.position !== "left" && t.config.legend.position !== "right" || 1.5 * this.dCtx.lgRect.width > t.globals.svgWidth && (this.dCtx.lgRect.width = t.globals.svgWidth / 1.5), this.dCtx.lgRect;
    } }, { key: "getLargestStringFromMultiArr", value: function(t, n) {
      var a = t;
      if (this.w.globals.isMultiLineX) {
        var o = n.map(function(f, p) {
          return Array.isArray(f) ? f.length : 1;
        }), d = Math.max.apply(Math, ue(o));
        a = n[o.indexOf(d)];
      }
      return a;
    } }]), W;
  }(), ya = function() {
    function W(t) {
      T(this, W), this.w = t.w, this.dCtx = t;
    }
    return F(W, [{ key: "getxAxisLabelsCoords", value: function() {
      var t, n = this.w, a = n.globals.labels.slice();
      if (n.config.xaxis.convertedCatToNumeric && a.length === 0 && (a = n.globals.categoryLabels), n.globals.timescaleLabels.length > 0) {
        var o = this.getxAxisTimeScaleLabelsCoords();
        t = { width: o.width, height: o.height }, n.globals.rotateXLabels = !1;
      } else {
        this.dCtx.lgWidthForSideLegends = n.config.legend.position !== "left" && n.config.legend.position !== "right" || n.config.legend.floating ? 0 : this.dCtx.lgRect.width;
        var d = n.globals.xLabelFormatter, f = K.getLargestStringFromArr(a), p = this.dCtx.dimHelpers.getLargestStringFromMultiArr(f, a);
        n.globals.isBarHorizontal && (p = f = n.globals.yAxisScale[0].result.reduce(function(P, I) {
          return P.length > I.length ? P : I;
        }, 0));
        var y = new Tt(this.dCtx.ctx), S = f;
        f = y.xLabelFormat(d, f, S, { i: void 0, dateFormatter: new Ze(this.dCtx.ctx).formatDate, w: n }), p = y.xLabelFormat(d, p, S, { i: void 0, dateFormatter: new Ze(this.dCtx.ctx).formatDate, w: n }), (n.config.xaxis.convertedCatToNumeric && f === void 0 || String(f).trim() === "") && (p = f = "1");
        var C = new re(this.dCtx.ctx), E = C.getTextRects(f, n.config.xaxis.labels.style.fontSize), L = E;
        if (f !== p && (L = C.getTextRects(p, n.config.xaxis.labels.style.fontSize)), (t = { width: E.width >= L.width ? E.width : L.width, height: E.height >= L.height ? E.height : L.height }).width * a.length > n.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && n.config.xaxis.labels.rotate !== 0 || n.config.xaxis.labels.rotateAlways) {
          if (!n.globals.isBarHorizontal) {
            n.globals.rotateXLabels = !0;
            var M = function(P) {
              return C.getTextRects(P, n.config.xaxis.labels.style.fontSize, n.config.xaxis.labels.style.fontFamily, "rotate(".concat(n.config.xaxis.labels.rotate, " 0 0)"), !1);
            };
            E = M(f), f !== p && (L = M(p)), t.height = (E.height > L.height ? E.height : L.height) / 1.5, t.width = E.width > L.width ? E.width : L.width;
          }
        } else
          n.globals.rotateXLabels = !1;
      }
      return n.config.xaxis.labels.show || (t = { width: 0, height: 0 }), { width: t.width, height: t.height };
    } }, { key: "getxAxisGroupLabelsCoords", value: function() {
      var t, n = this.w;
      if (!n.globals.hasXaxisGroups)
        return { width: 0, height: 0 };
      var a, o = ((t = n.config.xaxis.group.style) === null || t === void 0 ? void 0 : t.fontSize) || n.config.xaxis.labels.style.fontSize, d = n.globals.groups.map(function(E) {
        return E.title;
      }), f = K.getLargestStringFromArr(d), p = this.dCtx.dimHelpers.getLargestStringFromMultiArr(f, d), y = new re(this.dCtx.ctx), S = y.getTextRects(f, o), C = S;
      return f !== p && (C = y.getTextRects(p, o)), a = { width: S.width >= C.width ? S.width : C.width, height: S.height >= C.height ? S.height : C.height }, n.config.xaxis.labels.show || (a = { width: 0, height: 0 }), { width: a.width, height: a.height };
    } }, { key: "getxAxisTitleCoords", value: function() {
      var t = this.w, n = 0, a = 0;
      if (t.config.xaxis.title.text !== void 0) {
        var o = new re(this.dCtx.ctx).getTextRects(t.config.xaxis.title.text, t.config.xaxis.title.style.fontSize);
        n = o.width, a = o.height;
      }
      return { width: n, height: a };
    } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
      var t, n = this.w;
      this.dCtx.timescaleLabels = n.globals.timescaleLabels.slice();
      var a = this.dCtx.timescaleLabels.map(function(d) {
        return d.value;
      }), o = a.reduce(function(d, f) {
        return d === void 0 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : d.length > f.length ? d : f;
      }, 0);
      return 1.05 * (t = new re(this.dCtx.ctx).getTextRects(o, n.config.xaxis.labels.style.fontSize)).width * a.length > n.globals.gridWidth && n.config.xaxis.labels.rotate !== 0 && (n.globals.overlappingXLabels = !0), t;
    } }, { key: "additionalPaddingXLabels", value: function(t) {
      var n = this, a = this.w, o = a.globals, d = a.config, f = d.xaxis.type, p = t.width;
      o.skipLastTimelinelabel = !1, o.skipFirstTimelinelabel = !1;
      var y = a.config.yaxis[0].opposite && a.globals.isBarHorizontal, S = function(C, E) {
        d.yaxis.length > 1 && function(L) {
          return o.collapsedSeriesIndices.indexOf(L) !== -1;
        }(E) || function(L) {
          if (n.dCtx.timescaleLabels && n.dCtx.timescaleLabels.length) {
            var M = n.dCtx.timescaleLabels[0], P = n.dCtx.timescaleLabels[n.dCtx.timescaleLabels.length - 1].position + p / 1.75 - n.dCtx.yAxisWidthRight, I = M.position - p / 1.75 + n.dCtx.yAxisWidthLeft, B = a.config.legend.position === "right" && n.dCtx.lgRect.width > 0 ? n.dCtx.lgRect.width : 0;
            P > o.svgWidth - o.translateX - B && (o.skipLastTimelinelabel = !0), I < -(L.show && !L.floating || d.chart.type !== "bar" && d.chart.type !== "candlestick" && d.chart.type !== "rangeBar" && d.chart.type !== "boxPlot" ? 10 : p / 1.75) && (o.skipFirstTimelinelabel = !0);
          } else
            f === "datetime" ? n.dCtx.gridPad.right < p && !o.rotateXLabels && (o.skipLastTimelinelabel = !0) : f !== "datetime" && n.dCtx.gridPad.right < p / 2 - n.dCtx.yAxisWidthRight && !o.rotateXLabels && !a.config.xaxis.labels.trim && (a.config.xaxis.tickPlacement !== "between" || a.globals.isBarHorizontal) && (n.dCtx.xPadRight = p / 2 + 1);
        }(C);
      };
      d.yaxis.forEach(function(C, E) {
        y ? (n.dCtx.gridPad.left < p && (n.dCtx.xPadLeft = p / 2 + 1), n.dCtx.xPadRight = p / 2 + 1) : S(C, E);
      });
    } }]), W;
  }(), fi = function() {
    function W(t) {
      T(this, W), this.w = t.w, this.dCtx = t;
    }
    return F(W, [{ key: "getyAxisLabelsCoords", value: function() {
      var t = this, n = this.w, a = [], o = 10, d = new Et(this.dCtx.ctx);
      return n.config.yaxis.map(function(f, p) {
        var y = n.globals.yAxisScale[p], S = 0;
        if (!d.isYAxisHidden(p) && f.labels.show && f.labels.minWidth !== void 0 && (S = f.labels.minWidth), !d.isYAxisHidden(p) && f.labels.show && y.result.length) {
          var C = n.globals.yLabelFormatters[p], E = y.niceMin === Number.MIN_VALUE ? 0 : y.niceMin, L = String(E).length > String(y.niceMax).length ? E : y.niceMax, M = C(L, { seriesIndex: p, dataPointIndex: -1, w: n }), P = M;
          if (M !== void 0 && M.length !== 0 || (M = L), n.globals.isBarHorizontal) {
            o = 0;
            var I = n.globals.labels.slice();
            M = C(M = K.getLargestStringFromArr(I), { seriesIndex: p, dataPointIndex: -1, w: n }), P = t.dCtx.dimHelpers.getLargestStringFromMultiArr(M, I);
          }
          var B = new re(t.dCtx.ctx), G = "rotate(".concat(f.labels.rotate, " 0 0)"), Z = B.getTextRects(M, f.labels.style.fontSize, f.labels.style.fontFamily, G, !1), b = Z;
          M !== P && (b = B.getTextRects(P, f.labels.style.fontSize, f.labels.style.fontFamily, G, !1)), a.push({ width: (S > b.width || S > Z.width ? S : b.width > Z.width ? b.width : Z.width) + o, height: b.height > Z.height ? b.height : Z.height });
        } else
          a.push({ width: 0, height: 0 });
      }), a;
    } }, { key: "getyAxisTitleCoords", value: function() {
      var t = this, n = this.w, a = [];
      return n.config.yaxis.map(function(o, d) {
        if (o.show && o.title.text !== void 0) {
          var f = new re(t.dCtx.ctx), p = "rotate(".concat(o.title.rotate, " 0 0)"), y = f.getTextRects(o.title.text, o.title.style.fontSize, o.title.style.fontFamily, p, !1);
          a.push({ width: y.width, height: y.height });
        } else
          a.push({ width: 0, height: 0 });
      }), a;
    } }, { key: "getTotalYAxisWidth", value: function() {
      var t = this.w, n = 0, a = 0, o = 0, d = t.globals.yAxisScale.length > 1 ? 10 : 0, f = new Et(this.dCtx.ctx), p = function(y, S) {
        var C = t.config.yaxis[S].floating, E = 0;
        y.width > 0 && !C ? (E = y.width + d, function(L) {
          return t.globals.ignoreYAxisIndexes.indexOf(L) > -1;
        }(S) && (E = E - y.width - d)) : E = C || f.isYAxisHidden(S) ? 0 : 5, t.config.yaxis[S].opposite ? o += E : a += E, n += E;
      };
      return t.globals.yLabelsCoords.map(function(y, S) {
        p(y, S);
      }), t.globals.yTitleCoords.map(function(y, S) {
        p(y, S);
      }), t.globals.isBarHorizontal && !t.config.yaxis[0].floating && (n = t.globals.yLabelsCoords[0].width + t.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = a, this.dCtx.yAxisWidthRight = o, n;
    } }]), W;
  }(), xa = function() {
    function W(t) {
      T(this, W), this.w = t.w, this.dCtx = t;
    }
    return F(W, [{ key: "gridPadForColumnsInNumericAxis", value: function(t) {
      var n = this.w;
      if (n.globals.noData || n.globals.allSeriesCollapsed)
        return 0;
      var a = function(C) {
        return C === "bar" || C === "rangeBar" || C === "candlestick" || C === "boxPlot";
      }, o = n.config.chart.type, d = 0, f = a(o) ? n.config.series.length : 1;
      if (n.globals.comboBarCount > 0 && (f = n.globals.comboBarCount), n.globals.collapsedSeries.forEach(function(C) {
        a(C.type) && (f -= 1);
      }), n.config.chart.stacked && (f = 1), (a(o) || n.globals.comboBarCount > 0) && n.globals.isXNumeric && !n.globals.isBarHorizontal && f > 0) {
        var p, y, S = Math.abs(n.globals.initialMaxX - n.globals.initialMinX);
        S <= 3 && (S = n.globals.dataPoints), p = S / t, n.globals.minXDiff && n.globals.minXDiff / p > 0 && (y = n.globals.minXDiff / p), y > t / 2 && (y /= 2), (d = y / f * parseInt(n.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (d = 1), d = d / (f > 1 ? 1 : 1.5) + 5, n.globals.barPadForNumericAxis = d;
      }
      return d;
    } }, { key: "gridPadFortitleSubtitle", value: function() {
      var t = this, n = this.w, a = n.globals, o = this.dCtx.isSparkline || !n.globals.axisCharts ? 0 : 10;
      ["title", "subtitle"].forEach(function(p) {
        n.config[p].text !== void 0 ? o += n.config[p].margin : o += t.dCtx.isSparkline || !n.globals.axisCharts ? 0 : 5;
      }), !n.config.legend.show || n.config.legend.position !== "bottom" || n.config.legend.floating || n.globals.axisCharts || (o += 10);
      var d = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), f = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
      a.gridHeight = a.gridHeight - d.height - f.height - o, a.translateY = a.translateY + d.height + f.height + o;
    } }, { key: "setGridXPosForDualYAxis", value: function(t, n) {
      var a = this.w, o = new Et(this.dCtx.ctx);
      a.config.yaxis.map(function(d, f) {
        a.globals.ignoreYAxisIndexes.indexOf(f) !== -1 || d.floating || o.isYAxisHidden(f) || (d.opposite && (a.globals.translateX = a.globals.translateX - (n[f].width + t[f].width) - parseInt(a.config.yaxis[f].labels.style.fontSize, 10) / 1.2 - 12), a.globals.translateX < 2 && (a.globals.translateX = 2));
      });
    } }]), W;
  }(), na = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new Qa(this), this.dimYAxis = new fi(this), this.dimXAxis = new ya(this), this.dimGrid = new xa(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
    }
    return F(W, [{ key: "plotCoords", value: function() {
      var t = this, n = this.w, a = n.globals;
      this.lgRect = this.dimHelpers.getLegendsRect(), this.isSparkline && (n.config.markers.discrete.length > 0 || n.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(d) {
        var f = se(d, 2), p = f[0], y = f[1];
        t.gridPad[p] = Math.max(y, t.w.globals.markers.largestSize / 1.5);
      }), a.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), a.gridHeight = a.gridHeight - this.gridPad.top - this.gridPad.bottom, a.gridWidth = a.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
      var o = this.dimGrid.gridPadForColumnsInNumericAxis(a.gridWidth);
      a.gridWidth = a.gridWidth - 2 * o, a.translateX = a.translateX + this.gridPad.left + this.xPadLeft + (o > 0 ? o + 4 : 0), a.translateY = a.translateY + this.gridPad.top;
    } }, { key: "setDimensionsForAxisCharts", value: function() {
      var t = this, n = this.w, a = n.globals, o = this.dimYAxis.getyAxisLabelsCoords(), d = this.dimYAxis.getyAxisTitleCoords();
      n.globals.yLabelsCoords = [], n.globals.yTitleCoords = [], n.config.yaxis.map(function(M, P) {
        n.globals.yLabelsCoords.push({ width: o[P].width, index: P }), n.globals.yTitleCoords.push({ width: d[P].width, index: P });
      }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
      var f = this.dimXAxis.getxAxisLabelsCoords(), p = this.dimXAxis.getxAxisGroupLabelsCoords(), y = this.dimXAxis.getxAxisTitleCoords();
      this.conditionalChecksForAxisCoords(f, y, p), a.translateXAxisY = n.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, a.translateXAxisX = n.globals.rotateXLabels && n.globals.isXNumeric && n.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, n.globals.isBarHorizontal && (a.rotateXLabels = !1, a.translateXAxisY = parseInt(n.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), a.translateXAxisY = a.translateXAxisY + n.config.xaxis.labels.offsetY, a.translateXAxisX = a.translateXAxisX + n.config.xaxis.labels.offsetX;
      var S = this.yAxisWidth, C = this.xAxisHeight;
      a.xAxisLabelsHeight = this.xAxisHeight - y.height, a.xAxisGroupLabelsHeight = a.xAxisLabelsHeight - f.height, a.xAxisLabelsWidth = this.xAxisWidth, a.xAxisHeight = this.xAxisHeight;
      var E = 10;
      (n.config.chart.type === "radar" || this.isSparkline) && (S = 0, C = a.goldenPadding), this.isSparkline && (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || n.config.chart.type === "treemap") && (S = 0, C = 0, E = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(f);
      var L = function() {
        a.translateX = S, a.gridHeight = a.svgHeight - t.lgRect.height - C - (t.isSparkline || n.config.chart.type === "treemap" ? 0 : n.globals.rotateXLabels ? 10 : 15), a.gridWidth = a.svgWidth - S;
      };
      switch (n.config.xaxis.position === "top" && (E = a.xAxisHeight - n.config.xaxis.axisTicks.height - 5), n.config.legend.position) {
        case "bottom":
          a.translateY = E, L();
          break;
        case "top":
          a.translateY = this.lgRect.height + E, L();
          break;
        case "left":
          a.translateY = E, a.translateX = this.lgRect.width + S, a.gridHeight = a.svgHeight - C - 12, a.gridWidth = a.svgWidth - this.lgRect.width - S;
          break;
        case "right":
          a.translateY = E, a.translateX = S, a.gridHeight = a.svgHeight - C - 12, a.gridWidth = a.svgWidth - this.lgRect.width - S - 5;
          break;
        default:
          throw new Error("Legend position not supported");
      }
      this.dimGrid.setGridXPosForDualYAxis(d, o), new jn(this.ctx).setYAxisXPosition(o, d);
    } }, { key: "setDimensionsForNonAxisCharts", value: function() {
      var t = this.w, n = t.globals, a = t.config, o = 0;
      t.config.legend.show && !t.config.legend.floating && (o = 20);
      var d = a.chart.type === "pie" || a.chart.type === "polarArea" || a.chart.type === "donut" ? "pie" : "radialBar", f = a.plotOptions[d].offsetY, p = a.plotOptions[d].offsetX;
      if (!a.legend.show || a.legend.floating)
        return n.gridHeight = n.svgHeight - a.grid.padding.left + a.grid.padding.right, n.gridWidth = n.gridHeight, n.translateY = f, void (n.translateX = p + (n.svgWidth - n.gridWidth) / 2);
      switch (a.legend.position) {
        case "bottom":
          n.gridHeight = n.svgHeight - this.lgRect.height - n.goldenPadding, n.gridWidth = n.svgWidth, n.translateY = f - 10, n.translateX = p + (n.svgWidth - n.gridWidth) / 2;
          break;
        case "top":
          n.gridHeight = n.svgHeight - this.lgRect.height - n.goldenPadding, n.gridWidth = n.svgWidth, n.translateY = this.lgRect.height + f + 10, n.translateX = p + (n.svgWidth - n.gridWidth) / 2;
          break;
        case "left":
          n.gridWidth = n.svgWidth - this.lgRect.width - o, n.gridHeight = a.chart.height !== "auto" ? n.svgHeight : n.gridWidth, n.translateY = f, n.translateX = p + this.lgRect.width + o;
          break;
        case "right":
          n.gridWidth = n.svgWidth - this.lgRect.width - o - 5, n.gridHeight = a.chart.height !== "auto" ? n.svgHeight : n.gridWidth, n.translateY = f, n.translateX = p + 10;
          break;
        default:
          throw new Error("Legend position not supported");
      }
    } }, { key: "conditionalChecksForAxisCoords", value: function(t, n, a) {
      var o = this.w, d = o.globals.hasXaxisGroups ? 2 : 1, f = a.height + t.height + n.height, p = o.globals.isMultiLineX ? 1.2 : o.globals.LINE_HEIGHT_RATIO, y = o.globals.rotateXLabels ? 22 : 10, S = o.globals.rotateXLabels && o.config.legend.position === "bottom" ? 10 : 0;
      this.xAxisHeight = f * p + d * y + S, this.xAxisWidth = t.width, this.xAxisHeight - n.height > o.config.xaxis.labels.maxHeight && (this.xAxisHeight = o.config.xaxis.labels.maxHeight), o.config.xaxis.labels.minHeight && this.xAxisHeight < o.config.xaxis.labels.minHeight && (this.xAxisHeight = o.config.xaxis.labels.minHeight), o.config.xaxis.floating && (this.xAxisHeight = 0);
      var C = 0, E = 0;
      o.config.yaxis.forEach(function(L) {
        C += L.labels.minWidth, E += L.labels.maxWidth;
      }), this.yAxisWidth < C && (this.yAxisWidth = C), this.yAxisWidth > E && (this.yAxisWidth = E);
    } }]), W;
  }(), sr = function() {
    function W(t) {
      T(this, W), this.w = t.w, this.lgCtx = t;
    }
    return F(W, [{ key: "getLegendStyles", value: function() {
      var t = document.createElement("style");
      t.setAttribute("type", "text/css");
      var n = document.createTextNode(`	
    	
      .apexcharts-legend {	
        display: flex;	
        overflow: auto;	
        padding: 0 10px;	
      }	
      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {	
        flex-wrap: wrap	
      }	
      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {	
        flex-direction: column;	
        bottom: 0;	
      }	
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {	
        justify-content: flex-start;	
      }	
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {	
        justify-content: center;  	
      }	
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {	
        justify-content: flex-end;	
      }	
      .apexcharts-legend-series {	
        cursor: pointer;	
        line-height: normal;	
      }	
      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{	
        display: flex;	
        align-items: center;	
      }	
      .apexcharts-legend-text {	
        position: relative;	
        font-size: 14px;	
      }	
      .apexcharts-legend-text *, .apexcharts-legend-marker * {	
        pointer-events: none;	
      }	
      .apexcharts-legend-marker {	
        position: relative;	
        display: inline-block;	
        cursor: pointer;	
        margin-right: 3px;	
        border-style: solid;
      }	
      	
      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{	
        display: inline-block;	
      }	
      .apexcharts-legend-series.apexcharts-no-click {	
        cursor: auto;	
      }	
      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {	
        display: none !important;	
      }	
      .apexcharts-inactive-legend {	
        opacity: 0.45;	
      }`);
      return t.appendChild(n), t;
    } }, { key: "getLegendBBox", value: function() {
      var t = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), n = t.width;
      return { clwh: t.height, clww: n };
    } }, { key: "appendToForeignObject", value: function() {
      this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
    } }, { key: "toggleDataSeries", value: function(t, n) {
      var a = this, o = this.w;
      if (o.globals.axisCharts || o.config.chart.type === "radialBar") {
        o.globals.resized = !0;
        var d = null, f = null;
        o.globals.risingSeries = [], o.globals.axisCharts ? (d = o.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "']")), f = parseInt(d.getAttribute("data:realIndex"), 10)) : (d = o.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t + 1, "']")), f = parseInt(d.getAttribute("rel"), 10) - 1), n ? [{ cs: o.globals.collapsedSeries, csi: o.globals.collapsedSeriesIndices }, { cs: o.globals.ancillaryCollapsedSeries, csi: o.globals.ancillaryCollapsedSeriesIndices }].forEach(function(C) {
          a.riseCollapsedSeries(C.cs, C.csi, f);
        }) : this.hideSeries({ seriesEl: d, realIndex: f });
      } else {
        var p = o.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t + 1, "'] path")), y = o.config.chart.type;
        if (y === "pie" || y === "polarArea" || y === "donut") {
          var S = o.config.plotOptions.pie.donut.labels;
          new re(this.lgCtx.ctx).pathMouseDown(p.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(p.members[0].node, S);
        }
        p.fire("click");
      }
    } }, { key: "hideSeries", value: function(t) {
      var n = t.seriesEl, a = t.realIndex, o = this.w, d = K.clone(o.config.series);
      if (o.globals.axisCharts) {
        var f = !1;
        if (o.config.yaxis[a] && o.config.yaxis[a].show && o.config.yaxis[a].showAlways && (f = !0, o.globals.ancillaryCollapsedSeriesIndices.indexOf(a) < 0 && (o.globals.ancillaryCollapsedSeries.push({ index: a, data: d[a].data.slice(), type: n.parentNode.className.baseVal.split("-")[1] }), o.globals.ancillaryCollapsedSeriesIndices.push(a))), !f) {
          o.globals.collapsedSeries.push({ index: a, data: d[a].data.slice(), type: n.parentNode.className.baseVal.split("-")[1] }), o.globals.collapsedSeriesIndices.push(a);
          var p = o.globals.risingSeries.indexOf(a);
          o.globals.risingSeries.splice(p, 1);
        }
      } else
        o.globals.collapsedSeries.push({ index: a, data: d[a] }), o.globals.collapsedSeriesIndices.push(a);
      for (var y = n.childNodes, S = 0; S < y.length; S++)
        y[S].classList.contains("apexcharts-series-markers-wrap") && (y[S].classList.contains("apexcharts-hide") ? y[S].classList.remove("apexcharts-hide") : y[S].classList.add("apexcharts-hide"));
      o.globals.allSeriesCollapsed = o.globals.collapsedSeries.length === o.config.series.length, d = this._getSeriesBasedOnCollapsedState(d), this.lgCtx.ctx.updateHelpers._updateSeries(d, o.config.chart.animations.dynamicAnimation.enabled);
    } }, { key: "riseCollapsedSeries", value: function(t, n, a) {
      var o = this.w, d = K.clone(o.config.series);
      if (t.length > 0) {
        for (var f = 0; f < t.length; f++)
          t[f].index === a && (o.globals.axisCharts ? (d[a].data = t[f].data.slice(), t.splice(f, 1), n.splice(f, 1), o.globals.risingSeries.push(a)) : (d[a] = t[f].data, t.splice(f, 1), n.splice(f, 1), o.globals.risingSeries.push(a)));
        d = this._getSeriesBasedOnCollapsedState(d), this.lgCtx.ctx.updateHelpers._updateSeries(d, o.config.chart.animations.dynamicAnimation.enabled);
      }
    } }, { key: "_getSeriesBasedOnCollapsedState", value: function(t) {
      var n = this.w;
      return n.globals.axisCharts ? t.forEach(function(a, o) {
        n.globals.collapsedSeriesIndices.indexOf(o) > -1 && (t[o].data = []);
      }) : t.forEach(function(a, o) {
        n.globals.collapsedSeriesIndices.indexOf(o) > -1 && (t[o] = 0);
      }), t;
    } }]), W;
  }(), ra = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = this.w.config.chart.type === "bar" && this.w.config.plotOptions.bar.distributed && this.w.config.series.length === 1, this.legendHelpers = new sr(this);
    }
    return F(W, [{ key: "init", value: function() {
      var t = this.w, n = t.globals, a = t.config;
      if ((a.legend.showForSingleSeries && n.series.length === 1 || this.isBarsDistributed || n.series.length > 1 || !n.axisCharts) && a.legend.show) {
        for (; n.dom.elLegendWrap.firstChild; )
          n.dom.elLegendWrap.removeChild(n.dom.elLegendWrap.firstChild);
        this.drawLegends(), K.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), a.legend.position === "bottom" || a.legend.position === "top" ? this.legendAlignHorizontal() : a.legend.position !== "right" && a.legend.position !== "left" || this.legendAlignVertical();
      }
    } }, { key: "drawLegends", value: function() {
      var t = this, n = this.w, a = n.config.legend.fontFamily, o = n.globals.seriesNames, d = n.globals.colors.slice();
      if (n.config.chart.type === "heatmap") {
        var f = n.config.plotOptions.heatmap.colorScale.ranges;
        o = f.map(function(Le) {
          return Le.name ? Le.name : Le.from + " - " + Le.to;
        }), d = f.map(function(Le) {
          return Le.color;
        });
      } else
        this.isBarsDistributed && (o = n.globals.labels.slice());
      n.config.legend.customLegendItems.length && (o = n.config.legend.customLegendItems);
      for (var p = n.globals.legendFormatter, y = n.config.legend.inverseOrder, S = y ? o.length - 1 : 0; y ? S >= 0 : S <= o.length - 1; y ? S-- : S++) {
        var C, E = p(o[S], { seriesIndex: S, w: n }), L = !1, M = !1;
        if (n.globals.collapsedSeries.length > 0)
          for (var P = 0; P < n.globals.collapsedSeries.length; P++)
            n.globals.collapsedSeries[P].index === S && (L = !0);
        if (n.globals.ancillaryCollapsedSeriesIndices.length > 0)
          for (var I = 0; I < n.globals.ancillaryCollapsedSeriesIndices.length; I++)
            n.globals.ancillaryCollapsedSeriesIndices[I] === S && (M = !0);
        var B = document.createElement("span");
        B.classList.add("apexcharts-legend-marker");
        var G = n.config.legend.markers.offsetX, Z = n.config.legend.markers.offsetY, b = n.config.legend.markers.height, O = n.config.legend.markers.width, N = n.config.legend.markers.strokeWidth, X = n.config.legend.markers.strokeColor, Q = n.config.legend.markers.radius, ee = B.style;
        ee.background = d[S], ee.color = d[S], ee.setProperty("background", d[S], "important"), n.config.legend.markers.fillColors && n.config.legend.markers.fillColors[S] && (ee.background = n.config.legend.markers.fillColors[S]), n.globals.seriesColors[S] !== void 0 && (ee.background = n.globals.seriesColors[S], ee.color = n.globals.seriesColors[S]), ee.height = Array.isArray(b) ? parseFloat(b[S]) + "px" : parseFloat(b) + "px", ee.width = Array.isArray(O) ? parseFloat(O[S]) + "px" : parseFloat(O) + "px", ee.left = (Array.isArray(G) ? parseFloat(G[S]) : parseFloat(G)) + "px", ee.top = (Array.isArray(Z) ? parseFloat(Z[S]) : parseFloat(Z)) + "px", ee.borderWidth = Array.isArray(N) ? N[S] : N, ee.borderColor = Array.isArray(X) ? X[S] : X, ee.borderRadius = Array.isArray(Q) ? parseFloat(Q[S]) + "px" : parseFloat(Q) + "px", n.config.legend.markers.customHTML && (Array.isArray(n.config.legend.markers.customHTML) ? n.config.legend.markers.customHTML[S] && (B.innerHTML = n.config.legend.markers.customHTML[S]()) : B.innerHTML = n.config.legend.markers.customHTML()), re.setAttrs(B, { rel: S + 1, "data:collapsed": L || M }), (L || M) && B.classList.add("apexcharts-inactive-legend");
        var oe = document.createElement("div"), fe = document.createElement("span");
        fe.classList.add("apexcharts-legend-text"), fe.innerHTML = Array.isArray(E) ? E.join(" ") : E;
        var ke = n.config.legend.labels.useSeriesColors ? n.globals.colors[S] : Array.isArray(n.config.legend.labels.colors) ? (C = n.config.legend.labels.colors) === null || C === void 0 ? void 0 : C[S] : n.config.legend.labels.colors;
        ke || (ke = n.config.chart.foreColor), fe.style.color = ke, fe.style.fontSize = parseFloat(n.config.legend.fontSize) + "px", fe.style.fontWeight = n.config.legend.fontWeight, fe.style.fontFamily = a || n.config.chart.fontFamily, re.setAttrs(fe, { rel: S + 1, i: S, "data:default-text": encodeURIComponent(E), "data:collapsed": L || M }), oe.appendChild(B), oe.appendChild(fe);
        var _e = new me(this.ctx);
        n.config.legend.showForZeroSeries || _e.getSeriesTotalByIndex(S) === 0 && _e.seriesHaveSameValues(S) && !_e.isSeriesNull(S) && n.globals.collapsedSeriesIndices.indexOf(S) === -1 && n.globals.ancillaryCollapsedSeriesIndices.indexOf(S) === -1 && oe.classList.add("apexcharts-hidden-zero-series"), n.config.legend.showForNullSeries || _e.isSeriesNull(S) && n.globals.collapsedSeriesIndices.indexOf(S) === -1 && n.globals.ancillaryCollapsedSeriesIndices.indexOf(S) === -1 && oe.classList.add("apexcharts-hidden-null-series"), n.globals.dom.elLegendWrap.appendChild(oe), n.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(n.config.legend.horizontalAlign)), n.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + n.config.legend.position), oe.classList.add("apexcharts-legend-series"), oe.style.margin = "".concat(n.config.legend.itemMargin.vertical, "px ").concat(n.config.legend.itemMargin.horizontal, "px"), n.globals.dom.elLegendWrap.style.width = n.config.legend.width ? n.config.legend.width + "px" : "", n.globals.dom.elLegendWrap.style.height = n.config.legend.height ? n.config.legend.height + "px" : "", re.setAttrs(oe, { rel: S + 1, seriesName: K.escapeString(o[S]), "data:collapsed": L || M }), (L || M) && oe.classList.add("apexcharts-inactive-legend"), n.config.legend.onItemClick.toggleDataSeries || oe.classList.add("apexcharts-no-click");
      }
      n.globals.dom.elWrap.addEventListener("click", t.onLegendClick, !0), n.config.legend.onItemHover.highlightDataSeries && n.config.legend.customLegendItems.length === 0 && (n.globals.dom.elWrap.addEventListener("mousemove", t.onLegendHovered, !0), n.globals.dom.elWrap.addEventListener("mouseout", t.onLegendHovered, !0));
    } }, { key: "setLegendWrapXY", value: function(t, n) {
      var a = this.w, o = a.globals.dom.elLegendWrap, d = o.getBoundingClientRect(), f = 0, p = 0;
      if (a.config.legend.position === "bottom")
        p += a.globals.svgHeight - d.height / 2;
      else if (a.config.legend.position === "top") {
        var y = new na(this.ctx), S = y.dimHelpers.getTitleSubtitleCoords("title").height, C = y.dimHelpers.getTitleSubtitleCoords("subtitle").height;
        p = p + (S > 0 ? S - 10 : 0) + (C > 0 ? C - 10 : 0);
      }
      o.style.position = "absolute", f = f + t + a.config.legend.offsetX, p = p + n + a.config.legend.offsetY, o.style.left = f + "px", o.style.top = p + "px", a.config.legend.position === "bottom" ? (o.style.top = "auto", o.style.bottom = 5 - a.config.legend.offsetY + "px") : a.config.legend.position === "right" && (o.style.left = "auto", o.style.right = 25 + a.config.legend.offsetX + "px"), ["width", "height"].forEach(function(E) {
        o.style[E] && (o.style[E] = parseInt(a.config.legend[E], 10) + "px");
      });
    } }, { key: "legendAlignHorizontal", value: function() {
      var t = this.w;
      t.globals.dom.elLegendWrap.style.right = 0;
      var n = this.legendHelpers.getLegendBBox(), a = new na(this.ctx), o = a.dimHelpers.getTitleSubtitleCoords("title"), d = a.dimHelpers.getTitleSubtitleCoords("subtitle"), f = 0;
      t.config.legend.position === "bottom" ? f = -n.clwh / 1.8 : t.config.legend.position === "top" && (f = o.height + d.height + t.config.title.margin + t.config.subtitle.margin - 10), this.setLegendWrapXY(20, f);
    } }, { key: "legendAlignVertical", value: function() {
      var t = this.w, n = this.legendHelpers.getLegendBBox(), a = 0;
      t.config.legend.position === "left" && (a = 20), t.config.legend.position === "right" && (a = t.globals.svgWidth - n.clww - 10), this.setLegendWrapXY(a, 20);
    } }, { key: "onLegendHovered", value: function(t) {
      var n = this.w, a = t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker");
      if (n.config.chart.type === "heatmap" || this.isBarsDistributed) {
        if (a) {
          var o = parseInt(t.target.getAttribute("rel"), 10) - 1;
          this.ctx.events.fireEvent("legendHover", [this.ctx, o, this.w]), new st(this.ctx).highlightRangeInSeries(t, t.target);
        }
      } else
        !t.target.classList.contains("apexcharts-inactive-legend") && a && new st(this.ctx).toggleSeriesOnHover(t, t.target);
    } }, { key: "onLegendClick", value: function(t) {
      var n = this.w;
      if (!n.config.legend.customLegendItems.length && (t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker"))) {
        var a = parseInt(t.target.getAttribute("rel"), 10) - 1, o = t.target.getAttribute("data:collapsed") === "true", d = this.w.config.chart.events.legendClick;
        typeof d == "function" && d(this.ctx, a, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, a, this.w]);
        var f = this.w.config.legend.markers.onClick;
        typeof f == "function" && t.target.classList.contains("apexcharts-legend-marker") && (f(this.ctx, a, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, a, this.w])), n.config.chart.type !== "treemap" && n.config.chart.type !== "heatmap" && !this.isBarsDistributed && n.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(a, o);
      }
    } }]), W;
  }(), Pi = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
      var n = this.w;
      this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = n.globals.minX, this.maxX = n.globals.maxX;
    }
    return F(W, [{ key: "createToolbar", value: function() {
      var t = this, n = this.w, a = function() {
        return document.createElement("div");
      }, o = a();
      if (o.setAttribute("class", "apexcharts-toolbar"), o.style.top = n.config.chart.toolbar.offsetY + "px", o.style.right = 3 - n.config.chart.toolbar.offsetX + "px", n.globals.dom.elWrap.appendChild(o), this.elZoom = a(), this.elZoomIn = a(), this.elZoomOut = a(), this.elPan = a(), this.elSelection = a(), this.elZoomReset = a(), this.elMenuIcon = a(), this.elMenu = a(), this.elCustomIcons = [], this.t = n.config.chart.toolbar.tools, Array.isArray(this.t.customIcons))
        for (var d = 0; d < this.t.customIcons.length; d++)
          this.elCustomIcons.push(a());
      var f = [], p = function(E, L, M) {
        var P = E.toLowerCase();
        t.t[P] && n.config.chart.zoom.enabled && f.push({ el: L, icon: typeof t.t[P] == "string" ? t.t[P] : M, title: t.localeValues[E], class: "apexcharts-".concat(P, "-icon") });
      };
      p("zoomIn", this.elZoomIn, `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
</svg>
`), p("zoomOut", this.elZoomOut, `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
</svg>
`);
      var y = function(E) {
        t.t[E] && n.config.chart[E].enabled && f.push({ el: E === "zoom" ? t.elZoom : t.elSelection, icon: typeof t.t[E] == "string" ? t.t[E] : E === "zoom" ? `<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0V0z" fill="none"/>
    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>
</svg>` : `<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>
</svg>`, title: t.localeValues[E === "zoom" ? "selectionZoom" : "selection"], class: n.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(E, "-icon") });
      };
      y("zoom"), y("selection"), this.t.pan && n.config.chart.zoom.enabled && f.push({ el: this.elPan, icon: typeof this.t.pan == "string" ? this.t.pan : `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">
    <defs>
        <path d="M0 0h24v24H0z" id="a"/>
    </defs>
    <clipPath id="b">
        <use overflow="visible" xlink:href="#a"/>
    </clipPath>
    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>
</svg>`, title: this.localeValues.pan, class: n.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon" }), p("reset", this.elZoomReset, `<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`), this.t.download && f.push({ el: this.elMenuIcon, icon: typeof this.t.download == "string" ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: "apexcharts-menu-icon" });
      for (var S = 0; S < this.elCustomIcons.length; S++)
        f.push({ el: this.elCustomIcons[S], icon: this.t.customIcons[S].icon, title: this.t.customIcons[S].title, index: this.t.customIcons[S].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[S].class });
      f.forEach(function(E, L) {
        E.index && K.moveIndexInArray(f, L, E.index);
      });
      for (var C = 0; C < f.length; C++)
        re.setAttrs(f[C].el, { class: f[C].class, title: f[C].title }), f[C].el.innerHTML = f[C].icon, o.appendChild(f[C].el);
      this._createHamburgerMenu(o), n.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : n.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : n.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
    } }, { key: "_createHamburgerMenu", value: function(t) {
      this.elMenuItems = [], t.appendChild(this.elMenu), re.setAttrs(this.elMenu, { class: "apexcharts-menu" });
      var n = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }, { name: "exportCSV", title: this.localeValues.exportToCSV }];
      this.w.globals.allSeriesHasEqualX || n.splice(2, 1);
      for (var a = 0; a < n.length; a++)
        this.elMenuItems.push(document.createElement("div")), this.elMenuItems[a].innerHTML = n[a].title, re.setAttrs(this.elMenuItems[a], { class: "apexcharts-menu-item ".concat(n[a].name), title: n[a].title }), this.elMenu.appendChild(this.elMenuItems[a]);
    } }, { key: "addToolbarEventListeners", value: function() {
      var t = this;
      this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(a) {
        a.classList.contains("exportSVG") ? a.addEventListener("click", t.handleDownload.bind(t, "svg")) : a.classList.contains("exportPNG") ? a.addEventListener("click", t.handleDownload.bind(t, "png")) : a.classList.contains("exportCSV") && a.addEventListener("click", t.handleDownload.bind(t, "csv"));
      });
      for (var n = 0; n < this.t.customIcons.length; n++)
        this.elCustomIcons[n].addEventListener("click", this.t.customIcons[n].click.bind(this, this.ctx, this.ctx.w));
    } }, { key: "toggleZoomSelection", value: function(t) {
      this.ctx.getSyncedCharts().forEach(function(n) {
        n.ctx.toolbar.toggleOtherControls();
        var a = t === "selection" ? n.ctx.toolbar.elSelection : n.ctx.toolbar.elZoom, o = t === "selection" ? "selectionEnabled" : "zoomEnabled";
        n.w.globals[o] = !n.w.globals[o], a.classList.contains(n.ctx.toolbar.selectedClass) ? a.classList.remove(n.ctx.toolbar.selectedClass) : a.classList.add(n.ctx.toolbar.selectedClass);
      });
    } }, { key: "getToolbarIconsReference", value: function() {
      var t = this.w;
      this.elZoom || (this.elZoom = t.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
    } }, { key: "enableZoomPanFromToolbar", value: function(t) {
      this.toggleOtherControls(), t === "pan" ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
      var n = t === "pan" ? this.elPan : this.elZoom, a = t === "pan" ? this.elZoom : this.elPan;
      n && n.classList.add(this.selectedClass), a && a.classList.remove(this.selectedClass);
    } }, { key: "togglePanning", value: function() {
      this.ctx.getSyncedCharts().forEach(function(t) {
        t.ctx.toolbar.toggleOtherControls(), t.w.globals.panEnabled = !t.w.globals.panEnabled, t.ctx.toolbar.elPan.classList.contains(t.ctx.toolbar.selectedClass) ? t.ctx.toolbar.elPan.classList.remove(t.ctx.toolbar.selectedClass) : t.ctx.toolbar.elPan.classList.add(t.ctx.toolbar.selectedClass);
      });
    } }, { key: "toggleOtherControls", value: function() {
      var t = this, n = this.w;
      n.globals.panEnabled = !1, n.globals.zoomEnabled = !1, n.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(a) {
        a && a.classList.remove(t.selectedClass);
      });
    } }, { key: "handleZoomIn", value: function() {
      var t = this.w;
      t.globals.isRangeBar && (this.minX = t.globals.minY, this.maxX = t.globals.maxY);
      var n = (this.minX + this.maxX) / 2, a = (this.minX + n) / 2, o = (this.maxX + n) / 2, d = this._getNewMinXMaxX(a, o);
      t.globals.disableZoomIn || this.zoomUpdateOptions(d.minX, d.maxX);
    } }, { key: "handleZoomOut", value: function() {
      var t = this.w;
      if (t.globals.isRangeBar && (this.minX = t.globals.minY, this.maxX = t.globals.maxY), !(t.config.xaxis.type === "datetime" && new Date(this.minX).getUTCFullYear() < 1e3)) {
        var n = (this.minX + this.maxX) / 2, a = this.minX - (n - this.minX), o = this.maxX - (n - this.maxX), d = this._getNewMinXMaxX(a, o);
        t.globals.disableZoomOut || this.zoomUpdateOptions(d.minX, d.maxX);
      }
    } }, { key: "_getNewMinXMaxX", value: function(t, n) {
      var a = this.w.config.xaxis.convertedCatToNumeric;
      return { minX: a ? Math.floor(t) : t, maxX: a ? Math.floor(n) : n };
    } }, { key: "zoomUpdateOptions", value: function(t, n) {
      var a = this.w;
      if (t !== void 0 || n !== void 0) {
        if (!(a.config.xaxis.convertedCatToNumeric && (t < 1 && (t = 1, n = a.globals.dataPoints), n - t < 2))) {
          var o = { min: t, max: n }, d = this.getBeforeZoomRange(o);
          d && (o = d.xaxis);
          var f = { xaxis: o }, p = K.clone(a.globals.initialConfig.yaxis);
          a.config.chart.zoom.autoScaleYaxis && (p = new qe(this.ctx).autoScaleY(this.ctx, p, { xaxis: o })), a.config.chart.group || (f.yaxis = p), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(f, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(o, p);
        }
      } else
        this.handleZoomReset();
    } }, { key: "zoomCallback", value: function(t, n) {
      typeof this.ev.zoomed == "function" && this.ev.zoomed(this.ctx, { xaxis: t, yaxis: n });
    } }, { key: "getBeforeZoomRange", value: function(t, n) {
      var a = null;
      return typeof this.ev.beforeZoom == "function" && (a = this.ev.beforeZoom(this, { xaxis: t, yaxis: n })), a;
    } }, { key: "toggleMenu", value: function() {
      var t = this;
      window.setTimeout(function() {
        t.elMenu.classList.contains("apexcharts-menu-open") ? t.elMenu.classList.remove("apexcharts-menu-open") : t.elMenu.classList.add("apexcharts-menu-open");
      }, 0);
    } }, { key: "handleDownload", value: function(t) {
      var n = this.w, a = new Ht(this.ctx);
      switch (t) {
        case "svg":
          a.exportToSVG(this.ctx);
          break;
        case "png":
          a.exportToPng(this.ctx);
          break;
        case "csv":
          a.exportToCSV({ series: n.config.series, columnDelimiter: n.config.chart.toolbar.export.csv.columnDelimiter });
      }
    } }, { key: "handleZoomReset", value: function(t) {
      this.ctx.getSyncedCharts().forEach(function(n) {
        var a = n.w;
        if (a.globals.lastXAxis.min = void 0, a.globals.lastXAxis.max = void 0, n.updateHelpers.revertDefaultAxisMinMax(), typeof a.config.chart.events.beforeResetZoom == "function") {
          var o = a.config.chart.events.beforeResetZoom(n, a);
          o && n.updateHelpers.revertDefaultAxisMinMax(o);
        }
        typeof a.config.chart.events.zoomed == "function" && n.ctx.toolbar.zoomCallback({ min: a.config.xaxis.min, max: a.config.xaxis.max }), a.globals.zoomed = !1;
        var d = n.ctx.series.emptyCollapsedSeries(K.clone(a.globals.initialSeries));
        n.updateHelpers._updateSeries(d, a.config.chart.animations.dynamicAnimation.enabled);
      });
    } }, { key: "destroy", value: function() {
      this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
    } }]), W;
  }(), Ka = function(W) {
    j(n, Pi);
    var t = ae(n);
    function n(a) {
      var o;
      return T(this, n), (o = t.call(this, a)).ctx = a, o.w = a.w, o.dragged = !1, o.graphics = new re(o.ctx), o.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], o.clientX = 0, o.clientY = 0, o.startX = 0, o.endX = 0, o.dragX = 0, o.startY = 0, o.endY = 0, o.dragY = 0, o.moveDirection = "none", o;
    }
    return F(n, [{ key: "init", value: function(a) {
      var o = this, d = a.xyRatios, f = this.w, p = this;
      this.xyRatios = d, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = f.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), f.globals.dom.elGraphical.add(this.zoomRect), f.globals.dom.elGraphical.add(this.selectionRect), f.config.chart.selection.type === "x" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: f.globals.gridWidth, maxY: f.globals.gridHeight }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : f.config.chart.selection.type === "y" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: f.globals.gridWidth }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = f.globals.dom.baseEl.querySelector("".concat(f.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(y) {
        o.hoverArea.addEventListener(y, p.svgMouseEvents.bind(p, d), { capture: !1, passive: !0 });
      });
    } }, { key: "destroy", value: function() {
      this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
    } }, { key: "svgMouseEvents", value: function(a, o) {
      var d = this.w, f = this, p = this.ctx.toolbar, y = d.globals.zoomEnabled ? d.config.chart.zoom.type : d.config.chart.selection.type, S = d.config.chart.toolbar.autoSelected;
      if (o.shiftKey ? (this.shiftWasPressed = !0, p.enableZoomPanFromToolbar(S === "pan" ? "zoom" : "pan")) : this.shiftWasPressed && (p.enableZoomPanFromToolbar(S), this.shiftWasPressed = !1), o.target) {
        var C, E = o.target.classList;
        if (o.target.parentNode && o.target.parentNode !== null && (C = o.target.parentNode.classList), !(E.contains("apexcharts-selection-rect") || E.contains("apexcharts-legend-marker") || E.contains("apexcharts-legend-text") || C && C.contains("apexcharts-toolbar"))) {
          if (f.clientX = o.type === "touchmove" || o.type === "touchstart" ? o.touches[0].clientX : o.type === "touchend" ? o.changedTouches[0].clientX : o.clientX, f.clientY = o.type === "touchmove" || o.type === "touchstart" ? o.touches[0].clientY : o.type === "touchend" ? o.changedTouches[0].clientY : o.clientY, o.type === "mousedown" && o.which === 1) {
            var L = f.gridRect.getBoundingClientRect();
            f.startX = f.clientX - L.left, f.startY = f.clientY - L.top, f.dragged = !1, f.w.globals.mousedown = !0;
          }
          if ((o.type === "mousemove" && o.which === 1 || o.type === "touchmove") && (f.dragged = !0, d.globals.panEnabled ? (d.globals.selection = null, f.w.globals.mousedown && f.panDragging({ context: f, zoomtype: y, xyRatios: a })) : (f.w.globals.mousedown && d.globals.zoomEnabled || f.w.globals.mousedown && d.globals.selectionEnabled) && (f.selection = f.selectionDrawing({ context: f, zoomtype: y }))), o.type === "mouseup" || o.type === "touchend" || o.type === "mouseleave") {
            var M = f.gridRect.getBoundingClientRect();
            f.w.globals.mousedown && (f.endX = f.clientX - M.left, f.endY = f.clientY - M.top, f.dragX = Math.abs(f.endX - f.startX), f.dragY = Math.abs(f.endY - f.startY), (d.globals.zoomEnabled || d.globals.selectionEnabled) && f.selectionDrawn({ context: f, zoomtype: y }), d.globals.panEnabled && d.config.xaxis.convertedCatToNumeric && f.delayedPanScrolled()), d.globals.zoomEnabled && f.hideSelectionRect(this.selectionRect), f.dragged = !1, f.w.globals.mousedown = !1;
          }
          this.makeSelectionRectDraggable();
        }
      }
    } }, { key: "makeSelectionRectDraggable", value: function() {
      var a = this.w;
      if (this.selectionRect) {
        var o = this.selectionRect.node.getBoundingClientRect();
        o.width > 0 && o.height > 0 && this.slDraggableRect.selectize({ points: "l, r", pointSize: 8, pointType: "rect" }).resize({ constraint: { minX: 0, minY: 0, maxX: a.globals.gridWidth, maxY: a.globals.gridHeight } }).on("resizing", this.selectionDragging.bind(this, "resizing"));
      }
    } }, { key: "preselectedSelection", value: function() {
      var a = this.w, o = this.xyRatios;
      if (!a.globals.zoomEnabled) {
        if (a.globals.selection !== void 0 && a.globals.selection !== null)
          this.drawSelectionRect(a.globals.selection);
        else if (a.config.chart.selection.xaxis.min !== void 0 && a.config.chart.selection.xaxis.max !== void 0) {
          var d = (a.config.chart.selection.xaxis.min - a.globals.minX) / o.xRatio, f = { x: d, y: 0, width: a.globals.gridWidth - (a.globals.maxX - a.config.chart.selection.xaxis.max) / o.xRatio - d, height: a.globals.gridHeight, translateX: 0, translateY: 0, selectionEnabled: !0 };
          this.drawSelectionRect(f), this.makeSelectionRectDraggable(), typeof a.config.chart.events.selection == "function" && a.config.chart.events.selection(this.ctx, { xaxis: { min: a.config.chart.selection.xaxis.min, max: a.config.chart.selection.xaxis.max }, yaxis: {} });
        }
      }
    } }, { key: "drawSelectionRect", value: function(a) {
      var o = a.x, d = a.y, f = a.width, p = a.height, y = a.translateX, S = y === void 0 ? 0 : y, C = a.translateY, E = C === void 0 ? 0 : C, L = this.w, M = this.zoomRect, P = this.selectionRect;
      if (this.dragged || L.globals.selection !== null) {
        var I = { transform: "translate(" + S + ", " + E + ")" };
        L.globals.zoomEnabled && this.dragged && (f < 0 && (f = 1), M.attr({ x: o, y: d, width: f, height: p, fill: L.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": L.config.chart.zoom.zoomedArea.fill.opacity, stroke: L.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": L.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": L.config.chart.zoom.zoomedArea.stroke.opacity }), re.setAttrs(M.node, I)), L.globals.selectionEnabled && (P.attr({ x: o, y: d, width: f > 0 ? f : 0, height: p > 0 ? p : 0, fill: L.config.chart.selection.fill.color, "fill-opacity": L.config.chart.selection.fill.opacity, stroke: L.config.chart.selection.stroke.color, "stroke-width": L.config.chart.selection.stroke.width, "stroke-dasharray": L.config.chart.selection.stroke.dashArray, "stroke-opacity": L.config.chart.selection.stroke.opacity }), re.setAttrs(P.node, I));
      }
    } }, { key: "hideSelectionRect", value: function(a) {
      a && a.attr({ x: 0, y: 0, width: 0, height: 0 });
    } }, { key: "selectionDrawing", value: function(a) {
      var o = a.context, d = a.zoomtype, f = this.w, p = o, y = this.gridRect.getBoundingClientRect(), S = p.startX - 1, C = p.startY, E = !1, L = !1, M = p.clientX - y.left - S, P = p.clientY - y.top - C, I = {};
      return Math.abs(M + S) > f.globals.gridWidth ? M = f.globals.gridWidth - S : p.clientX - y.left < 0 && (M = S), S > p.clientX - y.left && (E = !0, M = Math.abs(M)), C > p.clientY - y.top && (L = !0, P = Math.abs(P)), I = d === "x" ? { x: E ? S - M : S, y: 0, width: M, height: f.globals.gridHeight } : d === "y" ? { x: 0, y: L ? C - P : C, width: f.globals.gridWidth, height: P } : { x: E ? S - M : S, y: L ? C - P : C, width: M, height: P }, p.drawSelectionRect(I), p.selectionDragging("resizing"), I;
    } }, { key: "selectionDragging", value: function(a, o) {
      var d = this, f = this.w, p = this.xyRatios, y = this.selectionRect, S = 0;
      a === "resizing" && (S = 30);
      var C = function(L) {
        return parseFloat(y.node.getAttribute(L));
      }, E = { x: C("x"), y: C("y"), width: C("width"), height: C("height") };
      f.globals.selection = E, typeof f.config.chart.events.selection == "function" && f.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
        var L = d.gridRect.getBoundingClientRect(), M = y.node.getBoundingClientRect(), P = { xaxis: { min: f.globals.xAxisScale.niceMin + (M.left - L.left) * p.xRatio, max: f.globals.xAxisScale.niceMin + (M.right - L.left) * p.xRatio }, yaxis: { min: f.globals.yAxisScale[0].niceMin + (L.bottom - M.bottom) * p.yRatio[0], max: f.globals.yAxisScale[0].niceMax - (M.top - L.top) * p.yRatio[0] } };
        f.config.chart.events.selection(d.ctx, P), f.config.chart.brush.enabled && f.config.chart.events.brushScrolled !== void 0 && f.config.chart.events.brushScrolled(d.ctx, P);
      }, S));
    } }, { key: "selectionDrawn", value: function(a) {
      var o = a.context, d = a.zoomtype, f = this.w, p = o, y = this.xyRatios, S = this.ctx.toolbar;
      if (p.startX > p.endX) {
        var C = p.startX;
        p.startX = p.endX, p.endX = C;
      }
      if (p.startY > p.endY) {
        var E = p.startY;
        p.startY = p.endY, p.endY = E;
      }
      var L = void 0, M = void 0;
      f.globals.isRangeBar ? (L = f.globals.yAxisScale[0].niceMin + p.startX * y.invertedYRatio, M = f.globals.yAxisScale[0].niceMin + p.endX * y.invertedYRatio) : (L = f.globals.xAxisScale.niceMin + p.startX * y.xRatio, M = f.globals.xAxisScale.niceMin + p.endX * y.xRatio);
      var P = [], I = [];
      if (f.config.yaxis.forEach(function(Q, ee) {
        P.push(f.globals.yAxisScale[ee].niceMax - y.yRatio[ee] * p.startY), I.push(f.globals.yAxisScale[ee].niceMax - y.yRatio[ee] * p.endY);
      }), p.dragged && (p.dragX > 10 || p.dragY > 10) && L !== M) {
        if (f.globals.zoomEnabled) {
          var B = K.clone(f.globals.initialConfig.yaxis), G = K.clone(f.globals.initialConfig.xaxis);
          if (f.globals.zoomed = !0, f.config.xaxis.convertedCatToNumeric && (L = Math.floor(L), M = Math.floor(M), L < 1 && (L = 1, M = f.globals.dataPoints), M - L < 2 && (M = L + 1)), d !== "xy" && d !== "x" || (G = { min: L, max: M }), d !== "xy" && d !== "y" || B.forEach(function(Q, ee) {
            B[ee].min = I[ee], B[ee].max = P[ee];
          }), f.config.chart.zoom.autoScaleYaxis) {
            var Z = new qe(p.ctx);
            B = Z.autoScaleY(p.ctx, B, { xaxis: G });
          }
          if (S) {
            var b = S.getBeforeZoomRange(G, B);
            b && (G = b.xaxis ? b.xaxis : G, B = b.yaxis ? b.yaxis : B);
          }
          var O = { xaxis: G };
          f.config.chart.group || (O.yaxis = B), p.ctx.updateHelpers._updateOptions(O, !1, p.w.config.chart.animations.dynamicAnimation.enabled), typeof f.config.chart.events.zoomed == "function" && S.zoomCallback(G, B);
        } else if (f.globals.selectionEnabled) {
          var N, X = null;
          N = { min: L, max: M }, d !== "xy" && d !== "y" || (X = K.clone(f.config.yaxis)).forEach(function(Q, ee) {
            X[ee].min = I[ee], X[ee].max = P[ee];
          }), f.globals.selection = p.selection, typeof f.config.chart.events.selection == "function" && f.config.chart.events.selection(p.ctx, { xaxis: N, yaxis: X });
        }
      }
    } }, { key: "panDragging", value: function(a) {
      var o = a.context, d = this.w, f = o;
      if (d.globals.lastClientPosition.x !== void 0) {
        var p = d.globals.lastClientPosition.x - f.clientX, y = d.globals.lastClientPosition.y - f.clientY;
        Math.abs(p) > Math.abs(y) && p > 0 ? this.moveDirection = "left" : Math.abs(p) > Math.abs(y) && p < 0 ? this.moveDirection = "right" : Math.abs(y) > Math.abs(p) && y > 0 ? this.moveDirection = "up" : Math.abs(y) > Math.abs(p) && y < 0 && (this.moveDirection = "down");
      }
      d.globals.lastClientPosition = { x: f.clientX, y: f.clientY };
      var S = d.globals.isRangeBar ? d.globals.minY : d.globals.minX, C = d.globals.isRangeBar ? d.globals.maxY : d.globals.maxX;
      d.config.xaxis.convertedCatToNumeric || f.panScrolled(S, C);
    } }, { key: "delayedPanScrolled", value: function() {
      var a = this.w, o = a.globals.minX, d = a.globals.maxX, f = (a.globals.maxX - a.globals.minX) / 2;
      this.moveDirection === "left" ? (o = a.globals.minX + f, d = a.globals.maxX + f) : this.moveDirection === "right" && (o = a.globals.minX - f, d = a.globals.maxX - f), o = Math.floor(o), d = Math.floor(d), this.updateScrolledChart({ xaxis: { min: o, max: d } }, o, d);
    } }, { key: "panScrolled", value: function(a, o) {
      var d = this.w, f = this.xyRatios, p = K.clone(d.globals.initialConfig.yaxis), y = f.xRatio, S = d.globals.minX, C = d.globals.maxX;
      d.globals.isRangeBar && (y = f.invertedYRatio, S = d.globals.minY, C = d.globals.maxY), this.moveDirection === "left" ? (a = S + d.globals.gridWidth / 15 * y, o = C + d.globals.gridWidth / 15 * y) : this.moveDirection === "right" && (a = S - d.globals.gridWidth / 15 * y, o = C - d.globals.gridWidth / 15 * y), d.globals.isRangeBar || (a < d.globals.initialMinX || o > d.globals.initialMaxX) && (a = S, o = C);
      var E = { min: a, max: o };
      d.config.chart.zoom.autoScaleYaxis && (p = new qe(this.ctx).autoScaleY(this.ctx, p, { xaxis: E }));
      var L = { xaxis: { min: a, max: o } };
      d.config.chart.group || (L.yaxis = p), this.updateScrolledChart(L, a, o);
    } }, { key: "updateScrolledChart", value: function(a, o, d) {
      var f = this.w;
      this.ctx.updateHelpers._updateOptions(a, !1, !1), typeof f.config.chart.events.scrolled == "function" && f.config.chart.events.scrolled(this.ctx, { xaxis: { min: o, max: d } });
    } }]), n;
  }(), et = function() {
    function W(t) {
      T(this, W), this.w = t.w, this.ttCtx = t, this.ctx = t.ctx;
    }
    return F(W, [{ key: "getNearestValues", value: function(t) {
      var n = t.hoverArea, a = t.elGrid, o = t.clientX, d = t.clientY, f = this.w, p = a.getBoundingClientRect(), y = p.width, S = p.height, C = y / (f.globals.dataPoints - 1), E = S / f.globals.dataPoints, L = this.hasBars();
      !f.globals.comboCharts && !L || f.config.xaxis.convertedCatToNumeric || (C = y / f.globals.dataPoints);
      var M = o - p.left - f.globals.barPadForNumericAxis, P = d - p.top;
      M < 0 || P < 0 || M > y || P > S ? (n.classList.remove("hovering-zoom"), n.classList.remove("hovering-pan")) : f.globals.zoomEnabled ? (n.classList.remove("hovering-pan"), n.classList.add("hovering-zoom")) : f.globals.panEnabled && (n.classList.remove("hovering-zoom"), n.classList.add("hovering-pan"));
      var I = Math.round(M / C), B = Math.floor(P / E);
      L && !f.config.xaxis.convertedCatToNumeric && (I = Math.ceil(M / C), I -= 1);
      var G = null, Z = null, b = [], O = [];
      if (f.globals.seriesXvalues.forEach(function(ee) {
        b.push([ee[0] + 1e-6].concat(ee));
      }), f.globals.seriesYvalues.forEach(function(ee) {
        O.push([ee[0] + 1e-6].concat(ee));
      }), b = b.map(function(ee) {
        return ee.filter(function(oe) {
          return K.isNumber(oe);
        });
      }), O = O.map(function(ee) {
        return ee.filter(function(oe) {
          return K.isNumber(oe);
        });
      }), f.globals.isXNumeric) {
        var N = this.ttCtx.getElGrid().getBoundingClientRect(), X = M * (N.width / y), Q = P * (N.height / S);
        G = (Z = this.closestInMultiArray(X, Q, b, O)).index, I = Z.j, G !== null && (b = f.globals.seriesXvalues[G], I = (Z = this.closestInArray(X, b)).index);
      }
      return f.globals.capturedSeriesIndex = G === null ? -1 : G, (!I || I < 1) && (I = 0), f.globals.isBarHorizontal ? f.globals.capturedDataPointIndex = B : f.globals.capturedDataPointIndex = I, { capturedSeries: G, j: f.globals.isBarHorizontal ? B : I, hoverX: M, hoverY: P };
    } }, { key: "closestInMultiArray", value: function(t, n, a, o) {
      var d = this.w, f = 0, p = null, y = -1;
      d.globals.series.length > 1 ? f = this.getFirstActiveXArray(a) : p = 0;
      var S = a[f][0], C = Math.abs(t - S);
      if (a.forEach(function(M) {
        M.forEach(function(P, I) {
          var B = Math.abs(t - P);
          B < C && (C = B, y = I);
        });
      }), y !== -1) {
        var E = o[f][y], L = Math.abs(n - E);
        p = f, o.forEach(function(M, P) {
          var I = Math.abs(n - M[y]);
          I < L && (L = I, p = P);
        });
      }
      return { index: p, j: y };
    } }, { key: "getFirstActiveXArray", value: function(t) {
      for (var n = this.w, a = 0, o = t.map(function(f, p) {
        return f.length > 0 ? p : -1;
      }), d = 0; d < o.length; d++)
        if (o[d] !== -1 && n.globals.collapsedSeriesIndices.indexOf(d) === -1 && n.globals.ancillaryCollapsedSeriesIndices.indexOf(d) === -1) {
          a = o[d];
          break;
        }
      return a;
    } }, { key: "closestInArray", value: function(t, n) {
      for (var a = n[0], o = null, d = Math.abs(t - a), f = 0; f < n.length; f++) {
        var p = Math.abs(t - n[f]);
        p < d && (d = p, o = f);
      }
      return { index: o };
    } }, { key: "isXoverlap", value: function(t) {
      var n = [], a = this.w.globals.seriesX.filter(function(d) {
        return d[0] !== void 0;
      });
      if (a.length > 0)
        for (var o = 0; o < a.length - 1; o++)
          a[o][t] !== void 0 && a[o + 1][t] !== void 0 && a[o][t] !== a[o + 1][t] && n.push("unEqual");
      return n.length === 0;
    } }, { key: "isInitialSeriesSameLen", value: function() {
      for (var t = !0, n = this.w.globals.initialSeries, a = 0; a < n.length - 1; a++)
        if (n[a].data.length !== n[a + 1].data.length) {
          t = !1;
          break;
        }
      return t;
    } }, { key: "getBarsHeight", value: function(t) {
      return ue(t).reduce(function(n, a) {
        return n + a.getBBox().height;
      }, 0);
    } }, { key: "getElMarkers", value: function(t) {
      return typeof t == "number" ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *");
    } }, { key: "getAllMarkers", value: function() {
      var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
      (t = ue(t)).sort(function(a, o) {
        var d = Number(a.getAttribute("data:realIndex")), f = Number(o.getAttribute("data:realIndex"));
        return f < d ? 1 : f > d ? -1 : 0;
      });
      var n = [];
      return t.forEach(function(a) {
        n.push(a.querySelector(".apexcharts-marker"));
      }), n;
    } }, { key: "hasMarkers", value: function(t) {
      return this.getElMarkers(t).length > 0;
    } }, { key: "getElBars", value: function() {
      return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
    } }, { key: "hasBars", value: function() {
      return this.getElBars().length > 0;
    } }, { key: "getHoverMarkerSize", value: function(t) {
      var n = this.w, a = n.config.markers.hover.size;
      return a === void 0 && (a = n.globals.markers.size[t] + n.config.markers.hover.sizeOffset), a;
    } }, { key: "toggleAllTooltipSeriesGroups", value: function(t) {
      var n = this.w, a = this.ttCtx;
      a.allTooltipSeriesGroups.length === 0 && (a.allTooltipSeriesGroups = n.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
      for (var o = a.allTooltipSeriesGroups, d = 0; d < o.length; d++)
        t === "enable" ? (o[d].classList.add("apexcharts-active"), o[d].style.display = n.config.tooltip.items.display) : (o[d].classList.remove("apexcharts-active"), o[d].style.display = "none");
    } }]), W;
  }(), Lt = function() {
    function W(t) {
      T(this, W), this.w = t.w, this.ctx = t.ctx, this.ttCtx = t, this.tooltipUtil = new et(t);
    }
    return F(W, [{ key: "drawSeriesTexts", value: function(t) {
      var n = t.shared, a = n === void 0 || n, o = t.ttItems, d = t.i, f = d === void 0 ? 0 : d, p = t.j, y = p === void 0 ? null : p, S = t.y1, C = t.y2, E = t.e, L = this.w;
      L.config.tooltip.custom !== void 0 ? this.handleCustomTooltip({ i: f, j: y, y1: S, y2: C, w: L }) : this.toggleActiveInactiveSeries(a);
      var M = this.getValuesToPrint({ i: f, j: y });
      this.printLabels({ i: f, j: y, values: M, ttItems: o, shared: a, e: E });
      var P = this.ttCtx.getElTooltip();
      this.ttCtx.tooltipRect.ttWidth = P.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = P.getBoundingClientRect().height;
    } }, { key: "printLabels", value: function(t) {
      var n, a = this, o = t.i, d = t.j, f = t.values, p = t.ttItems, y = t.shared, S = t.e, C = this.w, E = [], L = function(N) {
        return C.globals.seriesGoals[N] && C.globals.seriesGoals[N][d] && Array.isArray(C.globals.seriesGoals[N][d]);
      }, M = f.xVal, P = f.zVal, I = f.xAxisTTVal, B = "", G = C.globals.colors[o];
      d !== null && C.config.plotOptions.bar.distributed && (G = C.globals.colors[d]);
      for (var Z = function(N, X) {
        var Q = a.getFormatters(o);
        B = a.getSeriesName({ fn: Q.yLbTitleFormatter, index: o, seriesIndex: o, j: d }), C.config.chart.type === "treemap" && (B = Q.yLbTitleFormatter(String(C.config.series[o].data[d].x), { series: C.globals.series, seriesIndex: o, dataPointIndex: d, w: C }));
        var ee = C.config.tooltip.inverseOrder ? X : N;
        if (C.globals.axisCharts) {
          var oe = function(_e) {
            var Le, Ie, at, Qt;
            return C.globals.isRangeData ? Q.yLbFormatter((Le = C.globals.seriesRangeStart) === null || Le === void 0 || (Ie = Le[_e]) === null || Ie === void 0 ? void 0 : Ie[d], { series: C.globals.seriesRangeStart, seriesIndex: _e, dataPointIndex: d, w: C }) + " - " + Q.yLbFormatter((at = C.globals.seriesRangeEnd) === null || at === void 0 || (Qt = at[_e]) === null || Qt === void 0 ? void 0 : Qt[d], { series: C.globals.seriesRangeEnd, seriesIndex: _e, dataPointIndex: d, w: C }) : Q.yLbFormatter(C.globals.series[_e][d], { series: C.globals.series, seriesIndex: _e, dataPointIndex: d, w: C });
          };
          if (y)
            Q = a.getFormatters(ee), B = a.getSeriesName({ fn: Q.yLbTitleFormatter, index: ee, seriesIndex: o, j: d }), G = C.globals.colors[ee], n = oe(ee), L(ee) && (E = C.globals.seriesGoals[ee][d].map(function(_e) {
              return { attrs: _e, val: Q.yLbFormatter(_e.value, { seriesIndex: ee, dataPointIndex: d, w: C }) };
            }));
          else {
            var fe, ke = S == null || (fe = S.target) === null || fe === void 0 ? void 0 : fe.getAttribute("fill");
            ke && (G = ke.indexOf("url") !== -1 ? document.querySelector(ke.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : ke), n = oe(o), L(o) && Array.isArray(C.globals.seriesGoals[o][d]) && (E = C.globals.seriesGoals[o][d].map(function(_e) {
              return { attrs: _e, val: Q.yLbFormatter(_e.value, { seriesIndex: o, dataPointIndex: d, w: C }) };
            }));
          }
        }
        d === null && (n = Q.yLbFormatter(C.globals.series[o], m(m({}, C), {}, { seriesIndex: o, dataPointIndex: o }))), a.DOMHandling({ i: o, t: ee, j: d, ttItems: p, values: { val: n, goalVals: E, xVal: M, xAxisTTVal: I, zVal: P }, seriesName: B, shared: y, pColor: G });
      }, b = 0, O = C.globals.series.length - 1; b < C.globals.series.length; b++, O--)
        Z(b, O);
    } }, { key: "getFormatters", value: function(t) {
      var n, a = this.w, o = a.globals.yLabelFormatters[t];
      return a.globals.ttVal !== void 0 ? Array.isArray(a.globals.ttVal) ? (o = a.globals.ttVal[t] && a.globals.ttVal[t].formatter, n = a.globals.ttVal[t] && a.globals.ttVal[t].title && a.globals.ttVal[t].title.formatter) : (o = a.globals.ttVal.formatter, typeof a.globals.ttVal.title.formatter == "function" && (n = a.globals.ttVal.title.formatter)) : n = a.config.tooltip.y.title.formatter, typeof o != "function" && (o = a.globals.yLabelFormatters[0] ? a.globals.yLabelFormatters[0] : function(d) {
        return d;
      }), typeof n != "function" && (n = function(d) {
        return d;
      }), { yLbFormatter: o, yLbTitleFormatter: n };
    } }, { key: "getSeriesName", value: function(t) {
      var n = t.fn, a = t.index, o = t.seriesIndex, d = t.j, f = this.w;
      return n(String(f.globals.seriesNames[a]), { series: f.globals.series, seriesIndex: o, dataPointIndex: d, w: f });
    } }, { key: "DOMHandling", value: function(t) {
      t.i;
      var n = t.t, a = t.j, o = t.ttItems, d = t.values, f = t.seriesName, p = t.shared, y = t.pColor, S = this.w, C = this.ttCtx, E = d.val, L = d.goalVals, M = d.xVal, P = d.xAxisTTVal, I = d.zVal, B = null;
      B = o[n].children, S.config.tooltip.fillSeriesColor && (o[n].style.backgroundColor = y, B[0].style.display = "none"), C.showTooltipTitle && (C.tooltipTitle === null && (C.tooltipTitle = S.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), C.tooltipTitle.innerHTML = M), C.isXAxisTooltipEnabled && (C.xaxisTooltipText.innerHTML = P !== "" ? P : M);
      var G = o[n].querySelector(".apexcharts-tooltip-text-y-label");
      G && (G.innerHTML = f || "");
      var Z = o[n].querySelector(".apexcharts-tooltip-text-y-value");
      Z && (Z.innerHTML = E !== void 0 ? E : ""), B[0] && B[0].classList.contains("apexcharts-tooltip-marker") && (S.config.tooltip.marker.fillColors && Array.isArray(S.config.tooltip.marker.fillColors) && (y = S.config.tooltip.marker.fillColors[n]), B[0].style.backgroundColor = y), S.config.tooltip.marker.show || (B[0].style.display = "none");
      var b = o[n].querySelector(".apexcharts-tooltip-text-goals-label"), O = o[n].querySelector(".apexcharts-tooltip-text-goals-value");
      if (L.length && S.globals.seriesGoals[n]) {
        var N = function() {
          var X = "<div >", Q = "<div>";
          L.forEach(function(ee, oe) {
            X += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(ee.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(ee.attrs.name, "</div>"), Q += "<div>".concat(ee.val, "</div>");
          }), b.innerHTML = X + "</div>", O.innerHTML = Q + "</div>";
        };
        p ? S.globals.seriesGoals[n][a] && Array.isArray(S.globals.seriesGoals[n][a]) ? N() : (b.innerHTML = "", O.innerHTML = "") : N();
      } else
        b.innerHTML = "", O.innerHTML = "";
      I !== null && (o[n].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = S.config.tooltip.z.title, o[n].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = I !== void 0 ? I : ""), p && B[0] && (E == null || S.globals.ancillaryCollapsedSeriesIndices.indexOf(n) > -1 || S.globals.collapsedSeriesIndices.indexOf(n) > -1 ? B[0].parentNode.style.display = "none" : B[0].parentNode.style.display = S.config.tooltip.items.display);
    } }, { key: "toggleActiveInactiveSeries", value: function(t) {
      var n = this.w;
      if (t)
        this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
      else {
        this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
        var a = n.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
        a && (a.classList.add("apexcharts-active"), a.style.display = n.config.tooltip.items.display);
      }
    } }, { key: "getValuesToPrint", value: function(t) {
      var n = t.i, a = t.j, o = this.w, d = this.ctx.series.filteredSeriesX(), f = "", p = "", y = null, S = null, C = { series: o.globals.series, seriesIndex: n, dataPointIndex: a, w: o }, E = o.globals.ttZFormatter;
      a === null ? S = o.globals.series[n] : o.globals.isXNumeric && o.config.chart.type !== "treemap" ? (f = d[n][a], d[n].length === 0 && (f = d[this.tooltipUtil.getFirstActiveXArray(d)][a])) : f = o.globals.labels[a] !== void 0 ? o.globals.labels[a] : "";
      var L = f;
      return o.globals.isXNumeric && o.config.xaxis.type === "datetime" ? f = new Tt(this.ctx).xLabelFormat(o.globals.ttKeyFormatter, L, L, { i: void 0, dateFormatter: new Ze(this.ctx).formatDate, w: this.w }) : f = o.globals.isBarHorizontal ? o.globals.yLabelFormatters[0](L, C) : o.globals.xLabelFormatter(L, C), o.config.tooltip.x.formatter !== void 0 && (f = o.globals.ttKeyFormatter(L, C)), o.globals.seriesZ.length > 0 && o.globals.seriesZ[n].length > 0 && (y = E(o.globals.seriesZ[n][a], o)), p = typeof o.config.xaxis.tooltip.formatter == "function" ? o.globals.xaxisTooltipFormatter(L, C) : f, { val: Array.isArray(S) ? S.join(" ") : S, xVal: Array.isArray(f) ? f.join(" ") : f, xAxisTTVal: Array.isArray(p) ? p.join(" ") : p, zVal: y };
    } }, { key: "handleCustomTooltip", value: function(t) {
      var n = t.i, a = t.j, o = t.y1, d = t.y2, f = t.w, p = this.ttCtx.getElTooltip(), y = f.config.tooltip.custom;
      Array.isArray(y) && y[n] && (y = y[n]), p.innerHTML = y({ ctx: this.ctx, series: f.globals.series, seriesIndex: n, dataPointIndex: a, y1: o, y2: d, w: f });
    } }]), W;
  }(), nn = function() {
    function W(t) {
      T(this, W), this.ttCtx = t, this.ctx = t.ctx, this.w = t.w;
    }
    return F(W, [{ key: "moveXCrosshairs", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, a = this.ttCtx, o = this.w, d = a.getElXCrosshairs(), f = t - a.xcrosshairsWidth / 2, p = o.globals.labels.slice().length;
      if (n !== null && (f = o.globals.gridWidth / p * n), d === null || o.globals.isBarHorizontal || (d.setAttribute("x", f), d.setAttribute("x1", f), d.setAttribute("x2", f), d.setAttribute("y2", o.globals.gridHeight), d.classList.add("apexcharts-active")), f < 0 && (f = 0), f > o.globals.gridWidth && (f = o.globals.gridWidth), a.isXAxisTooltipEnabled) {
        var y = f;
        o.config.xaxis.crosshairs.width !== "tickWidth" && o.config.xaxis.crosshairs.width !== "barWidth" || (y = f + a.xcrosshairsWidth / 2), this.moveXAxisTooltip(y);
      }
    } }, { key: "moveYCrosshairs", value: function(t) {
      var n = this.ttCtx;
      n.ycrosshairs !== null && re.setAttrs(n.ycrosshairs, { y1: t, y2: t }), n.ycrosshairsHidden !== null && re.setAttrs(n.ycrosshairsHidden, { y1: t, y2: t });
    } }, { key: "moveXAxisTooltip", value: function(t) {
      var n = this.w, a = this.ttCtx;
      if (a.xaxisTooltip !== null && a.xcrosshairsWidth !== 0) {
        a.xaxisTooltip.classList.add("apexcharts-active");
        var o = a.xaxisOffY + n.config.xaxis.tooltip.offsetY + n.globals.translateY + 1 + n.config.xaxis.offsetY;
        if (t -= a.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t)) {
          t += n.globals.translateX;
          var d;
          d = new re(this.ctx).getTextRects(a.xaxisTooltipText.innerHTML), a.xaxisTooltipText.style.minWidth = d.width + "px", a.xaxisTooltip.style.left = t + "px", a.xaxisTooltip.style.top = o + "px";
        }
      }
    } }, { key: "moveYAxisTooltip", value: function(t) {
      var n = this.w, a = this.ttCtx;
      a.yaxisTTEls === null && (a.yaxisTTEls = n.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
      var o = parseInt(a.ycrosshairsHidden.getAttribute("y1"), 10), d = n.globals.translateY + o, f = a.yaxisTTEls[t].getBoundingClientRect().height, p = n.globals.translateYAxisX[t] - 2;
      n.config.yaxis[t].opposite && (p -= 26), d -= f / 2, n.globals.ignoreYAxisIndexes.indexOf(t) === -1 ? (a.yaxisTTEls[t].classList.add("apexcharts-active"), a.yaxisTTEls[t].style.top = d + "px", a.yaxisTTEls[t].style.left = p + n.config.yaxis[t].tooltip.offsetX + "px") : a.yaxisTTEls[t].classList.remove("apexcharts-active");
    } }, { key: "moveTooltip", value: function(t, n) {
      var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, o = this.w, d = this.ttCtx, f = d.getElTooltip(), p = d.tooltipRect, y = a !== null ? parseFloat(a) : 1, S = parseFloat(t) + y + 5, C = parseFloat(n) + y / 2;
      if (S > o.globals.gridWidth / 2 && (S = S - p.ttWidth - y - 10), S > o.globals.gridWidth - p.ttWidth - 10 && (S = o.globals.gridWidth - p.ttWidth), S < -20 && (S = -20), o.config.tooltip.followCursor) {
        var E = d.getElGrid().getBoundingClientRect();
        (S = d.e.clientX - E.left) > o.globals.gridWidth / 2 && (S -= d.tooltipRect.ttWidth), (C = d.e.clientY + o.globals.translateY - E.top) > o.globals.gridHeight / 2 && (C -= d.tooltipRect.ttHeight);
      } else
        o.globals.isBarHorizontal || p.ttHeight / 2 + C > o.globals.gridHeight && (C = o.globals.gridHeight - p.ttHeight + o.globals.translateY);
      isNaN(S) || (S += o.globals.translateX, f.style.left = S + "px", f.style.top = C + "px");
    } }, { key: "moveMarkers", value: function(t, n) {
      var a = this.w, o = this.ttCtx;
      if (a.globals.markers.size[t] > 0)
        for (var d = a.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-marker")), f = 0; f < d.length; f++)
          parseInt(d[f].getAttribute("rel"), 10) === n && (o.marker.resetPointsSize(), o.marker.enlargeCurrentPoint(n, d[f]));
      else
        o.marker.resetPointsSize(), this.moveDynamicPointOnHover(n, t);
    } }, { key: "moveDynamicPointOnHover", value: function(t, n) {
      var a, o, d = this.w, f = this.ttCtx, p = d.globals.pointsArray, y = f.tooltipUtil.getHoverMarkerSize(n), S = d.config.series[n].type;
      if (!S || S !== "column" && S !== "candlestick" && S !== "boxPlot") {
        a = p[n][t][0], o = p[n][t][1] ? p[n][t][1] : 0;
        var C = d.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(n, "'] .apexcharts-series-markers circle"));
        C && o < d.globals.gridHeight && o > 0 && (C.setAttribute("r", y), C.setAttribute("cx", a), C.setAttribute("cy", o)), this.moveXCrosshairs(a), f.fixedTooltip || this.moveTooltip(a, o, y);
      }
    } }, { key: "moveDynamicPointsOnHover", value: function(t) {
      var n, a = this.ttCtx, o = a.w, d = 0, f = 0, p = o.globals.pointsArray;
      n = new st(this.ctx).getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
      var y = a.tooltipUtil.getHoverMarkerSize(n);
      p[n] && (d = p[n][t][0], f = p[n][t][1]);
      var S = a.tooltipUtil.getAllMarkers();
      if (S !== null)
        for (var C = 0; C < o.globals.series.length; C++) {
          var E = p[C];
          if (o.globals.comboCharts && E === void 0 && S.splice(C, 0, null), E && E.length) {
            var L = p[C][t][1], M = void 0;
            if (S[C].setAttribute("cx", d), o.config.chart.type === "rangeArea" && !o.globals.comboCharts) {
              var P = t + o.globals.series[C].length;
              M = p[C][P][1], L -= Math.abs(L - M) / 2;
            }
            L !== null && !isNaN(L) && L < o.globals.gridHeight + y && L + y > 0 ? (S[C] && S[C].setAttribute("r", y), S[C] && S[C].setAttribute("cy", L)) : S[C] && S[C].setAttribute("r", 0);
          }
        }
      this.moveXCrosshairs(d), a.fixedTooltip || this.moveTooltip(d, f || o.globals.gridHeight, y);
    } }, { key: "moveStickyTooltipOverBars", value: function(t, n) {
      var a = this.w, o = this.ttCtx, d = a.globals.columnSeries ? a.globals.columnSeries.length : a.globals.series.length, f = d >= 2 && d % 2 == 0 ? Math.floor(d / 2) : Math.floor(d / 2) + 1;
      a.globals.isBarHorizontal && (f = new st(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
      var p = a.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(f, "'] path[j='").concat(t, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(f, "'] path[j='").concat(t, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(f, "'] path[j='").concat(t, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(f, "'] path[j='").concat(t, "']"));
      p || typeof n != "number" || (p = a.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(n, "'] path[j='").concat(t, `'],
        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='`).concat(n, "'] path[j='").concat(t, `'],
        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='`).concat(n, "'] path[j='").concat(t, `'],
        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='`).concat(n, "'] path[j='").concat(t, "']")));
      var y = p ? parseFloat(p.getAttribute("cx")) : 0, S = p ? parseFloat(p.getAttribute("cy")) : 0, C = p ? parseFloat(p.getAttribute("barWidth")) : 0, E = o.getElGrid().getBoundingClientRect(), L = p && (p.classList.contains("apexcharts-candlestick-area") || p.classList.contains("apexcharts-boxPlot-area"));
      a.globals.isXNumeric ? (p && !L && (y -= d % 2 != 0 ? C / 2 : 0), p && L && a.globals.comboCharts && (y -= C / 2)) : a.globals.isBarHorizontal || (y = o.xAxisTicksPositions[t - 1] + o.dataPointsDividedWidth / 2, isNaN(y) && (y = o.xAxisTicksPositions[t] - o.dataPointsDividedWidth / 2)), a.globals.isBarHorizontal ? S -= o.tooltipRect.ttHeight : a.config.tooltip.followCursor ? S = o.e.clientY - E.top - o.tooltipRect.ttHeight / 2 : S + o.tooltipRect.ttHeight + 15 > a.globals.gridHeight && (S = a.globals.gridHeight), a.globals.isBarHorizontal || this.moveXCrosshairs(y), o.fixedTooltip || this.moveTooltip(y, S || a.globals.gridHeight);
    } }]), W;
  }(), bn = function() {
    function W(t) {
      T(this, W), this.w = t.w, this.ttCtx = t, this.ctx = t.ctx, this.tooltipPosition = new nn(t);
    }
    return F(W, [{ key: "drawDynamicPoints", value: function() {
      var t = this.w, n = new re(this.ctx), a = new kt(this.ctx), o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
      o = ue(o), t.config.chart.stacked && o.sort(function(E, L) {
        return parseFloat(E.getAttribute("data:realIndex")) - parseFloat(L.getAttribute("data:realIndex"));
      });
      for (var d = 0; d < o.length; d++) {
        var f = o[d].querySelector(".apexcharts-series-markers-wrap");
        if (f !== null) {
          var p = void 0, y = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
          t.config.chart.type !== "line" && t.config.chart.type !== "area" || t.globals.comboCharts || t.config.tooltip.intersect || (y += " no-pointer-events");
          var S = a.getMarkerConfig({ cssClass: y, seriesIndex: Number(f.getAttribute("data:realIndex")) });
          (p = n.drawMarker(0, 0, S)).node.setAttribute("default-marker-size", 0);
          var C = document.createElementNS(t.globals.SVGNS, "g");
          C.classList.add("apexcharts-series-markers"), C.appendChild(p.node), f.appendChild(C);
        }
      }
    } }, { key: "enlargeCurrentPoint", value: function(t, n) {
      var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, d = this.w;
      d.config.chart.type !== "bubble" && this.newPointSize(t, n);
      var f = n.getAttribute("cx"), p = n.getAttribute("cy");
      if (a !== null && o !== null && (f = a, p = o), this.tooltipPosition.moveXCrosshairs(f), !this.fixedTooltip) {
        if (d.config.chart.type === "radar") {
          var y = this.ttCtx.getElGrid().getBoundingClientRect();
          f = this.ttCtx.e.clientX - y.left;
        }
        this.tooltipPosition.moveTooltip(f, p, d.config.markers.hover.size);
      }
    } }, { key: "enlargePoints", value: function(t) {
      for (var n = this.w, a = this, o = this.ttCtx, d = t, f = n.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), p = n.config.markers.hover.size, y = 0; y < f.length; y++) {
        var S = f[y].getAttribute("rel"), C = f[y].getAttribute("index");
        if (p === void 0 && (p = n.globals.markers.size[C] + n.config.markers.hover.sizeOffset), d === parseInt(S, 10)) {
          a.newPointSize(d, f[y]);
          var E = f[y].getAttribute("cx"), L = f[y].getAttribute("cy");
          a.tooltipPosition.moveXCrosshairs(E), o.fixedTooltip || a.tooltipPosition.moveTooltip(E, L, p);
        } else
          a.oldPointSize(f[y]);
      }
    } }, { key: "newPointSize", value: function(t, n) {
      var a = this.w, o = a.config.markers.hover.size, d = t === 0 ? n.parentNode.firstChild : n.parentNode.lastChild;
      if (d.getAttribute("default-marker-size") !== "0") {
        var f = parseInt(d.getAttribute("index"), 10);
        o === void 0 && (o = a.globals.markers.size[f] + a.config.markers.hover.sizeOffset), o < 0 && (o = 0), d.setAttribute("r", o);
      }
    } }, { key: "oldPointSize", value: function(t) {
      var n = parseFloat(t.getAttribute("default-marker-size"));
      t.setAttribute("r", n);
    } }, { key: "resetPointsSize", value: function() {
      for (var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), n = 0; n < t.length; n++) {
        var a = parseFloat(t[n].getAttribute("default-marker-size"));
        K.isNumber(a) && a >= 0 ? t[n].setAttribute("r", a) : t[n].setAttribute("r", 0);
      }
    } }]), W;
  }(), Bn = function() {
    function W(t) {
      T(this, W), this.w = t.w;
      var n = this.w;
      this.ttCtx = t, this.isVerticalGroupedRangeBar = !n.globals.isBarHorizontal && n.config.chart.type === "rangeBar" && n.config.plotOptions.bar.rangeBarGroupRows;
    }
    return F(W, [{ key: "getAttr", value: function(t, n) {
      return parseFloat(t.target.getAttribute(n));
    } }, { key: "handleHeatTreeTooltip", value: function(t) {
      var n = t.e, a = t.opt, o = t.x, d = t.y, f = t.type, p = this.ttCtx, y = this.w;
      if (n.target.classList.contains("apexcharts-".concat(f, "-rect"))) {
        var S = this.getAttr(n, "i"), C = this.getAttr(n, "j"), E = this.getAttr(n, "cx"), L = this.getAttr(n, "cy"), M = this.getAttr(n, "width"), P = this.getAttr(n, "height");
        if (p.tooltipLabels.drawSeriesTexts({ ttItems: a.ttItems, i: S, j: C, shared: !1, e: n }), y.globals.capturedSeriesIndex = S, y.globals.capturedDataPointIndex = C, o = E + p.tooltipRect.ttWidth / 2 + M, d = L + p.tooltipRect.ttHeight / 2 - P / 2, p.tooltipPosition.moveXCrosshairs(E + M / 2), o > y.globals.gridWidth / 2 && (o = E - p.tooltipRect.ttWidth / 2 + M), p.w.config.tooltip.followCursor) {
          var I = y.globals.dom.elWrap.getBoundingClientRect();
          o = y.globals.clientX - I.left - (o > y.globals.gridWidth / 2 ? p.tooltipRect.ttWidth : 0), d = y.globals.clientY - I.top - (d > y.globals.gridHeight / 2 ? p.tooltipRect.ttHeight : 0);
        }
      }
      return { x: o, y: d };
    } }, { key: "handleMarkerTooltip", value: function(t) {
      var n, a, o = t.e, d = t.opt, f = t.x, p = t.y, y = this.w, S = this.ttCtx;
      if (o.target.classList.contains("apexcharts-marker")) {
        var C = parseInt(d.paths.getAttribute("cx"), 10), E = parseInt(d.paths.getAttribute("cy"), 10), L = parseFloat(d.paths.getAttribute("val"));
        if (a = parseInt(d.paths.getAttribute("rel"), 10), n = parseInt(d.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, S.intersect) {
          var M = K.findAncestor(d.paths, "apexcharts-series");
          M && (n = parseInt(M.getAttribute("data:realIndex"), 10));
        }
        if (S.tooltipLabels.drawSeriesTexts({ ttItems: d.ttItems, i: n, j: a, shared: !S.showOnIntersect && y.config.tooltip.shared, e: o }), o.type === "mouseup" && S.markerClick(o, n, a), y.globals.capturedSeriesIndex = n, y.globals.capturedDataPointIndex = a, f = C, p = E + y.globals.translateY - 1.4 * S.tooltipRect.ttHeight, S.w.config.tooltip.followCursor) {
          var P = S.getElGrid().getBoundingClientRect();
          p = S.e.clientY + y.globals.translateY - P.top;
        }
        L < 0 && (p = E), S.marker.enlargeCurrentPoint(a, d.paths, f, p);
      }
      return { x: f, y: p };
    } }, { key: "handleBarTooltip", value: function(t) {
      var n, a, o = t.e, d = t.opt, f = this.w, p = this.ttCtx, y = p.getElTooltip(), S = 0, C = 0, E = 0, L = this.getBarTooltipXY({ e: o, opt: d });
      n = L.i;
      var M = L.barHeight, P = L.j;
      f.globals.capturedSeriesIndex = n, f.globals.capturedDataPointIndex = P, f.globals.isBarHorizontal && p.tooltipUtil.hasBars() || !f.config.tooltip.shared ? (C = L.x, E = L.y, a = Array.isArray(f.config.stroke.width) ? f.config.stroke.width[n] : f.config.stroke.width, S = C) : f.globals.comboCharts || f.config.tooltip.shared || (S /= 2), isNaN(E) && (E = f.globals.svgHeight - p.tooltipRect.ttHeight);
      var I = parseInt(d.paths.parentNode.getAttribute("data:realIndex"), 10), B = f.globals.isMultipleYAxis ? f.config.yaxis[I] && f.config.yaxis[I].reversed : f.config.yaxis[0].reversed;
      if (C + p.tooltipRect.ttWidth > f.globals.gridWidth && !B ? C -= p.tooltipRect.ttWidth : C < 0 && (C = 0), p.w.config.tooltip.followCursor) {
        var G = p.getElGrid().getBoundingClientRect();
        E = p.e.clientY - G.top;
      }
      p.tooltip === null && (p.tooltip = f.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), f.config.tooltip.shared || (f.globals.comboBarCount > 0 ? p.tooltipPosition.moveXCrosshairs(S + a / 2) : p.tooltipPosition.moveXCrosshairs(S)), !p.fixedTooltip && (!f.config.tooltip.shared || f.globals.isBarHorizontal && p.tooltipUtil.hasBars()) && (B && (C -= p.tooltipRect.ttWidth) < 0 && (C = 0), !B || f.globals.isBarHorizontal && p.tooltipUtil.hasBars() || (E = E + M - 2 * (f.globals.series[n][P] < 0 ? M : 0)), E = E + f.globals.translateY - p.tooltipRect.ttHeight / 2, y.style.left = C + f.globals.translateX + "px", y.style.top = E + "px");
    } }, { key: "getBarTooltipXY", value: function(t) {
      var n = this, a = t.e, o = t.opt, d = this.w, f = null, p = this.ttCtx, y = 0, S = 0, C = 0, E = 0, L = 0, M = a.target.classList;
      if (M.contains("apexcharts-bar-area") || M.contains("apexcharts-candlestick-area") || M.contains("apexcharts-boxPlot-area") || M.contains("apexcharts-rangebar-area")) {
        var P = a.target, I = P.getBoundingClientRect(), B = o.elGrid.getBoundingClientRect(), G = I.height;
        L = I.height;
        var Z = I.width, b = parseInt(P.getAttribute("cx"), 10), O = parseInt(P.getAttribute("cy"), 10);
        E = parseFloat(P.getAttribute("barWidth"));
        var N = a.type === "touchmove" ? a.touches[0].clientX : a.clientX;
        f = parseInt(P.getAttribute("j"), 10), y = parseInt(P.parentNode.getAttribute("rel"), 10) - 1;
        var X = P.getAttribute("data-range-y1"), Q = P.getAttribute("data-range-y2");
        d.globals.comboCharts && (y = parseInt(P.parentNode.getAttribute("data:realIndex"), 10));
        var ee = function(fe) {
          return d.globals.isXNumeric ? b - Z / 2 : n.isVerticalGroupedRangeBar ? b + Z / 2 : b - p.dataPointsDividedWidth + Z / 2;
        }, oe = function() {
          return O - p.dataPointsDividedHeight + G / 2 - p.tooltipRect.ttHeight / 2;
        };
        p.tooltipLabels.drawSeriesTexts({ ttItems: o.ttItems, i: y, j: f, y1: X ? parseInt(X, 10) : null, y2: Q ? parseInt(Q, 10) : null, shared: !p.showOnIntersect && d.config.tooltip.shared, e: a }), d.config.tooltip.followCursor ? d.globals.isBarHorizontal ? (S = N - B.left + 15, C = oe()) : (S = ee(), C = a.clientY - B.top - p.tooltipRect.ttHeight / 2 - 15) : d.globals.isBarHorizontal ? ((S = b) < p.xyRatios.baseLineInvertedY && (S = b - p.tooltipRect.ttWidth), C = oe()) : (S = ee(), C = O);
      }
      return { x: S, y: C, barHeight: L, barWidth: E, i: y, j: f };
    } }]), W;
  }(), vr = function() {
    function W(t) {
      T(this, W), this.w = t.w, this.ttCtx = t;
    }
    return F(W, [{ key: "drawXaxisTooltip", value: function() {
      var t = this.w, n = this.ttCtx, a = t.config.xaxis.position === "bottom";
      n.xaxisOffY = a ? t.globals.gridHeight + 1 : -t.globals.xAxisHeight - t.config.xaxis.axisTicks.height + 3;
      var o = a ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", d = t.globals.dom.elWrap;
      n.isXAxisTooltipEnabled && t.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") === null && (n.xaxisTooltip = document.createElement("div"), n.xaxisTooltip.setAttribute("class", o + " apexcharts-theme-" + t.config.tooltip.theme), d.appendChild(n.xaxisTooltip), n.xaxisTooltipText = document.createElement("div"), n.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), n.xaxisTooltipText.style.fontFamily = t.config.xaxis.tooltip.style.fontFamily || t.config.chart.fontFamily, n.xaxisTooltipText.style.fontSize = t.config.xaxis.tooltip.style.fontSize, n.xaxisTooltip.appendChild(n.xaxisTooltipText));
    } }, { key: "drawYaxisTooltip", value: function() {
      for (var t = this.w, n = this.ttCtx, a = function(d) {
        var f = t.config.yaxis[d].opposite || t.config.yaxis[d].crosshairs.opposite;
        n.yaxisOffX = f ? t.globals.gridWidth + 1 : 1;
        var p = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(d, f ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
        t.globals.yAxisSameScaleIndices.map(function(S, C) {
          S.map(function(E, L) {
            L === d && (p += t.config.yaxis[L].show ? " " : " apexcharts-yaxistooltip-hidden");
          });
        });
        var y = t.globals.dom.elWrap;
        t.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(d)) === null && (n.yaxisTooltip = document.createElement("div"), n.yaxisTooltip.setAttribute("class", p + " apexcharts-theme-" + t.config.tooltip.theme), y.appendChild(n.yaxisTooltip), d === 0 && (n.yaxisTooltipText = []), n.yaxisTooltipText[d] = document.createElement("div"), n.yaxisTooltipText[d].classList.add("apexcharts-yaxistooltip-text"), n.yaxisTooltip.appendChild(n.yaxisTooltipText[d]));
      }, o = 0; o < t.config.yaxis.length; o++)
        a(o);
    } }, { key: "setXCrosshairWidth", value: function() {
      var t = this.w, n = this.ttCtx, a = n.getElXCrosshairs();
      if (n.xcrosshairsWidth = parseInt(t.config.xaxis.crosshairs.width, 10), t.globals.comboCharts) {
        var o = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
        if (o !== null && t.config.xaxis.crosshairs.width === "barWidth") {
          var d = parseFloat(o.getAttribute("barWidth"));
          n.xcrosshairsWidth = d;
        } else if (t.config.xaxis.crosshairs.width === "tickWidth") {
          var f = t.globals.labels.length;
          n.xcrosshairsWidth = t.globals.gridWidth / f;
        }
      } else if (t.config.xaxis.crosshairs.width === "tickWidth") {
        var p = t.globals.labels.length;
        n.xcrosshairsWidth = t.globals.gridWidth / p;
      } else if (t.config.xaxis.crosshairs.width === "barWidth") {
        var y = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
        if (y !== null) {
          var S = parseFloat(y.getAttribute("barWidth"));
          n.xcrosshairsWidth = S;
        } else
          n.xcrosshairsWidth = 1;
      }
      t.globals.isBarHorizontal && (n.xcrosshairsWidth = 0), a !== null && n.xcrosshairsWidth > 0 && a.setAttribute("width", n.xcrosshairsWidth);
    } }, { key: "handleYCrosshair", value: function() {
      var t = this.w, n = this.ttCtx;
      n.ycrosshairs = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), n.ycrosshairsHidden = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
    } }, { key: "drawYaxisTooltipText", value: function(t, n, a) {
      var o = this.ttCtx, d = this.w, f = d.globals.yLabelFormatters[t];
      if (o.yaxisTooltips[t]) {
        var p = o.getElGrid().getBoundingClientRect(), y = (n - p.top) * a.yRatio[t], S = d.globals.maxYArr[t] - d.globals.minYArr[t], C = d.globals.minYArr[t] + (S - y);
        o.tooltipPosition.moveYCrosshairs(n - p.top), o.yaxisTooltipText[t].innerHTML = f(C), o.tooltipPosition.moveYAxisTooltip(t);
      }
    } }]), W;
  }(), $n = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
      var n = this.w;
      this.tConfig = n.config.tooltip, this.tooltipUtil = new et(this), this.tooltipLabels = new Lt(this), this.tooltipPosition = new nn(this), this.marker = new bn(this), this.intersect = new Bn(this), this.axesTooltip = new vr(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !n.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
    }
    return F(W, [{ key: "getElTooltip", value: function(t) {
      return t || (t = this), t.w.globals.dom.baseEl ? t.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
    } }, { key: "getElXCrosshairs", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
    } }, { key: "getElGrid", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
    } }, { key: "drawTooltip", value: function(t) {
      var n = this.w;
      this.xyRatios = t, this.isXAxisTooltipEnabled = n.config.xaxis.tooltip.enabled && n.globals.axisCharts, this.yaxisTooltips = n.config.yaxis.map(function(f, p) {
        return !!(f.show && f.tooltip.enabled && n.globals.axisCharts);
      }), this.allTooltipSeriesGroups = [], n.globals.axisCharts || (this.showTooltipTitle = !1);
      var a = document.createElement("div");
      if (a.classList.add("apexcharts-tooltip"), n.config.tooltip.cssClass && a.classList.add(n.config.tooltip.cssClass), a.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), n.globals.dom.elWrap.appendChild(a), n.globals.axisCharts) {
        this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
        var o = new Wt(this.ctx);
        this.xAxisTicksPositions = o.getXAxisTicksPositions();
      }
      if (!n.globals.comboCharts && !this.tConfig.intersect && n.config.chart.type !== "rangeBar" || this.tConfig.shared || (this.showOnIntersect = !0), n.config.markers.size !== 0 && n.globals.markers.largestSize !== 0 || this.marker.drawDynamicPoints(this), n.globals.collapsedSeries.length !== n.globals.series.length) {
        this.dataPointsDividedHeight = n.globals.gridHeight / n.globals.dataPoints, this.dataPointsDividedWidth = n.globals.gridWidth / n.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || n.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, a.appendChild(this.tooltipTitle));
        var d = n.globals.series.length;
        (n.globals.xyCharts || n.globals.comboCharts) && this.tConfig.shared && (d = this.showOnIntersect ? 1 : n.globals.series.length), this.legendLabels = n.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(d), this.addSVGEvents();
      }
    } }, { key: "createTTElements", value: function(t) {
      for (var n = this, a = this.w, o = [], d = this.getElTooltip(), f = function(y) {
        var S = document.createElement("div");
        S.classList.add("apexcharts-tooltip-series-group"), S.style.order = a.config.tooltip.inverseOrder ? t - y : y + 1, n.tConfig.shared && n.tConfig.enabledOnSeries && Array.isArray(n.tConfig.enabledOnSeries) && n.tConfig.enabledOnSeries.indexOf(y) < 0 && S.classList.add("apexcharts-tooltip-series-group-hidden");
        var C = document.createElement("span");
        C.classList.add("apexcharts-tooltip-marker"), C.style.backgroundColor = a.globals.colors[y], S.appendChild(C);
        var E = document.createElement("div");
        E.classList.add("apexcharts-tooltip-text"), E.style.fontFamily = n.tConfig.style.fontFamily || a.config.chart.fontFamily, E.style.fontSize = n.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function(L) {
          var M = document.createElement("div");
          M.classList.add("apexcharts-tooltip-".concat(L, "-group"));
          var P = document.createElement("span");
          P.classList.add("apexcharts-tooltip-text-".concat(L, "-label")), M.appendChild(P);
          var I = document.createElement("span");
          I.classList.add("apexcharts-tooltip-text-".concat(L, "-value")), M.appendChild(I), E.appendChild(M);
        }), S.appendChild(E), d.appendChild(S), o.push(S);
      }, p = 0; p < t; p++)
        f(p);
      return o;
    } }, { key: "addSVGEvents", value: function() {
      var t = this.w, n = t.config.chart.type, a = this.getElTooltip(), o = !(n !== "bar" && n !== "candlestick" && n !== "boxPlot" && n !== "rangeBar"), d = n === "area" || n === "line" || n === "scatter" || n === "bubble" || n === "radar", f = t.globals.dom.Paper.node, p = this.getElGrid();
      p && (this.seriesBound = p.getBoundingClientRect());
      var y, S = [], C = [], E = { hoverArea: f, elGrid: p, tooltipEl: a, tooltipY: S, tooltipX: C, ttItems: this.ttItems };
      if (t.globals.axisCharts && (d ? y = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : o ? y = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : n !== "heatmap" && n !== "treemap" || (y = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), y && y.length))
        for (var L = 0; L < y.length; L++)
          S.push(y[L].getAttribute("cy")), C.push(y[L].getAttribute("cx"));
      if (t.globals.xyCharts && !this.showOnIntersect || t.globals.comboCharts && !this.showOnIntersect || o && this.tooltipUtil.hasBars() && this.tConfig.shared)
        this.addPathsEventListeners([f], E);
      else if (o && !t.globals.comboCharts || d && this.showOnIntersect)
        this.addDatapointEventsListeners(E);
      else if (!t.globals.axisCharts || n === "heatmap" || n === "treemap") {
        var M = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
        this.addPathsEventListeners(M, E);
      }
      if (this.showOnIntersect) {
        var P = t.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
        P.length > 0 && this.addPathsEventListeners(P, E), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(E);
      }
    } }, { key: "drawFixedTooltipRect", value: function() {
      var t = this.w, n = this.getElTooltip(), a = n.getBoundingClientRect(), o = a.width + 10, d = a.height + 10, f = this.tConfig.fixed.offsetX, p = this.tConfig.fixed.offsetY, y = this.tConfig.fixed.position.toLowerCase();
      return y.indexOf("right") > -1 && (f = f + t.globals.svgWidth - o + 10), y.indexOf("bottom") > -1 && (p = p + t.globals.svgHeight - d - 10), n.style.left = f + "px", n.style.top = p + "px", { x: f, y: p, ttWidth: o, ttHeight: d };
    } }, { key: "addDatapointEventsListeners", value: function(t) {
      var n = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
      this.addPathsEventListeners(n, t);
    } }, { key: "addPathsEventListeners", value: function(t, n) {
      for (var a = this, o = function(f) {
        var p = { paths: t[f], tooltipEl: n.tooltipEl, tooltipY: n.tooltipY, tooltipX: n.tooltipX, elGrid: n.elGrid, hoverArea: n.hoverArea, ttItems: n.ttItems };
        ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(y) {
          return t[f].addEventListener(y, a.onSeriesHover.bind(a, p), { capture: !1, passive: !0 });
        });
      }, d = 0; d < t.length; d++)
        o(d);
    } }, { key: "onSeriesHover", value: function(t, n) {
      var a = this, o = Date.now() - this.lastHoverTime;
      o >= 100 ? this.seriesHover(t, n) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
        a.seriesHover(t, n);
      }, 100 - o));
    } }, { key: "seriesHover", value: function(t, n) {
      var a = this;
      this.lastHoverTime = Date.now();
      var o = [], d = this.w;
      d.config.chart.group && (o = this.ctx.getGroupedCharts()), d.globals.axisCharts && (d.globals.minX === -1 / 0 && d.globals.maxX === 1 / 0 || d.globals.dataPoints === 0) || (o.length ? o.forEach(function(f) {
        var p = a.getElTooltip(f), y = { paths: t.paths, tooltipEl: p, tooltipY: t.tooltipY, tooltipX: t.tooltipX, elGrid: t.elGrid, hoverArea: t.hoverArea, ttItems: f.w.globals.tooltip.ttItems };
        f.w.globals.minX === a.w.globals.minX && f.w.globals.maxX === a.w.globals.maxX && f.w.globals.tooltip.seriesHoverByContext({ chartCtx: f, ttCtx: f.w.globals.tooltip, opt: y, e: n });
      }) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t, e: n }));
    } }, { key: "seriesHoverByContext", value: function(t) {
      var n = t.chartCtx, a = t.ttCtx, o = t.opt, d = t.e, f = n.w, p = this.getElTooltip();
      p && (a.tooltipRect = { x: 0, y: 0, ttWidth: p.getBoundingClientRect().width, ttHeight: p.getBoundingClientRect().height }, a.e = d, a.tooltipUtil.hasBars() && !f.globals.comboCharts && !a.isBarShared && this.tConfig.onDatasetHover.highlightDataSeries && new st(n).toggleSeriesOnHover(d, d.target.parentNode), a.fixedTooltip && a.drawFixedTooltipRect(), f.globals.axisCharts ? a.axisChartsTooltips({ e: d, opt: o, tooltipRect: a.tooltipRect }) : a.nonAxisChartsTooltips({ e: d, opt: o, tooltipRect: a.tooltipRect }));
    } }, { key: "axisChartsTooltips", value: function(t) {
      var n, a, o = t.e, d = t.opt, f = this.w, p = d.elGrid.getBoundingClientRect(), y = o.type === "touchmove" ? o.touches[0].clientX : o.clientX, S = o.type === "touchmove" ? o.touches[0].clientY : o.clientY;
      if (this.clientY = S, this.clientX = y, f.globals.capturedSeriesIndex = -1, f.globals.capturedDataPointIndex = -1, S < p.top || S > p.top + p.height)
        this.handleMouseOut(d);
      else {
        if (Array.isArray(this.tConfig.enabledOnSeries) && !f.config.tooltip.shared) {
          var C = parseInt(d.paths.getAttribute("index"), 10);
          if (this.tConfig.enabledOnSeries.indexOf(C) < 0)
            return void this.handleMouseOut(d);
        }
        var E = this.getElTooltip(), L = this.getElXCrosshairs(), M = f.globals.xyCharts || f.config.chart.type === "bar" && !f.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || f.globals.comboCharts && this.tooltipUtil.hasBars();
        if (o.type === "mousemove" || o.type === "touchmove" || o.type === "mouseup") {
          if (f.globals.collapsedSeries.length + f.globals.ancillaryCollapsedSeries.length === f.globals.series.length)
            return;
          L !== null && L.classList.add("apexcharts-active");
          var P = this.yaxisTooltips.filter(function(G) {
            return G === !0;
          });
          if (this.ycrosshairs !== null && P.length && this.ycrosshairs.classList.add("apexcharts-active"), M && !this.showOnIntersect)
            this.handleStickyTooltip(o, y, S, d);
          else if (f.config.chart.type === "heatmap" || f.config.chart.type === "treemap") {
            var I = this.intersect.handleHeatTreeTooltip({ e: o, opt: d, x: n, y: a, type: f.config.chart.type });
            n = I.x, a = I.y, E.style.left = n + "px", E.style.top = a + "px";
          } else
            this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: o, opt: d }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({ e: o, opt: d, x: n, y: a });
          if (this.yaxisTooltips.length)
            for (var B = 0; B < f.config.yaxis.length; B++)
              this.axesTooltip.drawYaxisTooltipText(B, S, this.xyRatios);
          d.tooltipEl.classList.add("apexcharts-active");
        } else
          o.type !== "mouseout" && o.type !== "touchend" || this.handleMouseOut(d);
      }
    } }, { key: "nonAxisChartsTooltips", value: function(t) {
      var n = t.e, a = t.opt, o = t.tooltipRect, d = this.w, f = a.paths.getAttribute("rel"), p = this.getElTooltip(), y = d.globals.dom.elWrap.getBoundingClientRect();
      if (n.type === "mousemove" || n.type === "touchmove") {
        p.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({ ttItems: a.ttItems, i: parseInt(f, 10) - 1, shared: !1 });
        var S = d.globals.clientX - y.left - o.ttWidth / 2, C = d.globals.clientY - y.top - o.ttHeight - 10;
        if (p.style.left = S + "px", p.style.top = C + "px", d.config.legend.tooltipHoverFormatter) {
          var E = f - 1, L = (0, d.config.legend.tooltipHoverFormatter)(this.legendLabels[E].getAttribute("data:default-text"), { seriesIndex: E, dataPointIndex: E, w: d });
          this.legendLabels[E].innerHTML = L;
        }
      } else
        n.type !== "mouseout" && n.type !== "touchend" || (p.classList.remove("apexcharts-active"), d.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(M) {
          var P = M.getAttribute("data:default-text");
          M.innerHTML = decodeURIComponent(P);
        }));
    } }, { key: "handleStickyTooltip", value: function(t, n, a, o) {
      var d = this.w, f = this.tooltipUtil.getNearestValues({ context: this, hoverArea: o.hoverArea, elGrid: o.elGrid, clientX: n, clientY: a }), p = f.j, y = f.capturedSeries;
      d.globals.collapsedSeriesIndices.includes(y) && (y = null);
      var S = o.elGrid.getBoundingClientRect();
      if (f.hoverX < 0 || f.hoverX > S.width)
        this.handleMouseOut(o);
      else if (y !== null)
        this.handleStickyCapturedSeries(t, y, o, p);
      else if (this.tooltipUtil.isXoverlap(p) || d.globals.isBarHorizontal) {
        var C = d.globals.series.findIndex(function(E, L) {
          return !d.globals.collapsedSeriesIndices.includes(L);
        });
        this.create(t, this, C, p, o.ttItems);
      }
    } }, { key: "handleStickyCapturedSeries", value: function(t, n, a, o) {
      var d = this.w;
      if (!this.tConfig.shared && d.globals.series[n][o] === null)
        return void this.handleMouseOut(a);
      if (d.globals.series[n][o] !== void 0)
        this.tConfig.shared && this.tooltipUtil.isXoverlap(o) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t, this, n, o, a.ttItems) : this.create(t, this, n, o, a.ttItems, !1);
      else if (this.tooltipUtil.isXoverlap(o)) {
        var f = d.globals.series.findIndex(function(p, y) {
          return !d.globals.collapsedSeriesIndices.includes(y);
        });
        this.create(t, this, f, o, a.ttItems);
      }
    } }, { key: "deactivateHoverFilter", value: function() {
      for (var t = this.w, n = new re(this.ctx), a = t.globals.dom.Paper.select(".apexcharts-bar-area"), o = 0; o < a.length; o++)
        n.pathMouseLeave(a[o]);
    } }, { key: "handleMouseOut", value: function(t) {
      var n = this.w, a = this.getElXCrosshairs();
      if (t.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), n.config.chart.type !== "bubble" && this.marker.resetPointsSize(), a !== null && a.classList.remove("apexcharts-active"), this.ycrosshairs !== null && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
        this.yaxisTTEls === null && (this.yaxisTTEls = n.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
        for (var o = 0; o < this.yaxisTTEls.length; o++)
          this.yaxisTTEls[o].classList.remove("apexcharts-active");
      }
      n.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(d) {
        var f = d.getAttribute("data:default-text");
        d.innerHTML = decodeURIComponent(f);
      });
    } }, { key: "markerClick", value: function(t, n, a) {
      var o = this.w;
      typeof o.config.chart.events.markerClick == "function" && o.config.chart.events.markerClick(t, this.ctx, { seriesIndex: n, dataPointIndex: a, w: o }), this.ctx.events.fireEvent("markerClick", [t, this.ctx, { seriesIndex: n, dataPointIndex: a, w: o }]);
    } }, { key: "create", value: function(t, n, a, o, d) {
      var f, p, y, S, C, E, L, M, P, I, B, G, Z, b, O, N, X = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, Q = this.w, ee = n;
      t.type === "mouseup" && this.markerClick(t, a, o), X === null && (X = this.tConfig.shared);
      var oe = this.tooltipUtil.hasMarkers(a), fe = this.tooltipUtil.getElBars();
      if (Q.config.legend.tooltipHoverFormatter) {
        var ke = Q.config.legend.tooltipHoverFormatter, _e = Array.from(this.legendLabels);
        _e.forEach(function(Br) {
          var Dn = Br.getAttribute("data:default-text");
          Br.innerHTML = decodeURIComponent(Dn);
        });
        for (var Le = 0; Le < _e.length; Le++) {
          var Ie = _e[Le], at = parseInt(Ie.getAttribute("i"), 10), Qt = decodeURIComponent(Ie.getAttribute("data:default-text")), Kt = ke(Qt, { seriesIndex: X ? at : a, dataPointIndex: o, w: Q });
          if (X)
            Ie.innerHTML = Q.globals.collapsedSeriesIndices.indexOf(at) < 0 ? Kt : Qt;
          else if (Ie.innerHTML = at === a ? Kt : Qt, a === at)
            break;
        }
      }
      var xt = m(m({ ttItems: d, i: a, j: o }, ((f = Q.globals.seriesRange) === null || f === void 0 || (p = f[a]) === null || p === void 0 || (y = p[o]) === null || y === void 0 || (S = y.y[0]) === null || S === void 0 ? void 0 : S.y1) !== void 0 && { y1: (C = Q.globals.seriesRange) === null || C === void 0 || (E = C[a]) === null || E === void 0 || (L = E[o]) === null || L === void 0 || (M = L.y[0]) === null || M === void 0 ? void 0 : M.y1 }), ((P = Q.globals.seriesRange) === null || P === void 0 || (I = P[a]) === null || I === void 0 || (B = I[o]) === null || B === void 0 || (G = B.y[0]) === null || G === void 0 ? void 0 : G.y2) !== void 0 && { y2: (Z = Q.globals.seriesRange) === null || Z === void 0 || (b = Z[a]) === null || b === void 0 || (O = b[o]) === null || O === void 0 || (N = O.y[0]) === null || N === void 0 ? void 0 : N.y2 });
      if (X) {
        if (ee.tooltipLabels.drawSeriesTexts(m(m({}, xt), {}, { shared: !this.showOnIntersect && this.tConfig.shared })), oe)
          Q.globals.markers.largestSize > 0 ? ee.marker.enlargePoints(o) : ee.tooltipPosition.moveDynamicPointsOnHover(o);
        else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(fe), this.barSeriesHeight > 0)) {
          var On = new re(this.ctx), zn = Q.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(o, "']"));
          this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(o, a);
          for (var vt = 0; vt < zn.length; vt++)
            On.pathMouseEnter(zn[vt]);
        }
      } else
        ee.tooltipLabels.drawSeriesTexts(m({ shared: !1 }, xt)), this.tooltipUtil.hasBars() && ee.tooltipPosition.moveStickyTooltipOverBars(o, a), oe && ee.tooltipPosition.moveMarkers(a, o);
    } }]), W;
  }(), aa = function() {
    function W(t) {
      T(this, W), this.w = t.w, this.barCtx = t, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
    }
    return F(W, [{ key: "handleBarDataLabels", value: function(t) {
      var n = t.x, a = t.y, o = t.y1, d = t.y2, f = t.i, p = t.j, y = t.realIndex, S = t.groupIndex, C = t.series, E = t.barHeight, L = t.barWidth, M = t.barXPosition, P = t.barYPosition, I = t.visibleSeries, B = t.renderedPath, G = this.w, Z = new re(this.barCtx.ctx), b = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[y] : this.barCtx.strokeWidth, O = n + parseFloat(L * I), N = a + parseFloat(E * I);
      G.globals.isXNumeric && !G.globals.isBarHorizontal && (O = n + parseFloat(L * (I + 1)), N = a + parseFloat(E * (I + 1)) - b);
      var X, Q = null, ee = n, oe = a, fe = {}, ke = G.config.dataLabels, _e = this.barCtx.barOptions.dataLabels, Le = this.barCtx.barOptions.dataLabels.total;
      P !== void 0 && this.barCtx.isRangeBar && (N = P, oe = P), M !== void 0 && this.barCtx.isVerticalGroupedRangeBar && (O = M, ee = M);
      var Ie = ke.offsetX, at = ke.offsetY, Qt = { width: 0, height: 0 };
      if (G.config.dataLabels.enabled) {
        var Kt = this.barCtx.series[f][p];
        Qt = Z.getTextRects(G.globals.yLabelFormatters[0](Kt), parseFloat(ke.style.fontSize));
      }
      var xt = { x: n, y: a, i: f, j: p, realIndex: y, groupIndex: S || -1, renderedPath: B, bcx: O, bcy: N, barHeight: E, barWidth: L, textRects: Qt, strokeWidth: b, dataLabelsX: ee, dataLabelsY: oe, dataLabelsConfig: ke, barDataLabelsConfig: _e, barTotalDataLabelsConfig: Le, offX: Ie, offY: at };
      return fe = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(xt) : this.calculateColumnsDataLabelsPosition(xt), B.attr({ cy: fe.bcy, cx: fe.bcx, j: p, val: C[f][p], barHeight: E, barWidth: L }), X = this.drawCalculatedDataLabels({ x: fe.dataLabelsX, y: fe.dataLabelsY, val: this.barCtx.isRangeBar ? [o, d] : C[f][p], i: y, j: p, barWidth: L, barHeight: E, textRects: Qt, dataLabelsConfig: ke }), G.config.chart.stacked && Le.enabled && (Q = this.drawTotalDataLabels({ x: fe.totalDataLabelsX, y: fe.totalDataLabelsY, realIndex: y, textAnchor: fe.totalDataLabelsAnchor, val: this.getStackedTotalDataLabel({ realIndex: y, j: p }), dataLabelsConfig: ke, barTotalDataLabelsConfig: Le })), { dataLabels: X, totalDataLabels: Q };
    } }, { key: "getStackedTotalDataLabel", value: function(t) {
      var n = t.realIndex, a = t.j, o = this.w, d = this.barCtx.stackedSeriesTotals[a];
      return this.totalFormatter && (d = this.totalFormatter(d, m(m({}, o), {}, { seriesIndex: n, dataPointIndex: a, w: o }))), d;
    } }, { key: "calculateColumnsDataLabelsPosition", value: function(t) {
      var n, a, o = this.w, d = t.i, f = t.j, p = t.realIndex, y = t.groupIndex, S = t.y, C = t.bcx, E = t.barWidth, L = t.barHeight, M = t.textRects, P = t.dataLabelsX, I = t.dataLabelsY, B = t.dataLabelsConfig, G = t.barDataLabelsConfig, Z = t.barTotalDataLabelsConfig, b = t.strokeWidth, O = t.offX, N = t.offY;
      L = Math.abs(L);
      var X = o.config.plotOptions.bar.dataLabels.orientation === "vertical";
      C = C - b / 2 + (y !== -1 ? y * E : 0);
      var Q = o.globals.gridWidth / o.globals.dataPoints;
      this.barCtx.isVerticalGroupedRangeBar ? P += E / 2 : P = o.globals.isXNumeric ? C - E / 2 + O : C - Q + E / 2 + O, X && (P = P + M.height / 2 - b / 2 - 2);
      var ee = this.barCtx.series[d][f] < 0, oe = S;
      switch (this.barCtx.isReversed && (oe = S - L + (ee ? 2 * L : 0), S -= L), G.position) {
        case "center":
          I = X ? ee ? oe + L / 2 + N : oe + L / 2 - N : ee ? oe - L / 2 + M.height / 2 + N : oe + L / 2 + M.height / 2 - N;
          break;
        case "bottom":
          I = X ? ee ? oe + L + N : oe + L - N : ee ? oe - L + M.height + b + N : oe + L - M.height / 2 + b - N;
          break;
        case "top":
          I = X ? ee ? oe + N : oe - N : ee ? oe - M.height / 2 - N : oe + M.height + N;
      }
      if (this.barCtx.lastActiveBarSerieIndex === p && Z.enabled) {
        var fe = new re(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: p, j: f }), B.fontSize);
        n = ee ? oe - fe.height / 2 - N - Z.offsetY + 18 : oe + fe.height + N + Z.offsetY - 18, a = P + Z.offsetX;
      }
      return o.config.chart.stacked || (I < 0 ? I = 0 + b : I + M.height / 3 > o.globals.gridHeight && (I = o.globals.gridHeight - b)), { bcx: C, bcy: S, dataLabelsX: P, dataLabelsY: I, totalDataLabelsX: a, totalDataLabelsY: n, totalDataLabelsAnchor: "middle" };
    } }, { key: "calculateBarsDataLabelsPosition", value: function(t) {
      var n = this.w, a = t.x, o = t.i, d = t.j, f = t.realIndex, p = t.groupIndex, y = t.bcy, S = t.barHeight, C = t.barWidth, E = t.textRects, L = t.dataLabelsX, M = t.strokeWidth, P = t.dataLabelsConfig, I = t.barDataLabelsConfig, B = t.barTotalDataLabelsConfig, G = t.offX, Z = t.offY, b = n.globals.gridHeight / n.globals.dataPoints;
      C = Math.abs(C);
      var O, N, X = (y += p !== -1 ? p * S : 0) - (this.barCtx.isRangeBar ? 0 : b) + S / 2 + E.height / 2 + Z - 3, Q = "start", ee = this.barCtx.series[o][d] < 0, oe = a;
      switch (this.barCtx.isReversed && (oe = a + C - (ee ? 2 * C : 0), a = n.globals.gridWidth - C), I.position) {
        case "center":
          L = ee ? oe + C / 2 - G : Math.max(E.width / 2, oe - C / 2) + G;
          break;
        case "bottom":
          L = ee ? oe + C - M - Math.round(E.width / 2) - G : oe - C + M + Math.round(E.width / 2) + G;
          break;
        case "top":
          L = ee ? oe - M + Math.round(E.width / 2) - G : oe - M - Math.round(E.width / 2) + G;
      }
      if (this.barCtx.lastActiveBarSerieIndex === f && B.enabled) {
        var fe = new re(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: f, j: d }), P.fontSize);
        ee ? (O = oe - M + Math.round(fe.width / 2) - G - B.offsetX - 15, Q = "end") : O = oe - M - Math.round(fe.width / 2) + G + B.offsetX + 15, N = X + B.offsetY;
      }
      return n.config.chart.stacked || (L < 0 ? L = L + E.width + M : L + E.width / 2 > n.globals.gridWidth && (L = n.globals.gridWidth - E.width - M)), { bcx: a, bcy: y, dataLabelsX: L, dataLabelsY: X, totalDataLabelsX: O, totalDataLabelsY: N, totalDataLabelsAnchor: Q };
    } }, { key: "drawCalculatedDataLabels", value: function(t) {
      var n = t.x, a = t.y, o = t.val, d = t.i, f = t.j, p = t.textRects, y = t.barHeight, S = t.barWidth, C = t.dataLabelsConfig, E = this.w, L = "rotate(0)";
      E.config.plotOptions.bar.dataLabels.orientation === "vertical" && (L = "rotate(-90, ".concat(n, ", ").concat(a, ")"));
      var M = new Pt(this.barCtx.ctx), P = new re(this.barCtx.ctx), I = C.formatter, B = null, G = E.globals.collapsedSeriesIndices.indexOf(d) > -1;
      if (C.enabled && !G) {
        B = P.group({ class: "apexcharts-data-labels", transform: L });
        var Z = "";
        o !== void 0 && (Z = I(o, m(m({}, E), {}, { seriesIndex: d, dataPointIndex: f, w: E }))), !o && E.config.plotOptions.bar.hideZeroBarsWhenGrouped && (Z = "");
        var b = E.globals.series[d][f] < 0, O = E.config.plotOptions.bar.dataLabels.position;
        E.config.plotOptions.bar.dataLabels.orientation === "vertical" && (O === "top" && (C.textAnchor = b ? "end" : "start"), O === "center" && (C.textAnchor = "middle"), O === "bottom" && (C.textAnchor = b ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && S < P.getTextRects(Z, parseFloat(C.style.fontSize)).width && (Z = ""), E.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? p.width / 1.6 > Math.abs(S) && (Z = "") : p.height / 1.6 > Math.abs(y) && (Z = ""));
        var N = m({}, C);
        this.barCtx.isHorizontal && o < 0 && (C.textAnchor === "start" ? N.textAnchor = "end" : C.textAnchor === "end" && (N.textAnchor = "start")), M.plotDataLabelsText({ x: n, y: a, text: Z, i: d, j: f, parent: B, dataLabelsConfig: N, alwaysDrawDataLabel: !0, offsetCorrection: !0 });
      }
      return B;
    } }, { key: "drawTotalDataLabels", value: function(t) {
      var n, a = t.x, o = t.y, d = t.val, f = t.realIndex, p = t.textAnchor, y = t.barTotalDataLabelsConfig, S = new re(this.barCtx.ctx);
      return y.enabled && a !== void 0 && o !== void 0 && this.barCtx.lastActiveBarSerieIndex === f && (n = S.drawText({ x: a, y: o, foreColor: y.style.color, text: d, textAnchor: p, fontFamily: y.style.fontFamily, fontSize: y.style.fontSize, fontWeight: y.style.fontWeight })), n;
    } }]), W;
  }(), Ln = function() {
    function W(t) {
      T(this, W), this.w = t.w, this.barCtx = t;
    }
    return F(W, [{ key: "initVariables", value: function(t) {
      var n = this.w;
      this.barCtx.series = t, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
      for (var a = 0; a < t.length; a++)
        if (t[a].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t[a].length), n.globals.isXNumeric)
          for (var o = 0; o < t[a].length; o++)
            n.globals.seriesX[a][o] > n.globals.minX && n.globals.seriesX[a][o] < n.globals.maxX && this.barCtx.visibleItems++;
        else
          this.barCtx.visibleItems = n.globals.dataPoints;
      this.barCtx.seriesLen === 0 && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], n.globals.comboCharts || this.checkZeroSeries({ series: t });
    } }, { key: "initialPositions", value: function() {
      var t, n, a, o, d, f, p, y, S = this.w, C = S.globals.dataPoints;
      this.barCtx.isRangeBar && (C = S.globals.labels.length);
      var E = this.barCtx.seriesLen;
      if (S.config.plotOptions.bar.rangeBarGroupRows && (E = 1), this.barCtx.isHorizontal)
        d = (a = S.globals.gridHeight / C) / E, S.globals.isXNumeric && (d = (a = S.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), d = d * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, String(this.barCtx.barOptions.barHeight).indexOf("%") === -1 && (d = parseInt(this.barCtx.barOptions.barHeight, 10)), y = this.barCtx.baseLineInvertedY + S.globals.padHorizontal + (this.barCtx.isReversed ? S.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (y = S.globals.gridWidth / 2), n = (a - d * this.barCtx.seriesLen) / 2;
      else {
        if (o = S.globals.gridWidth / this.barCtx.visibleItems, S.config.xaxis.convertedCatToNumeric && (o = S.globals.gridWidth / S.globals.dataPoints), f = o / E * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, S.globals.isXNumeric) {
          var L = this.barCtx.xRatio;
          S.config.xaxis.convertedCatToNumeric && (L = this.barCtx.initialXRatio), S.globals.minXDiff && S.globals.minXDiff !== 0.5 && S.globals.minXDiff / L > 0 && (o = S.globals.minXDiff / L), (f = o / E * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (f = 1);
        }
        String(this.barCtx.barOptions.columnWidth).indexOf("%") === -1 && (f = parseInt(this.barCtx.barOptions.columnWidth, 10)), p = S.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? S.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), t = S.globals.padHorizontal + (o - f * this.barCtx.seriesLen) / 2;
      }
      return { x: t, y: n, yDivision: a, xDivision: o, barHeight: d, barWidth: f, zeroH: p, zeroW: y };
    } }, { key: "initializeStackedPrevVars", value: function(t) {
      var n = t.w;
      n.globals.hasSeriesGroups ? n.globals.seriesGroups.forEach(function(a) {
        t[a] || (t[a] = {}), t[a].prevY = [], t[a].prevX = [], t[a].prevYF = [], t[a].prevXF = [], t[a].prevYVal = [], t[a].prevXVal = [];
      }) : (t.prevY = [], t.prevX = [], t.prevYF = [], t.prevXF = [], t.prevYVal = [], t.prevXVal = []);
    } }, { key: "initializeStackedXYVars", value: function(t) {
      var n = t.w;
      n.globals.hasSeriesGroups ? n.globals.seriesGroups.forEach(function(a) {
        t[a] || (t[a] = {}), t[a].xArrj = [], t[a].xArrjF = [], t[a].xArrjVal = [], t[a].yArrj = [], t[a].yArrjF = [], t[a].yArrjVal = [];
      }) : (t.xArrj = [], t.xArrjF = [], t.xArrjVal = [], t.yArrj = [], t.yArrjF = [], t.yArrjVal = []);
    } }, { key: "getPathFillColor", value: function(t, n, a, o) {
      var d, f, p, y, S = this.w, C = new Qe(this.barCtx.ctx), E = null, L = this.barCtx.barOptions.distributed ? a : n;
      return this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(M) {
        t[n][a] >= M.from && t[n][a] <= M.to && (E = M.color);
      }), S.config.series[n].data[a] && S.config.series[n].data[a].fillColor && (E = S.config.series[n].data[a].fillColor), C.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? L : o, dataPointIndex: a, color: E, value: t[n][a], fillConfig: (d = S.config.series[n].data[a]) === null || d === void 0 ? void 0 : d.fill, fillType: (f = S.config.series[n].data[a]) !== null && f !== void 0 && (p = f.fill) !== null && p !== void 0 && p.type ? (y = S.config.series[n].data[a]) === null || y === void 0 ? void 0 : y.fill.type : S.config.fill.type });
    } }, { key: "getStrokeWidth", value: function(t, n, a) {
      var o = 0, d = this.w;
      return this.barCtx.series[t][n] ? this.barCtx.isNullValue = !1 : this.barCtx.isNullValue = !0, d.config.stroke.show && (this.barCtx.isNullValue || (o = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[a] : this.barCtx.strokeWidth)), o;
    } }, { key: "shouldApplyRadius", value: function(t) {
      var n = this.w, a = !1;
      return n.config.plotOptions.bar.borderRadius > 0 && (n.config.chart.stacked && n.config.plotOptions.bar.borderRadiusWhenStacked === "last" ? this.barCtx.lastActiveBarSerieIndex === t && (a = !0) : a = !0), a;
    } }, { key: "barBackground", value: function(t) {
      var n = t.j, a = t.i, o = t.x1, d = t.x2, f = t.y1, p = t.y2, y = t.elSeries, S = this.w, C = new re(this.barCtx.ctx), E = new st(this.barCtx.ctx).getActiveConfigSeriesIndex();
      if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && E === a) {
        n >= this.barCtx.barOptions.colors.backgroundBarColors.length && (n %= this.barCtx.barOptions.colors.backgroundBarColors.length);
        var L = this.barCtx.barOptions.colors.backgroundBarColors[n], M = C.drawRect(o !== void 0 ? o : 0, f !== void 0 ? f : 0, d !== void 0 ? d : S.globals.gridWidth, p !== void 0 ? p : S.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, L, this.barCtx.barOptions.colors.backgroundBarOpacity);
        y.add(M), M.node.classList.add("apexcharts-backgroundBar");
      }
    } }, { key: "getColumnPaths", value: function(t) {
      var n, a = t.barWidth, o = t.barXPosition, d = t.y1, f = t.y2, p = t.strokeWidth, y = t.seriesGroup, S = t.realIndex, C = t.i, E = t.j, L = t.w, M = new re(this.barCtx.ctx);
      (p = Array.isArray(p) ? p[S] : p) || (p = 0);
      var P = a, I = o;
      (n = L.config.series[S].data[E]) !== null && n !== void 0 && n.columnWidthOffset && (I = o - L.config.series[S].data[E].columnWidthOffset / 2, P = a + L.config.series[S].data[E].columnWidthOffset);
      var B = I, G = I + P;
      d += 1e-3, f += 1e-3;
      var Z = M.move(B, d), b = M.move(B, d), O = M.line(G - p, d);
      if (L.globals.previousPaths.length > 0 && (b = this.barCtx.getPreviousPath(S, E, !1)), Z = Z + M.line(B, f) + M.line(G - p, f) + M.line(G - p, d) + (L.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), b = b + M.line(B, d) + O + O + O + O + O + M.line(B, d) + (L.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), this.shouldApplyRadius(S) && (Z = M.roundPathCorners(Z, L.config.plotOptions.bar.borderRadius)), L.config.chart.stacked) {
        var N = this.barCtx;
        L.globals.hasSeriesGroups && y && (N = this.barCtx[y]), N.yArrj.push(f), N.yArrjF.push(Math.abs(d - f)), N.yArrjVal.push(this.barCtx.series[C][E]);
      }
      return { pathTo: Z, pathFrom: b };
    } }, { key: "getBarpaths", value: function(t) {
      var n, a = t.barYPosition, o = t.barHeight, d = t.x1, f = t.x2, p = t.strokeWidth, y = t.seriesGroup, S = t.realIndex, C = t.i, E = t.j, L = t.w, M = new re(this.barCtx.ctx);
      (p = Array.isArray(p) ? p[S] : p) || (p = 0);
      var P = a, I = o;
      (n = L.config.series[S].data[E]) !== null && n !== void 0 && n.barHeightOffset && (P = a - L.config.series[S].data[E].barHeightOffset / 2, I = o + L.config.series[S].data[E].barHeightOffset);
      var B = P, G = P + I;
      d += 1e-3, f += 1e-3;
      var Z = M.move(d, B), b = M.move(d, B);
      L.globals.previousPaths.length > 0 && (b = this.barCtx.getPreviousPath(S, E, !1));
      var O = M.line(d, G - p);
      if (Z = Z + M.line(f, B) + M.line(f, G - p) + O + (L.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), b = b + M.line(d, B) + O + O + O + O + O + M.line(d, B) + (L.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), this.shouldApplyRadius(S) && (Z = M.roundPathCorners(Z, L.config.plotOptions.bar.borderRadius)), L.config.chart.stacked) {
        var N = this.barCtx;
        L.globals.hasSeriesGroups && y && (N = this.barCtx[y]), N.xArrj.push(f), N.xArrjF.push(Math.abs(d - f)), N.xArrjVal.push(this.barCtx.series[C][E]);
      }
      return { pathTo: Z, pathFrom: b };
    } }, { key: "checkZeroSeries", value: function(t) {
      for (var n = t.series, a = this.w, o = 0; o < n.length; o++) {
        for (var d = 0, f = 0; f < n[a.globals.maxValsInArrayIndex].length; f++)
          d += n[o][f];
        d === 0 && this.barCtx.zeroSerieses.push(o);
      }
    } }, { key: "getXForValue", value: function(t, n) {
      var a = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2] ? n : null;
      return t != null && (a = n + t / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t / this.barCtx.invertedYRatio : 0)), a;
    } }, { key: "getYForValue", value: function(t, n) {
      var a = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2] ? n : null;
      return t != null && (a = n - t / this.barCtx.yRatio[this.barCtx.yaxisIndex] + 2 * (this.barCtx.isReversed ? t / this.barCtx.yRatio[this.barCtx.yaxisIndex] : 0)), a;
    } }, { key: "getGoalValues", value: function(t, n, a, o, d) {
      var f = this, p = this.w, y = [], S = function(L, M) {
        var P;
        y.push((H(P = {}, t, t === "x" ? f.getXForValue(L, n, !1) : f.getYForValue(L, a, !1)), H(P, "attrs", M), P));
      };
      if (p.globals.seriesGoals[o] && p.globals.seriesGoals[o][d] && Array.isArray(p.globals.seriesGoals[o][d]) && p.globals.seriesGoals[o][d].forEach(function(L) {
        S(L.value, L);
      }), this.barCtx.barOptions.isDumbbell && p.globals.seriesRange.length) {
        var C = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : p.globals.colors, E = { strokeHeight: t === "x" ? 0 : p.globals.markers.size[o], strokeWidth: t === "x" ? p.globals.markers.size[o] : 0, strokeDashArray: 0, strokeLineCap: "round", strokeColor: Array.isArray(C[o]) ? C[o][0] : C[o] };
        S(p.globals.seriesRangeStart[o][d], E), S(p.globals.seriesRangeEnd[o][d], m(m({}, E), {}, { strokeColor: Array.isArray(C[o]) ? C[o][1] : C[o] }));
      }
      return y;
    } }, { key: "drawGoalLine", value: function(t) {
      var n = t.barXPosition, a = t.barYPosition, o = t.goalX, d = t.goalY, f = t.barWidth, p = t.barHeight, y = new re(this.barCtx.ctx), S = y.group({ className: "apexcharts-bar-goals-groups" });
      S.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({ el: S.node }), S.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
      var C = null;
      return this.barCtx.isHorizontal ? Array.isArray(o) && o.forEach(function(E) {
        var L = E.attrs.strokeHeight !== void 0 ? E.attrs.strokeHeight : p / 2, M = a + L + p / 2;
        C = y.drawLine(E.x, M - 2 * L, E.x, M, E.attrs.strokeColor ? E.attrs.strokeColor : void 0, E.attrs.strokeDashArray, E.attrs.strokeWidth ? E.attrs.strokeWidth : 2, E.attrs.strokeLineCap), S.add(C);
      }) : Array.isArray(d) && d.forEach(function(E) {
        var L = E.attrs.strokeWidth !== void 0 ? E.attrs.strokeWidth : f / 2, M = n + L + f / 2;
        C = y.drawLine(M - 2 * L, E.y, M, E.y, E.attrs.strokeColor ? E.attrs.strokeColor : void 0, E.attrs.strokeDashArray, E.attrs.strokeHeight ? E.attrs.strokeHeight : 2, E.attrs.strokeLineCap), S.add(C);
      }), S;
    } }, { key: "drawBarShadow", value: function(t) {
      var n = t.prevPaths, a = t.currPaths, o = t.color, d = this.w, f = n.x, p = n.x1, y = n.barYPosition, S = a.x, C = a.x1, E = a.barYPosition, L = y + a.barHeight, M = new re(this.barCtx.ctx), P = new K(), I = M.move(p, L) + M.line(f, L) + M.line(S, E) + M.line(C, E) + M.line(p, L) + (d.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z");
      return M.drawPath({ d: I, fill: P.shadeColor(0.5, K.rgb2hex(o)), stroke: "none", strokeWidth: 0, fillOpacity: 1, classes: "apexcharts-bar-shadows" });
    } }]), W;
  }(), yr = function() {
    function W(t, n) {
      T(this, W), this.ctx = t, this.w = t.w;
      var a = this.w;
      this.barOptions = a.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = a.config.stroke.width, this.isNullValue = !1, this.isRangeBar = a.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !a.globals.isBarHorizontal && a.globals.seriesRange.length && a.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = n, this.xyRatios !== null && (this.xRatio = n.xRatio, this.initialXRatio = n.initialXRatio, this.yRatio = n.yRatio, this.invertedXRatio = n.invertedXRatio, this.invertedYRatio = n.invertedYRatio, this.baseLineY = n.baseLineY, this.baseLineInvertedY = n.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.pathArr = [];
      var o = new st(this.ctx);
      this.lastActiveBarSerieIndex = o.getActiveConfigSeriesIndex("desc", ["bar", "column"]);
      var d = o.getBarSeriesIndices(), f = new me(this.ctx);
      this.stackedSeriesTotals = f.getStackedSeriesTotals(this.w.config.series.map(function(p, y) {
        return d.indexOf(y) === -1 ? y : -1;
      }).filter(function(p) {
        return p !== -1;
      })), this.barHelpers = new Ln(this);
    }
    return F(W, [{ key: "draw", value: function(t, n) {
      var a = this.w, o = new re(this.ctx), d = new me(this.ctx, a);
      t = d.getLogSeries(t), this.series = t, this.yRatio = d.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t);
      var f = o.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
      a.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.");
      for (var p = 0, y = 0; p < t.length; p++, y++) {
        var S, C, E, L, M = void 0, P = void 0, I = [], B = [], G = a.globals.comboCharts ? n[p] : p, Z = o.group({ class: "apexcharts-series", rel: p + 1, seriesName: K.escapeString(a.globals.seriesNames[G]), "data:realIndex": G });
        this.ctx.series.addCollapsedClassToSeries(Z, G), t[p].length > 0 && (this.visibleI = this.visibleI + 1);
        var b = 0, O = 0;
        this.yRatio.length > 1 && (this.yaxisIndex = G), this.isReversed = a.config.yaxis[this.yaxisIndex] && a.config.yaxis[this.yaxisIndex].reversed;
        var N = this.barHelpers.initialPositions();
        P = N.y, b = N.barHeight, C = N.yDivision, L = N.zeroW, M = N.x, O = N.barWidth, S = N.xDivision, E = N.zeroH, this.horizontal || B.push(M + O / 2);
        var X = o.group({ class: "apexcharts-datalabels", "data:realIndex": G });
        a.globals.delayedElements.push({ el: X.node }), X.node.classList.add("apexcharts-element-hidden");
        var Q = o.group({ class: "apexcharts-bar-goals-markers" }), ee = o.group({ class: "apexcharts-bar-shadows" });
        a.globals.delayedElements.push({ el: ee.node }), ee.node.classList.add("apexcharts-element-hidden");
        for (var oe = 0; oe < a.globals.dataPoints; oe++) {
          var fe = this.barHelpers.getStrokeWidth(p, oe, G), ke = null, _e = { indexes: { i: p, j: oe, realIndex: G, bc: y }, x: M, y: P, strokeWidth: fe, elSeries: Z };
          this.isHorizontal ? (ke = this.drawBarPaths(m(m({}, _e), {}, { barHeight: b, zeroW: L, yDivision: C })), O = this.series[p][oe] / this.invertedYRatio) : (ke = this.drawColumnPaths(m(m({}, _e), {}, { xDivision: S, barWidth: O, zeroH: E })), b = this.series[p][oe] / this.yRatio[this.yaxisIndex]);
          var Le = this.barHelpers.getPathFillColor(t, p, oe, G);
          if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && oe > 0) {
            var Ie = this.barHelpers.drawBarShadow({ color: typeof Le == "string" && (Le == null ? void 0 : Le.indexOf("url")) === -1 ? Le : K.hexToRgba(a.globals.colors[p]), prevPaths: this.pathArr[this.pathArr.length - 1], currPaths: ke });
            Ie && ee.add(Ie);
          }
          this.pathArr.push(ke);
          var at = this.barHelpers.drawGoalLine({ barXPosition: ke.barXPosition, barYPosition: ke.barYPosition, goalX: ke.goalX, goalY: ke.goalY, barHeight: b, barWidth: O });
          at && Q.add(at), P = ke.y, M = ke.x, oe > 0 && B.push(M + O / 2), I.push(P), this.renderSeries({ realIndex: G, pathFill: Le, j: oe, i: p, pathFrom: ke.pathFrom, pathTo: ke.pathTo, strokeWidth: fe, elSeries: Z, x: M, y: P, series: t, barHeight: ke.barHeight ? ke.barHeight : b, barWidth: ke.barWidth ? ke.barWidth : O, elDataLabelsWrap: X, elGoalsMarkers: Q, elBarShadows: ee, visibleSeries: this.visibleI, type: "bar" });
        }
        a.globals.seriesXvalues[G] = B, a.globals.seriesYvalues[G] = I, f.add(Z);
      }
      return f;
    } }, { key: "renderSeries", value: function(t) {
      var n = t.realIndex, a = t.pathFill, o = t.lineFill, d = t.j, f = t.i, p = t.groupIndex, y = t.pathFrom, S = t.pathTo, C = t.strokeWidth, E = t.elSeries, L = t.x, M = t.y, P = t.y1, I = t.y2, B = t.series, G = t.barHeight, Z = t.barWidth, b = t.barXPosition, O = t.barYPosition, N = t.elDataLabelsWrap, X = t.elGoalsMarkers, Q = t.elBarShadows, ee = t.visibleSeries, oe = t.type, fe = this.w, ke = new re(this.ctx);
      o || (o = this.barOptions.distributed ? fe.globals.stroke.colors[d] : fe.globals.stroke.colors[n]), fe.config.series[f].data[d] && fe.config.series[f].data[d].strokeColor && (o = fe.config.series[f].data[d].strokeColor), this.isNullValue && (a = "none");
      var _e = d / fe.config.chart.animations.animateGradually.delay * (fe.config.chart.animations.speed / fe.globals.dataPoints) / 2.4, Le = ke.renderPaths({ i: f, j: d, realIndex: n, pathFrom: y, pathTo: S, stroke: o, strokeWidth: C, strokeLineCap: fe.config.stroke.lineCap, fill: a, animationDelay: _e, initialSpeed: fe.config.chart.animations.speed, dataChangeSpeed: fe.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(oe, "-area") });
      Le.attr("clip-path", "url(#gridRectMask".concat(fe.globals.cuid, ")"));
      var Ie = fe.config.forecastDataPoints;
      Ie.count > 0 && d >= fe.globals.dataPoints - Ie.count && (Le.node.setAttribute("stroke-dasharray", Ie.dashArray), Le.node.setAttribute("stroke-width", Ie.strokeWidth), Le.node.setAttribute("fill-opacity", Ie.fillOpacity)), P !== void 0 && I !== void 0 && (Le.attr("data-range-y1", P), Le.attr("data-range-y2", I)), new Ee(this.ctx).setSelectionFilter(Le, n, d), E.add(Le);
      var at = new aa(this).handleBarDataLabels({ x: L, y: M, y1: P, y2: I, i: f, j: d, series: B, realIndex: n, groupIndex: p, barHeight: G, barWidth: Z, barXPosition: b, barYPosition: O, renderedPath: Le, visibleSeries: ee });
      return at.dataLabels !== null && N.add(at.dataLabels), at.totalDataLabels && N.add(at.totalDataLabels), E.add(N), X && E.add(X), Q && E.add(Q), E;
    } }, { key: "drawBarPaths", value: function(t) {
      var n, a = t.indexes, o = t.barHeight, d = t.strokeWidth, f = t.zeroW, p = t.x, y = t.y, S = t.yDivision, C = t.elSeries, E = this.w, L = a.i, M = a.j;
      if (E.globals.isXNumeric)
        n = (y = (E.globals.seriesX[L][M] - E.globals.minX) / this.invertedXRatio - o) + o * this.visibleI;
      else if (E.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
        var P = 0, I = 0;
        E.globals.seriesPercent.forEach(function(G, Z) {
          G[M] && P++, Z < L && G[M] === 0 && I++;
        }), P > 0 && (o = this.seriesLen * o / P), n = y + o * this.visibleI, n -= o * I;
      } else
        n = y + o * this.visibleI;
      this.isFunnel && (f -= (this.barHelpers.getXForValue(this.series[L][M], f) - f) / 2), p = this.barHelpers.getXForValue(this.series[L][M], f);
      var B = this.barHelpers.getBarpaths({ barYPosition: n, barHeight: o, x1: f, x2: p, strokeWidth: d, series: this.series, realIndex: a.realIndex, i: L, j: M, w: E });
      return E.globals.isXNumeric || (y += S), this.barHelpers.barBackground({ j: M, i: L, y1: n - o * this.visibleI, y2: o * this.seriesLen, elSeries: C }), { pathTo: B.pathTo, pathFrom: B.pathFrom, x1: f, x: p, y, goalX: this.barHelpers.getGoalValues("x", f, null, L, M), barYPosition: n, barHeight: o };
    } }, { key: "drawColumnPaths", value: function(t) {
      var n, a = t.indexes, o = t.x, d = t.y, f = t.xDivision, p = t.barWidth, y = t.zeroH, S = t.strokeWidth, C = t.elSeries, E = this.w, L = a.realIndex, M = a.i, P = a.j, I = a.bc;
      if (E.globals.isXNumeric) {
        var B = L;
        E.globals.seriesX[L].length || (B = E.globals.maxValsInArrayIndex), E.globals.seriesX[B][P] && (o = (E.globals.seriesX[B][P] - E.globals.minX) / this.xRatio - p * this.seriesLen / 2), n = o + p * this.visibleI;
      } else if (E.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
        var G = 0, Z = 0;
        E.globals.seriesPercent.forEach(function(O, N) {
          O[P] && G++, N < M && O[P] === 0 && Z++;
        }), G > 0 && (p = this.seriesLen * p / G), n = o + p * this.visibleI, n -= p * Z;
      } else
        n = o + p * this.visibleI;
      d = this.barHelpers.getYForValue(this.series[M][P], y);
      var b = this.barHelpers.getColumnPaths({ barXPosition: n, barWidth: p, y1: y, y2: d, strokeWidth: S, series: this.series, realIndex: a.realIndex, i: M, j: P, w: E });
      return E.globals.isXNumeric || (o += f), this.barHelpers.barBackground({ bc: I, j: P, i: M, x1: n - S / 2 - p * this.visibleI, x2: p * this.seriesLen + S / 2, elSeries: C }), { pathTo: b.pathTo, pathFrom: b.pathFrom, x: o, y: d, goalY: this.barHelpers.getGoalValues("y", null, y, M, P), barXPosition: n, barWidth: p };
    } }, { key: "getPreviousPath", value: function(t, n) {
      for (var a, o = this.w, d = 0; d < o.globals.previousPaths.length; d++) {
        var f = o.globals.previousPaths[d];
        f.paths && f.paths.length > 0 && parseInt(f.realIndex, 10) === parseInt(t, 10) && o.globals.previousPaths[d].paths[n] !== void 0 && (a = o.globals.previousPaths[d].paths[n].d);
      }
      return a;
    } }]), W;
  }(), kn = function(W) {
    j(n, yr);
    var t = ae(n);
    function n() {
      return T(this, n), t.apply(this, arguments);
    }
    return F(n, [{ key: "draw", value: function(a, o) {
      var d = this, f = this.w;
      this.graphics = new re(this.ctx), this.bar = new yr(this.ctx, this.xyRatios);
      var p = new me(this.ctx, f);
      a = p.getLogSeries(a), this.yRatio = p.getLogYRatios(this.yRatio), this.barHelpers.initVariables(a), f.config.chart.stackType === "100%" && (a = f.globals.seriesPercent.slice()), this.series = a, this.barHelpers.initializeStackedPrevVars(this);
      for (var y = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), S = 0, C = 0, E = function(P, I) {
        var B = void 0, G = void 0, Z = void 0, b = void 0, O = -1;
        d.groupCtx = d, f.globals.seriesGroups.forEach(function(zn, vt) {
          zn.indexOf(f.config.series[P].name) > -1 && (O = vt);
        }), O !== -1 && (d.groupCtx = d[f.globals.seriesGroups[O]]);
        var N = [], X = [], Q = f.globals.comboCharts ? o[P] : P;
        d.yRatio.length > 1 && (d.yaxisIndex = Q), d.isReversed = f.config.yaxis[d.yaxisIndex] && f.config.yaxis[d.yaxisIndex].reversed;
        var ee = d.graphics.group({ class: "apexcharts-series", seriesName: K.escapeString(f.globals.seriesNames[Q]), rel: P + 1, "data:realIndex": Q });
        d.ctx.series.addCollapsedClassToSeries(ee, Q);
        var oe = d.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": Q }), fe = d.graphics.group({ class: "apexcharts-bar-goals-markers" }), ke = 0, _e = 0, Le = d.initialPositions(S, C, B, G, Z, b);
        C = Le.y, ke = Le.barHeight, G = Le.yDivision, b = Le.zeroW, S = Le.x, _e = Le.barWidth, B = Le.xDivision, Z = Le.zeroH, d.barHelpers.initializeStackedXYVars(d), d.groupCtx.prevY.length === 1 && d.groupCtx.prevY[0].every(function(zn) {
          return isNaN(zn);
        }) && (d.groupCtx.prevY[0] = d.groupCtx.prevY[0].map(function(zn) {
          return Z;
        }), d.groupCtx.prevYF[0] = d.groupCtx.prevYF[0].map(function(zn) {
          return 0;
        }));
        for (var Ie = 0; Ie < f.globals.dataPoints; Ie++) {
          var at = d.barHelpers.getStrokeWidth(P, Ie, Q), Qt = { indexes: { i: P, j: Ie, realIndex: Q, bc: I }, strokeWidth: at, x: S, y: C, elSeries: ee, groupIndex: O, seriesGroup: f.globals.seriesGroups[O] }, Kt = null;
          d.isHorizontal ? (Kt = d.drawStackedBarPaths(m(m({}, Qt), {}, { zeroW: b, barHeight: ke, yDivision: G })), _e = d.series[P][Ie] / d.invertedYRatio) : (Kt = d.drawStackedColumnPaths(m(m({}, Qt), {}, { xDivision: B, barWidth: _e, zeroH: Z })), ke = d.series[P][Ie] / d.yRatio[d.yaxisIndex]);
          var xt = d.barHelpers.drawGoalLine({ barXPosition: Kt.barXPosition, barYPosition: Kt.barYPosition, goalX: Kt.goalX, goalY: Kt.goalY, barHeight: ke, barWidth: _e });
          xt && fe.add(xt), C = Kt.y, S = Kt.x, N.push(S), X.push(C);
          var On = d.barHelpers.getPathFillColor(a, P, Ie, Q);
          ee = d.renderSeries({ realIndex: Q, pathFill: On, j: Ie, i: P, groupIndex: O, pathFrom: Kt.pathFrom, pathTo: Kt.pathTo, strokeWidth: at, elSeries: ee, x: S, y: C, series: a, barHeight: ke, barWidth: _e, elDataLabelsWrap: oe, elGoalsMarkers: fe, type: "bar", visibleSeries: 0 });
        }
        f.globals.seriesXvalues[Q] = N, f.globals.seriesYvalues[Q] = X, d.groupCtx.prevY.push(d.groupCtx.yArrj), d.groupCtx.prevYF.push(d.groupCtx.yArrjF), d.groupCtx.prevYVal.push(d.groupCtx.yArrjVal), d.groupCtx.prevX.push(d.groupCtx.xArrj), d.groupCtx.prevXF.push(d.groupCtx.xArrjF), d.groupCtx.prevXVal.push(d.groupCtx.xArrjVal), y.add(ee);
      }, L = 0, M = 0; L < a.length; L++, M++)
        E(L, M);
      return y;
    } }, { key: "initialPositions", value: function(a, o, d, f, p, y) {
      var S, C, E, L, M = this.w;
      return this.isHorizontal ? (E = (E = f = M.globals.gridHeight / M.globals.dataPoints) * parseInt(M.config.plotOptions.bar.barHeight, 10) / 100, String(M.config.plotOptions.bar.barHeight).indexOf("%") === -1 && (E = parseInt(M.config.plotOptions.bar.barHeight, 10)), y = this.baseLineInvertedY + M.globals.padHorizontal + (this.isReversed ? M.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), o = (f - E) / 2) : (L = d = M.globals.gridWidth / M.globals.dataPoints, L = M.globals.isXNumeric && M.globals.dataPoints > 1 ? (d = M.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : L * parseInt(M.config.plotOptions.bar.columnWidth, 10) / 100, String(M.config.plotOptions.bar.columnWidth).indexOf("%") === -1 && (L = parseInt(M.config.plotOptions.bar.columnWidth, 10)), p = M.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? M.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), a = M.globals.padHorizontal + (d - L) / 2), { x: a, y: o, yDivision: f, xDivision: d, barHeight: (S = M.globals.seriesGroups) !== null && S !== void 0 && S.length ? E / M.globals.seriesGroups.length : E, barWidth: (C = M.globals.seriesGroups) !== null && C !== void 0 && C.length ? L / M.globals.seriesGroups.length : L, zeroH: p, zeroW: y };
    } }, { key: "drawStackedBarPaths", value: function(a) {
      for (var o, d = a.indexes, f = a.barHeight, p = a.strokeWidth, y = a.zeroW, S = a.x, C = a.y, E = a.groupIndex, L = a.seriesGroup, M = a.yDivision, P = a.elSeries, I = this.w, B = C + (E !== -1 ? E * f : 0), G = d.i, Z = d.j, b = 0, O = 0; O < this.groupCtx.prevXF.length; O++)
        b += this.groupCtx.prevXF[O][Z];
      var N = G;
      if (L && (N = L.indexOf(I.config.series[G].name)), N > 0) {
        var X = y;
        this.groupCtx.prevXVal[N - 1][Z] < 0 ? X = this.series[G][Z] >= 0 ? this.groupCtx.prevX[N - 1][Z] + b - 2 * (this.isReversed ? b : 0) : this.groupCtx.prevX[N - 1][Z] : this.groupCtx.prevXVal[N - 1][Z] >= 0 && (X = this.series[G][Z] >= 0 ? this.groupCtx.prevX[N - 1][Z] : this.groupCtx.prevX[N - 1][Z] - b + 2 * (this.isReversed ? b : 0)), o = X;
      } else
        o = y;
      S = this.series[G][Z] === null ? o : o + this.series[G][Z] / this.invertedYRatio - 2 * (this.isReversed ? this.series[G][Z] / this.invertedYRatio : 0);
      var Q = this.barHelpers.getBarpaths({ barYPosition: B, barHeight: f, x1: o, x2: S, strokeWidth: p, series: this.series, realIndex: d.realIndex, seriesGroup: L, i: G, j: Z, w: I });
      return this.barHelpers.barBackground({ j: Z, i: G, y1: B, y2: f, elSeries: P }), C += M, { pathTo: Q.pathTo, pathFrom: Q.pathFrom, goalX: this.barHelpers.getGoalValues("x", y, null, G, Z), barYPosition: B, x: S, y: C };
    } }, { key: "drawStackedColumnPaths", value: function(a) {
      var o = a.indexes, d = a.x, f = a.y, p = a.xDivision, y = a.barWidth, S = a.zeroH, C = a.groupIndex, E = a.seriesGroup, L = a.elSeries, M = this.w, P = o.i, I = o.j, B = o.bc;
      if (M.globals.isXNumeric) {
        var G = M.globals.seriesX[P][I];
        G || (G = 0), d = (G - M.globals.minX) / this.xRatio - y / 2, M.globals.seriesGroups.length && (d = (G - M.globals.minX) / this.xRatio - y / 2 * M.globals.seriesGroups.length);
      }
      for (var Z, b = d + (C !== -1 ? C * y : 0), O = 0, N = 0; N < this.groupCtx.prevYF.length; N++)
        O += isNaN(this.groupCtx.prevYF[N][I]) ? 0 : this.groupCtx.prevYF[N][I];
      var X = P;
      if (E && (X = E.indexOf(M.config.series[P].name)), X > 0 && !M.globals.isXNumeric || X > 0 && M.globals.isXNumeric && M.globals.seriesX[P - 1][I] === M.globals.seriesX[P][I]) {
        var Q, ee, oe, fe = Math.min(this.yRatio.length + 1, P + 1);
        if (this.groupCtx.prevY[X - 1] !== void 0 && this.groupCtx.prevY[X - 1].length)
          for (var ke = 1; ke < fe; ke++) {
            var _e;
            if (!isNaN((_e = this.groupCtx.prevY[X - ke]) === null || _e === void 0 ? void 0 : _e[I])) {
              oe = this.groupCtx.prevY[X - ke][I];
              break;
            }
          }
        for (var Le = 1; Le < fe; Le++) {
          var Ie, at;
          if (((Ie = this.groupCtx.prevYVal[X - Le]) === null || Ie === void 0 ? void 0 : Ie[I]) < 0) {
            ee = this.series[P][I] >= 0 ? oe - O + 2 * (this.isReversed ? O : 0) : oe;
            break;
          }
          if (((at = this.groupCtx.prevYVal[X - Le]) === null || at === void 0 ? void 0 : at[I]) >= 0) {
            ee = this.series[P][I] >= 0 ? oe : oe + O - 2 * (this.isReversed ? O : 0);
            break;
          }
        }
        ee === void 0 && (ee = M.globals.gridHeight), Z = (Q = this.groupCtx.prevYF[0]) !== null && Q !== void 0 && Q.every(function(Kt) {
          return Kt === 0;
        }) && this.groupCtx.prevYF.slice(1, X).every(function(Kt) {
          return Kt.every(function(xt) {
            return isNaN(xt);
          });
        }) ? S : ee;
      } else
        Z = S;
      f = this.series[P][I] ? Z - this.series[P][I] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[P][I] / this.yRatio[this.yaxisIndex] : 0) : Z;
      var Qt = this.barHelpers.getColumnPaths({ barXPosition: b, barWidth: y, y1: Z, y2: f, yRatio: this.yRatio[this.yaxisIndex], strokeWidth: this.strokeWidth, series: this.series, seriesGroup: E, realIndex: o.realIndex, i: P, j: I, w: M });
      return this.barHelpers.barBackground({ bc: B, j: I, i: P, x1: b, x2: y, elSeries: L }), d += p, { pathTo: Qt.pathTo, pathFrom: Qt.pathFrom, goalY: this.barHelpers.getGoalValues("y", null, S, P, I), barXPosition: b, x: M.globals.isXNumeric ? d - p : d, y: f };
    } }]), n;
  }(), Cn = function(W) {
    j(n, yr);
    var t = ae(n);
    function n() {
      return T(this, n), t.apply(this, arguments);
    }
    return F(n, [{ key: "draw", value: function(a, o, d) {
      var f = this, p = this.w, y = new re(this.ctx), S = p.globals.comboCharts ? o : p.config.chart.type, C = new Qe(this.ctx);
      this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = p.config.plotOptions.bar.horizontal;
      var E = new me(this.ctx, p);
      a = E.getLogSeries(a), this.series = a, this.yRatio = E.getLogYRatios(this.yRatio), this.barHelpers.initVariables(a);
      for (var L = y.group({ class: "apexcharts-".concat(S, "-series apexcharts-plot-series") }), M = function(I) {
        f.isBoxPlot = p.config.chart.type === "boxPlot" || p.config.series[I].type === "boxPlot";
        var B, G, Z, b, O = void 0, N = void 0, X = [], Q = [], ee = p.globals.comboCharts ? d[I] : I, oe = y.group({ class: "apexcharts-series", seriesName: K.escapeString(p.globals.seriesNames[ee]), rel: I + 1, "data:realIndex": ee });
        f.ctx.series.addCollapsedClassToSeries(oe, ee), a[I].length > 0 && (f.visibleI = f.visibleI + 1);
        var fe, ke;
        f.yRatio.length > 1 && (f.yaxisIndex = ee);
        var _e = f.barHelpers.initialPositions();
        N = _e.y, fe = _e.barHeight, G = _e.yDivision, b = _e.zeroW, O = _e.x, ke = _e.barWidth, B = _e.xDivision, Z = _e.zeroH, Q.push(O + ke / 2);
        for (var Le = y.group({ class: "apexcharts-datalabels", "data:realIndex": ee }), Ie = function(Qt) {
          var Kt = f.barHelpers.getStrokeWidth(I, Qt, ee), xt = null, On = { indexes: { i: I, j: Qt, realIndex: ee }, x: O, y: N, strokeWidth: Kt, elSeries: oe };
          xt = f.isHorizontal ? f.drawHorizontalBoxPaths(m(m({}, On), {}, { yDivision: G, barHeight: fe, zeroW: b })) : f.drawVerticalBoxPaths(m(m({}, On), {}, { xDivision: B, barWidth: ke, zeroH: Z })), N = xt.y, O = xt.x, Qt > 0 && Q.push(O + ke / 2), X.push(N), xt.pathTo.forEach(function(zn, vt) {
            var Br = !f.isBoxPlot && f.candlestickOptions.wick.useFillColor ? xt.color[vt] : p.globals.stroke.colors[I], Dn = C.fillPath({ seriesNumber: ee, dataPointIndex: Qt, color: xt.color[vt], value: a[I][Qt] });
            f.renderSeries({ realIndex: ee, pathFill: Dn, lineFill: Br, j: Qt, i: I, pathFrom: xt.pathFrom, pathTo: zn, strokeWidth: Kt, elSeries: oe, x: O, y: N, series: a, barHeight: fe, barWidth: ke, elDataLabelsWrap: Le, visibleSeries: f.visibleI, type: p.config.chart.type });
          });
        }, at = 0; at < p.globals.dataPoints; at++)
          Ie(at);
        p.globals.seriesXvalues[ee] = Q, p.globals.seriesYvalues[ee] = X, L.add(oe);
      }, P = 0; P < a.length; P++)
        M(P);
      return L;
    } }, { key: "drawVerticalBoxPaths", value: function(a) {
      var o = a.indexes, d = a.x;
      a.y;
      var f = a.xDivision, p = a.barWidth, y = a.zeroH, S = a.strokeWidth, C = this.w, E = new re(this.ctx), L = o.i, M = o.j, P = !0, I = C.config.plotOptions.candlestick.colors.upward, B = C.config.plotOptions.candlestick.colors.downward, G = "";
      this.isBoxPlot && (G = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
      var Z = this.yRatio[this.yaxisIndex], b = o.realIndex, O = this.getOHLCValue(b, M), N = y, X = y;
      O.o > O.c && (P = !1);
      var Q = Math.min(O.o, O.c), ee = Math.max(O.o, O.c), oe = O.m;
      C.globals.isXNumeric && (d = (C.globals.seriesX[b][M] - C.globals.minX) / this.xRatio - p / 2);
      var fe = d + p * this.visibleI;
      this.series[L][M] === void 0 || this.series[L][M] === null ? (Q = y, ee = y) : (Q = y - Q / Z, ee = y - ee / Z, N = y - O.h / Z, X = y - O.l / Z, oe = y - O.m / Z);
      var ke = E.move(fe, y), _e = E.move(fe + p / 2, Q);
      return C.globals.previousPaths.length > 0 && (_e = this.getPreviousPath(b, M, !0)), ke = this.isBoxPlot ? [E.move(fe, Q) + E.line(fe + p / 2, Q) + E.line(fe + p / 2, N) + E.line(fe + p / 4, N) + E.line(fe + p - p / 4, N) + E.line(fe + p / 2, N) + E.line(fe + p / 2, Q) + E.line(fe + p, Q) + E.line(fe + p, oe) + E.line(fe, oe) + E.line(fe, Q + S / 2), E.move(fe, oe) + E.line(fe + p, oe) + E.line(fe + p, ee) + E.line(fe + p / 2, ee) + E.line(fe + p / 2, X) + E.line(fe + p - p / 4, X) + E.line(fe + p / 4, X) + E.line(fe + p / 2, X) + E.line(fe + p / 2, ee) + E.line(fe, ee) + E.line(fe, oe) + "z"] : [E.move(fe, ee) + E.line(fe + p / 2, ee) + E.line(fe + p / 2, N) + E.line(fe + p / 2, ee) + E.line(fe + p, ee) + E.line(fe + p, Q) + E.line(fe + p / 2, Q) + E.line(fe + p / 2, X) + E.line(fe + p / 2, Q) + E.line(fe, Q) + E.line(fe, ee - S / 2)], _e += E.move(fe, Q), C.globals.isXNumeric || (d += f), { pathTo: ke, pathFrom: _e, x: d, y: ee, barXPosition: fe, color: this.isBoxPlot ? G : P ? [I] : [B] };
    } }, { key: "drawHorizontalBoxPaths", value: function(a) {
      var o = a.indexes;
      a.x;
      var d = a.y, f = a.yDivision, p = a.barHeight, y = a.zeroW, S = a.strokeWidth, C = this.w, E = new re(this.ctx), L = o.i, M = o.j, P = this.boxOptions.colors.lower;
      this.isBoxPlot && (P = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
      var I = this.invertedYRatio, B = o.realIndex, G = this.getOHLCValue(B, M), Z = y, b = y, O = Math.min(G.o, G.c), N = Math.max(G.o, G.c), X = G.m;
      C.globals.isXNumeric && (d = (C.globals.seriesX[B][M] - C.globals.minX) / this.invertedXRatio - p / 2);
      var Q = d + p * this.visibleI;
      this.series[L][M] === void 0 || this.series[L][M] === null ? (O = y, N = y) : (O = y + O / I, N = y + N / I, Z = y + G.h / I, b = y + G.l / I, X = y + G.m / I);
      var ee = E.move(y, Q), oe = E.move(O, Q + p / 2);
      return C.globals.previousPaths.length > 0 && (oe = this.getPreviousPath(B, M, !0)), ee = [E.move(O, Q) + E.line(O, Q + p / 2) + E.line(Z, Q + p / 2) + E.line(Z, Q + p / 2 - p / 4) + E.line(Z, Q + p / 2 + p / 4) + E.line(Z, Q + p / 2) + E.line(O, Q + p / 2) + E.line(O, Q + p) + E.line(X, Q + p) + E.line(X, Q) + E.line(O + S / 2, Q), E.move(X, Q) + E.line(X, Q + p) + E.line(N, Q + p) + E.line(N, Q + p / 2) + E.line(b, Q + p / 2) + E.line(b, Q + p - p / 4) + E.line(b, Q + p / 4) + E.line(b, Q + p / 2) + E.line(N, Q + p / 2) + E.line(N, Q) + E.line(X, Q) + "z"], oe += E.move(O, Q), C.globals.isXNumeric || (d += f), { pathTo: ee, pathFrom: oe, x: N, y: d, barYPosition: Q, color: P };
    } }, { key: "getOHLCValue", value: function(a, o) {
      var d = this.w;
      return { o: this.isBoxPlot ? d.globals.seriesCandleH[a][o] : d.globals.seriesCandleO[a][o], h: this.isBoxPlot ? d.globals.seriesCandleO[a][o] : d.globals.seriesCandleH[a][o], m: d.globals.seriesCandleM[a][o], l: this.isBoxPlot ? d.globals.seriesCandleC[a][o] : d.globals.seriesCandleL[a][o], c: this.isBoxPlot ? d.globals.seriesCandleL[a][o] : d.globals.seriesCandleC[a][o] };
    } }]), n;
  }(), cs = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "checkColorRange", value: function() {
      var t = this.w, n = !1, a = t.config.plotOptions[t.config.chart.type];
      return a.colorScale.ranges.length > 0 && a.colorScale.ranges.map(function(o, d) {
        o.from <= 0 && (n = !0);
      }), n;
    } }, { key: "getShadeColor", value: function(t, n, a, o) {
      var d = this.w, f = 1, p = d.config.plotOptions[t].shadeIntensity, y = this.determineColor(t, n, a);
      d.globals.hasNegs || o ? f = d.config.plotOptions[t].reverseNegativeShade ? y.percent < 0 ? y.percent / 100 * (1.25 * p) : (1 - y.percent / 100) * (1.25 * p) : y.percent <= 0 ? 1 - (1 + y.percent / 100) * p : (1 - y.percent / 100) * p : (f = 1 - y.percent / 100, t === "treemap" && (f = (1 - y.percent / 100) * (1.25 * p)));
      var S = y.color, C = new K();
      return d.config.plotOptions[t].enableShades && (S = this.w.config.theme.mode === "dark" ? K.hexToRgba(C.shadeColor(-1 * f, y.color), d.config.fill.opacity) : K.hexToRgba(C.shadeColor(f, y.color), d.config.fill.opacity)), { color: S, colorProps: y };
    } }, { key: "determineColor", value: function(t, n, a) {
      var o = this.w, d = o.globals.series[n][a], f = o.config.plotOptions[t], p = f.colorScale.inverse ? a : n;
      f.distributed && o.config.chart.type === "treemap" && (p = a);
      var y = o.globals.colors[p], S = null, C = Math.min.apply(Math, ue(o.globals.series[n])), E = Math.max.apply(Math, ue(o.globals.series[n]));
      f.distributed || t !== "heatmap" || (C = o.globals.minY, E = o.globals.maxY), f.colorScale.min !== void 0 && (C = f.colorScale.min < o.globals.minY ? f.colorScale.min : o.globals.minY, E = f.colorScale.max > o.globals.maxY ? f.colorScale.max : o.globals.maxY);
      var L = Math.abs(E) + Math.abs(C), M = 100 * d / (L === 0 ? L - 1e-6 : L);
      return f.colorScale.ranges.length > 0 && f.colorScale.ranges.map(function(P, I) {
        if (d >= P.from && d <= P.to) {
          y = P.color, S = P.foreColor ? P.foreColor : null, C = P.from, E = P.to;
          var B = Math.abs(E) + Math.abs(C);
          M = 100 * d / (B === 0 ? B - 1e-6 : B);
        }
      }), { color: y, foreColor: S, percent: M };
    } }, { key: "calculateDataLabels", value: function(t) {
      var n = t.text, a = t.x, o = t.y, d = t.i, f = t.j, p = t.colorProps, y = t.fontSize, S = this.w.config.dataLabels, C = new re(this.ctx), E = new Pt(this.ctx), L = null;
      if (S.enabled) {
        L = C.group({ class: "apexcharts-data-labels" });
        var M = S.offsetX, P = S.offsetY, I = a + M, B = o + parseFloat(S.style.fontSize) / 3 + P;
        E.plotDataLabelsText({ x: I, y: B, text: n, i: d, j: f, color: p.foreColor, parent: L, fontSize: y, dataLabelsConfig: S });
      }
      return L;
    } }, { key: "addListeners", value: function(t) {
      var n = new re(this.ctx);
      t.node.addEventListener("mouseenter", n.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", n.pathMouseLeave.bind(this, t)), t.node.addEventListener("mousedown", n.pathMouseDown.bind(this, t));
    } }]), W;
  }(), ds = function() {
    function W(t, n) {
      T(this, W), this.ctx = t, this.w = t.w, this.xRatio = n.xRatio, this.yRatio = n.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new cs(t), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
    }
    return F(W, [{ key: "draw", value: function(t) {
      var n = this.w, a = new re(this.ctx), o = a.group({ class: "apexcharts-heatmap" });
      o.attr("clip-path", "url(#gridRectMask".concat(n.globals.cuid, ")"));
      var d = n.globals.gridWidth / n.globals.dataPoints, f = n.globals.gridHeight / n.globals.series.length, p = 0, y = !1;
      this.negRange = this.helpers.checkColorRange();
      var S = t.slice();
      n.config.yaxis[0].reversed && (y = !0, S.reverse());
      for (var C = y ? 0 : S.length - 1; y ? C < S.length : C >= 0; y ? C++ : C--) {
        var E = a.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: K.escapeString(n.globals.seriesNames[C]), rel: C + 1, "data:realIndex": C });
        if (this.ctx.series.addCollapsedClassToSeries(E, C), n.config.chart.dropShadow.enabled) {
          var L = n.config.chart.dropShadow;
          new Ee(this.ctx).dropShadow(E, L, C);
        }
        for (var M = 0, P = n.config.plotOptions.heatmap.shadeIntensity, I = 0; I < S[C].length; I++) {
          var B = this.helpers.getShadeColor(n.config.chart.type, C, I, this.negRange), G = B.color, Z = B.colorProps;
          n.config.fill.type === "image" && (G = new Qe(this.ctx).fillPath({ seriesNumber: C, dataPointIndex: I, opacity: n.globals.hasNegs ? Z.percent < 0 ? 1 - (1 + Z.percent / 100) : P + Z.percent / 100 : Z.percent / 100, patternID: K.randomId(), width: n.config.fill.image.width ? n.config.fill.image.width : d, height: n.config.fill.image.height ? n.config.fill.image.height : f }));
          var b = this.rectRadius, O = a.drawRect(M, p, d, f, b);
          if (O.attr({ cx: M, cy: p }), O.node.classList.add("apexcharts-heatmap-rect"), E.add(O), O.attr({ fill: G, i: C, index: C, j: I, val: S[C][I], "stroke-width": this.strokeWidth, stroke: n.config.plotOptions.heatmap.useFillColorAsStroke ? G : n.globals.stroke.colors[0], color: G }), this.helpers.addListeners(O), n.config.chart.animations.enabled && !n.globals.dataChanged) {
            var N = 1;
            n.globals.resized || (N = n.config.chart.animations.speed), this.animateHeatMap(O, M, p, d, f, N);
          }
          if (n.globals.dataChanged) {
            var X = 1;
            if (this.dynamicAnim.enabled && n.globals.shouldAnimate) {
              X = this.dynamicAnim.speed;
              var Q = n.globals.previousPaths[C] && n.globals.previousPaths[C][I] && n.globals.previousPaths[C][I].color;
              Q || (Q = "rgba(255, 255, 255, 0)"), this.animateHeatColor(O, K.isColorHex(Q) ? Q : K.rgb2hex(Q), K.isColorHex(G) ? G : K.rgb2hex(G), X);
            }
          }
          var ee = (0, n.config.dataLabels.formatter)(n.globals.series[C][I], { value: n.globals.series[C][I], seriesIndex: C, dataPointIndex: I, w: n }), oe = this.helpers.calculateDataLabels({ text: ee, x: M + d / 2, y: p + f / 2, i: C, j: I, colorProps: Z, series: S });
          oe !== null && E.add(oe), M += d;
        }
        p += f, o.add(E);
      }
      var fe = n.globals.yAxisScale[0].result.slice();
      n.config.yaxis[0].reversed ? fe.unshift("") : fe.push(""), n.globals.yAxisScale[0].result = fe;
      var ke = n.globals.gridHeight / n.globals.series.length;
      return n.config.yaxis[0].labels.offsetY = -ke / 2, o;
    } }, { key: "animateHeatMap", value: function(t, n, a, o, d, f) {
      var p = new we(this.ctx);
      p.animateRect(t, { x: n + o / 2, y: a + d / 2, width: 0, height: 0 }, { x: n, y: a, width: o, height: d }, f, function() {
        p.animationCompleted(t);
      });
    } }, { key: "animateHeatColor", value: function(t, n, a, o) {
      t.attr({ fill: n }).animate(o).attr({ fill: a });
    } }]), W;
  }(), fs = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "drawYAxisTexts", value: function(t, n, a, o) {
      var d = this.w, f = d.config.yaxis[0], p = d.globals.yLabelFormatters[0];
      return new re(this.ctx).drawText({ x: t + f.labels.offsetX, y: n + f.labels.offsetY, text: p(o, a), textAnchor: "middle", fontSize: f.labels.style.fontSize, fontFamily: f.labels.style.fontFamily, foreColor: Array.isArray(f.labels.style.colors) ? f.labels.style.colors[a] : f.labels.style.colors });
    } }]), W;
  }(), Vs = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
      var n = this.w;
      this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = n.globals.stroke.colors !== void 0 ? n.globals.stroke.colors : n.globals.colors, this.defaultSize = Math.min(n.globals.gridWidth, n.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = n.globals.gridWidth / 2, n.config.chart.type === "radialBar" ? this.fullAngle = 360 : this.fullAngle = Math.abs(n.config.plotOptions.pie.endAngle - n.config.plotOptions.pie.startAngle), this.initialAngle = n.config.plotOptions.pie.startAngle % this.fullAngle, n.globals.radialSize = this.defaultSize / 2.05 - n.config.stroke.width - (n.config.chart.sparkline.enabled ? 0 : n.config.chart.dropShadow.blur), this.donutSize = n.globals.radialSize * parseInt(n.config.plotOptions.pie.donut.size, 10) / 100, this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
    }
    return F(W, [{ key: "draw", value: function(t) {
      var n = this, a = this.w, o = new re(this.ctx);
      if (this.ret = o.group({ class: "apexcharts-pie" }), a.globals.noData)
        return this.ret;
      for (var d = 0, f = 0; f < t.length; f++)
        d += K.negToZero(t[f]);
      var p = [], y = o.group();
      d === 0 && (d = 1e-5), t.forEach(function(Q) {
        n.maxY = Math.max(n.maxY, Q);
      }), a.config.yaxis[0].max && (this.maxY = a.config.yaxis[0].max), a.config.grid.position === "back" && this.chartType === "polarArea" && this.drawPolarElements(this.ret);
      for (var S = 0; S < t.length; S++) {
        var C = this.fullAngle * K.negToZero(t[S]) / d;
        p.push(C), this.chartType === "polarArea" ? (p[S] = this.fullAngle / t.length, this.sliceSizes.push(a.globals.radialSize * t[S] / this.maxY)) : this.sliceSizes.push(a.globals.radialSize);
      }
      if (a.globals.dataChanged) {
        for (var E, L = 0, M = 0; M < a.globals.previousPaths.length; M++)
          L += K.negToZero(a.globals.previousPaths[M]);
        for (var P = 0; P < a.globals.previousPaths.length; P++)
          E = this.fullAngle * K.negToZero(a.globals.previousPaths[P]) / L, this.prevSectorAngleArr.push(E);
      }
      this.donutSize < 0 && (this.donutSize = 0);
      var I = a.config.plotOptions.pie.customScale, B = a.globals.gridWidth / 2, G = a.globals.gridHeight / 2, Z = B - a.globals.gridWidth / 2 * I, b = G - a.globals.gridHeight / 2 * I;
      if (this.chartType === "donut") {
        var O = o.drawCircle(this.donutSize);
        O.attr({ cx: this.centerX, cy: this.centerY, fill: a.config.plotOptions.pie.donut.background ? a.config.plotOptions.pie.donut.background : "transparent" }), y.add(O);
      }
      var N = this.drawArcs(p, t);
      if (this.sliceLabels.forEach(function(Q) {
        N.add(Q);
      }), y.attr({ transform: "translate(".concat(Z, ", ").concat(b, ") scale(").concat(I, ")") }), y.add(N), this.ret.add(y), this.donutDataLabels.show) {
        var X = this.renderInnerDataLabels(this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show, translateX: Z, translateY: b });
        this.ret.add(X);
      }
      return a.config.grid.position === "front" && this.chartType === "polarArea" && this.drawPolarElements(this.ret), this.ret;
    } }, { key: "drawArcs", value: function(t, n) {
      var a = this.w, o = new Ee(this.ctx), d = new re(this.ctx), f = new Qe(this.ctx), p = d.group({ class: "apexcharts-slices" }), y = this.initialAngle, S = this.initialAngle, C = this.initialAngle, E = this.initialAngle;
      this.strokeWidth = a.config.stroke.show ? a.config.stroke.width : 0;
      for (var L = 0; L < t.length; L++) {
        var M = d.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: K.escapeString(a.globals.seriesNames[L]), rel: L + 1, "data:realIndex": L });
        p.add(M), S = E, C = (y = C) + t[L], E = S + this.prevSectorAngleArr[L];
        var P = C < y ? this.fullAngle + C - y : C - y, I = f.fillPath({ seriesNumber: L, size: this.sliceSizes[L], value: n[L] }), B = this.getChangedPath(S, E), G = d.drawPath({ d: B, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[L] : this.lineColorArr, strokeWidth: 0, fill: I, fillOpacity: a.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(L) });
        if (G.attr({ index: 0, j: L }), o.setSelectionFilter(G, 0, L), a.config.chart.dropShadow.enabled) {
          var Z = a.config.chart.dropShadow;
          o.dropShadow(G, Z, L);
        }
        this.addListeners(G, this.donutDataLabels), re.setAttrs(G.node, { "data:angle": P, "data:startAngle": y, "data:strokeWidth": this.strokeWidth, "data:value": n[L] });
        var b = { x: 0, y: 0 };
        this.chartType === "pie" || this.chartType === "polarArea" ? b = K.polarToCartesian(this.centerX, this.centerY, a.globals.radialSize / 1.25 + a.config.plotOptions.pie.dataLabels.offset, (y + P / 2) % this.fullAngle) : this.chartType === "donut" && (b = K.polarToCartesian(this.centerX, this.centerY, (a.globals.radialSize + this.donutSize) / 2 + a.config.plotOptions.pie.dataLabels.offset, (y + P / 2) % this.fullAngle)), M.add(G);
        var O = 0;
        if (!this.initialAnim || a.globals.resized || a.globals.dataChanged ? this.animBeginArr.push(0) : ((O = P / this.fullAngle * a.config.chart.animations.speed) === 0 && (O = 1), this.animDur = O + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && a.globals.dataChanged ? this.animatePaths(G, { size: this.sliceSizes[L], endAngle: C, startAngle: y, prevStartAngle: S, prevEndAngle: E, animateStartingPos: !0, i: L, animBeginArr: this.animBeginArr, shouldSetPrevPaths: !0, dur: a.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(G, { size: this.sliceSizes[L], endAngle: C, startAngle: y, i: L, totalItems: t.length - 1, animBeginArr: this.animBeginArr, dur: O }), a.config.plotOptions.pie.expandOnClick && this.chartType !== "polarArea" && G.click(this.pieClicked.bind(this, L)), a.globals.selectedDataPoints[0] !== void 0 && a.globals.selectedDataPoints[0].indexOf(L) > -1 && this.pieClicked(L), a.config.dataLabels.enabled) {
          var N = b.x, X = b.y, Q = 100 * P / this.fullAngle + "%";
          if (P !== 0 && a.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t[L]) {
            var ee = a.config.dataLabels.formatter;
            ee !== void 0 && (Q = ee(a.globals.seriesPercent[L][0], { seriesIndex: L, w: a }));
            var oe = a.globals.dataLabels.style.colors[L], fe = d.group({ class: "apexcharts-datalabels" }), ke = d.drawText({ x: N, y: X, text: Q, textAnchor: "middle", fontSize: a.config.dataLabels.style.fontSize, fontFamily: a.config.dataLabels.style.fontFamily, fontWeight: a.config.dataLabels.style.fontWeight, foreColor: oe });
            if (fe.add(ke), a.config.dataLabels.dropShadow.enabled) {
              var _e = a.config.dataLabels.dropShadow;
              o.dropShadow(ke, _e);
            }
            ke.node.classList.add("apexcharts-pie-label"), a.config.chart.animations.animate && a.globals.resized === !1 && (ke.node.classList.add("apexcharts-pie-label-delay"), ke.node.style.animationDelay = a.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(fe);
          }
        }
      }
      return p;
    } }, { key: "addListeners", value: function(t, n) {
      var a = new re(this.ctx);
      t.node.addEventListener("mouseenter", a.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", a.pathMouseLeave.bind(this, t)), t.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t.node, n)), t.node.addEventListener("mousedown", a.pathMouseDown.bind(this, t)), this.donutDataLabels.total.showAlways || (t.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t.node, n)), t.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t.node, n)));
    } }, { key: "animatePaths", value: function(t, n) {
      var a = this.w, o = n.endAngle < n.startAngle ? this.fullAngle + n.endAngle - n.startAngle : n.endAngle - n.startAngle, d = o, f = n.startAngle, p = n.startAngle;
      n.prevStartAngle !== void 0 && n.prevEndAngle !== void 0 && (f = n.prevEndAngle, d = n.prevEndAngle < n.prevStartAngle ? this.fullAngle + n.prevEndAngle - n.prevStartAngle : n.prevEndAngle - n.prevStartAngle), n.i === a.config.series.length - 1 && (o + p > this.fullAngle ? n.endAngle = n.endAngle - (o + p) : o + p < this.fullAngle && (n.endAngle = n.endAngle + (this.fullAngle - (o + p)))), o === this.fullAngle && (o = this.fullAngle - 0.01), this.animateArc(t, f, p, o, d, n);
    } }, { key: "animateArc", value: function(t, n, a, o, d, f) {
      var p, y = this, S = this.w, C = new we(this.ctx), E = f.size;
      (isNaN(n) || isNaN(d)) && (n = a, d = o, f.dur = 0);
      var L = o, M = a, P = n < a ? this.fullAngle + n - a : n - a;
      S.globals.dataChanged && f.shouldSetPrevPaths && f.prevEndAngle && (p = y.getPiePath({ me: y, startAngle: f.prevStartAngle, angle: f.prevEndAngle < f.prevStartAngle ? this.fullAngle + f.prevEndAngle - f.prevStartAngle : f.prevEndAngle - f.prevStartAngle, size: E }), t.attr({ d: p })), f.dur !== 0 ? t.animate(f.dur, S.globals.easing, f.animBeginArr[f.i]).afterAll(function() {
        y.chartType !== "pie" && y.chartType !== "donut" && y.chartType !== "polarArea" || this.animate(S.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": y.strokeWidth }), f.i === S.config.series.length - 1 && C.animationCompleted(t);
      }).during(function(I) {
        L = P + (o - P) * I, f.animateStartingPos && (L = d + (o - d) * I, M = n - d + (a - (n - d)) * I), p = y.getPiePath({ me: y, startAngle: M, angle: L, size: E }), t.node.setAttribute("data:pathOrig", p), t.attr({ d: p });
      }) : (p = y.getPiePath({ me: y, startAngle: M, angle: o, size: E }), f.isTrack || (S.globals.animationEnded = !0), t.node.setAttribute("data:pathOrig", p), t.attr({ d: p, "stroke-width": y.strokeWidth }));
    } }, { key: "pieClicked", value: function(t) {
      var n, a = this.w, o = this, d = o.sliceSizes[t] + (a.config.plotOptions.pie.expandOnClick ? 4 : 0), f = a.globals.dom.Paper.select(".apexcharts-".concat(o.chartType.toLowerCase(), "-slice-").concat(t)).members[0];
      if (f.attr("data:pieClicked") !== "true") {
        var p = a.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
        Array.prototype.forEach.call(p, function(E) {
          E.setAttribute("data:pieClicked", "false");
          var L = E.getAttribute("data:pathOrig");
          L && E.setAttribute("d", L);
        }), f.attr("data:pieClicked", "true");
        var y = parseInt(f.attr("data:startAngle"), 10), S = parseInt(f.attr("data:angle"), 10);
        n = o.getPiePath({ me: o, startAngle: y, angle: S, size: d }), S !== 360 && f.plot(n);
      } else {
        f.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(f.node, this.donutDataLabels);
        var C = f.attr("data:pathOrig");
        f.attr({ d: C });
      }
    } }, { key: "getChangedPath", value: function(t, n) {
      var a = "";
      return this.dynamicAnim && this.w.globals.dataChanged && (a = this.getPiePath({ me: this, startAngle: t, angle: n - t, size: this.size })), a;
    } }, { key: "getPiePath", value: function(t) {
      var n = t.me, a = t.startAngle, o = t.angle, d = t.size, f = a, p = Math.PI * (f - 90) / 180, y = o + a;
      Math.ceil(y) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (y = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(y) > this.fullAngle && (y -= this.fullAngle);
      var S = Math.PI * (y - 90) / 180, C = n.centerX + d * Math.cos(p), E = n.centerY + d * Math.sin(p), L = n.centerX + d * Math.cos(S), M = n.centerY + d * Math.sin(S), P = K.polarToCartesian(n.centerX, n.centerY, n.donutSize, y), I = K.polarToCartesian(n.centerX, n.centerY, n.donutSize, f), B = o > 180 ? 1 : 0, G = ["M", C, E, "A", d, d, 0, B, 1, L, M];
      return n.chartType === "donut" ? [].concat(G, ["L", P.x, P.y, "A", n.donutSize, n.donutSize, 0, B, 0, I.x, I.y, "L", C, E, "z"]).join(" ") : n.chartType === "pie" || n.chartType === "polarArea" ? [].concat(G, ["L", n.centerX, n.centerY, "L", C, E]).join(" ") : [].concat(G).join(" ");
    } }, { key: "drawPolarElements", value: function(t) {
      var n = this.w, a = new qe(this.ctx), o = new re(this.ctx), d = new fs(this.ctx), f = o.group(), p = o.group(), y = a.niceScale(0, Math.ceil(this.maxY), n.config.yaxis[0].tickAmount, 0, !0), S = y.result.reverse(), C = y.result.length;
      this.maxY = y.niceMax;
      for (var E = n.globals.radialSize, L = E / (C - 1), M = 0; M < C - 1; M++) {
        var P = o.drawCircle(E);
        if (P.attr({ cx: this.centerX, cy: this.centerY, fill: "none", "stroke-width": n.config.plotOptions.polarArea.rings.strokeWidth, stroke: n.config.plotOptions.polarArea.rings.strokeColor }), n.config.yaxis[0].show) {
          var I = d.drawYAxisTexts(this.centerX, this.centerY - E + parseInt(n.config.yaxis[0].labels.style.fontSize, 10) / 2, M, S[M]);
          p.add(I);
        }
        f.add(P), E -= L;
      }
      this.drawSpokes(t), t.add(f), t.add(p);
    } }, { key: "renderInnerDataLabels", value: function(t, n) {
      var a = this.w, o = new re(this.ctx), d = o.group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(n.translateX ? n.translateX : 0, ", ").concat(n.translateY ? n.translateY : 0, ") scale(").concat(a.config.plotOptions.pie.customScale, ")") }), f = t.total.show;
      d.node.style.opacity = n.opacity;
      var p, y, S = n.centerX, C = n.centerY;
      p = t.name.color === void 0 ? a.globals.colors[0] : t.name.color;
      var E = t.name.fontSize, L = t.name.fontFamily, M = t.name.fontWeight;
      y = t.value.color === void 0 ? a.config.chart.foreColor : t.value.color;
      var P = t.value.formatter, I = "", B = "";
      if (f ? (p = t.total.color, E = t.total.fontSize, L = t.total.fontFamily, M = t.total.fontWeight, B = t.total.label, I = t.total.formatter(a)) : a.globals.series.length === 1 && (I = P(a.globals.series[0], a), B = a.globals.seriesNames[0]), B && (B = t.name.formatter(B, t.total.show, a)), t.name.show) {
        var G = o.drawText({ x: S, y: C + parseFloat(t.name.offsetY), text: B, textAnchor: "middle", foreColor: p, fontSize: E, fontWeight: M, fontFamily: L });
        G.node.classList.add("apexcharts-datalabel-label"), d.add(G);
      }
      if (t.value.show) {
        var Z = t.name.show ? parseFloat(t.value.offsetY) + 16 : t.value.offsetY, b = o.drawText({ x: S, y: C + Z, text: I, textAnchor: "middle", foreColor: y, fontWeight: t.value.fontWeight, fontSize: t.value.fontSize, fontFamily: t.value.fontFamily });
        b.node.classList.add("apexcharts-datalabel-value"), d.add(b);
      }
      return d;
    } }, { key: "printInnerLabels", value: function(t, n, a, o) {
      var d, f = this.w;
      o ? d = t.name.color === void 0 ? f.globals.colors[parseInt(o.parentNode.getAttribute("rel"), 10) - 1] : t.name.color : f.globals.series.length > 1 && t.total.show && (d = t.total.color);
      var p = f.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), y = f.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
      a = (0, t.value.formatter)(a, f), o || typeof t.total.formatter != "function" || (a = t.total.formatter(f));
      var S = n === t.total.label;
      n = t.name.formatter(n, S, f), p !== null && (p.textContent = n), y !== null && (y.textContent = a), p !== null && (p.style.fill = d);
    } }, { key: "printDataLabelsInner", value: function(t, n) {
      var a = this.w, o = t.getAttribute("data:value"), d = a.globals.seriesNames[parseInt(t.parentNode.getAttribute("rel"), 10) - 1];
      a.globals.series.length > 1 && this.printInnerLabels(n, d, o, t);
      var f = a.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
      f !== null && (f.style.opacity = 1);
    } }, { key: "drawSpokes", value: function(t) {
      var n = this, a = this.w, o = new re(this.ctx), d = a.config.plotOptions.polarArea.spokes;
      if (d.strokeWidth !== 0) {
        for (var f = [], p = 360 / a.globals.series.length, y = 0; y < a.globals.series.length; y++)
          f.push(K.polarToCartesian(this.centerX, this.centerY, a.globals.radialSize, a.config.plotOptions.pie.startAngle + p * y));
        f.forEach(function(S, C) {
          var E = o.drawLine(S.x, S.y, n.centerX, n.centerY, Array.isArray(d.connectorColors) ? d.connectorColors[C] : d.connectorColors);
          t.add(E);
        });
      }
    } }, { key: "revertDataLabelsInner", value: function(t, n, a) {
      var o = this, d = this.w, f = d.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"), p = !1, y = d.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"), S = function(L) {
        var M = L.makeSliceOut, P = L.printLabel;
        Array.prototype.forEach.call(y, function(I) {
          I.getAttribute("data:pieClicked") === "true" && (M && (p = !0), P && o.printDataLabelsInner(I, n));
        });
      };
      if (S({ makeSliceOut: !0, printLabel: !1 }), n.total.show && d.globals.series.length > 1)
        p && !n.total.showAlways ? S({ makeSliceOut: !1, printLabel: !0 }) : this.printInnerLabels(n, n.total.label, n.total.formatter(d));
      else if (S({ makeSliceOut: !1, printLabel: !0 }), !p)
        if (d.globals.selectedDataPoints.length && d.globals.series.length > 1)
          if (d.globals.selectedDataPoints[0].length > 0) {
            var C = d.globals.selectedDataPoints[0], E = d.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(C));
            this.printDataLabelsInner(E, n);
          } else
            f && d.globals.selectedDataPoints.length && d.globals.selectedDataPoints[0].length === 0 && (f.style.opacity = 0);
        else
          f && d.globals.series.length > 1 && (f.style.opacity = 0);
    } }]), W;
  }(), Ol = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
      var n = this.w;
      this.graphics = new re(this.ctx), this.lineColorArr = n.globals.stroke.colors !== void 0 ? n.globals.stroke.colors : n.globals.colors, this.defaultSize = n.globals.svgHeight < n.globals.svgWidth ? n.globals.gridHeight + 1.5 * n.globals.goldenPadding : n.globals.gridWidth, this.isLog = n.config.yaxis[0].logarithmic, this.coreUtils = new me(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(n.globals.maxY, 0) : n.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : n.globals.minY, this.polygons = n.config.plotOptions.radar.polygons, this.strokeWidth = n.config.stroke.show ? n.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - n.config.chart.dropShadow.blur, n.config.xaxis.labels.show && (this.size = this.size - n.globals.xAxisLabelsWidth / 1.75), n.config.plotOptions.radar.size !== void 0 && (this.size = n.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
    }
    return F(W, [{ key: "draw", value: function(t) {
      var n = this, a = this.w, o = new Qe(this.ctx), d = [], f = new Pt(this.ctx);
      t.length && (this.dataPointsLen = t[a.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
      var p = a.globals.gridWidth / 2, y = a.globals.gridHeight / 2, S = p + a.config.plotOptions.radar.offsetX, C = y + a.config.plotOptions.radar.offsetY, E = this.graphics.group({ class: "apexcharts-radar-series apexcharts-plot-series", transform: "translate(".concat(S || 0, ", ").concat(C || 0, ")") }), L = [], M = null, P = null;
      if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), t.forEach(function(B, G) {
        var Z = B.length === a.globals.dataPoints, b = n.graphics.group().attr({ class: "apexcharts-series", "data:longestSeries": Z, seriesName: K.escapeString(a.globals.seriesNames[G]), rel: G + 1, "data:realIndex": G });
        n.dataRadiusOfPercent[G] = [], n.dataRadius[G] = [], n.angleArr[G] = [], B.forEach(function(Le, Ie) {
          var at = Math.abs(n.maxValue - n.minValue);
          Le += Math.abs(n.minValue), n.isLog && (Le = n.coreUtils.getLogVal(Le, 0)), n.dataRadiusOfPercent[G][Ie] = Le / at, n.dataRadius[G][Ie] = n.dataRadiusOfPercent[G][Ie] * n.size, n.angleArr[G][Ie] = Ie * n.disAngle;
        }), L = n.getDataPointsPos(n.dataRadius[G], n.angleArr[G]);
        var O = n.createPaths(L, { x: 0, y: 0 });
        M = n.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), P = n.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": G }), a.globals.delayedElements.push({ el: M.node, index: G });
        var N = { i: G, realIndex: G, animationDelay: G, initialSpeed: a.config.chart.animations.speed, dataChangeSpeed: a.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: !1, bindEventsOnPaths: !1, stroke: a.globals.stroke.colors[G], strokeLineCap: a.config.stroke.lineCap }, X = null;
        a.globals.previousPaths.length > 0 && (X = n.getPreviousPath(G));
        for (var Q = 0; Q < O.linePathsTo.length; Q++) {
          var ee = n.graphics.renderPaths(m(m({}, N), {}, { pathFrom: X === null ? O.linePathsFrom[Q] : X, pathTo: O.linePathsTo[Q], strokeWidth: Array.isArray(n.strokeWidth) ? n.strokeWidth[G] : n.strokeWidth, fill: "none", drawShadow: !1 }));
          b.add(ee);
          var oe = o.fillPath({ seriesNumber: G }), fe = n.graphics.renderPaths(m(m({}, N), {}, { pathFrom: X === null ? O.areaPathsFrom[Q] : X, pathTo: O.areaPathsTo[Q], strokeWidth: 0, fill: oe, drawShadow: !1 }));
          if (a.config.chart.dropShadow.enabled) {
            var ke = new Ee(n.ctx), _e = a.config.chart.dropShadow;
            ke.dropShadow(fe, Object.assign({}, _e, { noUserSpaceOnUse: !0 }), G);
          }
          b.add(fe);
        }
        B.forEach(function(Le, Ie) {
          var at = new kt(n.ctx).getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: G, dataPointIndex: Ie }), Qt = n.graphics.drawMarker(L[Ie].x, L[Ie].y, at);
          Qt.attr("rel", Ie), Qt.attr("j", Ie), Qt.attr("index", G), Qt.node.setAttribute("default-marker-size", at.pSize);
          var Kt = n.graphics.group({ class: "apexcharts-series-markers" });
          Kt && Kt.add(Qt), M.add(Kt), b.add(M);
          var xt = a.config.dataLabels;
          if (xt.enabled) {
            var On = xt.formatter(a.globals.series[G][Ie], { seriesIndex: G, dataPointIndex: Ie, w: a });
            f.plotDataLabelsText({ x: L[Ie].x, y: L[Ie].y, text: On, textAnchor: "middle", i: G, j: G, parent: P, offsetCorrection: !1, dataLabelsConfig: m({}, xt) });
          }
          b.add(P);
        }), d.push(b);
      }), this.drawPolygons({ parent: E }), a.config.xaxis.labels.show) {
        var I = this.drawXAxisTexts();
        E.add(I);
      }
      return d.forEach(function(B) {
        E.add(B);
      }), E.add(this.yaxisLabels), E;
    } }, { key: "drawPolygons", value: function(t) {
      for (var n = this, a = this.w, o = t.parent, d = new fs(this.ctx), f = a.globals.yAxisScale[0].result.reverse(), p = f.length, y = [], S = this.size / (p - 1), C = 0; C < p; C++)
        y[C] = S * C;
      y.reverse();
      var E = [], L = [];
      y.forEach(function(M, P) {
        var I = K.getPolygonPos(M, n.dataPointsLen), B = "";
        I.forEach(function(G, Z) {
          if (P === 0) {
            var b = n.graphics.drawLine(G.x, G.y, 0, 0, Array.isArray(n.polygons.connectorColors) ? n.polygons.connectorColors[Z] : n.polygons.connectorColors);
            L.push(b);
          }
          Z === 0 && n.yaxisLabelsTextsPos.push({ x: G.x, y: G.y }), B += G.x + "," + G.y + " ";
        }), E.push(B);
      }), E.forEach(function(M, P) {
        var I = n.polygons.strokeColors, B = n.polygons.strokeWidth, G = n.graphics.drawPolygon(M, Array.isArray(I) ? I[P] : I, Array.isArray(B) ? B[P] : B, a.globals.radarPolygons.fill.colors[P]);
        o.add(G);
      }), L.forEach(function(M) {
        o.add(M);
      }), a.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(M, P) {
        var I = d.drawYAxisTexts(M.x, M.y, P, f[P]);
        n.yaxisLabels.add(I);
      });
    } }, { key: "drawXAxisTexts", value: function() {
      var t = this, n = this.w, a = n.config.xaxis.labels, o = this.graphics.group({ class: "apexcharts-xaxis" }), d = K.getPolygonPos(this.size, this.dataPointsLen);
      return n.globals.labels.forEach(function(f, p) {
        var y = n.config.xaxis.labels.formatter, S = new Pt(t.ctx);
        if (d[p]) {
          var C = t.getTextPos(d[p], t.size), E = y(f, { seriesIndex: -1, dataPointIndex: p, w: n });
          S.plotDataLabelsText({ x: C.newX, y: C.newY, text: E, textAnchor: C.textAnchor, i: p, j: p, parent: o, color: Array.isArray(a.style.colors) && a.style.colors[p] ? a.style.colors[p] : "#a8a8a8", dataLabelsConfig: m({ textAnchor: C.textAnchor, dropShadow: { enabled: !1 } }, a), offsetCorrection: !1 });
        }
      }), o;
    } }, { key: "createPaths", value: function(t, n) {
      var a = this, o = [], d = [], f = [], p = [];
      if (t.length) {
        d = [this.graphics.move(n.x, n.y)], p = [this.graphics.move(n.x, n.y)];
        var y = this.graphics.move(t[0].x, t[0].y), S = this.graphics.move(t[0].x, t[0].y);
        t.forEach(function(C, E) {
          y += a.graphics.line(C.x, C.y), S += a.graphics.line(C.x, C.y), E === t.length - 1 && (y += "Z", S += "Z");
        }), o.push(y), f.push(S);
      }
      return { linePathsFrom: d, linePathsTo: o, areaPathsFrom: p, areaPathsTo: f };
    } }, { key: "getTextPos", value: function(t, n) {
      var a = "middle", o = t.x, d = t.y;
      return Math.abs(t.x) >= 10 ? t.x > 0 ? (a = "start", o += 10) : t.x < 0 && (a = "end", o -= 10) : a = "middle", Math.abs(t.y) >= n - 10 && (t.y < 0 ? d -= 10 : t.y > 0 && (d += 10)), { textAnchor: a, newX: o, newY: d };
    } }, { key: "getPreviousPath", value: function(t) {
      for (var n = this.w, a = null, o = 0; o < n.globals.previousPaths.length; o++) {
        var d = n.globals.previousPaths[o];
        d.paths.length > 0 && parseInt(d.realIndex, 10) === parseInt(t, 10) && n.globals.previousPaths[o].paths[0] !== void 0 && (a = n.globals.previousPaths[o].paths[0].d);
      }
      return a;
    } }, { key: "getDataPointsPos", value: function(t, n) {
      var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.dataPointsLen;
      t = t || [], n = n || [];
      for (var o = [], d = 0; d < a; d++) {
        var f = {};
        f.x = t[d] * Math.sin(n[d]), f.y = -t[d] * Math.cos(n[d]), o.push(f);
      }
      return o;
    } }]), W;
  }(), hs = function(W) {
    j(n, Vs);
    var t = ae(n);
    function n(a) {
      var o;
      T(this, n), (o = t.call(this, a)).ctx = a, o.w = a.w, o.animBeginArr = [0], o.animDur = 0;
      var d = o.w;
      return o.startAngle = d.config.plotOptions.radialBar.startAngle, o.endAngle = d.config.plotOptions.radialBar.endAngle, o.totalAngle = Math.abs(d.config.plotOptions.radialBar.endAngle - d.config.plotOptions.radialBar.startAngle), o.trackStartAngle = d.config.plotOptions.radialBar.track.startAngle, o.trackEndAngle = d.config.plotOptions.radialBar.track.endAngle, o.donutDataLabels = o.w.config.plotOptions.radialBar.dataLabels, o.radialDataLabels = o.donutDataLabels, o.trackStartAngle || (o.trackStartAngle = o.startAngle), o.trackEndAngle || (o.trackEndAngle = o.endAngle), o.endAngle === 360 && (o.endAngle = 359.99), o.margin = parseInt(d.config.plotOptions.radialBar.track.margin, 10), o;
    }
    return F(n, [{ key: "draw", value: function(a) {
      var o = this.w, d = new re(this.ctx), f = d.group({ class: "apexcharts-radialbar" });
      if (o.globals.noData)
        return f;
      var p = d.group(), y = this.defaultSize / 2, S = o.globals.gridWidth / 2, C = this.defaultSize / 2.05;
      o.config.chart.sparkline.enabled || (C = C - o.config.stroke.width - o.config.chart.dropShadow.blur);
      var E = o.globals.fill.colors;
      if (o.config.plotOptions.radialBar.track.show) {
        var L = this.drawTracks({ size: C, centerX: S, centerY: y, colorArr: E, series: a });
        p.add(L);
      }
      var M = this.drawArcs({ size: C, centerX: S, centerY: y, colorArr: E, series: a }), P = 360;
      o.config.plotOptions.radialBar.startAngle < 0 && (P = this.totalAngle);
      var I = (360 - P) / 360;
      if (o.globals.radialSize = C - C * I, this.radialDataLabels.value.show) {
        var B = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
        o.globals.radialSize += B * I;
      }
      return p.add(M.g), o.config.plotOptions.radialBar.hollow.position === "front" && (M.g.add(M.elHollow), M.dataLabels && M.g.add(M.dataLabels)), f.add(p), f;
    } }, { key: "drawTracks", value: function(a) {
      var o = this.w, d = new re(this.ctx), f = d.group({ class: "apexcharts-tracks" }), p = new Ee(this.ctx), y = new Qe(this.ctx), S = this.getStrokeWidth(a);
      a.size = a.size - S / 2;
      for (var C = 0; C < a.series.length; C++) {
        var E = d.group({ class: "apexcharts-radialbar-track apexcharts-track" });
        f.add(E), E.attr({ rel: C + 1 }), a.size = a.size - S - this.margin;
        var L = o.config.plotOptions.radialBar.track, M = y.fillPath({ seriesNumber: 0, size: a.size, fillColors: Array.isArray(L.background) ? L.background[C] : L.background, solid: !0 }), P = this.trackStartAngle, I = this.trackEndAngle;
        Math.abs(I) + Math.abs(P) >= 360 && (I = 360 - Math.abs(this.startAngle) - 0.1);
        var B = d.drawPath({ d: "", stroke: M, strokeWidth: S * parseInt(L.strokeWidth, 10) / 100, fill: "none", strokeOpacity: L.opacity, classes: "apexcharts-radialbar-area" });
        if (L.dropShadow.enabled) {
          var G = L.dropShadow;
          p.dropShadow(B, G);
        }
        E.add(B), B.attr("id", "apexcharts-radialbarTrack-" + C), this.animatePaths(B, { centerX: a.centerX, centerY: a.centerY, endAngle: I, startAngle: P, size: a.size, i: C, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: !0, easing: o.globals.easing });
      }
      return f;
    } }, { key: "drawArcs", value: function(a) {
      var o = this.w, d = new re(this.ctx), f = new Qe(this.ctx), p = new Ee(this.ctx), y = d.group(), S = this.getStrokeWidth(a);
      a.size = a.size - S / 2;
      var C = o.config.plotOptions.radialBar.hollow.background, E = a.size - S * a.series.length - this.margin * a.series.length - S * parseInt(o.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, L = E - o.config.plotOptions.radialBar.hollow.margin;
      o.config.plotOptions.radialBar.hollow.image !== void 0 && (C = this.drawHollowImage(a, y, E, C));
      var M = this.drawHollow({ size: L, centerX: a.centerX, centerY: a.centerY, fill: C || "transparent" });
      if (o.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
        var P = o.config.plotOptions.radialBar.hollow.dropShadow;
        p.dropShadow(M, P);
      }
      var I = 1;
      !this.radialDataLabels.total.show && o.globals.series.length > 1 && (I = 0);
      var B = null;
      this.radialDataLabels.show && (B = this.renderInnerDataLabels(this.radialDataLabels, { hollowSize: E, centerX: a.centerX, centerY: a.centerY, opacity: I })), o.config.plotOptions.radialBar.hollow.position === "back" && (y.add(M), B && y.add(B));
      var G = !1;
      o.config.plotOptions.radialBar.inverseOrder && (G = !0);
      for (var Z = G ? a.series.length - 1 : 0; G ? Z >= 0 : Z < a.series.length; G ? Z-- : Z++) {
        var b = d.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: K.escapeString(o.globals.seriesNames[Z]) });
        y.add(b), b.attr({ rel: Z + 1, "data:realIndex": Z }), this.ctx.series.addCollapsedClassToSeries(b, Z), a.size = a.size - S - this.margin;
        var O = f.fillPath({ seriesNumber: Z, size: a.size, value: a.series[Z] }), N = this.startAngle, X = void 0, Q = K.negToZero(a.series[Z] > 100 ? 100 : a.series[Z]) / 100, ee = Math.round(this.totalAngle * Q) + this.startAngle, oe = void 0;
        o.globals.dataChanged && (X = this.startAngle, oe = Math.round(this.totalAngle * K.negToZero(o.globals.previousPaths[Z]) / 100) + X), Math.abs(ee) + Math.abs(N) >= 360 && (ee -= 0.01), Math.abs(oe) + Math.abs(X) >= 360 && (oe -= 0.01);
        var fe = ee - N, ke = Array.isArray(o.config.stroke.dashArray) ? o.config.stroke.dashArray[Z] : o.config.stroke.dashArray, _e = d.drawPath({ d: "", stroke: O, strokeWidth: S, fill: "none", fillOpacity: o.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + Z, strokeDashArray: ke });
        if (re.setAttrs(_e.node, { "data:angle": fe, "data:value": a.series[Z] }), o.config.chart.dropShadow.enabled) {
          var Le = o.config.chart.dropShadow;
          p.dropShadow(_e, Le, Z);
        }
        p.setSelectionFilter(_e, 0, Z), this.addListeners(_e, this.radialDataLabels), b.add(_e), _e.attr({ index: 0, j: Z });
        var Ie = 0;
        !this.initialAnim || o.globals.resized || o.globals.dataChanged || (Ie = o.config.chart.animations.speed), o.globals.dataChanged && (Ie = o.config.chart.animations.dynamicAnimation.speed), this.animDur = Ie / (1.2 * a.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(_e, { centerX: a.centerX, centerY: a.centerY, endAngle: ee, startAngle: N, prevEndAngle: oe, prevStartAngle: X, size: a.size, i: Z, totalItems: 2, animBeginArr: this.animBeginArr, dur: Ie, shouldSetPrevPaths: !0, easing: o.globals.easing });
      }
      return { g: y, elHollow: M, dataLabels: B };
    } }, { key: "drawHollow", value: function(a) {
      var o = new re(this.ctx).drawCircle(2 * a.size);
      return o.attr({ class: "apexcharts-radialbar-hollow", cx: a.centerX, cy: a.centerY, r: a.size, fill: a.fill }), o;
    } }, { key: "drawHollowImage", value: function(a, o, d, f) {
      var p = this.w, y = new Qe(this.ctx), S = K.randomId(), C = p.config.plotOptions.radialBar.hollow.image;
      if (p.config.plotOptions.radialBar.hollow.imageClipped)
        y.clippedImgArea({ width: d, height: d, image: C, patternID: "pattern".concat(p.globals.cuid).concat(S) }), f = "url(#pattern".concat(p.globals.cuid).concat(S, ")");
      else {
        var E = p.config.plotOptions.radialBar.hollow.imageWidth, L = p.config.plotOptions.radialBar.hollow.imageHeight;
        if (E === void 0 && L === void 0) {
          var M = p.globals.dom.Paper.image(C).loaded(function(I) {
            this.move(a.centerX - I.width / 2 + p.config.plotOptions.radialBar.hollow.imageOffsetX, a.centerY - I.height / 2 + p.config.plotOptions.radialBar.hollow.imageOffsetY);
          });
          o.add(M);
        } else {
          var P = p.globals.dom.Paper.image(C).loaded(function(I) {
            this.move(a.centerX - E / 2 + p.config.plotOptions.radialBar.hollow.imageOffsetX, a.centerY - L / 2 + p.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(E, L);
          });
          o.add(P);
        }
      }
      return f;
    } }, { key: "getStrokeWidth", value: function(a) {
      var o = this.w;
      return a.size * (100 - parseInt(o.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (a.series.length + 1) - this.margin;
    } }]), n;
  }(), Gs = function(W) {
    j(n, yr);
    var t = ae(n);
    function n() {
      return T(this, n), t.apply(this, arguments);
    }
    return F(n, [{ key: "draw", value: function(a, o) {
      var d = this.w, f = new re(this.ctx);
      this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = a, this.seriesRangeStart = d.globals.seriesRangeStart, this.seriesRangeEnd = d.globals.seriesRangeEnd, this.barHelpers.initVariables(a);
      for (var p = f.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), y = 0; y < a.length; y++) {
        var S, C, E, L, M = void 0, P = void 0, I = d.globals.comboCharts ? o[y] : y, B = f.group({ class: "apexcharts-series", seriesName: K.escapeString(d.globals.seriesNames[I]), rel: y + 1, "data:realIndex": I });
        this.ctx.series.addCollapsedClassToSeries(B, I), a[y].length > 0 && (this.visibleI = this.visibleI + 1);
        var G = 0, Z = 0;
        this.yRatio.length > 1 && (this.yaxisIndex = I);
        var b = this.barHelpers.initialPositions();
        P = b.y, L = b.zeroW, M = b.x, Z = b.barWidth, G = b.barHeight, S = b.xDivision, C = b.yDivision, E = b.zeroH;
        for (var O = f.group({ class: "apexcharts-datalabels", "data:realIndex": I }), N = f.group({ class: "apexcharts-rangebar-goals-markers" }), X = 0; X < d.globals.dataPoints; X++) {
          var Q, ee = this.barHelpers.getStrokeWidth(y, X, I), oe = this.seriesRangeStart[y][X], fe = this.seriesRangeEnd[y][X], ke = null, _e = null, Le = null, Ie = { x: M, y: P, strokeWidth: ee, elSeries: B }, at = this.seriesLen;
          if (d.config.plotOptions.bar.rangeBarGroupRows && (at = 1), d.config.series[y].data[X] === void 0)
            break;
          if (this.isHorizontal) {
            Le = P + G * this.visibleI;
            var Qt = (C - G * at) / 2;
            if (d.config.series[y].data[X].x) {
              var Kt = this.detectOverlappingBars({ i: y, j: X, barYPosition: Le, srty: Qt, barHeight: G, yDivision: C, initPositions: b });
              G = Kt.barHeight, Le = Kt.barYPosition;
            }
            Z = (ke = this.drawRangeBarPaths(m({ indexes: { i: y, j: X, realIndex: I }, barHeight: G, barYPosition: Le, zeroW: L, yDivision: C, y1: oe, y2: fe }, Ie))).barWidth;
          } else {
            d.globals.isXNumeric && (M = (d.globals.seriesX[y][X] - d.globals.minX) / this.xRatio - Z / 2), _e = M + Z * this.visibleI;
            var xt = (S - Z * at) / 2;
            if (d.config.series[y].data[X].x) {
              var On = this.detectOverlappingBars({ i: y, j: X, barXPosition: _e, srtx: xt, barWidth: Z, xDivision: S, initPositions: b });
              Z = On.barWidth, _e = On.barXPosition;
            }
            G = (ke = this.drawRangeColumnPaths(m({ indexes: { i: y, j: X, realIndex: I }, barWidth: Z, barXPosition: _e, zeroH: E, xDivision: S }, Ie))).barHeight;
          }
          var zn = this.barHelpers.drawGoalLine({ barXPosition: ke.barXPosition, barYPosition: Le, goalX: ke.goalX, goalY: ke.goalY, barHeight: G, barWidth: Z });
          zn && N.add(zn), P = ke.y, M = ke.x;
          var vt = this.barHelpers.getPathFillColor(a, y, X, I), Br = d.globals.stroke.colors[I];
          this.renderSeries((H(Q = { realIndex: I, pathFill: vt, lineFill: Br, j: X, i: y, x: M, y: P, y1: oe, y2: fe, pathFrom: ke.pathFrom, pathTo: ke.pathTo, strokeWidth: ee, elSeries: B, series: a, barHeight: G, barWidth: Z, barXPosition: _e, barYPosition: Le }, "barWidth", Z), H(Q, "elDataLabelsWrap", O), H(Q, "elGoalsMarkers", N), H(Q, "visibleSeries", this.visibleI), H(Q, "type", "rangebar"), Q));
        }
        p.add(B);
      }
      return p;
    } }, { key: "detectOverlappingBars", value: function(a) {
      var o = a.i, d = a.j, f = a.barYPosition, p = a.barXPosition, y = a.srty, S = a.srtx, C = a.barHeight, E = a.barWidth, L = a.yDivision, M = a.xDivision, P = a.initPositions, I = this.w, B = [], G = I.config.series[o].data[d].rangeName, Z = I.config.series[o].data[d].x, b = Array.isArray(Z) ? Z.join(" ") : Z, O = I.globals.labels.map(function(X) {
        return Array.isArray(X) ? X.join(" ") : X;
      }).indexOf(b), N = I.globals.seriesRange[o].findIndex(function(X) {
        return X.x === b && X.overlaps.length > 0;
      });
      return this.isHorizontal ? (f = I.config.plotOptions.bar.rangeBarGroupRows ? y + L * O : y + C * this.visibleI + L * O, N > -1 && !I.config.plotOptions.bar.rangeBarOverlap && (B = I.globals.seriesRange[o][N].overlaps).indexOf(G) > -1 && (f = (C = P.barHeight / B.length) * this.visibleI + L * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + C * (this.visibleI + B.indexOf(G)) + L * O)) : (O > -1 && (p = I.config.plotOptions.bar.rangeBarGroupRows ? S + M * O : S + E * this.visibleI + M * O), N > -1 && !I.config.plotOptions.bar.rangeBarOverlap && (B = I.globals.seriesRange[o][N].overlaps).indexOf(G) > -1 && (p = (E = P.barWidth / B.length) * this.visibleI + M * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + E * (this.visibleI + B.indexOf(G)) + M * O)), { barYPosition: f, barXPosition: p, barHeight: C, barWidth: E };
    } }, { key: "drawRangeColumnPaths", value: function(a) {
      var o = a.indexes, d = a.x, f = a.xDivision, p = a.barWidth, y = a.barXPosition, S = a.zeroH, C = this.w, E = o.i, L = o.j, M = this.yRatio[this.yaxisIndex], P = o.realIndex, I = this.getRangeValue(P, L), B = Math.min(I.start, I.end), G = Math.max(I.start, I.end);
      this.series[E][L] === void 0 || this.series[E][L] === null ? B = S : (B = S - B / M, G = S - G / M);
      var Z = Math.abs(G - B), b = this.barHelpers.getColumnPaths({ barXPosition: y, barWidth: p, y1: B, y2: G, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: o.realIndex, i: P, j: L, w: C });
      return C.globals.isXNumeric || (d += f), { pathTo: b.pathTo, pathFrom: b.pathFrom, barHeight: Z, x: d, y: G, goalY: this.barHelpers.getGoalValues("y", null, S, E, L), barXPosition: y };
    } }, { key: "drawRangeBarPaths", value: function(a) {
      var o = a.indexes, d = a.y, f = a.y1, p = a.y2, y = a.yDivision, S = a.barHeight, C = a.barYPosition, E = a.zeroW, L = this.w, M = E + f / this.invertedYRatio, P = E + p / this.invertedYRatio, I = Math.abs(P - M), B = this.barHelpers.getBarpaths({ barYPosition: C, barHeight: S, x1: M, x2: P, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: o.realIndex, realIndex: o.realIndex, j: o.j, w: L });
      return L.globals.isXNumeric || (d += y), { pathTo: B.pathTo, pathFrom: B.pathFrom, barWidth: I, x: P, goalX: this.barHelpers.getGoalValues("x", E, null, o.realIndex, o.j), y: d };
    } }, { key: "getRangeValue", value: function(a, o) {
      var d = this.w;
      return { start: d.globals.seriesRangeStart[a][o], end: d.globals.seriesRangeEnd[a][o] };
    } }]), n;
  }(), ps = function() {
    function W(t) {
      T(this, W), this.w = t.w, this.lineCtx = t;
    }
    return F(W, [{ key: "sameValueSeriesFix", value: function(t, n) {
      var a = this.w;
      if ((a.config.fill.type === "gradient" || a.config.fill.type[t] === "gradient") && new me(this.lineCtx.ctx, a).seriesHaveSameValues(t)) {
        var o = n[t].slice();
        o[o.length - 1] = o[o.length - 1] + 1e-6, n[t] = o;
      }
      return n;
    } }, { key: "calculatePoints", value: function(t) {
      var n = t.series, a = t.realIndex, o = t.x, d = t.y, f = t.i, p = t.j, y = t.prevY, S = this.w, C = [], E = [];
      if (p === 0) {
        var L = this.lineCtx.categoryAxisCorrection + S.config.markers.offsetX;
        S.globals.isXNumeric && (L = (S.globals.seriesX[a][0] - S.globals.minX) / this.lineCtx.xRatio + S.config.markers.offsetX), C.push(L), E.push(K.isNumber(n[f][0]) ? y + S.config.markers.offsetY : null), C.push(o + S.config.markers.offsetX), E.push(K.isNumber(n[f][p + 1]) ? d + S.config.markers.offsetY : null);
      } else
        C.push(o + S.config.markers.offsetX), E.push(K.isNumber(n[f][p + 1]) ? d + S.config.markers.offsetY : null);
      return { x: C, y: E };
    } }, { key: "checkPreviousPaths", value: function(t) {
      for (var n = t.pathFromLine, a = t.pathFromArea, o = t.realIndex, d = this.w, f = 0; f < d.globals.previousPaths.length; f++) {
        var p = d.globals.previousPaths[f];
        (p.type === "line" || p.type === "area") && p.paths.length > 0 && parseInt(p.realIndex, 10) === parseInt(o, 10) && (p.type === "line" ? (this.lineCtx.appendPathFrom = !1, n = d.globals.previousPaths[f].paths[0].d) : p.type === "area" && (this.lineCtx.appendPathFrom = !1, a = d.globals.previousPaths[f].paths[0].d, d.config.stroke.show && d.globals.previousPaths[f].paths[1] && (n = d.globals.previousPaths[f].paths[1].d)));
      }
      return { pathFromLine: n, pathFromArea: a };
    } }, { key: "determineFirstPrevY", value: function(t) {
      var n, a = t.i, o = t.series, d = t.prevY, f = t.lineYPosition, p = this.w;
      if (((n = o[a]) === null || n === void 0 ? void 0 : n[0]) !== void 0)
        d = (f = p.config.chart.stacked && a > 0 ? this.lineCtx.prevSeriesY[a - 1][0] : this.lineCtx.zeroY) - o[a][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? o[a][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);
      else if (p.config.chart.stacked && a > 0 && o[a][0] === void 0) {
        for (var y = a - 1; y >= 0; y--)
          if (o[y][0] !== null && o[y][0] !== void 0) {
            d = f = this.lineCtx.prevSeriesY[y][0];
            break;
          }
      }
      return { prevY: d, lineYPosition: f };
    } }]), W;
  }(), $s = function(W) {
    for (var t, n, a, o, d = function(C) {
      for (var E = [], L = C[0], M = C[1], P = E[0] = jr(L, M), I = 1, B = C.length - 1; I < B; I++)
        L = M, M = C[I + 1], E[I] = 0.5 * (P + (P = jr(L, M)));
      return E[I] = P, E;
    }(W), f = W.length - 1, p = [], y = 0; y < f; y++)
      a = jr(W[y], W[y + 1]), Math.abs(a) < 1e-6 ? d[y] = d[y + 1] = 0 : (o = (t = d[y] / a) * t + (n = d[y + 1] / a) * n) > 9 && (o = 3 * a / Math.sqrt(o), d[y] = o * t, d[y + 1] = o * n);
    for (var S = 0; S <= f; S++)
      o = (W[Math.min(f, S + 1)][0] - W[Math.max(0, S - 1)][0]) / (6 * (1 + d[S] * d[S])), p.push([o || 0, d[S] * o || 0]);
    return p;
  }, Ma = function(W) {
    for (var t = "", n = 0; n < W.length; n++) {
      var a = W[n], o = a.length;
      o > 4 ? (t += "C".concat(a[0], ", ").concat(a[1]), t += ", ".concat(a[2], ", ").concat(a[3]), t += ", ".concat(a[4], ", ").concat(a[5])) : o > 2 && (t += "S".concat(a[0], ", ").concat(a[1]), t += ", ".concat(a[2], ", ").concat(a[3]));
    }
    return t;
  }, Ni = function(W) {
    var t = $s(W), n = W[1], a = W[0], o = [], d = t[1], f = t[0];
    o.push(a, [a[0] + f[0], a[1] + f[1], n[0] - d[0], n[1] - d[1], n[0], n[1]]);
    for (var p = 2, y = t.length; p < y; p++) {
      var S = W[p], C = t[p];
      o.push([S[0] - C[0], S[1] - C[1], S[0], S[1]]);
    }
    return o;
  };
  function jr(W, t) {
    return (t[1] - W[1]) / (t[0] - W[0]);
  }
  var ba = function() {
    function W(t, n, a) {
      T(this, W), this.ctx = t, this.w = t.w, this.xyRatios = n, this.pointsChart = !(this.w.config.chart.type !== "bubble" && this.w.config.chart.type !== "scatter") || a, this.scatter = new mt(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new ps(this), this.markers = new kt(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
    }
    return F(W, [{ key: "draw", value: function(t, n, a, o) {
      var d = this.w, f = new re(this.ctx), p = d.globals.comboCharts ? n : d.config.chart.type, y = f.group({ class: "apexcharts-".concat(p, "-series apexcharts-plot-series") }), S = new me(this.ctx, d);
      this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t = S.getLogSeries(t), this.yRatio = S.getLogYRatios(this.yRatio);
      for (var C = [], E = 0; E < t.length; E++) {
        t = this.lineHelpers.sameValueSeriesFix(E, t);
        var L = d.globals.comboCharts ? a[E] : E;
        this._initSerieVariables(t, E, L);
        var M = [], P = [], I = [], B = d.globals.padHorizontal + this.categoryAxisCorrection;
        this.ctx.series.addCollapsedClassToSeries(this.elSeries, L), d.globals.isXNumeric && d.globals.seriesX.length > 0 && (B = (d.globals.seriesX[L][0] - d.globals.minX) / this.xRatio), I.push(B);
        var G, Z = B, b = void 0, O = Z, N = this.zeroY, X = this.zeroY;
        N = this.lineHelpers.determineFirstPrevY({ i: E, series: t, prevY: N, lineYPosition: 0 }).prevY, M.push(N), G = N, p === "rangeArea" && (b = X = this.lineHelpers.determineFirstPrevY({ i: E, series: o, prevY: X, lineYPosition: 0 }).prevY, P.push(X));
        var Q = { type: p, series: t, realIndex: L, i: E, x: B, y: 1, pX: Z, pY: G, pathsFrom: this._calculatePathsFrom({ type: p, series: t, i: E, realIndex: L, prevX: O, prevY: N, prevY2: X }), linePaths: [], areaPaths: [], seriesIndex: a, lineYPosition: 0, xArrj: I, yArrj: M, y2Arrj: P, seriesRangeEnd: o }, ee = this._iterateOverDataPoints(m(m({}, Q), {}, { iterations: p === "rangeArea" ? t[E].length - 1 : void 0, isRangeStart: !0 }));
        if (p === "rangeArea") {
          var oe = this._calculatePathsFrom({ series: o, i: E, realIndex: L, prevX: O, prevY: X }), fe = this._iterateOverDataPoints(m(m({}, Q), {}, { series: o, pY: b, pathsFrom: oe, iterations: o[E].length - 1, isRangeStart: !1 }));
          ee.linePaths[0] = fe.linePath + ee.linePath, ee.pathFromLine = fe.pathFromLine + ee.pathFromLine;
        }
        this._handlePaths({ type: p, realIndex: L, i: E, paths: ee }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), C.push(this.elSeries);
      }
      if (d.config.chart.stacked)
        for (var ke = C.length; ke > 0; ke--)
          y.add(C[ke - 1]);
      else
        for (var _e = 0; _e < C.length; _e++)
          y.add(C[_e]);
      return y;
    } }, { key: "_initSerieVariables", value: function(t, n, a) {
      var o = this.w, d = new re(this.ctx);
      this.xDivision = o.globals.gridWidth / (o.globals.dataPoints - (o.config.xaxis.tickPlacement === "on" ? 1 : 0)), this.strokeWidth = Array.isArray(o.config.stroke.width) ? o.config.stroke.width[a] : o.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = a), this.isReversed = o.config.yaxis[this.yaxisIndex] && o.config.yaxis[this.yaxisIndex].reversed, this.zeroY = o.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? o.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, (this.zeroY > o.globals.gridHeight || o.config.plotOptions.area.fillTo === "end") && (this.areaBottomY = o.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = d.group({ class: "apexcharts-series", seriesName: K.escapeString(o.globals.seriesNames[a]) }), this.elPointsMain = d.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": a }), this.elDataLabelsWrap = d.group({ class: "apexcharts-datalabels", "data:realIndex": a });
      var f = t[n].length === o.globals.dataPoints;
      this.elSeries.attr({ "data:longestSeries": f, rel: n + 1, "data:realIndex": a }), this.appendPathFrom = !0;
    } }, { key: "_calculatePathsFrom", value: function(t) {
      var n, a, o, d, f = t.type, p = t.series, y = t.i, S = t.realIndex, C = t.prevX, E = t.prevY, L = t.prevY2, M = this.w, P = new re(this.ctx);
      if (p[y][0] === null) {
        for (var I = 0; I < p[y].length; I++)
          if (p[y][I] !== null) {
            C = this.xDivision * I, E = this.zeroY - p[y][I] / this.yRatio[this.yaxisIndex], n = P.move(C, E), a = P.move(C, this.areaBottomY);
            break;
          }
      } else
        n = P.move(C, E), f === "rangeArea" && (n = P.move(C, L) + P.line(C, E)), a = P.move(C, this.areaBottomY) + P.line(C, E);
      if (o = P.move(-1, this.zeroY) + P.line(-1, this.zeroY), d = P.move(-1, this.zeroY) + P.line(-1, this.zeroY), M.globals.previousPaths.length > 0) {
        var B = this.lineHelpers.checkPreviousPaths({ pathFromLine: o, pathFromArea: d, realIndex: S });
        o = B.pathFromLine, d = B.pathFromArea;
      }
      return { prevX: C, prevY: E, linePath: n, areaPath: a, pathFromLine: o, pathFromArea: d };
    } }, { key: "_handlePaths", value: function(t) {
      var n = t.type, a = t.realIndex, o = t.i, d = t.paths, f = this.w, p = new re(this.ctx), y = new Qe(this.ctx);
      this.prevSeriesY.push(d.yArrj), f.globals.seriesXvalues[a] = d.xArrj, f.globals.seriesYvalues[a] = d.yArrj;
      var S = f.config.forecastDataPoints;
      if (S.count > 0 && n !== "rangeArea") {
        var C = f.globals.seriesXvalues[a][f.globals.seriesXvalues[a].length - S.count - 1], E = p.drawRect(C, 0, f.globals.gridWidth, f.globals.gridHeight, 0);
        f.globals.dom.elForecastMask.appendChild(E.node);
        var L = p.drawRect(0, 0, C, f.globals.gridHeight, 0);
        f.globals.dom.elNonForecastMask.appendChild(L.node);
      }
      this.pointsChart || f.globals.delayedElements.push({ el: this.elPointsMain.node, index: a });
      var M = { i: o, realIndex: a, animationDelay: o, initialSpeed: f.config.chart.animations.speed, dataChangeSpeed: f.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(n) };
      if (n === "area")
        for (var P = y.fillPath({ seriesNumber: a }), I = 0; I < d.areaPaths.length; I++) {
          var B = p.renderPaths(m(m({}, M), {}, { pathFrom: d.pathFromArea, pathTo: d.areaPaths[I], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: P }));
          this.elSeries.add(B);
        }
      if (f.config.stroke.show && !this.pointsChart) {
        var G = null;
        if (n === "line")
          G = y.fillPath({ seriesNumber: a, i: o });
        else if (f.config.stroke.fill.type === "solid")
          G = f.globals.stroke.colors[a];
        else {
          var Z = f.config.fill;
          f.config.fill = f.config.stroke.fill, G = y.fillPath({ seriesNumber: a, i: o }), f.config.fill = Z;
        }
        for (var b = 0; b < d.linePaths.length; b++) {
          var O = G;
          n === "rangeArea" && (O = y.fillPath({ seriesNumber: a }));
          var N = m(m({}, M), {}, { pathFrom: d.pathFromLine, pathTo: d.linePaths[b], stroke: G, strokeWidth: this.strokeWidth, strokeLineCap: f.config.stroke.lineCap, fill: n === "rangeArea" ? O : "none" }), X = p.renderPaths(N);
          if (this.elSeries.add(X), X.attr("fill-rule", "evenodd"), S.count > 0 && n !== "rangeArea") {
            var Q = p.renderPaths(N);
            Q.node.setAttribute("stroke-dasharray", S.dashArray), S.strokeWidth && Q.node.setAttribute("stroke-width", S.strokeWidth), this.elSeries.add(Q), Q.attr("clip-path", "url(#forecastMask".concat(f.globals.cuid, ")")), X.attr("clip-path", "url(#nonForecastMask".concat(f.globals.cuid, ")"));
          }
        }
      }
    } }, { key: "_iterateOverDataPoints", value: function(t) {
      var n = t.type, a = t.series, o = t.iterations, d = t.realIndex, f = t.i, p = t.x, y = t.y, S = t.pX, C = t.pY, E = t.pathsFrom, L = t.linePaths, M = t.areaPaths, P = t.seriesIndex, I = t.lineYPosition, B = t.xArrj, G = t.yArrj, Z = t.y2Arrj, b = t.isRangeStart, O = t.seriesRangeEnd, N = this.w, X = new re(this.ctx), Q = this.yRatio, ee = E.prevY, oe = E.linePath, fe = E.areaPath, ke = E.pathFromLine, _e = E.pathFromArea, Le = K.isNumber(N.globals.minYArr[d]) ? N.globals.minYArr[d] : N.globals.minY;
      o || (o = N.globals.dataPoints > 1 ? N.globals.dataPoints - 1 : N.globals.dataPoints);
      for (var Ie = y, at = 0; at < o; at++) {
        var Qt = a[f][at + 1] === void 0 || a[f][at + 1] === null;
        if (N.globals.isXNumeric) {
          var Kt = N.globals.seriesX[d][at + 1];
          N.globals.seriesX[d][at + 1] === void 0 && (Kt = N.globals.seriesX[d][o - 1]), p = (Kt - N.globals.minX) / this.xRatio;
        } else
          p += this.xDivision;
        N.config.chart.stacked ? f > 0 && N.globals.collapsedSeries.length < N.config.series.length - 1 ? I = this.prevSeriesY[function(zn) {
          for (var vt = zn, Br = 0; Br < N.globals.series.length; Br++)
            if (N.globals.collapsedSeriesIndices.indexOf(zn) > -1) {
              vt--;
              break;
            }
          return vt >= 0 ? vt : 0;
        }(f - 1)][at + 1] : I = this.zeroY : I = this.zeroY, Qt ? y = I - Le / Q[this.yaxisIndex] + 2 * (this.isReversed ? Le / Q[this.yaxisIndex] : 0) : (y = I - a[f][at + 1] / Q[this.yaxisIndex] + 2 * (this.isReversed ? a[f][at + 1] / Q[this.yaxisIndex] : 0), n === "rangeArea" && (Ie = I - O[f][at + 1] / Q[this.yaxisIndex] + 2 * (this.isReversed ? O[f][at + 1] / Q[this.yaxisIndex] : 0))), B.push(p), G.push(y), Z.push(Ie);
        var xt = this.lineHelpers.calculatePoints({ series: a, x: p, y, realIndex: d, i: f, j: at, prevY: ee }), On = this._createPaths({ type: n, series: a, i: f, realIndex: d, j: at, x: p, y, y2: Ie, xArrj: B, yArrj: G, y2Arrj: Z, pX: S, pY: C, linePath: oe, areaPath: fe, linePaths: L, areaPaths: M, seriesIndex: P, isRangeStart: b });
        M = On.areaPaths, L = On.linePaths, S = On.pX, C = On.pY, fe = On.areaPath, oe = On.linePath, !this.appendPathFrom || N.config.stroke.curve === "monotoneCubic" && n === "rangeArea" || (ke += X.line(p, this.zeroY), _e += X.line(p, this.zeroY)), this.handleNullDataPoints(a, xt, f, at, d), this._handleMarkersAndLabels({ type: n, pointsPos: xt, i: f, j: at, realIndex: d, isRangeStart: b });
      }
      return { yArrj: G, xArrj: B, pathFromArea: _e, areaPaths: M, pathFromLine: ke, linePaths: L, linePath: oe, areaPath: fe };
    } }, { key: "_handleMarkersAndLabels", value: function(t) {
      var n = t.type, a = t.pointsPos, o = t.isRangeStart, d = t.i, f = t.j, p = t.realIndex, y = this.w, S = new Pt(this.ctx);
      if (this.pointsChart)
        this.scatter.draw(this.elSeries, f, { realIndex: p, pointsPos: a, zRatio: this.zRatio, elParent: this.elPointsMain });
      else {
        y.globals.series[d].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
        var C = this.markers.plotChartMarkers(a, p, f + 1);
        C !== null && this.elPointsMain.add(C);
      }
      var E = S.drawDataLabel({ type: n, isRangeStart: o, pos: a, i: p, j: f + 1 });
      E !== null && this.elDataLabelsWrap.add(E);
    } }, { key: "_createPaths", value: function(t) {
      var n = t.type, a = t.series, o = t.i, d = t.realIndex, f = t.j, p = t.x, y = t.y, S = t.xArrj, C = t.yArrj, E = t.y2, L = t.y2Arrj, M = t.pX, P = t.pY, I = t.linePath, B = t.areaPath, G = t.linePaths, Z = t.areaPaths, b = t.seriesIndex, O = t.isRangeStart, N = this.w, X = new re(this.ctx), Q = N.config.stroke.curve, ee = this.areaBottomY;
      if (Array.isArray(N.config.stroke.curve) && (Q = Array.isArray(b) ? N.config.stroke.curve[b[o]] : N.config.stroke.curve[o]), (n === "rangeArea" && (N.globals.hasNullValues || N.config.forecastDataPoints.count > 0) || N.globals.hasNullValues) && Q === "monotoneCubic" && (Q = "straight"), Q === "smooth") {
        var oe = 0.35 * (p - M);
        N.globals.hasNullValues ? (a[o][f] !== null && (a[o][f + 1] !== null ? (I = X.move(M, P) + X.curve(M + oe, P, p - oe, y, p + 1, y), B = X.move(M + 1, P) + X.curve(M + oe, P, p - oe, y, p + 1, y) + X.line(p, ee) + X.line(M, ee) + "z") : (I = X.move(M, P), B = X.move(M, P) + "z")), G.push(I), Z.push(B)) : (I += X.curve(M + oe, P, p - oe, y, p, y), B += X.curve(M + oe, P, p - oe, y, p, y)), M = p, P = y, f === a[o].length - 2 && (B += X.curve(M, P, p, y, p, ee) + X.move(p, y) + "z", n === "rangeArea" && O ? I += X.curve(M, P, p, y, p, E) + X.move(p, E) + "z" : N.globals.hasNullValues || (G.push(I), Z.push(B)));
      } else if (Q === "monotoneCubic") {
        if (n === "rangeArea" ? S.length === N.globals.dataPoints : f === a[o].length - 2) {
          var fe = S.map(function(Kt, xt) {
            return [S[xt], C[xt]];
          }), ke = Ni(fe);
          if (I += Ma(ke), B += Ma(ke), M = p, P = y, n === "rangeArea" && O) {
            I += X.line(S[S.length - 1], L[L.length - 1]);
            var _e = S.slice().reverse(), Le = L.slice().reverse(), Ie = _e.map(function(Kt, xt) {
              return [_e[xt], Le[xt]];
            }), at = Ni(Ie);
            B = I += Ma(at);
          } else
            B += X.curve(M, P, p, y, p, ee) + X.move(p, y) + "z";
          G.push(I), Z.push(B);
        }
      } else {
        if (a[o][f + 1] === null) {
          I += X.move(p, y);
          var Qt = N.globals.isXNumeric ? (N.globals.seriesX[d][f] - N.globals.minX) / this.xRatio : p - this.xDivision;
          B = B + X.line(Qt, ee) + X.move(p, y) + "z";
        }
        a[o][f] === null && (I += X.move(p, y), B += X.move(p, ee)), Q === "stepline" ? (I = I + X.line(p, null, "H") + X.line(null, y, "V"), B = B + X.line(p, null, "H") + X.line(null, y, "V")) : Q === "straight" && (I += X.line(p, y), B += X.line(p, y)), f === a[o].length - 2 && (B = B + X.line(p, ee) + X.move(p, y) + "z", n === "rangeArea" && O ? I = I + X.line(p, E) + X.move(p, E) + "z" : (G.push(I), Z.push(B)));
      }
      return { linePaths: G, areaPaths: Z, pX: M, pY: P, linePath: I, areaPath: B };
    } }, { key: "handleNullDataPoints", value: function(t, n, a, o, d) {
      var f = this.w;
      if (t[a][o] === null && f.config.markers.showNullDataPoints || t[a].length === 1) {
        var p = this.markers.plotChartMarkers(n, d, o + 1, this.strokeWidth - f.config.markers.strokeWidth / 2, !0);
        p !== null && this.elPointsMain.add(p);
      }
    } }]), W;
  }();
  window.TreemapSquared = {}, window.TreemapSquared.generate = function() {
    function W(p, y, S, C) {
      this.xoffset = p, this.yoffset = y, this.height = C, this.width = S, this.shortestEdge = function() {
        return Math.min(this.height, this.width);
      }, this.getCoordinates = function(E) {
        var L, M = [], P = this.xoffset, I = this.yoffset, B = d(E) / this.height, G = d(E) / this.width;
        if (this.width >= this.height)
          for (L = 0; L < E.length; L++)
            M.push([P, I, P + B, I + E[L] / B]), I += E[L] / B;
        else
          for (L = 0; L < E.length; L++)
            M.push([P, I, P + E[L] / G, I + G]), P += E[L] / G;
        return M;
      }, this.cutArea = function(E) {
        var L;
        if (this.width >= this.height) {
          var M = E / this.height, P = this.width - M;
          L = new W(this.xoffset + M, this.yoffset, P, this.height);
        } else {
          var I = E / this.width, B = this.height - I;
          L = new W(this.xoffset, this.yoffset + I, this.width, B);
        }
        return L;
      };
    }
    function t(p, y, S, C, E) {
      C = C === void 0 ? 0 : C, E = E === void 0 ? 0 : E;
      var L = n(function(M, P) {
        var I, B = [], G = P / d(M);
        for (I = 0; I < M.length; I++)
          B[I] = M[I] * G;
        return B;
      }(p, y * S), [], new W(C, E, y, S), []);
      return function(M) {
        var P, I, B = [];
        for (P = 0; P < M.length; P++)
          for (I = 0; I < M[P].length; I++)
            B.push(M[P][I]);
        return B;
      }(L);
    }
    function n(p, y, S, C) {
      var E, L, M;
      if (p.length !== 0)
        return E = S.shortestEdge(), function(P, I, B) {
          var G;
          if (P.length === 0)
            return !0;
          (G = P.slice()).push(I);
          var Z = a(P, B), b = a(G, B);
          return Z >= b;
        }(y, L = p[0], E) ? (y.push(L), n(p.slice(1), y, S, C)) : (M = S.cutArea(d(y), C), C.push(S.getCoordinates(y)), n(p, [], M, C)), C;
      C.push(S.getCoordinates(y));
    }
    function a(p, y) {
      var S = Math.min.apply(Math, p), C = Math.max.apply(Math, p), E = d(p);
      return Math.max(Math.pow(y, 2) * C / Math.pow(E, 2), Math.pow(E, 2) / (Math.pow(y, 2) * S));
    }
    function o(p) {
      return p && p.constructor === Array;
    }
    function d(p) {
      var y, S = 0;
      for (y = 0; y < p.length; y++)
        S += p[y];
      return S;
    }
    function f(p) {
      var y, S = 0;
      if (o(p[0]))
        for (y = 0; y < p.length; y++)
          S += f(p[y]);
      else
        S = d(p);
      return S;
    }
    return function p(y, S, C, E, L) {
      E = E === void 0 ? 0 : E, L = L === void 0 ? 0 : L;
      var M, P, I = [], B = [];
      if (o(y[0])) {
        for (P = 0; P < y.length; P++)
          I[P] = f(y[P]);
        for (M = t(I, S, C, E, L), P = 0; P < y.length; P++)
          B.push(p(y[P], M[P][2] - M[P][0], M[P][3] - M[P][1], M[P][0], M[P][1]));
      } else
        B = t(y, S, C, E, L);
      return B;
    };
  }();
  var ia, le, Ye = function() {
    function W(t, n) {
      T(this, W), this.ctx = t, this.w = t.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new cs(t), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
    }
    return F(W, [{ key: "draw", value: function(t) {
      var n = this, a = this.w, o = new re(this.ctx), d = new Qe(this.ctx), f = o.group({ class: "apexcharts-treemap" });
      if (a.globals.noData)
        return f;
      var p = [];
      return t.forEach(function(y) {
        var S = y.map(function(C) {
          return Math.abs(C);
        });
        p.push(S);
      }), this.negRange = this.helpers.checkColorRange(), a.config.series.forEach(function(y, S) {
        y.data.forEach(function(C) {
          Array.isArray(n.labels[S]) || (n.labels[S] = []), n.labels[S].push(C.x);
        });
      }), window.TreemapSquared.generate(p, a.globals.gridWidth, a.globals.gridHeight).forEach(function(y, S) {
        var C = o.group({ class: "apexcharts-series apexcharts-treemap-series", seriesName: K.escapeString(a.globals.seriesNames[S]), rel: S + 1, "data:realIndex": S });
        if (a.config.chart.dropShadow.enabled) {
          var E = a.config.chart.dropShadow;
          new Ee(n.ctx).dropShadow(f, E, S);
        }
        var L = o.group({ class: "apexcharts-data-labels" });
        y.forEach(function(M, P) {
          var I = M[0], B = M[1], G = M[2], Z = M[3], b = o.drawRect(I, B, G - I, Z - B, 0, "#fff", 1, n.strokeWidth, a.config.plotOptions.treemap.useFillColorAsStroke ? N : a.globals.stroke.colors[S]);
          b.attr({ cx: I, cy: B, index: S, i: S, j: P, width: G - I, height: Z - B });
          var O = n.helpers.getShadeColor(a.config.chart.type, S, P, n.negRange), N = O.color;
          a.config.series[S].data[P] !== void 0 && a.config.series[S].data[P].fillColor && (N = a.config.series[S].data[P].fillColor);
          var X = d.fillPath({ color: N, seriesNumber: S, dataPointIndex: P });
          b.node.classList.add("apexcharts-treemap-rect"), b.attr({ fill: X }), n.helpers.addListeners(b);
          var Q = { x: I + (G - I) / 2, y: B + (Z - B) / 2, width: 0, height: 0 }, ee = { x: I, y: B, width: G - I, height: Z - B };
          if (a.config.chart.animations.enabled && !a.globals.dataChanged) {
            var oe = 1;
            a.globals.resized || (oe = a.config.chart.animations.speed), n.animateTreemap(b, Q, ee, oe);
          }
          if (a.globals.dataChanged) {
            var fe = 1;
            n.dynamicAnim.enabled && a.globals.shouldAnimate && (fe = n.dynamicAnim.speed, a.globals.previousPaths[S] && a.globals.previousPaths[S][P] && a.globals.previousPaths[S][P].rect && (Q = a.globals.previousPaths[S][P].rect), n.animateTreemap(b, Q, ee, fe));
          }
          var ke = n.getFontSize(M), _e = a.config.dataLabels.formatter(n.labels[S][P], { value: a.globals.series[S][P], seriesIndex: S, dataPointIndex: P, w: a });
          a.config.plotOptions.treemap.dataLabels.format === "truncate" && (ke = parseInt(a.config.dataLabels.style.fontSize, 10), _e = n.truncateLabels(_e, ke, I, B, G, Z));
          var Le = n.helpers.calculateDataLabels({ text: _e, x: (I + G) / 2, y: (B + Z) / 2 + n.strokeWidth / 2 + ke / 3, i: S, j: P, colorProps: O, fontSize: ke, series: t });
          a.config.dataLabels.enabled && Le && n.rotateToFitLabel(Le, ke, _e, I, B, G, Z), C.add(b), Le !== null && C.add(Le);
        }), C.add(L), f.add(C);
      }), f;
    } }, { key: "getFontSize", value: function(t) {
      var n = this.w, a, o, d, f, p = function y(S) {
        var C, E = 0;
        if (Array.isArray(S[0]))
          for (C = 0; C < S.length; C++)
            E += y(S[C]);
        else
          for (C = 0; C < S.length; C++)
            E += S[C].length;
        return E;
      }(this.labels) / function y(S) {
        var C, E = 0;
        if (Array.isArray(S[0]))
          for (C = 0; C < S.length; C++)
            E += y(S[C]);
        else
          for (C = 0; C < S.length; C++)
            E += 1;
        return E;
      }(this.labels);
      return a = t[2] - t[0], o = t[3] - t[1], d = a * o, f = Math.pow(d, 0.5), Math.min(f / p, parseInt(n.config.dataLabels.style.fontSize, 10));
    } }, { key: "rotateToFitLabel", value: function(t, n, a, o, d, f, p) {
      var y = new re(this.ctx), S = y.getTextRects(a, n);
      if (S.width + this.w.config.stroke.width + 5 > f - o && S.width <= p - d) {
        var C = y.rotateAroundCenter(t.node);
        t.node.setAttribute("transform", "rotate(-90 ".concat(C.x, " ").concat(C.y, ") translate(").concat(S.height / 3, ")"));
      }
    } }, { key: "truncateLabels", value: function(t, n, a, o, d, f) {
      var p = new re(this.ctx), y = p.getTextRects(t, n).width + this.w.config.stroke.width + 5 > d - a && f - o > d - a ? f - o : d - a, S = p.getTextBasedOnMaxWidth({ text: t, maxWidth: y, fontSize: n });
      return t.length !== S.length && y / n < 5 ? "" : S;
    } }, { key: "animateTreemap", value: function(t, n, a, o) {
      var d = new we(this.ctx);
      d.animateRect(t, { x: n.x, y: n.y, width: n.width, height: n.height }, { x: a.x, y: a.y, width: a.width, height: a.height }, o, function() {
        d.animationCompleted(t);
      });
    } }]), W;
  }(), tt = 86400, Dt = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
    }
    return F(W, [{ key: "calculateTimeScaleTicks", value: function(t, n) {
      var a = this, o = this.w;
      if (o.globals.allSeriesCollapsed)
        return o.globals.labels = [], o.globals.timescaleLabels = [], [];
      var d = new Ze(this.ctx), f = (n - t) / 864e5;
      this.determineInterval(f), o.globals.disableZoomIn = !1, o.globals.disableZoomOut = !1, f < 11574074074074075e-20 ? o.globals.disableZoomIn = !0 : f > 5e4 && (o.globals.disableZoomOut = !0);
      var p = d.getTimeUnitsfromTimestamp(t, n, this.utc), y = o.globals.gridWidth / f, S = y / 24, C = S / 60, E = C / 60, L = Math.floor(24 * f), M = Math.floor(1440 * f), P = Math.floor(f * tt), I = Math.floor(f), B = Math.floor(f / 30), G = Math.floor(f / 365), Z = { minMillisecond: p.minMillisecond, minSecond: p.minSecond, minMinute: p.minMinute, minHour: p.minHour, minDate: p.minDate, minMonth: p.minMonth, minYear: p.minYear }, b = { firstVal: Z, currentMillisecond: Z.minMillisecond, currentSecond: Z.minSecond, currentMinute: Z.minMinute, currentHour: Z.minHour, currentMonthDate: Z.minDate, currentDate: Z.minDate, currentMonth: Z.minMonth, currentYear: Z.minYear, daysWidthOnXAxis: y, hoursWidthOnXAxis: S, minutesWidthOnXAxis: C, secondsWidthOnXAxis: E, numberOfSeconds: P, numberOfMinutes: M, numberOfHours: L, numberOfDays: I, numberOfMonths: B, numberOfYears: G };
      switch (this.tickInterval) {
        case "years":
          this.generateYearScale(b);
          break;
        case "months":
        case "half_year":
          this.generateMonthScale(b);
          break;
        case "months_days":
        case "months_fortnight":
        case "days":
        case "week_days":
          this.generateDayScale(b);
          break;
        case "hours":
          this.generateHourScale(b);
          break;
        case "minutes_fives":
        case "minutes":
          this.generateMinuteScale(b);
          break;
        case "seconds_tens":
        case "seconds_fives":
        case "seconds":
          this.generateSecondScale(b);
      }
      var O = this.timeScaleArray.map(function(N) {
        var X = { position: N.position, unit: N.unit, year: N.year, day: N.day ? N.day : 1, hour: N.hour ? N.hour : 0, month: N.month + 1 };
        return N.unit === "month" ? m(m({}, X), {}, { day: 1, value: N.value + 1 }) : N.unit === "day" || N.unit === "hour" ? m(m({}, X), {}, { value: N.value }) : N.unit === "minute" ? m(m({}, X), {}, { value: N.value, minute: N.value }) : N.unit === "second" ? m(m({}, X), {}, { value: N.value, minute: N.minute, second: N.second }) : N;
      });
      return O.filter(function(N) {
        var X = 1, Q = Math.ceil(o.globals.gridWidth / 120), ee = N.value;
        o.config.xaxis.tickAmount !== void 0 && (Q = o.config.xaxis.tickAmount), O.length > Q && (X = Math.floor(O.length / Q));
        var oe = !1, fe = !1;
        switch (a.tickInterval) {
          case "years":
            N.unit === "year" && (oe = !0);
            break;
          case "half_year":
            X = 7, N.unit === "year" && (oe = !0);
            break;
          case "months":
            X = 1, N.unit === "year" && (oe = !0);
            break;
          case "months_fortnight":
            X = 15, N.unit !== "year" && N.unit !== "month" || (oe = !0), ee === 30 && (fe = !0);
            break;
          case "months_days":
            X = 10, N.unit === "month" && (oe = !0), ee === 30 && (fe = !0);
            break;
          case "week_days":
            X = 8, N.unit === "month" && (oe = !0);
            break;
          case "days":
            X = 1, N.unit === "month" && (oe = !0);
            break;
          case "hours":
            N.unit === "day" && (oe = !0);
            break;
          case "minutes_fives":
          case "seconds_fives":
            ee % 5 != 0 && (fe = !0);
            break;
          case "seconds_tens":
            ee % 10 != 0 && (fe = !0);
        }
        if (a.tickInterval === "hours" || a.tickInterval === "minutes_fives" || a.tickInterval === "seconds_tens" || a.tickInterval === "seconds_fives") {
          if (!fe)
            return !0;
        } else if ((ee % X == 0 || oe) && !fe)
          return !0;
      });
    } }, { key: "recalcDimensionsBasedOnFormat", value: function(t, n) {
      var a = this.w, o = this.formatDates(t), d = this.removeOverlappingTS(o);
      a.globals.timescaleLabels = d.slice(), new na(this.ctx).plotCoords();
    } }, { key: "determineInterval", value: function(t) {
      var n = 24 * t, a = 60 * n;
      switch (!0) {
        case t / 365 > 5:
          this.tickInterval = "years";
          break;
        case t > 800:
          this.tickInterval = "half_year";
          break;
        case t > 180:
          this.tickInterval = "months";
          break;
        case t > 90:
          this.tickInterval = "months_fortnight";
          break;
        case t > 60:
          this.tickInterval = "months_days";
          break;
        case t > 30:
          this.tickInterval = "week_days";
          break;
        case t > 2:
          this.tickInterval = "days";
          break;
        case n > 2.4:
          this.tickInterval = "hours";
          break;
        case a > 15:
          this.tickInterval = "minutes_fives";
          break;
        case a > 5:
          this.tickInterval = "minutes";
          break;
        case a > 1:
          this.tickInterval = "seconds_tens";
          break;
        case 60 * a > 20:
          this.tickInterval = "seconds_fives";
          break;
        default:
          this.tickInterval = "seconds";
      }
    } }, { key: "generateYearScale", value: function(t) {
      var n = t.firstVal, a = t.currentMonth, o = t.currentYear, d = t.daysWidthOnXAxis, f = t.numberOfYears, p = n.minYear, y = 0, S = new Ze(this.ctx), C = "year";
      if (n.minDate > 1 || n.minMonth > 0) {
        var E = S.determineRemainingDaysOfYear(n.minYear, n.minMonth, n.minDate);
        y = (S.determineDaysOfYear(n.minYear) - E + 1) * d, p = n.minYear + 1, this.timeScaleArray.push({ position: y, value: p, unit: C, year: p, month: K.monthMod(a + 1) });
      } else
        n.minDate === 1 && n.minMonth === 0 && this.timeScaleArray.push({ position: y, value: p, unit: C, year: o, month: K.monthMod(a + 1) });
      for (var L = p, M = y, P = 0; P < f; P++)
        L++, M = S.determineDaysOfYear(L - 1) * d + M, this.timeScaleArray.push({ position: M, value: L, unit: C, year: L, month: 1 });
    } }, { key: "generateMonthScale", value: function(t) {
      var n = t.firstVal, a = t.currentMonthDate, o = t.currentMonth, d = t.currentYear, f = t.daysWidthOnXAxis, p = t.numberOfMonths, y = o, S = 0, C = new Ze(this.ctx), E = "month", L = 0;
      if (n.minDate > 1) {
        S = (C.determineDaysOfMonths(o + 1, n.minYear) - a + 1) * f, y = K.monthMod(o + 1);
        var M = d + L, P = K.monthMod(y), I = y;
        y === 0 && (E = "year", I = M, P = 1, M += L += 1), this.timeScaleArray.push({ position: S, value: I, unit: E, year: M, month: P });
      } else
        this.timeScaleArray.push({ position: S, value: y, unit: E, year: d, month: K.monthMod(o) });
      for (var B = y + 1, G = S, Z = 0, b = 1; Z < p; Z++, b++) {
        (B = K.monthMod(B)) === 0 ? (E = "year", L += 1) : E = "month";
        var O = this._getYear(d, B, L);
        G = C.determineDaysOfMonths(B, O) * f + G;
        var N = B === 0 ? O : B;
        this.timeScaleArray.push({ position: G, value: N, unit: E, year: O, month: B === 0 ? 1 : B }), B++;
      }
    } }, { key: "generateDayScale", value: function(t) {
      var n = t.firstVal, a = t.currentMonth, o = t.currentYear, d = t.hoursWidthOnXAxis, f = t.numberOfDays, p = new Ze(this.ctx), y = "day", S = n.minDate + 1, C = S, E = function(b, O, N) {
        return b > p.determineDaysOfMonths(O + 1, N) && (C = 1, y = "month", M = O += 1), O;
      }, L = (24 - n.minHour) * d, M = S, P = E(C, a, o);
      n.minHour === 0 && n.minDate === 1 ? (L = 0, M = K.monthMod(n.minMonth), y = "month", C = n.minDate, f++) : n.minDate !== 1 && n.minHour === 0 && n.minMinute === 0 && (L = 0, S = n.minDate, M = S, P = E(C = S, a, o)), this.timeScaleArray.push({ position: L, value: M, unit: y, year: this._getYear(o, P, 0), month: K.monthMod(P), day: C });
      for (var I = L, B = 0; B < f; B++) {
        y = "day", P = E(C += 1, P, this._getYear(o, P, 0));
        var G = this._getYear(o, P, 0);
        I = 24 * d + I;
        var Z = C === 1 ? K.monthMod(P) : C;
        this.timeScaleArray.push({ position: I, value: Z, unit: y, year: G, month: K.monthMod(P), day: Z });
      }
    } }, { key: "generateHourScale", value: function(t) {
      var n = t.firstVal, a = t.currentDate, o = t.currentMonth, d = t.currentYear, f = t.minutesWidthOnXAxis, p = t.numberOfHours, y = new Ze(this.ctx), S = "hour", C = function(X, Q) {
        return X > y.determineDaysOfMonths(Q + 1, d) && (B = 1, Q += 1), { month: Q, date: B };
      }, E = function(X, Q) {
        return X > y.determineDaysOfMonths(Q + 1, d) ? Q += 1 : Q;
      }, L = 60 - (n.minMinute + n.minSecond / 60), M = L * f, P = n.minHour + 1, I = P + 1;
      L === 60 && (M = 0, I = (P = n.minHour) + 1);
      var B = a, G = E(B, o);
      this.timeScaleArray.push({ position: M, value: P, unit: S, day: B, hour: I, year: d, month: K.monthMod(G) });
      for (var Z = M, b = 0; b < p; b++) {
        S = "hour", I >= 24 && (I = 0, S = "day", G = C(B += 1, G).month, G = E(B, G));
        var O = this._getYear(d, G, 0);
        Z = 60 * f + Z;
        var N = I === 0 ? B : I;
        this.timeScaleArray.push({ position: Z, value: N, unit: S, hour: I, day: B, year: O, month: K.monthMod(G) }), I++;
      }
    } }, { key: "generateMinuteScale", value: function(t) {
      for (var n = t.currentMillisecond, a = t.currentSecond, o = t.currentMinute, d = t.currentHour, f = t.currentDate, p = t.currentMonth, y = t.currentYear, S = t.minutesWidthOnXAxis, C = t.secondsWidthOnXAxis, E = t.numberOfMinutes, L = o + 1, M = f, P = p, I = y, B = d, G = (60 - a - n / 1e3) * C, Z = 0; Z < E; Z++)
        L >= 60 && (L = 0, (B += 1) === 24 && (B = 0)), this.timeScaleArray.push({ position: G, value: L, unit: "minute", hour: B, minute: L, day: M, year: this._getYear(I, P, 0), month: K.monthMod(P) }), G += S, L++;
    } }, { key: "generateSecondScale", value: function(t) {
      for (var n = t.currentMillisecond, a = t.currentSecond, o = t.currentMinute, d = t.currentHour, f = t.currentDate, p = t.currentMonth, y = t.currentYear, S = t.secondsWidthOnXAxis, C = t.numberOfSeconds, E = a + 1, L = o, M = f, P = p, I = y, B = d, G = (1e3 - n) / 1e3 * S, Z = 0; Z < C; Z++)
        E >= 60 && (E = 0, ++L >= 60 && (L = 0, ++B === 24 && (B = 0))), this.timeScaleArray.push({ position: G, value: E, unit: "second", hour: B, minute: L, second: E, day: M, year: this._getYear(I, P, 0), month: K.monthMod(P) }), G += S, E++;
    } }, { key: "createRawDateString", value: function(t, n) {
      var a = t.year;
      return t.month === 0 && (t.month = 1), a += "-" + ("0" + t.month.toString()).slice(-2), t.unit === "day" ? a += t.unit === "day" ? "-" + ("0" + n).slice(-2) : "-01" : a += "-" + ("0" + (t.day ? t.day : "1")).slice(-2), t.unit === "hour" ? a += t.unit === "hour" ? "T" + ("0" + n).slice(-2) : "T00" : a += "T" + ("0" + (t.hour ? t.hour : "0")).slice(-2), t.unit === "minute" ? a += ":" + ("0" + n).slice(-2) : a += ":" + (t.minute ? ("0" + t.minute).slice(-2) : "00"), t.unit === "second" ? a += ":" + ("0" + n).slice(-2) : a += ":00", this.utc && (a += ".000Z"), a;
    } }, { key: "formatDates", value: function(t) {
      var n = this, a = this.w;
      return t.map(function(o) {
        var d = o.value.toString(), f = new Ze(n.ctx), p = n.createRawDateString(o, d), y = f.getDate(f.parseDate(p));
        if (n.utc || (y = f.getDate(f.parseDateWithTimezone(p))), a.config.xaxis.labels.format === void 0) {
          var S = "dd MMM", C = a.config.xaxis.labels.datetimeFormatter;
          o.unit === "year" && (S = C.year), o.unit === "month" && (S = C.month), o.unit === "day" && (S = C.day), o.unit === "hour" && (S = C.hour), o.unit === "minute" && (S = C.minute), o.unit === "second" && (S = C.second), d = f.formatDate(y, S);
        } else
          d = f.formatDate(y, a.config.xaxis.labels.format);
        return { dateString: p, position: o.position, value: d, unit: o.unit, year: o.year, month: o.month };
      });
    } }, { key: "removeOverlappingTS", value: function(t) {
      var n, a = this, o = new re(this.ctx), d = !1;
      t.length > 0 && t[0].value && t.every(function(y) {
        return y.value.length === t[0].value.length;
      }) && (d = !0, n = o.getTextRects(t[0].value).width);
      var f = 0, p = t.map(function(y, S) {
        if (S > 0 && a.w.config.xaxis.labels.hideOverlappingLabels) {
          var C = d ? n : o.getTextRects(t[f].value).width, E = t[f].position;
          return y.position > E + C + 10 ? (f = S, y) : null;
        }
        return y;
      });
      return p = p.filter(function(y) {
        return y !== null;
      });
    } }, { key: "_getYear", value: function(t, n, a) {
      return t + Math.floor(n / 12) + a;
    } }]), W;
  }(), qt = function() {
    function W(t, n) {
      T(this, W), this.ctx = n, this.w = n.w, this.el = t;
    }
    return F(W, [{ key: "setupElements", value: function() {
      var t = this.w.globals, n = this.w.config, a = n.chart.type;
      t.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(a) > -1, t.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(a) > -1, t.isBarHorizontal = (n.chart.type === "bar" || n.chart.type === "rangeBar" || n.chart.type === "boxPlot") && n.plotOptions.bar.horizontal, t.chartClass = ".apexcharts" + t.chartID, t.dom.baseEl = this.el, t.dom.elWrap = document.createElement("div"), re.setAttrs(t.dom.elWrap, { id: t.chartClass.substring(1), class: "apexcharts-canvas " + t.chartClass.substring(1) }), this.el.appendChild(t.dom.elWrap), t.dom.Paper = new window.SVG.Doc(t.dom.elWrap), t.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(n.chart.offsetX, ", ").concat(n.chart.offsetY, ")") }), t.dom.Paper.node.style.background = n.chart.background, this.setSVGDimensions(), t.dom.elLegendForeign = document.createElementNS(t.SVGNS, "foreignObject"), re.setAttrs(t.dom.elLegendForeign, { x: 0, y: 0, width: t.svgWidth, height: t.svgHeight }), t.dom.elLegendWrap = document.createElement("div"), t.dom.elLegendWrap.classList.add("apexcharts-legend"), t.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), t.dom.elLegendForeign.appendChild(t.dom.elLegendWrap), t.dom.Paper.node.appendChild(t.dom.elLegendForeign), t.dom.elGraphical = t.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), t.dom.elDefs = t.dom.Paper.defs(), t.dom.Paper.add(t.dom.elGraphical), t.dom.elGraphical.add(t.dom.elDefs);
    } }, { key: "plotChartType", value: function(t, n) {
      var a = this.w, o = a.config, d = a.globals, f = { series: [], i: [] }, p = { series: [], i: [] }, y = { series: [], i: [] }, S = { series: [], i: [] }, C = { series: [], i: [] }, E = { series: [], i: [] }, L = { series: [], i: [] }, M = { series: [], i: [] }, P = { series: [], seriesRangeEnd: [], i: [] };
      d.series.map(function(Q, ee) {
        var oe = 0;
        t[ee].type !== void 0 ? (t[ee].type === "column" || t[ee].type === "bar" ? (d.series.length > 1 && o.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"), C.series.push(Q), C.i.push(ee), oe++, a.globals.columnSeries = C.series) : t[ee].type === "area" ? (p.series.push(Q), p.i.push(ee), oe++) : t[ee].type === "line" ? (f.series.push(Q), f.i.push(ee), oe++) : t[ee].type === "scatter" ? (y.series.push(Q), y.i.push(ee)) : t[ee].type === "bubble" ? (S.series.push(Q), S.i.push(ee), oe++) : t[ee].type === "candlestick" ? (E.series.push(Q), E.i.push(ee), oe++) : t[ee].type === "boxPlot" ? (L.series.push(Q), L.i.push(ee), oe++) : t[ee].type === "rangeBar" ? (M.series.push(Q), M.i.push(ee), oe++) : t[ee].type === "rangeArea" ? (P.series.push(d.seriesRangeStart[ee]), P.seriesRangeEnd.push(d.seriesRangeEnd[ee]), P.i.push(ee), oe++) : console.warn("You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble/candlestick/boxPlot/rangeBar/rangeArea"), oe > 1 && (d.comboCharts = !0)) : (f.series.push(Q), f.i.push(ee));
      });
      var I = new ba(this.ctx, n), B = new Cn(this.ctx, n);
      this.ctx.pie = new Vs(this.ctx);
      var G = new hs(this.ctx);
      this.ctx.rangeBar = new Gs(this.ctx, n);
      var Z = new Ol(this.ctx), b = [];
      if (d.comboCharts) {
        if (p.series.length > 0 && b.push(I.draw(p.series, "area", p.i)), C.series.length > 0)
          if (a.config.chart.stacked) {
            var O = new kn(this.ctx, n);
            b.push(O.draw(C.series, C.i));
          } else
            this.ctx.bar = new yr(this.ctx, n), b.push(this.ctx.bar.draw(C.series, C.i));
        if (P.series.length > 0 && b.push(I.draw(P.series, "rangeArea", P.i, P.seriesRangeEnd)), f.series.length > 0 && b.push(I.draw(f.series, "line", f.i)), E.series.length > 0 && b.push(B.draw(E.series, "candlestick", E.i)), L.series.length > 0 && b.push(B.draw(L.series, "boxPlot", L.i)), M.series.length > 0 && b.push(this.ctx.rangeBar.draw(M.series, M.i)), y.series.length > 0) {
          var N = new ba(this.ctx, n, !0);
          b.push(N.draw(y.series, "scatter", y.i));
        }
        if (S.series.length > 0) {
          var X = new ba(this.ctx, n, !0);
          b.push(X.draw(S.series, "bubble", S.i));
        }
      } else
        switch (o.chart.type) {
          case "line":
            b = I.draw(d.series, "line");
            break;
          case "area":
            b = I.draw(d.series, "area");
            break;
          case "bar":
            o.chart.stacked ? b = new kn(this.ctx, n).draw(d.series) : (this.ctx.bar = new yr(this.ctx, n), b = this.ctx.bar.draw(d.series));
            break;
          case "candlestick":
            b = new Cn(this.ctx, n).draw(d.series, "candlestick");
            break;
          case "boxPlot":
            b = new Cn(this.ctx, n).draw(d.series, o.chart.type);
            break;
          case "rangeBar":
            b = this.ctx.rangeBar.draw(d.series);
            break;
          case "rangeArea":
            b = I.draw(d.seriesRangeStart, "rangeArea", void 0, d.seriesRangeEnd);
            break;
          case "heatmap":
            b = new ds(this.ctx, n).draw(d.series);
            break;
          case "treemap":
            b = new Ye(this.ctx, n).draw(d.series);
            break;
          case "pie":
          case "donut":
          case "polarArea":
            b = this.ctx.pie.draw(d.series);
            break;
          case "radialBar":
            b = G.draw(d.series);
            break;
          case "radar":
            b = Z.draw(d.series);
            break;
          default:
            b = I.draw(d.series);
        }
      return b;
    } }, { key: "setSVGDimensions", value: function() {
      var t = this.w.globals, n = this.w.config;
      t.svgWidth = n.chart.width, t.svgHeight = n.chart.height;
      var a = K.getDimensions(this.el), o = n.chart.width.toString().split(/[0-9]+/g).pop();
      o === "%" ? K.isNumber(a[0]) && (a[0].width === 0 && (a = K.getDimensions(this.el.parentNode)), t.svgWidth = a[0] * parseInt(n.chart.width, 10) / 100) : o !== "px" && o !== "" || (t.svgWidth = parseInt(n.chart.width, 10));
      var d = n.chart.height.toString().split(/[0-9]+/g).pop();
      if (t.svgHeight !== "auto" && t.svgHeight !== "")
        if (d === "%") {
          var f = K.getDimensions(this.el.parentNode);
          t.svgHeight = f[1] * parseInt(n.chart.height, 10) / 100;
        } else
          t.svgHeight = parseInt(n.chart.height, 10);
      else
        t.axisCharts ? t.svgHeight = t.svgWidth / 1.61 : t.svgHeight = t.svgWidth / 1.2;
      if (t.svgWidth < 0 && (t.svgWidth = 0), t.svgHeight < 0 && (t.svgHeight = 0), re.setAttrs(t.dom.Paper.node, { width: t.svgWidth, height: t.svgHeight }), d !== "%") {
        var p = n.chart.sparkline.enabled ? 0 : t.axisCharts ? n.chart.parentHeightOffset : 0;
        t.dom.Paper.node.parentNode.parentNode.style.minHeight = t.svgHeight + p + "px";
      }
      t.dom.elWrap.style.width = t.svgWidth + "px", t.dom.elWrap.style.height = t.svgHeight + "px";
    } }, { key: "shiftGraphPosition", value: function() {
      var t = this.w.globals, n = t.translateY, a = { transform: "translate(" + t.translateX + ", " + n + ")" };
      re.setAttrs(t.dom.elGraphical.node, a);
    } }, { key: "resizeNonAxisCharts", value: function() {
      var t = this.w, n = t.globals, a = 0, o = t.config.chart.sparkline.enabled ? 1 : 15;
      o += t.config.grid.padding.bottom, t.config.legend.position !== "top" && t.config.legend.position !== "bottom" || !t.config.legend.show || t.config.legend.floating || (a = new ra(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
      var d = t.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), f = 2.05 * t.globals.radialSize;
      if (d && !t.config.chart.sparkline.enabled && t.config.plotOptions.radialBar.startAngle !== 0) {
        var p = K.getBoundingClientRect(d);
        f = p.bottom;
        var y = p.bottom - p.top;
        f = Math.max(2.05 * t.globals.radialSize, y);
      }
      var S = f + n.translateY + a + o;
      n.dom.elLegendForeign && n.dom.elLegendForeign.setAttribute("height", S), t.config.chart.height && String(t.config.chart.height).indexOf("%") > 0 || (n.dom.elWrap.style.height = S + "px", re.setAttrs(n.dom.Paper.node, { height: S }), n.dom.Paper.node.parentNode.parentNode.style.minHeight = S + "px");
    } }, { key: "coreCalculations", value: function() {
      new pn(this.ctx).init();
    } }, { key: "resetGlobals", value: function() {
      var t = this, n = function() {
        return t.w.config.series.map(function(d) {
          return [];
        });
      }, a = new ye(), o = this.w.globals;
      a.initGlobalVars(o), o.seriesXvalues = n(), o.seriesYvalues = n();
    } }, { key: "isMultipleY", value: function() {
      if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1)
        return this.w.globals.isMultipleYAxis = !0, !0;
    } }, { key: "xySettings", value: function() {
      var t = null, n = this.w;
      if (n.globals.axisCharts) {
        if (n.config.xaxis.crosshairs.position === "back" && new ta(this.ctx).drawXCrosshairs(), n.config.yaxis[0].crosshairs.position === "back" && new ta(this.ctx).drawYCrosshairs(), n.config.xaxis.type === "datetime" && n.config.xaxis.labels.formatter === void 0) {
          this.ctx.timeScale = new Dt(this.ctx);
          var a = [];
          isFinite(n.globals.minX) && isFinite(n.globals.maxX) && !n.globals.isBarHorizontal ? a = this.ctx.timeScale.calculateTimeScaleTicks(n.globals.minX, n.globals.maxX) : n.globals.isBarHorizontal && (a = this.ctx.timeScale.calculateTimeScaleTicks(n.globals.minY, n.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(a);
        }
        t = new me(this.ctx).getCalculatedRatios();
      }
      return t;
    } }, { key: "updateSourceChart", value: function(t) {
      this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: t.w.globals.minX, max: t.w.globals.maxX } } } }, !1, !1);
    } }, { key: "setupBrushHandler", value: function() {
      var t = this, n = this.w;
      if (n.config.chart.brush.enabled && typeof n.config.chart.events.selection != "function") {
        var a = Array.isArray(n.config.chart.brush.targets) || [n.config.chart.brush.target];
        a.forEach(function(o) {
          var d = ApexCharts.getChartByID(o);
          d.w.globals.brushSource = t.ctx, typeof d.w.config.chart.events.zoomed != "function" && (d.w.config.chart.events.zoomed = function() {
            t.updateSourceChart(d);
          }), typeof d.w.config.chart.events.scrolled != "function" && (d.w.config.chart.events.scrolled = function() {
            t.updateSourceChart(d);
          });
        }), n.config.chart.events.selection = function(o, d) {
          a.forEach(function(f) {
            var p = ApexCharts.getChartByID(f), y = K.clone(n.config.yaxis);
            if (n.config.chart.brush.autoScaleYaxis && p.w.globals.series.length === 1) {
              var S = new qe(p);
              y = S.autoScaleY(p, y, d);
            }
            var C = p.w.config.yaxis.reduce(function(E, L, M) {
              return [].concat(ue(E), [m(m({}, p.w.config.yaxis[M]), {}, { min: y[0].min, max: y[0].max })]);
            }, []);
            p.ctx.updateHelpers._updateOptions({ xaxis: { min: d.xaxis.min, max: d.xaxis.max }, yaxis: C }, !1, !1, !1, !1);
          });
        };
      }
    } }]), W;
  }(), cn = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "_updateOptions", value: function(t) {
      var n = this, a = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], o = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], d = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], f = arguments.length > 4 && arguments[4] !== void 0 && arguments[4];
      return new Promise(function(p) {
        var y = [n.ctx];
        d && (y = n.ctx.getSyncedCharts()), n.ctx.w.globals.isExecCalled && (y = [n.ctx], n.ctx.w.globals.isExecCalled = !1), y.forEach(function(S, C) {
          var E = S.w;
          if (E.globals.shouldAnimate = o, a || (E.globals.resized = !0, E.globals.dataChanged = !0, o && S.series.getPreviousPaths()), t && w(t) === "object" && (S.config = new pt(t), t = me.extendArrayProps(S.config, t, E), S.w.globals.chartID !== n.ctx.w.globals.chartID && delete t.series, E.config = K.extend(E.config, t), f && (E.globals.lastXAxis = t.xaxis ? K.clone(t.xaxis) : [], E.globals.lastYAxis = t.yaxis ? K.clone(t.yaxis) : [], E.globals.initialConfig = K.extend({}, E.config), E.globals.initialSeries = K.clone(E.config.series), t.series))) {
            for (var L = 0; L < E.globals.collapsedSeriesIndices.length; L++) {
              var M = E.config.series[E.globals.collapsedSeriesIndices[L]];
              E.globals.collapsedSeries[L].data = E.globals.axisCharts ? M.data.slice() : M;
            }
            for (var P = 0; P < E.globals.ancillaryCollapsedSeriesIndices.length; P++) {
              var I = E.config.series[E.globals.ancillaryCollapsedSeriesIndices[P]];
              E.globals.ancillaryCollapsedSeries[P].data = E.globals.axisCharts ? I.data.slice() : I;
            }
            S.series.emptyCollapsedSeries(E.config.series);
          }
          return S.update(t).then(function() {
            C === y.length - 1 && p(S);
          });
        });
      });
    } }, { key: "_updateSeries", value: function(t, n) {
      var a = this, o = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
      return new Promise(function(d) {
        var f, p = a.w;
        return p.globals.shouldAnimate = n, p.globals.dataChanged = !0, n && a.ctx.series.getPreviousPaths(), p.globals.axisCharts ? ((f = t.map(function(y, S) {
          return a._extendSeries(y, S);
        })).length === 0 && (f = [{ data: [] }]), p.config.series = f) : p.config.series = t.slice(), o && (p.globals.initialConfig.series = K.clone(p.config.series), p.globals.initialSeries = K.clone(p.config.series)), a.ctx.update().then(function() {
          d(a.ctx);
        });
      });
    } }, { key: "_extendSeries", value: function(t, n) {
      var a = this.w, o = a.config.series[n];
      return m(m({}, a.config.series[n]), {}, { name: t.name ? t.name : o && o.name, color: t.color ? t.color : o && o.color, type: t.type ? t.type : o && o.type, group: t.group ? t.group : o && o.group, data: t.data ? t.data : o && o.data });
    } }, { key: "toggleDataPointSelection", value: function(t, n) {
      var a = this.w, o = null, d = ".apexcharts-series[data\\:realIndex='".concat(t, "']");
      return a.globals.axisCharts ? o = a.globals.dom.Paper.select("".concat(d, " path[j='").concat(n, "'], ").concat(d, " circle[j='").concat(n, "'], ").concat(d, " rect[j='").concat(n, "']")).members[0] : n === void 0 && (o = a.globals.dom.Paper.select("".concat(d, " path[j='").concat(t, "']")).members[0], a.config.chart.type !== "pie" && a.config.chart.type !== "polarArea" && a.config.chart.type !== "donut" || this.ctx.pie.pieClicked(t)), o ? (new re(this.ctx).pathMouseDown(o, null), o.node ? o.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
    } }, { key: "forceXAxisUpdate", value: function(t) {
      var n = this.w;
      if (["min", "max"].forEach(function(o) {
        t.xaxis[o] !== void 0 && (n.config.xaxis[o] = t.xaxis[o], n.globals.lastXAxis[o] = t.xaxis[o]);
      }), t.xaxis.categories && t.xaxis.categories.length && (n.config.xaxis.categories = t.xaxis.categories), n.config.xaxis.convertedCatToNumeric) {
        var a = new We(t);
        t = a.convertCatToNumericXaxis(t, this.ctx);
      }
      return t;
    } }, { key: "forceYAxisUpdate", value: function(t) {
      return t.chart && t.chart.stacked && t.chart.stackType === "100%" && (Array.isArray(t.yaxis) ? t.yaxis.forEach(function(n, a) {
        t.yaxis[a].min = 0, t.yaxis[a].max = 100;
      }) : (t.yaxis.min = 0, t.yaxis.max = 100)), t;
    } }, { key: "revertDefaultAxisMinMax", value: function(t) {
      var n = this, a = this.w, o = a.globals.lastXAxis, d = a.globals.lastYAxis;
      t && t.xaxis && (o = t.xaxis), t && t.yaxis && (d = t.yaxis), a.config.xaxis.min = o.min, a.config.xaxis.max = o.max;
      var f = function(p) {
        d[p] !== void 0 && (a.config.yaxis[p].min = d[p].min, a.config.yaxis[p].max = d[p].max);
      };
      a.config.yaxis.map(function(p, y) {
        a.globals.zoomed || d[y] !== void 0 ? f(y) : n.ctx.opts.yaxis[y] !== void 0 && (p.min = n.ctx.opts.yaxis[y].min, p.max = n.ctx.opts.yaxis[y].max);
      });
    } }]), W;
  }();
  ia = typeof window < "u" ? window : void 0, le = function(W, t) {
    var n = (this !== void 0 ? this : W).SVG = function(b) {
      if (n.supported)
        return b = new n.Doc(b), n.parser.draw || n.prepare(), b;
    };
    if (n.ns = "http://www.w3.org/2000/svg", n.xmlns = "http://www.w3.org/2000/xmlns/", n.xlink = "http://www.w3.org/1999/xlink", n.svgjs = "http://svgjs.dev", n.supported = !0, !n.supported)
      return !1;
    n.did = 1e3, n.eid = function(b) {
      return "Svgjs" + C(b) + n.did++;
    }, n.create = function(b) {
      var O = t.createElementNS(this.ns, b);
      return O.setAttribute("id", this.eid(b)), O;
    }, n.extend = function() {
      var b, O;
      O = (b = [].slice.call(arguments)).pop();
      for (var N = b.length - 1; N >= 0; N--)
        if (b[N])
          for (var X in O)
            b[N].prototype[X] = O[X];
      n.Set && n.Set.inherit && n.Set.inherit();
    }, n.invent = function(b) {
      var O = typeof b.create == "function" ? b.create : function() {
        this.constructor.call(this, n.create(b.create));
      };
      return b.inherit && (O.prototype = new b.inherit()), b.extend && n.extend(O, b.extend), b.construct && n.extend(b.parent || n.Container, b.construct), O;
    }, n.adopt = function(b) {
      return b ? b.instance ? b.instance : ((O = b.nodeName == "svg" ? b.parentNode instanceof W.SVGElement ? new n.Nested() : new n.Doc() : b.nodeName == "linearGradient" ? new n.Gradient("linear") : b.nodeName == "radialGradient" ? new n.Gradient("radial") : n[C(b.nodeName)] ? new n[C(b.nodeName)]() : new n.Element(b)).type = b.nodeName, O.node = b, b.instance = O, O instanceof n.Doc && O.namespace().defs(), O.setData(JSON.parse(b.getAttribute("svgjs:data")) || {}), O) : null;
      var O;
    }, n.prepare = function() {
      var b = t.getElementsByTagName("body")[0], O = (b ? new n.Doc(b) : n.adopt(t.documentElement).nested()).size(2, 0);
      n.parser = { body: b || t.documentElement, draw: O.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node, poly: O.polyline().node, path: O.path().node, native: n.create("svg") };
    }, n.parser = { native: n.create("svg") }, t.addEventListener("DOMContentLoaded", function() {
      n.parser.draw || n.prepare();
    }, !1), n.regex = { numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, rgb: /rgb\((\d+),(\d+),(\d+)\)/, reference: /#([a-z0-9\-_]+)/i, transforms: /\)\s*,?\s*/, whitespace: /\s/g, isHex: /^#[a-f0-9]{3,6}$/i, isRgb: /^rgb\(/, isCss: /[^:]+:[^;]+;?/, isBlank: /^(\s+)?$/, isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, isPercent: /^-?[\d\.]+%$/, isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, delimiter: /[\s,]+/, hyphen: /([^e])\-/gi, pathLetters: /[MLHVCSQTAZ]/gi, isPathLetter: /[MLHVCSQTAZ]/i, numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi, dots: /\./g }, n.utils = { map: function(b, O) {
      for (var N = b.length, X = [], Q = 0; Q < N; Q++)
        X.push(O(b[Q]));
      return X;
    }, filter: function(b, O) {
      for (var N = b.length, X = [], Q = 0; Q < N; Q++)
        O(b[Q]) && X.push(b[Q]);
      return X;
    }, filterSVGElements: function(b) {
      return this.filter(b, function(O) {
        return O instanceof W.SVGElement;
      });
    } }, n.defaults = { attrs: { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "font-size": 16, "font-family": "Helvetica, Arial, sans-serif", "text-anchor": "start" } }, n.Color = function(b) {
      var O, N;
      this.r = 0, this.g = 0, this.b = 0, b && (typeof b == "string" ? n.regex.isRgb.test(b) ? (O = n.regex.rgb.exec(b.replace(n.regex.whitespace, "")), this.r = parseInt(O[1]), this.g = parseInt(O[2]), this.b = parseInt(O[3])) : n.regex.isHex.test(b) && (O = n.regex.hex.exec((N = b).length == 4 ? ["#", N.substring(1, 2), N.substring(1, 2), N.substring(2, 3), N.substring(2, 3), N.substring(3, 4), N.substring(3, 4)].join("") : N), this.r = parseInt(O[1], 16), this.g = parseInt(O[2], 16), this.b = parseInt(O[3], 16)) : w(b) === "object" && (this.r = b.r, this.g = b.g, this.b = b.b));
    }, n.extend(n.Color, { toString: function() {
      return this.toHex();
    }, toHex: function() {
      return "#" + E(this.r) + E(this.g) + E(this.b);
    }, toRgb: function() {
      return "rgb(" + [this.r, this.g, this.b].join() + ")";
    }, brightness: function() {
      return this.r / 255 * 0.3 + this.g / 255 * 0.59 + this.b / 255 * 0.11;
    }, morph: function(b) {
      return this.destination = new n.Color(b), this;
    }, at: function(b) {
      return this.destination ? (b = b < 0 ? 0 : b > 1 ? 1 : b, new n.Color({ r: ~~(this.r + (this.destination.r - this.r) * b), g: ~~(this.g + (this.destination.g - this.g) * b), b: ~~(this.b + (this.destination.b - this.b) * b) })) : this;
    } }), n.Color.test = function(b) {
      return b += "", n.regex.isHex.test(b) || n.regex.isRgb.test(b);
    }, n.Color.isRgb = function(b) {
      return b && typeof b.r == "number" && typeof b.g == "number" && typeof b.b == "number";
    }, n.Color.isColor = function(b) {
      return n.Color.isRgb(b) || n.Color.test(b);
    }, n.Array = function(b, O) {
      (b = (b || []).valueOf()).length == 0 && O && (b = O.valueOf()), this.value = this.parse(b);
    }, n.extend(n.Array, { toString: function() {
      return this.value.join(" ");
    }, valueOf: function() {
      return this.value;
    }, parse: function(b) {
      return b = b.valueOf(), Array.isArray(b) ? b : this.split(b);
    } }), n.PointArray = function(b, O) {
      n.Array.call(this, b, O || [[0, 0]]);
    }, n.PointArray.prototype = new n.Array(), n.PointArray.prototype.constructor = n.PointArray;
    for (var a = { M: function(b, O, N) {
      return O.x = N.x = b[0], O.y = N.y = b[1], ["M", O.x, O.y];
    }, L: function(b, O) {
      return O.x = b[0], O.y = b[1], ["L", b[0], b[1]];
    }, H: function(b, O) {
      return O.x = b[0], ["H", b[0]];
    }, V: function(b, O) {
      return O.y = b[0], ["V", b[0]];
    }, C: function(b, O) {
      return O.x = b[4], O.y = b[5], ["C", b[0], b[1], b[2], b[3], b[4], b[5]];
    }, Q: function(b, O) {
      return O.x = b[2], O.y = b[3], ["Q", b[0], b[1], b[2], b[3]];
    }, S: function(b, O) {
      return O.x = b[2], O.y = b[3], ["S", b[0], b[1], b[2], b[3]];
    }, Z: function(b, O, N) {
      return O.x = N.x, O.y = N.y, ["Z"];
    } }, o = "mlhvqtcsaz".split(""), d = 0, f = o.length; d < f; ++d)
      a[o[d]] = function(b) {
        return function(O, N, X) {
          if (b == "H")
            O[0] = O[0] + N.x;
          else if (b == "V")
            O[0] = O[0] + N.y;
          else if (b == "A")
            O[5] = O[5] + N.x, O[6] = O[6] + N.y;
          else
            for (var Q = 0, ee = O.length; Q < ee; ++Q)
              O[Q] = O[Q] + (Q % 2 ? N.y : N.x);
          if (a && typeof a[b] == "function")
            return a[b](O, N, X);
        };
      }(o[d].toUpperCase());
    n.PathArray = function(b, O) {
      n.Array.call(this, b, O || [["M", 0, 0]]);
    }, n.PathArray.prototype = new n.Array(), n.PathArray.prototype.constructor = n.PathArray, n.extend(n.PathArray, { toString: function() {
      return function(b) {
        for (var O = 0, N = b.length, X = ""; O < N; O++)
          X += b[O][0], b[O][1] != null && (X += b[O][1], b[O][2] != null && (X += " ", X += b[O][2], b[O][3] != null && (X += " ", X += b[O][3], X += " ", X += b[O][4], b[O][5] != null && (X += " ", X += b[O][5], X += " ", X += b[O][6], b[O][7] != null && (X += " ", X += b[O][7])))));
        return X + " ";
      }(this.value);
    }, move: function(b, O) {
      var N = this.bbox();
      return N.x, N.y, this;
    }, at: function(b) {
      if (!this.destination)
        return this;
      for (var O = this.value, N = this.destination.value, X = [], Q = new n.PathArray(), ee = 0, oe = O.length; ee < oe; ee++) {
        X[ee] = [O[ee][0]];
        for (var fe = 1, ke = O[ee].length; fe < ke; fe++)
          X[ee][fe] = O[ee][fe] + (N[ee][fe] - O[ee][fe]) * b;
        X[ee][0] === "A" && (X[ee][4] = +(X[ee][4] != 0), X[ee][5] = +(X[ee][5] != 0));
      }
      return Q.value = X, Q;
    }, parse: function(b) {
      if (b instanceof n.PathArray)
        return b.valueOf();
      var O, N = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };
      b = typeof b == "string" ? b.replace(n.regex.numbersWithDots, y).replace(n.regex.pathLetters, " $& ").replace(n.regex.hyphen, "$1 -").trim().split(n.regex.delimiter) : b.reduce(function(ke, _e) {
        return [].concat.call(ke, _e);
      }, []);
      var X = [], Q = new n.Point(), ee = new n.Point(), oe = 0, fe = b.length;
      do
        n.regex.isPathLetter.test(b[oe]) ? (O = b[oe], ++oe) : O == "M" ? O = "L" : O == "m" && (O = "l"), X.push(a[O].call(null, b.slice(oe, oe += N[O.toUpperCase()]).map(parseFloat), Q, ee));
      while (fe > oe);
      return X;
    }, bbox: function() {
      return n.parser.draw || n.prepare(), n.parser.path.setAttribute("d", this.toString()), n.parser.path.getBBox();
    } }), n.Number = n.invent({ create: function(b, O) {
      this.value = 0, this.unit = O || "", typeof b == "number" ? this.value = isNaN(b) ? 0 : isFinite(b) ? b : b < 0 ? -34e37 : 34e37 : typeof b == "string" ? (O = b.match(n.regex.numberAndUnit)) && (this.value = parseFloat(O[1]), O[5] == "%" ? this.value /= 100 : O[5] == "s" && (this.value *= 1e3), this.unit = O[5]) : b instanceof n.Number && (this.value = b.valueOf(), this.unit = b.unit);
    }, extend: { toString: function() {
      return (this.unit == "%" ? ~~(1e8 * this.value) / 1e6 : this.unit == "s" ? this.value / 1e3 : this.value) + this.unit;
    }, toJSON: function() {
      return this.toString();
    }, valueOf: function() {
      return this.value;
    }, plus: function(b) {
      return b = new n.Number(b), new n.Number(this + b, this.unit || b.unit);
    }, minus: function(b) {
      return b = new n.Number(b), new n.Number(this - b, this.unit || b.unit);
    }, times: function(b) {
      return b = new n.Number(b), new n.Number(this * b, this.unit || b.unit);
    }, divide: function(b) {
      return b = new n.Number(b), new n.Number(this / b, this.unit || b.unit);
    }, to: function(b) {
      var O = new n.Number(this);
      return typeof b == "string" && (O.unit = b), O;
    }, morph: function(b) {
      return this.destination = new n.Number(b), b.relative && (this.destination.value += this.value), this;
    }, at: function(b) {
      return this.destination ? new n.Number(this.destination).minus(this).times(b).plus(this) : this;
    } } }), n.Element = n.invent({ create: function(b) {
      this._stroke = n.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = b) && (this.type = b.nodeName, this.node.instance = this, this._stroke = b.getAttribute("stroke") || this._stroke);
    }, extend: { x: function(b) {
      return this.attr("x", b);
    }, y: function(b) {
      return this.attr("y", b);
    }, cx: function(b) {
      return b == null ? this.x() + this.width() / 2 : this.x(b - this.width() / 2);
    }, cy: function(b) {
      return b == null ? this.y() + this.height() / 2 : this.y(b - this.height() / 2);
    }, move: function(b, O) {
      return this.x(b).y(O);
    }, center: function(b, O) {
      return this.cx(b).cy(O);
    }, width: function(b) {
      return this.attr("width", b);
    }, height: function(b) {
      return this.attr("height", b);
    }, size: function(b, O) {
      var N = L(this, b, O);
      return this.width(new n.Number(N.width)).height(new n.Number(N.height));
    }, clone: function(b) {
      this.writeDataToDom();
      var O = I(this.node.cloneNode(!0));
      return b ? b.add(O) : this.after(O), O;
    }, remove: function() {
      return this.parent() && this.parent().removeElement(this), this;
    }, replace: function(b) {
      return this.after(b).remove(), b;
    }, addTo: function(b) {
      return b.put(this);
    }, putIn: function(b) {
      return b.add(this);
    }, id: function(b) {
      return this.attr("id", b);
    }, show: function() {
      return this.style("display", "");
    }, hide: function() {
      return this.style("display", "none");
    }, visible: function() {
      return this.style("display") != "none";
    }, toString: function() {
      return this.attr("id");
    }, classes: function() {
      var b = this.attr("class");
      return b == null ? [] : b.trim().split(n.regex.delimiter);
    }, hasClass: function(b) {
      return this.classes().indexOf(b) != -1;
    }, addClass: function(b) {
      if (!this.hasClass(b)) {
        var O = this.classes();
        O.push(b), this.attr("class", O.join(" "));
      }
      return this;
    }, removeClass: function(b) {
      return this.hasClass(b) && this.attr("class", this.classes().filter(function(O) {
        return O != b;
      }).join(" ")), this;
    }, toggleClass: function(b) {
      return this.hasClass(b) ? this.removeClass(b) : this.addClass(b);
    }, reference: function(b) {
      return n.get(this.attr(b));
    }, parent: function(b) {
      var O = this;
      if (!O.node.parentNode)
        return null;
      if (O = n.adopt(O.node.parentNode), !b)
        return O;
      for (; O && O.node instanceof W.SVGElement; ) {
        if (typeof b == "string" ? O.matches(b) : O instanceof b)
          return O;
        if (!O.node.parentNode || O.node.parentNode.nodeName == "#document")
          return null;
        O = n.adopt(O.node.parentNode);
      }
    }, doc: function() {
      return this instanceof n.Doc ? this : this.parent(n.Doc);
    }, parents: function(b) {
      var O = [], N = this;
      do {
        if (!(N = N.parent(b)) || !N.node)
          break;
        O.push(N);
      } while (N.parent);
      return O;
    }, matches: function(b) {
      return function(O, N) {
        return (O.matches || O.matchesSelector || O.msMatchesSelector || O.mozMatchesSelector || O.webkitMatchesSelector || O.oMatchesSelector).call(O, N);
      }(this.node, b);
    }, native: function() {
      return this.node;
    }, svg: function(b) {
      var O = t.createElement("svg");
      if (!(b && this instanceof n.Parent))
        return O.appendChild(b = t.createElement("svg")), this.writeDataToDom(), b.appendChild(this.node.cloneNode(!0)), O.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
      O.innerHTML = "<svg>" + b.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
      for (var N = 0, X = O.firstChild.childNodes.length; N < X; N++)
        this.node.appendChild(O.firstChild.firstChild);
      return this;
    }, writeDataToDom: function() {
      return (this.each || this.lines) && (this.each ? this : this.lines()).each(function() {
        this.writeDataToDom();
      }), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this;
    }, setData: function(b) {
      return this.dom = b, this;
    }, is: function(b) {
      return function(O, N) {
        return O instanceof N;
      }(this, b);
    } } }), n.easing = { "-": function(b) {
      return b;
    }, "<>": function(b) {
      return -Math.cos(b * Math.PI) / 2 + 0.5;
    }, ">": function(b) {
      return Math.sin(b * Math.PI / 2);
    }, "<": function(b) {
      return 1 - Math.cos(b * Math.PI / 2);
    } }, n.morph = function(b) {
      return function(O, N) {
        return new n.MorphObj(O, N).at(b);
      };
    }, n.Situation = n.invent({ create: function(b) {
      this.init = !1, this.reversed = !1, this.reversing = !1, this.duration = new n.Number(b.duration).valueOf(), this.delay = new n.Number(b.delay).valueOf(), this.start = +/* @__PURE__ */ new Date() + this.delay, this.finish = this.start + this.duration, this.ease = b.ease, this.loop = 0, this.loops = !1, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {};
    } }), n.FX = n.invent({ create: function(b) {
      this._target = b, this.situations = [], this.active = !1, this.situation = null, this.paused = !1, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1;
    }, extend: { animate: function(b, O, N) {
      w(b) === "object" && (O = b.ease, N = b.delay, b = b.duration);
      var X = new n.Situation({ duration: b || 1e3, delay: N || 0, ease: n.easing[O || "-"] || O });
      return this.queue(X), this;
    }, target: function(b) {
      return b && b instanceof n.Element ? (this._target = b, this) : this._target;
    }, timeToAbsPos: function(b) {
      return (b - this.situation.start) / (this.situation.duration / this._speed);
    }, absPosToTime: function(b) {
      return this.situation.duration / this._speed * b + this.situation.start;
    }, startAnimFrame: function() {
      this.stopAnimFrame(), this.animationFrame = W.requestAnimationFrame((function() {
        this.step();
      }).bind(this));
    }, stopAnimFrame: function() {
      W.cancelAnimationFrame(this.animationFrame);
    }, start: function() {
      return !this.active && this.situation && (this.active = !0, this.startCurrent()), this;
    }, startCurrent: function() {
      return this.situation.start = +/* @__PURE__ */ new Date() + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step();
    }, queue: function(b) {
      return (typeof b == "function" || b instanceof n.Situation) && this.situations.push(b), this.situation || (this.situation = this.situations.shift()), this;
    }, dequeue: function() {
      return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof n.Situation ? this.start() : this.situation.call(this)), this;
    }, initAnimations: function() {
      var b, O = this.situation;
      if (O.init)
        return this;
      for (var N in O.animations) {
        b = this.target()[N](), Array.isArray(b) || (b = [b]), Array.isArray(O.animations[N]) || (O.animations[N] = [O.animations[N]]);
        for (var X = b.length; X--; )
          O.animations[N][X] instanceof n.Number && (b[X] = new n.Number(b[X])), O.animations[N][X] = b[X].morph(O.animations[N][X]);
      }
      for (var N in O.attrs)
        O.attrs[N] = new n.MorphObj(this.target().attr(N), O.attrs[N]);
      for (var N in O.styles)
        O.styles[N] = new n.MorphObj(this.target().style(N), O.styles[N]);
      return O.initialTransformation = this.target().matrixify(), O.init = !0, this;
    }, clearQueue: function() {
      return this.situations = [], this;
    }, clearCurrent: function() {
      return this.situation = null, this;
    }, stop: function(b, O) {
      var N = this.active;
      return this.active = !1, O && this.clearQueue(), b && this.situation && (!N && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent();
    }, after: function(b) {
      var O = this.last();
      return this.target().on("finished.fx", function N(X) {
        X.detail.situation == O && (b.call(this, O), this.off("finished.fx", N));
      }), this._callStart();
    }, during: function(b) {
      var O = this.last(), N = function(X) {
        X.detail.situation == O && b.call(this, X.detail.pos, n.morph(X.detail.pos), X.detail.eased, O);
      };
      return this.target().off("during.fx", N).on("during.fx", N), this.after(function() {
        this.off("during.fx", N);
      }), this._callStart();
    }, afterAll: function(b) {
      var O = function N(X) {
        b.call(this), this.off("allfinished.fx", N);
      };
      return this.target().off("allfinished.fx", O).on("allfinished.fx", O), this._callStart();
    }, last: function() {
      return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
    }, add: function(b, O, N) {
      return this.last()[N || "animations"][b] = O, this._callStart();
    }, step: function(b) {
      var O, N, X;
      b || (this.absPos = this.timeToAbsPos(+/* @__PURE__ */ new Date())), this.situation.loops !== !1 ? (O = Math.max(this.absPos, 0), N = Math.floor(O), this.situation.loops === !0 || N < this.situation.loops ? (this.pos = O - N, X = this.situation.loop, this.situation.loop = N) : (this.absPos = this.situation.loops, this.pos = 1, X = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != !!((this.situation.loop - X) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
      var Q = this.situation.ease(this.pos);
      for (var ee in this.situation.once)
        ee > this.lastPos && ee <= Q && (this.situation.once[ee].call(this.target(), this.pos, Q), delete this.situation.once[ee]);
      return this.active && this.target().fire("during", { pos: this.pos, eased: Q, fx: this, situation: this.situation }), this.situation ? (this.eachAt(), this.pos == 1 && !this.situation.reversed || this.situation.reversed && this.pos == 0 ? (this.stopAnimFrame(), this.target().fire("finished", { fx: this, situation: this.situation }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = !1)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = Q, this) : this;
    }, eachAt: function() {
      var b, O = this, N = this.target(), X = this.situation;
      for (var Q in X.animations)
        b = [].concat(X.animations[Q]).map(function(fe) {
          return typeof fe != "string" && fe.at ? fe.at(X.ease(O.pos), O.pos) : fe;
        }), N[Q].apply(N, b);
      for (var Q in X.attrs)
        b = [Q].concat(X.attrs[Q]).map(function(ke) {
          return typeof ke != "string" && ke.at ? ke.at(X.ease(O.pos), O.pos) : ke;
        }), N.attr.apply(N, b);
      for (var Q in X.styles)
        b = [Q].concat(X.styles[Q]).map(function(ke) {
          return typeof ke != "string" && ke.at ? ke.at(X.ease(O.pos), O.pos) : ke;
        }), N.style.apply(N, b);
      if (X.transforms.length) {
        b = X.initialTransformation, Q = 0;
        for (var ee = X.transforms.length; Q < ee; Q++) {
          var oe = X.transforms[Q];
          oe instanceof n.Matrix ? b = oe.relative ? b.multiply(new n.Matrix().morph(oe).at(X.ease(this.pos))) : b.morph(oe).at(X.ease(this.pos)) : (oe.relative || oe.undo(b.extract()), b = b.multiply(oe.at(X.ease(this.pos))));
        }
        N.matrix(b);
      }
      return this;
    }, once: function(b, O, N) {
      var X = this.last();
      return N || (b = X.ease(b)), X.once[b] = O, this;
    }, _callStart: function() {
      return setTimeout((function() {
        this.start();
      }).bind(this), 0), this;
    } }, parent: n.Element, construct: { animate: function(b, O, N) {
      return (this.fx || (this.fx = new n.FX(this))).animate(b, O, N);
    }, delay: function(b) {
      return (this.fx || (this.fx = new n.FX(this))).delay(b);
    }, stop: function(b, O) {
      return this.fx && this.fx.stop(b, O), this;
    }, finish: function() {
      return this.fx && this.fx.finish(), this;
    } } }), n.MorphObj = n.invent({ create: function(b, O) {
      return n.Color.isColor(O) ? new n.Color(b).morph(O) : n.regex.delimiter.test(b) ? n.regex.pathLetters.test(b) ? new n.PathArray(b).morph(O) : new n.Array(b).morph(O) : n.regex.numberAndUnit.test(O) ? new n.Number(b).morph(O) : (this.value = b, void (this.destination = O));
    }, extend: { at: function(b, O) {
      return O < 1 ? this.value : this.destination;
    }, valueOf: function() {
      return this.value;
    } } }), n.extend(n.FX, { attr: function(b, O, N) {
      if (w(b) === "object")
        for (var X in b)
          this.attr(X, b[X]);
      else
        this.add(b, O, "attrs");
      return this;
    }, plot: function(b, O, N, X) {
      return arguments.length == 4 ? this.plot([b, O, N, X]) : this.add("plot", new (this.target()).morphArray(b));
    } }), n.Box = n.invent({ create: function(b, O, N, X) {
      if (!(w(b) !== "object" || b instanceof n.Element))
        return n.Box.call(this, b.left != null ? b.left : b.x, b.top != null ? b.top : b.y, b.width, b.height);
      var Q;
      arguments.length == 4 && (this.x = b, this.y = O, this.width = N, this.height = X), (Q = this).x == null && (Q.x = 0, Q.y = 0, Q.width = 0, Q.height = 0), Q.w = Q.width, Q.h = Q.height, Q.x2 = Q.x + Q.width, Q.y2 = Q.y + Q.height, Q.cx = Q.x + Q.width / 2, Q.cy = Q.y + Q.height / 2;
    } }), n.BBox = n.invent({ create: function(b) {
      if (n.Box.apply(this, [].slice.call(arguments)), b instanceof n.Element) {
        var O;
        try {
          if (!t.documentElement.contains) {
            for (var N = b.node; N.parentNode; )
              N = N.parentNode;
            if (N != t)
              throw new Error("Element not in the dom");
          }
          O = b.node.getBBox();
        } catch {
          if (b instanceof n.Shape) {
            n.parser.draw || n.prepare();
            var X = b.clone(n.parser.draw.instance).show();
            X && X.node && typeof X.node.getBBox == "function" && (O = X.node.getBBox()), X && typeof X.remove == "function" && X.remove();
          } else
            O = { x: b.node.clientLeft, y: b.node.clientTop, width: b.node.clientWidth, height: b.node.clientHeight };
        }
        n.Box.call(this, O);
      }
    }, inherit: n.Box, parent: n.Element, construct: { bbox: function() {
      return new n.BBox(this);
    } } }), n.BBox.prototype.constructor = n.BBox, n.Matrix = n.invent({ create: function(b) {
      var O = P([1, 0, 0, 1, 0, 0]);
      b = b === null ? O : b instanceof n.Element ? b.matrixify() : typeof b == "string" ? P(b.split(n.regex.delimiter).map(parseFloat)) : arguments.length == 6 ? P([].slice.call(arguments)) : Array.isArray(b) ? P(b) : b && w(b) === "object" ? b : O;
      for (var N = G.length - 1; N >= 0; --N)
        this[G[N]] = b[G[N]] != null ? b[G[N]] : O[G[N]];
    }, extend: { extract: function() {
      var b = M(this, 0, 1);
      M(this, 1, 0);
      var O = 180 / Math.PI * Math.atan2(b.y, b.x) - 90;
      return { x: this.e, y: this.f, transformedX: (this.e * Math.cos(O * Math.PI / 180) + this.f * Math.sin(O * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b), transformedY: (this.f * Math.cos(O * Math.PI / 180) + this.e * Math.sin(-O * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d), rotation: O, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f, matrix: new n.Matrix(this) };
    }, clone: function() {
      return new n.Matrix(this);
    }, morph: function(b) {
      return this.destination = new n.Matrix(b), this;
    }, multiply: function(b) {
      return new n.Matrix(this.native().multiply(function(O) {
        return O instanceof n.Matrix || (O = new n.Matrix(O)), O;
      }(b).native()));
    }, inverse: function() {
      return new n.Matrix(this.native().inverse());
    }, translate: function(b, O) {
      return new n.Matrix(this.native().translate(b || 0, O || 0));
    }, native: function() {
      for (var b = n.parser.native.createSVGMatrix(), O = G.length - 1; O >= 0; O--)
        b[G[O]] = this[G[O]];
      return b;
    }, toString: function() {
      return "matrix(" + B(this.a) + "," + B(this.b) + "," + B(this.c) + "," + B(this.d) + "," + B(this.e) + "," + B(this.f) + ")";
    } }, parent: n.Element, construct: { ctm: function() {
      return new n.Matrix(this.node.getCTM());
    }, screenCTM: function() {
      if (this instanceof n.Nested) {
        var b = this.rect(1, 1), O = b.node.getScreenCTM();
        return b.remove(), new n.Matrix(O);
      }
      return new n.Matrix(this.node.getScreenCTM());
    } } }), n.Point = n.invent({ create: function(b, O) {
      var N;
      N = Array.isArray(b) ? { x: b[0], y: b[1] } : w(b) === "object" ? { x: b.x, y: b.y } : b != null ? { x: b, y: O ?? b } : { x: 0, y: 0 }, this.x = N.x, this.y = N.y;
    }, extend: { clone: function() {
      return new n.Point(this);
    }, morph: function(b, O) {
      return this.destination = new n.Point(b, O), this;
    } } }), n.extend(n.Element, { point: function(b, O) {
      return new n.Point(b, O).transform(this.screenCTM().inverse());
    } }), n.extend(n.Element, { attr: function(b, O, N) {
      if (b == null) {
        for (b = {}, N = (O = this.node.attributes).length - 1; N >= 0; N--)
          b[O[N].nodeName] = n.regex.isNumber.test(O[N].nodeValue) ? parseFloat(O[N].nodeValue) : O[N].nodeValue;
        return b;
      }
      if (w(b) === "object")
        for (var X in b)
          this.attr(X, b[X]);
      else if (O === null)
        this.node.removeAttribute(b);
      else {
        if (O == null)
          return (O = this.node.getAttribute(b)) == null ? n.defaults.attrs[b] : n.regex.isNumber.test(O) ? parseFloat(O) : O;
        b == "stroke-width" ? this.attr("stroke", parseFloat(O) > 0 ? this._stroke : null) : b == "stroke" && (this._stroke = O), b != "fill" && b != "stroke" || (n.regex.isImage.test(O) && (O = this.doc().defs().image(O, 0, 0)), O instanceof n.Image && (O = this.doc().defs().pattern(0, 0, function() {
          this.add(O);
        }))), typeof O == "number" ? O = new n.Number(O) : n.Color.isColor(O) ? O = new n.Color(O) : Array.isArray(O) && (O = new n.Array(O)), b == "leading" ? this.leading && this.leading(O) : typeof N == "string" ? this.node.setAttributeNS(N, b, O.toString()) : this.node.setAttribute(b, O.toString()), !this.rebuild || b != "font-size" && b != "x" || this.rebuild(b, O);
      }
      return this;
    } }), n.extend(n.Element, { transform: function(b, O) {
      var N;
      return w(b) !== "object" ? (N = new n.Matrix(this).extract(), typeof b == "string" ? N[b] : N) : (N = new n.Matrix(this), O = !!O || !!b.relative, b.a != null && (N = O ? N.multiply(new n.Matrix(b)) : new n.Matrix(b)), this.attr("transform", N));
    } }), n.extend(n.Element, { untransform: function() {
      return this.attr("transform", null);
    }, matrixify: function() {
      return (this.attr("transform") || "").split(n.regex.transforms).slice(0, -1).map(function(b) {
        var O = b.trim().split("(");
        return [O[0], O[1].split(n.regex.delimiter).map(function(N) {
          return parseFloat(N);
        })];
      }).reduce(function(b, O) {
        return O[0] == "matrix" ? b.multiply(P(O[1])) : b[O[0]].apply(b, O[1]);
      }, new n.Matrix());
    }, toParent: function(b) {
      if (this == b)
        return this;
      var O = this.screenCTM(), N = b.screenCTM().inverse();
      return this.addTo(b).untransform().transform(N.multiply(O)), this;
    }, toDoc: function() {
      return this.toParent(this.doc());
    } }), n.Transformation = n.invent({ create: function(b, O) {
      if (arguments.length > 1 && typeof O != "boolean")
        return this.constructor.call(this, [].slice.call(arguments));
      if (Array.isArray(b))
        for (var N = 0, X = this.arguments.length; N < X; ++N)
          this[this.arguments[N]] = b[N];
      else if (b && w(b) === "object")
        for (N = 0, X = this.arguments.length; N < X; ++N)
          this[this.arguments[N]] = b[this.arguments[N]];
      this.inversed = !1, O === !0 && (this.inversed = !0);
    } }), n.Translate = n.invent({ parent: n.Matrix, inherit: n.Transformation, create: function(b, O) {
      this.constructor.apply(this, [].slice.call(arguments));
    }, extend: { arguments: ["transformedX", "transformedY"], method: "translate" } }), n.extend(n.Element, { style: function(b, O) {
      if (arguments.length == 0)
        return this.node.style.cssText || "";
      if (arguments.length < 2)
        if (w(b) === "object")
          for (var N in b)
            this.style(N, b[N]);
        else {
          if (!n.regex.isCss.test(b))
            return this.node.style[S(b)];
          for (b = b.split(/\s*;\s*/).filter(function(X) {
            return !!X;
          }).map(function(X) {
            return X.split(/\s*:\s*/);
          }); O = b.pop(); )
            this.style(O[0], O[1]);
        }
      else
        this.node.style[S(b)] = O === null || n.regex.isBlank.test(O) ? "" : O;
      return this;
    } }), n.Parent = n.invent({ create: function(b) {
      this.constructor.call(this, b);
    }, inherit: n.Element, extend: { children: function() {
      return n.utils.map(n.utils.filterSVGElements(this.node.childNodes), function(b) {
        return n.adopt(b);
      });
    }, add: function(b, O) {
      return O == null ? this.node.appendChild(b.node) : b.node != this.node.childNodes[O] && this.node.insertBefore(b.node, this.node.childNodes[O]), this;
    }, put: function(b, O) {
      return this.add(b, O), b;
    }, has: function(b) {
      return this.index(b) >= 0;
    }, index: function(b) {
      return [].slice.call(this.node.childNodes).indexOf(b.node);
    }, get: function(b) {
      return n.adopt(this.node.childNodes[b]);
    }, first: function() {
      return this.get(0);
    }, last: function() {
      return this.get(this.node.childNodes.length - 1);
    }, each: function(b, O) {
      for (var N = this.children(), X = 0, Q = N.length; X < Q; X++)
        N[X] instanceof n.Element && b.apply(N[X], [X, N]), O && N[X] instanceof n.Container && N[X].each(b, O);
      return this;
    }, removeElement: function(b) {
      return this.node.removeChild(b.node), this;
    }, clear: function() {
      for (; this.node.hasChildNodes(); )
        this.node.removeChild(this.node.lastChild);
      return delete this._defs, this;
    }, defs: function() {
      return this.doc().defs();
    } } }), n.extend(n.Parent, { ungroup: function(b, O) {
      return O === 0 || this instanceof n.Defs || this.node == n.parser.draw || (b = b || (this instanceof n.Doc ? this : this.parent(n.Parent)), O = O || 1 / 0, this.each(function() {
        return this instanceof n.Defs ? this : this instanceof n.Parent ? this.ungroup(b, O - 1) : this.toParent(b);
      }), this.node.firstChild || this.remove()), this;
    }, flatten: function(b, O) {
      return this.ungroup(b, O);
    } }), n.Container = n.invent({ create: function(b) {
      this.constructor.call(this, b);
    }, inherit: n.Parent }), n.ViewBox = n.invent({ parent: n.Container, construct: {} }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function(b) {
      n.Element.prototype[b] = function(O) {
        return n.on(this.node, b, O), this;
      };
    }), n.listeners = [], n.handlerMap = [], n.listenerId = 0, n.on = function(b, O, N, X, Q) {
      var ee = N.bind(X || b.instance || b), oe = (n.handlerMap.indexOf(b) + 1 || n.handlerMap.push(b)) - 1, fe = O.split(".")[0], ke = O.split(".")[1] || "*";
      n.listeners[oe] = n.listeners[oe] || {}, n.listeners[oe][fe] = n.listeners[oe][fe] || {}, n.listeners[oe][fe][ke] = n.listeners[oe][fe][ke] || {}, N._svgjsListenerId || (N._svgjsListenerId = ++n.listenerId), n.listeners[oe][fe][ke][N._svgjsListenerId] = ee, b.addEventListener(fe, ee, Q || { passive: !0 });
    }, n.off = function(b, O, N) {
      var X = n.handlerMap.indexOf(b), Q = O && O.split(".")[0], ee = O && O.split(".")[1], oe = "";
      if (X != -1)
        if (N) {
          if (typeof N == "function" && (N = N._svgjsListenerId), !N)
            return;
          n.listeners[X][Q] && n.listeners[X][Q][ee || "*"] && (b.removeEventListener(Q, n.listeners[X][Q][ee || "*"][N], !1), delete n.listeners[X][Q][ee || "*"][N]);
        } else if (ee && Q) {
          if (n.listeners[X][Q] && n.listeners[X][Q][ee]) {
            for (var fe in n.listeners[X][Q][ee])
              n.off(b, [Q, ee].join("."), fe);
            delete n.listeners[X][Q][ee];
          }
        } else if (ee)
          for (var ke in n.listeners[X])
            for (var oe in n.listeners[X][ke])
              ee === oe && n.off(b, [ke, ee].join("."));
        else if (Q) {
          if (n.listeners[X][Q]) {
            for (var oe in n.listeners[X][Q])
              n.off(b, [Q, oe].join("."));
            delete n.listeners[X][Q];
          }
        } else {
          for (var ke in n.listeners[X])
            n.off(b, ke);
          delete n.listeners[X], delete n.handlerMap[X];
        }
    }, n.extend(n.Element, { on: function(b, O, N, X) {
      return n.on(this.node, b, O, N, X), this;
    }, off: function(b, O) {
      return n.off(this.node, b, O), this;
    }, fire: function(b, O) {
      return b instanceof W.Event ? this.node.dispatchEvent(b) : this.node.dispatchEvent(b = new n.CustomEvent(b, { detail: O, cancelable: !0 })), this._event = b, this;
    }, event: function() {
      return this._event;
    } }), n.Defs = n.invent({ create: "defs", inherit: n.Container }), n.G = n.invent({ create: "g", inherit: n.Container, extend: { x: function(b) {
      return b == null ? this.transform("x") : this.transform({ x: b - this.x() }, !0);
    } }, construct: { group: function() {
      return this.put(new n.G());
    } } }), n.Doc = n.invent({ create: function(b) {
      b && ((b = typeof b == "string" ? t.getElementById(b) : b).nodeName == "svg" ? this.constructor.call(this, b) : (this.constructor.call(this, n.create("svg")), b.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs());
    }, inherit: n.Container, extend: { namespace: function() {
      return this.attr({ xmlns: n.ns, version: "1.1" }).attr("xmlns:xlink", n.xlink, n.xmlns).attr("xmlns:svgjs", n.svgjs, n.xmlns);
    }, defs: function() {
      var b;
      return this._defs || ((b = this.node.getElementsByTagName("defs")[0]) ? this._defs = n.adopt(b) : this._defs = new n.Defs(), this.node.appendChild(this._defs.node)), this._defs;
    }, parent: function() {
      return this.node.parentNode && this.node.parentNode.nodeName != "#document" ? this.node.parentNode : null;
    }, remove: function() {
      return this.parent() && this.parent().removeChild(this.node), this;
    }, clear: function() {
      for (; this.node.hasChildNodes(); )
        this.node.removeChild(this.node.lastChild);
      return delete this._defs, n.parser.draw && !n.parser.draw.parentNode && this.node.appendChild(n.parser.draw), this;
    }, clone: function(b) {
      this.writeDataToDom();
      var O = this.node, N = I(O.cloneNode(!0));
      return b ? (b.node || b).appendChild(N.node) : O.parentNode.insertBefore(N.node, O.nextSibling), N;
    } } }), n.extend(n.Element, {}), n.Gradient = n.invent({ create: function(b) {
      this.constructor.call(this, n.create(b + "Gradient")), this.type = b;
    }, inherit: n.Container, extend: { at: function(b, O, N) {
      return this.put(new n.Stop()).update(b, O, N);
    }, update: function(b) {
      return this.clear(), typeof b == "function" && b.call(this, this), this;
    }, fill: function() {
      return "url(#" + this.id() + ")";
    }, toString: function() {
      return this.fill();
    }, attr: function(b, O, N) {
      return b == "transform" && (b = "gradientTransform"), n.Container.prototype.attr.call(this, b, O, N);
    } }, construct: { gradient: function(b, O) {
      return this.defs().gradient(b, O);
    } } }), n.extend(n.Gradient, n.FX, { from: function(b, O) {
      return (this._target || this).type == "radial" ? this.attr({ fx: new n.Number(b), fy: new n.Number(O) }) : this.attr({ x1: new n.Number(b), y1: new n.Number(O) });
    }, to: function(b, O) {
      return (this._target || this).type == "radial" ? this.attr({ cx: new n.Number(b), cy: new n.Number(O) }) : this.attr({ x2: new n.Number(b), y2: new n.Number(O) });
    } }), n.extend(n.Defs, { gradient: function(b, O) {
      return this.put(new n.Gradient(b)).update(O);
    } }), n.Stop = n.invent({ create: "stop", inherit: n.Element, extend: { update: function(b) {
      return (typeof b == "number" || b instanceof n.Number) && (b = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), b.opacity != null && this.attr("stop-opacity", b.opacity), b.color != null && this.attr("stop-color", b.color), b.offset != null && this.attr("offset", new n.Number(b.offset)), this;
    } } }), n.Pattern = n.invent({ create: "pattern", inherit: n.Container, extend: { fill: function() {
      return "url(#" + this.id() + ")";
    }, update: function(b) {
      return this.clear(), typeof b == "function" && b.call(this, this), this;
    }, toString: function() {
      return this.fill();
    }, attr: function(b, O, N) {
      return b == "transform" && (b = "patternTransform"), n.Container.prototype.attr.call(this, b, O, N);
    } }, construct: { pattern: function(b, O, N) {
      return this.defs().pattern(b, O, N);
    } } }), n.extend(n.Defs, { pattern: function(b, O, N) {
      return this.put(new n.Pattern()).update(N).attr({ x: 0, y: 0, width: b, height: O, patternUnits: "userSpaceOnUse" });
    } }), n.Shape = n.invent({ create: function(b) {
      this.constructor.call(this, b);
    }, inherit: n.Element }), n.Symbol = n.invent({ create: "symbol", inherit: n.Container, construct: { symbol: function() {
      return this.put(new n.Symbol());
    } } }), n.Use = n.invent({ create: "use", inherit: n.Shape, extend: { element: function(b, O) {
      return this.attr("href", (O || "") + "#" + b, n.xlink);
    } }, construct: { use: function(b, O) {
      return this.put(new n.Use()).element(b, O);
    } } }), n.Rect = n.invent({ create: "rect", inherit: n.Shape, construct: { rect: function(b, O) {
      return this.put(new n.Rect()).size(b, O);
    } } }), n.Circle = n.invent({ create: "circle", inherit: n.Shape, construct: { circle: function(b) {
      return this.put(new n.Circle()).rx(new n.Number(b).divide(2)).move(0, 0);
    } } }), n.extend(n.Circle, n.FX, { rx: function(b) {
      return this.attr("r", b);
    }, ry: function(b) {
      return this.rx(b);
    } }), n.Ellipse = n.invent({ create: "ellipse", inherit: n.Shape, construct: { ellipse: function(b, O) {
      return this.put(new n.Ellipse()).size(b, O).move(0, 0);
    } } }), n.extend(n.Ellipse, n.Rect, n.FX, { rx: function(b) {
      return this.attr("rx", b);
    }, ry: function(b) {
      return this.attr("ry", b);
    } }), n.extend(n.Circle, n.Ellipse, { x: function(b) {
      return b == null ? this.cx() - this.rx() : this.cx(b + this.rx());
    }, y: function(b) {
      return b == null ? this.cy() - this.ry() : this.cy(b + this.ry());
    }, cx: function(b) {
      return b == null ? this.attr("cx") : this.attr("cx", b);
    }, cy: function(b) {
      return b == null ? this.attr("cy") : this.attr("cy", b);
    }, width: function(b) {
      return b == null ? 2 * this.rx() : this.rx(new n.Number(b).divide(2));
    }, height: function(b) {
      return b == null ? 2 * this.ry() : this.ry(new n.Number(b).divide(2));
    }, size: function(b, O) {
      var N = L(this, b, O);
      return this.rx(new n.Number(N.width).divide(2)).ry(new n.Number(N.height).divide(2));
    } }), n.Line = n.invent({ create: "line", inherit: n.Shape, extend: { array: function() {
      return new n.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
    }, plot: function(b, O, N, X) {
      return b == null ? this.array() : (b = O !== void 0 ? { x1: b, y1: O, x2: N, y2: X } : new n.PointArray(b).toLine(), this.attr(b));
    }, move: function(b, O) {
      return this.attr(this.array().move(b, O).toLine());
    }, size: function(b, O) {
      var N = L(this, b, O);
      return this.attr(this.array().size(N.width, N.height).toLine());
    } }, construct: { line: function(b, O, N, X) {
      return n.Line.prototype.plot.apply(this.put(new n.Line()), b != null ? [b, O, N, X] : [0, 0, 0, 0]);
    } } }), n.Polyline = n.invent({ create: "polyline", inherit: n.Shape, construct: { polyline: function(b) {
      return this.put(new n.Polyline()).plot(b || new n.PointArray());
    } } }), n.Polygon = n.invent({ create: "polygon", inherit: n.Shape, construct: { polygon: function(b) {
      return this.put(new n.Polygon()).plot(b || new n.PointArray());
    } } }), n.extend(n.Polyline, n.Polygon, { array: function() {
      return this._array || (this._array = new n.PointArray(this.attr("points")));
    }, plot: function(b) {
      return b == null ? this.array() : this.clear().attr("points", typeof b == "string" ? b : this._array = new n.PointArray(b));
    }, clear: function() {
      return delete this._array, this;
    }, move: function(b, O) {
      return this.attr("points", this.array().move(b, O));
    }, size: function(b, O) {
      var N = L(this, b, O);
      return this.attr("points", this.array().size(N.width, N.height));
    } }), n.extend(n.Line, n.Polyline, n.Polygon, { morphArray: n.PointArray, x: function(b) {
      return b == null ? this.bbox().x : this.move(b, this.bbox().y);
    }, y: function(b) {
      return b == null ? this.bbox().y : this.move(this.bbox().x, b);
    }, width: function(b) {
      var O = this.bbox();
      return b == null ? O.width : this.size(b, O.height);
    }, height: function(b) {
      var O = this.bbox();
      return b == null ? O.height : this.size(O.width, b);
    } }), n.Path = n.invent({ create: "path", inherit: n.Shape, extend: { morphArray: n.PathArray, array: function() {
      return this._array || (this._array = new n.PathArray(this.attr("d")));
    }, plot: function(b) {
      return b == null ? this.array() : this.clear().attr("d", typeof b == "string" ? b : this._array = new n.PathArray(b));
    }, clear: function() {
      return delete this._array, this;
    } }, construct: { path: function(b) {
      return this.put(new n.Path()).plot(b || new n.PathArray());
    } } }), n.Image = n.invent({ create: "image", inherit: n.Shape, extend: { load: function(b) {
      if (!b)
        return this;
      var O = this, N = new W.Image();
      return n.on(N, "load", function() {
        n.off(N);
        var X = O.parent(n.Pattern);
        X !== null && (O.width() == 0 && O.height() == 0 && O.size(N.width, N.height), X && X.width() == 0 && X.height() == 0 && X.size(O.width(), O.height()), typeof O._loaded == "function" && O._loaded.call(O, { width: N.width, height: N.height, ratio: N.width / N.height, url: b }));
      }), n.on(N, "error", function(X) {
        n.off(N), typeof O._error == "function" && O._error.call(O, X);
      }), this.attr("href", N.src = this.src = b, n.xlink);
    }, loaded: function(b) {
      return this._loaded = b, this;
    }, error: function(b) {
      return this._error = b, this;
    } }, construct: { image: function(b, O, N) {
      return this.put(new n.Image()).load(b).size(O || 0, N || O || 0);
    } } }), n.Text = n.invent({ create: function() {
      this.constructor.call(this, n.create("text")), this.dom.leading = new n.Number(1.3), this._rebuild = !0, this._build = !1, this.attr("font-family", n.defaults.attrs["font-family"]);
    }, inherit: n.Shape, extend: { x: function(b) {
      return b == null ? this.attr("x") : this.attr("x", b);
    }, text: function(b) {
      if (b === void 0) {
        b = "";
        for (var O = this.node.childNodes, N = 0, X = O.length; N < X; ++N)
          N != 0 && O[N].nodeType != 3 && n.adopt(O[N]).dom.newLined == 1 && (b += `
`), b += O[N].textContent;
        return b;
      }
      if (this.clear().build(!0), typeof b == "function")
        b.call(this, this);
      else {
        N = 0;
        for (var Q = (b = b.split(`
`)).length; N < Q; N++)
          this.tspan(b[N]).newLine();
      }
      return this.build(!1).rebuild();
    }, size: function(b) {
      return this.attr("font-size", b).rebuild();
    }, leading: function(b) {
      return b == null ? this.dom.leading : (this.dom.leading = new n.Number(b), this.rebuild());
    }, lines: function() {
      var b = (this.textPath && this.textPath() || this).node, O = n.utils.map(n.utils.filterSVGElements(b.childNodes), function(N) {
        return n.adopt(N);
      });
      return new n.Set(O);
    }, rebuild: function(b) {
      if (typeof b == "boolean" && (this._rebuild = b), this._rebuild) {
        var O = this, N = 0, X = this.dom.leading * new n.Number(this.attr("font-size"));
        this.lines().each(function() {
          this.dom.newLined && (O.textPath() || this.attr("x", O.attr("x")), this.text() == `
` ? N += X : (this.attr("dy", X + N), N = 0));
        }), this.fire("rebuild");
      }
      return this;
    }, build: function(b) {
      return this._build = !!b, this;
    }, setData: function(b) {
      return this.dom = b, this.dom.leading = new n.Number(b.leading || 1.3), this;
    } }, construct: { text: function(b) {
      return this.put(new n.Text()).text(b);
    }, plain: function(b) {
      return this.put(new n.Text()).plain(b);
    } } }), n.Tspan = n.invent({ create: "tspan", inherit: n.Shape, extend: { text: function(b) {
      return b == null ? this.node.textContent + (this.dom.newLined ? `
` : "") : (typeof b == "function" ? b.call(this, this) : this.plain(b), this);
    }, dx: function(b) {
      return this.attr("dx", b);
    }, dy: function(b) {
      return this.attr("dy", b);
    }, newLine: function() {
      var b = this.parent(n.Text);
      return this.dom.newLined = !0, this.dy(b.dom.leading * b.attr("font-size")).attr("x", b.x());
    } } }), n.extend(n.Text, n.Tspan, { plain: function(b) {
      return this._build === !1 && this.clear(), this.node.appendChild(t.createTextNode(b)), this;
    }, tspan: function(b) {
      var O = (this.textPath && this.textPath() || this).node, N = new n.Tspan();
      return this._build === !1 && this.clear(), O.appendChild(N.node), N.text(b);
    }, clear: function() {
      for (var b = (this.textPath && this.textPath() || this).node; b.hasChildNodes(); )
        b.removeChild(b.lastChild);
      return this;
    }, length: function() {
      return this.node.getComputedTextLength();
    } }), n.TextPath = n.invent({ create: "textPath", inherit: n.Parent, parent: n.Text, construct: { morphArray: n.PathArray, array: function() {
      var b = this.track();
      return b ? b.array() : null;
    }, plot: function(b) {
      var O = this.track(), N = null;
      return O && (N = O.plot(b)), b == null ? N : this;
    }, track: function() {
      var b = this.textPath();
      if (b)
        return b.reference("href");
    }, textPath: function() {
      if (this.node.firstChild && this.node.firstChild.nodeName == "textPath")
        return n.adopt(this.node.firstChild);
    } } }), n.Nested = n.invent({ create: function() {
      this.constructor.call(this, n.create("svg")), this.style("overflow", "visible");
    }, inherit: n.Container, construct: { nested: function() {
      return this.put(new n.Nested());
    } } });
    var p = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(b, O) {
      return O == "color" ? b : b + "-" + O;
    } };
    function y(b, O, N, X) {
      return N + X.replace(n.regex.dots, " .");
    }
    function S(b) {
      return b.toLowerCase().replace(/-(.)/g, function(O, N) {
        return N.toUpperCase();
      });
    }
    function C(b) {
      return b.charAt(0).toUpperCase() + b.slice(1);
    }
    function E(b) {
      var O = b.toString(16);
      return O.length == 1 ? "0" + O : O;
    }
    function L(b, O, N) {
      if (O == null || N == null) {
        var X = b.bbox();
        O == null ? O = X.width / X.height * N : N == null && (N = X.height / X.width * O);
      }
      return { width: O, height: N };
    }
    function M(b, O, N) {
      return { x: O * b.a + N * b.c + 0, y: O * b.b + N * b.d + 0 };
    }
    function P(b) {
      return { a: b[0], b: b[1], c: b[2], d: b[3], e: b[4], f: b[5] };
    }
    function I(b) {
      for (var O = b.childNodes.length - 1; O >= 0; O--)
        b.childNodes[O] instanceof W.SVGElement && I(b.childNodes[O]);
      return n.adopt(b).id(n.eid(b.nodeName));
    }
    function B(b) {
      return Math.abs(b) > 1e-37 ? b : 0;
    }
    ["fill", "stroke"].forEach(function(b) {
      var O = {};
      O[b] = function(N) {
        if (N === void 0)
          return this;
        if (typeof N == "string" || n.Color.isRgb(N) || N && typeof N.fill == "function")
          this.attr(b, N);
        else
          for (var X = p[b].length - 1; X >= 0; X--)
            N[p[b][X]] != null && this.attr(p.prefix(b, p[b][X]), N[p[b][X]]);
        return this;
      }, n.extend(n.Element, n.FX, O);
    }), n.extend(n.Element, n.FX, { translate: function(b, O) {
      return this.transform({ x: b, y: O });
    }, matrix: function(b) {
      return this.attr("transform", new n.Matrix(arguments.length == 6 ? [].slice.call(arguments) : b));
    }, opacity: function(b) {
      return this.attr("opacity", b);
    }, dx: function(b) {
      return this.x(new n.Number(b).plus(this instanceof n.FX ? 0 : this.x()), !0);
    }, dy: function(b) {
      return this.y(new n.Number(b).plus(this instanceof n.FX ? 0 : this.y()), !0);
    } }), n.extend(n.Path, { length: function() {
      return this.node.getTotalLength();
    }, pointAt: function(b) {
      return this.node.getPointAtLength(b);
    } }), n.Set = n.invent({ create: function(b) {
      Array.isArray(b) ? this.members = b : this.clear();
    }, extend: { add: function() {
      for (var b = [].slice.call(arguments), O = 0, N = b.length; O < N; O++)
        this.members.push(b[O]);
      return this;
    }, remove: function(b) {
      var O = this.index(b);
      return O > -1 && this.members.splice(O, 1), this;
    }, each: function(b) {
      for (var O = 0, N = this.members.length; O < N; O++)
        b.apply(this.members[O], [O, this.members]);
      return this;
    }, clear: function() {
      return this.members = [], this;
    }, length: function() {
      return this.members.length;
    }, has: function(b) {
      return this.index(b) >= 0;
    }, index: function(b) {
      return this.members.indexOf(b);
    }, get: function(b) {
      return this.members[b];
    }, first: function() {
      return this.get(0);
    }, last: function() {
      return this.get(this.members.length - 1);
    }, valueOf: function() {
      return this.members;
    } }, construct: { set: function(b) {
      return new n.Set(b);
    } } }), n.FX.Set = n.invent({ create: function(b) {
      this.set = b;
    } }), n.Set.inherit = function() {
      var b = [];
      for (var O in n.Shape.prototype)
        typeof n.Shape.prototype[O] == "function" && typeof n.Set.prototype[O] != "function" && b.push(O);
      for (var O in b.forEach(function(X) {
        n.Set.prototype[X] = function() {
          for (var Q = 0, ee = this.members.length; Q < ee; Q++)
            this.members[Q] && typeof this.members[Q][X] == "function" && this.members[Q][X].apply(this.members[Q], arguments);
          return X == "animate" ? this.fx || (this.fx = new n.FX.Set(this)) : this;
        };
      }), b = [], n.FX.prototype)
        typeof n.FX.prototype[O] == "function" && typeof n.FX.Set.prototype[O] != "function" && b.push(O);
      b.forEach(function(N) {
        n.FX.Set.prototype[N] = function() {
          for (var X = 0, Q = this.set.members.length; X < Q; X++)
            this.set.members[X].fx[N].apply(this.set.members[X].fx, arguments);
          return this;
        };
      });
    }, n.extend(n.Element, {}), n.extend(n.Element, { remember: function(b, O) {
      if (w(arguments[0]) === "object")
        for (var N in b)
          this.remember(N, b[N]);
      else {
        if (arguments.length == 1)
          return this.memory()[b];
        this.memory()[b] = O;
      }
      return this;
    }, forget: function() {
      if (arguments.length == 0)
        this._memory = {};
      else
        for (var b = arguments.length - 1; b >= 0; b--)
          delete this.memory()[arguments[b]];
      return this;
    }, memory: function() {
      return this._memory || (this._memory = {});
    } }), n.get = function(b) {
      var O = t.getElementById(function(N) {
        var X = (N || "").toString().match(n.regex.reference);
        if (X)
          return X[1];
      }(b) || b);
      return n.adopt(O);
    }, n.select = function(b, O) {
      return new n.Set(n.utils.map((O || t).querySelectorAll(b), function(N) {
        return n.adopt(N);
      }));
    }, n.extend(n.Parent, { select: function(b) {
      return n.select(b, this.node);
    } });
    var G = "abcdef".split("");
    if (typeof W.CustomEvent != "function") {
      var Z = function(b, O) {
        O = O || { bubbles: !1, cancelable: !1, detail: void 0 };
        var N = t.createEvent("CustomEvent");
        return N.initCustomEvent(b, O.bubbles, O.cancelable, O.detail), N;
      };
      Z.prototype = W.Event.prototype, n.CustomEvent = Z;
    } else
      n.CustomEvent = W.CustomEvent;
    return n;
  }, w(u) === "object" ? s.exports = ia.document ? le(ia, ia.document) : function(W) {
    return le(W, W.document);
  } : ia.SVG = le(ia, ia.document), /*! svg.filter.js - v2.0.2 - 2016-02-24
  * https://github.com/wout/svg.filter.js
  * Copyright (c) 2016 Wout Fierens; Licensed MIT */
  (function() {
    SVG.Filter = SVG.invent({ create: "filter", inherit: SVG.Parent, extend: { source: "SourceGraphic", sourceAlpha: "SourceAlpha", background: "BackgroundImage", backgroundAlpha: "BackgroundAlpha", fill: "FillPaint", stroke: "StrokePaint", autoSetIn: !0, put: function(f, p) {
      return this.add(f, p), !f.attr("in") && this.autoSetIn && f.attr("in", this.source), f.attr("result") || f.attr("result", f), f;
    }, blend: function(f, p, y) {
      return this.put(new SVG.BlendEffect(f, p, y));
    }, colorMatrix: function(f, p) {
      return this.put(new SVG.ColorMatrixEffect(f, p));
    }, convolveMatrix: function(f) {
      return this.put(new SVG.ConvolveMatrixEffect(f));
    }, componentTransfer: function(f) {
      return this.put(new SVG.ComponentTransferEffect(f));
    }, composite: function(f, p, y) {
      return this.put(new SVG.CompositeEffect(f, p, y));
    }, flood: function(f, p) {
      return this.put(new SVG.FloodEffect(f, p));
    }, offset: function(f, p) {
      return this.put(new SVG.OffsetEffect(f, p));
    }, image: function(f) {
      return this.put(new SVG.ImageEffect(f));
    }, merge: function() {
      var f = [void 0];
      for (var p in arguments)
        f.push(arguments[p]);
      return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, f))());
    }, gaussianBlur: function(f, p) {
      return this.put(new SVG.GaussianBlurEffect(f, p));
    }, morphology: function(f, p) {
      return this.put(new SVG.MorphologyEffect(f, p));
    }, diffuseLighting: function(f, p, y) {
      return this.put(new SVG.DiffuseLightingEffect(f, p, y));
    }, displacementMap: function(f, p, y, S, C) {
      return this.put(new SVG.DisplacementMapEffect(f, p, y, S, C));
    }, specularLighting: function(f, p, y, S) {
      return this.put(new SVG.SpecularLightingEffect(f, p, y, S));
    }, tile: function() {
      return this.put(new SVG.TileEffect());
    }, turbulence: function(f, p, y, S, C) {
      return this.put(new SVG.TurbulenceEffect(f, p, y, S, C));
    }, toString: function() {
      return "url(#" + this.attr("id") + ")";
    } } }), SVG.extend(SVG.Defs, { filter: function(f) {
      var p = this.put(new SVG.Filter());
      return typeof f == "function" && f.call(p, p), p;
    } }), SVG.extend(SVG.Container, { filter: function(f) {
      return this.defs().filter(f);
    } }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, { filter: function(f) {
      return this.filterer = f instanceof SVG.Element ? f : this.doc().filter(f), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer;
    }, unfilter: function(f) {
      return this.filterer && f === !0 && this.filterer.remove(), delete this.filterer, this.attr("filter", null);
    } }), SVG.Effect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Element, extend: { in: function(f) {
      return f == null ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", f);
    }, result: function(f) {
      return f == null ? this.attr("result") : this.attr("result", f);
    }, toString: function() {
      return this.result();
    } } }), SVG.ParentEffect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Parent, extend: { in: function(f) {
      return f == null ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", f);
    }, result: function(f) {
      return f == null ? this.attr("result") : this.attr("result", f);
    }, toString: function() {
      return this.result();
    } } });
    var W = { blend: function(f, p) {
      return this.parent() && this.parent().blend(this, f, p);
    }, colorMatrix: function(f, p) {
      return this.parent() && this.parent().colorMatrix(f, p).in(this);
    }, convolveMatrix: function(f) {
      return this.parent() && this.parent().convolveMatrix(f).in(this);
    }, componentTransfer: function(f) {
      return this.parent() && this.parent().componentTransfer(f).in(this);
    }, composite: function(f, p) {
      return this.parent() && this.parent().composite(this, f, p);
    }, flood: function(f, p) {
      return this.parent() && this.parent().flood(f, p);
    }, offset: function(f, p) {
      return this.parent() && this.parent().offset(f, p).in(this);
    }, image: function(f) {
      return this.parent() && this.parent().image(f);
    }, merge: function() {
      return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments));
    }, gaussianBlur: function(f, p) {
      return this.parent() && this.parent().gaussianBlur(f, p).in(this);
    }, morphology: function(f, p) {
      return this.parent() && this.parent().morphology(f, p).in(this);
    }, diffuseLighting: function(f, p, y) {
      return this.parent() && this.parent().diffuseLighting(f, p, y).in(this);
    }, displacementMap: function(f, p, y, S) {
      return this.parent() && this.parent().displacementMap(this, f, p, y, S);
    }, specularLighting: function(f, p, y, S) {
      return this.parent() && this.parent().specularLighting(f, p, y, S).in(this);
    }, tile: function() {
      return this.parent() && this.parent().tile().in(this);
    }, turbulence: function(f, p, y, S, C) {
      return this.parent() && this.parent().turbulence(f, p, y, S, C).in(this);
    } };
    SVG.extend(SVG.Effect, W), SVG.extend(SVG.ParentEffect, W), SVG.ChildEffect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Element, extend: { in: function(f) {
      this.attr("in", f);
    } } });
    var t = { blend: function(f, p, y) {
      this.attr({ in: f, in2: p, mode: y || "normal" });
    }, colorMatrix: function(f, p) {
      f == "matrix" && (p = o(p)), this.attr({ type: f, values: p === void 0 ? null : p });
    }, convolveMatrix: function(f) {
      f = o(f), this.attr({ order: Math.sqrt(f.split(" ").length), kernelMatrix: f });
    }, composite: function(f, p, y) {
      this.attr({ in: f, in2: p, operator: y });
    }, flood: function(f, p) {
      this.attr("flood-color", f), p != null && this.attr("flood-opacity", p);
    }, offset: function(f, p) {
      this.attr({ dx: f, dy: p });
    }, image: function(f) {
      this.attr("href", f, SVG.xlink);
    }, displacementMap: function(f, p, y, S, C) {
      this.attr({ in: f, in2: p, scale: y, xChannelSelector: S, yChannelSelector: C });
    }, gaussianBlur: function(f, p) {
      f != null || p != null ? this.attr("stdDeviation", function(y) {
        if (!Array.isArray(y))
          return y;
        for (var S = 0, C = y.length, E = []; S < C; S++)
          E.push(y[S]);
        return E.join(" ");
      }(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0");
    }, morphology: function(f, p) {
      this.attr({ operator: f, radius: p });
    }, tile: function() {
    }, turbulence: function(f, p, y, S, C) {
      this.attr({ numOctaves: p, seed: y, stitchTiles: S, baseFrequency: f, type: C });
    } }, n = { merge: function() {
      var f;
      if (arguments[0] instanceof SVG.Set) {
        var p = this;
        arguments[0].each(function(S) {
          this instanceof SVG.MergeNode ? p.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && p.put(new SVG.MergeNode(this));
        });
      } else {
        f = Array.isArray(arguments[0]) ? arguments[0] : arguments;
        for (var y = 0; y < f.length; y++)
          f[y] instanceof SVG.MergeNode ? this.put(f[y]) : this.put(new SVG.MergeNode(f[y]));
      }
    }, componentTransfer: function(f) {
      if (this.rgb = new SVG.Set(), ["r", "g", "b", "a"].forEach((function(y) {
        this[y] = new SVG["Func" + y.toUpperCase()]("identity"), this.rgb.add(this[y]), this.node.appendChild(this[y].node);
      }).bind(this)), f)
        for (var p in f.rgb && (["r", "g", "b"].forEach((function(y) {
          this[y].attr(f.rgb);
        }).bind(this)), delete f.rgb), f)
          this[p].attr(f[p]);
    }, diffuseLighting: function(f, p, y) {
      this.attr({ surfaceScale: f, diffuseConstant: p, kernelUnitLength: y });
    }, specularLighting: function(f, p, y, S) {
      this.attr({ surfaceScale: f, diffuseConstant: p, specularExponent: y, kernelUnitLength: S });
    } }, a = { distantLight: function(f, p) {
      this.attr({ azimuth: f, elevation: p });
    }, pointLight: function(f, p, y) {
      this.attr({ x: f, y: p, z: y });
    }, spotLight: function(f, p, y, S, C, E) {
      this.attr({ x: f, y: p, z: y, pointsAtX: S, pointsAtY: C, pointsAtZ: E });
    }, mergeNode: function(f) {
      this.attr("in", f);
    } };
    function o(f) {
      return Array.isArray(f) && (f = new SVG.Array(f)), f.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
    }
    function d() {
      var f = function() {
      };
      for (var p in typeof arguments[arguments.length - 1] == "function" && (f = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments)
        for (var y in arguments[p])
          f(arguments[p][y], y, arguments[p]);
    }
    ["r", "g", "b", "a"].forEach(function(f) {
      a["Func" + f.toUpperCase()] = function(p) {
        switch (this.attr("type", p), p) {
          case "table":
            this.attr("tableValues", arguments[1]);
            break;
          case "linear":
            this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
            break;
          case "gamma":
            this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2]);
        }
      };
    }), d(t, function(f, p) {
      var y = p.charAt(0).toUpperCase() + p.slice(1);
      SVG[y + "Effect"] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + y)), f.apply(this, arguments), this.result(this.attr("id") + "Out");
      }, inherit: SVG.Effect, extend: {} });
    }), d(n, function(f, p) {
      var y = p.charAt(0).toUpperCase() + p.slice(1);
      SVG[y + "Effect"] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + y)), f.apply(this, arguments), this.result(this.attr("id") + "Out");
      }, inherit: SVG.ParentEffect, extend: {} });
    }), d(a, function(f, p) {
      var y = p.charAt(0).toUpperCase() + p.slice(1);
      SVG[y] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + y)), f.apply(this, arguments);
      }, inherit: SVG.ChildEffect, extend: {} });
    }), SVG.extend(SVG.MergeEffect, { in: function(f) {
      return f instanceof SVG.MergeNode ? this.add(f, 0) : this.add(new SVG.MergeNode(f), 0), this;
    } }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, { in2: function(f) {
      return f == null ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", f);
    } }), SVG.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
  }).call(void 0), function() {
    function W(d, f, p, y, S, C, E) {
      for (var L = d.slice(f, p || E), M = y.slice(S, C || E), P = 0, I = { pos: [0, 0], start: [0, 0] }, B = { pos: [0, 0], start: [0, 0] }; L[P] = t.call(I, L[P]), M[P] = t.call(B, M[P]), L[P][0] != M[P][0] || L[P][0] == "M" || L[P][0] == "A" && (L[P][4] != M[P][4] || L[P][5] != M[P][5]) ? (Array.prototype.splice.apply(L, [P, 1].concat(a.call(I, L[P]))), Array.prototype.splice.apply(M, [P, 1].concat(a.call(B, M[P])))) : (L[P] = n.call(I, L[P]), M[P] = n.call(B, M[P])), !(++P == L.length && P == M.length); )
        P == L.length && L.push(["C", I.pos[0], I.pos[1], I.pos[0], I.pos[1], I.pos[0], I.pos[1]]), P == M.length && M.push(["C", B.pos[0], B.pos[1], B.pos[0], B.pos[1], B.pos[0], B.pos[1]]);
      return { start: L, dest: M };
    }
    function t(d) {
      switch (d[0]) {
        case "z":
        case "Z":
          d[0] = "L", d[1] = this.start[0], d[2] = this.start[1];
          break;
        case "H":
          d[0] = "L", d[2] = this.pos[1];
          break;
        case "V":
          d[0] = "L", d[2] = d[1], d[1] = this.pos[0];
          break;
        case "T":
          d[0] = "Q", d[3] = d[1], d[4] = d[2], d[1] = this.reflection[1], d[2] = this.reflection[0];
          break;
        case "S":
          d[0] = "C", d[6] = d[4], d[5] = d[3], d[4] = d[2], d[3] = d[1], d[2] = this.reflection[1], d[1] = this.reflection[0];
      }
      return d;
    }
    function n(d) {
      var f = d.length;
      return this.pos = [d[f - 2], d[f - 1]], "SCQT".indexOf(d[0]) != -1 && (this.reflection = [2 * this.pos[0] - d[f - 4], 2 * this.pos[1] - d[f - 3]]), d;
    }
    function a(d) {
      var f = [d];
      switch (d[0]) {
        case "M":
          return this.pos = this.start = [d[1], d[2]], f;
        case "L":
          d[5] = d[3] = d[1], d[6] = d[4] = d[2], d[1] = this.pos[0], d[2] = this.pos[1];
          break;
        case "Q":
          d[6] = d[4], d[5] = d[3], d[4] = 1 * d[4] / 3 + 2 * d[2] / 3, d[3] = 1 * d[3] / 3 + 2 * d[1] / 3, d[2] = 1 * this.pos[1] / 3 + 2 * d[2] / 3, d[1] = 1 * this.pos[0] / 3 + 2 * d[1] / 3;
          break;
        case "A":
          f = function(p, y) {
            var S, C, E, L, M, P, I, B, G, Z, b, O, N, X, Q, ee, oe, fe, ke, _e, Le, Ie, at, Qt, Kt, xt, On = Math.abs(y[1]), zn = Math.abs(y[2]), vt = y[3] % 360, Br = y[4], Dn = y[5], sa = y[6], oa = y[7], xr = new SVG.Point(p), ln = new SVG.Point(sa, oa), wn = [];
            if (On === 0 || zn === 0 || xr.x === ln.x && xr.y === ln.y)
              return [["C", xr.x, xr.y, ln.x, ln.y, ln.x, ln.y]];
            for (S = new SVG.Point((xr.x - ln.x) / 2, (xr.y - ln.y) / 2).transform(new SVG.Matrix().rotate(vt)), (C = S.x * S.x / (On * On) + S.y * S.y / (zn * zn)) > 1 && (On *= C = Math.sqrt(C), zn *= C), E = new SVG.Matrix().rotate(vt).scale(1 / On, 1 / zn).rotate(-vt), xr = xr.transform(E), ln = ln.transform(E), L = [ln.x - xr.x, ln.y - xr.y], P = L[0] * L[0] + L[1] * L[1], M = Math.sqrt(P), L[0] /= M, L[1] /= M, I = P < 4 ? Math.sqrt(1 - P / 4) : 0, Br === Dn && (I *= -1), B = new SVG.Point((ln.x + xr.x) / 2 + I * -L[1], (ln.y + xr.y) / 2 + I * L[0]), G = new SVG.Point(xr.x - B.x, xr.y - B.y), Z = new SVG.Point(ln.x - B.x, ln.y - B.y), b = Math.acos(G.x / Math.sqrt(G.x * G.x + G.y * G.y)), G.y < 0 && (b *= -1), O = Math.acos(Z.x / Math.sqrt(Z.x * Z.x + Z.y * Z.y)), Z.y < 0 && (O *= -1), Dn && b > O && (O += 2 * Math.PI), !Dn && b < O && (O -= 2 * Math.PI), X = Math.ceil(2 * Math.abs(b - O) / Math.PI), ee = [], oe = b, N = (O - b) / X, Q = 4 * Math.tan(N / 4) / 3, Le = 0; Le <= X; Le++)
              ke = Math.cos(oe), fe = Math.sin(oe), _e = new SVG.Point(B.x + ke, B.y + fe), ee[Le] = [new SVG.Point(_e.x + Q * fe, _e.y - Q * ke), _e, new SVG.Point(_e.x - Q * fe, _e.y + Q * ke)], oe += N;
            for (ee[0][0] = ee[0][1].clone(), ee[ee.length - 1][2] = ee[ee.length - 1][1].clone(), E = new SVG.Matrix().rotate(vt).scale(On, zn).rotate(-vt), Le = 0, Ie = ee.length; Le < Ie; Le++)
              ee[Le][0] = ee[Le][0].transform(E), ee[Le][1] = ee[Le][1].transform(E), ee[Le][2] = ee[Le][2].transform(E);
            for (Le = 1, Ie = ee.length; Le < Ie; Le++)
              at = (_e = ee[Le - 1][2]).x, Qt = _e.y, Kt = (_e = ee[Le][0]).x, xt = _e.y, sa = (_e = ee[Le][1]).x, oa = _e.y, wn.push(["C", at, Qt, Kt, xt, sa, oa]);
            return wn;
          }(this.pos, d), d = f[0];
      }
      return d[0] = "C", this.pos = [d[5], d[6]], this.reflection = [2 * d[5] - d[3], 2 * d[6] - d[4]], f;
    }
    function o(d, f) {
      if (f === !1)
        return !1;
      for (var p = f, y = d.length; p < y; ++p)
        if (d[p][0] == "M")
          return p;
      return !1;
    }
    SVG.extend(SVG.PathArray, { morph: function(d) {
      for (var f = this.value, p = this.parse(d), y = 0, S = 0, C = !1, E = !1; y !== !1 || S !== !1; ) {
        var L;
        C = o(f, y !== !1 && y + 1), E = o(p, S !== !1 && S + 1), y === !1 && (y = (L = new SVG.PathArray(M.start).bbox()).height == 0 || L.width == 0 ? f.push(f[0]) - 1 : f.push(["M", L.x + L.width / 2, L.y + L.height / 2]) - 1), S === !1 && (S = (L = new SVG.PathArray(M.dest).bbox()).height == 0 || L.width == 0 ? p.push(p[0]) - 1 : p.push(["M", L.x + L.width / 2, L.y + L.height / 2]) - 1);
        var M = W(f, y, C, p, S, E);
        f = f.slice(0, y).concat(M.start, C === !1 ? [] : f.slice(C)), p = p.slice(0, S).concat(M.dest, E === !1 ? [] : p.slice(E)), y = C !== !1 && y + M.start.length, S = E !== !1 && S + M.dest.length;
      }
      return this.value = f, this.destination = new SVG.PathArray(), this.destination.value = p, this;
    } });
  }(), /*! svg.draggable.js - v2.2.2 - 2019-01-08
  * https://github.com/svgdotjs/svg.draggable.js
  * Copyright (c) 2019 Wout Fierens; Licensed MIT */
  (function() {
    function W(t) {
      t.remember("_draggable", this), this.el = t;
    }
    W.prototype.init = function(t, n) {
      var a = this;
      this.constraint = t, this.value = n, this.el.on("mousedown.drag", function(o) {
        a.start(o);
      }), this.el.on("touchstart.drag", function(o) {
        a.start(o);
      });
    }, W.prototype.transformPoint = function(t, n) {
      var a = (t = t || window.event).changedTouches && t.changedTouches[0] || t;
      return this.p.x = a.clientX - (n || 0), this.p.y = a.clientY, this.p.matrixTransform(this.m);
    }, W.prototype.getBBox = function() {
      var t = this.el.bbox();
      return this.el instanceof SVG.Nested && (t = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t.x = this.el.x(), t.y = this.el.y()), t;
    }, W.prototype.start = function(t) {
      if (t.type != "click" && t.type != "mousedown" && t.type != "mousemove" || (t.which || t.buttons) == 1) {
        var n = this;
        if (this.el.fire("beforedrag", { event: t, handler: this }), !this.el.event().defaultPrevented) {
          t.preventDefault(), t.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
          var a, o = this.getBBox();
          if (this.el instanceof SVG.Text)
            switch (a = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
              case "middle":
                a /= 2;
                break;
              case "start":
                a = 0;
            }
          this.startPoints = { point: this.transformPoint(t, a), box: o, transform: this.el.transform() }, SVG.on(window, "mousemove.drag", function(d) {
            n.drag(d);
          }), SVG.on(window, "touchmove.drag", function(d) {
            n.drag(d);
          }), SVG.on(window, "mouseup.drag", function(d) {
            n.end(d);
          }), SVG.on(window, "touchend.drag", function(d) {
            n.end(d);
          }), this.el.fire("dragstart", { event: t, p: this.startPoints.point, m: this.m, handler: this });
        }
      }
    }, W.prototype.drag = function(t) {
      var n = this.getBBox(), a = this.transformPoint(t), o = this.startPoints.box.x + a.x - this.startPoints.point.x, d = this.startPoints.box.y + a.y - this.startPoints.point.y, f = this.constraint, p = a.x - this.startPoints.point.x, y = a.y - this.startPoints.point.y;
      if (this.el.fire("dragmove", { event: t, p: a, m: this.m, handler: this }), this.el.event().defaultPrevented)
        return a;
      if (typeof f == "function") {
        var S = f.call(this.el, o, d, this.m);
        typeof S == "boolean" && (S = { x: S, y: S }), S.x === !0 ? this.el.x(o) : S.x !== !1 && this.el.x(S.x), S.y === !0 ? this.el.y(d) : S.y !== !1 && this.el.y(S.y);
      } else
        typeof f == "object" && (f.minX != null && o < f.minX ? p = (o = f.minX) - this.startPoints.box.x : f.maxX != null && o > f.maxX - n.width && (p = (o = f.maxX - n.width) - this.startPoints.box.x), f.minY != null && d < f.minY ? y = (d = f.minY) - this.startPoints.box.y : f.maxY != null && d > f.maxY - n.height && (y = (d = f.maxY - n.height) - this.startPoints.box.y), f.snapToGrid != null && (o -= o % f.snapToGrid, d -= d % f.snapToGrid, p -= p % f.snapToGrid, y -= y % f.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({ x: p, y }, !0) : this.el.move(o, d));
      return a;
    }, W.prototype.end = function(t) {
      var n = this.drag(t);
      this.el.fire("dragend", { event: t, p: n, m: this.m, handler: this }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag");
    }, SVG.extend(SVG.Element, { draggable: function(t, n) {
      typeof t != "function" && typeof t != "object" || (n = t, t = !0);
      var a = this.remember("_draggable") || new W(this);
      return (t = t === void 0 || t) ? a.init(n || {}, t) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this;
    } });
  }).call(void 0), function() {
    function W(t) {
      this.el = t, t.remember("_selectHandler", this), this.pointSelection = { isSelected: !1 }, this.rectSelection = { isSelected: !1 }, this.pointsList = { lt: [0, 0], rt: ["width", 0], rb: ["width", "height"], lb: [0, "height"], t: ["width", 0], r: ["width", "height"], b: ["width", "height"], l: [0, "height"] }, this.pointCoord = function(n, a, o) {
        var d = typeof n != "string" ? n : a[n];
        return o ? d / 2 : d;
      }, this.pointCoords = function(n, a) {
        var o = this.pointsList[n];
        return { x: this.pointCoord(o[0], a, n === "t" || n === "b"), y: this.pointCoord(o[1], a, n === "r" || n === "l") };
      };
    }
    W.prototype.init = function(t, n) {
      var a = this.el.bbox();
      this.options = {};
      var o = this.el.selectize.defaults.points;
      for (var d in this.el.selectize.defaults)
        this.options[d] = this.el.selectize.defaults[d], n[d] !== void 0 && (this.options[d] = n[d]);
      var f = ["points", "pointsExclude"];
      for (var d in f) {
        var p = this.options[f[d]];
        typeof p == "string" ? p = p.length > 0 ? p.split(/\s*,\s*/i) : [] : typeof p == "boolean" && f[d] === "points" && (p = p ? o : []), this.options[f[d]] = p;
      }
      this.options.points = [o, this.options.points].reduce(function(y, S) {
        return y.filter(function(C) {
          return S.indexOf(C) > -1;
        });
      }), this.options.points = [this.options.points, this.options.pointsExclude].reduce(function(y, S) {
        return y.filter(function(C) {
          return S.indexOf(C) < 0;
        });
      }), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(a.x, a.y)), this.options.deepSelect && ["line", "polyline", "polygon"].indexOf(this.el.type) !== -1 ? this.selectPoints(t) : this.selectRect(t), this.observe(), this.cleanup();
    }, W.prototype.selectPoints = function(t) {
      return this.pointSelection.isSelected = t, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this;
    }, W.prototype.getPointArray = function() {
      var t = this.el.bbox();
      return this.el.array().valueOf().map(function(n) {
        return [n[0] - t.x, n[1] - t.y];
      });
    }, W.prototype.drawPoints = function() {
      for (var t = this, n = this.getPointArray(), a = 0, o = n.length; a < o; ++a) {
        var d = function(p) {
          return function(y) {
            (y = y || window.event).preventDefault ? y.preventDefault() : y.returnValue = !1, y.stopPropagation();
            var S = y.pageX || y.touches[0].pageX, C = y.pageY || y.touches[0].pageY;
            t.el.fire("point", { x: S, y: C, i: p, event: y });
          };
        }(a), f = this.drawPoint(n[a][0], n[a][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", d).on("mousedown", d);
        this.pointSelection.set.add(f);
      }
    }, W.prototype.drawPoint = function(t, n) {
      var a = this.options.pointType;
      switch (a) {
        case "circle":
          return this.drawCircle(t, n);
        case "rect":
          return this.drawRect(t, n);
        default:
          if (typeof a == "function")
            return a.call(this, t, n);
          throw new Error("Unknown " + a + " point type!");
      }
    }, W.prototype.drawCircle = function(t, n) {
      return this.nested.circle(this.options.pointSize).center(t, n);
    }, W.prototype.drawRect = function(t, n) {
      return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t, n);
    }, W.prototype.updatePointSelection = function() {
      var t = this.getPointArray();
      this.pointSelection.set.each(function(n) {
        this.cx() === t[n][0] && this.cy() === t[n][1] || this.center(t[n][0], t[n][1]);
      });
    }, W.prototype.updateRectSelection = function() {
      var t = this, n = this.el.bbox();
      if (this.rectSelection.set.get(0).attr({ width: n.width, height: n.height }), this.options.points.length && this.options.points.map(function(o, d) {
        var f = t.pointCoords(o, n);
        t.rectSelection.set.get(d + 1).center(f.x, f.y);
      }), this.options.rotationPoint) {
        var a = this.rectSelection.set.length();
        this.rectSelection.set.get(a - 1).center(n.width / 2, 20);
      }
    }, W.prototype.selectRect = function(t) {
      var n = this, a = this.el.bbox();
      function o(p) {
        return function(y) {
          (y = y || window.event).preventDefault ? y.preventDefault() : y.returnValue = !1, y.stopPropagation();
          var S = y.pageX || y.touches[0].pageX, C = y.pageY || y.touches[0].pageY;
          n.el.fire(p, { x: S, y: C, event: y });
        };
      }
      if (this.rectSelection.isSelected = t, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(a.width, a.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2 && (this.options.points.map(function(p, y) {
        var S = n.pointCoords(p, a), C = n.drawPoint(S.x, S.y).attr("class", n.options.classPoints + "_" + p).on("mousedown", o(p)).on("touchstart", o(p));
        n.rectSelection.set.add(C);
      }), this.rectSelection.set.each(function() {
        this.addClass(n.options.classPoints);
      })), this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
        var d = function(p) {
          (p = p || window.event).preventDefault ? p.preventDefault() : p.returnValue = !1, p.stopPropagation();
          var y = p.pageX || p.touches[0].pageX, S = p.pageY || p.touches[0].pageY;
          n.el.fire("rot", { x: y, y: S, event: p });
        }, f = this.drawPoint(a.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", d).on("mousedown", d);
        this.rectSelection.set.add(f);
      }
    }, W.prototype.handler = function() {
      var t = this.el.bbox();
      this.nested.matrix(new SVG.Matrix(this.el).translate(t.x, t.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection();
    }, W.prototype.observe = function() {
      var t = this;
      if (MutationObserver)
        if (this.rectSelection.isSelected || this.pointSelection.isSelected)
          this.observerInst = this.observerInst || new MutationObserver(function() {
            t.handler();
          }), this.observerInst.observe(this.el.node, { attributes: !0 });
        else
          try {
            this.observerInst.disconnect(), delete this.observerInst;
          } catch {
          }
      else
        this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function() {
          t.handler();
        });
    }, W.prototype.cleanup = function() {
      !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function() {
        this.remove();
      }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function() {
        this.remove();
      }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested);
    }, SVG.extend(SVG.Element, { selectize: function(t, n) {
      return typeof t == "object" && (n = t, t = !0), (this.remember("_selectHandler") || new W(this)).init(t === void 0 || t, n || {}), this;
    } }), SVG.Element.prototype.selectize.defaults = { points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"], pointsExclude: [], classRect: "svg_select_boundingRect", classPoints: "svg_select_points", pointSize: 7, rotationPoint: !0, deepSelect: !1, pointType: "circle" };
  }(), function() {
    (function() {
      function W(t) {
        t.remember("_resizeHandler", this), this.el = t, this.parameters = {}, this.lastUpdateCall = null, this.p = t.doc().node.createSVGPoint();
      }
      W.prototype.transformPoint = function(t, n, a) {
        return this.p.x = t - (this.offset.x - window.pageXOffset), this.p.y = n - (this.offset.y - window.pageYOffset), this.p.matrixTransform(a || this.m);
      }, W.prototype._extractPosition = function(t) {
        return { x: t.clientX != null ? t.clientX : t.touches[0].clientX, y: t.clientY != null ? t.clientY : t.touches[0].clientY };
      }, W.prototype.init = function(t) {
        var n = this;
        if (this.stop(), t !== "stop") {
          for (var a in this.options = {}, this.el.resize.defaults)
            this.options[a] = this.el.resize.defaults[a], t[a] !== void 0 && (this.options[a] = t[a]);
          this.el.on("lt.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("rt.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("rb.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("lb.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("t.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("r.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("b.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("l.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("rot.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("point.resize", function(o) {
            n.resize(o || window.event);
          }), this.update();
        }
      }, W.prototype.stop = function() {
        return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this;
      }, W.prototype.resize = function(t) {
        var n = this;
        this.m = this.el.node.getScreenCTM().inverse(), this.offset = { x: window.pageXOffset, y: window.pageYOffset };
        var a = this._extractPosition(t.detail.event);
        if (this.parameters = { type: this.el.type, p: this.transformPoint(a.x, a.y), x: t.detail.x, y: t.detail.y, box: this.el.bbox(), rotation: this.el.transform().rotation }, this.el.type === "text" && (this.parameters.fontSize = this.el.attr()["font-size"]), t.detail.i !== void 0) {
          var o = this.el.array().valueOf();
          this.parameters.i = t.detail.i, this.parameters.pointCoords = [o[t.detail.i][0], o[t.detail.i][1]];
        }
        switch (t.type) {
          case "lt":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f);
              if (this.parameters.box.width - p[0] > 0 && this.parameters.box.height - p[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x + p[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - p[0]);
                p = this.checkAspectRatio(p), this.el.move(this.parameters.box.x + p[0], this.parameters.box.y + p[1]).size(this.parameters.box.width - p[0], this.parameters.box.height - p[1]);
              }
            };
            break;
          case "rt":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 2);
              if (this.parameters.box.width + p[0] > 0 && this.parameters.box.height - p[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x - p[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + p[0]);
                p = this.checkAspectRatio(p, !0), this.el.move(this.parameters.box.x, this.parameters.box.y + p[1]).size(this.parameters.box.width + p[0], this.parameters.box.height - p[1]);
              }
            };
            break;
          case "rb":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 0);
              if (this.parameters.box.width + p[0] > 0 && this.parameters.box.height + p[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x - p[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + p[0]);
                p = this.checkAspectRatio(p), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + p[0], this.parameters.box.height + p[1]);
              }
            };
            break;
          case "lb":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 1);
              if (this.parameters.box.width - p[0] > 0 && this.parameters.box.height + p[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x + p[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - p[0]);
                p = this.checkAspectRatio(p, !0), this.el.move(this.parameters.box.x + p[0], this.parameters.box.y).size(this.parameters.box.width - p[0], this.parameters.box.height + p[1]);
              }
            };
            break;
          case "t":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 2);
              if (this.parameters.box.height - p[1] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y + p[1]).height(this.parameters.box.height - p[1]);
              }
            };
            break;
          case "r":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 0);
              if (this.parameters.box.width + p[0] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + p[0]);
              }
            };
            break;
          case "b":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 0);
              if (this.parameters.box.height + p[1] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + p[1]);
              }
            };
            break;
          case "l":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 1);
              if (this.parameters.box.width - p[0] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x + p[0], this.parameters.box.y).width(this.parameters.box.width - p[0]);
              }
            };
            break;
          case "rot":
            this.calc = function(d, f) {
              var p = d + this.parameters.p.x, y = f + this.parameters.p.y, S = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2), C = Math.atan2(y - this.parameters.box.y - this.parameters.box.height / 2, p - this.parameters.box.x - this.parameters.box.width / 2), E = this.parameters.rotation + 180 * (C - S) / Math.PI + this.options.snapToAngle / 2;
              this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(E - E % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);
            };
            break;
          case "point":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, this.parameters.pointCoords[0], this.parameters.pointCoords[1]), y = this.el.array().valueOf();
              y[this.parameters.i][0] = this.parameters.pointCoords[0] + p[0], y[this.parameters.i][1] = this.parameters.pointCoords[1] + p[1], this.el.plot(y);
            };
        }
        this.el.fire("resizestart", { dx: this.parameters.x, dy: this.parameters.y, event: t }), SVG.on(window, "touchmove.resize", function(d) {
          n.update(d || window.event);
        }), SVG.on(window, "touchend.resize", function() {
          n.done();
        }), SVG.on(window, "mousemove.resize", function(d) {
          n.update(d || window.event);
        }), SVG.on(window, "mouseup.resize", function() {
          n.done();
        });
      }, W.prototype.update = function(t) {
        if (t) {
          var n = this._extractPosition(t), a = this.transformPoint(n.x, n.y), o = a.x - this.parameters.p.x, d = a.y - this.parameters.p.y;
          this.lastUpdateCall = [o, d], this.calc(o, d), this.el.fire("resizing", { dx: o, dy: d, event: t });
        } else
          this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
      }, W.prototype.done = function() {
        this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone");
      }, W.prototype.snapToGrid = function(t, n, a, o) {
        var d;
        return o !== void 0 ? d = [(a + t) % this.options.snapToGrid, (o + n) % this.options.snapToGrid] : (a = a ?? 3, d = [(this.parameters.box.x + t + (1 & a ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + n + (2 & a ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), t < 0 && (d[0] -= this.options.snapToGrid), n < 0 && (d[1] -= this.options.snapToGrid), t -= Math.abs(d[0]) < this.options.snapToGrid / 2 ? d[0] : d[0] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid), n -= Math.abs(d[1]) < this.options.snapToGrid / 2 ? d[1] : d[1] - (n < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t, n, a, o);
      }, W.prototype.constraintToBox = function(t, n, a, o) {
        var d, f, p = this.options.constraint || {};
        return o !== void 0 ? (d = a, f = o) : (d = this.parameters.box.x + (1 & a ? 0 : this.parameters.box.width), f = this.parameters.box.y + (2 & a ? 0 : this.parameters.box.height)), p.minX !== void 0 && d + t < p.minX && (t = p.minX - d), p.maxX !== void 0 && d + t > p.maxX && (t = p.maxX - d), p.minY !== void 0 && f + n < p.minY && (n = p.minY - f), p.maxY !== void 0 && f + n > p.maxY && (n = p.maxY - f), [t, n];
      }, W.prototype.checkAspectRatio = function(t, n) {
        if (!this.options.saveAspectRatio)
          return t;
        var a = t.slice(), o = this.parameters.box.width / this.parameters.box.height, d = this.parameters.box.width + t[0], f = this.parameters.box.height - t[1], p = d / f;
        return p < o ? (a[1] = d / o - this.parameters.box.height, n && (a[1] = -a[1])) : p > o && (a[0] = this.parameters.box.width - f * o, n && (a[0] = -a[0])), a;
      }, SVG.extend(SVG.Element, { resize: function(t) {
        return (this.remember("_resizeHandler") || new W(this)).init(t || {}), this;
      } }), SVG.Element.prototype.resize.defaults = { snapToAngle: 0.1, snapToGrid: 1, constraint: {}, saveAspectRatio: !1 };
    }).call(this);
  }(), window.Apex === void 0 && (window.Apex = {});
  var Zt = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "initModules", value: function() {
      this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new we(this.ctx), this.ctx.axes = new Mr(this.ctx), this.ctx.core = new qt(this.ctx.el, this.ctx), this.ctx.config = new pt({}), this.ctx.data = new Nt(this.ctx), this.ctx.grid = new mn(this.ctx), this.ctx.graphics = new re(this.ctx), this.ctx.coreUtils = new me(this.ctx), this.ctx.crosshairs = new ta(this.ctx), this.ctx.events = new ir(this.ctx), this.ctx.exports = new Ht(this.ctx), this.ctx.localization = new Dr(this.ctx), this.ctx.options = new ht(), this.ctx.responsive = new Za(this.ctx), this.ctx.series = new st(this.ctx), this.ctx.theme = new _i(this.ctx), this.ctx.formatters = new Tt(this.ctx), this.ctx.titleSubtitle = new di(this.ctx), this.ctx.legend = new ra(this.ctx), this.ctx.toolbar = new Pi(this.ctx), this.ctx.tooltip = new $n(this.ctx), this.ctx.dimensions = new na(this.ctx), this.ctx.updateHelpers = new cn(this.ctx), this.ctx.zoomPanSelection = new Ka(this.ctx), this.ctx.w.globals.tooltip = new $n(this.ctx);
    } }]), W;
  }(), Mt = function() {
    function W(t) {
      T(this, W), this.ctx = t, this.w = t.w;
    }
    return F(W, [{ key: "clear", value: function(t) {
      var n = t.isUpdating;
      this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: n });
    } }, { key: "killSVG", value: function(t) {
      t.each(function(n, a) {
        this.removeClass("*"), this.off(), this.stop();
      }, !0), t.ungroup(), t.clear();
    } }, { key: "clearDomElements", value: function(t) {
      var n = this, a = t.isUpdating, o = this.w.globals.dom.Paper.node;
      o.parentNode && o.parentNode.parentNode && !a && (o.parentNode.parentNode.style.minHeight = "unset");
      var d = this.w.globals.dom.baseEl;
      d && this.ctx.eventList.forEach(function(p) {
        d.removeEventListener(p, n.ctx.events.documentEvent);
      });
      var f = this.w.globals.dom;
      if (this.ctx.el !== null)
        for (; this.ctx.el.firstChild; )
          this.ctx.el.removeChild(this.ctx.el.firstChild);
      this.killSVG(f.Paper), f.Paper.remove(), f.elWrap = null, f.elGraphical = null, f.elLegendWrap = null, f.elLegendForeign = null, f.baseEl = null, f.elGridRect = null, f.elGridRectMask = null, f.elGridRectMarkerMask = null, f.elForecastMask = null, f.elNonForecastMask = null, f.elDefs = null;
    } }]), W;
  }(), or = /* @__PURE__ */ new WeakMap(), Yn = function() {
    function W(t, n) {
      T(this, W), this.opts = n, this.ctx = this, this.w = new je(n).init(), this.el = t, this.w.globals.cuid = K.randomId(), this.w.globals.chartID = this.w.config.chart.id ? K.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new Zt(this).initModules(), this.create = K.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
    }
    return F(W, [{ key: "render", value: function() {
      var t = this;
      return new Promise(function(n, a) {
        if (t.el !== null) {
          Apex._chartInstances === void 0 && (Apex._chartInstances = []), t.w.config.chart.id && Apex._chartInstances.push({ id: t.w.globals.chartID, group: t.w.config.chart.group, chart: t }), t.setLocale(t.w.config.chart.defaultLocale);
          var o = t.w.config.chart.events.beforeMount;
          if (typeof o == "function" && o(t, t.w), t.events.fireEvent("beforeMount", [t, t.w]), window.addEventListener("resize", t.windowResizeHandler), function(C, E) {
            var L = !1;
            if (C.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
              var M = C.getBoundingClientRect();
              C.style.display !== "none" && M.width !== 0 || (L = !0);
            }
            var P = new ResizeObserver(function(I) {
              L && E.call(C, I), L = !0;
            });
            C.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(C.children).forEach(function(I) {
              return P.observe(I);
            }) : P.observe(C), or.set(E, P);
          }(t.el.parentNode, t.parentResizeHandler), !t.css) {
            var d = t.el.getRootNode && t.el.getRootNode(), f = K.is("ShadowRoot", d), p = t.el.ownerDocument, y = p.getElementById("apexcharts-css");
            !f && y || (t.css = document.createElement("style"), t.css.id = "apexcharts-css", t.css.textContent = `@keyframes opaque {
  0% {
      opacity: 0
  }

  to {
      opacity: 1
  }
}

@keyframes resizeanim {
  0%,to {
      opacity: 0
  }
}

.apexcharts-canvas {
  position: relative;
  user-select: none
}

.apexcharts-canvas ::-webkit-scrollbar {
  -webkit-appearance: none;
  width: 6px
}

.apexcharts-canvas ::-webkit-scrollbar-thumb {
  border-radius: 4px;
  background-color: rgba(0,0,0,.5);
  box-shadow: 0 0 1px rgba(255,255,255,.5);
  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5)
}

.apexcharts-inner {
  position: relative
}

.apexcharts-text tspan {
  font-family: inherit
}

.legend-mouseover-inactive {
  transition: .15s ease all;
  opacity: .2
}

.apexcharts-legend-text {
  padding-left: 15px;
  margin-left: -15px;
}

.apexcharts-series-collapsed {
  opacity: 0
}

.apexcharts-tooltip {
  border-radius: 5px;
  box-shadow: 2px 2px 6px -4px #999;
  cursor: default;
  font-size: 14px;
  left: 62px;
  opacity: 0;
  pointer-events: none;
  position: absolute;
  top: 20px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  white-space: nowrap;
  z-index: 12;
  transition: .15s ease all
}

.apexcharts-tooltip.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-tooltip.apexcharts-theme-light {
  border: 1px solid #e3e3e3;
  background: rgba(255,255,255,.96)
}

.apexcharts-tooltip.apexcharts-theme-dark {
  color: #fff;
  background: rgba(30,30,30,.8)
}

.apexcharts-tooltip * {
  font-family: inherit
}

.apexcharts-tooltip-title {
  padding: 6px;
  font-size: 15px;
  margin-bottom: 4px
}

.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {
  background: #eceff1;
  border-bottom: 1px solid #ddd
}

.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {
  background: rgba(0,0,0,.7);
  border-bottom: 1px solid #333
}

.apexcharts-tooltip-text-goals-value,.apexcharts-tooltip-text-y-value,.apexcharts-tooltip-text-z-value {
  display: inline-block;
  margin-left: 5px;
  font-weight: 600
}

.apexcharts-tooltip-text-goals-label:empty,.apexcharts-tooltip-text-goals-value:empty,.apexcharts-tooltip-text-y-label:empty,.apexcharts-tooltip-text-y-value:empty,.apexcharts-tooltip-text-z-value:empty,.apexcharts-tooltip-title:empty {
  display: none
}

.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {
  padding: 6px 0 5px
}

.apexcharts-tooltip-goals-group,.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {
  display: flex
}

.apexcharts-tooltip-text-goals-label:not(:empty),.apexcharts-tooltip-text-goals-value:not(:empty) {
  margin-top: -6px
}

.apexcharts-tooltip-marker {
  width: 12px;
  height: 12px;
  position: relative;
  top: 0;
  margin-right: 10px;
  border-radius: 50%
}

.apexcharts-tooltip-series-group {
  padding: 0 10px;
  display: none;
  text-align: left;
  justify-content: left;
  align-items: center
}

.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {
  opacity: 1
}

.apexcharts-tooltip-series-group.apexcharts-active,.apexcharts-tooltip-series-group:last-child {
  padding-bottom: 4px
}

.apexcharts-tooltip-series-group-hidden {
  opacity: 0;
  height: 0;
  line-height: 0;
  padding: 0!important
}

.apexcharts-tooltip-y-group {
  padding: 6px 0 5px
}

.apexcharts-custom-tooltip,.apexcharts-tooltip-box {
  padding: 4px 8px
}

.apexcharts-tooltip-boxPlot {
  display: flex;
  flex-direction: column-reverse
}

.apexcharts-tooltip-box>div {
  margin: 4px 0
}

.apexcharts-tooltip-box span.value {
  font-weight: 700
}

.apexcharts-tooltip-rangebar {
  padding: 5px 8px
}

.apexcharts-tooltip-rangebar .category {
  font-weight: 600;
  color: #777
}

.apexcharts-tooltip-rangebar .series-name {
  font-weight: 700;
  display: block;
  margin-bottom: 5px
}

.apexcharts-xaxistooltip,.apexcharts-yaxistooltip {
  opacity: 0;
  pointer-events: none;
  color: #373d3f;
  font-size: 13px;
  text-align: center;
  border-radius: 2px;
  position: absolute;
  z-index: 10;
  background: #eceff1;
  border: 1px solid #90a4ae
}

.apexcharts-xaxistooltip {
  padding: 9px 10px;
  transition: .15s ease all
}

.apexcharts-xaxistooltip.apexcharts-theme-dark {
  background: rgba(0,0,0,.7);
  border: 1px solid rgba(0,0,0,.5);
  color: #fff
}

.apexcharts-xaxistooltip:after,.apexcharts-xaxistooltip:before {
  left: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none
}

.apexcharts-xaxistooltip:after {
  border-color: transparent;
  border-width: 6px;
  margin-left: -6px
}

.apexcharts-xaxistooltip:before {
  border-color: transparent;
  border-width: 7px;
  margin-left: -7px
}

.apexcharts-xaxistooltip-bottom:after,.apexcharts-xaxistooltip-bottom:before {
  bottom: 100%
}

.apexcharts-xaxistooltip-top:after,.apexcharts-xaxistooltip-top:before {
  top: 100%
}

.apexcharts-xaxistooltip-bottom:after {
  border-bottom-color: #eceff1
}

.apexcharts-xaxistooltip-bottom:before {
  border-bottom-color: #90a4ae
}

.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {
  border-bottom-color: rgba(0,0,0,.5)
}

.apexcharts-xaxistooltip-top:after {
  border-top-color: #eceff1
}

.apexcharts-xaxistooltip-top:before {
  border-top-color: #90a4ae
}

.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {
  border-top-color: rgba(0,0,0,.5)
}

.apexcharts-xaxistooltip.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-yaxistooltip {
  padding: 4px 10px
}

.apexcharts-yaxistooltip.apexcharts-theme-dark {
  background: rgba(0,0,0,.7);
  border: 1px solid rgba(0,0,0,.5);
  color: #fff
}

.apexcharts-yaxistooltip:after,.apexcharts-yaxistooltip:before {
  top: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none
}

.apexcharts-yaxistooltip:after {
  border-color: transparent;
  border-width: 6px;
  margin-top: -6px
}

.apexcharts-yaxistooltip:before {
  border-color: transparent;
  border-width: 7px;
  margin-top: -7px
}

.apexcharts-yaxistooltip-left:after,.apexcharts-yaxistooltip-left:before {
  left: 100%
}

.apexcharts-yaxistooltip-right:after,.apexcharts-yaxistooltip-right:before {
  right: 100%
}

.apexcharts-yaxistooltip-left:after {
  border-left-color: #eceff1
}

.apexcharts-yaxistooltip-left:before {
  border-left-color: #90a4ae
}

.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {
  border-left-color: rgba(0,0,0,.5)
}

.apexcharts-yaxistooltip-right:after {
  border-right-color: #eceff1
}

.apexcharts-yaxistooltip-right:before {
  border-right-color: #90a4ae
}

.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {
  border-right-color: rgba(0,0,0,.5)
}

.apexcharts-yaxistooltip.apexcharts-active {
  opacity: 1
}

.apexcharts-yaxistooltip-hidden {
  display: none
}

.apexcharts-xcrosshairs,.apexcharts-ycrosshairs {
  pointer-events: none;
  opacity: 0;
  transition: .15s ease all
}

.apexcharts-xcrosshairs.apexcharts-active,.apexcharts-ycrosshairs.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-ycrosshairs-hidden {
  opacity: 0
}

.apexcharts-selection-rect {
  cursor: move
}

.svg_select_boundingRect,.svg_select_points_rot {
  pointer-events: none;
  opacity: 0;
  visibility: hidden
}

.apexcharts-selection-rect+g .svg_select_boundingRect,.apexcharts-selection-rect+g .svg_select_points_rot {
  opacity: 0;
  visibility: hidden
}

.apexcharts-selection-rect+g .svg_select_points_l,.apexcharts-selection-rect+g .svg_select_points_r {
  cursor: ew-resize;
  opacity: 1;
  visibility: visible
}

.svg_select_points {
  fill: #efefef;
  stroke: #333;
  rx: 2
}

.apexcharts-svg.apexcharts-zoomable.hovering-zoom {
  cursor: crosshair
}

.apexcharts-svg.apexcharts-zoomable.hovering-pan {
  cursor: move
}

.apexcharts-menu-icon,.apexcharts-pan-icon,.apexcharts-reset-icon,.apexcharts-selection-icon,.apexcharts-toolbar-custom-icon,.apexcharts-zoom-icon,.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {
  cursor: pointer;
  width: 20px;
  height: 20px;
  line-height: 24px;
  color: #6e8192;
  text-align: center
}

.apexcharts-menu-icon svg,.apexcharts-reset-icon svg,.apexcharts-zoom-icon svg,.apexcharts-zoomin-icon svg,.apexcharts-zoomout-icon svg {
  fill: #6e8192
}

.apexcharts-selection-icon svg {
  fill: #444;
  transform: scale(.76)
}

.apexcharts-theme-dark .apexcharts-menu-icon svg,.apexcharts-theme-dark .apexcharts-pan-icon svg,.apexcharts-theme-dark .apexcharts-reset-icon svg,.apexcharts-theme-dark .apexcharts-selection-icon svg,.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,.apexcharts-theme-dark .apexcharts-zoom-icon svg,.apexcharts-theme-dark .apexcharts-zoomin-icon svg,.apexcharts-theme-dark .apexcharts-zoomout-icon svg {
  fill: #f3f4f5
}

.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {
  fill: #008ffb
}

.apexcharts-theme-light .apexcharts-menu-icon:hover svg,.apexcharts-theme-light .apexcharts-reset-icon:hover svg,.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {
  fill: #333
}

.apexcharts-menu-icon,.apexcharts-selection-icon {
  position: relative
}

.apexcharts-reset-icon {
  margin-left: 5px
}

.apexcharts-menu-icon,.apexcharts-reset-icon,.apexcharts-zoom-icon {
  transform: scale(.85)
}

.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {
  transform: scale(.7)
}

.apexcharts-zoomout-icon {
  margin-right: 3px
}

.apexcharts-pan-icon {
  transform: scale(.62);
  position: relative;
  left: 1px;
  top: 0
}

.apexcharts-pan-icon svg {
  fill: #fff;
  stroke: #6e8192;
  stroke-width: 2
}

.apexcharts-pan-icon.apexcharts-selected svg {
  stroke: #008ffb
}

.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {
  stroke: #333
}

.apexcharts-toolbar {
  position: absolute;
  z-index: 11;
  max-width: 176px;
  text-align: right;
  border-radius: 3px;
  padding: 0 6px 2px;
  display: flex;
  justify-content: space-between;
  align-items: center
}

.apexcharts-menu {
  background: #fff;
  position: absolute;
  top: 100%;
  border: 1px solid #ddd;
  border-radius: 3px;
  padding: 3px;
  right: 10px;
  opacity: 0;
  min-width: 110px;
  transition: .15s ease all;
  pointer-events: none
}

.apexcharts-menu.apexcharts-menu-open {
  opacity: 1;
  pointer-events: all;
  transition: .15s ease all
}

.apexcharts-menu-item {
  padding: 6px 7px;
  font-size: 12px;
  cursor: pointer
}

.apexcharts-theme-light .apexcharts-menu-item:hover {
  background: #eee
}

.apexcharts-theme-dark .apexcharts-menu {
  background: rgba(0,0,0,.7);
  color: #fff
}

@media screen and (min-width:768px) {
  .apexcharts-canvas:hover .apexcharts-toolbar {
      opacity: 1
  }
}

.apexcharts-canvas .apexcharts-element-hidden,.apexcharts-datalabel.apexcharts-element-hidden,.apexcharts-hide .apexcharts-series-points {
  opacity: 0
}

.apexcharts-hidden-element-shown {
  opacity: 1;
  transition: 0.25s ease all;
}
.apexcharts-datalabel,.apexcharts-datalabel-label,.apexcharts-datalabel-value,.apexcharts-datalabels,.apexcharts-pie-label {
  cursor: default;
  pointer-events: none
}

.apexcharts-pie-label-delay {
  opacity: 0;
  animation-name: opaque;
  animation-duration: .3s;
  animation-fill-mode: forwards;
  animation-timing-function: ease
}

.apexcharts-annotation-rect,.apexcharts-area-series .apexcharts-area,.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-gridline,.apexcharts-line,.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-point-annotation-label,.apexcharts-radar-series path,.apexcharts-radar-series polygon,.apexcharts-toolbar svg,.apexcharts-tooltip .apexcharts-marker,.apexcharts-xaxis-annotation-label,.apexcharts-yaxis-annotation-label,.apexcharts-zoom-rect {
  pointer-events: none
}

.apexcharts-marker {
  transition: .15s ease all
}

.resize-triggers {
  animation: 1ms resizeanim;
  visibility: hidden;
  opacity: 0;
  height: 100%;
  width: 100%;
  overflow: hidden
}

.contract-trigger:before,.resize-triggers,.resize-triggers>div {
  content: " ";
  display: block;
  position: absolute;
  top: 0;
  left: 0
}

.resize-triggers>div {
  height: 100%;
  width: 100%;
  background: #eee;
  overflow: auto
}

.contract-trigger:before {
  overflow: hidden;
  width: 200%;
  height: 200%
}

.apexcharts-bar-goals-markers{
  pointer-events: none
}

.apexcharts-bar-shadows{
  pointer-events: none
}

.apexcharts-rangebar-goals-markers{
  pointer-events: none
}`, f ? d.prepend(t.css) : p.head.appendChild(t.css));
          }
          var S = t.create(t.w.config.series, {});
          if (!S)
            return n(t);
          t.mount(S).then(function() {
            typeof t.w.config.chart.events.mounted == "function" && t.w.config.chart.events.mounted(t, t.w), t.events.fireEvent("mounted", [t, t.w]), n(S);
          }).catch(function(C) {
            a(C);
          });
        } else
          a(new Error("Element not found"));
      });
    } }, { key: "create", value: function(t, n) {
      var a = this.w;
      new Zt(this).initModules();
      var o = this.w.globals;
      if (o.noData = !1, o.animationEnded = !1, this.responsive.checkResponsiveConfig(n), a.config.xaxis.convertedCatToNumeric && new We(a.config).convertCatToNumericXaxis(a.config, this.ctx), this.el === null || (this.core.setupElements(), a.config.chart.type === "treemap" && (a.config.grid.show = !1, a.config.yaxis[0].show = !1), o.svgWidth === 0))
        return o.animationEnded = !0, null;
      var d = me.checkComboSeries(t);
      o.comboCharts = d.comboCharts, o.comboBarCount = d.comboBarCount;
      var f = t.every(function(C) {
        return C.data && C.data.length === 0;
      });
      (t.length === 0 || f) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t), this.theme.init(), new kt(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), o.noData && o.collapsedSeries.length !== o.series.length && !a.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), o.axisCharts && (this.core.coreCalculations(), a.config.xaxis.type !== "category" && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = a.globals.minX, this.ctx.toolbar.maxX = a.globals.maxX), this.formatters.heatmapLabelFormatters(), new me(this).getLargestMarkerSize(), this.dimensions.plotCoords();
      var p = this.core.xySettings();
      this.grid.createGridMask();
      var y = this.core.plotChartType(t, p), S = new Pt(this);
      return S.bringForward(), a.config.dataLabels.background.enabled && S.dataLabelsBackground(), this.core.shiftGraphPosition(), { elGraph: y, xyRatios: p, dimensions: { plot: { left: a.globals.translateX, top: a.globals.translateY, width: a.globals.gridWidth, height: a.globals.gridHeight } } };
    } }, { key: "mount", value: function() {
      var t = this, n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, a = this, o = a.w;
      return new Promise(function(d, f) {
        if (a.el === null)
          return f(new Error("Not enough data to display or target element not found"));
        (n === null || o.globals.allSeriesCollapsed) && a.series.handleNoData(), a.grid = new mn(a);
        var p, y, S = a.grid.drawGrid();
        if (a.annotations = new Ke(a), a.annotations.drawImageAnnos(), a.annotations.drawTextAnnos(), o.config.grid.position === "back" && (S && o.globals.dom.elGraphical.add(S.el), S != null && (p = S.elGridBorders) !== null && p !== void 0 && p.node && o.globals.dom.elGraphical.add(S.elGridBorders)), Array.isArray(n.elGraph))
          for (var C = 0; C < n.elGraph.length; C++)
            o.globals.dom.elGraphical.add(n.elGraph[C]);
        else
          o.globals.dom.elGraphical.add(n.elGraph);
        o.config.grid.position === "front" && (S && o.globals.dom.elGraphical.add(S.el), S != null && (y = S.elGridBorders) !== null && y !== void 0 && y.node && o.globals.dom.elGraphical.add(S.elGridBorders)), o.config.xaxis.crosshairs.position === "front" && a.crosshairs.drawXCrosshairs(), o.config.yaxis[0].crosshairs.position === "front" && a.crosshairs.drawYCrosshairs(), o.config.chart.type !== "treemap" && a.axes.drawAxis(o.config.chart.type, S);
        var E = new Wt(t.ctx, S), L = new jn(t.ctx, S);
        if (S !== null && (E.xAxisLabelCorrections(S.xAxisTickWidth), L.setYAxisTextAlignments(), o.config.yaxis.map(function(P, I) {
          o.globals.ignoreYAxisIndexes.indexOf(I) === -1 && L.yAxisTitleRotate(I, P.opposite);
        })), a.annotations.drawAxesAnnotations(), !o.globals.noData) {
          if (o.config.tooltip.enabled && !o.globals.noData && a.w.globals.tooltip.drawTooltip(n.xyRatios), o.globals.axisCharts && (o.globals.isXNumeric || o.config.xaxis.convertedCatToNumeric || o.globals.isRangeBar))
            (o.config.chart.zoom.enabled || o.config.chart.selection && o.config.chart.selection.enabled || o.config.chart.pan && o.config.chart.pan.enabled) && a.zoomPanSelection.init({ xyRatios: n.xyRatios });
          else {
            var M = o.config.chart.toolbar.tools;
            ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(P) {
              M[P] = !1;
            });
          }
          o.config.chart.toolbar.show && !o.globals.allSeriesCollapsed && a.toolbar.createToolbar();
        }
        o.globals.memory.methodsToExec.length > 0 && o.globals.memory.methodsToExec.forEach(function(P) {
          P.method(P.params, !1, P.context);
        }), o.globals.axisCharts || o.globals.noData || a.core.resizeNonAxisCharts(), d(a);
      });
    } }, { key: "destroy", value: function() {
      var t, n;
      window.removeEventListener("resize", this.windowResizeHandler), this.el.parentNode, t = this.parentResizeHandler, (n = or.get(t)) && (n.disconnect(), or.delete(t));
      var a = this.w.config.chart.id;
      a && Apex._chartInstances.forEach(function(o, d) {
        o.id === K.escapeString(a) && Apex._chartInstances.splice(d, 1);
      }), new Mt(this.ctx).clear({ isUpdating: !1 });
    } }, { key: "updateOptions", value: function(t) {
      var n = this, a = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], o = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], d = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], f = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], p = this.w;
      return p.globals.selection = void 0, t.series && (this.series.resetSeries(!1, !0, !1), t.series.length && t.series[0].data && (t.series = t.series.map(function(y, S) {
        return n.updateHelpers._extendSeries(y, S);
      })), this.updateHelpers.revertDefaultAxisMinMax()), t.xaxis && (t = this.updateHelpers.forceXAxisUpdate(t)), t.yaxis && (t = this.updateHelpers.forceYAxisUpdate(t)), p.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t.theme && (t = this.theme.updateThemeOptions(t)), this.updateHelpers._updateOptions(t, a, o, d, f);
    } }, { key: "updateSeries", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], a = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
      return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t, n, a);
    } }, { key: "appendSeries", value: function(t) {
      var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], a = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], o = this.w.config.series.slice();
      return o.push(t), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(o, n, a);
    } }, { key: "appendData", value: function(t) {
      var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], a = this;
      a.w.globals.dataChanged = !0, a.series.getPreviousPaths();
      for (var o = a.w.config.series.slice(), d = 0; d < o.length; d++)
        if (t[d] !== null && t[d] !== void 0)
          for (var f = 0; f < t[d].data.length; f++)
            o[d].data.push(t[d].data[f]);
      return a.w.config.series = o, n && (a.w.globals.initialSeries = K.clone(a.w.config.series)), this.update();
    } }, { key: "update", value: function(t) {
      var n = this;
      return new Promise(function(a, o) {
        new Mt(n.ctx).clear({ isUpdating: !0 });
        var d = n.create(n.w.config.series, t);
        if (!d)
          return a(n);
        n.mount(d).then(function() {
          typeof n.w.config.chart.events.updated == "function" && n.w.config.chart.events.updated(n, n.w), n.events.fireEvent("updated", [n, n.w]), n.w.globals.isDirty = !0, a(n);
        }).catch(function(f) {
          o(f);
        });
      });
    } }, { key: "getSyncedCharts", value: function() {
      var t = this.getGroupedCharts(), n = [this];
      return t.length && (n = [], t.forEach(function(a) {
        n.push(a);
      })), n;
    } }, { key: "getGroupedCharts", value: function() {
      var t = this;
      return Apex._chartInstances.filter(function(n) {
        if (n.group)
          return !0;
      }).map(function(n) {
        return t.w.config.chart.group === n.group ? n.chart : t;
      });
    } }, { key: "toggleSeries", value: function(t) {
      return this.series.toggleSeries(t);
    } }, { key: "highlightSeriesOnLegendHover", value: function(t, n) {
      return this.series.toggleSeriesOnHover(t, n);
    } }, { key: "showSeries", value: function(t) {
      this.series.showSeries(t);
    } }, { key: "hideSeries", value: function(t) {
      this.series.hideSeries(t);
    } }, { key: "resetSeries", value: function() {
      var t = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
      this.series.resetSeries(t, n);
    } }, { key: "addEventListener", value: function(t, n) {
      this.events.addEventListener(t, n);
    } }, { key: "removeEventListener", value: function(t, n) {
      this.events.removeEventListener(t, n);
    } }, { key: "addXaxisAnnotation", value: function(t) {
      var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, o = this;
      a && (o = a), o.annotations.addXaxisAnnotationExternal(t, n, o);
    } }, { key: "addYaxisAnnotation", value: function(t) {
      var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, o = this;
      a && (o = a), o.annotations.addYaxisAnnotationExternal(t, n, o);
    } }, { key: "addPointAnnotation", value: function(t) {
      var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, o = this;
      a && (o = a), o.annotations.addPointAnnotationExternal(t, n, o);
    } }, { key: "clearAnnotations", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0, n = this;
      t && (n = t), n.annotations.clearAnnotations(n);
    } }, { key: "removeAnnotation", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0, a = this;
      n && (a = n), a.annotations.removeAnnotation(a, t);
    } }, { key: "getChartArea", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
    } }, { key: "getSeriesTotalXRange", value: function(t, n) {
      return this.coreUtils.getSeriesTotalsXRange(t, n);
    } }, { key: "getHighestValueInSeries", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return new pn(this.ctx).getMinYMaxY(t).highestY;
    } }, { key: "getLowestValueInSeries", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return new pn(this.ctx).getMinYMaxY(t).lowestY;
    } }, { key: "getSeriesTotal", value: function() {
      return this.w.globals.seriesTotals;
    } }, { key: "toggleDataPointSelection", value: function(t, n) {
      return this.updateHelpers.toggleDataPointSelection(t, n);
    } }, { key: "zoomX", value: function(t, n) {
      this.ctx.toolbar.zoomUpdateOptions(t, n);
    } }, { key: "setLocale", value: function(t) {
      this.localization.setCurrentLocaleValues(t);
    } }, { key: "dataURI", value: function(t) {
      return new Ht(this.ctx).dataURI(t);
    } }, { key: "exportToCSV", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return new Ht(this.ctx).exportToCSV(t);
    } }, { key: "paper", value: function() {
      return this.w.globals.dom.Paper;
    } }, { key: "_parentResizeCallback", value: function() {
      this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
    } }, { key: "_windowResize", value: function() {
      var t = this;
      clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
        t.w.globals.resized = !0, t.w.globals.dataChanged = !1, t.ctx.update();
      }, 150);
    } }, { key: "_windowResizeHandler", value: function() {
      var t = this.w.config.chart.redrawOnWindowResize;
      typeof t == "function" && (t = t()), t && this._windowResize();
    } }], [{ key: "getChartByID", value: function(t) {
      var n = K.escapeString(t), a = Apex._chartInstances.filter(function(o) {
        return o.id === n;
      })[0];
      return a && a.chart;
    } }, { key: "initOnLoad", value: function() {
      for (var t = document.querySelectorAll("[data-apexcharts]"), n = 0; n < t.length; n++)
        new W(t[n], JSON.parse(t[n].getAttribute("data-options"))).render();
    } }, { key: "exec", value: function(t, n) {
      var a = this.getChartByID(t);
      if (a) {
        a.w.globals.isExecCalled = !0;
        var o = null;
        if (a.publicMethods.indexOf(n) !== -1) {
          for (var d = arguments.length, f = new Array(d > 2 ? d - 2 : 0), p = 2; p < d; p++)
            f[p - 2] = arguments[p];
          o = a[n].apply(a, f);
        }
        return o;
      }
    } }, { key: "merge", value: function(t, n) {
      return K.extend(t, n);
    } }]), W;
  }();
  s.exports = Yn;
})(D1, D1.exports);
var mj = D1.exports, M1 = { exports: {} }, Ty = { exports: {} }, Pn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var eE;
function vj() {
  if (eE)
    return Pn;
  eE = 1;
  var s = typeof Symbol == "function" && Symbol.for, u = s ? Symbol.for("react.element") : 60103, h = s ? Symbol.for("react.portal") : 60106, m = s ? Symbol.for("react.fragment") : 60107, w = s ? Symbol.for("react.strict_mode") : 60108, T = s ? Symbol.for("react.profiler") : 60114, A = s ? Symbol.for("react.provider") : 60109, F = s ? Symbol.for("react.context") : 60110, H = s ? Symbol.for("react.async_mode") : 60111, j = s ? Symbol.for("react.concurrent_mode") : 60111, V = s ? Symbol.for("react.forward_ref") : 60112, q = s ? Symbol.for("react.suspense") : 60113, te = s ? Symbol.for("react.suspense_list") : 60120, ae = s ? Symbol.for("react.memo") : 60115, se = s ? Symbol.for("react.lazy") : 60116, ue = s ? Symbol.for("react.block") : 60121, Ce = s ? Symbol.for("react.fundamental") : 60117, Pe = s ? Symbol.for("react.responder") : 60118, K = s ? Symbol.for("react.scope") : 60119;
  function we(re) {
    if (typeof re == "object" && re !== null) {
      var me = re.$$typeof;
      switch (me) {
        case u:
          switch (re = re.type, re) {
            case H:
            case j:
            case m:
            case T:
            case w:
            case q:
              return re;
            default:
              switch (re = re && re.$$typeof, re) {
                case F:
                case V:
                case se:
                case ae:
                case A:
                  return re;
                default:
                  return me;
              }
          }
        case h:
          return me;
      }
    }
  }
  function Ee(re) {
    return we(re) === j;
  }
  return Pn.AsyncMode = H, Pn.ConcurrentMode = j, Pn.ContextConsumer = F, Pn.ContextProvider = A, Pn.Element = u, Pn.ForwardRef = V, Pn.Fragment = m, Pn.Lazy = se, Pn.Memo = ae, Pn.Portal = h, Pn.Profiler = T, Pn.StrictMode = w, Pn.Suspense = q, Pn.isAsyncMode = function(re) {
    return Ee(re) || we(re) === H;
  }, Pn.isConcurrentMode = Ee, Pn.isContextConsumer = function(re) {
    return we(re) === F;
  }, Pn.isContextProvider = function(re) {
    return we(re) === A;
  }, Pn.isElement = function(re) {
    return typeof re == "object" && re !== null && re.$$typeof === u;
  }, Pn.isForwardRef = function(re) {
    return we(re) === V;
  }, Pn.isFragment = function(re) {
    return we(re) === m;
  }, Pn.isLazy = function(re) {
    return we(re) === se;
  }, Pn.isMemo = function(re) {
    return we(re) === ae;
  }, Pn.isPortal = function(re) {
    return we(re) === h;
  }, Pn.isProfiler = function(re) {
    return we(re) === T;
  }, Pn.isStrictMode = function(re) {
    return we(re) === w;
  }, Pn.isSuspense = function(re) {
    return we(re) === q;
  }, Pn.isValidElementType = function(re) {
    return typeof re == "string" || typeof re == "function" || re === m || re === j || re === T || re === w || re === q || re === te || typeof re == "object" && re !== null && (re.$$typeof === se || re.$$typeof === ae || re.$$typeof === A || re.$$typeof === F || re.$$typeof === V || re.$$typeof === Ce || re.$$typeof === Pe || re.$$typeof === K || re.$$typeof === ue);
  }, Pn.typeOf = we, Pn;
}
var Nn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tE;
function yj() {
  return tE || (tE = 1, process.env.NODE_ENV !== "production" && function() {
    var s = typeof Symbol == "function" && Symbol.for, u = s ? Symbol.for("react.element") : 60103, h = s ? Symbol.for("react.portal") : 60106, m = s ? Symbol.for("react.fragment") : 60107, w = s ? Symbol.for("react.strict_mode") : 60108, T = s ? Symbol.for("react.profiler") : 60114, A = s ? Symbol.for("react.provider") : 60109, F = s ? Symbol.for("react.context") : 60110, H = s ? Symbol.for("react.async_mode") : 60111, j = s ? Symbol.for("react.concurrent_mode") : 60111, V = s ? Symbol.for("react.forward_ref") : 60112, q = s ? Symbol.for("react.suspense") : 60113, te = s ? Symbol.for("react.suspense_list") : 60120, ae = s ? Symbol.for("react.memo") : 60115, se = s ? Symbol.for("react.lazy") : 60116, ue = s ? Symbol.for("react.block") : 60121, Ce = s ? Symbol.for("react.fundamental") : 60117, Pe = s ? Symbol.for("react.responder") : 60118, K = s ? Symbol.for("react.scope") : 60119;
    function we(qe) {
      return typeof qe == "string" || typeof qe == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      qe === m || qe === j || qe === T || qe === w || qe === q || qe === te || typeof qe == "object" && qe !== null && (qe.$$typeof === se || qe.$$typeof === ae || qe.$$typeof === A || qe.$$typeof === F || qe.$$typeof === V || qe.$$typeof === Ce || qe.$$typeof === Pe || qe.$$typeof === K || qe.$$typeof === ue);
    }
    function Ee(qe) {
      if (typeof qe == "object" && qe !== null) {
        var pn = qe.$$typeof;
        switch (pn) {
          case u:
            var jn = qe.type;
            switch (jn) {
              case H:
              case j:
              case m:
              case T:
              case w:
              case q:
                return jn;
              default:
                var ir = jn && jn.$$typeof;
                switch (ir) {
                  case F:
                  case V:
                  case se:
                  case ae:
                  case A:
                    return ir;
                  default:
                    return pn;
                }
            }
          case h:
            return pn;
        }
      }
    }
    var re = H, me = j, Me = F, Je = A, Ve = u, Xe = V, it = m, ht = se, Ke = ae, Ze = h, Tt = T, It = w, Jt = q, We = !1;
    function pt(qe) {
      return We || (We = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), ye(qe) || Ee(qe) === H;
    }
    function ye(qe) {
      return Ee(qe) === j;
    }
    function je(qe) {
      return Ee(qe) === F;
    }
    function Qe(qe) {
      return Ee(qe) === A;
    }
    function kt(qe) {
      return typeof qe == "object" && qe !== null && qe.$$typeof === u;
    }
    function mt(qe) {
      return Ee(qe) === V;
    }
    function Pt(qe) {
      return Ee(qe) === m;
    }
    function st(qe) {
      return Ee(qe) === se;
    }
    function Nt(qe) {
      return Ee(qe) === ae;
    }
    function Et(qe) {
      return Ee(qe) === h;
    }
    function Ht(qe) {
      return Ee(qe) === T;
    }
    function Wt(qe) {
      return Ee(qe) === w;
    }
    function mn(qe) {
      return Ee(qe) === q;
    }
    Nn.AsyncMode = re, Nn.ConcurrentMode = me, Nn.ContextConsumer = Me, Nn.ContextProvider = Je, Nn.Element = Ve, Nn.ForwardRef = Xe, Nn.Fragment = it, Nn.Lazy = ht, Nn.Memo = Ke, Nn.Portal = Ze, Nn.Profiler = Tt, Nn.StrictMode = It, Nn.Suspense = Jt, Nn.isAsyncMode = pt, Nn.isConcurrentMode = ye, Nn.isContextConsumer = je, Nn.isContextProvider = Qe, Nn.isElement = kt, Nn.isForwardRef = mt, Nn.isFragment = Pt, Nn.isLazy = st, Nn.isMemo = Nt, Nn.isPortal = Et, Nn.isProfiler = Ht, Nn.isStrictMode = Wt, Nn.isSuspense = mn, Nn.isValidElementType = we, Nn.typeOf = Ee;
  }()), Nn;
}
var nE;
function GR() {
  return nE || (nE = 1, process.env.NODE_ENV === "production" ? Ty.exports = vj() : Ty.exports = yj()), Ty.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var t1, rE;
function xj() {
  if (rE)
    return t1;
  rE = 1;
  var s = Object.getOwnPropertySymbols, u = Object.prototype.hasOwnProperty, h = Object.prototype.propertyIsEnumerable;
  function m(T) {
    if (T == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(T);
  }
  function w() {
    try {
      if (!Object.assign)
        return !1;
      var T = new String("abc");
      if (T[5] = "de", Object.getOwnPropertyNames(T)[0] === "5")
        return !1;
      for (var A = {}, F = 0; F < 10; F++)
        A["_" + String.fromCharCode(F)] = F;
      var H = Object.getOwnPropertyNames(A).map(function(V) {
        return A[V];
      });
      if (H.join("") !== "0123456789")
        return !1;
      var j = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(V) {
        j[V] = V;
      }), Object.keys(Object.assign({}, j)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return t1 = w() ? Object.assign : function(T, A) {
    for (var F, H = m(T), j, V = 1; V < arguments.length; V++) {
      F = Object(arguments[V]);
      for (var q in F)
        u.call(F, q) && (H[q] = F[q]);
      if (s) {
        j = s(F);
        for (var te = 0; te < j.length; te++)
          h.call(F, j[te]) && (H[j[te]] = F[j[te]]);
      }
    }
    return H;
  }, t1;
}
var n1, aE;
function gS() {
  if (aE)
    return n1;
  aE = 1;
  var s = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return n1 = s, n1;
}
var r1, iE;
function $R() {
  return iE || (iE = 1, r1 = Function.call.bind(Object.prototype.hasOwnProperty)), r1;
}
var a1, sE;
function bj() {
  if (sE)
    return a1;
  sE = 1;
  var s = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var u = gS(), h = {}, m = $R();
    s = function(T) {
      var A = "Warning: " + T;
      typeof console < "u" && console.error(A);
      try {
        throw new Error(A);
      } catch {
      }
    };
  }
  function w(T, A, F, H, j) {
    if (process.env.NODE_ENV !== "production") {
      for (var V in T)
        if (m(T, V)) {
          var q;
          try {
            if (typeof T[V] != "function") {
              var te = Error(
                (H || "React class") + ": " + F + " type `" + V + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof T[V] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw te.name = "Invariant Violation", te;
            }
            q = T[V](A, V, H, F, null, u);
          } catch (se) {
            q = se;
          }
          if (q && !(q instanceof Error) && s(
            (H || "React class") + ": type specification of " + F + " `" + V + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof q + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), q instanceof Error && !(q.message in h)) {
            h[q.message] = !0;
            var ae = j ? j() : "";
            s(
              "Failed " + F + " type: " + q.message + (ae ?? "")
            );
          }
        }
    }
  }
  return w.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (h = {});
  }, a1 = w, a1;
}
var i1, oE;
function wj() {
  if (oE)
    return i1;
  oE = 1;
  var s = GR(), u = xj(), h = gS(), m = $R(), w = bj(), T = function() {
  };
  process.env.NODE_ENV !== "production" && (T = function(F) {
    var H = "Warning: " + F;
    typeof console < "u" && console.error(H);
    try {
      throw new Error(H);
    } catch {
    }
  });
  function A() {
    return null;
  }
  return i1 = function(F, H) {
    var j = typeof Symbol == "function" && Symbol.iterator, V = "@@iterator";
    function q(ye) {
      var je = ye && (j && ye[j] || ye[V]);
      if (typeof je == "function")
        return je;
    }
    var te = "<<anonymous>>", ae = {
      array: Pe("array"),
      bigint: Pe("bigint"),
      bool: Pe("boolean"),
      func: Pe("function"),
      number: Pe("number"),
      object: Pe("object"),
      string: Pe("string"),
      symbol: Pe("symbol"),
      any: K(),
      arrayOf: we,
      element: Ee(),
      elementType: re(),
      instanceOf: me,
      node: Xe(),
      objectOf: Je,
      oneOf: Me,
      oneOfType: Ve,
      shape: ht,
      exact: Ke
    };
    function se(ye, je) {
      return ye === je ? ye !== 0 || 1 / ye === 1 / je : ye !== ye && je !== je;
    }
    function ue(ye, je) {
      this.message = ye, this.data = je && typeof je == "object" ? je : {}, this.stack = "";
    }
    ue.prototype = Error.prototype;
    function Ce(ye) {
      if (process.env.NODE_ENV !== "production")
        var je = {}, Qe = 0;
      function kt(Pt, st, Nt, Et, Ht, Wt, mn) {
        if (Et = Et || te, Wt = Wt || Nt, mn !== h) {
          if (H) {
            var qe = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw qe.name = "Invariant Violation", qe;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var pn = Et + ":" + Nt;
            !je[pn] && // Avoid spamming the console because they are often not actionable except for lib authors
            Qe < 3 && (T(
              "You are manually calling a React.PropTypes validation function for the `" + Wt + "` prop on `" + Et + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), je[pn] = !0, Qe++);
          }
        }
        return st[Nt] == null ? Pt ? st[Nt] === null ? new ue("The " + Ht + " `" + Wt + "` is marked as required " + ("in `" + Et + "`, but its value is `null`.")) : new ue("The " + Ht + " `" + Wt + "` is marked as required in " + ("`" + Et + "`, but its value is `undefined`.")) : null : ye(st, Nt, Et, Ht, Wt);
      }
      var mt = kt.bind(null, !1);
      return mt.isRequired = kt.bind(null, !0), mt;
    }
    function Pe(ye) {
      function je(Qe, kt, mt, Pt, st, Nt) {
        var Et = Qe[kt], Ht = It(Et);
        if (Ht !== ye) {
          var Wt = Jt(Et);
          return new ue(
            "Invalid " + Pt + " `" + st + "` of type " + ("`" + Wt + "` supplied to `" + mt + "`, expected ") + ("`" + ye + "`."),
            { expectedType: ye }
          );
        }
        return null;
      }
      return Ce(je);
    }
    function K() {
      return Ce(A);
    }
    function we(ye) {
      function je(Qe, kt, mt, Pt, st) {
        if (typeof ye != "function")
          return new ue("Property `" + st + "` of component `" + mt + "` has invalid PropType notation inside arrayOf.");
        var Nt = Qe[kt];
        if (!Array.isArray(Nt)) {
          var Et = It(Nt);
          return new ue("Invalid " + Pt + " `" + st + "` of type " + ("`" + Et + "` supplied to `" + mt + "`, expected an array."));
        }
        for (var Ht = 0; Ht < Nt.length; Ht++) {
          var Wt = ye(Nt, Ht, mt, Pt, st + "[" + Ht + "]", h);
          if (Wt instanceof Error)
            return Wt;
        }
        return null;
      }
      return Ce(je);
    }
    function Ee() {
      function ye(je, Qe, kt, mt, Pt) {
        var st = je[Qe];
        if (!F(st)) {
          var Nt = It(st);
          return new ue("Invalid " + mt + " `" + Pt + "` of type " + ("`" + Nt + "` supplied to `" + kt + "`, expected a single ReactElement."));
        }
        return null;
      }
      return Ce(ye);
    }
    function re() {
      function ye(je, Qe, kt, mt, Pt) {
        var st = je[Qe];
        if (!s.isValidElementType(st)) {
          var Nt = It(st);
          return new ue("Invalid " + mt + " `" + Pt + "` of type " + ("`" + Nt + "` supplied to `" + kt + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return Ce(ye);
    }
    function me(ye) {
      function je(Qe, kt, mt, Pt, st) {
        if (!(Qe[kt] instanceof ye)) {
          var Nt = ye.name || te, Et = pt(Qe[kt]);
          return new ue("Invalid " + Pt + " `" + st + "` of type " + ("`" + Et + "` supplied to `" + mt + "`, expected ") + ("instance of `" + Nt + "`."));
        }
        return null;
      }
      return Ce(je);
    }
    function Me(ye) {
      if (!Array.isArray(ye))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? T(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : T("Invalid argument supplied to oneOf, expected an array.")), A;
      function je(Qe, kt, mt, Pt, st) {
        for (var Nt = Qe[kt], Et = 0; Et < ye.length; Et++)
          if (se(Nt, ye[Et]))
            return null;
        var Ht = JSON.stringify(ye, function(mn, qe) {
          var pn = Jt(qe);
          return pn === "symbol" ? String(qe) : qe;
        });
        return new ue("Invalid " + Pt + " `" + st + "` of value `" + String(Nt) + "` " + ("supplied to `" + mt + "`, expected one of " + Ht + "."));
      }
      return Ce(je);
    }
    function Je(ye) {
      function je(Qe, kt, mt, Pt, st) {
        if (typeof ye != "function")
          return new ue("Property `" + st + "` of component `" + mt + "` has invalid PropType notation inside objectOf.");
        var Nt = Qe[kt], Et = It(Nt);
        if (Et !== "object")
          return new ue("Invalid " + Pt + " `" + st + "` of type " + ("`" + Et + "` supplied to `" + mt + "`, expected an object."));
        for (var Ht in Nt)
          if (m(Nt, Ht)) {
            var Wt = ye(Nt, Ht, mt, Pt, st + "." + Ht, h);
            if (Wt instanceof Error)
              return Wt;
          }
        return null;
      }
      return Ce(je);
    }
    function Ve(ye) {
      if (!Array.isArray(ye))
        return process.env.NODE_ENV !== "production" && T("Invalid argument supplied to oneOfType, expected an instance of array."), A;
      for (var je = 0; je < ye.length; je++) {
        var Qe = ye[je];
        if (typeof Qe != "function")
          return T(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + We(Qe) + " at index " + je + "."
          ), A;
      }
      function kt(mt, Pt, st, Nt, Et) {
        for (var Ht = [], Wt = 0; Wt < ye.length; Wt++) {
          var mn = ye[Wt], qe = mn(mt, Pt, st, Nt, Et, h);
          if (qe == null)
            return null;
          qe.data && m(qe.data, "expectedType") && Ht.push(qe.data.expectedType);
        }
        var pn = Ht.length > 0 ? ", expected one of type [" + Ht.join(", ") + "]" : "";
        return new ue("Invalid " + Nt + " `" + Et + "` supplied to " + ("`" + st + "`" + pn + "."));
      }
      return Ce(kt);
    }
    function Xe() {
      function ye(je, Qe, kt, mt, Pt) {
        return Ze(je[Qe]) ? null : new ue("Invalid " + mt + " `" + Pt + "` supplied to " + ("`" + kt + "`, expected a ReactNode."));
      }
      return Ce(ye);
    }
    function it(ye, je, Qe, kt, mt) {
      return new ue(
        (ye || "React class") + ": " + je + " type `" + Qe + "." + kt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + mt + "`."
      );
    }
    function ht(ye) {
      function je(Qe, kt, mt, Pt, st) {
        var Nt = Qe[kt], Et = It(Nt);
        if (Et !== "object")
          return new ue("Invalid " + Pt + " `" + st + "` of type `" + Et + "` " + ("supplied to `" + mt + "`, expected `object`."));
        for (var Ht in ye) {
          var Wt = ye[Ht];
          if (typeof Wt != "function")
            return it(mt, Pt, st, Ht, Jt(Wt));
          var mn = Wt(Nt, Ht, mt, Pt, st + "." + Ht, h);
          if (mn)
            return mn;
        }
        return null;
      }
      return Ce(je);
    }
    function Ke(ye) {
      function je(Qe, kt, mt, Pt, st) {
        var Nt = Qe[kt], Et = It(Nt);
        if (Et !== "object")
          return new ue("Invalid " + Pt + " `" + st + "` of type `" + Et + "` " + ("supplied to `" + mt + "`, expected `object`."));
        var Ht = u({}, Qe[kt], ye);
        for (var Wt in Ht) {
          var mn = ye[Wt];
          if (m(ye, Wt) && typeof mn != "function")
            return it(mt, Pt, st, Wt, Jt(mn));
          if (!mn)
            return new ue(
              "Invalid " + Pt + " `" + st + "` key `" + Wt + "` supplied to `" + mt + "`.\nBad object: " + JSON.stringify(Qe[kt], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(ye), null, "  ")
            );
          var qe = mn(Nt, Wt, mt, Pt, st + "." + Wt, h);
          if (qe)
            return qe;
        }
        return null;
      }
      return Ce(je);
    }
    function Ze(ye) {
      switch (typeof ye) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !ye;
        case "object":
          if (Array.isArray(ye))
            return ye.every(Ze);
          if (ye === null || F(ye))
            return !0;
          var je = q(ye);
          if (je) {
            var Qe = je.call(ye), kt;
            if (je !== ye.entries) {
              for (; !(kt = Qe.next()).done; )
                if (!Ze(kt.value))
                  return !1;
            } else
              for (; !(kt = Qe.next()).done; ) {
                var mt = kt.value;
                if (mt && !Ze(mt[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Tt(ye, je) {
      return ye === "symbol" ? !0 : je ? je["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && je instanceof Symbol : !1;
    }
    function It(ye) {
      var je = typeof ye;
      return Array.isArray(ye) ? "array" : ye instanceof RegExp ? "object" : Tt(je, ye) ? "symbol" : je;
    }
    function Jt(ye) {
      if (typeof ye > "u" || ye === null)
        return "" + ye;
      var je = It(ye);
      if (je === "object") {
        if (ye instanceof Date)
          return "date";
        if (ye instanceof RegExp)
          return "regexp";
      }
      return je;
    }
    function We(ye) {
      var je = Jt(ye);
      switch (je) {
        case "array":
        case "object":
          return "an " + je;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + je;
        default:
          return je;
      }
    }
    function pt(ye) {
      return !ye.constructor || !ye.constructor.name ? te : ye.constructor.name;
    }
    return ae.checkPropTypes = w, ae.resetWarningCache = w.resetWarningCache, ae.PropTypes = ae, ae;
  }, i1;
}
var s1, lE;
function Sj() {
  if (lE)
    return s1;
  lE = 1;
  var s = gS();
  function u() {
  }
  function h() {
  }
  return h.resetWarningCache = u, s1 = function() {
    function m(A, F, H, j, V, q) {
      if (q !== s) {
        var te = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw te.name = "Invariant Violation", te;
      }
    }
    m.isRequired = m;
    function w() {
      return m;
    }
    var T = {
      array: m,
      bigint: m,
      bool: m,
      func: m,
      number: m,
      object: m,
      string: m,
      symbol: m,
      any: m,
      arrayOf: w,
      element: m,
      elementType: m,
      instanceOf: w,
      node: m,
      objectOf: w,
      oneOf: w,
      oneOfType: w,
      shape: w,
      exact: w,
      checkPropTypes: h,
      resetWarningCache: u
    };
    return T.PropTypes = T, T;
  }, s1;
}
if (process.env.NODE_ENV !== "production") {
  var kj = GR(), Cj = !0;
  M1.exports = wj()(kj.isElement, Cj);
} else
  M1.exports = Sj()();
var Tj = M1.exports, qR;
Object.defineProperty(VR, "__esModule", { value: !0 });
var Aj = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(s) {
  return typeof s;
} : function(s) {
  return s && typeof Symbol == "function" && s.constructor === Symbol && s !== Symbol.prototype ? "symbol" : typeof s;
}, Ej = Object.assign || function(s) {
  for (var u = 1; u < arguments.length; u++) {
    var h, m = arguments[u];
    for (h in m)
      Object.prototype.hasOwnProperty.call(m, h) && (s[h] = m[h]);
  }
  return s;
}, Rj = function() {
  function s(u, h) {
    for (var m = 0; m < h.length; m++) {
      var w = h[m];
      w.enumerable = w.enumerable || !1, w.configurable = !0, "value" in w && (w.writable = !0), Object.defineProperty(u, w.key, w);
    }
  }
  return function(u, h, m) {
    return h && s(u.prototype, h), m && s(u, m), u;
  };
}(), Lj = mj, ZR = mS(Lj), QR = va, sg = mS(QR), Oj = Tj, Sl = mS(Oj);
function mS(s) {
  return s && s.__esModule ? s : { default: s };
}
function Dj(s, u, h) {
  return u in s ? Object.defineProperty(s, u, { value: h, enumerable: !0, configurable: !0, writable: !0 }) : s[u] = h, s;
}
function Mj(s, u) {
  var h, m = {};
  for (h in s)
    0 <= u.indexOf(h) || Object.prototype.hasOwnProperty.call(s, h) && (m[h] = s[h]);
  return m;
}
function _j(s, u) {
  if (!(s instanceof u))
    throw new TypeError("Cannot call a class as a function");
}
function Pj(s, u) {
  if (s)
    return !u || typeof u != "object" && typeof u != "function" ? s : u;
  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
}
function Nj(s, u) {
  if (typeof u != "function" && u !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof u);
  s.prototype = Object.create(u && u.prototype, { constructor: { value: s, enumerable: !1, writable: !0, configurable: !0 } }), u && (Object.setPrototypeOf ? Object.setPrototypeOf(s, u) : s.__proto__ = u);
}
window.ApexCharts = ZR.default;
var uE = function() {
  function s(u) {
    _j(this, s);
    var h = Pj(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, u));
    return sg.default.createRef ? h.chartRef = sg.default.createRef() : h.setRef = function(m) {
      return h.chartRef = m;
    }, h.chart = null, h;
  }
  return Nj(s, QR.Component), Rj(s, [{ key: "render", value: function() {
    var u = Mj(this.props, []);
    return sg.default.createElement("div", Ej({ ref: sg.default.createRef ? this.chartRef : this.setRef }, u));
  } }, { key: "componentDidMount", value: function() {
    var u = sg.default.createRef ? this.chartRef.current : this.chartRef;
    this.chart = new ZR.default(u, this.getConfig()), this.chart.render();
  } }, { key: "getConfig", value: function() {
    var T = this.props, u = T.type, h = T.height, m = T.width, w = T.series, T = T.options;
    return this.extend(T, { chart: { type: u, height: h, width: m }, series: w });
  } }, { key: "isObject", value: function(u) {
    return u && (u === void 0 ? "undefined" : Aj(u)) === "object" && !Array.isArray(u) && u != null;
  } }, { key: "extend", value: function(u, h) {
    var m = this, w = (typeof Object.assign != "function" && (Object.assign = function(T) {
      if (T == null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var A = Object(T), F = 1; F < arguments.length; F++) {
        var H = arguments[F];
        if (H != null)
          for (var j in H)
            H.hasOwnProperty(j) && (A[j] = H[j]);
      }
      return A;
    }), Object.assign({}, u));
    return this.isObject(u) && this.isObject(h) && Object.keys(h).forEach(function(T) {
      m.isObject(h[T]) && T in u ? w[T] = m.extend(u[T], h[T]) : Object.assign(w, Dj({}, T, h[T]));
    }), w;
  } }, { key: "componentDidUpdate", value: function(u) {
    if (!this.chart)
      return null;
    var w = this.props, F = w.options, h = w.series, m = w.height, w = w.width, T = JSON.stringify(u.options), A = JSON.stringify(u.series), F = JSON.stringify(F), H = JSON.stringify(h);
    T === F && A === H && m === u.height && w === u.width || (A !== H && T === F && m === u.height && w === u.width ? this.chart.updateSeries(h) : this.chart.updateOptions(this.getConfig()));
  } }, { key: "componentWillUnmount", value: function() {
    this.chart && typeof this.chart.destroy == "function" && this.chart.destroy();
  } }]), s;
}();
(qR = VR.default = uE).propTypes = { type: Sl.default.string.isRequired, width: Sl.default.oneOfType([Sl.default.string, Sl.default.number]), height: Sl.default.oneOfType([Sl.default.string, Sl.default.number]), series: Sl.default.array.isRequired, options: Sl.default.object.isRequired }, uE.defaultProps = { type: "line", width: "100%", height: "auto" };
const zj = ({
  data: s,
  groupBy: u,
  labels: h,
  groupByFormatter: m = (T) => T,
  hidden: w = []
}) => {
  if ((s == null ? void 0 : s.length) === 0)
    return { series: [], labels: [] };
  const T = [];
  s.forEach((V) => {
    Object.keys(V).forEach((q) => {
      V[q] === 0 && T.push(q);
    });
  });
  const A = [], F = {};
  let H = 0;
  const j = [];
  return Object.keys(s[0]).forEach((V) => {
    w.includes(V) || u === V || T.includes(V) || (A.push({ name: V, data: [] }), F[V] = H, H++);
  }), s.forEach((V) => {
    Object.entries(V).forEach(([q, te]) => {
      var se, ue;
      if (u === q && j.push(
        m(te) ?? ""
      ), w.includes(q) || T.includes(q))
        return;
      let ae = 0;
      typeof te == "number" && (ae = te), (ue = (se = A[F[q]]) == null ? void 0 : se.data) == null || ue.push(ae);
    });
  }), { series: A, labels: j ?? h };
}, Ij = ({
  type: s = "bar",
  foreColor: u = "var(--neutral-content)",
  id: h = "any",
  labelFormatter: m = (F) => F,
  dataLabelFormatter: w = (F) => F,
  series: T = [],
  labels: A = []
}) => ({
  options: {
    chart: {
      id: h,
      type: s,
      foreColor: u,
      toolbar: {
        show: !0
      }
    },
    plotOptions: {
      bar: {
        borderRadius: 4,
        borderRadiusApplication: "around"
      }
    },
    colors: [
      "var(--info)",
      "var(--info-hover)",
      "var(--danger)",
      "var(--danger-hover)",
      "var(--warning)",
      "var(--warning-hover)",
      "var(--primary)",
      "var(--primary-hover)"
    ],
    grid: {
      show: !1
    },
    legend: {
      position: "top",
      formatter: w
    },
    xaxis: {
      categories: A,
      labels: {
        formatter: m,
        style: {
          colors: ["var(--text-neutral-content)"]
        }
      }
    },
    dataLabels: {
      enabled: !0
      // formatter: dataLabelFormatter,
    },
    tooltip: {
      x: {},
      y: {
        title: {
          formatter: w
        }
      }
    },
    yaxis: {
      show: !1
    }
  },
  series: T ?? []
}), tB = ({
  data: s,
  labelFormatter: u,
  groupBy: h,
  translation: m = "common",
  type: w = "bar",
  hidden: T = [],
  color: A = "neutral-content"
}) => (hE({ language: "pt-BR" }), /* @__PURE__ */ ce.jsx(
  qR,
  {
    type: w,
    ...Ij({
      type: w,
      labelFormatter: u,
      dataLabelFormatter: (F) => nr(`${m}.${F}`),
      foreColor: `var(--${A})`,
      id: "any",
      ...zj({
        data: s,
        groupBy: h,
        hidden: T
      })
    })
  }
));
export {
  Wj as Chart,
  Vj as DateRangePicker,
  $j as DetailedWorkDay,
  tB as GenericChart,
  qj as Header,
  nj as Modal,
  Gj as MultiSelect,
  Yy as Select,
  Xj as ShowPassword,
  Zj as Sidebar,
  Qj as Table,
  TN as Textfield,
  eB as changeDesignLanguage,
  j1 as debounce,
  Jj as initDesignTranslator,
  XR as useModal,
  ij as useScroll,
  Kj as useToast
};
