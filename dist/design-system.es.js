import vi, { Fragment as sE, useRef as hr, useState as wr, useCallback as Mu, useEffect as Yf, useDebugValue as __ } from "react";
function P_(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var i1 = { exports: {} }, Kp = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qA;
function N_() {
  if (qA)
    return Kp;
  qA = 1;
  var s = vi, u = Symbol.for("react.element"), h = Symbol.for("react.fragment"), v = Object.prototype.hasOwnProperty, w = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, A = { key: !0, ref: !0, __self: !0, __source: !0 };
  function T(F, H, U) {
    var $, q = {}, te = null, se = null;
    U !== void 0 && (te = "" + U), H.key !== void 0 && (te = "" + H.key), H.ref !== void 0 && (se = H.ref);
    for ($ in H)
      v.call(H, $) && !A.hasOwnProperty($) && (q[$] = H[$]);
    if (F && F.defaultProps)
      for ($ in H = F.defaultProps, H)
        q[$] === void 0 && (q[$] = H[$]);
    return { $$typeof: u, type: F, key: te, ref: se, props: q, _owner: w.current };
  }
  return Kp.Fragment = h, Kp.jsx = T, Kp.jsxs = T, Kp;
}
var Jp = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ZA;
function z_() {
  return ZA || (ZA = 1, process.env.NODE_ENV !== "production" && function() {
    var s = vi, u = Symbol.for("react.element"), h = Symbol.for("react.portal"), v = Symbol.for("react.fragment"), w = Symbol.for("react.strict_mode"), A = Symbol.for("react.profiler"), T = Symbol.for("react.provider"), F = Symbol.for("react.context"), H = Symbol.for("react.forward_ref"), U = Symbol.for("react.suspense"), $ = Symbol.for("react.suspense_list"), q = Symbol.for("react.memo"), te = Symbol.for("react.lazy"), se = Symbol.for("react.offscreen"), ae = Symbol.iterator, ue = "@@iterator";
    function Re(le) {
      if (le === null || typeof le != "object")
        return null;
      var Ye = ae && le[ae] || le[ue];
      return typeof Ye == "function" ? Ye : null;
    }
    var Ne = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function Q(le) {
      {
        for (var Ye = arguments.length, et = new Array(Ye > 1 ? Ye - 1 : 0), Dt = 1; Dt < Ye; Dt++)
          et[Dt - 1] = arguments[Dt];
        we("error", le, et);
      }
    }
    function we(le, Ye, et) {
      {
        var Dt = Ne.ReactDebugCurrentFrame, qt = Dt.getStackAddendum();
        qt !== "" && (Ye += "%s", et = et.concat([qt]));
        var cn = et.map(function(Zt) {
          return String(Zt);
        });
        cn.unshift("Warning: " + Ye), Function.prototype.apply.call(console[le], console, cn);
      }
    }
    var Ee = !1, re = !1, ve = !1, Le = !1, Qe = !1, Be;
    Be = Symbol.for("react.module.reference");
    function Ge(le) {
      return !!(typeof le == "string" || typeof le == "function" || le === v || le === A || Qe || le === w || le === U || le === $ || Le || le === se || Ee || re || ve || typeof le == "object" && le !== null && (le.$$typeof === te || le.$$typeof === q || le.$$typeof === T || le.$$typeof === F || le.$$typeof === H || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      le.$$typeof === Be || le.getModuleId !== void 0));
    }
    function ft(le, Ye, et) {
      var Dt = le.displayName;
      if (Dt)
        return Dt;
      var qt = Ye.displayName || Ye.name || "";
      return qt !== "" ? et + "(" + qt + ")" : et;
    }
    function wt(le) {
      return le.displayName || "Context";
    }
    function st(le) {
      if (le == null)
        return null;
      if (typeof le.tag == "number" && Q("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof le == "function")
        return le.displayName || le.name || null;
      if (typeof le == "string")
        return le;
      switch (le) {
        case v:
          return "Fragment";
        case h:
          return "Portal";
        case A:
          return "Profiler";
        case w:
          return "StrictMode";
        case U:
          return "Suspense";
        case $:
          return "SuspenseList";
      }
      if (typeof le == "object")
        switch (le.$$typeof) {
          case F:
            var Ye = le;
            return wt(Ye) + ".Consumer";
          case T:
            var et = le;
            return wt(et._context) + ".Provider";
          case H:
            return ft(le, le.render, "ForwardRef");
          case q:
            var Dt = le.displayName || null;
            return Dt !== null ? Dt : st(le.type) || "Memo";
          case te: {
            var qt = le, cn = qt._payload, Zt = qt._init;
            try {
              return st(Zt(cn));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var it = Object.assign, Ht = 0, Mt, an, We, pt, ye, je, Je;
    function kt() {
    }
    kt.__reactDisabledLog = !0;
    function At() {
      {
        if (Ht === 0) {
          Mt = console.log, an = console.info, We = console.warn, pt = console.error, ye = console.group, je = console.groupCollapsed, Je = console.groupEnd;
          var le = {
            configurable: !0,
            enumerable: !0,
            value: kt,
            writable: !0
          };
          Object.defineProperties(console, {
            info: le,
            log: le,
            warn: le,
            error: le,
            group: le,
            groupCollapsed: le,
            groupEnd: le
          });
        }
        Ht++;
      }
    }
    function jt() {
      {
        if (Ht--, Ht === 0) {
          var le = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: it({}, le, {
              value: Mt
            }),
            info: it({}, le, {
              value: an
            }),
            warn: it({}, le, {
              value: We
            }),
            error: it({}, le, {
              value: pt
            }),
            group: it({}, le, {
              value: ye
            }),
            groupCollapsed: it({}, le, {
              value: je
            }),
            groupEnd: it({}, le, {
              value: Je
            })
          });
        }
        Ht < 0 && Q("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ot = Ne.ReactCurrentDispatcher, It;
    function Et(le, Ye, et) {
      {
        if (It === void 0)
          try {
            throw Error();
          } catch (qt) {
            var Dt = qt.stack.trim().match(/\n( *(at )?)/);
            It = Dt && Dt[1] || "";
          }
        return `
` + It + le;
      }
    }
    var Ut = !1, Bt;
    {
      var vn = typeof WeakMap == "function" ? WeakMap : Map;
      Bt = new vn();
    }
    function Ze(le, Ye) {
      if (!le || Ut)
        return "";
      {
        var et = Bt.get(le);
        if (et !== void 0)
          return et;
      }
      var Dt;
      Ut = !0;
      var qt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var cn;
      cn = ot.current, ot.current = null, At();
      try {
        if (Ye) {
          var Zt = function() {
            throw Error();
          };
          if (Object.defineProperty(Zt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Zt, []);
            } catch (o) {
              Dt = o;
            }
            Reflect.construct(le, [], Zt);
          } else {
            try {
              Zt.call();
            } catch (o) {
              Dt = o;
            }
            le.call(Zt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (o) {
            Dt = o;
          }
          le();
        }
      } catch (o) {
        if (o && Dt && typeof o.stack == "string") {
          for (var Ot = o.stack.split(`
`), ar = Dt.stack.split(`
`), Yn = Ot.length - 1, B = ar.length - 1; Yn >= 1 && B >= 0 && Ot[Yn] !== ar[B]; )
            B--;
          for (; Yn >= 1 && B >= 0; Yn--, B--)
            if (Ot[Yn] !== ar[B]) {
              if (Yn !== 1 || B !== 1)
                do
                  if (Yn--, B--, B < 0 || Ot[Yn] !== ar[B]) {
                    var t = `
` + Ot[Yn].replace(" at new ", " at ");
                    return le.displayName && t.includes("<anonymous>") && (t = t.replace("<anonymous>", le.displayName)), typeof le == "function" && Bt.set(le, t), t;
                  }
                while (Yn >= 1 && B >= 0);
              break;
            }
        }
      } finally {
        Ut = !1, ot.current = cn, jt(), Error.prepareStackTrace = qt;
      }
      var n = le ? le.displayName || le.name : "", i = n ? Et(n) : "";
      return typeof le == "function" && Bt.set(le, i), i;
    }
    function pn(le, Ye, et) {
      return Ze(le, !1);
    }
    function jn(le) {
      var Ye = le.prototype;
      return !!(Ye && Ye.isReactComponent);
    }
    function rr(le, Ye, et) {
      if (le == null)
        return "";
      if (typeof le == "function")
        return Ze(le, jn(le));
      if (typeof le == "string")
        return Et(le);
      switch (le) {
        case U:
          return Et("Suspense");
        case $:
          return Et("SuspenseList");
      }
      if (typeof le == "object")
        switch (le.$$typeof) {
          case H:
            return pn(le.render);
          case q:
            return rr(le.type, Ye, et);
          case te: {
            var Dt = le, qt = Dt._payload, cn = Dt._init;
            try {
              return rr(cn(qt), Ye, et);
            } catch {
            }
          }
        }
      return "";
    }
    var Lr = Object.prototype.hasOwnProperty, Mr = {}, ei = Ne.ReactDebugCurrentFrame;
    function qi(le) {
      if (le) {
        var Ye = le._owner, et = rr(le.type, le._source, Ye ? Ye.type : null);
        ei.setExtraStackFrame(et);
      } else
        ei.setExtraStackFrame(null);
    }
    function Oa(le, Ye, et, Dt, qt) {
      {
        var cn = Function.call.bind(Lr);
        for (var Zt in le)
          if (cn(le, Zt)) {
            var Ot = void 0;
            try {
              if (typeof le[Zt] != "function") {
                var ar = Error((Dt || "React class") + ": " + et + " type `" + Zt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof le[Zt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ar.name = "Invariant Violation", ar;
              }
              Ot = le[Zt](Ye, Zt, Dt, et, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Yn) {
              Ot = Yn;
            }
            Ot && !(Ot instanceof Error) && (qi(qt), Q("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Dt || "React class", et, Zt, typeof Ot), qi(null)), Ot instanceof Error && !(Ot.message in Mr) && (Mr[Ot.message] = !0, qi(qt), Q("Failed %s type: %s", et, Ot.message), qi(null));
          }
      }
    }
    var ca = Array.isArray;
    function Zi(le) {
      return ca(le);
    }
    function mi(le) {
      {
        var Ye = typeof Symbol == "function" && Symbol.toStringTag, et = Ye && le[Symbol.toStringTag] || le.constructor.name || "Object";
        return et;
      }
    }
    function da(le) {
      try {
        return yi(le), !1;
      } catch {
        return !0;
      }
    }
    function yi(le) {
      return "" + le;
    }
    function ti(le) {
      if (da(le))
        return Q("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", mi(le)), yi(le);
    }
    var ir = Ne.ReactCurrentOwner, ni = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, _a, Qi, Ke;
    Ke = {};
    function Rt(le) {
      if (Lr.call(le, "ref")) {
        var Ye = Object.getOwnPropertyDescriptor(le, "ref").get;
        if (Ye && Ye.isReactWarning)
          return !1;
      }
      return le.ref !== void 0;
    }
    function tn(le) {
      if (Lr.call(le, "key")) {
        var Ye = Object.getOwnPropertyDescriptor(le, "key").get;
        if (Ye && Ye.isReactWarning)
          return !1;
      }
      return le.key !== void 0;
    }
    function bn(le, Ye) {
      if (typeof le.ref == "string" && ir.current && Ye && ir.current.stateNode !== Ye) {
        var et = st(ir.current.type);
        Ke[et] || (Q('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', st(ir.current.type), le.ref), Ke[et] = !0);
      }
    }
    function Un(le, Ye) {
      {
        var et = function() {
          _a || (_a = !0, Q("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ye));
        };
        et.isReactWarning = !0, Object.defineProperty(le, "key", {
          get: et,
          configurable: !0
        });
      }
    }
    function pr(le, Ye) {
      {
        var et = function() {
          Qi || (Qi = !0, Q("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ye));
        };
        et.isReactWarning = !0, Object.defineProperty(le, "ref", {
          get: et,
          configurable: !0
        });
      }
    }
    var $n = function(le, Ye, et, Dt, qt, cn, Zt) {
      var Ot = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: u,
        // Built-in properties that belong on the element
        type: le,
        key: Ye,
        ref: et,
        props: Zt,
        // Record the component responsible for creating this element.
        _owner: cn
      };
      return Ot._store = {}, Object.defineProperty(Ot._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ot, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Dt
      }), Object.defineProperty(Ot, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: qt
      }), Object.freeze && (Object.freeze(Ot.props), Object.freeze(Ot)), Ot;
    };
    function ri(le, Ye, et, Dt, qt) {
      {
        var cn, Zt = {}, Ot = null, ar = null;
        et !== void 0 && (ti(et), Ot = "" + et), tn(Ye) && (ti(Ye.key), Ot = "" + Ye.key), Rt(Ye) && (ar = Ye.ref, bn(Ye, qt));
        for (cn in Ye)
          Lr.call(Ye, cn) && !ni.hasOwnProperty(cn) && (Zt[cn] = Ye[cn]);
        if (le && le.defaultProps) {
          var Yn = le.defaultProps;
          for (cn in Yn)
            Zt[cn] === void 0 && (Zt[cn] = Yn[cn]);
        }
        if (Ot || ar) {
          var B = typeof le == "function" ? le.displayName || le.name || "Unknown" : le;
          Ot && Un(Zt, B), ar && pr(Zt, B);
        }
        return $n(le, Ot, ar, qt, Dt, ir.current, Zt);
      }
    }
    var Ln = Ne.ReactCurrentOwner, gr = Ne.ReactDebugCurrentFrame;
    function kn(le) {
      if (le) {
        var Ye = le._owner, et = rr(le.type, le._source, Ye ? Ye.type : null);
        gr.setExtraStackFrame(et);
      } else
        gr.setExtraStackFrame(null);
    }
    var Cn;
    Cn = !1;
    function us(le) {
      return typeof le == "object" && le !== null && le.$$typeof === u;
    }
    function cs() {
      {
        if (Ln.current) {
          var le = st(Ln.current.type);
          if (le)
            return `

Check the render method of \`` + le + "`.";
        }
        return "";
      }
    }
    function ds(le) {
      {
        if (le !== void 0) {
          var Ye = le.fileName.replace(/^.*[\\\/]/, ""), et = le.lineNumber;
          return `

Check your code at ` + Ye + ":" + et + ".";
        }
        return "";
      }
    }
    var Xs = {};
    function Ll(le) {
      {
        var Ye = cs();
        if (!Ye) {
          var et = typeof le == "string" ? le : le.displayName || le.name;
          et && (Ye = `

Check the top-level render call using <` + et + ">.");
        }
        return Ye;
      }
    }
    function fs(le, Ye) {
      {
        if (!le._store || le._store.validated || le.key != null)
          return;
        le._store.validated = !0;
        var et = Ll(Ye);
        if (Xs[et])
          return;
        Xs[et] = !0;
        var Dt = "";
        le && le._owner && le._owner !== Ln.current && (Dt = " It was passed a child from " + st(le._owner.type) + "."), kn(le), Q('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', et, Dt), kn(null);
      }
    }
    function Vs(le, Ye) {
      {
        if (typeof le != "object")
          return;
        if (Zi(le))
          for (var et = 0; et < le.length; et++) {
            var Dt = le[et];
            us(Dt) && fs(Dt, Ye);
          }
        else if (us(le))
          le._store && (le._store.validated = !0);
        else if (le) {
          var qt = Re(le);
          if (typeof qt == "function" && qt !== le.entries)
            for (var cn = qt.call(le), Zt; !(Zt = cn.next()).done; )
              us(Zt.value) && fs(Zt.value, Ye);
        }
      }
    }
    function hs(le) {
      {
        var Ye = le.type;
        if (Ye == null || typeof Ye == "string")
          return;
        var et;
        if (typeof Ye == "function")
          et = Ye.propTypes;
        else if (typeof Ye == "object" && (Ye.$$typeof === H || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Ye.$$typeof === q))
          et = Ye.propTypes;
        else
          return;
        if (et) {
          var Dt = st(Ye);
          Oa(et, le.props, "prop", Dt, le);
        } else if (Ye.PropTypes !== void 0 && !Cn) {
          Cn = !0;
          var qt = st(Ye);
          Q("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", qt || "Unknown");
        }
        typeof Ye.getDefaultProps == "function" && !Ye.getDefaultProps.isReactClassApproved && Q("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Gs(le) {
      {
        for (var Ye = Object.keys(le.props), et = 0; et < Ye.length; et++) {
          var Dt = Ye[et];
          if (Dt !== "children" && Dt !== "key") {
            kn(le), Q("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Dt), kn(null);
            break;
          }
        }
        le.ref !== null && (kn(le), Q("Invalid attribute `ref` supplied to `React.Fragment`."), kn(null));
      }
    }
    function Di(le, Ye, et, Dt, qt, cn) {
      {
        var Zt = Ge(le);
        if (!Zt) {
          var Ot = "";
          (le === void 0 || typeof le == "object" && le !== null && Object.keys(le).length === 0) && (Ot += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ar = ds(qt);
          ar ? Ot += ar : Ot += cs();
          var Yn;
          le === null ? Yn = "null" : Zi(le) ? Yn = "array" : le !== void 0 && le.$$typeof === u ? (Yn = "<" + (st(le.type) || "Unknown") + " />", Ot = " Did you accidentally export a JSX literal instead of a component?") : Yn = typeof le, Q("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Yn, Ot);
        }
        var B = ri(le, Ye, et, qt, cn);
        if (B == null)
          return B;
        if (Zt) {
          var t = Ye.children;
          if (t !== void 0)
            if (Dt)
              if (Zi(t)) {
                for (var n = 0; n < t.length; n++)
                  Vs(t[n], le);
                Object.freeze && Object.freeze(t);
              } else
                Q("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Vs(t, le);
        }
        return le === v ? Gs(B) : hs(B), B;
      }
    }
    function Pa(le, Ye, et) {
      return Di(le, Ye, et, !0);
    }
    function Hr(le, Ye, et) {
      return Di(le, Ye, et, !1);
    }
    var xi = Hr, ii = Pa;
    Jp.Fragment = v, Jp.jsx = xi, Jp.jsxs = ii;
  }()), Jp;
}
process.env.NODE_ENV === "production" ? i1.exports = N_() : i1.exports = z_();
var fe = i1.exports;
const I_ = {
  type: "logger",
  log(s) {
    this.output("log", s);
  },
  warn(s) {
    this.output("warn", s);
  },
  error(s) {
    this.output("error", s);
  },
  output(s, u) {
    console && console[s] && console[s].apply(console, u);
  }
};
class Oy {
  constructor(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(u, h);
  }
  init(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = h.prefix || "i18next:", this.logger = u || I_, this.options = h, this.debug = h.debug;
  }
  log() {
    for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
      h[v] = arguments[v];
    return this.forward(h, "log", "", !0);
  }
  warn() {
    for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
      h[v] = arguments[v];
    return this.forward(h, "warn", "", !0);
  }
  error() {
    for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
      h[v] = arguments[v];
    return this.forward(h, "error", "");
  }
  deprecate() {
    for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
      h[v] = arguments[v];
    return this.forward(h, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(u, h, v, w) {
    return w && !this.debug ? null : (typeof u[0] == "string" && (u[0] = `${v}${this.prefix} ${u[0]}`), this.logger[h](u));
  }
  create(u) {
    return new Oy(this.logger, {
      prefix: `${this.prefix}:${u}:`,
      ...this.options
    });
  }
  clone(u) {
    return u = u || this.options, u.prefix = u.prefix || this.prefix, new Oy(this.logger, u);
  }
}
var Lo = new Oy();
class Xy {
  constructor() {
    this.observers = {};
  }
  on(u, h) {
    return u.split(" ").forEach((v) => {
      this.observers[v] = this.observers[v] || [], this.observers[v].push(h);
    }), this;
  }
  off(u, h) {
    if (this.observers[u]) {
      if (!h) {
        delete this.observers[u];
        return;
      }
      this.observers[u] = this.observers[u].filter((v) => v !== h);
    }
  }
  emit(u) {
    for (var h = arguments.length, v = new Array(h > 1 ? h - 1 : 0), w = 1; w < h; w++)
      v[w - 1] = arguments[w];
    this.observers[u] && [].concat(this.observers[u]).forEach((A) => {
      A(...v);
    }), this.observers["*"] && [].concat(this.observers["*"]).forEach((A) => {
      A.apply(A, [u, ...v]);
    });
  }
}
function eg() {
  let s, u;
  const h = new Promise((v, w) => {
    s = v, u = w;
  });
  return h.resolve = s, h.reject = u, h;
}
function QA(s) {
  return s == null ? "" : "" + s;
}
function F_(s, u, h) {
  s.forEach((v) => {
    u[v] && (h[v] = u[v]);
  });
}
function M1(s, u, h) {
  function v(T) {
    return T && T.indexOf("###") > -1 ? T.replace(/###/g, ".") : T;
  }
  function w() {
    return !s || typeof s == "string";
  }
  const A = typeof u != "string" ? [].concat(u) : u.split(".");
  for (; A.length > 1; ) {
    if (w())
      return {};
    const T = v(A.shift());
    !s[T] && h && (s[T] = new h()), Object.prototype.hasOwnProperty.call(s, T) ? s = s[T] : s = {};
  }
  return w() ? {} : {
    obj: s,
    k: v(A.shift())
  };
}
function KA(s, u, h) {
  const {
    obj: v,
    k: w
  } = M1(s, u, Object);
  v[w] = h;
}
function Y_(s, u, h, v) {
  const {
    obj: w,
    k: A
  } = M1(s, u, Object);
  w[A] = w[A] || [], v && (w[A] = w[A].concat(h)), v || w[A].push(h);
}
function _y(s, u) {
  const {
    obj: h,
    k: v
  } = M1(s, u);
  if (h)
    return h[v];
}
function H_(s, u, h) {
  const v = _y(s, h);
  return v !== void 0 ? v : _y(u, h);
}
function oE(s, u, h) {
  for (const v in u)
    v !== "__proto__" && v !== "constructor" && (v in s ? typeof s[v] == "string" || s[v] instanceof String || typeof u[v] == "string" || u[v] instanceof String ? h && (s[v] = u[v]) : oE(s[v], u[v], h) : s[v] = u[v]);
  return s;
}
function Df(s) {
  return s.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var j_ = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function U_(s) {
  return typeof s == "string" ? s.replace(/[&<>"'\/]/g, (u) => j_[u]) : s;
}
const B_ = [" ", ",", "?", "!", ";"];
function W_(s, u, h) {
  u = u || "", h = h || "";
  const v = B_.filter((T) => u.indexOf(T) < 0 && h.indexOf(T) < 0);
  if (v.length === 0)
    return !0;
  const w = new RegExp(`(${v.map((T) => T === "?" ? "\\?" : T).join("|")})`);
  let A = !w.test(s);
  if (!A) {
    const T = s.indexOf(h);
    T > 0 && !w.test(s.substring(0, T)) && (A = !0);
  }
  return A;
}
function Py(s, u) {
  let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!s)
    return;
  if (s[u])
    return s[u];
  const v = u.split(h);
  let w = s;
  for (let A = 0; A < v.length; ++A) {
    if (!w || typeof w[v[A]] == "string" && A + 1 < v.length)
      return;
    if (w[v[A]] === void 0) {
      let T = 2, F = v.slice(A, A + T).join(h), H = w[F];
      for (; H === void 0 && v.length > A + T; )
        T++, F = v.slice(A, A + T).join(h), H = w[F];
      if (H === void 0)
        return;
      if (H === null)
        return null;
      if (u.endsWith(F)) {
        if (typeof H == "string")
          return H;
        if (F && typeof H[F] == "string")
          return H[F];
      }
      const U = v.slice(A + T).join(h);
      return U ? Py(H, U, h) : void 0;
    }
    w = w[v[A]];
  }
  return w;
}
function Ny(s) {
  return s && s.indexOf("_") > 0 ? s.replace("_", "-") : s;
}
class JA extends Xy {
  constructor(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = u || {}, this.options = h, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(u) {
    this.options.ns.indexOf(u) < 0 && this.options.ns.push(u);
  }
  removeNamespaces(u) {
    const h = this.options.ns.indexOf(u);
    h > -1 && this.options.ns.splice(h, 1);
  }
  getResource(u, h, v) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const A = w.keySeparator !== void 0 ? w.keySeparator : this.options.keySeparator, T = w.ignoreJSONStructure !== void 0 ? w.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let F = [u, h];
    v && typeof v != "string" && (F = F.concat(v)), v && typeof v == "string" && (F = F.concat(A ? v.split(A) : v)), u.indexOf(".") > -1 && (F = u.split("."));
    const H = _y(this.data, F);
    return H || !T || typeof v != "string" ? H : Py(this.data && this.data[u] && this.data[u][h], v, A);
  }
  addResource(u, h, v, w) {
    let A = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const T = A.keySeparator !== void 0 ? A.keySeparator : this.options.keySeparator;
    let F = [u, h];
    v && (F = F.concat(T ? v.split(T) : v)), u.indexOf(".") > -1 && (F = u.split("."), w = h, h = F[1]), this.addNamespaces(h), KA(this.data, F, w), A.silent || this.emit("added", u, h, v, w);
  }
  addResources(u, h, v) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const A in v)
      (typeof v[A] == "string" || Object.prototype.toString.apply(v[A]) === "[object Array]") && this.addResource(u, h, A, v[A], {
        silent: !0
      });
    w.silent || this.emit("added", u, h, v);
  }
  addResourceBundle(u, h, v, w, A) {
    let T = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: !1
    }, F = [u, h];
    u.indexOf(".") > -1 && (F = u.split("."), w = v, v = h, h = F[1]), this.addNamespaces(h);
    let H = _y(this.data, F) || {};
    w ? oE(H, v, A) : H = {
      ...H,
      ...v
    }, KA(this.data, F, H), T.silent || this.emit("added", u, h, v);
  }
  removeResourceBundle(u, h) {
    this.hasResourceBundle(u, h) && delete this.data[u][h], this.removeNamespaces(h), this.emit("removed", u, h);
  }
  hasResourceBundle(u, h) {
    return this.getResource(u, h) !== void 0;
  }
  getResourceBundle(u, h) {
    return h || (h = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? {
      ...this.getResource(u, h)
    } : this.getResource(u, h);
  }
  getDataByLanguage(u) {
    return this.data[u];
  }
  hasLanguageSomeTranslations(u) {
    const h = this.getDataByLanguage(u);
    return !!(h && Object.keys(h) || []).find((v) => h[v] && Object.keys(h[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var lE = {
  processors: {},
  addPostProcessor(s) {
    this.processors[s.name] = s;
  },
  handle(s, u, h, v, w) {
    return s.forEach((A) => {
      this.processors[A] && (u = this.processors[A].process(u, h, v, w));
    }), u;
  }
};
const eT = {};
class zy extends Xy {
  constructor(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), F_(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], u, this), this.options = h, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = Lo.create("translator");
  }
  changeLanguage(u) {
    u && (this.language = u);
  }
  exists(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (u == null)
      return !1;
    const v = this.resolve(u, h);
    return v && v.res !== void 0;
  }
  extractFromKey(u, h) {
    let v = h.nsSeparator !== void 0 ? h.nsSeparator : this.options.nsSeparator;
    v === void 0 && (v = ":");
    const w = h.keySeparator !== void 0 ? h.keySeparator : this.options.keySeparator;
    let A = h.ns || this.options.defaultNS || [];
    const T = v && u.indexOf(v) > -1, F = !this.options.userDefinedKeySeparator && !h.keySeparator && !this.options.userDefinedNsSeparator && !h.nsSeparator && !W_(u, v, w);
    if (T && !F) {
      const H = u.match(this.interpolator.nestingRegexp);
      if (H && H.length > 0)
        return {
          key: u,
          namespaces: A
        };
      const U = u.split(v);
      (v !== w || v === w && this.options.ns.indexOf(U[0]) > -1) && (A = U.shift()), u = U.join(w);
    }
    return typeof A == "string" && (A = [A]), {
      key: u,
      namespaces: A
    };
  }
  translate(u, h, v) {
    if (typeof h != "object" && this.options.overloadTranslationOptionHandler && (h = this.options.overloadTranslationOptionHandler(arguments)), typeof h == "object" && (h = {
      ...h
    }), h || (h = {}), u == null)
      return "";
    Array.isArray(u) || (u = [String(u)]);
    const w = h.returnDetails !== void 0 ? h.returnDetails : this.options.returnDetails, A = h.keySeparator !== void 0 ? h.keySeparator : this.options.keySeparator, {
      key: T,
      namespaces: F
    } = this.extractFromKey(u[u.length - 1], h), H = F[F.length - 1], U = h.lng || this.language, $ = h.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (U && U.toLowerCase() === "cimode") {
      if ($) {
        const we = h.nsSeparator || this.options.nsSeparator;
        return w ? {
          res: `${H}${we}${T}`,
          usedKey: T,
          exactUsedKey: T,
          usedLng: U,
          usedNS: H
        } : `${H}${we}${T}`;
      }
      return w ? {
        res: T,
        usedKey: T,
        exactUsedKey: T,
        usedLng: U,
        usedNS: H
      } : T;
    }
    const q = this.resolve(u, h);
    let te = q && q.res;
    const se = q && q.usedKey || T, ae = q && q.exactUsedKey || T, ue = Object.prototype.toString.apply(te), Re = ["[object Number]", "[object Function]", "[object RegExp]"], Ne = h.joinArrays !== void 0 ? h.joinArrays : this.options.joinArrays, Q = !this.i18nFormat || this.i18nFormat.handleAsObject;
    if (Q && te && typeof te != "string" && typeof te != "boolean" && typeof te != "number" && Re.indexOf(ue) < 0 && !(typeof Ne == "string" && ue === "[object Array]")) {
      if (!h.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const we = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(se, te, {
          ...h,
          ns: F
        }) : `key '${T} (${this.language})' returned an object instead of string.`;
        return w ? (q.res = we, q) : we;
      }
      if (A) {
        const we = ue === "[object Array]", Ee = we ? [] : {}, re = we ? ae : se;
        for (const ve in te)
          if (Object.prototype.hasOwnProperty.call(te, ve)) {
            const Le = `${re}${A}${ve}`;
            Ee[ve] = this.translate(Le, {
              ...h,
              joinArrays: !1,
              ns: F
            }), Ee[ve] === Le && (Ee[ve] = te[ve]);
          }
        te = Ee;
      }
    } else if (Q && typeof Ne == "string" && ue === "[object Array]")
      te = te.join(Ne), te && (te = this.extendTranslation(te, u, h, v));
    else {
      let we = !1, Ee = !1;
      const re = h.count !== void 0 && typeof h.count != "string", ve = zy.hasDefaultValue(h), Le = re ? this.pluralResolver.getSuffix(U, h.count, h) : "", Qe = h.ordinal && re ? this.pluralResolver.getSuffix(U, h.count, {
        ordinal: !1
      }) : "", Be = h[`defaultValue${Le}`] || h[`defaultValue${Qe}`] || h.defaultValue;
      !this.isValidLookup(te) && ve && (we = !0, te = Be), this.isValidLookup(te) || (Ee = !0, te = T);
      const Ge = (h.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && Ee ? void 0 : te, ft = ve && Be !== te && this.options.updateMissing;
      if (Ee || we || ft) {
        if (this.logger.log(ft ? "updateKey" : "missingKey", U, H, T, ft ? Be : te), A) {
          const Ht = this.resolve(T, {
            ...h,
            keySeparator: !1
          });
          Ht && Ht.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let wt = [];
        const st = this.languageUtils.getFallbackCodes(this.options.fallbackLng, h.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && st && st[0])
          for (let Ht = 0; Ht < st.length; Ht++)
            wt.push(st[Ht]);
        else
          this.options.saveMissingTo === "all" ? wt = this.languageUtils.toResolveHierarchy(h.lng || this.language) : wt.push(h.lng || this.language);
        const it = (Ht, Mt, an) => {
          const We = ve && an !== te ? an : Ge;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(Ht, H, Mt, We, ft, h) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(Ht, H, Mt, We, ft, h), this.emit("missingKey", Ht, H, Mt, te);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && re ? wt.forEach((Ht) => {
          this.pluralResolver.getSuffixes(Ht, h).forEach((Mt) => {
            it([Ht], T + Mt, h[`defaultValue${Mt}`] || Be);
          });
        }) : it(wt, T, Be));
      }
      te = this.extendTranslation(te, u, h, q, v), Ee && te === T && this.options.appendNamespaceToMissingKey && (te = `${H}:${T}`), (Ee || we) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? te = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${H}:${T}` : T, we ? te : void 0) : te = this.options.parseMissingKeyHandler(te));
    }
    return w ? (q.res = te, q) : te;
  }
  extendTranslation(u, h, v, w, A) {
    var T = this;
    if (this.i18nFormat && this.i18nFormat.parse)
      u = this.i18nFormat.parse(u, {
        ...this.options.interpolation.defaultVariables,
        ...v
      }, v.lng || this.language || w.usedLng, w.usedNS, w.usedKey, {
        resolved: w
      });
    else if (!v.skipInterpolation) {
      v.interpolation && this.interpolator.init({
        ...v,
        interpolation: {
          ...this.options.interpolation,
          ...v.interpolation
        }
      });
      const U = typeof u == "string" && (v && v.interpolation && v.interpolation.skipOnVariables !== void 0 ? v.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let $;
      if (U) {
        const te = u.match(this.interpolator.nestingRegexp);
        $ = te && te.length;
      }
      let q = v.replace && typeof v.replace != "string" ? v.replace : v;
      if (this.options.interpolation.defaultVariables && (q = {
        ...this.options.interpolation.defaultVariables,
        ...q
      }), u = this.interpolator.interpolate(u, q, v.lng || this.language, v), U) {
        const te = u.match(this.interpolator.nestingRegexp), se = te && te.length;
        $ < se && (v.nest = !1);
      }
      !v.lng && this.options.compatibilityAPI !== "v1" && w && w.res && (v.lng = w.usedLng), v.nest !== !1 && (u = this.interpolator.nest(u, function() {
        for (var te = arguments.length, se = new Array(te), ae = 0; ae < te; ae++)
          se[ae] = arguments[ae];
        return A && A[0] === se[0] && !v.context ? (T.logger.warn(`It seems you are nesting recursively key: ${se[0]} in key: ${h[0]}`), null) : T.translate(...se, h);
      }, v)), v.interpolation && this.interpolator.reset();
    }
    const F = v.postProcess || this.options.postProcess, H = typeof F == "string" ? [F] : F;
    return u != null && H && H.length && v.applyPostProcessor !== !1 && (u = lE.handle(H, u, h, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: w,
      ...v
    } : v, this)), u;
  }
  resolve(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, v, w, A, T, F;
    return typeof u == "string" && (u = [u]), u.forEach((H) => {
      if (this.isValidLookup(v))
        return;
      const U = this.extractFromKey(H, h), $ = U.key;
      w = $;
      let q = U.namespaces;
      this.options.fallbackNS && (q = q.concat(this.options.fallbackNS));
      const te = h.count !== void 0 && typeof h.count != "string", se = te && !h.ordinal && h.count === 0 && this.pluralResolver.shouldUseIntlApi(), ae = h.context !== void 0 && (typeof h.context == "string" || typeof h.context == "number") && h.context !== "", ue = h.lngs ? h.lngs : this.languageUtils.toResolveHierarchy(h.lng || this.language, h.fallbackLng);
      q.forEach((Re) => {
        this.isValidLookup(v) || (F = Re, !eT[`${ue[0]}-${Re}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(F) && (eT[`${ue[0]}-${Re}`] = !0, this.logger.warn(`key "${w}" for languages "${ue.join(", ")}" won't get resolved as namespace "${F}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), ue.forEach((Ne) => {
          if (this.isValidLookup(v))
            return;
          T = Ne;
          const Q = [$];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys)
            this.i18nFormat.addLookupKeys(Q, $, Ne, Re, h);
          else {
            let Ee;
            te && (Ee = this.pluralResolver.getSuffix(Ne, h.count, h));
            const re = `${this.options.pluralSeparator}zero`, ve = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (te && (Q.push($ + Ee), h.ordinal && Ee.indexOf(ve) === 0 && Q.push($ + Ee.replace(ve, this.options.pluralSeparator)), se && Q.push($ + re)), ae) {
              const Le = `${$}${this.options.contextSeparator}${h.context}`;
              Q.push(Le), te && (Q.push(Le + Ee), h.ordinal && Ee.indexOf(ve) === 0 && Q.push(Le + Ee.replace(ve, this.options.pluralSeparator)), se && Q.push(Le + re));
            }
          }
          let we;
          for (; we = Q.pop(); )
            this.isValidLookup(v) || (A = we, v = this.getResource(Ne, Re, we, h));
        }));
      });
    }), {
      res: v,
      usedKey: w,
      exactUsedKey: A,
      usedLng: T,
      usedNS: F
    };
  }
  isValidLookup(u) {
    return u !== void 0 && !(!this.options.returnNull && u === null) && !(!this.options.returnEmptyString && u === "");
  }
  getResource(u, h, v) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(u, h, v, w) : this.resourceStore.getResource(u, h, v, w);
  }
  static hasDefaultValue(u) {
    const h = "defaultValue";
    for (const v in u)
      if (Object.prototype.hasOwnProperty.call(u, v) && h === v.substring(0, h.length) && u[v] !== void 0)
        return !0;
    return !1;
  }
}
function zw(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
class tT {
  constructor(u) {
    this.options = u, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Lo.create("languageUtils");
  }
  getScriptPartFromCode(u) {
    if (u = Ny(u), !u || u.indexOf("-") < 0)
      return null;
    const h = u.split("-");
    return h.length === 2 || (h.pop(), h[h.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(h.join("-"));
  }
  getLanguagePartFromCode(u) {
    if (u = Ny(u), !u || u.indexOf("-") < 0)
      return u;
    const h = u.split("-");
    return this.formatLanguageCode(h[0]);
  }
  formatLanguageCode(u) {
    if (typeof u == "string" && u.indexOf("-") > -1) {
      const h = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let v = u.split("-");
      return this.options.lowerCaseLng ? v = v.map((w) => w.toLowerCase()) : v.length === 2 ? (v[0] = v[0].toLowerCase(), v[1] = v[1].toUpperCase(), h.indexOf(v[1].toLowerCase()) > -1 && (v[1] = zw(v[1].toLowerCase()))) : v.length === 3 && (v[0] = v[0].toLowerCase(), v[1].length === 2 && (v[1] = v[1].toUpperCase()), v[0] !== "sgn" && v[2].length === 2 && (v[2] = v[2].toUpperCase()), h.indexOf(v[1].toLowerCase()) > -1 && (v[1] = zw(v[1].toLowerCase())), h.indexOf(v[2].toLowerCase()) > -1 && (v[2] = zw(v[2].toLowerCase()))), v.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? u.toLowerCase() : u;
  }
  isSupportedCode(u) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (u = this.getLanguagePartFromCode(u)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(u) > -1;
  }
  getBestMatchFromCodes(u) {
    if (!u)
      return null;
    let h;
    return u.forEach((v) => {
      if (h)
        return;
      const w = this.formatLanguageCode(v);
      (!this.options.supportedLngs || this.isSupportedCode(w)) && (h = w);
    }), !h && this.options.supportedLngs && u.forEach((v) => {
      if (h)
        return;
      const w = this.getLanguagePartFromCode(v);
      if (this.isSupportedCode(w))
        return h = w;
      h = this.options.supportedLngs.find((A) => {
        if (A === w || !(A.indexOf("-") < 0 && w.indexOf("-") < 0) && A.indexOf(w) === 0)
          return A;
      });
    }), h || (h = this.getFallbackCodes(this.options.fallbackLng)[0]), h;
  }
  getFallbackCodes(u, h) {
    if (!u)
      return [];
    if (typeof u == "function" && (u = u(h)), typeof u == "string" && (u = [u]), Object.prototype.toString.apply(u) === "[object Array]")
      return u;
    if (!h)
      return u.default || [];
    let v = u[h];
    return v || (v = u[this.getScriptPartFromCode(h)]), v || (v = u[this.formatLanguageCode(h)]), v || (v = u[this.getLanguagePartFromCode(h)]), v || (v = u.default), v || [];
  }
  toResolveHierarchy(u, h) {
    const v = this.getFallbackCodes(h || this.options.fallbackLng || [], u), w = [], A = (T) => {
      T && (this.isSupportedCode(T) ? w.push(T) : this.logger.warn(`rejecting language code not found in supportedLngs: ${T}`));
    };
    return typeof u == "string" && (u.indexOf("-") > -1 || u.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && A(this.formatLanguageCode(u)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && A(this.getScriptPartFromCode(u)), this.options.load !== "currentOnly" && A(this.getLanguagePartFromCode(u))) : typeof u == "string" && A(this.formatLanguageCode(u)), v.forEach((T) => {
      w.indexOf(T) < 0 && A(this.formatLanguageCode(T));
    }), w;
  }
}
let X_ = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], V_ = {
  1: function(s) {
    return +(s > 1);
  },
  2: function(s) {
    return +(s != 1);
  },
  3: function(s) {
    return 0;
  },
  4: function(s) {
    return s % 10 == 1 && s % 100 != 11 ? 0 : s % 10 >= 2 && s % 10 <= 4 && (s % 100 < 10 || s % 100 >= 20) ? 1 : 2;
  },
  5: function(s) {
    return s == 0 ? 0 : s == 1 ? 1 : s == 2 ? 2 : s % 100 >= 3 && s % 100 <= 10 ? 3 : s % 100 >= 11 ? 4 : 5;
  },
  6: function(s) {
    return s == 1 ? 0 : s >= 2 && s <= 4 ? 1 : 2;
  },
  7: function(s) {
    return s == 1 ? 0 : s % 10 >= 2 && s % 10 <= 4 && (s % 100 < 10 || s % 100 >= 20) ? 1 : 2;
  },
  8: function(s) {
    return s == 1 ? 0 : s == 2 ? 1 : s != 8 && s != 11 ? 2 : 3;
  },
  9: function(s) {
    return +(s >= 2);
  },
  10: function(s) {
    return s == 1 ? 0 : s == 2 ? 1 : s < 7 ? 2 : s < 11 ? 3 : 4;
  },
  11: function(s) {
    return s == 1 || s == 11 ? 0 : s == 2 || s == 12 ? 1 : s > 2 && s < 20 ? 2 : 3;
  },
  12: function(s) {
    return +(s % 10 != 1 || s % 100 == 11);
  },
  13: function(s) {
    return +(s !== 0);
  },
  14: function(s) {
    return s == 1 ? 0 : s == 2 ? 1 : s == 3 ? 2 : 3;
  },
  15: function(s) {
    return s % 10 == 1 && s % 100 != 11 ? 0 : s % 10 >= 2 && (s % 100 < 10 || s % 100 >= 20) ? 1 : 2;
  },
  16: function(s) {
    return s % 10 == 1 && s % 100 != 11 ? 0 : s !== 0 ? 1 : 2;
  },
  17: function(s) {
    return s == 1 || s % 10 == 1 && s % 100 != 11 ? 0 : 1;
  },
  18: function(s) {
    return s == 0 ? 0 : s == 1 ? 1 : 2;
  },
  19: function(s) {
    return s == 1 ? 0 : s == 0 || s % 100 > 1 && s % 100 < 11 ? 1 : s % 100 > 10 && s % 100 < 20 ? 2 : 3;
  },
  20: function(s) {
    return s == 1 ? 0 : s == 0 || s % 100 > 0 && s % 100 < 20 ? 1 : 2;
  },
  21: function(s) {
    return s % 100 == 1 ? 1 : s % 100 == 2 ? 2 : s % 100 == 3 || s % 100 == 4 ? 3 : 0;
  },
  22: function(s) {
    return s == 1 ? 0 : s == 2 ? 1 : (s < 0 || s > 10) && s % 10 == 0 ? 2 : 3;
  }
};
const G_ = ["v1", "v2", "v3"], $_ = ["v4"], nT = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function q_() {
  const s = {};
  return X_.forEach((u) => {
    u.lngs.forEach((h) => {
      s[h] = {
        numbers: u.nr,
        plurals: V_[u.fc]
      };
    });
  }), s;
}
class Z_ {
  constructor(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = u, this.options = h, this.logger = Lo.create("pluralResolver"), (!this.options.compatibilityJSON || $_.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = q_();
  }
  addRule(u, h) {
    this.rules[u] = h;
  }
  getRule(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi())
      try {
        return new Intl.PluralRules(Ny(u), {
          type: h.ordinal ? "ordinal" : "cardinal"
        });
      } catch {
        return;
      }
    return this.rules[u] || this.rules[this.languageUtils.getLanguagePartFromCode(u)];
  }
  needsPlural(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const v = this.getRule(u, h);
    return this.shouldUseIntlApi() ? v && v.resolvedOptions().pluralCategories.length > 1 : v && v.numbers.length > 1;
  }
  getPluralFormsOfKey(u, h) {
    let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(u, v).map((w) => `${h}${w}`);
  }
  getSuffixes(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const v = this.getRule(u, h);
    return v ? this.shouldUseIntlApi() ? v.resolvedOptions().pluralCategories.sort((w, A) => nT[w] - nT[A]).map((w) => `${this.options.prepend}${h.ordinal ? `ordinal${this.options.prepend}` : ""}${w}`) : v.numbers.map((w) => this.getSuffix(u, w, h)) : [];
  }
  getSuffix(u, h) {
    let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const w = this.getRule(u, v);
    return w ? this.shouldUseIntlApi() ? `${this.options.prepend}${v.ordinal ? `ordinal${this.options.prepend}` : ""}${w.select(h)}` : this.getSuffixRetroCompatible(w, h) : (this.logger.warn(`no plural rule found for: ${u}`), "");
  }
  getSuffixRetroCompatible(u, h) {
    const v = u.noAbs ? u.plurals(h) : u.plurals(Math.abs(h));
    let w = u.numbers[v];
    this.options.simplifyPluralSuffix && u.numbers.length === 2 && u.numbers[0] === 1 && (w === 2 ? w = "plural" : w === 1 && (w = ""));
    const A = () => this.options.prepend && w.toString() ? this.options.prepend + w.toString() : w.toString();
    return this.options.compatibilityJSON === "v1" ? w === 1 ? "" : typeof w == "number" ? `_plural_${w.toString()}` : A() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && u.numbers.length === 2 && u.numbers[0] === 1 ? A() : this.options.prepend && v.toString() ? this.options.prepend + v.toString() : v.toString();
  }
  shouldUseIntlApi() {
    return !G_.includes(this.options.compatibilityJSON);
  }
}
function rT(s, u, h) {
  let v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", w = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, A = H_(s, u, h);
  return !A && w && typeof h == "string" && (A = Py(s, h, v), A === void 0 && (A = Py(u, h, v))), A;
}
class Q_ {
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Lo.create("interpolator"), this.options = u, this.format = u.interpolation && u.interpolation.format || ((h) => h), this.init(u);
  }
  init() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    u.interpolation || (u.interpolation = {
      escapeValue: !0
    });
    const h = u.interpolation;
    this.escape = h.escape !== void 0 ? h.escape : U_, this.escapeValue = h.escapeValue !== void 0 ? h.escapeValue : !0, this.useRawValueToEscape = h.useRawValueToEscape !== void 0 ? h.useRawValueToEscape : !1, this.prefix = h.prefix ? Df(h.prefix) : h.prefixEscaped || "{{", this.suffix = h.suffix ? Df(h.suffix) : h.suffixEscaped || "}}", this.formatSeparator = h.formatSeparator ? h.formatSeparator : h.formatSeparator || ",", this.unescapePrefix = h.unescapeSuffix ? "" : h.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : h.unescapeSuffix || "", this.nestingPrefix = h.nestingPrefix ? Df(h.nestingPrefix) : h.nestingPrefixEscaped || Df("$t("), this.nestingSuffix = h.nestingSuffix ? Df(h.nestingSuffix) : h.nestingSuffixEscaped || Df(")"), this.nestingOptionsSeparator = h.nestingOptionsSeparator ? h.nestingOptionsSeparator : h.nestingOptionsSeparator || ",", this.maxReplaces = h.maxReplaces ? h.maxReplaces : 1e3, this.alwaysFormat = h.alwaysFormat !== void 0 ? h.alwaysFormat : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const u = `${this.prefix}(.+?)${this.suffix}`;
    this.regexp = new RegExp(u, "g");
    const h = `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`;
    this.regexpUnescape = new RegExp(h, "g");
    const v = `${this.nestingPrefix}(.+?)${this.nestingSuffix}`;
    this.nestingRegexp = new RegExp(v, "g");
  }
  interpolate(u, h, v, w) {
    let A, T, F;
    const H = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    function U(se) {
      return se.replace(/\$/g, "$$$$");
    }
    const $ = (se) => {
      if (se.indexOf(this.formatSeparator) < 0) {
        const Ne = rT(h, H, se, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(Ne, void 0, v, {
          ...w,
          ...h,
          interpolationkey: se
        }) : Ne;
      }
      const ae = se.split(this.formatSeparator), ue = ae.shift().trim(), Re = ae.join(this.formatSeparator).trim();
      return this.format(rT(h, H, ue, this.options.keySeparator, this.options.ignoreJSONStructure), Re, v, {
        ...w,
        ...h,
        interpolationkey: ue
      });
    };
    this.resetRegExp();
    const q = w && w.missingInterpolationHandler || this.options.missingInterpolationHandler, te = w && w.interpolation && w.interpolation.skipOnVariables !== void 0 ? w.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (se) => U(se)
    }, {
      regex: this.regexp,
      safeValue: (se) => this.escapeValue ? U(this.escape(se)) : U(se)
    }].forEach((se) => {
      for (F = 0; A = se.regex.exec(u); ) {
        const ae = A[1].trim();
        if (T = $(ae), T === void 0)
          if (typeof q == "function") {
            const Re = q(u, A, w);
            T = typeof Re == "string" ? Re : "";
          } else if (w && Object.prototype.hasOwnProperty.call(w, ae))
            T = "";
          else if (te) {
            T = A[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${ae} for interpolating ${u}`), T = "";
        else
          typeof T != "string" && !this.useRawValueToEscape && (T = QA(T));
        const ue = se.safeValue(T);
        if (u = u.replace(A[0], ue), te ? (se.regex.lastIndex += T.length, se.regex.lastIndex -= A[0].length) : se.regex.lastIndex = 0, F++, F >= this.maxReplaces)
          break;
      }
    }), u;
  }
  nest(u, h) {
    let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, w, A, T;
    function F(H, U) {
      const $ = this.nestingOptionsSeparator;
      if (H.indexOf($) < 0)
        return H;
      const q = H.split(new RegExp(`${$}[ ]*{`));
      let te = `{${q[1]}`;
      H = q[0], te = this.interpolate(te, T);
      const se = te.match(/'/g), ae = te.match(/"/g);
      (se && se.length % 2 === 0 && !ae || ae.length % 2 !== 0) && (te = te.replace(/'/g, '"'));
      try {
        T = JSON.parse(te), U && (T = {
          ...U,
          ...T
        });
      } catch (ue) {
        return this.logger.warn(`failed parsing options string in nesting for key ${H}`, ue), `${H}${$}${te}`;
      }
      return delete T.defaultValue, H;
    }
    for (; w = this.nestingRegexp.exec(u); ) {
      let H = [];
      T = {
        ...v
      }, T = T.replace && typeof T.replace != "string" ? T.replace : T, T.applyPostProcessor = !1, delete T.defaultValue;
      let U = !1;
      if (w[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(w[1])) {
        const $ = w[1].split(this.formatSeparator).map((q) => q.trim());
        w[1] = $.shift(), H = $, U = !0;
      }
      if (A = h(F.call(this, w[1].trim(), T), T), A && w[0] === u && typeof A != "string")
        return A;
      typeof A != "string" && (A = QA(A)), A || (this.logger.warn(`missed to resolve ${w[1]} for nesting ${u}`), A = ""), U && (A = H.reduce(($, q) => this.format($, q, v.lng, {
        ...v,
        interpolationkey: w[1].trim()
      }), A.trim())), u = u.replace(w[0], A), this.regexp.lastIndex = 0;
    }
    return u;
  }
}
function K_(s) {
  let u = s.toLowerCase().trim();
  const h = {};
  if (s.indexOf("(") > -1) {
    const v = s.split("(");
    u = v[0].toLowerCase().trim();
    const w = v[1].substring(0, v[1].length - 1);
    u === "currency" && w.indexOf(":") < 0 ? h.currency || (h.currency = w.trim()) : u === "relativetime" && w.indexOf(":") < 0 ? h.range || (h.range = w.trim()) : w.split(";").forEach((A) => {
      if (!A)
        return;
      const [T, ...F] = A.split(":"), H = F.join(":").trim().replace(/^'+|'+$/g, "");
      h[T.trim()] || (h[T.trim()] = H), H === "false" && (h[T.trim()] = !1), H === "true" && (h[T.trim()] = !0), isNaN(H) || (h[T.trim()] = parseInt(H, 10));
    });
  }
  return {
    formatName: u,
    formatOptions: h
  };
}
function Of(s) {
  const u = {};
  return function(h, v, w) {
    const A = v + JSON.stringify(w);
    let T = u[A];
    return T || (T = s(Ny(v), w), u[A] = T), T(h);
  };
}
class J_ {
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Lo.create("formatter"), this.options = u, this.formats = {
      number: Of((h, v) => {
        const w = new Intl.NumberFormat(h, {
          ...v
        });
        return (A) => w.format(A);
      }),
      currency: Of((h, v) => {
        const w = new Intl.NumberFormat(h, {
          ...v,
          style: "currency"
        });
        return (A) => w.format(A);
      }),
      datetime: Of((h, v) => {
        const w = new Intl.DateTimeFormat(h, {
          ...v
        });
        return (A) => w.format(A);
      }),
      relativetime: Of((h, v) => {
        const w = new Intl.RelativeTimeFormat(h, {
          ...v
        });
        return (A) => w.format(A, v.range || "day");
      }),
      list: Of((h, v) => {
        const w = new Intl.ListFormat(h, {
          ...v
        });
        return (A) => w.format(A);
      })
    }, this.init(u);
  }
  init(u) {
    const h = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    }).interpolation;
    this.formatSeparator = h.formatSeparator ? h.formatSeparator : h.formatSeparator || ",";
  }
  add(u, h) {
    this.formats[u.toLowerCase().trim()] = h;
  }
  addCached(u, h) {
    this.formats[u.toLowerCase().trim()] = Of(h);
  }
  format(u, h, v) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return h.split(this.formatSeparator).reduce((A, T) => {
      const {
        formatName: F,
        formatOptions: H
      } = K_(T);
      if (this.formats[F]) {
        let U = A;
        try {
          const $ = w && w.formatParams && w.formatParams[w.interpolationkey] || {}, q = $.locale || $.lng || w.locale || w.lng || v;
          U = this.formats[F](A, q, {
            ...H,
            ...w,
            ...$
          });
        } catch ($) {
          this.logger.warn($);
        }
        return U;
      } else
        this.logger.warn(`there was no format function for ${F}`);
      return A;
    }, u);
  }
}
function eP(s, u) {
  s.pending[u] !== void 0 && (delete s.pending[u], s.pendingCount--);
}
class tP extends Xy {
  constructor(u, h, v) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = u, this.store = h, this.services = v, this.languageUtils = v.languageUtils, this.options = w, this.logger = Lo.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = w.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = w.maxRetries >= 0 ? w.maxRetries : 5, this.retryTimeout = w.retryTimeout >= 1 ? w.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(v, w.backend, w);
  }
  queueLoad(u, h, v, w) {
    const A = {}, T = {}, F = {}, H = {};
    return u.forEach((U) => {
      let $ = !0;
      h.forEach((q) => {
        const te = `${U}|${q}`;
        !v.reload && this.store.hasResourceBundle(U, q) ? this.state[te] = 2 : this.state[te] < 0 || (this.state[te] === 1 ? T[te] === void 0 && (T[te] = !0) : (this.state[te] = 1, $ = !1, T[te] === void 0 && (T[te] = !0), A[te] === void 0 && (A[te] = !0), H[q] === void 0 && (H[q] = !0)));
      }), $ || (F[U] = !0);
    }), (Object.keys(A).length || Object.keys(T).length) && this.queue.push({
      pending: T,
      pendingCount: Object.keys(T).length,
      loaded: {},
      errors: [],
      callback: w
    }), {
      toLoad: Object.keys(A),
      pending: Object.keys(T),
      toLoadLanguages: Object.keys(F),
      toLoadNamespaces: Object.keys(H)
    };
  }
  loaded(u, h, v) {
    const w = u.split("|"), A = w[0], T = w[1];
    h && this.emit("failedLoading", A, T, h), v && this.store.addResourceBundle(A, T, v), this.state[u] = h ? -1 : 2;
    const F = {};
    this.queue.forEach((H) => {
      Y_(H.loaded, [A], T), eP(H, u), h && H.errors.push(h), H.pendingCount === 0 && !H.done && (Object.keys(H.loaded).forEach((U) => {
        F[U] || (F[U] = {});
        const $ = H.loaded[U];
        $.length && $.forEach((q) => {
          F[U][q] === void 0 && (F[U][q] = !0);
        });
      }), H.done = !0, H.errors.length ? H.callback(H.errors) : H.callback());
    }), this.emit("loaded", F), this.queue = this.queue.filter((H) => !H.done);
  }
  read(u, h, v) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, A = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, T = arguments.length > 5 ? arguments[5] : void 0;
    if (!u.length)
      return T(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: u,
        ns: h,
        fcName: v,
        tried: w,
        wait: A,
        callback: T
      });
      return;
    }
    this.readingCalls++;
    const F = (U, $) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const q = this.waitingReads.shift();
        this.read(q.lng, q.ns, q.fcName, q.tried, q.wait, q.callback);
      }
      if (U && $ && w < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, u, h, v, w + 1, A * 2, T);
        }, A);
        return;
      }
      T(U, $);
    }, H = this.backend[v].bind(this.backend);
    if (H.length === 2) {
      try {
        const U = H(u, h);
        U && typeof U.then == "function" ? U.then(($) => F(null, $)).catch(F) : F(null, U);
      } catch (U) {
        F(U);
      }
      return;
    }
    return H(u, h, F);
  }
  prepareLoading(u, h) {
    let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, w = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), w && w();
    typeof u == "string" && (u = this.languageUtils.toResolveHierarchy(u)), typeof h == "string" && (h = [h]);
    const A = this.queueLoad(u, h, v, w);
    if (!A.toLoad.length)
      return A.pending.length || w(), null;
    A.toLoad.forEach((T) => {
      this.loadOne(T);
    });
  }
  load(u, h, v) {
    this.prepareLoading(u, h, {}, v);
  }
  reload(u, h, v) {
    this.prepareLoading(u, h, {
      reload: !0
    }, v);
  }
  loadOne(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const v = u.split("|"), w = v[0], A = v[1];
    this.read(w, A, "read", void 0, void 0, (T, F) => {
      T && this.logger.warn(`${h}loading namespace ${A} for language ${w} failed`, T), !T && F && this.logger.log(`${h}loaded namespace ${A} for language ${w}`, F), this.loaded(u, T, F);
    });
  }
  saveMissing(u, h, v, w, A) {
    let T = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, F = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(h)) {
      this.logger.warn(`did not save key "${v}" as the namespace "${h}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(v == null || v === "")) {
      if (this.backend && this.backend.create) {
        const H = {
          ...T,
          isUpdate: A
        }, U = this.backend.create.bind(this.backend);
        if (U.length < 6)
          try {
            let $;
            U.length === 5 ? $ = U(u, h, v, w, H) : $ = U(u, h, v, w), $ && typeof $.then == "function" ? $.then((q) => F(null, q)).catch(F) : F(null, $);
          } catch ($) {
            F($);
          }
        else
          U(u, h, v, w, F, H);
      }
      !u || !u[0] || this.store.addResource(u[0], h, v, w);
    }
  }
}
function iT() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !1,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(s) {
      let u = {};
      if (typeof s[1] == "object" && (u = s[1]), typeof s[1] == "string" && (u.defaultValue = s[1]), typeof s[2] == "string" && (u.tDescription = s[2]), typeof s[2] == "object" || typeof s[3] == "object") {
        const h = s[3] || s[2];
        Object.keys(h).forEach((v) => {
          u[v] = h[v];
        });
      }
      return u;
    },
    interpolation: {
      escapeValue: !0,
      format: (s, u, h, v) => s,
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
function aT(s) {
  return typeof s.ns == "string" && (s.ns = [s.ns]), typeof s.fallbackLng == "string" && (s.fallbackLng = [s.fallbackLng]), typeof s.fallbackNS == "string" && (s.fallbackNS = [s.fallbackNS]), s.supportedLngs && s.supportedLngs.indexOf("cimode") < 0 && (s.supportedLngs = s.supportedLngs.concat(["cimode"])), s;
}
function my() {
}
function nP(s) {
  Object.getOwnPropertyNames(Object.getPrototypeOf(s)).forEach((u) => {
    typeof s[u] == "function" && (s[u] = s[u].bind(s));
  });
}
class fg extends Xy {
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = aT(u), this.services = {}, this.logger = Lo, this.modules = {
      external: []
    }, nP(this), h && !this.isInitialized && !u.isClone) {
      if (!this.options.initImmediate)
        return this.init(u, h), this;
      setTimeout(() => {
        this.init(u, h);
      }, 0);
    }
  }
  init() {
    var u = this;
    let h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, v = arguments.length > 1 ? arguments[1] : void 0;
    typeof h == "function" && (v = h, h = {}), !h.defaultNS && h.defaultNS !== !1 && h.ns && (typeof h.ns == "string" ? h.defaultNS = h.ns : h.ns.indexOf("translation") < 0 && (h.defaultNS = h.ns[0]));
    const w = iT();
    this.options = {
      ...w,
      ...this.options,
      ...aT(h)
    }, this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
      ...w.interpolation,
      ...this.options.interpolation
    }), h.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = h.keySeparator), h.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = h.nsSeparator);
    function A(H) {
      return H ? typeof H == "function" ? new H() : H : null;
    }
    if (!this.options.isClone) {
      this.modules.logger ? Lo.init(A(this.modules.logger), this.options) : Lo.init(null, this.options);
      let H;
      this.modules.formatter ? H = this.modules.formatter : typeof Intl < "u" && (H = J_);
      const U = new tT(this.options);
      this.store = new JA(this.options.resources, this.options);
      const $ = this.services;
      $.logger = Lo, $.resourceStore = this.store, $.languageUtils = U, $.pluralResolver = new Z_(U, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), H && (!this.options.interpolation.format || this.options.interpolation.format === w.interpolation.format) && ($.formatter = A(H), $.formatter.init($, this.options), this.options.interpolation.format = $.formatter.format.bind($.formatter)), $.interpolator = new Q_(this.options), $.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, $.backendConnector = new tP(A(this.modules.backend), $.resourceStore, $, this.options), $.backendConnector.on("*", function(q) {
        for (var te = arguments.length, se = new Array(te > 1 ? te - 1 : 0), ae = 1; ae < te; ae++)
          se[ae - 1] = arguments[ae];
        u.emit(q, ...se);
      }), this.modules.languageDetector && ($.languageDetector = A(this.modules.languageDetector), $.languageDetector.init && $.languageDetector.init($, this.options.detection, this.options)), this.modules.i18nFormat && ($.i18nFormat = A(this.modules.i18nFormat), $.i18nFormat.init && $.i18nFormat.init(this)), this.translator = new zy(this.services, this.options), this.translator.on("*", function(q) {
        for (var te = arguments.length, se = new Array(te > 1 ? te - 1 : 0), ae = 1; ae < te; ae++)
          se[ae - 1] = arguments[ae];
        u.emit(q, ...se);
      }), this.modules.external.forEach((q) => {
        q.init && q.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, v || (v = my), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const H = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      H.length > 0 && H[0] !== "dev" && (this.options.lng = H[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((H) => {
      this[H] = function() {
        return u.store[H](...arguments);
      };
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((H) => {
      this[H] = function() {
        return u.store[H](...arguments), u;
      };
    });
    const T = eg(), F = () => {
      const H = (U, $) => {
        this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), T.resolve($), v(U, $);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized)
        return H(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, H);
    };
    return this.options.resources || !this.options.initImmediate ? F() : setTimeout(F, 0), T;
  }
  loadResources(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : my;
    const v = typeof u == "string" ? u : this.language;
    if (typeof u == "function" && (h = u), !this.options.resources || this.options.partialBundledLanguages) {
      if (v && v.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0))
        return h();
      const w = [], A = (T) => {
        !T || T === "cimode" || this.services.languageUtils.toResolveHierarchy(T).forEach((F) => {
          F !== "cimode" && w.indexOf(F) < 0 && w.push(F);
        });
      };
      v ? A(v) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((T) => A(T)), this.options.preload && this.options.preload.forEach((T) => A(T)), this.services.backendConnector.load(w, this.options.ns, (T) => {
        !T && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), h(T);
      });
    } else
      h(null);
  }
  reloadResources(u, h, v) {
    const w = eg();
    return u || (u = this.languages), h || (h = this.options.ns), v || (v = my), this.services.backendConnector.reload(u, h, (A) => {
      w.resolve(), v(A);
    }), w;
  }
  use(u) {
    if (!u)
      throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!u.type)
      throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return u.type === "backend" && (this.modules.backend = u), (u.type === "logger" || u.log && u.warn && u.error) && (this.modules.logger = u), u.type === "languageDetector" && (this.modules.languageDetector = u), u.type === "i18nFormat" && (this.modules.i18nFormat = u), u.type === "postProcessor" && lE.addPostProcessor(u), u.type === "formatter" && (this.modules.formatter = u), u.type === "3rdParty" && this.modules.external.push(u), this;
  }
  setResolvedLanguage(u) {
    if (!(!u || !this.languages) && !(["cimode", "dev"].indexOf(u) > -1))
      for (let h = 0; h < this.languages.length; h++) {
        const v = this.languages[h];
        if (!(["cimode", "dev"].indexOf(v) > -1) && this.store.hasLanguageSomeTranslations(v)) {
          this.resolvedLanguage = v;
          break;
        }
      }
  }
  changeLanguage(u, h) {
    var v = this;
    this.isLanguageChangingTo = u;
    const w = eg();
    this.emit("languageChanging", u);
    const A = (H) => {
      this.language = H, this.languages = this.services.languageUtils.toResolveHierarchy(H), this.resolvedLanguage = void 0, this.setResolvedLanguage(H);
    }, T = (H, U) => {
      U ? (A(U), this.translator.changeLanguage(U), this.isLanguageChangingTo = void 0, this.emit("languageChanged", U), this.logger.log("languageChanged", U)) : this.isLanguageChangingTo = void 0, w.resolve(function() {
        return v.t(...arguments);
      }), h && h(H, function() {
        return v.t(...arguments);
      });
    }, F = (H) => {
      !u && !H && this.services.languageDetector && (H = []);
      const U = typeof H == "string" ? H : this.services.languageUtils.getBestMatchFromCodes(H);
      U && (this.language || A(U), this.translator.language || this.translator.changeLanguage(U), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(U)), this.loadResources(U, ($) => {
        T($, U);
      });
    };
    return !u && this.services.languageDetector && !this.services.languageDetector.async ? F(this.services.languageDetector.detect()) : !u && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(F) : this.services.languageDetector.detect(F) : F(u), w;
  }
  getFixedT(u, h, v) {
    var w = this;
    const A = function(T, F) {
      let H;
      if (typeof F != "object") {
        for (var U = arguments.length, $ = new Array(U > 2 ? U - 2 : 0), q = 2; q < U; q++)
          $[q - 2] = arguments[q];
        H = w.options.overloadTranslationOptionHandler([T, F].concat($));
      } else
        H = {
          ...F
        };
      H.lng = H.lng || A.lng, H.lngs = H.lngs || A.lngs, H.ns = H.ns || A.ns, H.keyPrefix = H.keyPrefix || v || A.keyPrefix;
      const te = w.options.keySeparator || ".";
      let se;
      return H.keyPrefix && Array.isArray(T) ? se = T.map((ae) => `${H.keyPrefix}${te}${ae}`) : se = H.keyPrefix ? `${H.keyPrefix}${te}${T}` : T, w.t(se, H);
    };
    return typeof u == "string" ? A.lng = u : A.lngs = u, A.ns = h, A.keyPrefix = v, A;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(u) {
    this.options.defaultNS = u;
  }
  hasLoadedNamespace(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const v = h.lng || this.resolvedLanguage || this.languages[0], w = this.options ? this.options.fallbackLng : !1, A = this.languages[this.languages.length - 1];
    if (v.toLowerCase() === "cimode")
      return !0;
    const T = (F, H) => {
      const U = this.services.backendConnector.state[`${F}|${H}`];
      return U === -1 || U === 2;
    };
    if (h.precheck) {
      const F = h.precheck(this, T);
      if (F !== void 0)
        return F;
    }
    return !!(this.hasResourceBundle(v, u) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || T(v, u) && (!w || T(A, u)));
  }
  loadNamespaces(u, h) {
    const v = eg();
    return this.options.ns ? (typeof u == "string" && (u = [u]), u.forEach((w) => {
      this.options.ns.indexOf(w) < 0 && this.options.ns.push(w);
    }), this.loadResources((w) => {
      v.resolve(), h && h(w);
    }), v) : (h && h(), Promise.resolve());
  }
  loadLanguages(u, h) {
    const v = eg();
    typeof u == "string" && (u = [u]);
    const w = this.options.preload || [], A = u.filter((T) => w.indexOf(T) < 0);
    return A.length ? (this.options.preload = w.concat(A), this.loadResources((T) => {
      v.resolve(), h && h(T);
    }), v) : (h && h(), Promise.resolve());
  }
  dir(u) {
    if (u || (u = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !u)
      return "rtl";
    const h = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], v = this.services && this.services.languageUtils || new tT(iT());
    return h.indexOf(v.getLanguagePartFromCode(u)) > -1 || u.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = arguments.length > 1 ? arguments[1] : void 0;
    return new fg(u, h);
  }
  cloneInstance() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : my;
    const v = u.forkResourceStore;
    v && delete u.forkResourceStore;
    const w = {
      ...this.options,
      ...u,
      isClone: !0
    }, A = new fg(w);
    return (u.debug !== void 0 || u.prefix !== void 0) && (A.logger = A.logger.clone(u)), ["store", "services", "language"].forEach((T) => {
      A[T] = this[T];
    }), A.services = {
      ...this.services
    }, A.services.utils = {
      hasLoadedNamespace: A.hasLoadedNamespace.bind(A)
    }, v && (A.store = new JA(this.store.data, w), A.services.resourceStore = A.store), A.translator = new zy(A.services, w), A.translator.on("*", function(T) {
      for (var F = arguments.length, H = new Array(F > 1 ? F - 1 : 0), U = 1; U < F; U++)
        H[U - 1] = arguments[U];
      A.emit(T, ...H);
    }), A.init(w, h), A.translator.options = w, A.translator.backendConnector.services.utils = {
      hasLoadedNamespace: A.hasLoadedNamespace.bind(A)
    }, A;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const Mi = fg.createInstance();
Mi.createInstance = fg.createInstance;
Mi.createInstance;
Mi.dir;
Mi.init;
Mi.loadResources;
Mi.reloadResources;
Mi.use;
const rP = Mi.changeLanguage;
Mi.getFixedT;
Mi.t;
Mi.exists;
Mi.setDefaultNamespace;
Mi.hasLoadedNamespace;
Mi.loadNamespaces;
Mi.loadLanguages;
const Yr = (s, u) => Mi.t(s, u), iP = {
  common: {
    ok: "Okay",
    "not-found": "Not Found",
    settings: "Settings",
    home: "Home",
    user: "User",
    tenant: "Tenant",
    admin: "Administrator",
    calls: "Calls",
    viewer: "Viewer",
    role: "Role",
    roles: "Roles",
    add: "Add",
    adherence: "Adherence",
    "file-type": "File Type",
    file: "File",
    "contact-right-person": "Contact Right Person",
    error: "Error",
    cancel: "Cancel",
    "real-time": "Real Time",
    back: "Back",
    name: "Name",
    email: "Email",
    group: "Group",
    password: "Password",
    services: "Services",
    visualization: "Visualization",
    table: "Table",
    chart: "Chart",
    continue: "Continue",
    close: "Close",
    save: "Save",
    open: "Open",
    break: "Break",
    breaks: "Breaks",
    edit: "Edit",
    logout: "Log Out",
    new: "New",
    agents: "Agents",
    agent: "Agent",
    users: "Users",
    applications: "Applications",
    general: "General",
    workgroups: "Work Groups",
    scalesgroups: "Scales Group",
    scales: "Scales",
    remove: "Remove",
    company: "Company",
    companies: "Companies",
    database: "Databases",
    theme: "Theme",
    language: "Language",
    search: "Search",
    done: "Done",
    next: "Next",
    previous: "Previous",
    loading: "Loading",
    journey: "Journey",
    action: "Action",
    start: "Start",
    entry: "Entry",
    end: "End",
    finish: "Finish"
  },
  complement: {
    add: "Add {{complement}}",
    select: "Select {{complement}}",
    remove: "Remove {{complement}}",
    name: "{{complement}}`s name",
    new: "New {{complement}}",
    edit: "Edit {{complement}}",
    open: "Open {{complement}}",
    close: "Close {{complement}}"
  },
  settings: {
    "application-title": "Select a company and database",
    tabs: {
      personal: "Personal",
      application: "Application"
    },
    themes: {
      coffe: "Coffee",
      light: "Light",
      dark: "Dark",
      forest: "Forest"
    },
    langs: {
      english: "English",
      portuguese: "Portuguese",
      spanish: "Spanish"
    }
  },
  messages: {
    "not-found": "No {{item}} was found",
    typing: "Type your {{item}}...",
    success: "{{item}} {{action}} successfully",
    failed: "{{item}} {{action}} failed"
  },
  table: {
    page: "Page",
    of: "of",
    "per-page": "Per page",
    items: "Items"
  },
  picker: {
    date: {
      days: {
        su: "Su",
        mo: "Mo",
        tu: "Tu",
        we: "We",
        th: "Th",
        fr: "Fr",
        sa: "Sa"
      }
    }
  },
  select: {
    "select-one": "Select one of the options"
  },
  sidebar: {
    general: "General",
    services: "Services",
    calls: "Calls",
    users: "Users",
    agents: "Agents",
    dashboard: "Dashboard",
    adherence: "Adherence",
    "real-time": "Real Time",
    workgroups: "Workgroups",
    staffing: "Staffing",
    home: "Home",
    scales: "Scales",
    scalesgroups: "Scales Groups",
    forecast: "Forecast"
  },
  actions: {
    create: "create",
    created: "created",
    download: "download",
    downloaded: "downloaded",
    update: "update",
    updated: "updated",
    remove: "remove",
    removed: "removed"
  },
  data: {
    users: {
      firstName: "First Name",
      lastName: "Last Name",
      email: "Email",
      role: "Role",
      active: "Active"
    },
    workgroups: {
      name: "Name",
      agents: "Agents",
      workGroups: "Work Groups",
      timeScale: "Time Scale",
      supervisor: "Supervisor"
    },
    scales: {
      firstName: "First Name",
      lastName: "Last Name",
      baseUserId: "Base User ID"
    },
    scalesgroups: {
      name: "Name",
      timeScale: "Time Scale",
      workGroups: "Work Groups",
      breaks: "Breaks"
    },
    services: {
      attempts: "Attempts",
      hour: "Hour",
      answereds: "Answereds",
      contact_right_person: "Contact Right Person",
      loggeds_agents: "Loggeds Agents",
      average_service_time: "Average Service Time"
    },
    charts: {
      absenteeism: "Absenteeism",
      topAdherenceOffenders: "Top Adherence Offenders",
      mediumWorkGroupsAdherence: "Medium WorkGroups Adherence",
      totalWorkGroupsExtraHours: "Total Work Groups Extra Hours",
      mediumWorkGroupsBreaksTimes: "Medium Work Groups Breaks Times",
      mediumWorkGroupsLoggedTimes: "Medium Work Groups Logged Times"
    },
    "real-time": {
      serviceName: "Service Name",
      serviceId: "Service Id",
      allAgentsLoggeds: "Agents Logged In",
      allAgentsInCall: "Agents in Call",
      allAgentIdle: "Agents Idle",
      allAgentNotReady: "Agents Not Ready",
      allAgentOthers: "Others",
      occupancyRate: "Occupancy Rate",
      inHold: "In Hold",
      inWrap: "In Wrap",
      date: "Date",
      totalCalls: "Total Calls",
      answered: "Answered",
      answeredPercentage: "Answered Percentage",
      notAnswered: "Not Answered",
      notAnsweredPercentage: "Not Answered Percentage",
      busy: "Busy",
      busyPercentage: "Busy Percentage",
      notAttend: "Not Attended",
      notAttendPercentage: "Not Attended Percentage",
      message: "Message",
      messagePercentage: "Message Percentage",
      cpc: "Contact Right Person"
    }
  }
}, aP = {
  common: {
    ok: "Aceptar",
    "not-found": "No Encontrado",
    settings: "Configuración",
    home: "Inicio",
    user: "Usuario",
    tenant: "Inquilino",
    admin: "Administrador",
    calls: "Llamadas",
    viewer: "Visor",
    role: "Rol",
    roles: "Roles",
    add: "Agregar",
    adherence: "Adherencia",
    "file-type": "Tipo de Archivo",
    file: "Archivo",
    "contact-right-person": "Contactar a la Persona Correcta",
    error: "Error",
    cancel: "Cancelar",
    "real-time": "Tiempo Real",
    back: "Volver",
    name: "Nombre",
    email: "Correo Electrónico",
    group: "Grupo",
    password: "Contraseña",
    services: "Servicios",
    visualization: "Visualización",
    table: "Tabla",
    chart: "Gráfico",
    continue: "Continuar",
    close: "Cerrar",
    save: "Guardar",
    open: "Abrir",
    break: "Descanso",
    breaks: "Descansos",
    edit: "Editar",
    logout: "Cerrar Sesión",
    new: "Nuevo",
    agents: "Agentes",
    agent: "Agente",
    users: "Usuarios",
    applications: "Aplicaciones",
    general: "General",
    workgroups: "Grupos de Trabajo",
    scalesgroups: "Grupos de Escalas",
    scales: "Escalas",
    remove: "Eliminar",
    company: "Empresa",
    companies: "Empresas",
    database: "Base de Datos",
    theme: "Tema",
    language: "Idioma",
    search: "Buscar",
    done: "Listo",
    next: "Siguiente",
    previous: "Anterior",
    loading: "Cargando",
    journey: "Trayecto",
    action: "Acción",
    start: "Comenzar",
    entry: "Entrada",
    end: "Fin",
    finish: "Terminar"
  },
  complement: {
    add: "Agregar {{complement}}",
    select: "Seleccionar {{complement}}",
    remove: "Eliminar {{complement}}",
    name: "Nombre de {{complement}}",
    new: "Nuevo {{complement}}",
    edit: "Editar {{complement}}",
    open: "Abrir {{complement}}",
    close: "Cerrar {{complement}}"
  },
  settings: {
    "application-title": "Seleccione una empresa y una base de datos",
    tabs: {
      personal: "Personal",
      application: "Aplicación"
    },
    themes: {
      coffe: "Café",
      light: "Claro",
      dark: "Oscuro",
      forest: "Bosque"
    },
    langs: {
      english: "Inglés",
      portuguese: "Portugués",
      spanish: "Español"
    }
  },
  messages: {
    "not-found": "No se encontró {{item}}",
    typing: "Escriba su {{item}}...",
    success: "{{item}} {{action}} exitosamente",
    failed: "{{item}} {{action}} falló"
  },
  table: {
    page: "Página",
    of: "de",
    "per-page": "Por página",
    items: "Elementos"
  },
  picker: {
    date: {
      days: {
        su: "Do",
        mo: "Lu",
        tu: "Ma",
        we: "Mi",
        th: "Ju",
        fr: "Vi",
        sa: "Sá"
      }
    }
  },
  select: {
    "select-one": "Selecciona una de las opciones"
  },
  sidebar: {
    general: "General",
    services: "Servicios",
    calls: "Llamadas",
    users: "Usuarios",
    agents: "Agentes",
    dashboard: "Tablero",
    adherence: "Adherencia",
    "real-time": "Tiempo Real",
    workgroups: "Grupos de Trabajo",
    staffing: "Dotación",
    home: "Inicio",
    scales: "Escalas",
    scalesgroups: "Grupos de Escalas",
    forecast: "Pronóstico"
  },
  actions: {
    create: "crear",
    created: "creado",
    download: "descargar",
    downloaded: "descargado",
    update: "actualizar",
    updated: "actualizado",
    remove: "eliminar",
    removed: "eliminado"
  },
  data: {
    users: {
      firstName: "Primer Nombre",
      lastName: "Apellido",
      email: "Correo Electrónico",
      role: "Rol",
      active: "Activo"
    },
    workgroups: {
      name: "Nombre",
      agents: "Agentes",
      workGroups: "Grupos de Trabajo",
      timeScale: "Escala de Tiempo",
      supervisor: "Supervisor"
    },
    scales: {
      firstName: "Primer Nombre",
      lastName: "Apellido",
      baseUserId: "ID del Usuario Base"
    },
    scalesgroups: {
      name: "Nombre",
      timeScale: "Escala de Tiempo",
      workGroups: "Grupos de Trabajo",
      breaks: "Descansos"
    },
    services: {
      attempts: "Intentos",
      hour: "Hora",
      answereds: "Atendidas",
      contact_right_person: "Contactar a la Persona Correcta",
      loggeds_agents: "Agentes Registrados",
      average_service_time: "Tiempo Promedio de Servicio"
    },
    charts: {
      absenteeism: "Ausentismo",
      topAdherenceOffenders: "Principales Infractores de Adherencia",
      mediumWorkGroupsAdherence: "Adherencia Media de Grupos de Trabajo",
      totalWorkGroupsExtraHours: "Total de Horas Extra de Grupos de Trabajo",
      mediumWorkGroupsBreaksTimes: "Tiempo Medio de Descansos de Grupos de Trabajo",
      mediumWorkGroupsLoggedTimes: "Tiempo Medio de Registro de Grupos de Trabajo"
    },
    "real-time": {
      serviceName: "Nombre del Servicio",
      serviceId: "ID del Servicio",
      allAgentsLoggeds: "Agentes Registrados",
      allAgentsInCall: "Agentes en Llamada",
      allAgentIdle: "Agentes Inactivos",
      allAgentNotReady: "Agentes No Disponibles",
      allAgentOthers: "Otros",
      occupancyRate: "Tasa de Ocupación",
      inHold: "En Espera",
      inWrap: "En Finalización",
      date: "Fecha",
      totalCalls: "Total de Llamadas",
      answered: "Atendidas",
      answeredPercentage: "Porcentaje Atendidas",
      notAnswered: "No Atendidas",
      notAnsweredPercentage: "Porcentaje No Atendidas",
      busy: "Ocupadas",
      busyPercentage: "Porcentaje Ocupadas",
      notAttend: "No Atendido",
      notAttendPercentage: "Porcentaje No Atendido",
      message: "Mensaje",
      messagePercentage: "Porcentaje de Mensajes",
      cpc: "Contactar a la Persona Correcta"
    }
  }
}, sP = {
  common: {
    ok: "Ok",
    "not-found": "Não Encontrado",
    settings: "Configurações",
    home: "Início",
    user: "Usuário",
    tenant: "Locatário",
    admin: "Administrador",
    calls: "Chamadas",
    viewer: "Visualizador",
    role: "Cargo",
    roles: "Cargos",
    add: "Adicionar",
    adherence: "Adesão",
    "file-type": "Tipo de Arquivo",
    file: "Arquivo",
    "contact-right-person": "Entrar em Contato com a Pessoa Certa",
    error: "Erro",
    cancel: "Cancelar",
    "real-time": "Tempo Real",
    back: "Voltar",
    name: "Nome",
    email: "E-mail",
    group: "Grupo",
    password: "Senha",
    services: "Serviços",
    visualization: "Visualização",
    table: "Tabela",
    chart: "Gráfico",
    continue: "Continuar",
    close: "Fechar",
    save: "Salvar",
    open: "Abrir",
    break: "Pausa",
    breaks: "Pausas",
    edit: "Editar",
    logout: "Sair",
    new: "Novo",
    agents: "Agentes",
    agent: "Agente",
    users: "Usuários",
    applications: "Aplicações",
    general: "Geral",
    workgroups: "Grupos de Trabalho",
    scalesgroups: "Grupos de Escalas",
    scales: "Escalas",
    remove: "Remover",
    company: "Empresa",
    companies: "Empresas",
    database: "Banco de Dados",
    theme: "Tema",
    language: "Idioma",
    search: "Pesquisar",
    done: "Concluído",
    next: "Próximo",
    previous: "Anterior",
    loading: "Carregando",
    journey: "Jornada",
    action: "Ação",
    start: "Iniciar",
    entry: "Entrada",
    end: "Fim",
    finish: "Terminar"
  },
  complement: {
    add: "Adicionar {{complement}}",
    select: "Selecionar {{complement}}",
    remove: "Remover {{complement}}",
    name: "Nome de {{complement}}",
    new: "Novo {{complement}}",
    edit: "Editar {{complement}}",
    open: "Abrir {{complement}}",
    close: "Fechar {{complement}}"
  },
  settings: {
    "application-title": "Selecione uma empresa e banco de dados",
    tabs: {
      personal: "Pessoal",
      application: "Aplicação"
    },
    themes: {
      coffe: "Café",
      light: "Claro",
      dark: "Escuro",
      forest: "Floresta"
    },
    langs: {
      english: "Inglês",
      portuguese: "Português",
      spanish: "Espanhol"
    }
  },
  messages: {
    "not-found": "Nenhum {{item}} encontrado",
    typing: "Digite o seu {{item}}...",
    success: "{{item}} {{action}} com sucesso",
    failed: "{{item}} {{action}} falhou"
  },
  table: {
    page: "Página",
    of: "de",
    "per-page": "Por página",
    items: "Itens"
  },
  picker: {
    date: {
      days: {
        su: "Dom",
        mo: "Seg",
        tu: "Ter",
        we: "Qua",
        th: "Qui",
        fr: "Sex",
        sa: "Sáb"
      }
    }
  },
  select: {
    "select-one": "Selecione uma das opções"
  },
  sidebar: {
    general: "Geral",
    services: "Serviços",
    calls: "Chamadas",
    users: "Usuários",
    agents: "Agentes",
    dashboard: "Painel",
    adherence: "Adesão",
    "real-time": "Tempo Real",
    workgroups: "Grupos de Trabalho",
    staffing: "Dimensionamento",
    home: "Início",
    scales: "Escalas",
    scalesgroups: "Grupos de Escalas",
    forecast: "Previsão"
  },
  actions: {
    create: "criar",
    created: "criado",
    download: "baixar",
    downloaded: "baixado",
    update: "atualizar",
    updated: "atualizado",
    remove: "remover",
    removed: "removido"
  },
  data: {
    users: {
      firstName: "Primeiro Nome",
      lastName: "Sobrenome",
      email: "E-mail",
      role: "Cargo",
      active: "Ativo"
    },
    workgroups: {
      name: "Nome",
      agents: "Agentes",
      workGroups: "Grupos de Trabalho",
      timeScale: "Escala de Tempo",
      supervisor: "Supervisor"
    },
    scales: {
      firstName: "Primeiro Nome",
      lastName: "Sobrenome",
      baseUserId: "ID do Usuário Base"
    },
    scalesgroups: {
      name: "Nome",
      timeScale: "Escala de Tempo",
      workGroups: "Grupos de Trabalho",
      breaks: "Pausas"
    },
    services: {
      attempts: "Tentativas",
      hour: "Hora",
      answereds: "Atendidas",
      contact_right_person: "Entrar em Contato com a Pessoa Certa",
      loggeds_agents: "Agentes Logados",
      average_service_time: "Tempo Médio de Atendimento"
    },
    charts: {
      absenteeism: "Absenteísmo",
      topAdherenceOffenders: "Principais Infratores de Adesão",
      mediumWorkGroupsAdherence: "Adesão Média dos Grupos de Trabalho",
      totalWorkGroupsExtraHours: "Total de Horas Extras dos Grupos de Trabalho",
      mediumWorkGroupsBreaksTimes: "Tempo Médio de Pausas dos Grupos de Trabalho",
      mediumWorkGroupsLoggedTimes: "Tempo Médio de Log dos Grupos de Trabalho"
    },
    "real-time": {
      serviceName: "Nome do Serviço",
      serviceId: "ID do Serviço",
      allAgentsLoggeds: "Agentes Logados",
      allAgentsInCall: "Agentes em Chamada",
      allAgentIdle: "Agentes Inativos",
      allAgentNotReady: "Agentes Não Prontos",
      allAgentOthers: "Outros",
      occupancyRate: "Taxa de Ocupação",
      inHold: "Em Espera",
      inWrap: "Em Encerramento",
      date: "Data",
      totalCalls: "Total de Chamadas",
      answered: "Atendidas",
      answeredPercentage: "Percentual Atendido",
      notAnswered: "Não Atendidas",
      notAnsweredPercentage: "Percentual Não Atendido",
      busy: "Ocupadas",
      busyPercentage: "Percentual Ocupado",
      notAttend: "Não Atendido",
      notAttendPercentage: "Percentual Não Atendido",
      message: "Mensagem",
      messagePercentage: "Percentual de Mensagens",
      cpc: "Contato com a Pessoa Certa"
    }
  }
}, uE = ({ language: s = "en" }) => {
  Mi.init({
    lng: s,
    fallbackLng: "en",
    resources: {
      en: { translation: iP },
      "pt-BR": { translation: sP },
      es: { translation: aP }
    }
  });
}, oP = (s) => {
  rP(s);
}, lP = (s, u, h, v, w, A) => {
  u = u - 16;
  const T = u / v, F = [];
  return Object.values(s).forEach((H) => {
    let U = "";
    H.forEach(($, q) => {
      q === 0 && (A ? U += `M-4,${u + 50}L-4,${u - $ * T}` : U += `M0,${u - $ * T}`), q > 0 && (U += `L${w * q},${u - $ * T}`), q === H.length - 1 && (U += `L${h + 4},${u + 50}`);
    }), F.push(U);
  }), F;
}, uP = ({
  data: s,
  width: u,
  height: h,
  filled: v = !1,
  tooltipRef: w,
  translation: A,
  maxItemValue: T,
  lineRef: F
}) => {
  if (u === 0 || h === 0 || s.length === 0)
    return null;
  const H = Object.keys(s[0]).length, U = u / (s.length - 1) + 1, $ = s.reduce(
    (te, se) => (Object.entries(se).forEach(
      ([ae, ue]) => {
        te != null && te[ae] ? te[ae].push(ue) : te[ae] = [ue];
      }
    ), te),
    {}
  ), q = lP(
    $,
    h,
    u,
    T,
    U,
    v
  );
  return /* @__PURE__ */ fe.jsx(fe.Fragment, { children: q == null ? void 0 : q.map((te, se) => /* @__PURE__ */ fe.jsxs("g", { children: [
    /* @__PURE__ */ fe.jsx(
      "path",
      {
        className: v ? "filled" : "",
        d: te,
        strokeWidth: "3",
        fill: v ? "currentColor" : "none",
        strokeLinejoin: "round",
        strokeLinecap: "round",
        onMouseMove: (ae) => {
          const ue = ae.clientX;
          if (F.current) {
            const Re = F.current.parentNode.getBoundingClientRect().left, Q = Array.from({ length: H }).map(
              (Ee, re) => U * re
            ).map(
              (Ee) => Math.abs(ue - Re - Ee)
            ), we = Q.indexOf(
              Math.min(...Q)
            );
            if (w.current) {
              const Ee = Object.entries(
                s[we] ?? []
              ).reduce((re, ve) => (re += `<span>${Yr(
                `data.${A}.${ve[0]}`
              )}: ${ve[1]}</span>`, re), "");
              w.current.innerHTML = `
                       ${Ee}
                    `;
            }
          }
        }
      }
    ),
    v && /* @__PURE__ */ fe.jsxs("linearGradient", { id: `lgrad-${se}`, gradientTransform: "rotate(90)", children: [
      /* @__PURE__ */ fe.jsx("stop", { offset: "0%", stopColor: "#4169e1" }),
      /* @__PURE__ */ fe.jsx("stop", { offset: "75%", stopColor: "#c44764" })
    ] })
  ] }, se)) });
}, cP = ({
  label: s,
  onMouseEnter: u,
  x: h,
  y: v,
  height: w,
  width: A,
  ...T
}) => {
  if (T.value === 0)
    return null;
  const F = String(T.value).length * 4, H = A / 2 - F;
  return /* @__PURE__ */ fe.jsxs(
    "g",
    {
      onMouseEnter: () => u == null ? void 0 : u({
        label: s,
        value: Number(T.value)
      }),
      onMouseMove: (U) => {
        var $;
        return ($ = T.onMouseMove) == null ? void 0 : $.call(T, { x: U.clientX, y: U.clientY });
      },
      children: [
        /* @__PURE__ */ fe.jsx("text", { x: h + H, y: v - 5, children: T.value }),
        /* @__PURE__ */ fe.jsx("rect", { x: h, y: v, height: w, width: A, rx: 4 })
      ]
    }
  );
}, dP = ({
  width: s,
  height: u,
  data: h,
  showOnly: v,
  tooltipRef: w,
  groupBy: A,
  translation: T,
  maxItemValue: F
}) => {
  if (console.log(h), s === 0 || u === 0 || h.length === 0)
    return null;
  v && (h = h.map((q) => ({
    [A]: q[A],
    [v]: q[v]
  })));
  const H = Object.keys(h[0]).length;
  let U = 24, $ = (s - U * (h.length - 1)) / h.length;
  return v ? U = 24 : (U = 0, $ = (s - U * (h.length - 1) * (H - 1)) / h.length / H), console.log(h, $, H), /* @__PURE__ */ fe.jsx(fe.Fragment, { children: h.map((q, te) => {
    const se = (u - 40) / F, ae = { ...q };
    delete ae[A];
    let ue = 1, Ne = te * ue * H * (($ + U) / (H - 1)), Q = te > 0 ? Ne / 2 : Ne;
    Q += String(q[A]).length * 6;
    const we = ($ + U) * H;
    let Ee = 0;
    if (!v) {
      const re = (s - U * (h.length - 1)) / h.length;
      Q = re * te + re / 2 - String(q[A]).length * 8;
    }
    return console.log(Yr("data.workgroups.name")), /* @__PURE__ */ fe.jsxs("g", { children: [
      Object.entries(ae).map(([re, ve]) => {
        const Le = Ee;
        if (ve === 0)
          return null;
        Ne = Le * H * (($ + U * (H - 1)) / (H - 1)), Ne = Ne + te * we, v && (Ne /= 2);
        const Be = Number(ve) * se;
        return ue += 1, Ee += 1, /* @__PURE__ */ fe.jsx(
          cP,
          {
            x: Ne + 16,
            value: Number(ve),
            y: u - 20 - Be,
            onMouseEnter: ({ label: Ge, value: ft }) => {
              w.current && (w.current.innerHTML = `
                         <span>${Ge}: ${ft}</span>
                    `);
            },
            itemIndex: te,
            width: $,
            height: Be,
            label: Yr(
              `data.${T}.${re}`
            )
          },
          `${re}-${te}`
        );
      }),
      /* @__PURE__ */ fe.jsx(
        "text",
        {
          y: u - 4,
          x: Q + ($ - U - $ * (H - 3) - String(q[A]).length * 8) / 2 + 16,
          children: q[A]
        }
      )
    ] }, te);
  }) });
};
//! moment.js
//! version : 2.29.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var cE;
function Ve() {
  return cE.apply(null, arguments);
}
function fP(s) {
  cE = s;
}
function Us(s) {
  return s instanceof Array || Object.prototype.toString.call(s) === "[object Array]";
}
function Fc(s) {
  return s != null && Object.prototype.toString.call(s) === "[object Object]";
}
function En(s, u) {
  return Object.prototype.hasOwnProperty.call(s, u);
}
function D1(s) {
  if (Object.getOwnPropertyNames)
    return Object.getOwnPropertyNames(s).length === 0;
  var u;
  for (u in s)
    if (En(s, u))
      return !1;
  return !0;
}
function Da(s) {
  return s === void 0;
}
function Tl(s) {
  return typeof s == "number" || Object.prototype.toString.call(s) === "[object Number]";
}
function bg(s) {
  return s instanceof Date || Object.prototype.toString.call(s) === "[object Date]";
}
function dE(s, u) {
  var h = [], v, w = s.length;
  for (v = 0; v < w; ++v)
    h.push(u(s[v], v));
  return h;
}
function Eu(s, u) {
  for (var h in u)
    En(u, h) && (s[h] = u[h]);
  return En(u, "toString") && (s.toString = u.toString), En(u, "valueOf") && (s.valueOf = u.valueOf), s;
}
function Do(s, u, h, v) {
  return NE(s, u, h, v, !0).utc();
}
function hP() {
  return {
    empty: !1,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: !1,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: !1,
    userInvalidated: !1,
    iso: !1,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: !1,
    weekdayMismatch: !1
  };
}
function rn(s) {
  return s._pf == null && (s._pf = hP()), s._pf;
}
var a1;
Array.prototype.some ? a1 = Array.prototype.some : a1 = function(s) {
  var u = Object(this), h = u.length >>> 0, v;
  for (v = 0; v < h; v++)
    if (v in u && s.call(this, u[v], v, u))
      return !0;
  return !1;
};
function O1(s) {
  if (s._isValid == null) {
    var u = rn(s), h = a1.call(u.parsedDateParts, function(w) {
      return w != null;
    }), v = !isNaN(s._d.getTime()) && u.overflow < 0 && !u.empty && !u.invalidEra && !u.invalidMonth && !u.invalidWeekday && !u.weekdayMismatch && !u.nullInput && !u.invalidFormat && !u.userInvalidated && (!u.meridiem || u.meridiem && h);
    if (s._strict && (v = v && u.charsLeftOver === 0 && u.unusedTokens.length === 0 && u.bigHour === void 0), Object.isFrozen == null || !Object.isFrozen(s))
      s._isValid = v;
    else
      return v;
  }
  return s._isValid;
}
function Vy(s) {
  var u = Do(NaN);
  return s != null ? Eu(rn(u), s) : rn(u).userInvalidated = !0, u;
}
var sT = Ve.momentProperties = [], Iw = !1;
function _1(s, u) {
  var h, v, w, A = sT.length;
  if (Da(u._isAMomentObject) || (s._isAMomentObject = u._isAMomentObject), Da(u._i) || (s._i = u._i), Da(u._f) || (s._f = u._f), Da(u._l) || (s._l = u._l), Da(u._strict) || (s._strict = u._strict), Da(u._tzm) || (s._tzm = u._tzm), Da(u._isUTC) || (s._isUTC = u._isUTC), Da(u._offset) || (s._offset = u._offset), Da(u._pf) || (s._pf = rn(u)), Da(u._locale) || (s._locale = u._locale), A > 0)
    for (h = 0; h < A; h++)
      v = sT[h], w = u[v], Da(w) || (s[v] = w);
  return s;
}
function wg(s) {
  _1(this, s), this._d = new Date(s._d != null ? s._d.getTime() : NaN), this.isValid() || (this._d = /* @__PURE__ */ new Date(NaN)), Iw === !1 && (Iw = !0, Ve.updateOffset(this), Iw = !1);
}
function Bs(s) {
  return s instanceof wg || s != null && s._isAMomentObject != null;
}
function fE(s) {
  Ve.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn("Deprecation warning: " + s);
}
function os(s, u) {
  var h = !0;
  return Eu(function() {
    if (Ve.deprecationHandler != null && Ve.deprecationHandler(null, s), h) {
      var v = [], w, A, T, F = arguments.length;
      for (A = 0; A < F; A++) {
        if (w = "", typeof arguments[A] == "object") {
          w += `
[` + A + "] ";
          for (T in arguments[0])
            En(arguments[0], T) && (w += T + ": " + arguments[0][T] + ", ");
          w = w.slice(0, -2);
        } else
          w = arguments[A];
        v.push(w);
      }
      fE(
        s + `
Arguments: ` + Array.prototype.slice.call(v).join("") + `
` + new Error().stack
      ), h = !1;
    }
    return u.apply(this, arguments);
  }, u);
}
var oT = {};
function hE(s, u) {
  Ve.deprecationHandler != null && Ve.deprecationHandler(s, u), oT[s] || (fE(u), oT[s] = !0);
}
Ve.suppressDeprecationWarnings = !1;
Ve.deprecationHandler = null;
function Oo(s) {
  return typeof Function < "u" && s instanceof Function || Object.prototype.toString.call(s) === "[object Function]";
}
function pP(s) {
  var u, h;
  for (h in s)
    En(s, h) && (u = s[h], Oo(u) ? this[h] = u : this["_" + h] = u);
  this._config = s, this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function s1(s, u) {
  var h = Eu({}, s), v;
  for (v in u)
    En(u, v) && (Fc(s[v]) && Fc(u[v]) ? (h[v] = {}, Eu(h[v], s[v]), Eu(h[v], u[v])) : u[v] != null ? h[v] = u[v] : delete h[v]);
  for (v in s)
    En(s, v) && !En(u, v) && Fc(s[v]) && (h[v] = Eu({}, h[v]));
  return h;
}
function P1(s) {
  s != null && this.set(s);
}
var o1;
Object.keys ? o1 = Object.keys : o1 = function(s) {
  var u, h = [];
  for (u in s)
    En(s, u) && h.push(u);
  return h;
};
var gP = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function vP(s, u, h) {
  var v = this._calendar[s] || this._calendar.sameElse;
  return Oo(v) ? v.call(u, h) : v;
}
function Mo(s, u, h) {
  var v = "" + Math.abs(s), w = u - v.length, A = s >= 0;
  return (A ? h ? "+" : "" : "-") + Math.pow(10, Math.max(0, w)).toString().substr(1) + v;
}
var N1 = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, yy = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, Fw = {}, zf = {};
function zt(s, u, h, v) {
  var w = v;
  typeof v == "string" && (w = function() {
    return this[v]();
  }), s && (zf[s] = w), u && (zf[u[0]] = function() {
    return Mo(w.apply(this, arguments), u[1], u[2]);
  }), h && (zf[h] = function() {
    return this.localeData().ordinal(
      w.apply(this, arguments),
      s
    );
  });
}
function mP(s) {
  return s.match(/\[[\s\S]/) ? s.replace(/^\[|\]$/g, "") : s.replace(/\\/g, "");
}
function yP(s) {
  var u = s.match(N1), h, v;
  for (h = 0, v = u.length; h < v; h++)
    zf[u[h]] ? u[h] = zf[u[h]] : u[h] = mP(u[h]);
  return function(w) {
    var A = "", T;
    for (T = 0; T < v; T++)
      A += Oo(u[T]) ? u[T].call(w, s) : u[T];
    return A;
  };
}
function Ay(s, u) {
  return s.isValid() ? (u = pE(u, s.localeData()), Fw[u] = Fw[u] || yP(u), Fw[u](s)) : s.localeData().invalidDate();
}
function pE(s, u) {
  var h = 5;
  function v(w) {
    return u.longDateFormat(w) || w;
  }
  for (yy.lastIndex = 0; h >= 0 && yy.test(s); )
    s = s.replace(
      yy,
      v
    ), yy.lastIndex = 0, h -= 1;
  return s;
}
var xP = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function bP(s) {
  var u = this._longDateFormat[s], h = this._longDateFormat[s.toUpperCase()];
  return u || !h ? u : (this._longDateFormat[s] = h.match(N1).map(function(v) {
    return v === "MMMM" || v === "MM" || v === "DD" || v === "dddd" ? v.slice(1) : v;
  }).join(""), this._longDateFormat[s]);
}
var wP = "Invalid date";
function SP() {
  return this._invalidDate;
}
var kP = "%d", CP = /\d{1,2}/;
function AP(s) {
  return this._ordinal.replace("%d", s);
}
var TP = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function EP(s, u, h, v) {
  var w = this._relativeTime[h];
  return Oo(w) ? w(s, u, h, v) : w.replace(/%d/i, s);
}
function RP(s, u) {
  var h = this._relativeTime[s > 0 ? "future" : "past"];
  return Oo(h) ? h(u) : h.replace(/%s/i, u);
}
var sg = {};
function Gi(s, u) {
  var h = s.toLowerCase();
  sg[h] = sg[h + "s"] = sg[u] = s;
}
function ls(s) {
  return typeof s == "string" ? sg[s] || sg[s.toLowerCase()] : void 0;
}
function z1(s) {
  var u = {}, h, v;
  for (v in s)
    En(s, v) && (h = ls(v), h && (u[h] = s[v]));
  return u;
}
var gE = {};
function $i(s, u) {
  gE[s] = u;
}
function LP(s) {
  var u = [], h;
  for (h in s)
    En(s, h) && u.push({ unit: h, priority: gE[h] });
  return u.sort(function(v, w) {
    return v.priority - w.priority;
  }), u;
}
function Gy(s) {
  return s % 4 === 0 && s % 100 !== 0 || s % 400 === 0;
}
function ss(s) {
  return s < 0 ? Math.ceil(s) || 0 : Math.floor(s);
}
function un(s) {
  var u = +s, h = 0;
  return u !== 0 && isFinite(u) && (h = ss(u)), h;
}
function Hf(s, u) {
  return function(h) {
    return h != null ? (vE(this, s, h), Ve.updateOffset(this, u), this) : Iy(this, s);
  };
}
function Iy(s, u) {
  return s.isValid() ? s._d["get" + (s._isUTC ? "UTC" : "") + u]() : NaN;
}
function vE(s, u, h) {
  s.isValid() && !isNaN(h) && (u === "FullYear" && Gy(s.year()) && s.month() === 1 && s.date() === 29 ? (h = un(h), s._d["set" + (s._isUTC ? "UTC" : "") + u](
    h,
    s.month(),
    Jy(h, s.month())
  )) : s._d["set" + (s._isUTC ? "UTC" : "") + u](h));
}
function MP(s) {
  return s = ls(s), Oo(this[s]) ? this[s]() : this;
}
function DP(s, u) {
  if (typeof s == "object") {
    s = z1(s);
    var h = LP(s), v, w = h.length;
    for (v = 0; v < w; v++)
      this[h[v].unit](s[h[v].unit]);
  } else if (s = ls(s), Oo(this[s]))
    return this[s](u);
  return this;
}
var mE = /\d/, Xa = /\d\d/, yE = /\d{3}/, I1 = /\d{4}/, $y = /[+-]?\d{6}/, nr = /\d\d?/, xE = /\d\d\d\d?/, bE = /\d\d\d\d\d\d?/, qy = /\d{1,3}/, F1 = /\d{1,4}/, Zy = /[+-]?\d{1,6}/, jf = /\d+/, Qy = /[+-]?\d+/, OP = /Z|[+-]\d\d:?\d\d/gi, Ky = /Z|[+-]\d\d(?::?\d\d)?/gi, _P = /[+-]?\d+(\.\d{1,3})?/, Sg = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, Fy;
Fy = {};
function vt(s, u, h) {
  Fy[s] = Oo(u) ? u : function(v, w) {
    return v && h ? h : u;
  };
}
function PP(s, u) {
  return En(Fy, s) ? Fy[s](u._strict, u._locale) : new RegExp(NP(s));
}
function NP(s) {
  return Wa(
    s.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(u, h, v, w, A) {
        return h || v || w || A;
      }
    )
  );
}
function Wa(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var l1 = {};
function Hn(s, u) {
  var h, v = u, w;
  for (typeof s == "string" && (s = [s]), Tl(u) && (v = function(A, T) {
    T[u] = un(A);
  }), w = s.length, h = 0; h < w; h++)
    l1[s[h]] = v;
}
function kg(s, u) {
  Hn(s, function(h, v, w, A) {
    w._w = w._w || {}, u(h, w._w, w, A);
  });
}
function zP(s, u, h) {
  u != null && En(l1, s) && l1[s](u, h._a, h, s);
}
var Vi = 0, kl = 1, Ro = 2, Jr = 3, js = 4, Cl = 5, Ic = 6, IP = 7, FP = 8;
function YP(s, u) {
  return (s % u + u) % u;
}
var Rr;
Array.prototype.indexOf ? Rr = Array.prototype.indexOf : Rr = function(s) {
  var u;
  for (u = 0; u < this.length; ++u)
    if (this[u] === s)
      return u;
  return -1;
};
function Jy(s, u) {
  if (isNaN(s) || isNaN(u))
    return NaN;
  var h = YP(u, 12);
  return s += (u - h) / 12, h === 1 ? Gy(s) ? 29 : 28 : 31 - h % 7 % 2;
}
zt("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
zt("MMM", 0, 0, function(s) {
  return this.localeData().monthsShort(this, s);
});
zt("MMMM", 0, 0, function(s) {
  return this.localeData().months(this, s);
});
Gi("month", "M");
$i("month", 8);
vt("M", nr);
vt("MM", nr, Xa);
vt("MMM", function(s, u) {
  return u.monthsShortRegex(s);
});
vt("MMMM", function(s, u) {
  return u.monthsRegex(s);
});
Hn(["M", "MM"], function(s, u) {
  u[kl] = un(s) - 1;
});
Hn(["MMM", "MMMM"], function(s, u, h, v) {
  var w = h._locale.monthsParse(s, v, h._strict);
  w != null ? u[kl] = w : rn(h).invalidMonth = s;
});
var HP = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), wE = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), SE = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, jP = Sg, UP = Sg;
function BP(s, u) {
  return s ? Us(this._months) ? this._months[s.month()] : this._months[(this._months.isFormat || SE).test(u) ? "format" : "standalone"][s.month()] : Us(this._months) ? this._months : this._months.standalone;
}
function WP(s, u) {
  return s ? Us(this._monthsShort) ? this._monthsShort[s.month()] : this._monthsShort[SE.test(u) ? "format" : "standalone"][s.month()] : Us(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
}
function XP(s, u, h) {
  var v, w, A, T = s.toLocaleLowerCase();
  if (!this._monthsParse)
    for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], v = 0; v < 12; ++v)
      A = Do([2e3, v]), this._shortMonthsParse[v] = this.monthsShort(
        A,
        ""
      ).toLocaleLowerCase(), this._longMonthsParse[v] = this.months(A, "").toLocaleLowerCase();
  return h ? u === "MMM" ? (w = Rr.call(this._shortMonthsParse, T), w !== -1 ? w : null) : (w = Rr.call(this._longMonthsParse, T), w !== -1 ? w : null) : u === "MMM" ? (w = Rr.call(this._shortMonthsParse, T), w !== -1 ? w : (w = Rr.call(this._longMonthsParse, T), w !== -1 ? w : null)) : (w = Rr.call(this._longMonthsParse, T), w !== -1 ? w : (w = Rr.call(this._shortMonthsParse, T), w !== -1 ? w : null));
}
function VP(s, u, h) {
  var v, w, A;
  if (this._monthsParseExact)
    return XP.call(this, s, u, h);
  for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), v = 0; v < 12; v++) {
    if (w = Do([2e3, v]), h && !this._longMonthsParse[v] && (this._longMonthsParse[v] = new RegExp(
      "^" + this.months(w, "").replace(".", "") + "$",
      "i"
    ), this._shortMonthsParse[v] = new RegExp(
      "^" + this.monthsShort(w, "").replace(".", "") + "$",
      "i"
    )), !h && !this._monthsParse[v] && (A = "^" + this.months(w, "") + "|^" + this.monthsShort(w, ""), this._monthsParse[v] = new RegExp(A.replace(".", ""), "i")), h && u === "MMMM" && this._longMonthsParse[v].test(s))
      return v;
    if (h && u === "MMM" && this._shortMonthsParse[v].test(s))
      return v;
    if (!h && this._monthsParse[v].test(s))
      return v;
  }
}
function kE(s, u) {
  var h;
  if (!s.isValid())
    return s;
  if (typeof u == "string") {
    if (/^\d+$/.test(u))
      u = un(u);
    else if (u = s.localeData().monthsParse(u), !Tl(u))
      return s;
  }
  return h = Math.min(s.date(), Jy(s.year(), u)), s._d["set" + (s._isUTC ? "UTC" : "") + "Month"](u, h), s;
}
function CE(s) {
  return s != null ? (kE(this, s), Ve.updateOffset(this, !0), this) : Iy(this, "Month");
}
function GP() {
  return Jy(this.year(), this.month());
}
function $P(s) {
  return this._monthsParseExact ? (En(this, "_monthsRegex") || AE.call(this), s ? this._monthsShortStrictRegex : this._monthsShortRegex) : (En(this, "_monthsShortRegex") || (this._monthsShortRegex = jP), this._monthsShortStrictRegex && s ? this._monthsShortStrictRegex : this._monthsShortRegex);
}
function qP(s) {
  return this._monthsParseExact ? (En(this, "_monthsRegex") || AE.call(this), s ? this._monthsStrictRegex : this._monthsRegex) : (En(this, "_monthsRegex") || (this._monthsRegex = UP), this._monthsStrictRegex && s ? this._monthsStrictRegex : this._monthsRegex);
}
function AE() {
  function s(T, F) {
    return F.length - T.length;
  }
  var u = [], h = [], v = [], w, A;
  for (w = 0; w < 12; w++)
    A = Do([2e3, w]), u.push(this.monthsShort(A, "")), h.push(this.months(A, "")), v.push(this.months(A, "")), v.push(this.monthsShort(A, ""));
  for (u.sort(s), h.sort(s), v.sort(s), w = 0; w < 12; w++)
    u[w] = Wa(u[w]), h[w] = Wa(h[w]);
  for (w = 0; w < 24; w++)
    v[w] = Wa(v[w]);
  this._monthsRegex = new RegExp("^(" + v.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp(
    "^(" + h.join("|") + ")",
    "i"
  ), this._monthsShortStrictRegex = new RegExp(
    "^(" + u.join("|") + ")",
    "i"
  );
}
zt("Y", 0, 0, function() {
  var s = this.year();
  return s <= 9999 ? Mo(s, 4) : "+" + s;
});
zt(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
zt(0, ["YYYY", 4], 0, "year");
zt(0, ["YYYYY", 5], 0, "year");
zt(0, ["YYYYYY", 6, !0], 0, "year");
Gi("year", "y");
$i("year", 1);
vt("Y", Qy);
vt("YY", nr, Xa);
vt("YYYY", F1, I1);
vt("YYYYY", Zy, $y);
vt("YYYYYY", Zy, $y);
Hn(["YYYYY", "YYYYYY"], Vi);
Hn("YYYY", function(s, u) {
  u[Vi] = s.length === 2 ? Ve.parseTwoDigitYear(s) : un(s);
});
Hn("YY", function(s, u) {
  u[Vi] = Ve.parseTwoDigitYear(s);
});
Hn("Y", function(s, u) {
  u[Vi] = parseInt(s, 10);
});
function og(s) {
  return Gy(s) ? 366 : 365;
}
Ve.parseTwoDigitYear = function(s) {
  return un(s) + (un(s) > 68 ? 1900 : 2e3);
};
var TE = Hf("FullYear", !0);
function ZP() {
  return Gy(this.year());
}
function QP(s, u, h, v, w, A, T) {
  var F;
  return s < 100 && s >= 0 ? (F = new Date(s + 400, u, h, v, w, A, T), isFinite(F.getFullYear()) && F.setFullYear(s)) : F = new Date(s, u, h, v, w, A, T), F;
}
function hg(s) {
  var u, h;
  return s < 100 && s >= 0 ? (h = Array.prototype.slice.call(arguments), h[0] = s + 400, u = new Date(Date.UTC.apply(null, h)), isFinite(u.getUTCFullYear()) && u.setUTCFullYear(s)) : u = new Date(Date.UTC.apply(null, arguments)), u;
}
function Yy(s, u, h) {
  var v = 7 + u - h, w = (7 + hg(s, 0, v).getUTCDay() - u) % 7;
  return -w + v - 1;
}
function EE(s, u, h, v, w) {
  var A = (7 + h - v) % 7, T = Yy(s, v, w), F = 1 + 7 * (u - 1) + A + T, H, U;
  return F <= 0 ? (H = s - 1, U = og(H) + F) : F > og(s) ? (H = s + 1, U = F - og(s)) : (H = s, U = F), {
    year: H,
    dayOfYear: U
  };
}
function pg(s, u, h) {
  var v = Yy(s.year(), u, h), w = Math.floor((s.dayOfYear() - v - 1) / 7) + 1, A, T;
  return w < 1 ? (T = s.year() - 1, A = w + Al(T, u, h)) : w > Al(s.year(), u, h) ? (A = w - Al(s.year(), u, h), T = s.year() + 1) : (T = s.year(), A = w), {
    week: A,
    year: T
  };
}
function Al(s, u, h) {
  var v = Yy(s, u, h), w = Yy(s + 1, u, h);
  return (og(s) - v + w) / 7;
}
zt("w", ["ww", 2], "wo", "week");
zt("W", ["WW", 2], "Wo", "isoWeek");
Gi("week", "w");
Gi("isoWeek", "W");
$i("week", 5);
$i("isoWeek", 5);
vt("w", nr);
vt("ww", nr, Xa);
vt("W", nr);
vt("WW", nr, Xa);
kg(
  ["w", "ww", "W", "WW"],
  function(s, u, h, v) {
    u[v.substr(0, 1)] = un(s);
  }
);
function KP(s) {
  return pg(s, this._week.dow, this._week.doy).week;
}
var JP = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function eN() {
  return this._week.dow;
}
function tN() {
  return this._week.doy;
}
function nN(s) {
  var u = this.localeData().week(this);
  return s == null ? u : this.add((s - u) * 7, "d");
}
function rN(s) {
  var u = pg(this, 1, 4).week;
  return s == null ? u : this.add((s - u) * 7, "d");
}
zt("d", 0, "do", "day");
zt("dd", 0, 0, function(s) {
  return this.localeData().weekdaysMin(this, s);
});
zt("ddd", 0, 0, function(s) {
  return this.localeData().weekdaysShort(this, s);
});
zt("dddd", 0, 0, function(s) {
  return this.localeData().weekdays(this, s);
});
zt("e", 0, 0, "weekday");
zt("E", 0, 0, "isoWeekday");
Gi("day", "d");
Gi("weekday", "e");
Gi("isoWeekday", "E");
$i("day", 11);
$i("weekday", 11);
$i("isoWeekday", 11);
vt("d", nr);
vt("e", nr);
vt("E", nr);
vt("dd", function(s, u) {
  return u.weekdaysMinRegex(s);
});
vt("ddd", function(s, u) {
  return u.weekdaysShortRegex(s);
});
vt("dddd", function(s, u) {
  return u.weekdaysRegex(s);
});
kg(["dd", "ddd", "dddd"], function(s, u, h, v) {
  var w = h._locale.weekdaysParse(s, v, h._strict);
  w != null ? u.d = w : rn(h).invalidWeekday = s;
});
kg(["d", "e", "E"], function(s, u, h, v) {
  u[v] = un(s);
});
function iN(s, u) {
  return typeof s != "string" ? s : isNaN(s) ? (s = u.weekdaysParse(s), typeof s == "number" ? s : null) : parseInt(s, 10);
}
function aN(s, u) {
  return typeof s == "string" ? u.weekdaysParse(s) % 7 || 7 : isNaN(s) ? null : s;
}
function Y1(s, u) {
  return s.slice(u, 7).concat(s.slice(0, u));
}
var sN = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), RE = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), oN = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), lN = Sg, uN = Sg, cN = Sg;
function dN(s, u) {
  var h = Us(this._weekdays) ? this._weekdays : this._weekdays[s && s !== !0 && this._weekdays.isFormat.test(u) ? "format" : "standalone"];
  return s === !0 ? Y1(h, this._week.dow) : s ? h[s.day()] : h;
}
function fN(s) {
  return s === !0 ? Y1(this._weekdaysShort, this._week.dow) : s ? this._weekdaysShort[s.day()] : this._weekdaysShort;
}
function hN(s) {
  return s === !0 ? Y1(this._weekdaysMin, this._week.dow) : s ? this._weekdaysMin[s.day()] : this._weekdaysMin;
}
function pN(s, u, h) {
  var v, w, A, T = s.toLocaleLowerCase();
  if (!this._weekdaysParse)
    for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], v = 0; v < 7; ++v)
      A = Do([2e3, 1]).day(v), this._minWeekdaysParse[v] = this.weekdaysMin(
        A,
        ""
      ).toLocaleLowerCase(), this._shortWeekdaysParse[v] = this.weekdaysShort(
        A,
        ""
      ).toLocaleLowerCase(), this._weekdaysParse[v] = this.weekdays(A, "").toLocaleLowerCase();
  return h ? u === "dddd" ? (w = Rr.call(this._weekdaysParse, T), w !== -1 ? w : null) : u === "ddd" ? (w = Rr.call(this._shortWeekdaysParse, T), w !== -1 ? w : null) : (w = Rr.call(this._minWeekdaysParse, T), w !== -1 ? w : null) : u === "dddd" ? (w = Rr.call(this._weekdaysParse, T), w !== -1 || (w = Rr.call(this._shortWeekdaysParse, T), w !== -1) ? w : (w = Rr.call(this._minWeekdaysParse, T), w !== -1 ? w : null)) : u === "ddd" ? (w = Rr.call(this._shortWeekdaysParse, T), w !== -1 || (w = Rr.call(this._weekdaysParse, T), w !== -1) ? w : (w = Rr.call(this._minWeekdaysParse, T), w !== -1 ? w : null)) : (w = Rr.call(this._minWeekdaysParse, T), w !== -1 || (w = Rr.call(this._weekdaysParse, T), w !== -1) ? w : (w = Rr.call(this._shortWeekdaysParse, T), w !== -1 ? w : null));
}
function gN(s, u, h) {
  var v, w, A;
  if (this._weekdaysParseExact)
    return pN.call(this, s, u, h);
  for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), v = 0; v < 7; v++) {
    if (w = Do([2e3, 1]).day(v), h && !this._fullWeekdaysParse[v] && (this._fullWeekdaysParse[v] = new RegExp(
      "^" + this.weekdays(w, "").replace(".", "\\.?") + "$",
      "i"
    ), this._shortWeekdaysParse[v] = new RegExp(
      "^" + this.weekdaysShort(w, "").replace(".", "\\.?") + "$",
      "i"
    ), this._minWeekdaysParse[v] = new RegExp(
      "^" + this.weekdaysMin(w, "").replace(".", "\\.?") + "$",
      "i"
    )), this._weekdaysParse[v] || (A = "^" + this.weekdays(w, "") + "|^" + this.weekdaysShort(w, "") + "|^" + this.weekdaysMin(w, ""), this._weekdaysParse[v] = new RegExp(A.replace(".", ""), "i")), h && u === "dddd" && this._fullWeekdaysParse[v].test(s))
      return v;
    if (h && u === "ddd" && this._shortWeekdaysParse[v].test(s))
      return v;
    if (h && u === "dd" && this._minWeekdaysParse[v].test(s))
      return v;
    if (!h && this._weekdaysParse[v].test(s))
      return v;
  }
}
function vN(s) {
  if (!this.isValid())
    return s != null ? this : NaN;
  var u = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  return s != null ? (s = iN(s, this.localeData()), this.add(s - u, "d")) : u;
}
function mN(s) {
  if (!this.isValid())
    return s != null ? this : NaN;
  var u = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return s == null ? u : this.add(s - u, "d");
}
function yN(s) {
  if (!this.isValid())
    return s != null ? this : NaN;
  if (s != null) {
    var u = aN(s, this.localeData());
    return this.day(this.day() % 7 ? u : u - 7);
  } else
    return this.day() || 7;
}
function xN(s) {
  return this._weekdaysParseExact ? (En(this, "_weekdaysRegex") || H1.call(this), s ? this._weekdaysStrictRegex : this._weekdaysRegex) : (En(this, "_weekdaysRegex") || (this._weekdaysRegex = lN), this._weekdaysStrictRegex && s ? this._weekdaysStrictRegex : this._weekdaysRegex);
}
function bN(s) {
  return this._weekdaysParseExact ? (En(this, "_weekdaysRegex") || H1.call(this), s ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (En(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = uN), this._weekdaysShortStrictRegex && s ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
}
function wN(s) {
  return this._weekdaysParseExact ? (En(this, "_weekdaysRegex") || H1.call(this), s ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (En(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = cN), this._weekdaysMinStrictRegex && s ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
}
function H1() {
  function s($, q) {
    return q.length - $.length;
  }
  var u = [], h = [], v = [], w = [], A, T, F, H, U;
  for (A = 0; A < 7; A++)
    T = Do([2e3, 1]).day(A), F = Wa(this.weekdaysMin(T, "")), H = Wa(this.weekdaysShort(T, "")), U = Wa(this.weekdays(T, "")), u.push(F), h.push(H), v.push(U), w.push(F), w.push(H), w.push(U);
  u.sort(s), h.sort(s), v.sort(s), w.sort(s), this._weekdaysRegex = new RegExp("^(" + w.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp(
    "^(" + v.join("|") + ")",
    "i"
  ), this._weekdaysShortStrictRegex = new RegExp(
    "^(" + h.join("|") + ")",
    "i"
  ), this._weekdaysMinStrictRegex = new RegExp(
    "^(" + u.join("|") + ")",
    "i"
  );
}
function j1() {
  return this.hours() % 12 || 12;
}
function SN() {
  return this.hours() || 24;
}
zt("H", ["HH", 2], 0, "hour");
zt("h", ["hh", 2], 0, j1);
zt("k", ["kk", 2], 0, SN);
zt("hmm", 0, 0, function() {
  return "" + j1.apply(this) + Mo(this.minutes(), 2);
});
zt("hmmss", 0, 0, function() {
  return "" + j1.apply(this) + Mo(this.minutes(), 2) + Mo(this.seconds(), 2);
});
zt("Hmm", 0, 0, function() {
  return "" + this.hours() + Mo(this.minutes(), 2);
});
zt("Hmmss", 0, 0, function() {
  return "" + this.hours() + Mo(this.minutes(), 2) + Mo(this.seconds(), 2);
});
function LE(s, u) {
  zt(s, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      u
    );
  });
}
LE("a", !0);
LE("A", !1);
Gi("hour", "h");
$i("hour", 13);
function ME(s, u) {
  return u._meridiemParse;
}
vt("a", ME);
vt("A", ME);
vt("H", nr);
vt("h", nr);
vt("k", nr);
vt("HH", nr, Xa);
vt("hh", nr, Xa);
vt("kk", nr, Xa);
vt("hmm", xE);
vt("hmmss", bE);
vt("Hmm", xE);
vt("Hmmss", bE);
Hn(["H", "HH"], Jr);
Hn(["k", "kk"], function(s, u, h) {
  var v = un(s);
  u[Jr] = v === 24 ? 0 : v;
});
Hn(["a", "A"], function(s, u, h) {
  h._isPm = h._locale.isPM(s), h._meridiem = s;
});
Hn(["h", "hh"], function(s, u, h) {
  u[Jr] = un(s), rn(h).bigHour = !0;
});
Hn("hmm", function(s, u, h) {
  var v = s.length - 2;
  u[Jr] = un(s.substr(0, v)), u[js] = un(s.substr(v)), rn(h).bigHour = !0;
});
Hn("hmmss", function(s, u, h) {
  var v = s.length - 4, w = s.length - 2;
  u[Jr] = un(s.substr(0, v)), u[js] = un(s.substr(v, 2)), u[Cl] = un(s.substr(w)), rn(h).bigHour = !0;
});
Hn("Hmm", function(s, u, h) {
  var v = s.length - 2;
  u[Jr] = un(s.substr(0, v)), u[js] = un(s.substr(v));
});
Hn("Hmmss", function(s, u, h) {
  var v = s.length - 4, w = s.length - 2;
  u[Jr] = un(s.substr(0, v)), u[js] = un(s.substr(v, 2)), u[Cl] = un(s.substr(w));
});
function kN(s) {
  return (s + "").toLowerCase().charAt(0) === "p";
}
var CN = /[ap]\.?m?\.?/i, AN = Hf("Hours", !0);
function TN(s, u, h) {
  return s > 11 ? h ? "pm" : "PM" : h ? "am" : "AM";
}
var DE = {
  calendar: gP,
  longDateFormat: xP,
  invalidDate: wP,
  ordinal: kP,
  dayOfMonthOrdinalParse: CP,
  relativeTime: TP,
  months: HP,
  monthsShort: wE,
  week: JP,
  weekdays: sN,
  weekdaysMin: oN,
  weekdaysShort: RE,
  meridiemParse: CN
}, ur = {}, tg = {}, gg;
function EN(s, u) {
  var h, v = Math.min(s.length, u.length);
  for (h = 0; h < v; h += 1)
    if (s[h] !== u[h])
      return h;
  return v;
}
function lT(s) {
  return s && s.toLowerCase().replace("_", "-");
}
function RN(s) {
  for (var u = 0, h, v, w, A; u < s.length; ) {
    for (A = lT(s[u]).split("-"), h = A.length, v = lT(s[u + 1]), v = v ? v.split("-") : null; h > 0; ) {
      if (w = ex(A.slice(0, h).join("-")), w)
        return w;
      if (v && v.length >= h && EN(A, v) >= h - 1)
        break;
      h--;
    }
    u++;
  }
  return gg;
}
function LN(s) {
  return s.match("^[^/\\\\]*$") != null;
}
function ex(s) {
  var u = null, h;
  if (ur[s] === void 0 && typeof module < "u" && module && module.exports && LN(s))
    try {
      u = gg._abbr, h = require, h("./locale/" + s), Lu(u);
    } catch {
      ur[s] = null;
    }
  return ur[s];
}
function Lu(s, u) {
  var h;
  return s && (Da(u) ? h = El(s) : h = U1(s, u), h ? gg = h : typeof console < "u" && console.warn && console.warn(
    "Locale " + s + " not found. Did you forget to load it?"
  )), gg._abbr;
}
function U1(s, u) {
  if (u !== null) {
    var h, v = DE;
    if (u.abbr = s, ur[s] != null)
      hE(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      ), v = ur[s]._config;
    else if (u.parentLocale != null)
      if (ur[u.parentLocale] != null)
        v = ur[u.parentLocale]._config;
      else if (h = ex(u.parentLocale), h != null)
        v = h._config;
      else
        return tg[u.parentLocale] || (tg[u.parentLocale] = []), tg[u.parentLocale].push({
          name: s,
          config: u
        }), null;
    return ur[s] = new P1(s1(v, u)), tg[s] && tg[s].forEach(function(w) {
      U1(w.name, w.config);
    }), Lu(s), ur[s];
  } else
    return delete ur[s], null;
}
function MN(s, u) {
  if (u != null) {
    var h, v, w = DE;
    ur[s] != null && ur[s].parentLocale != null ? ur[s].set(s1(ur[s]._config, u)) : (v = ex(s), v != null && (w = v._config), u = s1(w, u), v == null && (u.abbr = s), h = new P1(u), h.parentLocale = ur[s], ur[s] = h), Lu(s);
  } else
    ur[s] != null && (ur[s].parentLocale != null ? (ur[s] = ur[s].parentLocale, s === Lu() && Lu(s)) : ur[s] != null && delete ur[s]);
  return ur[s];
}
function El(s) {
  var u;
  if (s && s._locale && s._locale._abbr && (s = s._locale._abbr), !s)
    return gg;
  if (!Us(s)) {
    if (u = ex(s), u)
      return u;
    s = [s];
  }
  return RN(s);
}
function DN() {
  return o1(ur);
}
function B1(s) {
  var u, h = s._a;
  return h && rn(s).overflow === -2 && (u = h[kl] < 0 || h[kl] > 11 ? kl : h[Ro] < 1 || h[Ro] > Jy(h[Vi], h[kl]) ? Ro : h[Jr] < 0 || h[Jr] > 24 || h[Jr] === 24 && (h[js] !== 0 || h[Cl] !== 0 || h[Ic] !== 0) ? Jr : h[js] < 0 || h[js] > 59 ? js : h[Cl] < 0 || h[Cl] > 59 ? Cl : h[Ic] < 0 || h[Ic] > 999 ? Ic : -1, rn(s)._overflowDayOfYear && (u < Vi || u > Ro) && (u = Ro), rn(s)._overflowWeeks && u === -1 && (u = IP), rn(s)._overflowWeekday && u === -1 && (u = FP), rn(s).overflow = u), s;
}
var ON = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, _N = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, PN = /Z|[+-]\d\d(?::?\d\d)?/, xy = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, !1],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, !1],
  ["YYYY", /\d{4}/, !1]
], Yw = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], NN = /^\/?Date\((-?\d+)/i, zN = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, IN = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function OE(s) {
  var u, h, v = s._i, w = ON.exec(v) || _N.exec(v), A, T, F, H, U = xy.length, $ = Yw.length;
  if (w) {
    for (rn(s).iso = !0, u = 0, h = U; u < h; u++)
      if (xy[u][1].exec(w[1])) {
        T = xy[u][0], A = xy[u][2] !== !1;
        break;
      }
    if (T == null) {
      s._isValid = !1;
      return;
    }
    if (w[3]) {
      for (u = 0, h = $; u < h; u++)
        if (Yw[u][1].exec(w[3])) {
          F = (w[2] || " ") + Yw[u][0];
          break;
        }
      if (F == null) {
        s._isValid = !1;
        return;
      }
    }
    if (!A && F != null) {
      s._isValid = !1;
      return;
    }
    if (w[4])
      if (PN.exec(w[4]))
        H = "Z";
      else {
        s._isValid = !1;
        return;
      }
    s._f = T + (F || "") + (H || ""), X1(s);
  } else
    s._isValid = !1;
}
function FN(s, u, h, v, w, A) {
  var T = [
    YN(s),
    wE.indexOf(u),
    parseInt(h, 10),
    parseInt(v, 10),
    parseInt(w, 10)
  ];
  return A && T.push(parseInt(A, 10)), T;
}
function YN(s) {
  var u = parseInt(s, 10);
  return u <= 49 ? 2e3 + u : u <= 999 ? 1900 + u : u;
}
function HN(s) {
  return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function jN(s, u, h) {
  if (s) {
    var v = RE.indexOf(s), w = new Date(
      u[0],
      u[1],
      u[2]
    ).getDay();
    if (v !== w)
      return rn(h).weekdayMismatch = !0, h._isValid = !1, !1;
  }
  return !0;
}
function UN(s, u, h) {
  if (s)
    return IN[s];
  if (u)
    return 0;
  var v = parseInt(h, 10), w = v % 100, A = (v - w) / 100;
  return A * 60 + w;
}
function _E(s) {
  var u = zN.exec(HN(s._i)), h;
  if (u) {
    if (h = FN(
      u[4],
      u[3],
      u[2],
      u[5],
      u[6],
      u[7]
    ), !jN(u[1], h, s))
      return;
    s._a = h, s._tzm = UN(u[8], u[9], u[10]), s._d = hg.apply(null, s._a), s._d.setUTCMinutes(s._d.getUTCMinutes() - s._tzm), rn(s).rfc2822 = !0;
  } else
    s._isValid = !1;
}
function BN(s) {
  var u = NN.exec(s._i);
  if (u !== null) {
    s._d = /* @__PURE__ */ new Date(+u[1]);
    return;
  }
  if (OE(s), s._isValid === !1)
    delete s._isValid;
  else
    return;
  if (_E(s), s._isValid === !1)
    delete s._isValid;
  else
    return;
  s._strict ? s._isValid = !1 : Ve.createFromInputFallback(s);
}
Ve.createFromInputFallback = os(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(s) {
    s._d = /* @__PURE__ */ new Date(s._i + (s._useUTC ? " UTC" : ""));
  }
);
function Pf(s, u, h) {
  return s ?? u ?? h;
}
function WN(s) {
  var u = new Date(Ve.now());
  return s._useUTC ? [
    u.getUTCFullYear(),
    u.getUTCMonth(),
    u.getUTCDate()
  ] : [u.getFullYear(), u.getMonth(), u.getDate()];
}
function W1(s) {
  var u, h, v = [], w, A, T;
  if (!s._d) {
    for (w = WN(s), s._w && s._a[Ro] == null && s._a[kl] == null && XN(s), s._dayOfYear != null && (T = Pf(s._a[Vi], w[Vi]), (s._dayOfYear > og(T) || s._dayOfYear === 0) && (rn(s)._overflowDayOfYear = !0), h = hg(T, 0, s._dayOfYear), s._a[kl] = h.getUTCMonth(), s._a[Ro] = h.getUTCDate()), u = 0; u < 3 && s._a[u] == null; ++u)
      s._a[u] = v[u] = w[u];
    for (; u < 7; u++)
      s._a[u] = v[u] = s._a[u] == null ? u === 2 ? 1 : 0 : s._a[u];
    s._a[Jr] === 24 && s._a[js] === 0 && s._a[Cl] === 0 && s._a[Ic] === 0 && (s._nextDay = !0, s._a[Jr] = 0), s._d = (s._useUTC ? hg : QP).apply(
      null,
      v
    ), A = s._useUTC ? s._d.getUTCDay() : s._d.getDay(), s._tzm != null && s._d.setUTCMinutes(s._d.getUTCMinutes() - s._tzm), s._nextDay && (s._a[Jr] = 24), s._w && typeof s._w.d < "u" && s._w.d !== A && (rn(s).weekdayMismatch = !0);
  }
}
function XN(s) {
  var u, h, v, w, A, T, F, H, U;
  u = s._w, u.GG != null || u.W != null || u.E != null ? (A = 1, T = 4, h = Pf(
    u.GG,
    s._a[Vi],
    pg(tr(), 1, 4).year
  ), v = Pf(u.W, 1), w = Pf(u.E, 1), (w < 1 || w > 7) && (H = !0)) : (A = s._locale._week.dow, T = s._locale._week.doy, U = pg(tr(), A, T), h = Pf(u.gg, s._a[Vi], U.year), v = Pf(u.w, U.week), u.d != null ? (w = u.d, (w < 0 || w > 6) && (H = !0)) : u.e != null ? (w = u.e + A, (u.e < 0 || u.e > 6) && (H = !0)) : w = A), v < 1 || v > Al(h, A, T) ? rn(s)._overflowWeeks = !0 : H != null ? rn(s)._overflowWeekday = !0 : (F = EE(h, v, w, A, T), s._a[Vi] = F.year, s._dayOfYear = F.dayOfYear);
}
Ve.ISO_8601 = function() {
};
Ve.RFC_2822 = function() {
};
function X1(s) {
  if (s._f === Ve.ISO_8601) {
    OE(s);
    return;
  }
  if (s._f === Ve.RFC_2822) {
    _E(s);
    return;
  }
  s._a = [], rn(s).empty = !0;
  var u = "" + s._i, h, v, w, A, T, F = u.length, H = 0, U, $;
  for (w = pE(s._f, s._locale).match(N1) || [], $ = w.length, h = 0; h < $; h++)
    A = w[h], v = (u.match(PP(A, s)) || [])[0], v && (T = u.substr(0, u.indexOf(v)), T.length > 0 && rn(s).unusedInput.push(T), u = u.slice(
      u.indexOf(v) + v.length
    ), H += v.length), zf[A] ? (v ? rn(s).empty = !1 : rn(s).unusedTokens.push(A), zP(A, v, s)) : s._strict && !v && rn(s).unusedTokens.push(A);
  rn(s).charsLeftOver = F - H, u.length > 0 && rn(s).unusedInput.push(u), s._a[Jr] <= 12 && rn(s).bigHour === !0 && s._a[Jr] > 0 && (rn(s).bigHour = void 0), rn(s).parsedDateParts = s._a.slice(0), rn(s).meridiem = s._meridiem, s._a[Jr] = VN(
    s._locale,
    s._a[Jr],
    s._meridiem
  ), U = rn(s).era, U !== null && (s._a[Vi] = s._locale.erasConvertYear(U, s._a[Vi])), W1(s), B1(s);
}
function VN(s, u, h) {
  var v;
  return h == null ? u : s.meridiemHour != null ? s.meridiemHour(u, h) : (s.isPM != null && (v = s.isPM(h), v && u < 12 && (u += 12), !v && u === 12 && (u = 0)), u);
}
function GN(s) {
  var u, h, v, w, A, T, F = !1, H = s._f.length;
  if (H === 0) {
    rn(s).invalidFormat = !0, s._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (w = 0; w < H; w++)
    A = 0, T = !1, u = _1({}, s), s._useUTC != null && (u._useUTC = s._useUTC), u._f = s._f[w], X1(u), O1(u) && (T = !0), A += rn(u).charsLeftOver, A += rn(u).unusedTokens.length * 10, rn(u).score = A, F ? A < v && (v = A, h = u) : (v == null || A < v || T) && (v = A, h = u, T && (F = !0));
  Eu(s, h || u);
}
function $N(s) {
  if (!s._d) {
    var u = z1(s._i), h = u.day === void 0 ? u.date : u.day;
    s._a = dE(
      [u.year, u.month, h, u.hour, u.minute, u.second, u.millisecond],
      function(v) {
        return v && parseInt(v, 10);
      }
    ), W1(s);
  }
}
function qN(s) {
  var u = new wg(B1(PE(s)));
  return u._nextDay && (u.add(1, "d"), u._nextDay = void 0), u;
}
function PE(s) {
  var u = s._i, h = s._f;
  return s._locale = s._locale || El(s._l), u === null || h === void 0 && u === "" ? Vy({ nullInput: !0 }) : (typeof u == "string" && (s._i = u = s._locale.preparse(u)), Bs(u) ? new wg(B1(u)) : (bg(u) ? s._d = u : Us(h) ? GN(s) : h ? X1(s) : ZN(s), O1(s) || (s._d = null), s));
}
function ZN(s) {
  var u = s._i;
  Da(u) ? s._d = new Date(Ve.now()) : bg(u) ? s._d = new Date(u.valueOf()) : typeof u == "string" ? BN(s) : Us(u) ? (s._a = dE(u.slice(0), function(h) {
    return parseInt(h, 10);
  }), W1(s)) : Fc(u) ? $N(s) : Tl(u) ? s._d = new Date(u) : Ve.createFromInputFallback(s);
}
function NE(s, u, h, v, w) {
  var A = {};
  return (u === !0 || u === !1) && (v = u, u = void 0), (h === !0 || h === !1) && (v = h, h = void 0), (Fc(s) && D1(s) || Us(s) && s.length === 0) && (s = void 0), A._isAMomentObject = !0, A._useUTC = A._isUTC = w, A._l = h, A._i = s, A._f = u, A._strict = v, qN(A);
}
function tr(s, u, h, v) {
  return NE(s, u, h, v, !1);
}
var QN = os(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var s = tr.apply(null, arguments);
    return this.isValid() && s.isValid() ? s < this ? this : s : Vy();
  }
), KN = os(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var s = tr.apply(null, arguments);
    return this.isValid() && s.isValid() ? s > this ? this : s : Vy();
  }
);
function zE(s, u) {
  var h, v;
  if (u.length === 1 && Us(u[0]) && (u = u[0]), !u.length)
    return tr();
  for (h = u[0], v = 1; v < u.length; ++v)
    (!u[v].isValid() || u[v][s](h)) && (h = u[v]);
  return h;
}
function JN() {
  var s = [].slice.call(arguments, 0);
  return zE("isBefore", s);
}
function ez() {
  var s = [].slice.call(arguments, 0);
  return zE("isAfter", s);
}
var tz = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
}, ng = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function nz(s) {
  var u, h = !1, v, w = ng.length;
  for (u in s)
    if (En(s, u) && !(Rr.call(ng, u) !== -1 && (s[u] == null || !isNaN(s[u]))))
      return !1;
  for (v = 0; v < w; ++v)
    if (s[ng[v]]) {
      if (h)
        return !1;
      parseFloat(s[ng[v]]) !== un(s[ng[v]]) && (h = !0);
    }
  return !0;
}
function rz() {
  return this._isValid;
}
function iz() {
  return Ws(NaN);
}
function tx(s) {
  var u = z1(s), h = u.year || 0, v = u.quarter || 0, w = u.month || 0, A = u.week || u.isoWeek || 0, T = u.day || 0, F = u.hour || 0, H = u.minute || 0, U = u.second || 0, $ = u.millisecond || 0;
  this._isValid = nz(u), this._milliseconds = +$ + U * 1e3 + // 1000
  H * 6e4 + // 1000 * 60
  F * 1e3 * 60 * 60, this._days = +T + A * 7, this._months = +w + v * 3 + h * 12, this._data = {}, this._locale = El(), this._bubble();
}
function Ty(s) {
  return s instanceof tx;
}
function u1(s) {
  return s < 0 ? Math.round(-1 * s) * -1 : Math.round(s);
}
function az(s, u, h) {
  var v = Math.min(s.length, u.length), w = Math.abs(s.length - u.length), A = 0, T;
  for (T = 0; T < v; T++)
    (h && s[T] !== u[T] || !h && un(s[T]) !== un(u[T])) && A++;
  return A + w;
}
function IE(s, u) {
  zt(s, 0, 0, function() {
    var h = this.utcOffset(), v = "+";
    return h < 0 && (h = -h, v = "-"), v + Mo(~~(h / 60), 2) + u + Mo(~~h % 60, 2);
  });
}
IE("Z", ":");
IE("ZZ", "");
vt("Z", Ky);
vt("ZZ", Ky);
Hn(["Z", "ZZ"], function(s, u, h) {
  h._useUTC = !0, h._tzm = V1(Ky, s);
});
var sz = /([\+\-]|\d\d)/gi;
function V1(s, u) {
  var h = (u || "").match(s), v, w, A;
  return h === null ? null : (v = h[h.length - 1] || [], w = (v + "").match(sz) || ["-", 0, 0], A = +(w[1] * 60) + un(w[2]), A === 0 ? 0 : w[0] === "+" ? A : -A);
}
function G1(s, u) {
  var h, v;
  return u._isUTC ? (h = u.clone(), v = (Bs(s) || bg(s) ? s.valueOf() : tr(s).valueOf()) - h.valueOf(), h._d.setTime(h._d.valueOf() + v), Ve.updateOffset(h, !1), h) : tr(s).local();
}
function c1(s) {
  return -Math.round(s._d.getTimezoneOffset());
}
Ve.updateOffset = function() {
};
function oz(s, u, h) {
  var v = this._offset || 0, w;
  if (!this.isValid())
    return s != null ? this : NaN;
  if (s != null) {
    if (typeof s == "string") {
      if (s = V1(Ky, s), s === null)
        return this;
    } else
      Math.abs(s) < 16 && !h && (s = s * 60);
    return !this._isUTC && u && (w = c1(this)), this._offset = s, this._isUTC = !0, w != null && this.add(w, "m"), v !== s && (!u || this._changeInProgress ? HE(
      this,
      Ws(s - v, "m"),
      1,
      !1
    ) : this._changeInProgress || (this._changeInProgress = !0, Ve.updateOffset(this, !0), this._changeInProgress = null)), this;
  } else
    return this._isUTC ? v : c1(this);
}
function lz(s, u) {
  return s != null ? (typeof s != "string" && (s = -s), this.utcOffset(s, u), this) : -this.utcOffset();
}
function uz(s) {
  return this.utcOffset(0, s);
}
function cz(s) {
  return this._isUTC && (this.utcOffset(0, s), this._isUTC = !1, s && this.subtract(c1(this), "m")), this;
}
function dz() {
  if (this._tzm != null)
    this.utcOffset(this._tzm, !1, !0);
  else if (typeof this._i == "string") {
    var s = V1(OP, this._i);
    s != null ? this.utcOffset(s) : this.utcOffset(0, !0);
  }
  return this;
}
function fz(s) {
  return this.isValid() ? (s = s ? tr(s).utcOffset() : 0, (this.utcOffset() - s) % 60 === 0) : !1;
}
function hz() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function pz() {
  if (!Da(this._isDSTShifted))
    return this._isDSTShifted;
  var s = {}, u;
  return _1(s, this), s = PE(s), s._a ? (u = s._isUTC ? Do(s._a) : tr(s._a), this._isDSTShifted = this.isValid() && az(s._a, u.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted;
}
function gz() {
  return this.isValid() ? !this._isUTC : !1;
}
function vz() {
  return this.isValid() ? this._isUTC : !1;
}
function FE() {
  return this.isValid() ? this._isUTC && this._offset === 0 : !1;
}
var mz = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, yz = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function Ws(s, u) {
  var h = s, v = null, w, A, T;
  return Ty(s) ? h = {
    ms: s._milliseconds,
    d: s._days,
    M: s._months
  } : Tl(s) || !isNaN(+s) ? (h = {}, u ? h[u] = +s : h.milliseconds = +s) : (v = mz.exec(s)) ? (w = v[1] === "-" ? -1 : 1, h = {
    y: 0,
    d: un(v[Ro]) * w,
    h: un(v[Jr]) * w,
    m: un(v[js]) * w,
    s: un(v[Cl]) * w,
    ms: un(u1(v[Ic] * 1e3)) * w
    // the millisecond decimal point is included in the match
  }) : (v = yz.exec(s)) ? (w = v[1] === "-" ? -1 : 1, h = {
    y: zc(v[2], w),
    M: zc(v[3], w),
    w: zc(v[4], w),
    d: zc(v[5], w),
    h: zc(v[6], w),
    m: zc(v[7], w),
    s: zc(v[8], w)
  }) : h == null ? h = {} : typeof h == "object" && ("from" in h || "to" in h) && (T = xz(
    tr(h.from),
    tr(h.to)
  ), h = {}, h.ms = T.milliseconds, h.M = T.months), A = new tx(h), Ty(s) && En(s, "_locale") && (A._locale = s._locale), Ty(s) && En(s, "_isValid") && (A._isValid = s._isValid), A;
}
Ws.fn = tx.prototype;
Ws.invalid = iz;
function zc(s, u) {
  var h = s && parseFloat(s.replace(",", "."));
  return (isNaN(h) ? 0 : h) * u;
}
function uT(s, u) {
  var h = {};
  return h.months = u.month() - s.month() + (u.year() - s.year()) * 12, s.clone().add(h.months, "M").isAfter(u) && --h.months, h.milliseconds = +u - +s.clone().add(h.months, "M"), h;
}
function xz(s, u) {
  var h;
  return s.isValid() && u.isValid() ? (u = G1(u, s), s.isBefore(u) ? h = uT(s, u) : (h = uT(u, s), h.milliseconds = -h.milliseconds, h.months = -h.months), h) : { milliseconds: 0, months: 0 };
}
function YE(s, u) {
  return function(h, v) {
    var w, A;
    return v !== null && !isNaN(+v) && (hE(
      u,
      "moment()." + u + "(period, number) is deprecated. Please use moment()." + u + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
    ), A = h, h = v, v = A), w = Ws(h, v), HE(this, w, s), this;
  };
}
function HE(s, u, h, v) {
  var w = u._milliseconds, A = u1(u._days), T = u1(u._months);
  s.isValid() && (v = v ?? !0, T && kE(s, Iy(s, "Month") + T * h), A && vE(s, "Date", Iy(s, "Date") + A * h), w && s._d.setTime(s._d.valueOf() + w * h), v && Ve.updateOffset(s, A || T));
}
var bz = YE(1, "add"), wz = YE(-1, "subtract");
function jE(s) {
  return typeof s == "string" || s instanceof String;
}
function Sz(s) {
  return Bs(s) || bg(s) || jE(s) || Tl(s) || Cz(s) || kz(s) || s === null || s === void 0;
}
function kz(s) {
  var u = Fc(s) && !D1(s), h = !1, v = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], w, A, T = v.length;
  for (w = 0; w < T; w += 1)
    A = v[w], h = h || En(s, A);
  return u && h;
}
function Cz(s) {
  var u = Us(s), h = !1;
  return u && (h = s.filter(function(v) {
    return !Tl(v) && jE(s);
  }).length === 0), u && h;
}
function Az(s) {
  var u = Fc(s) && !D1(s), h = !1, v = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], w, A;
  for (w = 0; w < v.length; w += 1)
    A = v[w], h = h || En(s, A);
  return u && h;
}
function Tz(s, u) {
  var h = s.diff(u, "days", !0);
  return h < -6 ? "sameElse" : h < -1 ? "lastWeek" : h < 0 ? "lastDay" : h < 1 ? "sameDay" : h < 2 ? "nextDay" : h < 7 ? "nextWeek" : "sameElse";
}
function Ez(s, u) {
  arguments.length === 1 && (arguments[0] ? Sz(arguments[0]) ? (s = arguments[0], u = void 0) : Az(arguments[0]) && (u = arguments[0], s = void 0) : (s = void 0, u = void 0));
  var h = s || tr(), v = G1(h, this).startOf("day"), w = Ve.calendarFormat(this, v) || "sameElse", A = u && (Oo(u[w]) ? u[w].call(this, h) : u[w]);
  return this.format(
    A || this.localeData().calendar(w, this, tr(h))
  );
}
function Rz() {
  return new wg(this);
}
function Lz(s, u) {
  var h = Bs(s) ? s : tr(s);
  return this.isValid() && h.isValid() ? (u = ls(u) || "millisecond", u === "millisecond" ? this.valueOf() > h.valueOf() : h.valueOf() < this.clone().startOf(u).valueOf()) : !1;
}
function Mz(s, u) {
  var h = Bs(s) ? s : tr(s);
  return this.isValid() && h.isValid() ? (u = ls(u) || "millisecond", u === "millisecond" ? this.valueOf() < h.valueOf() : this.clone().endOf(u).valueOf() < h.valueOf()) : !1;
}
function Dz(s, u, h, v) {
  var w = Bs(s) ? s : tr(s), A = Bs(u) ? u : tr(u);
  return this.isValid() && w.isValid() && A.isValid() ? (v = v || "()", (v[0] === "(" ? this.isAfter(w, h) : !this.isBefore(w, h)) && (v[1] === ")" ? this.isBefore(A, h) : !this.isAfter(A, h))) : !1;
}
function Oz(s, u) {
  var h = Bs(s) ? s : tr(s), v;
  return this.isValid() && h.isValid() ? (u = ls(u) || "millisecond", u === "millisecond" ? this.valueOf() === h.valueOf() : (v = h.valueOf(), this.clone().startOf(u).valueOf() <= v && v <= this.clone().endOf(u).valueOf())) : !1;
}
function _z(s, u) {
  return this.isSame(s, u) || this.isAfter(s, u);
}
function Pz(s, u) {
  return this.isSame(s, u) || this.isBefore(s, u);
}
function Nz(s, u, h) {
  var v, w, A;
  if (!this.isValid())
    return NaN;
  if (v = G1(s, this), !v.isValid())
    return NaN;
  switch (w = (v.utcOffset() - this.utcOffset()) * 6e4, u = ls(u), u) {
    case "year":
      A = Ey(this, v) / 12;
      break;
    case "month":
      A = Ey(this, v);
      break;
    case "quarter":
      A = Ey(this, v) / 3;
      break;
    case "second":
      A = (this - v) / 1e3;
      break;
    case "minute":
      A = (this - v) / 6e4;
      break;
    case "hour":
      A = (this - v) / 36e5;
      break;
    case "day":
      A = (this - v - w) / 864e5;
      break;
    case "week":
      A = (this - v - w) / 6048e5;
      break;
    default:
      A = this - v;
  }
  return h ? A : ss(A);
}
function Ey(s, u) {
  if (s.date() < u.date())
    return -Ey(u, s);
  var h = (u.year() - s.year()) * 12 + (u.month() - s.month()), v = s.clone().add(h, "months"), w, A;
  return u - v < 0 ? (w = s.clone().add(h - 1, "months"), A = (u - v) / (v - w)) : (w = s.clone().add(h + 1, "months"), A = (u - v) / (w - v)), -(h + A) || 0;
}
Ve.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
Ve.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function zz() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function Iz(s) {
  if (!this.isValid())
    return null;
  var u = s !== !0, h = u ? this.clone().utc() : this;
  return h.year() < 0 || h.year() > 9999 ? Ay(
    h,
    u ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
  ) : Oo(Date.prototype.toISOString) ? u ? this.toDate().toISOString() : new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", Ay(h, "Z")) : Ay(
    h,
    u ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function Fz() {
  if (!this.isValid())
    return "moment.invalid(/* " + this._i + " */)";
  var s = "moment", u = "", h, v, w, A;
  return this.isLocal() || (s = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", u = "Z"), h = "[" + s + '("]', v = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", w = "-MM-DD[T]HH:mm:ss.SSS", A = u + '[")]', this.format(h + v + w + A);
}
function Yz(s) {
  s || (s = this.isUtc() ? Ve.defaultFormatUtc : Ve.defaultFormat);
  var u = Ay(this, s);
  return this.localeData().postformat(u);
}
function Hz(s, u) {
  return this.isValid() && (Bs(s) && s.isValid() || tr(s).isValid()) ? Ws({ to: this, from: s }).locale(this.locale()).humanize(!u) : this.localeData().invalidDate();
}
function jz(s) {
  return this.from(tr(), s);
}
function Uz(s, u) {
  return this.isValid() && (Bs(s) && s.isValid() || tr(s).isValid()) ? Ws({ from: this, to: s }).locale(this.locale()).humanize(!u) : this.localeData().invalidDate();
}
function Bz(s) {
  return this.to(tr(), s);
}
function UE(s) {
  var u;
  return s === void 0 ? this._locale._abbr : (u = El(s), u != null && (this._locale = u), this);
}
var BE = os(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(s) {
    return s === void 0 ? this.localeData() : this.locale(s);
  }
);
function WE() {
  return this._locale;
}
var Hy = 1e3, If = 60 * Hy, jy = 60 * If, XE = (365 * 400 + 97) * 24 * jy;
function Ff(s, u) {
  return (s % u + u) % u;
}
function VE(s, u, h) {
  return s < 100 && s >= 0 ? new Date(s + 400, u, h) - XE : new Date(s, u, h).valueOf();
}
function GE(s, u, h) {
  return s < 100 && s >= 0 ? Date.UTC(s + 400, u, h) - XE : Date.UTC(s, u, h);
}
function Wz(s) {
  var u, h;
  if (s = ls(s), s === void 0 || s === "millisecond" || !this.isValid())
    return this;
  switch (h = this._isUTC ? GE : VE, s) {
    case "year":
      u = h(this.year(), 0, 1);
      break;
    case "quarter":
      u = h(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      u = h(this.year(), this.month(), 1);
      break;
    case "week":
      u = h(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      u = h(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      u = h(this.year(), this.month(), this.date());
      break;
    case "hour":
      u = this._d.valueOf(), u -= Ff(
        u + (this._isUTC ? 0 : this.utcOffset() * If),
        jy
      );
      break;
    case "minute":
      u = this._d.valueOf(), u -= Ff(u, If);
      break;
    case "second":
      u = this._d.valueOf(), u -= Ff(u, Hy);
      break;
  }
  return this._d.setTime(u), Ve.updateOffset(this, !0), this;
}
function Xz(s) {
  var u, h;
  if (s = ls(s), s === void 0 || s === "millisecond" || !this.isValid())
    return this;
  switch (h = this._isUTC ? GE : VE, s) {
    case "year":
      u = h(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      u = h(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      u = h(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      u = h(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      u = h(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      u = h(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      u = this._d.valueOf(), u += jy - Ff(
        u + (this._isUTC ? 0 : this.utcOffset() * If),
        jy
      ) - 1;
      break;
    case "minute":
      u = this._d.valueOf(), u += If - Ff(u, If) - 1;
      break;
    case "second":
      u = this._d.valueOf(), u += Hy - Ff(u, Hy) - 1;
      break;
  }
  return this._d.setTime(u), Ve.updateOffset(this, !0), this;
}
function Vz() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function Gz() {
  return Math.floor(this.valueOf() / 1e3);
}
function $z() {
  return new Date(this.valueOf());
}
function qz() {
  var s = this;
  return [
    s.year(),
    s.month(),
    s.date(),
    s.hour(),
    s.minute(),
    s.second(),
    s.millisecond()
  ];
}
function Zz() {
  var s = this;
  return {
    years: s.year(),
    months: s.month(),
    date: s.date(),
    hours: s.hours(),
    minutes: s.minutes(),
    seconds: s.seconds(),
    milliseconds: s.milliseconds()
  };
}
function Qz() {
  return this.isValid() ? this.toISOString() : null;
}
function Kz() {
  return O1(this);
}
function Jz() {
  return Eu({}, rn(this));
}
function eI() {
  return rn(this).overflow;
}
function tI() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
zt("N", 0, 0, "eraAbbr");
zt("NN", 0, 0, "eraAbbr");
zt("NNN", 0, 0, "eraAbbr");
zt("NNNN", 0, 0, "eraName");
zt("NNNNN", 0, 0, "eraNarrow");
zt("y", ["y", 1], "yo", "eraYear");
zt("y", ["yy", 2], 0, "eraYear");
zt("y", ["yyy", 3], 0, "eraYear");
zt("y", ["yyyy", 4], 0, "eraYear");
vt("N", $1);
vt("NN", $1);
vt("NNN", $1);
vt("NNNN", fI);
vt("NNNNN", hI);
Hn(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(s, u, h, v) {
    var w = h._locale.erasParse(s, v, h._strict);
    w ? rn(h).era = w : rn(h).invalidEra = s;
  }
);
vt("y", jf);
vt("yy", jf);
vt("yyy", jf);
vt("yyyy", jf);
vt("yo", pI);
Hn(["y", "yy", "yyy", "yyyy"], Vi);
Hn(["yo"], function(s, u, h, v) {
  var w;
  h._locale._eraYearOrdinalRegex && (w = s.match(h._locale._eraYearOrdinalRegex)), h._locale.eraYearOrdinalParse ? u[Vi] = h._locale.eraYearOrdinalParse(s, w) : u[Vi] = parseInt(s, 10);
});
function nI(s, u) {
  var h, v, w, A = this._eras || El("en")._eras;
  for (h = 0, v = A.length; h < v; ++h) {
    switch (typeof A[h].since) {
      case "string":
        w = Ve(A[h].since).startOf("day"), A[h].since = w.valueOf();
        break;
    }
    switch (typeof A[h].until) {
      case "undefined":
        A[h].until = 1 / 0;
        break;
      case "string":
        w = Ve(A[h].until).startOf("day").valueOf(), A[h].until = w.valueOf();
        break;
    }
  }
  return A;
}
function rI(s, u, h) {
  var v, w, A = this.eras(), T, F, H;
  for (s = s.toUpperCase(), v = 0, w = A.length; v < w; ++v)
    if (T = A[v].name.toUpperCase(), F = A[v].abbr.toUpperCase(), H = A[v].narrow.toUpperCase(), h)
      switch (u) {
        case "N":
        case "NN":
        case "NNN":
          if (F === s)
            return A[v];
          break;
        case "NNNN":
          if (T === s)
            return A[v];
          break;
        case "NNNNN":
          if (H === s)
            return A[v];
          break;
      }
    else if ([T, F, H].indexOf(s) >= 0)
      return A[v];
}
function iI(s, u) {
  var h = s.since <= s.until ? 1 : -1;
  return u === void 0 ? Ve(s.since).year() : Ve(s.since).year() + (u - s.offset) * h;
}
function aI() {
  var s, u, h, v = this.localeData().eras();
  for (s = 0, u = v.length; s < u; ++s)
    if (h = this.clone().startOf("day").valueOf(), v[s].since <= h && h <= v[s].until || v[s].until <= h && h <= v[s].since)
      return v[s].name;
  return "";
}
function sI() {
  var s, u, h, v = this.localeData().eras();
  for (s = 0, u = v.length; s < u; ++s)
    if (h = this.clone().startOf("day").valueOf(), v[s].since <= h && h <= v[s].until || v[s].until <= h && h <= v[s].since)
      return v[s].narrow;
  return "";
}
function oI() {
  var s, u, h, v = this.localeData().eras();
  for (s = 0, u = v.length; s < u; ++s)
    if (h = this.clone().startOf("day").valueOf(), v[s].since <= h && h <= v[s].until || v[s].until <= h && h <= v[s].since)
      return v[s].abbr;
  return "";
}
function lI() {
  var s, u, h, v, w = this.localeData().eras();
  for (s = 0, u = w.length; s < u; ++s)
    if (h = w[s].since <= w[s].until ? 1 : -1, v = this.clone().startOf("day").valueOf(), w[s].since <= v && v <= w[s].until || w[s].until <= v && v <= w[s].since)
      return (this.year() - Ve(w[s].since).year()) * h + w[s].offset;
  return this.year();
}
function uI(s) {
  return En(this, "_erasNameRegex") || q1.call(this), s ? this._erasNameRegex : this._erasRegex;
}
function cI(s) {
  return En(this, "_erasAbbrRegex") || q1.call(this), s ? this._erasAbbrRegex : this._erasRegex;
}
function dI(s) {
  return En(this, "_erasNarrowRegex") || q1.call(this), s ? this._erasNarrowRegex : this._erasRegex;
}
function $1(s, u) {
  return u.erasAbbrRegex(s);
}
function fI(s, u) {
  return u.erasNameRegex(s);
}
function hI(s, u) {
  return u.erasNarrowRegex(s);
}
function pI(s, u) {
  return u._eraYearOrdinalRegex || jf;
}
function q1() {
  var s = [], u = [], h = [], v = [], w, A, T = this.eras();
  for (w = 0, A = T.length; w < A; ++w)
    u.push(Wa(T[w].name)), s.push(Wa(T[w].abbr)), h.push(Wa(T[w].narrow)), v.push(Wa(T[w].name)), v.push(Wa(T[w].abbr)), v.push(Wa(T[w].narrow));
  this._erasRegex = new RegExp("^(" + v.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + u.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp(
    "^(" + h.join("|") + ")",
    "i"
  );
}
zt(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
zt(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function nx(s, u) {
  zt(0, [s, s.length], 0, u);
}
nx("gggg", "weekYear");
nx("ggggg", "weekYear");
nx("GGGG", "isoWeekYear");
nx("GGGGG", "isoWeekYear");
Gi("weekYear", "gg");
Gi("isoWeekYear", "GG");
$i("weekYear", 1);
$i("isoWeekYear", 1);
vt("G", Qy);
vt("g", Qy);
vt("GG", nr, Xa);
vt("gg", nr, Xa);
vt("GGGG", F1, I1);
vt("gggg", F1, I1);
vt("GGGGG", Zy, $y);
vt("ggggg", Zy, $y);
kg(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(s, u, h, v) {
    u[v.substr(0, 2)] = un(s);
  }
);
kg(["gg", "GG"], function(s, u, h, v) {
  u[v] = Ve.parseTwoDigitYear(s);
});
function gI(s) {
  return $E.call(
    this,
    s,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function vI(s) {
  return $E.call(
    this,
    s,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function mI() {
  return Al(this.year(), 1, 4);
}
function yI() {
  return Al(this.isoWeekYear(), 1, 4);
}
function xI() {
  var s = this.localeData()._week;
  return Al(this.year(), s.dow, s.doy);
}
function bI() {
  var s = this.localeData()._week;
  return Al(this.weekYear(), s.dow, s.doy);
}
function $E(s, u, h, v, w) {
  var A;
  return s == null ? pg(this, v, w).year : (A = Al(s, v, w), u > A && (u = A), wI.call(this, s, u, h, v, w));
}
function wI(s, u, h, v, w) {
  var A = EE(s, u, h, v, w), T = hg(A.year, 0, A.dayOfYear);
  return this.year(T.getUTCFullYear()), this.month(T.getUTCMonth()), this.date(T.getUTCDate()), this;
}
zt("Q", 0, "Qo", "quarter");
Gi("quarter", "Q");
$i("quarter", 7);
vt("Q", mE);
Hn("Q", function(s, u) {
  u[kl] = (un(s) - 1) * 3;
});
function SI(s) {
  return s == null ? Math.ceil((this.month() + 1) / 3) : this.month((s - 1) * 3 + this.month() % 3);
}
zt("D", ["DD", 2], "Do", "date");
Gi("date", "D");
$i("date", 9);
vt("D", nr);
vt("DD", nr, Xa);
vt("Do", function(s, u) {
  return s ? u._dayOfMonthOrdinalParse || u._ordinalParse : u._dayOfMonthOrdinalParseLenient;
});
Hn(["D", "DD"], Ro);
Hn("Do", function(s, u) {
  u[Ro] = un(s.match(nr)[0]);
});
var qE = Hf("Date", !0);
zt("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
Gi("dayOfYear", "DDD");
$i("dayOfYear", 4);
vt("DDD", qy);
vt("DDDD", yE);
Hn(["DDD", "DDDD"], function(s, u, h) {
  h._dayOfYear = un(s);
});
function kI(s) {
  var u = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return s == null ? u : this.add(s - u, "d");
}
zt("m", ["mm", 2], 0, "minute");
Gi("minute", "m");
$i("minute", 14);
vt("m", nr);
vt("mm", nr, Xa);
Hn(["m", "mm"], js);
var CI = Hf("Minutes", !1);
zt("s", ["ss", 2], 0, "second");
Gi("second", "s");
$i("second", 15);
vt("s", nr);
vt("ss", nr, Xa);
Hn(["s", "ss"], Cl);
var AI = Hf("Seconds", !1);
zt("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
zt(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
zt(0, ["SSS", 3], 0, "millisecond");
zt(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
zt(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
zt(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
zt(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
zt(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
zt(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
Gi("millisecond", "ms");
$i("millisecond", 16);
vt("S", qy, mE);
vt("SS", qy, Xa);
vt("SSS", qy, yE);
var Ru, ZE;
for (Ru = "SSSS"; Ru.length <= 9; Ru += "S")
  vt(Ru, jf);
function TI(s, u) {
  u[Ic] = un(("0." + s) * 1e3);
}
for (Ru = "S"; Ru.length <= 9; Ru += "S")
  Hn(Ru, TI);
ZE = Hf("Milliseconds", !1);
zt("z", 0, 0, "zoneAbbr");
zt("zz", 0, 0, "zoneName");
function EI() {
  return this._isUTC ? "UTC" : "";
}
function RI() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var $e = wg.prototype;
$e.add = bz;
$e.calendar = Ez;
$e.clone = Rz;
$e.diff = Nz;
$e.endOf = Xz;
$e.format = Yz;
$e.from = Hz;
$e.fromNow = jz;
$e.to = Uz;
$e.toNow = Bz;
$e.get = MP;
$e.invalidAt = eI;
$e.isAfter = Lz;
$e.isBefore = Mz;
$e.isBetween = Dz;
$e.isSame = Oz;
$e.isSameOrAfter = _z;
$e.isSameOrBefore = Pz;
$e.isValid = Kz;
$e.lang = BE;
$e.locale = UE;
$e.localeData = WE;
$e.max = KN;
$e.min = QN;
$e.parsingFlags = Jz;
$e.set = DP;
$e.startOf = Wz;
$e.subtract = wz;
$e.toArray = qz;
$e.toObject = Zz;
$e.toDate = $z;
$e.toISOString = Iz;
$e.inspect = Fz;
typeof Symbol < "u" && Symbol.for != null && ($e[Symbol.for("nodejs.util.inspect.custom")] = function() {
  return "Moment<" + this.format() + ">";
});
$e.toJSON = Qz;
$e.toString = zz;
$e.unix = Gz;
$e.valueOf = Vz;
$e.creationData = tI;
$e.eraName = aI;
$e.eraNarrow = sI;
$e.eraAbbr = oI;
$e.eraYear = lI;
$e.year = TE;
$e.isLeapYear = ZP;
$e.weekYear = gI;
$e.isoWeekYear = vI;
$e.quarter = $e.quarters = SI;
$e.month = CE;
$e.daysInMonth = GP;
$e.week = $e.weeks = nN;
$e.isoWeek = $e.isoWeeks = rN;
$e.weeksInYear = xI;
$e.weeksInWeekYear = bI;
$e.isoWeeksInYear = mI;
$e.isoWeeksInISOWeekYear = yI;
$e.date = qE;
$e.day = $e.days = vN;
$e.weekday = mN;
$e.isoWeekday = yN;
$e.dayOfYear = kI;
$e.hour = $e.hours = AN;
$e.minute = $e.minutes = CI;
$e.second = $e.seconds = AI;
$e.millisecond = $e.milliseconds = ZE;
$e.utcOffset = oz;
$e.utc = uz;
$e.local = cz;
$e.parseZone = dz;
$e.hasAlignedHourOffset = fz;
$e.isDST = hz;
$e.isLocal = gz;
$e.isUtcOffset = vz;
$e.isUtc = FE;
$e.isUTC = FE;
$e.zoneAbbr = EI;
$e.zoneName = RI;
$e.dates = os(
  "dates accessor is deprecated. Use date instead.",
  qE
);
$e.months = os(
  "months accessor is deprecated. Use month instead",
  CE
);
$e.years = os(
  "years accessor is deprecated. Use year instead",
  TE
);
$e.zone = os(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  lz
);
$e.isDSTShifted = os(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  pz
);
function LI(s) {
  return tr(s * 1e3);
}
function MI() {
  return tr.apply(null, arguments).parseZone();
}
function QE(s) {
  return s;
}
var Rn = P1.prototype;
Rn.calendar = vP;
Rn.longDateFormat = bP;
Rn.invalidDate = SP;
Rn.ordinal = AP;
Rn.preparse = QE;
Rn.postformat = QE;
Rn.relativeTime = EP;
Rn.pastFuture = RP;
Rn.set = pP;
Rn.eras = nI;
Rn.erasParse = rI;
Rn.erasConvertYear = iI;
Rn.erasAbbrRegex = cI;
Rn.erasNameRegex = uI;
Rn.erasNarrowRegex = dI;
Rn.months = BP;
Rn.monthsShort = WP;
Rn.monthsParse = VP;
Rn.monthsRegex = qP;
Rn.monthsShortRegex = $P;
Rn.week = KP;
Rn.firstDayOfYear = tN;
Rn.firstDayOfWeek = eN;
Rn.weekdays = dN;
Rn.weekdaysMin = hN;
Rn.weekdaysShort = fN;
Rn.weekdaysParse = gN;
Rn.weekdaysRegex = xN;
Rn.weekdaysShortRegex = bN;
Rn.weekdaysMinRegex = wN;
Rn.isPM = kN;
Rn.meridiem = TN;
function Uy(s, u, h, v) {
  var w = El(), A = Do().set(v, u);
  return w[h](A, s);
}
function KE(s, u, h) {
  if (Tl(s) && (u = s, s = void 0), s = s || "", u != null)
    return Uy(s, u, h, "month");
  var v, w = [];
  for (v = 0; v < 12; v++)
    w[v] = Uy(s, v, h, "month");
  return w;
}
function Z1(s, u, h, v) {
  typeof s == "boolean" ? (Tl(u) && (h = u, u = void 0), u = u || "") : (u = s, h = u, s = !1, Tl(u) && (h = u, u = void 0), u = u || "");
  var w = El(), A = s ? w._week.dow : 0, T, F = [];
  if (h != null)
    return Uy(u, (h + A) % 7, v, "day");
  for (T = 0; T < 7; T++)
    F[T] = Uy(u, (T + A) % 7, v, "day");
  return F;
}
function DI(s, u) {
  return KE(s, u, "months");
}
function OI(s, u) {
  return KE(s, u, "monthsShort");
}
function _I(s, u, h) {
  return Z1(s, u, h, "weekdays");
}
function PI(s, u, h) {
  return Z1(s, u, h, "weekdaysShort");
}
function NI(s, u, h) {
  return Z1(s, u, h, "weekdaysMin");
}
Lu("en", {
  eras: [
    {
      since: "0001-01-01",
      until: 1 / 0,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -1 / 0,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(s) {
    var u = s % 10, h = un(s % 100 / 10) === 1 ? "th" : u === 1 ? "st" : u === 2 ? "nd" : u === 3 ? "rd" : "th";
    return s + h;
  }
});
Ve.lang = os(
  "moment.lang is deprecated. Use moment.locale instead.",
  Lu
);
Ve.langData = os(
  "moment.langData is deprecated. Use moment.localeData instead.",
  El
);
var bl = Math.abs;
function zI() {
  var s = this._data;
  return this._milliseconds = bl(this._milliseconds), this._days = bl(this._days), this._months = bl(this._months), s.milliseconds = bl(s.milliseconds), s.seconds = bl(s.seconds), s.minutes = bl(s.minutes), s.hours = bl(s.hours), s.months = bl(s.months), s.years = bl(s.years), this;
}
function JE(s, u, h, v) {
  var w = Ws(u, h);
  return s._milliseconds += v * w._milliseconds, s._days += v * w._days, s._months += v * w._months, s._bubble();
}
function II(s, u) {
  return JE(this, s, u, 1);
}
function FI(s, u) {
  return JE(this, s, u, -1);
}
function cT(s) {
  return s < 0 ? Math.floor(s) : Math.ceil(s);
}
function YI() {
  var s = this._milliseconds, u = this._days, h = this._months, v = this._data, w, A, T, F, H;
  return s >= 0 && u >= 0 && h >= 0 || s <= 0 && u <= 0 && h <= 0 || (s += cT(d1(h) + u) * 864e5, u = 0, h = 0), v.milliseconds = s % 1e3, w = ss(s / 1e3), v.seconds = w % 60, A = ss(w / 60), v.minutes = A % 60, T = ss(A / 60), v.hours = T % 24, u += ss(T / 24), H = ss(eR(u)), h += H, u -= cT(d1(H)), F = ss(h / 12), h %= 12, v.days = u, v.months = h, v.years = F, this;
}
function eR(s) {
  return s * 4800 / 146097;
}
function d1(s) {
  return s * 146097 / 4800;
}
function HI(s) {
  if (!this.isValid())
    return NaN;
  var u, h, v = this._milliseconds;
  if (s = ls(s), s === "month" || s === "quarter" || s === "year")
    switch (u = this._days + v / 864e5, h = this._months + eR(u), s) {
      case "month":
        return h;
      case "quarter":
        return h / 3;
      case "year":
        return h / 12;
    }
  else
    switch (u = this._days + Math.round(d1(this._months)), s) {
      case "week":
        return u / 7 + v / 6048e5;
      case "day":
        return u + v / 864e5;
      case "hour":
        return u * 24 + v / 36e5;
      case "minute":
        return u * 1440 + v / 6e4;
      case "second":
        return u * 86400 + v / 1e3;
      case "millisecond":
        return Math.floor(u * 864e5) + v;
      default:
        throw new Error("Unknown unit " + s);
    }
}
function jI() {
  return this.isValid() ? this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + un(this._months / 12) * 31536e6 : NaN;
}
function Rl(s) {
  return function() {
    return this.as(s);
  };
}
var UI = Rl("ms"), BI = Rl("s"), WI = Rl("m"), XI = Rl("h"), VI = Rl("d"), GI = Rl("w"), $I = Rl("M"), qI = Rl("Q"), ZI = Rl("y");
function QI() {
  return Ws(this);
}
function KI(s) {
  return s = ls(s), this.isValid() ? this[s + "s"]() : NaN;
}
function jc(s) {
  return function() {
    return this.isValid() ? this._data[s] : NaN;
  };
}
var JI = jc("milliseconds"), eF = jc("seconds"), tF = jc("minutes"), nF = jc("hours"), rF = jc("days"), iF = jc("months"), aF = jc("years");
function sF() {
  return ss(this.days() / 7);
}
var Sl = Math.round, Nf = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function oF(s, u, h, v, w) {
  return w.relativeTime(u || 1, !!h, s, v);
}
function lF(s, u, h, v) {
  var w = Ws(s).abs(), A = Sl(w.as("s")), T = Sl(w.as("m")), F = Sl(w.as("h")), H = Sl(w.as("d")), U = Sl(w.as("M")), $ = Sl(w.as("w")), q = Sl(w.as("y")), te = A <= h.ss && ["s", A] || A < h.s && ["ss", A] || T <= 1 && ["m"] || T < h.m && ["mm", T] || F <= 1 && ["h"] || F < h.h && ["hh", F] || H <= 1 && ["d"] || H < h.d && ["dd", H];
  return h.w != null && (te = te || $ <= 1 && ["w"] || $ < h.w && ["ww", $]), te = te || U <= 1 && ["M"] || U < h.M && ["MM", U] || q <= 1 && ["y"] || ["yy", q], te[2] = u, te[3] = +s > 0, te[4] = v, oF.apply(null, te);
}
function uF(s) {
  return s === void 0 ? Sl : typeof s == "function" ? (Sl = s, !0) : !1;
}
function cF(s, u) {
  return Nf[s] === void 0 ? !1 : u === void 0 ? Nf[s] : (Nf[s] = u, s === "s" && (Nf.ss = u - 1), !0);
}
function dF(s, u) {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var h = !1, v = Nf, w, A;
  return typeof s == "object" && (u = s, s = !1), typeof s == "boolean" && (h = s), typeof u == "object" && (v = Object.assign({}, Nf, u), u.s != null && u.ss == null && (v.ss = u.s - 1)), w = this.localeData(), A = lF(this, !h, v, w), h && (A = w.pastFuture(+this, A)), w.postformat(A);
}
var Hw = Math.abs;
function _f(s) {
  return (s > 0) - (s < 0) || +s;
}
function rx() {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var s = Hw(this._milliseconds) / 1e3, u = Hw(this._days), h = Hw(this._months), v, w, A, T, F = this.asSeconds(), H, U, $, q;
  return F ? (v = ss(s / 60), w = ss(v / 60), s %= 60, v %= 60, A = ss(h / 12), h %= 12, T = s ? s.toFixed(3).replace(/\.?0+$/, "") : "", H = F < 0 ? "-" : "", U = _f(this._months) !== _f(F) ? "-" : "", $ = _f(this._days) !== _f(F) ? "-" : "", q = _f(this._milliseconds) !== _f(F) ? "-" : "", H + "P" + (A ? U + A + "Y" : "") + (h ? U + h + "M" : "") + (u ? $ + u + "D" : "") + (w || v || s ? "T" : "") + (w ? q + w + "H" : "") + (v ? q + v + "M" : "") + (s ? q + T + "S" : "")) : "P0D";
}
var xn = tx.prototype;
xn.isValid = rz;
xn.abs = zI;
xn.add = II;
xn.subtract = FI;
xn.as = HI;
xn.asMilliseconds = UI;
xn.asSeconds = BI;
xn.asMinutes = WI;
xn.asHours = XI;
xn.asDays = VI;
xn.asWeeks = GI;
xn.asMonths = $I;
xn.asQuarters = qI;
xn.asYears = ZI;
xn.valueOf = jI;
xn._bubble = YI;
xn.clone = QI;
xn.get = KI;
xn.milliseconds = JI;
xn.seconds = eF;
xn.minutes = tF;
xn.hours = nF;
xn.days = rF;
xn.weeks = sF;
xn.months = iF;
xn.years = aF;
xn.humanize = dF;
xn.toISOString = rx;
xn.toString = rx;
xn.toJSON = rx;
xn.locale = UE;
xn.localeData = WE;
xn.toIsoString = os(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  rx
);
xn.lang = BE;
zt("X", 0, 0, "unix");
zt("x", 0, 0, "valueOf");
vt("x", Qy);
vt("X", _P);
Hn("X", function(s, u, h) {
  h._d = new Date(parseFloat(s) * 1e3);
});
Hn("x", function(s, u, h) {
  h._d = new Date(un(s));
});
//! moment.js
Ve.version = "2.29.4";
fP(tr);
Ve.fn = $e;
Ve.min = JN;
Ve.max = ez;
Ve.now = tz;
Ve.utc = Do;
Ve.unix = LI;
Ve.months = DI;
Ve.isDate = bg;
Ve.locale = Lu;
Ve.invalid = Vy;
Ve.duration = Ws;
Ve.isMoment = Bs;
Ve.weekdays = _I;
Ve.parseZone = MI;
Ve.localeData = El;
Ve.isDuration = Ty;
Ve.monthsShort = OI;
Ve.weekdaysMin = NI;
Ve.defineLocale = U1;
Ve.updateLocale = MN;
Ve.locales = DN;
Ve.weekdaysShort = PI;
Ve.normalizeUnits = ls;
Ve.relativeTimeRounding = uF;
Ve.relativeTimeThreshold = cF;
Ve.calendarFormat = Tz;
Ve.prototype = $e;
Ve.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
const fF = ({
  tooltipRef: s,
  width: u,
  maxDate: h,
  minDate: v,
  labels: w,
  spacing: A,
  iteration: T,
  rectHeight: F,
  proportion: H,
  theme: U,
  items: $,
  translation: q
}) => {
  const te = hr(null);
  return /* @__PURE__ */ fe.jsxs(
    "g",
    {
      onMouseMove: (se) => {
        if (se.target === te.current && s.current) {
          const ue = se.nativeEvent.offsetX / u * h.diff(v), Re = v.clone().add(ue, "milliseconds"), Q = h.diff(v) / 3600 / 1e3 > 24 ? "YYYY-MM-DD HH:mm:ss" : "HH:mm:ss";
          s.current.innerHTML = `
              ${Re.format(Q)}
          `;
        }
      },
      children: [
        (w == null ? void 0 : w.length) && (w == null ? void 0 : w.length) > 0 && /* @__PURE__ */ fe.jsx(
          "text",
          {
            x: A / 2 - w[T].length * 4,
            y: F / 2 + F * T + 4 + 20,
            children: w[T]
          }
        ),
        /* @__PURE__ */ fe.jsx(
          "rect",
          {
            rx: 4,
            x: A,
            y: F * T + 20,
            ref: te,
            width: h.diff(v) * H,
            height: F,
            className: U == null ? void 0 : U.period
          }
        ),
        Object.values($).map(
          (se, ae) => se.map((ue, Re) => {
            if (Object.keys($)[ae] === "period")
              return null;
            const Ne = ue.start.diff(v) * H, Q = ue.finish.diff(ue.start), we = Q * H, Ee = Object.keys($)[ae];
            let re = Q / 3600 / 1e3 < 1 ? Ve.utc(Q).format("mm[m]") : Ve.utc(Q).format("HH[h]mm");
            re = re.substring(re.length - 2, re.length) === "00" ? re.substring(0, re.length - 2) : re;
            const ve = (re.length + 0.5) * 4;
            return /* @__PURE__ */ fe.jsxs(
              "g",
              {
                y: 20,
                onMouseMove: (Le) => {
                  const Be = Le.nativeEvent.offsetX / u * h.diff(v), Ge = v.clone().add(Be, "milliseconds"), wt = h.diff(v) / 3600 / 1e3 > 24 ? "YYYY-MM-DD HH:mm:ss" : "HH:mm:ss";
                  s.current && (s.current.innerHTML = `
                  <span>${q(Ee)}</span>
                  <span>
                  ${Ge.format(wt)} |
                    ${Ve.utc(ue.start).format("HH[h]mm")} -
                    ${Ve.utc(ue.finish).format("HH[h]mm")}
                  </span>
                  <span>
                    Escalado: ${Ve.utc(ue == null ? void 0 : ue.scaled).format("HH[h]mm")}
                  </span>
                  <span>
                    Duração: ${re}
                 </span>
              `);
                },
                children: [
                  /* @__PURE__ */ fe.jsx(
                    "rect",
                    {
                      className: (U == null ? void 0 : U[Object.keys($)[ae]]) ?? "fill-text-disabled",
                      width: we,
                      rx: 4,
                      x: Ne + A,
                      height: F,
                      y: F * T + 20,
                      fill: "currentColor"
                    }
                  ),
                  ve < we / 2 && /* @__PURE__ */ fe.jsx(
                    "text",
                    {
                      x: Ne + we / 2 - ve + A,
                      y: F * T + F / 2 + 26,
                      children: re
                    }
                  )
                ]
              },
              Re
            );
          })
        )
      ]
    }
  );
}, hF = ({
  data: s,
  width: u,
  height: h,
  labels: v,
  tooltipRef: w,
  translation: A,
  theme: T
}) => {
  if (u === 0 || h === 0 || s.length === 0)
    return null;
  const F = v != null && v.length && (v == null ? void 0 : v.length) > 0 ? 80 : 0;
  u = u - F, h = h - 20;
  const H = h / s.length;
  let U = Ve(), $ = Ve();
  s.forEach((ue) => {
    Object.values(ue).forEach((Re) => {
      Re.forEach((Ne) => {
        U = Ve.min(U, Ne.start), $ = Ve.max($, Ne.finish);
      });
    });
  });
  const q = $.diff(U), te = u / q, se = Ve.duration(q, "milliseconds").hours(), ae = u / se / 4;
  return /* @__PURE__ */ fe.jsxs(fe.Fragment, { children: [
    s.map((ue, Re) => /* @__PURE__ */ fe.jsx(sE, { children: /* @__PURE__ */ fe.jsx(
      fF,
      {
        width: u + F,
        labels: v,
        items: ue,
        maxDate: $,
        minDate: U,
        spacing: F,
        iteration: Re,
        proportion: te,
        rectHeight: H,
        translation: A,
        tooltipRef: w,
        theme: T
      }
    ) }, Re)),
    Array.from({ length: se * 4 }).map((ue, Re) => /* @__PURE__ */ fe.jsx("g", { className: "interval", children: /* @__PURE__ */ fe.jsx(
      "line",
      {
        x1: ae * Re + 80,
        x2: ae * Re + 80,
        y1: 20,
        y2: h + 20
      }
    ) }, Re)),
    Array.from({ length: se + 1 }).map((ue, Re) => {
      const Ne = Ve.utc(U).hours() + Re;
      return /* @__PURE__ */ fe.jsxs(
        "text",
        {
          x: ae * 4 * Re + F - String(Ne).length * 8,
          y: 12,
          fill: "#fff",
          children: [
            Ne,
            "h"
          ]
        },
        Re
      );
    })
  ] });
};
function pF(s, u = 300) {
  let h;
  return function(...v) {
    clearTimeout(h), h = setTimeout(() => {
      s.apply(this, v);
    }, u);
  };
}
const jw = (s, u, h, v = !1) => {
  var T, F, H, U;
  const w = s.clientWidth, A = s.clientHeight;
  if ((T = u.current) == null || T.setAttribute("viewBox", `0 0 ${w} ${A}`), (F = u.current) == null || F.setAttribute("width", String(w)), !v) {
    (H = u.current) == null || H.setAttribute("height", String(A)), h({
      height: A,
      width: w
    });
    return;
  }
  (U = u.current) == null || U.setAttribute("height", String(A)), h(($) => ({
    ...$,
    width: w
  }));
}, gF = ({
  type: s,
  width: u,
  height: h,
  hide: v,
  data: w,
  children: A,
  translation: T = "workgroups",
  snap: F = !1
}) => {
  const H = hr(null), [U, $] = wr({
    width: u !== void 0 ? u - 32 : 0,
    height: h ?? 0
  }), q = hr(null), te = hr(null), se = Mu(() => v ? [...w].filter((ue) => (v.forEach((Re) => delete ue[Re]), ue)) : w, [v, w]);
  console.log(U), Yf(() => {
    var Re;
    const ue = (Re = H == null ? void 0 : H.current) == null ? void 0 : Re.parentNode;
    return window == null || window.addEventListener(
      "resize",
      pF(
        () => jw(ue, H, $, h !== void 0)
      )
    ), (!u || !h) && jw(ue, H, $, h !== void 0), () => ue == null ? void 0 : ue.removeEventListener(
      "resize",
      () => jw(ue, H, () => {
      }, h !== void 0)
    );
  }, [$, u, h]);
  const ae = Math.max(
    ...se().map((ue) => {
      const Re = Object.values(ue).filter(
        (Ne) => typeof Ne == "number"
      );
      return Math.max(...Re);
    })
  );
  return /* @__PURE__ */ fe.jsxs(fe.Fragment, { children: [
    /* @__PURE__ */ fe.jsx(
      "div",
      {
        ref: q,
        className: "chart-tooltip container rounded-box bg-neutral shadow-md gap-sm"
      }
    ),
    /* @__PURE__ */ fe.jsxs(
      "svg",
      {
        ref: H,
        className: `chart ${s}`,
        viewBox: `0 0 ${u ?? 0} ${h ?? 0}`,
        width: U.width,
        height: U.height,
        onMouseMove: (ue) => {
          if (te.current && H.current && q.current) {
            const Re = te.current.style, Ne = ue.clientX, Q = H.current.getBoundingClientRect().left, we = H.current.getBoundingClientRect().top;
            if (Re.opacity = "1", F) {
              const Qe = U.width / (w.length * 4), Be = Array.from({
                length: w.length
              }).map((wt, st) => Math.abs(
                Ne - Q - Qe * st - U.width / w.length * st
              )), Ge = Be.indexOf(
                Math.min(...Be)
              ), ft = U.width / w.length * Ge + Qe * Ge;
              Re.transform = `translate(${ft}px, 0px)`;
            } else
              Re.transform = `translate(${ue.clientX - Q}px, 0px)`, Re.transition = "none";
            if (q.current.innerHTML === "") {
              q.current.style.opacity = "0";
              return;
            }
            const Ee = ue.clientX - Q, re = q.current.clientWidth;
            q.current.style.opacity = "1";
            let ve = Ee + 20;
            const Le = ue.clientY - we + 20;
            q.current.offsetLeft + Ee + re + 20 > window.innerWidth && (ve = Ee - re - 20), q.current.style.transform = `translate(${ve}px, ${Le}px)`;
          }
        },
        onMouseLeave: () => {
          q.current && te.current && (q.current.innerHTML = "", q.current.style.opacity = "0", te.current.style.opacity = "0");
        },
        children: [
          A({
            currentSize: U,
            tooltipRef: q,
            data: se(),
            maxItemValue: ae,
            lineRef: te,
            translation: T
          }),
          /* @__PURE__ */ fe.jsx(
            "line",
            {
              ref: te,
              x1: "0",
              y1: "0",
              x2: "0",
              y2: h,
              strokeDasharray: 8,
              style: { stroke: "#ded", strokeWidth: "2px" }
            }
          )
        ]
      }
    )
  ] });
}, Nj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bar: dP,
  Line: uP,
  Time: hF,
  default: gF
}, Symbol.toStringTag, { value: "Module" }));
var Du = vi;
const lg = /^[a-z0-9]+(-[a-z0-9]+)*$/, ix = (s, u, h, v = "") => {
  const w = s.split(":");
  if (s.slice(0, 1) === "@") {
    if (w.length < 2 || w.length > 3)
      return null;
    v = w.shift().slice(1);
  }
  if (w.length > 3 || !w.length)
    return null;
  if (w.length > 1) {
    const F = w.pop(), H = w.pop(), U = {
      // Allow provider without '@': "provider:prefix:name"
      provider: w.length > 0 ? w[0] : v,
      prefix: H,
      name: F
    };
    return u && !Ry(U) ? null : U;
  }
  const A = w[0], T = A.split("-");
  if (T.length > 1) {
    const F = {
      provider: v,
      prefix: T.shift(),
      name: T.join("-")
    };
    return u && !Ry(F) ? null : F;
  }
  if (h && v === "") {
    const F = {
      provider: v,
      prefix: "",
      name: A
    };
    return u && !Ry(F, h) ? null : F;
  }
  return null;
}, Ry = (s, u) => s ? !!((s.provider === "" || s.provider.match(lg)) && (u && s.prefix === "" || s.prefix.match(lg)) && s.name.match(lg)) : !1, tR = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), By = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), Q1 = Object.freeze({
  ...tR,
  ...By
}), f1 = Object.freeze({
  ...Q1,
  body: "",
  hidden: !1
});
function vF(s, u) {
  const h = {};
  !s.hFlip != !u.hFlip && (h.hFlip = !0), !s.vFlip != !u.vFlip && (h.vFlip = !0);
  const v = ((s.rotate || 0) + (u.rotate || 0)) % 4;
  return v && (h.rotate = v), h;
}
function dT(s, u) {
  const h = vF(s, u);
  for (const v in f1)
    v in By ? v in s && !(v in h) && (h[v] = By[v]) : v in u ? h[v] = u[v] : v in s && (h[v] = s[v]);
  return h;
}
function mF(s, u) {
  const h = s.icons, v = s.aliases || /* @__PURE__ */ Object.create(null), w = /* @__PURE__ */ Object.create(null);
  function A(T) {
    if (h[T])
      return w[T] = [];
    if (!(T in w)) {
      w[T] = null;
      const F = v[T] && v[T].parent, H = F && A(F);
      H && (w[T] = [F].concat(H));
    }
    return w[T];
  }
  return (u || Object.keys(h).concat(Object.keys(v))).forEach(A), w;
}
function yF(s, u, h) {
  const v = s.icons, w = s.aliases || /* @__PURE__ */ Object.create(null);
  let A = {};
  function T(F) {
    A = dT(
      v[F] || w[F],
      A
    );
  }
  return T(u), h.forEach(T), dT(s, A);
}
function nR(s, u) {
  const h = [];
  if (typeof s != "object" || typeof s.icons != "object")
    return h;
  s.not_found instanceof Array && s.not_found.forEach((w) => {
    u(w, null), h.push(w);
  });
  const v = mF(s);
  for (const w in v) {
    const A = v[w];
    A && (u(w, yF(s, w, A)), h.push(w));
  }
  return h;
}
const xF = {
  provider: "",
  aliases: {},
  not_found: {},
  ...tR
};
function Uw(s, u) {
  for (const h in u)
    if (h in s && typeof s[h] != typeof u[h])
      return !1;
  return !0;
}
function rR(s) {
  if (typeof s != "object" || s === null)
    return null;
  const u = s;
  if (typeof u.prefix != "string" || !s.icons || typeof s.icons != "object" || !Uw(s, xF))
    return null;
  const h = u.icons;
  for (const w in h) {
    const A = h[w];
    if (!w.match(lg) || typeof A.body != "string" || !Uw(
      A,
      f1
    ))
      return null;
  }
  const v = u.aliases || /* @__PURE__ */ Object.create(null);
  for (const w in v) {
    const A = v[w], T = A.parent;
    if (!w.match(lg) || typeof T != "string" || !h[T] && !v[T] || !Uw(
      A,
      f1
    ))
      return null;
  }
  return u;
}
const fT = /* @__PURE__ */ Object.create(null);
function bF(s, u) {
  return {
    provider: s,
    prefix: u,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function Yc(s, u) {
  const h = fT[s] || (fT[s] = /* @__PURE__ */ Object.create(null));
  return h[u] || (h[u] = bF(s, u));
}
function K1(s, u) {
  return rR(u) ? nR(u, (h, v) => {
    v ? s.icons[h] = v : s.missing.add(h);
  }) : [];
}
function wF(s, u, h) {
  try {
    if (typeof h.body == "string")
      return s.icons[u] = { ...h }, !0;
  } catch {
  }
  return !1;
}
let vg = !1;
function iR(s) {
  return typeof s == "boolean" && (vg = s), vg;
}
function SF(s) {
  const u = typeof s == "string" ? ix(s, !0, vg) : s;
  if (u) {
    const h = Yc(u.provider, u.prefix), v = u.name;
    return h.icons[v] || (h.missing.has(v) ? null : void 0);
  }
}
function kF(s, u) {
  const h = ix(s, !0, vg);
  if (!h)
    return !1;
  const v = Yc(h.provider, h.prefix);
  return wF(v, h.name, u);
}
function CF(s, u) {
  if (typeof s != "object")
    return !1;
  if (typeof u != "string" && (u = s.provider || ""), vg && !u && !s.prefix) {
    let w = !1;
    return rR(s) && (s.prefix = "", nR(s, (A, T) => {
      T && kF(A, T) && (w = !0);
    })), w;
  }
  const h = s.prefix;
  if (!Ry({
    provider: u,
    prefix: h,
    name: "a"
  }))
    return !1;
  const v = Yc(u, h);
  return !!K1(v, s);
}
const aR = Object.freeze({
  width: null,
  height: null
}), sR = Object.freeze({
  // Dimensions
  ...aR,
  // Transformations
  ...By
}), AF = /(-?[0-9.]*[0-9]+[0-9.]*)/g, TF = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function hT(s, u, h) {
  if (u === 1)
    return s;
  if (h = h || 100, typeof s == "number")
    return Math.ceil(s * u * h) / h;
  if (typeof s != "string")
    return s;
  const v = s.split(AF);
  if (v === null || !v.length)
    return s;
  const w = [];
  let A = v.shift(), T = TF.test(A);
  for (; ; ) {
    if (T) {
      const F = parseFloat(A);
      isNaN(F) ? w.push(A) : w.push(Math.ceil(F * u * h) / h);
    } else
      w.push(A);
    if (A = v.shift(), A === void 0)
      return w.join("");
    T = !T;
  }
}
const EF = (s) => s === "unset" || s === "undefined" || s === "none";
function RF(s, u) {
  const h = {
    ...Q1,
    ...s
  }, v = {
    ...sR,
    ...u
  }, w = {
    left: h.left,
    top: h.top,
    width: h.width,
    height: h.height
  };
  let A = h.body;
  [h, v].forEach((ae) => {
    const ue = [], Re = ae.hFlip, Ne = ae.vFlip;
    let Q = ae.rotate;
    Re ? Ne ? Q += 2 : (ue.push(
      "translate(" + (w.width + w.left).toString() + " " + (0 - w.top).toString() + ")"
    ), ue.push("scale(-1 1)"), w.top = w.left = 0) : Ne && (ue.push(
      "translate(" + (0 - w.left).toString() + " " + (w.height + w.top).toString() + ")"
    ), ue.push("scale(1 -1)"), w.top = w.left = 0);
    let we;
    switch (Q < 0 && (Q -= Math.floor(Q / 4) * 4), Q = Q % 4, Q) {
      case 1:
        we = w.height / 2 + w.top, ue.unshift(
          "rotate(90 " + we.toString() + " " + we.toString() + ")"
        );
        break;
      case 2:
        ue.unshift(
          "rotate(180 " + (w.width / 2 + w.left).toString() + " " + (w.height / 2 + w.top).toString() + ")"
        );
        break;
      case 3:
        we = w.width / 2 + w.left, ue.unshift(
          "rotate(-90 " + we.toString() + " " + we.toString() + ")"
        );
        break;
    }
    Q % 2 === 1 && (w.left !== w.top && (we = w.left, w.left = w.top, w.top = we), w.width !== w.height && (we = w.width, w.width = w.height, w.height = we)), ue.length && (A = '<g transform="' + ue.join(" ") + '">' + A + "</g>");
  });
  const T = v.width, F = v.height, H = w.width, U = w.height;
  let $, q;
  T === null ? (q = F === null ? "1em" : F === "auto" ? U : F, $ = hT(q, H / U)) : ($ = T === "auto" ? H : T, q = F === null ? hT($, U / H) : F === "auto" ? U : F);
  const te = {}, se = (ae, ue) => {
    EF(ue) || (te[ae] = ue.toString());
  };
  return se("width", $), se("height", q), te.viewBox = w.left.toString() + " " + w.top.toString() + " " + H.toString() + " " + U.toString(), {
    attributes: te,
    body: A
  };
}
const LF = /\sid="(\S+)"/g, MF = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let DF = 0;
function OF(s, u = MF) {
  const h = [];
  let v;
  for (; v = LF.exec(s); )
    h.push(v[1]);
  if (!h.length)
    return s;
  const w = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return h.forEach((A) => {
    const T = typeof u == "function" ? u(A) : u + (DF++).toString(), F = A.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    s = s.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + F + ')([")]|\\.[a-z])', "g"),
      "$1" + T + w + "$3"
    );
  }), s = s.replace(new RegExp(w, "g"), ""), s;
}
const h1 = /* @__PURE__ */ Object.create(null);
function _F(s, u) {
  h1[s] = u;
}
function p1(s) {
  return h1[s] || h1[""];
}
function J1(s) {
  let u;
  if (typeof s.resources == "string")
    u = [s.resources];
  else if (u = s.resources, !(u instanceof Array) || !u.length)
    return null;
  return {
    // API hosts
    resources: u,
    // Root path
    path: s.path || "/",
    // URL length limit
    maxURL: s.maxURL || 500,
    // Timeout before next host is used.
    rotate: s.rotate || 750,
    // Timeout before failing query.
    timeout: s.timeout || 5e3,
    // Randomise default API end point.
    random: s.random === !0,
    // Start index
    index: s.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: s.dataAfterTimeout !== !1
  };
}
const eS = /* @__PURE__ */ Object.create(null), rg = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], Ly = [];
for (; rg.length > 0; )
  rg.length === 1 || Math.random() > 0.5 ? Ly.push(rg.shift()) : Ly.push(rg.pop());
eS[""] = J1({
  resources: ["https://api.iconify.design"].concat(Ly)
});
function PF(s, u) {
  const h = J1(u);
  return h === null ? !1 : (eS[s] = h, !0);
}
function tS(s) {
  return eS[s];
}
const NF = () => {
  let s;
  try {
    if (s = fetch, typeof s == "function")
      return s;
  } catch {
  }
};
let pT = NF();
function zF(s, u) {
  const h = tS(s);
  if (!h)
    return 0;
  let v;
  if (!h.maxURL)
    v = 0;
  else {
    let w = 0;
    h.resources.forEach((T) => {
      w = Math.max(w, T.length);
    });
    const A = u + ".json?icons=";
    v = h.maxURL - w - h.path.length - A.length;
  }
  return v;
}
function IF(s) {
  return s === 404;
}
const FF = (s, u, h) => {
  const v = [], w = zF(s, u), A = "icons";
  let T = {
    type: A,
    provider: s,
    prefix: u,
    icons: []
  }, F = 0;
  return h.forEach((H, U) => {
    F += H.length + 1, F >= w && U > 0 && (v.push(T), T = {
      type: A,
      provider: s,
      prefix: u,
      icons: []
    }, F = H.length), T.icons.push(H);
  }), v.push(T), v;
};
function YF(s) {
  if (typeof s == "string") {
    const u = tS(s);
    if (u)
      return u.path;
  }
  return "/";
}
const HF = (s, u, h) => {
  if (!pT) {
    h("abort", 424);
    return;
  }
  let v = YF(u.provider);
  switch (u.type) {
    case "icons": {
      const A = u.prefix, F = u.icons.join(","), H = new URLSearchParams({
        icons: F
      });
      v += A + ".json?" + H.toString();
      break;
    }
    case "custom": {
      const A = u.uri;
      v += A.slice(0, 1) === "/" ? A.slice(1) : A;
      break;
    }
    default:
      h("abort", 400);
      return;
  }
  let w = 503;
  pT(s + v).then((A) => {
    const T = A.status;
    if (T !== 200) {
      setTimeout(() => {
        h(IF(T) ? "abort" : "next", T);
      });
      return;
    }
    return w = 501, A.json();
  }).then((A) => {
    if (typeof A != "object" || A === null) {
      setTimeout(() => {
        A === 404 ? h("abort", A) : h("next", w);
      });
      return;
    }
    setTimeout(() => {
      h("success", A);
    });
  }).catch(() => {
    h("next", w);
  });
}, jF = {
  prepare: FF,
  send: HF
};
function UF(s) {
  const u = {
    loaded: [],
    missing: [],
    pending: []
  }, h = /* @__PURE__ */ Object.create(null);
  s.sort((w, A) => w.provider !== A.provider ? w.provider.localeCompare(A.provider) : w.prefix !== A.prefix ? w.prefix.localeCompare(A.prefix) : w.name.localeCompare(A.name));
  let v = {
    provider: "",
    prefix: "",
    name: ""
  };
  return s.forEach((w) => {
    if (v.name === w.name && v.prefix === w.prefix && v.provider === w.provider)
      return;
    v = w;
    const A = w.provider, T = w.prefix, F = w.name, H = h[A] || (h[A] = /* @__PURE__ */ Object.create(null)), U = H[T] || (H[T] = Yc(A, T));
    let $;
    F in U.icons ? $ = u.loaded : T === "" || U.missing.has(F) ? $ = u.missing : $ = u.pending;
    const q = {
      provider: A,
      prefix: T,
      name: F
    };
    $.push(q);
  }), u;
}
function oR(s, u) {
  s.forEach((h) => {
    const v = h.loaderCallbacks;
    v && (h.loaderCallbacks = v.filter((w) => w.id !== u));
  });
}
function BF(s) {
  s.pendingCallbacksFlag || (s.pendingCallbacksFlag = !0, setTimeout(() => {
    s.pendingCallbacksFlag = !1;
    const u = s.loaderCallbacks ? s.loaderCallbacks.slice(0) : [];
    if (!u.length)
      return;
    let h = !1;
    const v = s.provider, w = s.prefix;
    u.forEach((A) => {
      const T = A.icons, F = T.pending.length;
      T.pending = T.pending.filter((H) => {
        if (H.prefix !== w)
          return !0;
        const U = H.name;
        if (s.icons[U])
          T.loaded.push({
            provider: v,
            prefix: w,
            name: U
          });
        else if (s.missing.has(U))
          T.missing.push({
            provider: v,
            prefix: w,
            name: U
          });
        else
          return h = !0, !0;
        return !1;
      }), T.pending.length !== F && (h || oR([s], A.id), A.callback(
        T.loaded.slice(0),
        T.missing.slice(0),
        T.pending.slice(0),
        A.abort
      ));
    });
  }));
}
let WF = 0;
function XF(s, u, h) {
  const v = WF++, w = oR.bind(null, h, v);
  if (!u.pending.length)
    return w;
  const A = {
    id: v,
    icons: u,
    callback: s,
    abort: w
  };
  return h.forEach((T) => {
    (T.loaderCallbacks || (T.loaderCallbacks = [])).push(A);
  }), w;
}
function VF(s, u = !0, h = !1) {
  const v = [];
  return s.forEach((w) => {
    const A = typeof w == "string" ? ix(w, u, h) : w;
    A && v.push(A);
  }), v;
}
var GF = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function $F(s, u, h, v) {
  const w = s.resources.length, A = s.random ? Math.floor(Math.random() * w) : s.index;
  let T;
  if (s.random) {
    let ve = s.resources.slice(0);
    for (T = []; ve.length > 1; ) {
      const Le = Math.floor(Math.random() * ve.length);
      T.push(ve[Le]), ve = ve.slice(0, Le).concat(ve.slice(Le + 1));
    }
    T = T.concat(ve);
  } else
    T = s.resources.slice(A).concat(s.resources.slice(0, A));
  const F = Date.now();
  let H = "pending", U = 0, $, q = null, te = [], se = [];
  typeof v == "function" && se.push(v);
  function ae() {
    q && (clearTimeout(q), q = null);
  }
  function ue() {
    H === "pending" && (H = "aborted"), ae(), te.forEach((ve) => {
      ve.status === "pending" && (ve.status = "aborted");
    }), te = [];
  }
  function Re(ve, Le) {
    Le && (se = []), typeof ve == "function" && se.push(ve);
  }
  function Ne() {
    return {
      startTime: F,
      payload: u,
      status: H,
      queriesSent: U,
      queriesPending: te.length,
      subscribe: Re,
      abort: ue
    };
  }
  function Q() {
    H = "failed", se.forEach((ve) => {
      ve(void 0, $);
    });
  }
  function we() {
    te.forEach((ve) => {
      ve.status === "pending" && (ve.status = "aborted");
    }), te = [];
  }
  function Ee(ve, Le, Qe) {
    const Be = Le !== "success";
    switch (te = te.filter((Ge) => Ge !== ve), H) {
      case "pending":
        break;
      case "failed":
        if (Be || !s.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (Le === "abort") {
      $ = Qe, Q();
      return;
    }
    if (Be) {
      $ = Qe, te.length || (T.length ? re() : Q());
      return;
    }
    if (ae(), we(), !s.random) {
      const Ge = s.resources.indexOf(ve.resource);
      Ge !== -1 && Ge !== s.index && (s.index = Ge);
    }
    H = "completed", se.forEach((Ge) => {
      Ge(Qe);
    });
  }
  function re() {
    if (H !== "pending")
      return;
    ae();
    const ve = T.shift();
    if (ve === void 0) {
      if (te.length) {
        q = setTimeout(() => {
          ae(), H === "pending" && (we(), Q());
        }, s.timeout);
        return;
      }
      Q();
      return;
    }
    const Le = {
      status: "pending",
      resource: ve,
      callback: (Qe, Be) => {
        Ee(Le, Qe, Be);
      }
    };
    te.push(Le), U++, q = setTimeout(re, s.rotate), h(ve, u, Le.callback);
  }
  return setTimeout(re), Ne;
}
function lR(s) {
  const u = {
    ...GF,
    ...s
  };
  let h = [];
  function v() {
    h = h.filter((F) => F().status === "pending");
  }
  function w(F, H, U) {
    const $ = $F(
      u,
      F,
      H,
      (q, te) => {
        v(), U && U(q, te);
      }
    );
    return h.push($), $;
  }
  function A(F) {
    return h.find((H) => F(H)) || null;
  }
  return {
    query: w,
    find: A,
    setIndex: (F) => {
      u.index = F;
    },
    getIndex: () => u.index,
    cleanup: v
  };
}
function gT() {
}
const Bw = /* @__PURE__ */ Object.create(null);
function qF(s) {
  if (!Bw[s]) {
    const u = tS(s);
    if (!u)
      return;
    const h = lR(u), v = {
      config: u,
      redundancy: h
    };
    Bw[s] = v;
  }
  return Bw[s];
}
function ZF(s, u, h) {
  let v, w;
  if (typeof s == "string") {
    const A = p1(s);
    if (!A)
      return h(void 0, 424), gT;
    w = A.send;
    const T = qF(s);
    T && (v = T.redundancy);
  } else {
    const A = J1(s);
    if (A) {
      v = lR(A);
      const T = s.resources ? s.resources[0] : "", F = p1(T);
      F && (w = F.send);
    }
  }
  return !v || !w ? (h(void 0, 424), gT) : v.query(u, w, h)().abort;
}
const vT = "iconify2", mg = "iconify", uR = mg + "-count", mT = mg + "-version", cR = 36e5, QF = 168;
function g1(s, u) {
  try {
    return s.getItem(u);
  } catch {
  }
}
function nS(s, u, h) {
  try {
    return s.setItem(u, h), !0;
  } catch {
  }
}
function yT(s, u) {
  try {
    s.removeItem(u);
  } catch {
  }
}
function v1(s, u) {
  return nS(s, uR, u.toString());
}
function m1(s) {
  return parseInt(g1(s, uR)) || 0;
}
const ax = {
  local: !0,
  session: !0
}, dR = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let rS = !1;
function KF(s) {
  rS = s;
}
let by = typeof window > "u" ? {} : window;
function fR(s) {
  const u = s + "Storage";
  try {
    if (by && by[u] && typeof by[u].length == "number")
      return by[u];
  } catch {
  }
  ax[s] = !1;
}
function hR(s, u) {
  const h = fR(s);
  if (!h)
    return;
  const v = g1(h, mT);
  if (v !== vT) {
    if (v) {
      const F = m1(h);
      for (let H = 0; H < F; H++)
        yT(h, mg + H.toString());
    }
    nS(h, mT, vT), v1(h, 0);
    return;
  }
  const w = Math.floor(Date.now() / cR) - QF, A = (F) => {
    const H = mg + F.toString(), U = g1(h, H);
    if (typeof U == "string") {
      try {
        const $ = JSON.parse(U);
        if (typeof $ == "object" && typeof $.cached == "number" && $.cached > w && typeof $.provider == "string" && typeof $.data == "object" && typeof $.data.prefix == "string" && // Valid item: run callback
        u($, F))
          return !0;
      } catch {
      }
      yT(h, H);
    }
  };
  let T = m1(h);
  for (let F = T - 1; F >= 0; F--)
    A(F) || (F === T - 1 ? (T--, v1(h, T)) : dR[s].add(F));
}
function pR() {
  if (!rS) {
    KF(!0);
    for (const s in ax)
      hR(s, (u) => {
        const h = u.data, v = u.provider, w = h.prefix, A = Yc(
          v,
          w
        );
        if (!K1(A, h).length)
          return !1;
        const T = h.lastModified || -1;
        return A.lastModifiedCached = A.lastModifiedCached ? Math.min(A.lastModifiedCached, T) : T, !0;
      });
  }
}
function JF(s, u) {
  const h = s.lastModifiedCached;
  if (
    // Matches or newer
    h && h >= u
  )
    return h === u;
  if (s.lastModifiedCached = u, h)
    for (const v in ax)
      hR(v, (w) => {
        const A = w.data;
        return w.provider !== s.provider || A.prefix !== s.prefix || A.lastModified === u;
      });
  return !0;
}
function eY(s, u) {
  rS || pR();
  function h(v) {
    let w;
    if (!ax[v] || !(w = fR(v)))
      return;
    const A = dR[v];
    let T;
    if (A.size)
      A.delete(T = Array.from(A).shift());
    else if (T = m1(w), !v1(w, T + 1))
      return;
    const F = {
      cached: Math.floor(Date.now() / cR),
      provider: s.provider,
      data: u
    };
    return nS(
      w,
      mg + T.toString(),
      JSON.stringify(F)
    );
  }
  u.lastModified && !JF(s, u.lastModified) || Object.keys(u.icons).length && (u.not_found && (u = Object.assign({}, u), delete u.not_found), h("local") || h("session"));
}
function xT() {
}
function tY(s) {
  s.iconsLoaderFlag || (s.iconsLoaderFlag = !0, setTimeout(() => {
    s.iconsLoaderFlag = !1, BF(s);
  }));
}
function nY(s, u) {
  s.iconsToLoad ? s.iconsToLoad = s.iconsToLoad.concat(u).sort() : s.iconsToLoad = u, s.iconsQueueFlag || (s.iconsQueueFlag = !0, setTimeout(() => {
    s.iconsQueueFlag = !1;
    const { provider: h, prefix: v } = s, w = s.iconsToLoad;
    delete s.iconsToLoad;
    let A;
    if (!w || !(A = p1(h)))
      return;
    A.prepare(h, v, w).forEach((F) => {
      ZF(h, F, (H) => {
        if (typeof H != "object")
          F.icons.forEach((U) => {
            s.missing.add(U);
          });
        else
          try {
            const U = K1(
              s,
              H
            );
            if (!U.length)
              return;
            const $ = s.pendingIcons;
            $ && U.forEach((q) => {
              $.delete(q);
            }), eY(s, H);
          } catch (U) {
            console.error(U);
          }
        tY(s);
      });
    });
  }));
}
const rY = (s, u) => {
  const h = VF(s, !0, iR()), v = UF(h);
  if (!v.pending.length) {
    let H = !0;
    return u && setTimeout(() => {
      H && u(
        v.loaded,
        v.missing,
        v.pending,
        xT
      );
    }), () => {
      H = !1;
    };
  }
  const w = /* @__PURE__ */ Object.create(null), A = [];
  let T, F;
  return v.pending.forEach((H) => {
    const { provider: U, prefix: $ } = H;
    if ($ === F && U === T)
      return;
    T = U, F = $, A.push(Yc(U, $));
    const q = w[U] || (w[U] = /* @__PURE__ */ Object.create(null));
    q[$] || (q[$] = []);
  }), v.pending.forEach((H) => {
    const { provider: U, prefix: $, name: q } = H, te = Yc(U, $), se = te.pendingIcons || (te.pendingIcons = /* @__PURE__ */ new Set());
    se.has(q) || (se.add(q), w[U][$].push(q));
  }), A.forEach((H) => {
    const { provider: U, prefix: $ } = H;
    w[U][$].length && nY(H, w[U][$]);
  }), u ? XF(u, v, A) : xT;
};
function iY(s, u) {
  const h = {
    ...s
  };
  for (const v in u) {
    const w = u[v], A = typeof w;
    v in aR ? (w === null || w && (A === "string" || A === "number")) && (h[v] = w) : A === typeof h[v] && (h[v] = v === "rotate" ? w % 4 : w);
  }
  return h;
}
const aY = /[\s,]+/;
function sY(s, u) {
  u.split(aY).forEach((h) => {
    switch (h.trim()) {
      case "horizontal":
        s.hFlip = !0;
        break;
      case "vertical":
        s.vFlip = !0;
        break;
    }
  });
}
function oY(s, u = 0) {
  const h = s.replace(/^-?[0-9.]*/, "");
  function v(w) {
    for (; w < 0; )
      w += 4;
    return w % 4;
  }
  if (h === "") {
    const w = parseInt(s);
    return isNaN(w) ? 0 : v(w);
  } else if (h !== s) {
    let w = 0;
    switch (h) {
      case "%":
        w = 25;
        break;
      case "deg":
        w = 90;
    }
    if (w) {
      let A = parseFloat(s.slice(0, s.length - h.length));
      return isNaN(A) ? 0 : (A = A / w, A % 1 === 0 ? v(A) : 0);
    }
  }
  return u;
}
function lY(s, u) {
  let h = s.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const v in u)
    h += " " + v + '="' + u[v] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + h + ">" + s + "</svg>";
}
function uY(s) {
  return s.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function cY(s) {
  return "data:image/svg+xml," + uY(s);
}
function dY(s) {
  return 'url("' + cY(s) + '")';
}
let ug;
function fY() {
  try {
    ug = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (s) => s
    });
  } catch {
    ug = null;
  }
}
function hY(s) {
  return ug === void 0 && fY(), ug ? ug.createHTML(s) : s;
}
const gR = {
  ...sR,
  inline: !1
}, pY = {
  xmlns: "http://www.w3.org/2000/svg",
  xmlnsXlink: "http://www.w3.org/1999/xlink",
  "aria-hidden": !0,
  role: "img"
}, gY = {
  display: "inline-block"
}, y1 = {
  backgroundColor: "currentColor"
}, vR = {
  backgroundColor: "transparent"
}, bT = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
}, wT = {
  WebkitMask: y1,
  mask: y1,
  background: vR
};
for (const s in wT) {
  const u = wT[s];
  for (const h in bT)
    u[s + h] = bT[h];
}
const vY = {
  ...gR,
  inline: !0
};
function ST(s) {
  return s + (s.match(/^[-0-9.]+$/) ? "px" : "");
}
const mY = (s, u, h, v) => {
  const w = h ? vY : gR, A = iY(w, u), T = u.mode || "svg", F = {}, H = u.style || {}, U = {
    ...T === "svg" ? pY : {},
    ref: v
  };
  for (let Ne in u) {
    const Q = u[Ne];
    if (Q !== void 0)
      switch (Ne) {
        case "icon":
        case "style":
        case "children":
        case "onLoad":
        case "mode":
        case "_ref":
        case "_inline":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          A[Ne] = Q === !0 || Q === "true" || Q === 1;
          break;
        case "flip":
          typeof Q == "string" && sY(A, Q);
          break;
        case "color":
          F.color = Q;
          break;
        case "rotate":
          typeof Q == "string" ? A[Ne] = oY(Q) : typeof Q == "number" && (A[Ne] = Q);
          break;
        case "ariaHidden":
        case "aria-hidden":
          Q !== !0 && Q !== "true" && delete U["aria-hidden"];
          break;
        default:
          w[Ne] === void 0 && (U[Ne] = Q);
      }
  }
  const $ = RF(s, A), q = $.attributes;
  if (A.inline && (F.verticalAlign = "-0.125em"), T === "svg") {
    U.style = {
      ...F,
      ...H
    }, Object.assign(U, q);
    let Ne = 0, Q = u.id;
    return typeof Q == "string" && (Q = Q.replace(/-/g, "_")), U.dangerouslySetInnerHTML = {
      __html: hY(OF($.body, Q ? () => Q + "ID" + Ne++ : "iconifyReact"))
    }, Du.createElement("svg", U);
  }
  const { body: te, width: se, height: ae } = s, ue = T === "mask" || (T === "bg" ? !1 : te.indexOf("currentColor") !== -1), Re = lY(te, {
    ...q,
    width: se + "",
    height: ae + ""
  });
  return U.style = {
    ...F,
    "--svg": dY(Re),
    width: ST(q.width),
    height: ST(q.height),
    ...gY,
    ...ue ? y1 : vR,
    ...H
  }, Du.createElement("span", U);
};
iR(!0);
_F("", jF);
if (typeof document < "u" && typeof window < "u") {
  pR();
  const s = window;
  if (s.IconifyPreload !== void 0) {
    const u = s.IconifyPreload, h = "Invalid IconifyPreload syntax.";
    typeof u == "object" && u !== null && (u instanceof Array ? u : [u]).forEach((v) => {
      try {
        // Check if item is an object and not null/array
        (typeof v != "object" || v === null || v instanceof Array || // Check for 'icons' and 'prefix'
        typeof v.icons != "object" || typeof v.prefix != "string" || // Add icon set
        !CF(v)) && console.error(h);
      } catch {
        console.error(h);
      }
    });
  }
  if (s.IconifyProviders !== void 0) {
    const u = s.IconifyProviders;
    if (typeof u == "object" && u !== null)
      for (let h in u) {
        const v = "IconifyProviders[" + h + "] is invalid.";
        try {
          const w = u[h];
          if (typeof w != "object" || !w || w.resources === void 0)
            continue;
          PF(h, w) || console.error(v);
        } catch {
          console.error(v);
        }
      }
  }
}
let mR = class extends Du.Component {
  constructor(u) {
    super(u), this.state = {
      // Render placeholder before component is mounted
      icon: null
    };
  }
  /**
   * Abort loading icon
   */
  _abortLoading() {
    this._loading && (this._loading.abort(), this._loading = null);
  }
  /**
   * Update state
   */
  _setData(u) {
    this.state.icon !== u && this.setState({
      icon: u
    });
  }
  /**
   * Check if icon should be loaded
   */
  _checkIcon(u) {
    const h = this.state, v = this.props.icon;
    if (typeof v == "object" && v !== null && typeof v.body == "string") {
      this._icon = "", this._abortLoading(), (u || h.icon === null) && this._setData({
        data: v
      });
      return;
    }
    let w;
    if (typeof v != "string" || (w = ix(v, !1, !0)) === null) {
      this._abortLoading(), this._setData(null);
      return;
    }
    const A = SF(w);
    if (!A) {
      (!this._loading || this._loading.name !== v) && (this._abortLoading(), this._icon = "", this._setData(null), A !== null && (this._loading = {
        name: v,
        abort: rY([w], this._checkIcon.bind(this, !1))
      }));
      return;
    }
    if (this._icon !== v || h.icon === null) {
      this._abortLoading(), this._icon = v;
      const T = ["iconify"];
      w.prefix !== "" && T.push("iconify--" + w.prefix), w.provider !== "" && T.push("iconify--" + w.provider), this._setData({
        data: A,
        classes: T
      }), this.props.onLoad && this.props.onLoad(v);
    }
  }
  /**
   * Component mounted
   */
  componentDidMount() {
    this._checkIcon(!1);
  }
  /**
   * Component updated
   */
  componentDidUpdate(u) {
    u.icon !== this.props.icon && this._checkIcon(!0);
  }
  /**
   * Abort loading
   */
  componentWillUnmount() {
    this._abortLoading();
  }
  /**
   * Render
   */
  render() {
    const u = this.props, h = this.state.icon;
    if (h === null)
      return u.children ? u.children : Du.createElement("span", {});
    let v = u;
    return h.classes && (v = {
      ...u,
      className: (typeof u.className == "string" ? u.className + " " : "") + h.classes.join(" ")
    }), mY({
      ...Q1,
      ...h.data
    }, v, u._inline, u._ref);
  }
};
const yY = Du.forwardRef(function(u, h) {
  const v = {
    ...u,
    _ref: h,
    _inline: !1
  };
  return Du.createElement(mR, v);
});
Du.forwardRef(function(u, h) {
  const v = {
    ...u,
    _ref: h,
    _inline: !0
  };
  return Du.createElement(mR, v);
});
var gi = yY;
const xY = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (s) => {
  const u = Math.random() * 16 | 0;
  return (s === "x" ? u : u & 3 | 8).toString(16);
}), bY = ({
  onChange: s,
  defaultValue: u,
  children: h,
  name: v,
  invalidText: w,
  placeholder: A,
  variant: T,
  icon: F,
  required: H = !0,
  className: U = "",
  type: $ = "text",
  id: q = xY(),
  ...te
}) => /* @__PURE__ */ fe.jsxs("div", { className: `textfield ${T ? "bg-" + T : ""} ${U}`, children: [
  /* @__PURE__ */ fe.jsx("label", { htmlFor: q, children: A ?? v ?? q }),
  /* @__PURE__ */ fe.jsx(
    "input",
    {
      id: q,
      type: $,
      className: "input",
      name: v ?? q,
      onChange: s,
      defaultValue: u,
      placeholder: A ?? v ?? q ?? "",
      required: H,
      ...te
    }
  ),
  F && /* @__PURE__ */ fe.jsx(gi, { icon: F }),
  H && /* @__PURE__ */ fe.jsx("span", { className: "required", children: w ?? v ? `${v ?? q} should not be empty!` : "Should not be empty!" }),
  h && h
] }), Ij = ({
  defaultShow: s = !1,
  ...u
}) => {
  const [h, v] = wr(s);
  return /* @__PURE__ */ fe.jsx(fe.Fragment, { children: /* @__PURE__ */ fe.jsx(
    bY,
    {
      ...u,
      className: `textfield-password ${(u == null ? void 0 : u.className) ?? ""}`,
      type: h ? "text" : "password",
      autoComplete: "new-password",
      children: /* @__PURE__ */ fe.jsx(
        "button",
        {
          type: "button",
          title: "Show or hide the password",
          className: "btn btn-circle btn-sm ring-info",
          onClick: () => v((w) => !w),
          children: /* @__PURE__ */ fe.jsx(gi, { icon: h ? "ph:eye-slash" : "ph:eye-light" })
        }
      )
    }
  ) });
}, wY = (s) => {
  console.log(s);
}, SY = (s) => {
  console.log(s);
}, kY = ["Su", "Mo", "Tu", "We", "Th", "Fri", "Sa"], CY = ({
  defaultSelected: s,
  startDateRef: u,
  endDateRef: h,
  onClose: v
}) => {
  const [w, A] = wr(
    (s == null ? void 0 : s.end) === void 0 ? Ve() : s.end
  ), [T, F] = wr(
    s === void 0 ? {
      start: null,
      end: null
    } : s
  ), H = w, U = H.clone().startOf("month"), $ = H.clone().endOf("month"), q = [], te = U.day(), se = $.day();
  for (let ae = te - 1; ae >= 0; ae--)
    q.push(U.clone().subtract(ae, "days"));
  for (let ae = U.clone().add(1, "day"); ae.isSameOrBefore($); ae.add(1, "day"))
    q.push(ae.clone());
  for (let ae = 1; ae <= 6 - se + 1; ae++)
    q.push($.clone().add(ae, "days"));
  return /* @__PURE__ */ fe.jsx("div", { className: "dropdown", children: /* @__PURE__ */ fe.jsxs("div", { className: "container rounded-box shadow-md bg-base-200", children: [
    /* @__PURE__ */ fe.jsxs("header", { className: "date-header", children: [
      /* @__PURE__ */ fe.jsxs("div", { className: "date-header--actions", children: [
        /* @__PURE__ */ fe.jsx(
          "button",
          {
            type: "button",
            className: "btn btn-icon btn-sm btn-square btn-neutral",
            onClick: () => {
              A(
                (ae) => ae.clone().subtract(1, "month")
              );
            },
            children: /* @__PURE__ */ fe.jsx(gi, { icon: "ep:arrow-left-bold" })
          }
        ),
        /* @__PURE__ */ fe.jsx("button", { type: "button", className: "btn", children: H.format("MMM, YYYY") }),
        /* @__PURE__ */ fe.jsx(
          "button",
          {
            type: "button",
            className: "btn btn-icon btn-sm btn-square btn-neutral",
            onClick: () => {
              A(
                (ae) => ae.clone().add(1, "month")
              );
            },
            disabled: w.clone().add(1, "month").isSameOrAfter(Ve()),
            children: /* @__PURE__ */ fe.jsx(gi, { icon: "ep:arrow-left-bold", hFlip: !0 })
          }
        )
      ] }),
      /* @__PURE__ */ fe.jsx("ul", { className: "date-weekdays", children: kY.map((ae) => /* @__PURE__ */ fe.jsx("li", { children: /* @__PURE__ */ fe.jsx("span", { children: ae }) }, ae)) })
    ] }),
    /* @__PURE__ */ fe.jsx("ul", { className: "days-container", children: q.map((ae, ue) => {
      var Ee, re, ve;
      let Re = "";
      const Ne = (Ee = T.start) != null && Ee.startOf("day").isSame(ae) ? "selected start" : (ve = (re = T.end) == null ? void 0 : re.startOf("day")) != null && ve.isSame(ae) ? "selected end" : "", Q = ae.format("MM") !== H.format("MM") ? "not-current" : "", we = ae.isBetween(
        T.start,
        T.end
      ) ? "between" : "";
      return Re += Q + Ne + we, /* @__PURE__ */ fe.jsx("li", { children: /* @__PURE__ */ fe.jsx(
        "button",
        {
          type: "button",
          onClick: () => {
            var Le;
            if (!(u.current === null || h.current === null)) {
              if (((Le = T.start) == null ? void 0 : Le.date()) === ae.date()) {
                F({
                  start: null,
                  end: null
                }), u.current.value = "", h.current.value = "";
                return;
              }
              if (T.start === null)
                F((Qe) => ({
                  ...Qe,
                  start: ae
                })), u.current.value = ae.format("YYYY-MM-DD");
              else if (T.start !== null) {
                if (ae.isBefore(T.start)) {
                  F((Qe) => ({
                    start: ae,
                    end: Qe.start
                  })), u.current.value = ae.format("YYYY-MM-DD"), h.current.value = T.start.format("YYYY-MM-DD");
                  return;
                }
                F((Qe) => ({
                  ...Qe,
                  end: ae
                })), h.current.value = ae.format("YYYY-MM-DD");
              }
            }
          },
          className: Re,
          disabled: ae.isAfter(Ve()),
          children: ae.format("DD")
        }
      ) }, ue);
    }) }),
    /* @__PURE__ */ fe.jsx(
      "button",
      {
        type: "button",
        onClick: v,
        className: "btn btn-sm btn-primary",
        style: { alignSelf: "end" },
        children: "Done"
      }
    )
  ] }) });
}, Fj = ({
  defaultSelected: s,
  onSearch: u,
  children: h
}) => {
  const [v, w] = wr(!1), A = hr(null), T = hr(null), F = {
    ref: A,
    type: "date",
    name: "start",
    onFocus: wY,
    onClick: () => {
      w((U) => !U);
    },
    autoComplete: "off",
    defaultValue: s ? s.start.format("YYYY-MM-DD") : ""
  }, H = {
    ref: T,
    type: "date",
    name: "end",
    onFocus: SY,
    onClick: () => {
      w((U) => !U);
    },
    autoComplete: "off",
    defaultValue: s != null && s.end ? s.end.format("YYYY-MM-DD") : ""
  };
  return /* @__PURE__ */ fe.jsx(fe.Fragment, { children: /* @__PURE__ */ fe.jsxs(
    "form",
    {
      className: "date-range-picker",
      onSubmit: (U) => {
        U.preventDefault();
        const $ = new FormData(U.target), q = Object.fromEntries($.entries()), te = {
          start: Ve(q.start, "YYYY-MM-DD"),
          end: Ve(q.end, "YYYY-MM-DD")
        };
        u == null || u(te);
      },
      children: [
        /* @__PURE__ */ fe.jsxs("div", { className: "group rounded-box", children: [
          h({ startDateProps: F, endDateProps: H }),
          /* @__PURE__ */ fe.jsx("button", { className: "btn btn-primary ring-info", children: "Search" })
        ] }),
        v && /* @__PURE__ */ fe.jsx(
          CY,
          {
            defaultSelected: s,
            startDateRef: A,
            endDateRef: T,
            onClose: () => w(!1)
          }
        )
      ]
    }
  ) });
}, AY = (s, u, h, v, w, A) => {
  let T = 0, F = !1;
  switch (s.key) {
    case "ArrowUp": {
      if (u === 0)
        return;
      T = u - 1, w.current[T].focus(), h(T), v.current = "";
      break;
    }
    case "ArrowDown": {
      if (u === A - 1)
        return;
      T = u + 1, w.current[T].focus(), v.current = "", h(T);
      break;
    }
    case "Backspace": {
      v.current = v.current.slice(0, -1), v.current.length > 0 && (F = !0);
      break;
    }
    default:
      s.key.length === 1 && isNaN(Number(s.key)) && (v.current += s.key, F = !0);
  }
  if (F) {
    const H = w.current.findIndex(
      (U) => U.innerText.toLowerCase().includes(v.current.toLowerCase())
    );
    if (H === -1)
      return;
    w.current[H].focus(), h(H);
  }
}, TY = (s) => typeof s == "object" ? /* @__PURE__ */ fe.jsx("span", { children: Object.values(s)[0] }) : /* @__PURE__ */ fe.jsx("span", { children: s }), iS = ({
  items: s,
  selected: u,
  currentSelected: h,
  selector: v,
  onChange: w,
  labelExtractor: A,
  required: T = !0,
  showQty: F = 4,
  style: H = {},
  name: U = "",
  position: $ = "top",
  variant: q = "neutral",
  keyExtractor: te = TY
}) => {
  const [se, ae] = wr(!1), [ue, Re] = wr(
    u !== void 0 ? u : s.findIndex(
      (ve) => v ? ve[v] === (h == null ? void 0 : h[v]) : ve === h
    )
  );
  Yf(() => {
    u && u !== ue && Re(u);
  }, [u, ue]);
  const [Ne, Q] = wr(ue), we = hr(null), Ee = hr(""), re = hr([]);
  return /* @__PURE__ */ fe.jsxs(
    "div",
    {
      className: `select ${se ? "shadow-md" : ""} ${$}`,
      onBlur: () => {
      },
      style: H,
      children: [
        /* @__PURE__ */ fe.jsxs(
          "button",
          {
            type: "button",
            className: `btn btn-${q} btn-select ${se ? "active" : ""}`,
            onClick: () => {
              ae((Le) => !Le);
              const ve = h === void 0 ? 0 : ue;
              Q(ve), setTimeout(() => {
                se || re.current[ve].focus();
              }, 10);
            },
            children: [
              /* @__PURE__ */ fe.jsx("span", { className: ue === -1 ? "not-selected" : "", children: ue === -1 ? Yr("select.select-one") : (A == null ? void 0 : A(s[ue])) ?? te(s[ue]) }),
              /* @__PURE__ */ fe.jsx(gi, { icon: "eva:arrow-down-fill", vFlip: se })
            ]
          }
        ),
        /* @__PURE__ */ fe.jsx(
          "input",
          {
            style: {
              display: "block",
              position: "absolute",
              top: "100%",
              opacity: 0,
              height: 1,
              pointerEvents: "none"
            },
            defaultValue: typeof h == "object" && v ? h == null ? void 0 : h[v] : typeof h == "string" ? h : "",
            autoComplete: "new-password",
            name: U,
            ref: we,
            required: T
          }
        ),
        se && /* @__PURE__ */ fe.jsx(
          "ul",
          {
            className: `select-items${s.length > 4 ? " custom-scroll " : " "}bg-${q} shadow-md`,
            style: { "--select-items": F },
            children: s.map((ve, Le) => /* @__PURE__ */ fe.jsx("li", { className: "item", children: /* @__PURE__ */ fe.jsx(
              "button",
              {
                type: "button",
                className: `${Le === ue ? "active" : ""}`,
                ref: (Qe) => re.current[Le] = Qe,
                tabIndex: 0,
                onClick: () => {
                  Re(Le), w !== void 0 && w(Le, s[Le]), we.current && v && (we.current.value = String(s[Le][v])), ae(!1);
                },
                onMouseEnter: (Qe) => {
                  Q(Le), Qe.target.focus();
                },
                onMouseLeave: () => {
                  Q(ue);
                },
                onKeyDown: (Qe) => AY(
                  Qe,
                  Ne,
                  Q,
                  Ee,
                  re,
                  s.length
                ),
                children: te(ve)
              }
            ) }, Le))
          }
        )
      ]
    }
  );
}, kT = (s, u, h, v, w, A) => {
  let T = 0, F = !1;
  switch (s.key) {
    case "ArrowUp": {
      if (u === 0)
        return;
      T = u - 1, w.current[T].focus(), h(T), v.current = "";
      break;
    }
    case "ArrowDown": {
      if (u === A - 1)
        return;
      T = u + 1, w.current[T].focus(), v.current = "", h(T);
      break;
    }
    case "Backspace": {
      v.current = v.current.slice(0, -1), v.current.length > 0 && (F = !0);
      break;
    }
    default:
      s.key.length === 1 && isNaN(Number(s.key)) && (v.current += s.key, F = !0);
  }
  if (F) {
    const H = w.current.findIndex(
      (U) => U.innerText.toLowerCase().includes(v.current.toLowerCase())
    );
    if (H === -1)
      return;
    w.current[H].focus(), h(H);
  }
}, aS = (s, u, h) => {
  let v;
  return (...w) => {
    const T = () => {
      v = null, h || s.apply(void 0, w);
    }, F = h && !v;
    clearTimeout(v), v = setTimeout(T, u), F && s.apply(void 0, w);
  };
}, EY = [
  {
    mode: "all",
    label: "Todos"
  },
  {
    mode: "selected",
    label: "Selecionados"
  },
  {
    mode: "not-selected",
    label: "Não selecionados"
  }
], RY = (s) => typeof s == "object" ? /* @__PURE__ */ fe.jsx("span", { children: Object.values(s)[0] }) : /* @__PURE__ */ fe.jsx("span", { children: s }), Yj = ({
  items: s,
  selected: u,
  selector: h,
  onChange: v,
  labelExtractor: w,
  onAllChange: A = () => {
  },
  showQty: T = 10,
  style: F = {},
  position: H = "top",
  variant: U = "neutral",
  keyExtractor: $ = RY
}) => {
  const [q, te] = wr(!1), [se, ae] = wr(u ?? []), [ue, Re] = wr(
    "all"
  ), [Ne, Q] = wr("");
  Yf(() => {
    u && u !== se && ae(u ?? []);
  }, [u, se]);
  const we = Mu(() => {
    var Ge;
    const Be = [];
    for (let ft = 0; ft < s.length; ft++) {
      if (!String(h ? (Ge = s[ft]) == null ? void 0 : Ge[h] : s[ft]).toLowerCase().includes(Ne))
        continue;
      if (ue === "all") {
        Be.push(ft);
        continue;
      }
      const it = se.includes(ft);
      it && ue === "selected" && Be.push(ft), !it && ue === "not-selected" && Be.push(ft);
    }
    return Be;
  }, [s, Ne, h, ue, se]), [Ee, re] = wr(0), ve = hr(null), Le = hr(""), Qe = hr([]);
  return /* @__PURE__ */ fe.jsxs(
    "div",
    {
      className: `select multiselect ${q ? "shadow-md" : ""} ${H}`,
      onBlur: () => {
      },
      style: F,
      children: [
        /* @__PURE__ */ fe.jsxs(
          "button",
          {
            type: "button",
            className: `btn btn-${U} btn-select ${q ? "active" : ""}`,
            onClick: () => {
              te((Be) => !Be), re(0);
            },
            children: [
              /* @__PURE__ */ fe.jsx("span", { className: se.length === 0 ? "not-selected" : "", children: se.length === 0 ? "Clique para selecionar" : (w == null ? void 0 : w(se)) ?? `${se.length} selecionados` }),
              /* @__PURE__ */ fe.jsx(gi, { icon: "eva:arrow-down-fill", vFlip: q })
            ]
          }
        ),
        q && /* @__PURE__ */ fe.jsxs(
          "ul",
          {
            className: `select-items${s.length > 4 ? " custom-scroll " : " "}bg-${U} shadow-md`,
            style: { "--select-items": T },
            children: [
              /* @__PURE__ */ fe.jsx(
                "li",
                {
                  className: "group rounded-box",
                  style: { width: "fit-content", padding: "var(--spacing-xs)" },
                  children: EY.map((Be) => /* @__PURE__ */ fe.jsx(
                    "button",
                    {
                      className: `btn no-bounce btn-${Be.mode === ue ? "primary" : "neutral"} btn-sm`,
                      onClick: () => Re(Be.mode),
                      children: Be.label
                    },
                    Be.mode
                  ))
                }
              ),
              /* @__PURE__ */ fe.jsx("li", { className: "search-bar", children: /* @__PURE__ */ fe.jsx(
                "input",
                {
                  className: "input",
                  type: "input",
                  placeholder: "Buscar...",
                  onChange: aS((Be) => {
                    Q(Be.target.value.toLowerCase());
                  }, 300)
                }
              ) }),
              /* @__PURE__ */ fe.jsx("li", { className: "item", children: /* @__PURE__ */ fe.jsxs(
                "button",
                {
                  type: "button",
                  ref: (Be) => Qe.current[0] = Be,
                  className: `${se.length === s.length ? "active" : ""}`,
                  onMouseEnter: (Be) => {
                    re(0), Be.target.focus();
                  },
                  onClick: () => {
                    A(se.length !== s.length), se.length === s.length ? ae([]) : ae(s.map((Be, Ge) => Ge));
                  },
                  onKeyDown: (Be) => kT(
                    Be,
                    Ee,
                    re,
                    Le,
                    Qe,
                    s.length
                  ),
                  tabIndex: 0,
                  children: [
                    /* @__PURE__ */ fe.jsx(
                      "input",
                      {
                        type: "checkbox",
                        className: "checkbox checkbox-secondary",
                        onChange: () => {
                          A(se.length !== s.length), se.length === s.length ? ae([]) : ae(s.map((Be, Ge) => Ge));
                        },
                        checked: se.length === s.length
                      }
                    ),
                    /* @__PURE__ */ fe.jsx("span", { children: "Selecionar Tudo" })
                  ]
                }
              ) }),
              s.length === 0 || we().length === 0 && /* @__PURE__ */ fe.jsx("li", { className: "item", style: { padding: "var(--spacing-xs)" }, children: /* @__PURE__ */ fe.jsx("span", { children: "Nenhum item foi encontrado" }) }),
              s.map((Be, Ge) => {
                if (!we().includes(Ge))
                  return null;
                const ft = se.includes(Ge);
                return /* @__PURE__ */ fe.jsx("li", { className: "item", children: /* @__PURE__ */ fe.jsxs(
                  "button",
                  {
                    type: "button",
                    className: `${ft ? "active" : ""}`,
                    ref: (wt) => Qe.current[Ge + 1] = wt,
                    tabIndex: 0,
                    onClick: () => {
                      const wt = ft ? se.filter((st) => st !== Ge) : [...se, Ge];
                      ae(wt), v !== void 0 && v(Ge, s[Ge], wt), ve.current && h && (ve.current.value = String(s[Ge][h]));
                    },
                    onMouseEnter: (wt) => {
                      re(Ge), wt.target.focus();
                    },
                    onMouseLeave: () => {
                      re(0);
                    },
                    onKeyDown: (wt) => kT(
                      wt,
                      Ee,
                      re,
                      Le,
                      Qe,
                      we().length + 1
                    ),
                    children: [
                      /* @__PURE__ */ fe.jsx(
                        "input",
                        {
                          type: "checkbox",
                          className: "checkbox checkbox-secondary",
                          checked: ft ?? !1,
                          onChange: () => {
                            ae((wt) => ft ? wt.filter(
                              (st) => st !== Ge
                            ) : [...wt, Ge]), v !== void 0 && v(Ge, s[Ge]), ve.current && h && (ve.current.value = String(s[Ge][h]));
                          }
                        }
                      ),
                      $(Be)
                    ]
                  }
                ) }, Ge);
              })
            ]
          }
        )
      ]
    }
  );
};
//! moment.js locale configuration
//! locale : Portuguese (Brazil) [pt-br]
//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira
Ve.defineLocale("pt-br", {
  months: "janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split(
    "_"
  ),
  monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
  weekdays: "domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado".split(
    "_"
  ),
  weekdaysShort: "dom_seg_ter_qua_qui_sex_sáb".split("_"),
  weekdaysMin: "do_2ª_3ª_4ª_5ª_6ª_sá".split("_"),
  weekdaysParseExact: !0,
  longDateFormat: {
    LT: "HH:mm",
    LTS: "HH:mm:ss",
    L: "DD/MM/YYYY",
    LL: "D [de] MMMM [de] YYYY",
    LLL: "D [de] MMMM [de] YYYY [às] HH:mm",
    LLLL: "dddd, D [de] MMMM [de] YYYY [às] HH:mm"
  },
  calendar: {
    sameDay: "[Hoje às] LT",
    nextDay: "[Amanhã às] LT",
    nextWeek: "dddd [às] LT",
    lastDay: "[Ontem às] LT",
    lastWeek: function() {
      return this.day() === 0 || this.day() === 6 ? "[Último] dddd [às] LT" : "[Última] dddd [às] LT";
    },
    sameElse: "L"
  },
  relativeTime: {
    future: "em %s",
    past: "há %s",
    s: "poucos segundos",
    ss: "%d segundos",
    m: "um minuto",
    mm: "%d minutos",
    h: "uma hora",
    hh: "%d horas",
    d: "um dia",
    dd: "%d dias",
    M: "um mês",
    MM: "%d meses",
    y: "um ano",
    yy: "%d anos"
  },
  dayOfMonthOrdinalParse: /\d{1,2}º/,
  ordinal: "%dº",
  invalidDate: "Data inválida"
});
const LY = [
  {
    agent: {
      firstName: "Ricardo",
      lastName: "Dutra",
      baseUserId: "ricardo.dutra"
    },
    period: [
      {
        date: "2023-08-08T03:00:00.002Z",
        start: "2023-08-08T06:24:32.532Z",
        finish: "2023-08-08T15:24:32.532Z",
        description: "Saída mais cedo",
        breaks: [
          {
            start: "2023-08-08T06:24:32.532Z",
            finish: "2023-08-08T06:24:32.532Z",
            type: 205
          }
        ]
      },
      {
        date: "2023-08-11T03:00:00.002Z",
        start: "2023-08-11T06:24:32.532Z",
        finish: "2023-08-11T14:58:32.532Z",
        description: "Saída mais cedo",
        breaks: [
          {
            start: "2023-08-11T09:24:32.532Z",
            finish: "2023-08-11T09:54:32.532Z",
            type: 206
          },
          {
            start: "2023-08-11T11:15:02.532Z",
            finish: "2023-08-11T11:29:32.532Z",
            type: 205
          }
        ]
      }
    ]
  },
  {
    agent: {
      firstName: "José",
      lastName: "Aultra",
      baseUserId: "jose.aultra"
    },
    period: [
      {
        date: "2023-08-09T03:00:00.002Z",
        start: "2023-08-09T06:24:32.532Z",
        finish: "2023-08-09T14:58:32.532Z",
        description: "Saída mais cedo",
        breaks: [
          {
            start: "2023-09-08T09:24:32.532Z",
            finish: "2023-09-08T09:54:32.532Z",
            type: 206
          },
          {
            start: "2023-09-08T11:15:02.532Z",
            finish: "2023-09-08T11:29:32.532Z",
            type: 205
          }
        ]
      }
    ]
  },
  {
    agent: {
      firstName: "Rinaldo",
      lastName: "Guilherme",
      baseUserId: "rinaldo.guilherme"
    },
    period: [
      {
        date: "2023-08-10T03:00:00.002Z",
        start: "2023-08-10T06:24:32.532Z",
        finish: "2023-08-10T14:58:32.532Z",
        description: "Saída mais cedo",
        breaks: [
          {
            start: "2023-09-08T09:24:32.532Z",
            finish: "2023-09-08T09:54:32.532Z",
            type: 206
          },
          {
            start: "2023-09-08T11:15:02.532Z",
            finish: "2023-09-08T11:29:32.532Z",
            type: 205
          }
        ]
      },
      {
        date: "2023-08-14T03:00:00.002Z",
        start: "2023-08-14T06:24:32.532Z",
        finish: "2023-08-14T14:58:32.532Z",
        description: "Saída mais cedo",
        breaks: [
          {
            start: "2023-09-08T09:24:32.532Z",
            finish: "2023-09-08T09:54:32.532Z",
            type: 206
          },
          {
            start: "2023-09-08T11:15:02.532Z",
            finish: "2023-09-08T11:29:32.532Z",
            type: 205
          }
        ]
      }
    ]
  }
];
Ve.locale("pt-br");
const MY = {
  206: "Almoço",
  205: "Banheiro"
}, DY = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
], OY = ({
  data: s,
  lastSevenDays: u
}) => /* @__PURE__ */ fe.jsx("div", { className: "detailed-workday--period", children: u.map((h, v) => {
  const w = Ve(h).format("DD [de] MMMM"), A = s.find(
    ({ date: H }) => Ve(H).format("YYYY/MM/DD") === h.format("YYYY/MM/DD")
  );
  if (A === void 0)
    return /* @__PURE__ */ fe.jsx("div", { className: "day", children: /* @__PURE__ */ fe.jsx("span", { children: w }) }, v);
  const T = Ve.utc(A.start).format("HH[h]mm"), F = Ve.utc(A.finish).format("HH[h]mm");
  return /* @__PURE__ */ fe.jsxs("div", { className: "day", children: [
    /* @__PURE__ */ fe.jsx("span", { children: w }),
    /* @__PURE__ */ fe.jsx("span", { className: "service", children: "Serviço" }),
    /* @__PURE__ */ fe.jsxs("span", { className: "service-time", children: [
      T,
      " - ",
      F
    ] }),
    /* @__PURE__ */ fe.jsxs("span", { className: "description", children: [
      A.description,
      "*"
    ] }),
    /* @__PURE__ */ fe.jsx("div", { className: "breaks", children: A.breaks.map((H, U) => {
      const $ = Ve.utc(H.start).format("HH[h]mm"), q = Ve.utc(H.finish).format("HH[h]mm");
      return /* @__PURE__ */ fe.jsxs("div", { className: "break-item", children: [
        /* @__PURE__ */ fe.jsx("span", { className: "break-item--label", children: MY[String(H.type)] }),
        /* @__PURE__ */ fe.jsxs("span", { className: "break-item--content", children: [
          $,
          " - ",
          q
        ] })
      ] }, U);
    }) })
  ] }, v);
}) }), Hj = () => {
  const s = Array.from({ length: 7 }).map(
    (u, h) => Ve().clone().subtract(7 - h, "days")
  );
  return /* @__PURE__ */ fe.jsxs("div", { className: "detailed-workday container", children: [
    /* @__PURE__ */ fe.jsxs("header", { className: "detailed-workday--header container row spacing", children: [
      /* @__PURE__ */ fe.jsxs("div", { className: "group rounded-box", children: [
        /* @__PURE__ */ fe.jsx("label", { className: "bg-primary", children: "Filtro" }),
        /* @__PURE__ */ fe.jsx(iS, { items: ["Semana", "Mês", "Ano"] })
      ] }),
      /* @__PURE__ */ fe.jsx("span", { children: "Intervalo de data: 08/08/2023 - 14/08/2023" })
    ] }),
    /* @__PURE__ */ fe.jsxs("div", { className: "detailed-workday--container", children: [
      /* @__PURE__ */ fe.jsxs("div", { className: "detailed-workday--item", children: [
        /* @__PURE__ */ fe.jsx("span", { className: "", style: { width: "10rem" } }),
        /* @__PURE__ */ fe.jsx("div", { className: "weekdays", children: s.map((u) => {
          const h = Ve(u).day();
          return /* @__PURE__ */ fe.jsx("span", { className: "", children: DY[h] });
        }) })
      ] }),
      LY.map((u, h) => /* @__PURE__ */ fe.jsxs("div", { className: "detailed-workday--item", children: [
        /* @__PURE__ */ fe.jsx("span", { children: u.agent.firstName }),
        /* @__PURE__ */ fe.jsx(
          OY,
          {
            data: u.period,
            lastSevenDays: s
          },
          h
        )
      ] }, h))
    ] })
  ] });
}, jj = ({ logo: s, items: u }) => /* @__PURE__ */ fe.jsxs("header", { className: "header", children: [
  s,
  u
] }), _Y = (s, u) => {
  var w, A, T, F;
  const v = s.currentTarget.childNodes[1].childNodes;
  switch (s.key) {
    case "ArrowDown": {
      if (u.current === v.length - 1)
        return;
      u.current += 1;
      const H = (A = (w = v[u.current]) == null ? void 0 : w.firstChild) == null ? void 0 : A.firstChild;
      H !== null && H.focus();
      break;
    }
    case "ArrowUp": {
      if (u.current === 2)
        return;
      u.current -= 1;
      const H = (F = (T = v[u.current]) == null ? void 0 : T.firstChild) == null ? void 0 : F.firstChild;
      H !== null && H.focus();
      break;
    }
    case " ": {
      const H = s.target;
      H instanceof HTMLAnchorElement && H.click();
    }
  }
}, CT = (s, u, h, v, w, A = 0, T, F) => {
  s.current === null || u.current === null || (v.route === h && s.current.classList.add("active"), s.current.classList.contains("active") && v.route !== h && s.current.classList.remove("active"), T || (u.current.innerHTML = `
      <div className="sidebar-tooltip-container">
        <span>${F(v.label)}</span>
      </div>
    `, u.current.style.opacity = "1", u.current.style.top = `calc(48px * ${w + A})`), s.current.style.top = `calc(48px * ${w + A})`);
}, PY = (s, u, h, v, w, A, T) => {
  var F;
  {
    if (u.current === null || h.current === null)
      return;
    let H = -1;
    w || (h.current.innerHTML = "", h.current.style.opacity = "0"), A.forEach((U, $) => {
      s + U.route === v && (H = $, T !== null && $ >= T && (H += A[T].submenus.length)), Object.hasOwnProperty.call(U, "submenus") && U.submenus.forEach((q, te) => {
        `${s}${U.route}${q.route}` === v && (T === $ ? H = $ + te + 1 : H = $);
      });
    }), (F = document.activeElement) == null || F.blur(), H > -1 && (u.current.style.top = `calc(48px * ${H})`, u.current.classList.add("active"));
  }
}, Uj = ({
  data: s,
  itemLink: u,
  onSettings: h,
  onLogout: v,
  prefix: w = "",
  pathname: A = ""
}) => {
  const T = hr(null), F = hr(null), H = hr(null), U = hr(3), [$, q] = wr(!1), [te, se] = wr(null);
  return /* @__PURE__ */ fe.jsxs(
    "aside",
    {
      className: "sidebar closed",
      ref: T,
      onKeyDown: (ae) => _Y(ae, U),
      children: [
        /* @__PURE__ */ fe.jsx(
          "button",
          {
            type: "button",
            className: "btn btn-square btn-ghost ring-info",
            onClick: () => {
              T.current !== null && (q((ae) => !ae), T.current.classList.toggle("closed"));
            },
            children: /* @__PURE__ */ fe.jsx(gi, { icon: "jam:menu", height: 32 })
          }
        ),
        /* @__PURE__ */ fe.jsxs(
          "ul",
          {
            className: "sidebar-container",
            onMouseLeave: () => PY(
              w,
              F,
              H,
              A,
              $,
              s,
              te
            ),
            children: [
              /* @__PURE__ */ fe.jsx("span", { ref: F, className: "sidebar-selector" }),
              /* @__PURE__ */ fe.jsx("div", { ref: H, className: "sidebar-tooltip" }),
              s.map((ae, ue) => /* @__PURE__ */ fe.jsxs(sE, { children: [
                /* @__PURE__ */ fe.jsxs(
                  "li",
                  {
                    className: "sidebar-item",
                    onMouseEnter: () => CT(
                      F,
                      H,
                      A,
                      ae,
                      te !== null && ue > te ? ue + s[te].submenus.length : ue,
                      0,
                      $,
                      Yr
                    ),
                    onClick: () => {
                      ae != null && ae.submenus && se(
                        (Re) => Re === ue ? null : ue
                      );
                    },
                    children: [
                      /* @__PURE__ */ fe.jsx("div", { className: "sidebar-item--icon", children: u({
                        icon: ae.icon,
                        label: Yr(`sidebar.${ae.label}`),
                        route: ae.route,
                        isOpen: $,
                        props: {
                          className: ae != null && ae.submenus ? "group" : "",
                          onClick: () => {
                            U.current = ue + 2, F.current && F.current.classList.toggle("active");
                          }
                        }
                      }) }),
                      (ae == null ? void 0 : ae.submenus) && /* @__PURE__ */ fe.jsxs("div", { className: "sidebar-item--submenu-handler", children: [
                        $ && /* @__PURE__ */ fe.jsx("span", { className: "sidebar-item--indicator", children: ae.submenus.length }),
                        /* @__PURE__ */ fe.jsx(
                          gi,
                          {
                            icon: "ic:round-arrow-right",
                            height: 24,
                            rotate: ue === te ? 45 : 0
                          }
                        )
                      ] })
                    ]
                  }
                ),
                (ae == null ? void 0 : ae.submenus) && ue === te && /* @__PURE__ */ fe.jsx("div", { className: "sidebar-submenu", children: ae.submenus.map((Re, Ne) => /* @__PURE__ */ fe.jsx(
                  "div",
                  {
                    className: "sidebar-submenu-item",
                    onMouseEnter: () => CT(
                      F,
                      H,
                      A,
                      Re,
                      ue,
                      Ne + 1,
                      $,
                      Yr
                    ),
                    children: u({
                      icon: Re.icon,
                      label: Yr(
                        `sidebar.${Re.label}`
                      ),
                      route: `${ae.route}${Re.route}`,
                      isOpen: $,
                      props: { className: "" }
                    })
                  },
                  Re.route
                )) })
              ] }, ue))
            ]
          }
        ),
        h && /* @__PURE__ */ fe.jsxs(
          "button",
          {
            type: "button",
            className: "sidebar-settings-action ring-info",
            onClick: h,
            children: [
              /* @__PURE__ */ fe.jsx(gi, { icon: "ph:gear-six-fill", height: 16 }),
              $ && /* @__PURE__ */ fe.jsx("span", { children: Yr("common.settings") })
            ]
          }
        ),
        v && /* @__PURE__ */ fe.jsxs(
          "button",
          {
            type: "button",
            className: "sidebar-exit-action ring-warning",
            onClick: v,
            children: [
              /* @__PURE__ */ fe.jsx(gi, { icon: "mingcute:exit-fill", height: 16 }),
              $ && /* @__PURE__ */ fe.jsx("span", { children: Yr("common.logout") })
            ]
          }
        )
      ]
    }
  );
};
var x1 = { exports: {} }, La = {}, wy = { exports: {} }, Ww = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var AT;
function NY() {
  return AT || (AT = 1, function(s) {
    function u(We, pt) {
      var ye = We.length;
      We.push(pt);
      e:
        for (; 0 < ye; ) {
          var je = ye - 1 >>> 1, Je = We[je];
          if (0 < w(Je, pt))
            We[je] = pt, We[ye] = Je, ye = je;
          else
            break e;
        }
    }
    function h(We) {
      return We.length === 0 ? null : We[0];
    }
    function v(We) {
      if (We.length === 0)
        return null;
      var pt = We[0], ye = We.pop();
      if (ye !== pt) {
        We[0] = ye;
        e:
          for (var je = 0, Je = We.length, kt = Je >>> 1; je < kt; ) {
            var At = 2 * (je + 1) - 1, jt = We[At], ot = At + 1, It = We[ot];
            if (0 > w(jt, ye))
              ot < Je && 0 > w(It, jt) ? (We[je] = It, We[ot] = ye, je = ot) : (We[je] = jt, We[At] = ye, je = At);
            else if (ot < Je && 0 > w(It, ye))
              We[je] = It, We[ot] = ye, je = ot;
            else
              break e;
          }
      }
      return pt;
    }
    function w(We, pt) {
      var ye = We.sortIndex - pt.sortIndex;
      return ye !== 0 ? ye : We.id - pt.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var A = performance;
      s.unstable_now = function() {
        return A.now();
      };
    } else {
      var T = Date, F = T.now();
      s.unstable_now = function() {
        return T.now() - F;
      };
    }
    var H = [], U = [], $ = 1, q = null, te = 3, se = !1, ae = !1, ue = !1, Re = typeof setTimeout == "function" ? setTimeout : null, Ne = typeof clearTimeout == "function" ? clearTimeout : null, Q = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function we(We) {
      for (var pt = h(U); pt !== null; ) {
        if (pt.callback === null)
          v(U);
        else if (pt.startTime <= We)
          v(U), pt.sortIndex = pt.expirationTime, u(H, pt);
        else
          break;
        pt = h(U);
      }
    }
    function Ee(We) {
      if (ue = !1, we(We), !ae)
        if (h(H) !== null)
          ae = !0, Mt(re);
        else {
          var pt = h(U);
          pt !== null && an(Ee, pt.startTime - We);
        }
    }
    function re(We, pt) {
      ae = !1, ue && (ue = !1, Ne(Qe), Qe = -1), se = !0;
      var ye = te;
      try {
        for (we(pt), q = h(H); q !== null && (!(q.expirationTime > pt) || We && !ft()); ) {
          var je = q.callback;
          if (typeof je == "function") {
            q.callback = null, te = q.priorityLevel;
            var Je = je(q.expirationTime <= pt);
            pt = s.unstable_now(), typeof Je == "function" ? q.callback = Je : q === h(H) && v(H), we(pt);
          } else
            v(H);
          q = h(H);
        }
        if (q !== null)
          var kt = !0;
        else {
          var At = h(U);
          At !== null && an(Ee, At.startTime - pt), kt = !1;
        }
        return kt;
      } finally {
        q = null, te = ye, se = !1;
      }
    }
    var ve = !1, Le = null, Qe = -1, Be = 5, Ge = -1;
    function ft() {
      return !(s.unstable_now() - Ge < Be);
    }
    function wt() {
      if (Le !== null) {
        var We = s.unstable_now();
        Ge = We;
        var pt = !0;
        try {
          pt = Le(!0, We);
        } finally {
          pt ? st() : (ve = !1, Le = null);
        }
      } else
        ve = !1;
    }
    var st;
    if (typeof Q == "function")
      st = function() {
        Q(wt);
      };
    else if (typeof MessageChannel < "u") {
      var it = new MessageChannel(), Ht = it.port2;
      it.port1.onmessage = wt, st = function() {
        Ht.postMessage(null);
      };
    } else
      st = function() {
        Re(wt, 0);
      };
    function Mt(We) {
      Le = We, ve || (ve = !0, st());
    }
    function an(We, pt) {
      Qe = Re(function() {
        We(s.unstable_now());
      }, pt);
    }
    s.unstable_IdlePriority = 5, s.unstable_ImmediatePriority = 1, s.unstable_LowPriority = 4, s.unstable_NormalPriority = 3, s.unstable_Profiling = null, s.unstable_UserBlockingPriority = 2, s.unstable_cancelCallback = function(We) {
      We.callback = null;
    }, s.unstable_continueExecution = function() {
      ae || se || (ae = !0, Mt(re));
    }, s.unstable_forceFrameRate = function(We) {
      0 > We || 125 < We ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Be = 0 < We ? Math.floor(1e3 / We) : 5;
    }, s.unstable_getCurrentPriorityLevel = function() {
      return te;
    }, s.unstable_getFirstCallbackNode = function() {
      return h(H);
    }, s.unstable_next = function(We) {
      switch (te) {
        case 1:
        case 2:
        case 3:
          var pt = 3;
          break;
        default:
          pt = te;
      }
      var ye = te;
      te = pt;
      try {
        return We();
      } finally {
        te = ye;
      }
    }, s.unstable_pauseExecution = function() {
    }, s.unstable_requestPaint = function() {
    }, s.unstable_runWithPriority = function(We, pt) {
      switch (We) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          We = 3;
      }
      var ye = te;
      te = We;
      try {
        return pt();
      } finally {
        te = ye;
      }
    }, s.unstable_scheduleCallback = function(We, pt, ye) {
      var je = s.unstable_now();
      switch (typeof ye == "object" && ye !== null ? (ye = ye.delay, ye = typeof ye == "number" && 0 < ye ? je + ye : je) : ye = je, We) {
        case 1:
          var Je = -1;
          break;
        case 2:
          Je = 250;
          break;
        case 5:
          Je = 1073741823;
          break;
        case 4:
          Je = 1e4;
          break;
        default:
          Je = 5e3;
      }
      return Je = ye + Je, We = { id: $++, callback: pt, priorityLevel: We, startTime: ye, expirationTime: Je, sortIndex: -1 }, ye > je ? (We.sortIndex = ye, u(U, We), h(H) === null && We === h(U) && (ue ? (Ne(Qe), Qe = -1) : ue = !0, an(Ee, ye - je))) : (We.sortIndex = Je, u(H, We), ae || se || (ae = !0, Mt(re))), We;
    }, s.unstable_shouldYield = ft, s.unstable_wrapCallback = function(We) {
      var pt = te;
      return function() {
        var ye = te;
        te = pt;
        try {
          return We.apply(this, arguments);
        } finally {
          te = ye;
        }
      };
    };
  }(Ww)), Ww;
}
var Xw = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var TT;
function zY() {
  return TT || (TT = 1, function(s) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var u = !1, h = !1, v = 5;
      function w(Ke, Rt) {
        var tn = Ke.length;
        Ke.push(Rt), F(Ke, Rt, tn);
      }
      function A(Ke) {
        return Ke.length === 0 ? null : Ke[0];
      }
      function T(Ke) {
        if (Ke.length === 0)
          return null;
        var Rt = Ke[0], tn = Ke.pop();
        return tn !== Rt && (Ke[0] = tn, H(Ke, tn, 0)), Rt;
      }
      function F(Ke, Rt, tn) {
        for (var bn = tn; bn > 0; ) {
          var Un = bn - 1 >>> 1, pr = Ke[Un];
          if (U(pr, Rt) > 0)
            Ke[Un] = Rt, Ke[bn] = pr, bn = Un;
          else
            return;
        }
      }
      function H(Ke, Rt, tn) {
        for (var bn = tn, Un = Ke.length, pr = Un >>> 1; bn < pr; ) {
          var $n = (bn + 1) * 2 - 1, ri = Ke[$n], Ln = $n + 1, gr = Ke[Ln];
          if (U(ri, Rt) < 0)
            Ln < Un && U(gr, ri) < 0 ? (Ke[bn] = gr, Ke[Ln] = Rt, bn = Ln) : (Ke[bn] = ri, Ke[$n] = Rt, bn = $n);
          else if (Ln < Un && U(gr, Rt) < 0)
            Ke[bn] = gr, Ke[Ln] = Rt, bn = Ln;
          else
            return;
        }
      }
      function U(Ke, Rt) {
        var tn = Ke.sortIndex - Rt.sortIndex;
        return tn !== 0 ? tn : Ke.id - Rt.id;
      }
      var $ = 1, q = 2, te = 3, se = 4, ae = 5;
      function ue(Ke, Rt) {
      }
      var Re = typeof performance == "object" && typeof performance.now == "function";
      if (Re) {
        var Ne = performance;
        s.unstable_now = function() {
          return Ne.now();
        };
      } else {
        var Q = Date, we = Q.now();
        s.unstable_now = function() {
          return Q.now() - we;
        };
      }
      var Ee = 1073741823, re = -1, ve = 250, Le = 5e3, Qe = 1e4, Be = Ee, Ge = [], ft = [], wt = 1, st = null, it = te, Ht = !1, Mt = !1, an = !1, We = typeof setTimeout == "function" ? setTimeout : null, pt = typeof clearTimeout == "function" ? clearTimeout : null, ye = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function je(Ke) {
        for (var Rt = A(ft); Rt !== null; ) {
          if (Rt.callback === null)
            T(ft);
          else if (Rt.startTime <= Ke)
            T(ft), Rt.sortIndex = Rt.expirationTime, w(Ge, Rt);
          else
            return;
          Rt = A(ft);
        }
      }
      function Je(Ke) {
        if (an = !1, je(Ke), !Mt)
          if (A(Ge) !== null)
            Mt = !0, ti(kt);
          else {
            var Rt = A(ft);
            Rt !== null && ir(Je, Rt.startTime - Ke);
          }
      }
      function kt(Ke, Rt) {
        Mt = !1, an && (an = !1, ni()), Ht = !0;
        var tn = it;
        try {
          var bn;
          if (!h)
            return At(Ke, Rt);
        } finally {
          st = null, it = tn, Ht = !1;
        }
      }
      function At(Ke, Rt) {
        var tn = Rt;
        for (je(tn), st = A(Ge); st !== null && !u && !(st.expirationTime > tn && (!Ke || qi())); ) {
          var bn = st.callback;
          if (typeof bn == "function") {
            st.callback = null, it = st.priorityLevel;
            var Un = st.expirationTime <= tn, pr = bn(Un);
            tn = s.unstable_now(), typeof pr == "function" ? st.callback = pr : st === A(Ge) && T(Ge), je(tn);
          } else
            T(Ge);
          st = A(Ge);
        }
        if (st !== null)
          return !0;
        var $n = A(ft);
        return $n !== null && ir(Je, $n.startTime - tn), !1;
      }
      function jt(Ke, Rt) {
        switch (Ke) {
          case $:
          case q:
          case te:
          case se:
          case ae:
            break;
          default:
            Ke = te;
        }
        var tn = it;
        it = Ke;
        try {
          return Rt();
        } finally {
          it = tn;
        }
      }
      function ot(Ke) {
        var Rt;
        switch (it) {
          case $:
          case q:
          case te:
            Rt = te;
            break;
          default:
            Rt = it;
            break;
        }
        var tn = it;
        it = Rt;
        try {
          return Ke();
        } finally {
          it = tn;
        }
      }
      function It(Ke) {
        var Rt = it;
        return function() {
          var tn = it;
          it = Rt;
          try {
            return Ke.apply(this, arguments);
          } finally {
            it = tn;
          }
        };
      }
      function Et(Ke, Rt, tn) {
        var bn = s.unstable_now(), Un;
        if (typeof tn == "object" && tn !== null) {
          var pr = tn.delay;
          typeof pr == "number" && pr > 0 ? Un = bn + pr : Un = bn;
        } else
          Un = bn;
        var $n;
        switch (Ke) {
          case $:
            $n = re;
            break;
          case q:
            $n = ve;
            break;
          case ae:
            $n = Be;
            break;
          case se:
            $n = Qe;
            break;
          case te:
          default:
            $n = Le;
            break;
        }
        var ri = Un + $n, Ln = {
          id: wt++,
          callback: Rt,
          priorityLevel: Ke,
          startTime: Un,
          expirationTime: ri,
          sortIndex: -1
        };
        return Un > bn ? (Ln.sortIndex = Un, w(ft, Ln), A(Ge) === null && Ln === A(ft) && (an ? ni() : an = !0, ir(Je, Un - bn))) : (Ln.sortIndex = ri, w(Ge, Ln), !Mt && !Ht && (Mt = !0, ti(kt))), Ln;
      }
      function Ut() {
      }
      function Bt() {
        !Mt && !Ht && (Mt = !0, ti(kt));
      }
      function vn() {
        return A(Ge);
      }
      function Ze(Ke) {
        Ke.callback = null;
      }
      function pn() {
        return it;
      }
      var jn = !1, rr = null, Lr = -1, Mr = v, ei = -1;
      function qi() {
        var Ke = s.unstable_now() - ei;
        return !(Ke < Mr);
      }
      function Oa() {
      }
      function ca(Ke) {
        if (Ke < 0 || Ke > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Ke > 0 ? Mr = Math.floor(1e3 / Ke) : Mr = v;
      }
      var Zi = function() {
        if (rr !== null) {
          var Ke = s.unstable_now();
          ei = Ke;
          var Rt = !0, tn = !0;
          try {
            tn = rr(Rt, Ke);
          } finally {
            tn ? mi() : (jn = !1, rr = null);
          }
        } else
          jn = !1;
      }, mi;
      if (typeof ye == "function")
        mi = function() {
          ye(Zi);
        };
      else if (typeof MessageChannel < "u") {
        var da = new MessageChannel(), yi = da.port2;
        da.port1.onmessage = Zi, mi = function() {
          yi.postMessage(null);
        };
      } else
        mi = function() {
          We(Zi, 0);
        };
      function ti(Ke) {
        rr = Ke, jn || (jn = !0, mi());
      }
      function ir(Ke, Rt) {
        Lr = We(function() {
          Ke(s.unstable_now());
        }, Rt);
      }
      function ni() {
        pt(Lr), Lr = -1;
      }
      var _a = Oa, Qi = null;
      s.unstable_IdlePriority = ae, s.unstable_ImmediatePriority = $, s.unstable_LowPriority = se, s.unstable_NormalPriority = te, s.unstable_Profiling = Qi, s.unstable_UserBlockingPriority = q, s.unstable_cancelCallback = Ze, s.unstable_continueExecution = Bt, s.unstable_forceFrameRate = ca, s.unstable_getCurrentPriorityLevel = pn, s.unstable_getFirstCallbackNode = vn, s.unstable_next = ot, s.unstable_pauseExecution = Ut, s.unstable_requestPaint = _a, s.unstable_runWithPriority = jt, s.unstable_scheduleCallback = Et, s.unstable_shouldYield = qi, s.unstable_wrapCallback = It, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(Xw)), Xw;
}
var ET;
function yR() {
  return ET || (ET = 1, process.env.NODE_ENV === "production" ? wy.exports = NY() : wy.exports = zY()), wy.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var RT;
function IY() {
  if (RT)
    return La;
  RT = 1;
  var s = vi, u = yR();
  function h(a) {
    for (var l = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, m = 1; m < arguments.length; m++)
      l += "&args[]=" + encodeURIComponent(arguments[m]);
    return "Minified React error #" + a + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var v = /* @__PURE__ */ new Set(), w = {};
  function A(a, l) {
    T(a, l), T(a + "Capture", l);
  }
  function T(a, l) {
    for (w[a] = l, a = 0; a < l.length; a++)
      v.add(l[a]);
  }
  var F = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), H = Object.prototype.hasOwnProperty, U = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, $ = {}, q = {};
  function te(a) {
    return H.call(q, a) ? !0 : H.call($, a) ? !1 : U.test(a) ? q[a] = !0 : ($[a] = !0, !1);
  }
  function se(a, l, m, k) {
    if (m !== null && m.type === 0)
      return !1;
    switch (typeof l) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return k ? !1 : m !== null ? !m.acceptsBooleans : (a = a.toLowerCase().slice(0, 5), a !== "data-" && a !== "aria-");
      default:
        return !1;
    }
  }
  function ae(a, l, m, k) {
    if (l === null || typeof l > "u" || se(a, l, m, k))
      return !0;
    if (k)
      return !1;
    if (m !== null)
      switch (m.type) {
        case 3:
          return !l;
        case 4:
          return l === !1;
        case 5:
          return isNaN(l);
        case 6:
          return isNaN(l) || 1 > l;
      }
    return !1;
  }
  function ue(a, l, m, k, D, z, G) {
    this.acceptsBooleans = l === 2 || l === 3 || l === 4, this.attributeName = k, this.attributeNamespace = D, this.mustUseProperty = m, this.propertyName = a, this.type = l, this.sanitizeURL = z, this.removeEmptyString = G;
  }
  var Re = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    Re[a] = new ue(a, 0, !1, a, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
    var l = a[0];
    Re[l] = new ue(l, 1, !1, a[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
    Re[a] = new ue(a, 2, !1, a.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
    Re[a] = new ue(a, 2, !1, a, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    Re[a] = new ue(a, 3, !1, a.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(a) {
    Re[a] = new ue(a, 3, !0, a, null, !1, !1);
  }), ["capture", "download"].forEach(function(a) {
    Re[a] = new ue(a, 4, !1, a, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(a) {
    Re[a] = new ue(a, 6, !1, a, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(a) {
    Re[a] = new ue(a, 5, !1, a.toLowerCase(), null, !1, !1);
  });
  var Ne = /[\-:]([a-z])/g;
  function Q(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var l = a.replace(
      Ne,
      Q
    );
    Re[l] = new ue(l, 1, !1, a, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var l = a.replace(Ne, Q);
    Re[l] = new ue(l, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
    var l = a.replace(Ne, Q);
    Re[l] = new ue(l, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(a) {
    Re[a] = new ue(a, 1, !1, a.toLowerCase(), null, !1, !1);
  }), Re.xlinkHref = new ue("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(a) {
    Re[a] = new ue(a, 1, !1, a.toLowerCase(), null, !0, !0);
  });
  function we(a, l, m, k) {
    var D = Re.hasOwnProperty(l) ? Re[l] : null;
    (D !== null ? D.type !== 0 : k || !(2 < l.length) || l[0] !== "o" && l[0] !== "O" || l[1] !== "n" && l[1] !== "N") && (ae(l, m, D, k) && (m = null), k || D === null ? te(l) && (m === null ? a.removeAttribute(l) : a.setAttribute(l, "" + m)) : D.mustUseProperty ? a[D.propertyName] = m === null ? D.type === 3 ? !1 : "" : m : (l = D.attributeName, k = D.attributeNamespace, m === null ? a.removeAttribute(l) : (D = D.type, m = D === 3 || D === 4 && m === !0 ? "" : "" + m, k ? a.setAttributeNS(k, l, m) : a.setAttribute(l, m))));
  }
  var Ee = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, re = Symbol.for("react.element"), ve = Symbol.for("react.portal"), Le = Symbol.for("react.fragment"), Qe = Symbol.for("react.strict_mode"), Be = Symbol.for("react.profiler"), Ge = Symbol.for("react.provider"), ft = Symbol.for("react.context"), wt = Symbol.for("react.forward_ref"), st = Symbol.for("react.suspense"), it = Symbol.for("react.suspense_list"), Ht = Symbol.for("react.memo"), Mt = Symbol.for("react.lazy"), an = Symbol.for("react.offscreen"), We = Symbol.iterator;
  function pt(a) {
    return a === null || typeof a != "object" ? null : (a = We && a[We] || a["@@iterator"], typeof a == "function" ? a : null);
  }
  var ye = Object.assign, je;
  function Je(a) {
    if (je === void 0)
      try {
        throw Error();
      } catch (m) {
        var l = m.stack.trim().match(/\n( *(at )?)/);
        je = l && l[1] || "";
      }
    return `
` + je + a;
  }
  var kt = !1;
  function At(a, l) {
    if (!a || kt)
      return "";
    kt = !0;
    var m = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (l)
        if (l = function() {
          throw Error();
        }, Object.defineProperty(l.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(l, []);
          } catch (Te) {
            var k = Te;
          }
          Reflect.construct(a, [], l);
        } else {
          try {
            l.call();
          } catch (Te) {
            k = Te;
          }
          a.call(l.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Te) {
          k = Te;
        }
        a();
      }
    } catch (Te) {
      if (Te && k && typeof Te.stack == "string") {
        for (var D = Te.stack.split(`
`), z = k.stack.split(`
`), G = D.length - 1, ie = z.length - 1; 1 <= G && 0 <= ie && D[G] !== z[ie]; )
          ie--;
        for (; 1 <= G && 0 <= ie; G--, ie--)
          if (D[G] !== z[ie]) {
            if (G !== 1 || ie !== 1)
              do
                if (G--, ie--, 0 > ie || D[G] !== z[ie]) {
                  var ce = `
` + D[G].replace(" at new ", " at ");
                  return a.displayName && ce.includes("<anonymous>") && (ce = ce.replace("<anonymous>", a.displayName)), ce;
                }
              while (1 <= G && 0 <= ie);
            break;
          }
      }
    } finally {
      kt = !1, Error.prepareStackTrace = m;
    }
    return (a = a ? a.displayName || a.name : "") ? Je(a) : "";
  }
  function jt(a) {
    switch (a.tag) {
      case 5:
        return Je(a.type);
      case 16:
        return Je("Lazy");
      case 13:
        return Je("Suspense");
      case 19:
        return Je("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a = At(a.type, !1), a;
      case 11:
        return a = At(a.type.render, !1), a;
      case 1:
        return a = At(a.type, !0), a;
      default:
        return "";
    }
  }
  function ot(a) {
    if (a == null)
      return null;
    if (typeof a == "function")
      return a.displayName || a.name || null;
    if (typeof a == "string")
      return a;
    switch (a) {
      case Le:
        return "Fragment";
      case ve:
        return "Portal";
      case Be:
        return "Profiler";
      case Qe:
        return "StrictMode";
      case st:
        return "Suspense";
      case it:
        return "SuspenseList";
    }
    if (typeof a == "object")
      switch (a.$$typeof) {
        case ft:
          return (a.displayName || "Context") + ".Consumer";
        case Ge:
          return (a._context.displayName || "Context") + ".Provider";
        case wt:
          var l = a.render;
          return a = a.displayName, a || (a = l.displayName || l.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
        case Ht:
          return l = a.displayName || null, l !== null ? l : ot(a.type) || "Memo";
        case Mt:
          l = a._payload, a = a._init;
          try {
            return ot(a(l));
          } catch {
          }
      }
    return null;
  }
  function It(a) {
    var l = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (l.displayName || "Context") + ".Consumer";
      case 10:
        return (l._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a = l.render, a = a.displayName || a.name || "", l.displayName || (a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return l;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return ot(l);
      case 8:
        return l === Qe ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof l == "function")
          return l.displayName || l.name || null;
        if (typeof l == "string")
          return l;
    }
    return null;
  }
  function Et(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Ut(a) {
    var l = a.type;
    return (a = a.nodeName) && a.toLowerCase() === "input" && (l === "checkbox" || l === "radio");
  }
  function Bt(a) {
    var l = Ut(a) ? "checked" : "value", m = Object.getOwnPropertyDescriptor(a.constructor.prototype, l), k = "" + a[l];
    if (!a.hasOwnProperty(l) && typeof m < "u" && typeof m.get == "function" && typeof m.set == "function") {
      var D = m.get, z = m.set;
      return Object.defineProperty(a, l, { configurable: !0, get: function() {
        return D.call(this);
      }, set: function(G) {
        k = "" + G, z.call(this, G);
      } }), Object.defineProperty(a, l, { enumerable: m.enumerable }), { getValue: function() {
        return k;
      }, setValue: function(G) {
        k = "" + G;
      }, stopTracking: function() {
        a._valueTracker = null, delete a[l];
      } };
    }
  }
  function vn(a) {
    a._valueTracker || (a._valueTracker = Bt(a));
  }
  function Ze(a) {
    if (!a)
      return !1;
    var l = a._valueTracker;
    if (!l)
      return !0;
    var m = l.getValue(), k = "";
    return a && (k = Ut(a) ? a.checked ? "true" : "false" : a.value), a = k, a !== m ? (l.setValue(a), !0) : !1;
  }
  function pn(a) {
    if (a = a || (typeof document < "u" ? document : void 0), typeof a > "u")
      return null;
    try {
      return a.activeElement || a.body;
    } catch {
      return a.body;
    }
  }
  function jn(a, l) {
    var m = l.checked;
    return ye({}, l, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: m ?? a._wrapperState.initialChecked });
  }
  function rr(a, l) {
    var m = l.defaultValue == null ? "" : l.defaultValue, k = l.checked != null ? l.checked : l.defaultChecked;
    m = Et(l.value != null ? l.value : m), a._wrapperState = { initialChecked: k, initialValue: m, controlled: l.type === "checkbox" || l.type === "radio" ? l.checked != null : l.value != null };
  }
  function Lr(a, l) {
    l = l.checked, l != null && we(a, "checked", l, !1);
  }
  function Mr(a, l) {
    Lr(a, l);
    var m = Et(l.value), k = l.type;
    if (m != null)
      k === "number" ? (m === 0 && a.value === "" || a.value != m) && (a.value = "" + m) : a.value !== "" + m && (a.value = "" + m);
    else if (k === "submit" || k === "reset") {
      a.removeAttribute("value");
      return;
    }
    l.hasOwnProperty("value") ? qi(a, l.type, m) : l.hasOwnProperty("defaultValue") && qi(a, l.type, Et(l.defaultValue)), l.checked == null && l.defaultChecked != null && (a.defaultChecked = !!l.defaultChecked);
  }
  function ei(a, l, m) {
    if (l.hasOwnProperty("value") || l.hasOwnProperty("defaultValue")) {
      var k = l.type;
      if (!(k !== "submit" && k !== "reset" || l.value !== void 0 && l.value !== null))
        return;
      l = "" + a._wrapperState.initialValue, m || l === a.value || (a.value = l), a.defaultValue = l;
    }
    m = a.name, m !== "" && (a.name = ""), a.defaultChecked = !!a._wrapperState.initialChecked, m !== "" && (a.name = m);
  }
  function qi(a, l, m) {
    (l !== "number" || pn(a.ownerDocument) !== a) && (m == null ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + m && (a.defaultValue = "" + m));
  }
  var Oa = Array.isArray;
  function ca(a, l, m, k) {
    if (a = a.options, l) {
      l = {};
      for (var D = 0; D < m.length; D++)
        l["$" + m[D]] = !0;
      for (m = 0; m < a.length; m++)
        D = l.hasOwnProperty("$" + a[m].value), a[m].selected !== D && (a[m].selected = D), D && k && (a[m].defaultSelected = !0);
    } else {
      for (m = "" + Et(m), l = null, D = 0; D < a.length; D++) {
        if (a[D].value === m) {
          a[D].selected = !0, k && (a[D].defaultSelected = !0);
          return;
        }
        l !== null || a[D].disabled || (l = a[D]);
      }
      l !== null && (l.selected = !0);
    }
  }
  function Zi(a, l) {
    if (l.dangerouslySetInnerHTML != null)
      throw Error(h(91));
    return ye({}, l, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
  }
  function mi(a, l) {
    var m = l.value;
    if (m == null) {
      if (m = l.children, l = l.defaultValue, m != null) {
        if (l != null)
          throw Error(h(92));
        if (Oa(m)) {
          if (1 < m.length)
            throw Error(h(93));
          m = m[0];
        }
        l = m;
      }
      l == null && (l = ""), m = l;
    }
    a._wrapperState = { initialValue: Et(m) };
  }
  function da(a, l) {
    var m = Et(l.value), k = Et(l.defaultValue);
    m != null && (m = "" + m, m !== a.value && (a.value = m), l.defaultValue == null && a.defaultValue !== m && (a.defaultValue = m)), k != null && (a.defaultValue = "" + k);
  }
  function yi(a) {
    var l = a.textContent;
    l === a._wrapperState.initialValue && l !== "" && l !== null && (a.value = l);
  }
  function ti(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function ir(a, l) {
    return a == null || a === "http://www.w3.org/1999/xhtml" ? ti(l) : a === "http://www.w3.org/2000/svg" && l === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a;
  }
  var ni, _a = function(a) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(l, m, k, D) {
      MSApp.execUnsafeLocalFunction(function() {
        return a(l, m, k, D);
      });
    } : a;
  }(function(a, l) {
    if (a.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in a)
      a.innerHTML = l;
    else {
      for (ni = ni || document.createElement("div"), ni.innerHTML = "<svg>" + l.valueOf().toString() + "</svg>", l = ni.firstChild; a.firstChild; )
        a.removeChild(a.firstChild);
      for (; l.firstChild; )
        a.appendChild(l.firstChild);
    }
  });
  function Qi(a, l) {
    if (l) {
      var m = a.firstChild;
      if (m && m === a.lastChild && m.nodeType === 3) {
        m.nodeValue = l;
        return;
      }
    }
    a.textContent = l;
  }
  var Ke = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Rt = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Ke).forEach(function(a) {
    Rt.forEach(function(l) {
      l = l + a.charAt(0).toUpperCase() + a.substring(1), Ke[l] = Ke[a];
    });
  });
  function tn(a, l, m) {
    return l == null || typeof l == "boolean" || l === "" ? "" : m || typeof l != "number" || l === 0 || Ke.hasOwnProperty(a) && Ke[a] ? ("" + l).trim() : l + "px";
  }
  function bn(a, l) {
    a = a.style;
    for (var m in l)
      if (l.hasOwnProperty(m)) {
        var k = m.indexOf("--") === 0, D = tn(m, l[m], k);
        m === "float" && (m = "cssFloat"), k ? a.setProperty(m, D) : a[m] = D;
      }
  }
  var Un = ye({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function pr(a, l) {
    if (l) {
      if (Un[a] && (l.children != null || l.dangerouslySetInnerHTML != null))
        throw Error(h(137, a));
      if (l.dangerouslySetInnerHTML != null) {
        if (l.children != null)
          throw Error(h(60));
        if (typeof l.dangerouslySetInnerHTML != "object" || !("__html" in l.dangerouslySetInnerHTML))
          throw Error(h(61));
      }
      if (l.style != null && typeof l.style != "object")
        throw Error(h(62));
    }
  }
  function $n(a, l) {
    if (a.indexOf("-") === -1)
      return typeof l.is == "string";
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var ri = null;
  function Ln(a) {
    return a = a.target || a.srcElement || window, a.correspondingUseElement && (a = a.correspondingUseElement), a.nodeType === 3 ? a.parentNode : a;
  }
  var gr = null, kn = null, Cn = null;
  function us(a) {
    if (a = qu(a)) {
      if (typeof gr != "function")
        throw Error(h(280));
      var l = a.stateNode;
      l && (l = _t(l), gr(a.stateNode, a.type, l));
    }
  }
  function cs(a) {
    kn ? Cn ? Cn.push(a) : Cn = [a] : kn = a;
  }
  function ds() {
    if (kn) {
      var a = kn, l = Cn;
      if (Cn = kn = null, us(a), l)
        for (a = 0; a < l.length; a++)
          us(l[a]);
    }
  }
  function Xs(a, l) {
    return a(l);
  }
  function Ll() {
  }
  var fs = !1;
  function Vs(a, l, m) {
    if (fs)
      return a(l, m);
    fs = !0;
    try {
      return Xs(a, l, m);
    } finally {
      fs = !1, (kn !== null || Cn !== null) && (Ll(), ds());
    }
  }
  function hs(a, l) {
    var m = a.stateNode;
    if (m === null)
      return null;
    var k = _t(m);
    if (k === null)
      return null;
    m = k[l];
    e:
      switch (l) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (k = !k.disabled) || (a = a.type, k = !(a === "button" || a === "input" || a === "select" || a === "textarea")), a = !k;
          break e;
        default:
          a = !1;
      }
    if (a)
      return null;
    if (m && typeof m != "function")
      throw Error(h(231, l, typeof m));
    return m;
  }
  var Gs = !1;
  if (F)
    try {
      var Di = {};
      Object.defineProperty(Di, "passive", { get: function() {
        Gs = !0;
      } }), window.addEventListener("test", Di, Di), window.removeEventListener("test", Di, Di);
    } catch {
      Gs = !1;
    }
  function Pa(a, l, m, k, D, z, G, ie, ce) {
    var Te = Array.prototype.slice.call(arguments, 3);
    try {
      l.apply(m, Te);
    } catch (He) {
      this.onError(He);
    }
  }
  var Hr = !1, xi = null, ii = !1, le = null, Ye = { onError: function(a) {
    Hr = !0, xi = a;
  } };
  function et(a, l, m, k, D, z, G, ie, ce) {
    Hr = !1, xi = null, Pa.apply(Ye, arguments);
  }
  function Dt(a, l, m, k, D, z, G, ie, ce) {
    if (et.apply(this, arguments), Hr) {
      if (Hr) {
        var Te = xi;
        Hr = !1, xi = null;
      } else
        throw Error(h(198));
      ii || (ii = !0, le = Te);
    }
  }
  function qt(a) {
    var l = a, m = a;
    if (a.alternate)
      for (; l.return; )
        l = l.return;
    else {
      a = l;
      do
        l = a, l.flags & 4098 && (m = l.return), a = l.return;
      while (a);
    }
    return l.tag === 3 ? m : null;
  }
  function cn(a) {
    if (a.tag === 13) {
      var l = a.memoizedState;
      if (l === null && (a = a.alternate, a !== null && (l = a.memoizedState)), l !== null)
        return l.dehydrated;
    }
    return null;
  }
  function Zt(a) {
    if (qt(a) !== a)
      throw Error(h(188));
  }
  function Ot(a) {
    var l = a.alternate;
    if (!l) {
      if (l = qt(a), l === null)
        throw Error(h(188));
      return l !== a ? null : a;
    }
    for (var m = a, k = l; ; ) {
      var D = m.return;
      if (D === null)
        break;
      var z = D.alternate;
      if (z === null) {
        if (k = D.return, k !== null) {
          m = k;
          continue;
        }
        break;
      }
      if (D.child === z.child) {
        for (z = D.child; z; ) {
          if (z === m)
            return Zt(D), a;
          if (z === k)
            return Zt(D), l;
          z = z.sibling;
        }
        throw Error(h(188));
      }
      if (m.return !== k.return)
        m = D, k = z;
      else {
        for (var G = !1, ie = D.child; ie; ) {
          if (ie === m) {
            G = !0, m = D, k = z;
            break;
          }
          if (ie === k) {
            G = !0, k = D, m = z;
            break;
          }
          ie = ie.sibling;
        }
        if (!G) {
          for (ie = z.child; ie; ) {
            if (ie === m) {
              G = !0, m = z, k = D;
              break;
            }
            if (ie === k) {
              G = !0, k = z, m = D;
              break;
            }
            ie = ie.sibling;
          }
          if (!G)
            throw Error(h(189));
        }
      }
      if (m.alternate !== k)
        throw Error(h(190));
    }
    if (m.tag !== 3)
      throw Error(h(188));
    return m.stateNode.current === m ? a : l;
  }
  function ar(a) {
    return a = Ot(a), a !== null ? Yn(a) : null;
  }
  function Yn(a) {
    if (a.tag === 5 || a.tag === 6)
      return a;
    for (a = a.child; a !== null; ) {
      var l = Yn(a);
      if (l !== null)
        return l;
      a = a.sibling;
    }
    return null;
  }
  var B = u.unstable_scheduleCallback, t = u.unstable_cancelCallback, n = u.unstable_shouldYield, i = u.unstable_requestPaint, o = u.unstable_now, d = u.unstable_getCurrentPriorityLevel, f = u.unstable_ImmediatePriority, p = u.unstable_UserBlockingPriority, y = u.unstable_NormalPriority, S = u.unstable_LowPriority, C = u.unstable_IdlePriority, E = null, L = null;
  function O(a) {
    if (L && typeof L.onCommitFiberRoot == "function")
      try {
        L.onCommitFiberRoot(E, a, void 0, (a.current.flags & 128) === 128);
      } catch {
      }
  }
  var P = Math.clz32 ? Math.clz32 : V, I = Math.log, j = Math.LN2;
  function V(a) {
    return a >>>= 0, a === 0 ? 32 : 31 - (I(a) / j | 0) | 0;
  }
  var Z = 64, b = 4194304;
  function M(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function N(a, l) {
    var m = a.pendingLanes;
    if (m === 0)
      return 0;
    var k = 0, D = a.suspendedLanes, z = a.pingedLanes, G = m & 268435455;
    if (G !== 0) {
      var ie = G & ~D;
      ie !== 0 ? k = M(ie) : (z &= G, z !== 0 && (k = M(z)));
    } else
      G = m & ~D, G !== 0 ? k = M(G) : z !== 0 && (k = M(z));
    if (k === 0)
      return 0;
    if (l !== 0 && l !== k && !(l & D) && (D = k & -k, z = l & -l, D >= z || D === 16 && (z & 4194240) !== 0))
      return l;
    if (k & 4 && (k |= m & 16), l = a.entangledLanes, l !== 0)
      for (a = a.entanglements, l &= k; 0 < l; )
        m = 31 - P(l), D = 1 << m, k |= a[m], l &= ~D;
    return k;
  }
  function X(a, l) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return l + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function K(a, l) {
    for (var m = a.suspendedLanes, k = a.pingedLanes, D = a.expirationTimes, z = a.pendingLanes; 0 < z; ) {
      var G = 31 - P(z), ie = 1 << G, ce = D[G];
      ce === -1 ? (!(ie & m) || ie & k) && (D[G] = X(ie, l)) : ce <= l && (a.expiredLanes |= ie), z &= ~ie;
    }
  }
  function ee(a) {
    return a = a.pendingLanes & -1073741825, a !== 0 ? a : a & 1073741824 ? 1073741824 : 0;
  }
  function oe() {
    var a = Z;
    return Z <<= 1, !(Z & 4194240) && (Z = 64), a;
  }
  function de(a) {
    for (var l = [], m = 0; 31 > m; m++)
      l.push(a);
    return l;
  }
  function ke(a, l, m) {
    a.pendingLanes |= l, l !== 536870912 && (a.suspendedLanes = 0, a.pingedLanes = 0), a = a.eventTimes, l = 31 - P(l), a[l] = m;
  }
  function _e(a, l) {
    var m = a.pendingLanes & ~l;
    a.pendingLanes = l, a.suspendedLanes = 0, a.pingedLanes = 0, a.expiredLanes &= l, a.mutableReadLanes &= l, a.entangledLanes &= l, l = a.entanglements;
    var k = a.eventTimes;
    for (a = a.expirationTimes; 0 < m; ) {
      var D = 31 - P(m), z = 1 << D;
      l[D] = 0, k[D] = -1, a[D] = -1, m &= ~z;
    }
  }
  function Me(a, l) {
    var m = a.entangledLanes |= l;
    for (a = a.entanglements; m; ) {
      var k = 31 - P(m), D = 1 << k;
      D & l | a[k] & l && (a[k] |= l), m &= ~D;
    }
  }
  var Ie = 0;
  function rt(a) {
    return a &= -a, 1 < a ? 4 < a ? a & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var Qt, Kt, mt, Mn, zn, gt = !1, jr = [], Dn = null, ai = null, si = null, vr = /* @__PURE__ */ new Map(), ln = /* @__PURE__ */ new Map(), wn = [], lx = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Na(a, l) {
    switch (a) {
      case "focusin":
      case "focusout":
        Dn = null;
        break;
      case "dragenter":
      case "dragleave":
        ai = null;
        break;
      case "mouseover":
      case "mouseout":
        si = null;
        break;
      case "pointerover":
      case "pointerout":
        vr.delete(l.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        ln.delete(l.pointerId);
    }
  }
  function oi(a, l, m, k, D, z) {
    return a === null || a.nativeEvent !== z ? (a = { blockedOn: l, domEventName: m, eventSystemFlags: k, nativeEvent: z, targetContainers: [D] }, l !== null && (l = qu(l), l !== null && Kt(l)), a) : (a.eventSystemFlags |= k, l = a.targetContainers, D !== null && l.indexOf(D) === -1 && l.push(D), a);
  }
  function $s(a, l, m, k, D) {
    switch (l) {
      case "focusin":
        return Dn = oi(Dn, a, l, m, k, D), !0;
      case "dragenter":
        return ai = oi(ai, a, l, m, k, D), !0;
      case "mouseover":
        return si = oi(si, a, l, m, k, D), !0;
      case "pointerover":
        var z = D.pointerId;
        return vr.set(z, oi(vr.get(z) || null, a, l, m, k, D)), !0;
      case "gotpointercapture":
        return z = D.pointerId, ln.set(z, oi(ln.get(z) || null, a, l, m, k, D)), !0;
    }
    return !1;
  }
  function Cg(a) {
    var l = ha(a.target);
    if (l !== null) {
      var m = qt(l);
      if (m !== null) {
        if (l = m.tag, l === 13) {
          if (l = cn(m), l !== null) {
            a.blockedOn = l, zn(a.priority, function() {
              mt(m);
            });
            return;
          }
        } else if (l === 3 && m.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = m.tag === 3 ? m.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function Ml(a) {
    if (a.blockedOn !== null)
      return !1;
    for (var l = a.targetContainers; 0 < l.length; ) {
      var m = Wc(a.domEventName, a.eventSystemFlags, l[0], a.nativeEvent);
      if (m === null) {
        m = a.nativeEvent;
        var k = new m.constructor(m.type, m);
        ri = k, m.target.dispatchEvent(k), ri = null;
      } else
        return l = qu(m), l !== null && Kt(l), a.blockedOn = m, !1;
      l.shift();
    }
    return !0;
  }
  function Uf(a, l, m) {
    Ml(a) && m.delete(l);
  }
  function Ag() {
    gt = !1, Dn !== null && Ml(Dn) && (Dn = null), ai !== null && Ml(ai) && (ai = null), si !== null && Ml(si) && (si = null), vr.forEach(Uf), ln.forEach(Uf);
  }
  function Ou(a, l) {
    a.blockedOn === l && (a.blockedOn = null, gt || (gt = !0, u.unstable_scheduleCallback(u.unstable_NormalPriority, Ag)));
  }
  function _u(a) {
    function l(D) {
      return Ou(D, a);
    }
    if (0 < jr.length) {
      Ou(jr[0], a);
      for (var m = 1; m < jr.length; m++) {
        var k = jr[m];
        k.blockedOn === a && (k.blockedOn = null);
      }
    }
    for (Dn !== null && Ou(Dn, a), ai !== null && Ou(ai, a), si !== null && Ou(si, a), vr.forEach(l), ln.forEach(l), m = 0; m < wn.length; m++)
      k = wn[m], k.blockedOn === a && (k.blockedOn = null);
    for (; 0 < wn.length && (m = wn[0], m.blockedOn === null); )
      Cg(m), m.blockedOn === null && wn.shift();
  }
  var Dl = Ee.ReactCurrentBatchConfig, _o = !0;
  function Tg(a, l, m, k) {
    var D = Ie, z = Dl.transition;
    Dl.transition = null;
    try {
      Ie = 1, Bc(a, l, m, k);
    } finally {
      Ie = D, Dl.transition = z;
    }
  }
  function Uc(a, l, m, k) {
    var D = Ie, z = Dl.transition;
    Dl.transition = null;
    try {
      Ie = 4, Bc(a, l, m, k);
    } finally {
      Ie = D, Dl.transition = z;
    }
  }
  function Bc(a, l, m, k) {
    if (_o) {
      var D = Wc(a, l, m, k);
      if (D === null)
        nd(a, l, k, Pu, m), Na(a, k);
      else if ($s(D, a, l, m, k))
        k.stopPropagation();
      else if (Na(a, k), l & 4 && -1 < lx.indexOf(a)) {
        for (; D !== null; ) {
          var z = qu(D);
          if (z !== null && Qt(z), z = Wc(a, l, m, k), z === null && nd(a, l, k, Pu, m), z === D)
            break;
          D = z;
        }
        D !== null && k.stopPropagation();
      } else
        nd(a, l, k, null, m);
    }
  }
  var Pu = null;
  function Wc(a, l, m, k) {
    if (Pu = null, a = Ln(k), a = ha(a), a !== null)
      if (l = qt(a), l === null)
        a = null;
      else if (m = l.tag, m === 13) {
        if (a = cn(l), a !== null)
          return a;
        a = null;
      } else if (m === 3) {
        if (l.stateNode.current.memoizedState.isDehydrated)
          return l.tag === 3 ? l.stateNode.containerInfo : null;
        a = null;
      } else
        l !== a && (a = null);
    return Pu = a, null;
  }
  function Bf(a) {
    switch (a) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (d()) {
          case f:
            return 1;
          case p:
            return 4;
          case y:
          case S:
            return 16;
          case C:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var ps = null, Nu = null, zu = null;
  function Wf() {
    if (zu)
      return zu;
    var a, l = Nu, m = l.length, k, D = "value" in ps ? ps.value : ps.textContent, z = D.length;
    for (a = 0; a < m && l[a] === D[a]; a++)
      ;
    var G = m - a;
    for (k = 1; k <= G && l[m - k] === D[z - k]; k++)
      ;
    return zu = D.slice(a, 1 < k ? 1 - k : void 0);
  }
  function Ol(a) {
    var l = a.keyCode;
    return "charCode" in a ? (a = a.charCode, a === 0 && l === 13 && (a = 13)) : a = l, a === 10 && (a = 13), 32 <= a || a === 13 ? a : 0;
  }
  function Iu() {
    return !0;
  }
  function Eg() {
    return !1;
  }
  function Ki(a) {
    function l(m, k, D, z, G) {
      this._reactName = m, this._targetInst = D, this.type = k, this.nativeEvent = z, this.target = G, this.currentTarget = null;
      for (var ie in a)
        a.hasOwnProperty(ie) && (m = a[ie], this[ie] = m ? m(z) : z[ie]);
      return this.isDefaultPrevented = (z.defaultPrevented != null ? z.defaultPrevented : z.returnValue === !1) ? Iu : Eg, this.isPropagationStopped = Eg, this;
    }
    return ye(l.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var m = this.nativeEvent;
      m && (m.preventDefault ? m.preventDefault() : typeof m.returnValue != "unknown" && (m.returnValue = !1), this.isDefaultPrevented = Iu);
    }, stopPropagation: function() {
      var m = this.nativeEvent;
      m && (m.stopPropagation ? m.stopPropagation() : typeof m.cancelBubble != "unknown" && (m.cancelBubble = !0), this.isPropagationStopped = Iu);
    }, persist: function() {
    }, isPersistent: Iu }), l;
  }
  var qs = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Xc = Ki(qs), _l = ye({}, qs, { view: 0, detail: 0 }), Rg = Ki(_l), Vc, Xf, Fu, Dr = ye({}, _l, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: qf, button: 0, buttons: 0, relatedTarget: function(a) {
    return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  }, movementX: function(a) {
    return "movementX" in a ? a.movementX : (a !== Fu && (Fu && a.type === "mousemove" ? (Vc = a.screenX - Fu.screenX, Xf = a.screenY - Fu.screenY) : Xf = Vc = 0, Fu = a), Vc);
  }, movementY: function(a) {
    return "movementY" in a ? a.movementY : Xf;
  } }), Gc = Ki(Dr), Lg = ye({}, Dr, { dataTransfer: 0 }), Mg = Ki(Lg), ux = ye({}, _l, { relatedTarget: 0 }), Zs = Ki(ux), Vf = ye({}, qs, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Dg = Ki(Vf), cx = ye({}, qs, { clipboardData: function(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } }), dx = Ki(cx), fx = ye({}, qs, { data: 0 }), Gf = Ki(fx), $f = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Og = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, _g = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pg(a) {
    var l = this.nativeEvent;
    return l.getModifierState ? l.getModifierState(a) : (a = _g[a]) ? !!l[a] : !1;
  }
  function qf() {
    return Pg;
  }
  var gs = ye({}, _l, { key: function(a) {
    if (a.key) {
      var l = $f[a.key] || a.key;
      if (l !== "Unidentified")
        return l;
    }
    return a.type === "keypress" ? (a = Ol(a), a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? Og[a.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: qf, charCode: function(a) {
    return a.type === "keypress" ? Ol(a) : 0;
  }, keyCode: function(a) {
    return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
  }, which: function(a) {
    return a.type === "keypress" ? Ol(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
  } }), hx = Ki(gs), Zf = ye({}, Dr, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), $c = Ki(Zf), Qf = ye({}, _l, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: qf }), px = Ki(Qf), qc = ye({}, qs, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Ng = Ki(qc), Oi = ye({}, Dr, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), vs = Ki(Oi), mr = [9, 13, 27, 32], za = F && "CompositionEvent" in window, Po = null;
  F && "documentMode" in document && (Po = document.documentMode);
  var Zc = F && "TextEvent" in window && !Po, zg = F && (!za || Po && 8 < Po && 11 >= Po), Pl = String.fromCharCode(32), Ig = !1;
  function Fg(a, l) {
    switch (a) {
      case "keyup":
        return mr.indexOf(l.keyCode) !== -1;
      case "keydown":
        return l.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Qc(a) {
    return a = a.detail, typeof a == "object" && "data" in a ? a.data : null;
  }
  var Nl = !1;
  function gx(a, l) {
    switch (a) {
      case "compositionend":
        return Qc(l);
      case "keypress":
        return l.which !== 32 ? null : (Ig = !0, Pl);
      case "textInput":
        return a = l.data, a === Pl && Ig ? null : a;
      default:
        return null;
    }
  }
  function vx(a, l) {
    if (Nl)
      return a === "compositionend" || !za && Fg(a, l) ? (a = Wf(), zu = Nu = ps = null, Nl = !1, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) {
          if (l.char && 1 < l.char.length)
            return l.char;
          if (l.which)
            return String.fromCharCode(l.which);
        }
        return null;
      case "compositionend":
        return zg && l.locale !== "ko" ? null : l.data;
      default:
        return null;
    }
  }
  var Yg = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Hg(a) {
    var l = a && a.nodeName && a.nodeName.toLowerCase();
    return l === "input" ? !!Yg[a.type] : l === "textarea";
  }
  function jg(a, l, m, k) {
    cs(k), l = Vu(l, "onChange"), 0 < l.length && (m = new Xc("onChange", "change", null, m, k), a.push({ event: m, listeners: l }));
  }
  var Yu = null, zl = null;
  function Il(a) {
    td(a, 0);
  }
  function Fl(a) {
    var l = Hl(a);
    if (Ze(l))
      return a;
  }
  function Ug(a, l) {
    if (a === "change")
      return l;
  }
  var Kf = !1;
  if (F) {
    var Jf;
    if (F) {
      var eh = "oninput" in document;
      if (!eh) {
        var Bg = document.createElement("div");
        Bg.setAttribute("oninput", "return;"), eh = typeof Bg.oninput == "function";
      }
      Jf = eh;
    } else
      Jf = !1;
    Kf = Jf && (!document.documentMode || 9 < document.documentMode);
  }
  function Wg() {
    Yu && (Yu.detachEvent("onpropertychange", Xg), zl = Yu = null);
  }
  function Xg(a) {
    if (a.propertyName === "value" && Fl(zl)) {
      var l = [];
      jg(l, zl, a, Ln(a)), Vs(Il, l);
    }
  }
  function mx(a, l, m) {
    a === "focusin" ? (Wg(), Yu = l, zl = m, Yu.attachEvent("onpropertychange", Xg)) : a === "focusout" && Wg();
  }
  function yx(a) {
    if (a === "selectionchange" || a === "keyup" || a === "keydown")
      return Fl(zl);
  }
  function xx(a, l) {
    if (a === "click")
      return Fl(l);
  }
  function Vg(a, l) {
    if (a === "input" || a === "change")
      return Fl(l);
  }
  function bx(a, l) {
    return a === l && (a !== 0 || 1 / a === 1 / l) || a !== a && l !== l;
  }
  var fa = typeof Object.is == "function" ? Object.is : bx;
  function Hu(a, l) {
    if (fa(a, l))
      return !0;
    if (typeof a != "object" || a === null || typeof l != "object" || l === null)
      return !1;
    var m = Object.keys(a), k = Object.keys(l);
    if (m.length !== k.length)
      return !1;
    for (k = 0; k < m.length; k++) {
      var D = m[k];
      if (!H.call(l, D) || !fa(a[D], l[D]))
        return !1;
    }
    return !0;
  }
  function Gg(a) {
    for (; a && a.firstChild; )
      a = a.firstChild;
    return a;
  }
  function $g(a, l) {
    var m = Gg(a);
    a = 0;
    for (var k; m; ) {
      if (m.nodeType === 3) {
        if (k = a + m.textContent.length, a <= l && k >= l)
          return { node: m, offset: l - a };
        a = k;
      }
      e: {
        for (; m; ) {
          if (m.nextSibling) {
            m = m.nextSibling;
            break e;
          }
          m = m.parentNode;
        }
        m = void 0;
      }
      m = Gg(m);
    }
  }
  function qg(a, l) {
    return a && l ? a === l ? !0 : a && a.nodeType === 3 ? !1 : l && l.nodeType === 3 ? qg(a, l.parentNode) : "contains" in a ? a.contains(l) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(l) & 16) : !1 : !1;
  }
  function Kc() {
    for (var a = window, l = pn(); l instanceof a.HTMLIFrameElement; ) {
      try {
        var m = typeof l.contentWindow.location.href == "string";
      } catch {
        m = !1;
      }
      if (m)
        a = l.contentWindow;
      else
        break;
      l = pn(a.document);
    }
    return l;
  }
  function ms(a) {
    var l = a && a.nodeName && a.nodeName.toLowerCase();
    return l && (l === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || l === "textarea" || a.contentEditable === "true");
  }
  function Jc(a) {
    var l = Kc(), m = a.focusedElem, k = a.selectionRange;
    if (l !== m && m && m.ownerDocument && qg(m.ownerDocument.documentElement, m)) {
      if (k !== null && ms(m)) {
        if (l = k.start, a = k.end, a === void 0 && (a = l), "selectionStart" in m)
          m.selectionStart = l, m.selectionEnd = Math.min(a, m.value.length);
        else if (a = (l = m.ownerDocument || document) && l.defaultView || window, a.getSelection) {
          a = a.getSelection();
          var D = m.textContent.length, z = Math.min(k.start, D);
          k = k.end === void 0 ? z : Math.min(k.end, D), !a.extend && z > k && (D = k, k = z, z = D), D = $g(m, z);
          var G = $g(
            m,
            k
          );
          D && G && (a.rangeCount !== 1 || a.anchorNode !== D.node || a.anchorOffset !== D.offset || a.focusNode !== G.node || a.focusOffset !== G.offset) && (l = l.createRange(), l.setStart(D.node, D.offset), a.removeAllRanges(), z > k ? (a.addRange(l), a.extend(G.node, G.offset)) : (l.setEnd(G.node, G.offset), a.addRange(l)));
        }
      }
      for (l = [], a = m; a = a.parentNode; )
        a.nodeType === 1 && l.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      for (typeof m.focus == "function" && m.focus(), m = 0; m < l.length; m++)
        a = l[m], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
    }
  }
  var Zg = F && "documentMode" in document && 11 >= document.documentMode, Ia = null, th = null, ju = null, nh = !1;
  function Qg(a, l, m) {
    var k = m.window === m ? m.document : m.nodeType === 9 ? m : m.ownerDocument;
    nh || Ia == null || Ia !== pn(k) || (k = Ia, "selectionStart" in k && ms(k) ? k = { start: k.selectionStart, end: k.selectionEnd } : (k = (k.ownerDocument && k.ownerDocument.defaultView || window).getSelection(), k = { anchorNode: k.anchorNode, anchorOffset: k.anchorOffset, focusNode: k.focusNode, focusOffset: k.focusOffset }), ju && Hu(ju, k) || (ju = k, k = Vu(th, "onSelect"), 0 < k.length && (l = new Xc("onSelect", "select", null, l, m), a.push({ event: l, listeners: k }), l.target = Ia)));
  }
  function ed(a, l) {
    var m = {};
    return m[a.toLowerCase()] = l.toLowerCase(), m["Webkit" + a] = "webkit" + l, m["Moz" + a] = "moz" + l, m;
  }
  var No = { animationend: ed("Animation", "AnimationEnd"), animationiteration: ed("Animation", "AnimationIteration"), animationstart: ed("Animation", "AnimationStart"), transitionend: ed("Transition", "TransitionEnd") }, rh = {}, ih = {};
  F && (ih = document.createElement("div").style, "AnimationEvent" in window || (delete No.animationend.animation, delete No.animationiteration.animation, delete No.animationstart.animation), "TransitionEvent" in window || delete No.transitionend.transition);
  function Or(a) {
    if (rh[a])
      return rh[a];
    if (!No[a])
      return a;
    var l = No[a], m;
    for (m in l)
      if (l.hasOwnProperty(m) && m in ih)
        return rh[a] = l[m];
    return a;
  }
  var ah = Or("animationend"), Kg = Or("animationiteration"), Jg = Or("animationstart"), ev = Or("transitionend"), tv = /* @__PURE__ */ new Map(), nv = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ys(a, l) {
    tv.set(a, l), A(l, [a]);
  }
  for (var Uu = 0; Uu < nv.length; Uu++) {
    var zo = nv[Uu], wx = zo.toLowerCase(), Bu = zo[0].toUpperCase() + zo.slice(1);
    ys(wx, "on" + Bu);
  }
  ys(ah, "onAnimationEnd"), ys(Kg, "onAnimationIteration"), ys(Jg, "onAnimationStart"), ys("dblclick", "onDoubleClick"), ys("focusin", "onFocus"), ys("focusout", "onBlur"), ys(ev, "onTransitionEnd"), T("onMouseEnter", ["mouseout", "mouseover"]), T("onMouseLeave", ["mouseout", "mouseover"]), T("onPointerEnter", ["pointerout", "pointerover"]), T("onPointerLeave", ["pointerout", "pointerover"]), A("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), A("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), A("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), A("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), A("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), A("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Wu = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Sx = new Set("cancel close invalid load scroll toggle".split(" ").concat(Wu));
  function rv(a, l, m) {
    var k = a.type || "unknown-event";
    a.currentTarget = m, Dt(k, l, void 0, a), a.currentTarget = null;
  }
  function td(a, l) {
    l = (l & 4) !== 0;
    for (var m = 0; m < a.length; m++) {
      var k = a[m], D = k.event;
      k = k.listeners;
      e: {
        var z = void 0;
        if (l)
          for (var G = k.length - 1; 0 <= G; G--) {
            var ie = k[G], ce = ie.instance, Te = ie.currentTarget;
            if (ie = ie.listener, ce !== z && D.isPropagationStopped())
              break e;
            rv(D, ie, Te), z = ce;
          }
        else
          for (G = 0; G < k.length; G++) {
            if (ie = k[G], ce = ie.instance, Te = ie.currentTarget, ie = ie.listener, ce !== z && D.isPropagationStopped())
              break e;
            rv(D, ie, Te), z = ce;
          }
      }
    }
    if (ii)
      throw a = le, ii = !1, le = null, a;
  }
  function In(a, l) {
    var m = l[fh];
    m === void 0 && (m = l[fh] = /* @__PURE__ */ new Set());
    var k = a + "__bubble";
    m.has(k) || (iv(l, a, 2, !1), m.add(k));
  }
  function Qs(a, l, m) {
    var k = 0;
    l && (k |= 4), iv(m, a, k, l);
  }
  var xs = "_reactListening" + Math.random().toString(36).slice(2);
  function Yl(a) {
    if (!a[xs]) {
      a[xs] = !0, v.forEach(function(m) {
        m !== "selectionchange" && (Sx.has(m) || Qs(m, !1, a), Qs(m, !0, a));
      });
      var l = a.nodeType === 9 ? a : a.ownerDocument;
      l === null || l[xs] || (l[xs] = !0, Qs("selectionchange", !1, l));
    }
  }
  function iv(a, l, m, k) {
    switch (Bf(l)) {
      case 1:
        var D = Tg;
        break;
      case 4:
        D = Uc;
        break;
      default:
        D = Bc;
    }
    m = D.bind(null, l, m, a), D = void 0, !Gs || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (D = !0), k ? D !== void 0 ? a.addEventListener(l, m, { capture: !0, passive: D }) : a.addEventListener(l, m, !0) : D !== void 0 ? a.addEventListener(l, m, { passive: D }) : a.addEventListener(l, m, !1);
  }
  function nd(a, l, m, k, D) {
    var z = k;
    if (!(l & 1) && !(l & 2) && k !== null)
      e:
        for (; ; ) {
          if (k === null)
            return;
          var G = k.tag;
          if (G === 3 || G === 4) {
            var ie = k.stateNode.containerInfo;
            if (ie === D || ie.nodeType === 8 && ie.parentNode === D)
              break;
            if (G === 4)
              for (G = k.return; G !== null; ) {
                var ce = G.tag;
                if ((ce === 3 || ce === 4) && (ce = G.stateNode.containerInfo, ce === D || ce.nodeType === 8 && ce.parentNode === D))
                  return;
                G = G.return;
              }
            for (; ie !== null; ) {
              if (G = ha(ie), G === null)
                return;
              if (ce = G.tag, ce === 5 || ce === 6) {
                k = z = G;
                continue e;
              }
              ie = ie.parentNode;
            }
          }
          k = k.return;
        }
    Vs(function() {
      var Te = z, He = Ln(m), Ue = [];
      e: {
        var Fe = tv.get(a);
        if (Fe !== void 0) {
          var lt = Xc, yt = a;
          switch (a) {
            case "keypress":
              if (Ol(m) === 0)
                break e;
            case "keydown":
            case "keyup":
              lt = hx;
              break;
            case "focusin":
              yt = "focus", lt = Zs;
              break;
            case "focusout":
              yt = "blur", lt = Zs;
              break;
            case "beforeblur":
            case "afterblur":
              lt = Zs;
              break;
            case "click":
              if (m.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              lt = Gc;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              lt = Mg;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              lt = px;
              break;
            case ah:
            case Kg:
            case Jg:
              lt = Dg;
              break;
            case ev:
              lt = Ng;
              break;
            case "scroll":
              lt = Rg;
              break;
            case "wheel":
              lt = vs;
              break;
            case "copy":
            case "cut":
            case "paste":
              lt = dx;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              lt = $c;
          }
          var St = (l & 4) !== 0, dr = !St && a === "scroll", me = St ? Fe !== null ? Fe + "Capture" : null : Fe;
          St = [];
          for (var pe = Te, Se; pe !== null; ) {
            Se = pe;
            var qe = Se.stateNode;
            if (Se.tag === 5 && qe !== null && (Se = qe, me !== null && (qe = hs(pe, me), qe != null && St.push(Xu(pe, qe, Se)))), dr)
              break;
            pe = pe.return;
          }
          0 < St.length && (Fe = new lt(Fe, yt, null, m, He), Ue.push({ event: Fe, listeners: St }));
        }
      }
      if (!(l & 7)) {
        e: {
          if (Fe = a === "mouseover" || a === "pointerover", lt = a === "mouseout" || a === "pointerout", Fe && m !== ri && (yt = m.relatedTarget || m.fromElement) && (ha(yt) || yt[bs]))
            break e;
          if ((lt || Fe) && (Fe = He.window === He ? He : (Fe = He.ownerDocument) ? Fe.defaultView || Fe.parentWindow : window, lt ? (yt = m.relatedTarget || m.toElement, lt = Te, yt = yt ? ha(yt) : null, yt !== null && (dr = qt(yt), yt !== dr || yt.tag !== 5 && yt.tag !== 6) && (yt = null)) : (lt = null, yt = Te), lt !== yt)) {
            if (St = Gc, qe = "onMouseLeave", me = "onMouseEnter", pe = "mouse", (a === "pointerout" || a === "pointerover") && (St = $c, qe = "onPointerLeave", me = "onPointerEnter", pe = "pointer"), dr = lt == null ? Fe : Hl(lt), Se = yt == null ? Fe : Hl(yt), Fe = new St(qe, pe + "leave", lt, m, He), Fe.target = dr, Fe.relatedTarget = Se, qe = null, ha(He) === Te && (St = new St(me, pe + "enter", yt, m, He), St.target = Se, St.relatedTarget = dr, qe = St), dr = qe, lt && yt)
              t: {
                for (St = lt, me = yt, pe = 0, Se = St; Se; Se = Io(Se))
                  pe++;
                for (Se = 0, qe = me; qe; qe = Io(qe))
                  Se++;
                for (; 0 < pe - Se; )
                  St = Io(St), pe--;
                for (; 0 < Se - pe; )
                  me = Io(me), Se--;
                for (; pe--; ) {
                  if (St === me || me !== null && St === me.alternate)
                    break t;
                  St = Io(St), me = Io(me);
                }
                St = null;
              }
            else
              St = null;
            lt !== null && sh(Ue, Fe, lt, St, !1), yt !== null && dr !== null && sh(Ue, dr, yt, St, !0);
          }
        }
        e: {
          if (Fe = Te ? Hl(Te) : window, lt = Fe.nodeName && Fe.nodeName.toLowerCase(), lt === "select" || lt === "input" && Fe.type === "file")
            var Ct = Ug;
          else if (Hg(Fe))
            if (Kf)
              Ct = Vg;
            else {
              Ct = yx;
              var xt = mx;
            }
          else
            (lt = Fe.nodeName) && lt.toLowerCase() === "input" && (Fe.type === "checkbox" || Fe.type === "radio") && (Ct = xx);
          if (Ct && (Ct = Ct(a, Te))) {
            jg(Ue, Ct, m, He);
            break e;
          }
          xt && xt(a, Fe, Te), a === "focusout" && (xt = Fe._wrapperState) && xt.controlled && Fe.type === "number" && qi(Fe, "number", Fe.value);
        }
        switch (xt = Te ? Hl(Te) : window, a) {
          case "focusin":
            (Hg(xt) || xt.contentEditable === "true") && (Ia = xt, th = Te, ju = null);
            break;
          case "focusout":
            ju = th = Ia = null;
            break;
          case "mousedown":
            nh = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            nh = !1, Qg(Ue, m, He);
            break;
          case "selectionchange":
            if (Zg)
              break;
          case "keydown":
          case "keyup":
            Qg(Ue, m, He);
        }
        var Lt;
        if (za)
          e: {
            switch (a) {
              case "compositionstart":
                var Vt = "onCompositionStart";
                break e;
              case "compositionend":
                Vt = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Vt = "onCompositionUpdate";
                break e;
            }
            Vt = void 0;
          }
        else
          Nl ? Fg(a, m) && (Vt = "onCompositionEnd") : a === "keydown" && m.keyCode === 229 && (Vt = "onCompositionStart");
        Vt && (zg && m.locale !== "ko" && (Nl || Vt !== "onCompositionStart" ? Vt === "onCompositionEnd" && Nl && (Lt = Wf()) : (ps = He, Nu = "value" in ps ? ps.value : ps.textContent, Nl = !0)), xt = Vu(Te, Vt), 0 < xt.length && (Vt = new Gf(Vt, a, null, m, He), Ue.push({ event: Vt, listeners: xt }), Lt ? Vt.data = Lt : (Lt = Qc(m), Lt !== null && (Vt.data = Lt)))), (Lt = Zc ? gx(a, m) : vx(a, m)) && (Te = Vu(Te, "onBeforeInput"), 0 < Te.length && (He = new Gf("onBeforeInput", "beforeinput", null, m, He), Ue.push({ event: He, listeners: Te }), He.data = Lt));
      }
      td(Ue, l);
    });
  }
  function Xu(a, l, m) {
    return { instance: a, listener: l, currentTarget: m };
  }
  function Vu(a, l) {
    for (var m = l + "Capture", k = []; a !== null; ) {
      var D = a, z = D.stateNode;
      D.tag === 5 && z !== null && (D = z, z = hs(a, m), z != null && k.unshift(Xu(a, z, D)), z = hs(a, l), z != null && k.push(Xu(a, z, D))), a = a.return;
    }
    return k;
  }
  function Io(a) {
    if (a === null)
      return null;
    do
      a = a.return;
    while (a && a.tag !== 5);
    return a || null;
  }
  function sh(a, l, m, k, D) {
    for (var z = l._reactName, G = []; m !== null && m !== k; ) {
      var ie = m, ce = ie.alternate, Te = ie.stateNode;
      if (ce !== null && ce === k)
        break;
      ie.tag === 5 && Te !== null && (ie = Te, D ? (ce = hs(m, z), ce != null && G.unshift(Xu(m, ce, ie))) : D || (ce = hs(m, z), ce != null && G.push(Xu(m, ce, ie)))), m = m.return;
    }
    G.length !== 0 && a.push({ event: l, listeners: G });
  }
  var oh = /\r\n?/g, kx = /\u0000|\uFFFD/g;
  function lh(a) {
    return (typeof a == "string" ? a : "" + a).replace(oh, `
`).replace(kx, "");
  }
  function rd(a, l, m) {
    if (l = lh(l), lh(a) !== l && m)
      throw Error(h(425));
  }
  function id() {
  }
  var uh = null, Fo = null;
  function Gu(a, l) {
    return a === "textarea" || a === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null;
  }
  var Yo = typeof setTimeout == "function" ? setTimeout : void 0, av = typeof clearTimeout == "function" ? clearTimeout : void 0, ch = typeof Promise == "function" ? Promise : void 0, dh = typeof queueMicrotask == "function" ? queueMicrotask : typeof ch < "u" ? function(a) {
    return ch.resolve(null).then(a).catch(Cx);
  } : Yo;
  function Cx(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function Ks(a, l) {
    var m = l, k = 0;
    do {
      var D = m.nextSibling;
      if (a.removeChild(m), D && D.nodeType === 8)
        if (m = D.data, m === "/$") {
          if (k === 0) {
            a.removeChild(D), _u(l);
            return;
          }
          k--;
        } else
          m !== "$" && m !== "$?" && m !== "$!" || k++;
      m = D;
    } while (m);
    _u(l);
  }
  function Fa(a) {
    for (; a != null; a = a.nextSibling) {
      var l = a.nodeType;
      if (l === 1 || l === 3)
        break;
      if (l === 8) {
        if (l = a.data, l === "$" || l === "$!" || l === "$?")
          break;
        if (l === "/$")
          return null;
      }
    }
    return a;
  }
  function $u(a) {
    a = a.previousSibling;
    for (var l = 0; a; ) {
      if (a.nodeType === 8) {
        var m = a.data;
        if (m === "$" || m === "$!" || m === "$?") {
          if (l === 0)
            return a;
          l--;
        } else
          m === "/$" && l++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var Js = Math.random().toString(36).slice(2), Va = "__reactFiber$" + Js, Ho = "__reactProps$" + Js, bs = "__reactContainer$" + Js, fh = "__reactEvents$" + Js, Ax = "__reactListeners$" + Js, hh = "__reactHandles$" + Js;
  function ha(a) {
    var l = a[Va];
    if (l)
      return l;
    for (var m = a.parentNode; m; ) {
      if (l = m[bs] || m[Va]) {
        if (m = l.alternate, l.child !== null || m !== null && m.child !== null)
          for (a = $u(a); a !== null; ) {
            if (m = a[Va])
              return m;
            a = $u(a);
          }
        return l;
      }
      a = m, m = a.parentNode;
    }
    return null;
  }
  function qu(a) {
    return a = a[Va] || a[bs], !a || a.tag !== 5 && a.tag !== 6 && a.tag !== 13 && a.tag !== 3 ? null : a;
  }
  function Hl(a) {
    if (a.tag === 5 || a.tag === 6)
      return a.stateNode;
    throw Error(h(33));
  }
  function _t(a) {
    return a[Ho] || null;
  }
  var eo = [], Bn = -1;
  function Jt(a) {
    return { current: a };
  }
  function Sn(a) {
    0 > Bn || (a.current = eo[Bn], eo[Bn] = null, Bn--);
  }
  function An(a, l) {
    Bn++, eo[Bn] = a.current, a.current = l;
  }
  var Ga = {}, Xt = Jt(Ga), sr = Jt(!1), _i = Ga;
  function pa(a, l) {
    var m = a.type.contextTypes;
    if (!m)
      return Ga;
    var k = a.stateNode;
    if (k && k.__reactInternalMemoizedUnmaskedChildContext === l)
      return k.__reactInternalMemoizedMaskedChildContext;
    var D = {}, z;
    for (z in m)
      D[z] = l[z];
    return k && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = l, a.__reactInternalMemoizedMaskedChildContext = D), D;
  }
  function qn(a) {
    return a = a.childContextTypes, a != null;
  }
  function ga() {
    Sn(sr), Sn(Xt);
  }
  function to(a, l, m) {
    if (Xt.current !== Ga)
      throw Error(h(168));
    An(Xt, l), An(sr, m);
  }
  function Zu(a, l, m) {
    var k = a.stateNode;
    if (l = l.childContextTypes, typeof k.getChildContext != "function")
      return m;
    k = k.getChildContext();
    for (var D in k)
      if (!(D in l))
        throw Error(h(108, It(a) || "Unknown", D));
    return ye({}, m, k);
  }
  function ad(a) {
    return a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Ga, _i = Xt.current, An(Xt, a), An(sr, sr.current), !0;
  }
  function sv(a, l, m) {
    var k = a.stateNode;
    if (!k)
      throw Error(h(169));
    m ? (a = Zu(a, l, _i), k.__reactInternalMemoizedMergedChildContext = a, Sn(sr), Sn(Xt), An(Xt, a)) : Sn(sr), An(sr, m);
  }
  var Ji = null, _r = !1, Qu = !1;
  function ph(a) {
    Ji === null ? Ji = [a] : Ji.push(a);
  }
  function gh(a) {
    _r = !0, ph(a);
  }
  function Pi() {
    if (!Qu && Ji !== null) {
      Qu = !0;
      var a = 0, l = Ie;
      try {
        var m = Ji;
        for (Ie = 1; a < m.length; a++) {
          var k = m[a];
          do
            k = k(!0);
          while (k !== null);
        }
        Ji = null, _r = !1;
      } catch (D) {
        throw Ji !== null && (Ji = Ji.slice(a + 1)), B(f, Pi), D;
      } finally {
        Ie = l, Qu = !1;
      }
    }
    return null;
  }
  var no = [], Ni = 0, jo = null, jl = 0, zi = [], li = 0, va = null, Ur = 1, ws = "";
  function ea(a, l) {
    no[Ni++] = jl, no[Ni++] = jo, jo = a, jl = l;
  }
  function vh(a, l, m) {
    zi[li++] = Ur, zi[li++] = ws, zi[li++] = va, va = a;
    var k = Ur;
    a = ws;
    var D = 32 - P(k) - 1;
    k &= ~(1 << D), m += 1;
    var z = 32 - P(l) + D;
    if (30 < z) {
      var G = D - D % 5;
      z = (k & (1 << G) - 1).toString(32), k >>= G, D -= G, Ur = 1 << 32 - P(l) + D | m << D | k, ws = z + a;
    } else
      Ur = 1 << z | m << D | k, ws = a;
  }
  function sd(a) {
    a.return !== null && (ea(a, 1), vh(a, 1, 0));
  }
  function mh(a) {
    for (; a === jo; )
      jo = no[--Ni], no[Ni] = null, jl = no[--Ni], no[Ni] = null;
    for (; a === va; )
      va = zi[--li], zi[li] = null, ws = zi[--li], zi[li] = null, Ur = zi[--li], zi[li] = null;
  }
  var ta = null, Ii = null, Wn = !1, ma = null;
  function yh(a, l) {
    var m = ka(5, null, null, 0);
    m.elementType = "DELETED", m.stateNode = l, m.return = a, l = a.deletions, l === null ? (a.deletions = [m], a.flags |= 16) : l.push(m);
  }
  function ov(a, l) {
    switch (a.tag) {
      case 5:
        var m = a.type;
        return l = l.nodeType !== 1 || m.toLowerCase() !== l.nodeName.toLowerCase() ? null : l, l !== null ? (a.stateNode = l, ta = a, Ii = Fa(l.firstChild), !0) : !1;
      case 6:
        return l = a.pendingProps === "" || l.nodeType !== 3 ? null : l, l !== null ? (a.stateNode = l, ta = a, Ii = null, !0) : !1;
      case 13:
        return l = l.nodeType !== 8 ? null : l, l !== null ? (m = va !== null ? { id: Ur, overflow: ws } : null, a.memoizedState = { dehydrated: l, treeContext: m, retryLane: 1073741824 }, m = ka(18, null, null, 0), m.stateNode = l, m.return = a, a.child = m, ta = a, Ii = null, !0) : !1;
      default:
        return !1;
    }
  }
  function od(a) {
    return (a.mode & 1) !== 0 && (a.flags & 128) === 0;
  }
  function ld(a) {
    if (Wn) {
      var l = Ii;
      if (l) {
        var m = l;
        if (!ov(a, l)) {
          if (od(a))
            throw Error(h(418));
          l = Fa(m.nextSibling);
          var k = ta;
          l && ov(a, l) ? yh(k, m) : (a.flags = a.flags & -4097 | 2, Wn = !1, ta = a);
        }
      } else {
        if (od(a))
          throw Error(h(418));
        a.flags = a.flags & -4097 | 2, Wn = !1, ta = a;
      }
    }
  }
  function lv(a) {
    for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; )
      a = a.return;
    ta = a;
  }
  function ud(a) {
    if (a !== ta)
      return !1;
    if (!Wn)
      return lv(a), Wn = !0, !1;
    var l;
    if ((l = a.tag !== 3) && !(l = a.tag !== 5) && (l = a.type, l = l !== "head" && l !== "body" && !Gu(a.type, a.memoizedProps)), l && (l = Ii)) {
      if (od(a))
        throw uv(), Error(h(418));
      for (; l; )
        yh(a, l), l = Fa(l.nextSibling);
    }
    if (lv(a), a.tag === 13) {
      if (a = a.memoizedState, a = a !== null ? a.dehydrated : null, !a)
        throw Error(h(317));
      e: {
        for (a = a.nextSibling, l = 0; a; ) {
          if (a.nodeType === 8) {
            var m = a.data;
            if (m === "/$") {
              if (l === 0) {
                Ii = Fa(a.nextSibling);
                break e;
              }
              l--;
            } else
              m !== "$" && m !== "$!" && m !== "$?" || l++;
          }
          a = a.nextSibling;
        }
        Ii = null;
      }
    } else
      Ii = ta ? Fa(a.stateNode.nextSibling) : null;
    return !0;
  }
  function uv() {
    for (var a = Ii; a; )
      a = Fa(a.nextSibling);
  }
  function Qn() {
    Ii = ta = null, Wn = !1;
  }
  function xh(a) {
    ma === null ? ma = [a] : ma.push(a);
  }
  var cd = Ee.ReactCurrentBatchConfig;
  function na(a, l) {
    if (a && a.defaultProps) {
      l = ye({}, l), a = a.defaultProps;
      for (var m in a)
        l[m] === void 0 && (l[m] = a[m]);
      return l;
    }
    return l;
  }
  var $a = Jt(null), dd = null, ro = null, bh = null;
  function wh() {
    bh = ro = dd = null;
  }
  function io(a) {
    var l = $a.current;
    Sn($a), a._currentValue = l;
  }
  function Pr(a, l, m) {
    for (; a !== null; ) {
      var k = a.alternate;
      if ((a.childLanes & l) !== l ? (a.childLanes |= l, k !== null && (k.childLanes |= l)) : k !== null && (k.childLanes & l) !== l && (k.childLanes |= l), a === m)
        break;
      a = a.return;
    }
  }
  function tt(a, l) {
    dd = a, bh = ro = null, a = a.dependencies, a !== null && a.firstContext !== null && (a.lanes & l && (yr = !0), a.firstContext = null);
  }
  function cr(a) {
    var l = a._currentValue;
    if (bh !== a)
      if (a = { context: a, memoizedValue: l, next: null }, ro === null) {
        if (dd === null)
          throw Error(h(308));
        ro = a, dd.dependencies = { lanes: 0, firstContext: a };
      } else
        ro = ro.next = a;
    return l;
  }
  var Br = null;
  function Sh(a) {
    Br === null ? Br = [a] : Br.push(a);
  }
  function cv(a, l, m, k) {
    var D = l.interleaved;
    return D === null ? (m.next = m, Sh(l)) : (m.next = D.next, D.next = m), l.interleaved = m, Ss(a, k);
  }
  function Ss(a, l) {
    a.lanes |= l;
    var m = a.alternate;
    for (m !== null && (m.lanes |= l), m = a, a = a.return; a !== null; )
      a.childLanes |= l, m = a.alternate, m !== null && (m.childLanes |= l), m = a, a = a.return;
    return m.tag === 3 ? m.stateNode : null;
  }
  var ao = !1;
  function kh(a) {
    a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Sr(a, l) {
    a = a.updateQueue, l.updateQueue === a && (l.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
  }
  function ks(a, l) {
    return { eventTime: a, lane: l, tag: 0, payload: null, callback: null, next: null };
  }
  function so(a, l, m) {
    var k = a.updateQueue;
    if (k === null)
      return null;
    if (k = k.shared, sn & 2) {
      var D = k.pending;
      return D === null ? l.next = l : (l.next = D.next, D.next = l), k.pending = l, Ss(a, m);
    }
    return D = k.interleaved, D === null ? (l.next = l, Sh(k)) : (l.next = D.next, D.next = l), k.interleaved = l, Ss(a, m);
  }
  function fd(a, l, m) {
    if (l = l.updateQueue, l !== null && (l = l.shared, (m & 4194240) !== 0)) {
      var k = l.lanes;
      k &= a.pendingLanes, m |= k, l.lanes = m, Me(a, m);
    }
  }
  function Ch(a, l) {
    var m = a.updateQueue, k = a.alternate;
    if (k !== null && (k = k.updateQueue, m === k)) {
      var D = null, z = null;
      if (m = m.firstBaseUpdate, m !== null) {
        do {
          var G = { eventTime: m.eventTime, lane: m.lane, tag: m.tag, payload: m.payload, callback: m.callback, next: null };
          z === null ? D = z = G : z = z.next = G, m = m.next;
        } while (m !== null);
        z === null ? D = z = l : z = z.next = l;
      } else
        D = z = l;
      m = { baseState: k.baseState, firstBaseUpdate: D, lastBaseUpdate: z, shared: k.shared, effects: k.effects }, a.updateQueue = m;
      return;
    }
    a = m.lastBaseUpdate, a === null ? m.firstBaseUpdate = l : a.next = l, m.lastBaseUpdate = l;
  }
  function oo(a, l, m, k) {
    var D = a.updateQueue;
    ao = !1;
    var z = D.firstBaseUpdate, G = D.lastBaseUpdate, ie = D.shared.pending;
    if (ie !== null) {
      D.shared.pending = null;
      var ce = ie, Te = ce.next;
      ce.next = null, G === null ? z = Te : G.next = Te, G = ce;
      var He = a.alternate;
      He !== null && (He = He.updateQueue, ie = He.lastBaseUpdate, ie !== G && (ie === null ? He.firstBaseUpdate = Te : ie.next = Te, He.lastBaseUpdate = ce));
    }
    if (z !== null) {
      var Ue = D.baseState;
      G = 0, He = Te = ce = null, ie = z;
      do {
        var Fe = ie.lane, lt = ie.eventTime;
        if ((k & Fe) === Fe) {
          He !== null && (He = He.next = {
            eventTime: lt,
            lane: 0,
            tag: ie.tag,
            payload: ie.payload,
            callback: ie.callback,
            next: null
          });
          e: {
            var yt = a, St = ie;
            switch (Fe = l, lt = m, St.tag) {
              case 1:
                if (yt = St.payload, typeof yt == "function") {
                  Ue = yt.call(lt, Ue, Fe);
                  break e;
                }
                Ue = yt;
                break e;
              case 3:
                yt.flags = yt.flags & -65537 | 128;
              case 0:
                if (yt = St.payload, Fe = typeof yt == "function" ? yt.call(lt, Ue, Fe) : yt, Fe == null)
                  break e;
                Ue = ye({}, Ue, Fe);
                break e;
              case 2:
                ao = !0;
            }
          }
          ie.callback !== null && ie.lane !== 0 && (a.flags |= 64, Fe = D.effects, Fe === null ? D.effects = [ie] : Fe.push(ie));
        } else
          lt = { eventTime: lt, lane: Fe, tag: ie.tag, payload: ie.payload, callback: ie.callback, next: null }, He === null ? (Te = He = lt, ce = Ue) : He = He.next = lt, G |= Fe;
        if (ie = ie.next, ie === null) {
          if (ie = D.shared.pending, ie === null)
            break;
          Fe = ie, ie = Fe.next, Fe.next = null, D.lastBaseUpdate = Fe, D.shared.pending = null;
        }
      } while (1);
      if (He === null && (ce = Ue), D.baseState = ce, D.firstBaseUpdate = Te, D.lastBaseUpdate = He, l = D.shared.interleaved, l !== null) {
        D = l;
        do
          G |= D.lane, D = D.next;
        while (D !== l);
      } else
        z === null && (D.shared.lanes = 0);
      Es |= G, a.lanes = G, a.memoizedState = Ue;
    }
  }
  function Uo(a, l, m) {
    if (a = l.effects, l.effects = null, a !== null)
      for (l = 0; l < a.length; l++) {
        var k = a[l], D = k.callback;
        if (D !== null) {
          if (k.callback = null, k = m, typeof D != "function")
            throw Error(h(191, D));
          D.call(k);
        }
      }
  }
  var dv = new s.Component().refs;
  function Ah(a, l, m, k) {
    l = a.memoizedState, m = m(k, l), m = m == null ? l : ye({}, l, m), a.memoizedState = m, a.lanes === 0 && (a.updateQueue.baseState = m);
  }
  var hd = { isMounted: function(a) {
    return (a = a._reactInternals) ? qt(a) === a : !1;
  }, enqueueSetState: function(a, l, m) {
    a = a._reactInternals;
    var k = fi(), D = xr(a), z = ks(k, D);
    z.payload = l, m != null && (z.callback = m), l = so(a, z, D), l !== null && (hi(l, a, D, k), fd(l, a, D));
  }, enqueueReplaceState: function(a, l, m) {
    a = a._reactInternals;
    var k = fi(), D = xr(a), z = ks(k, D);
    z.tag = 1, z.payload = l, m != null && (z.callback = m), l = so(a, z, D), l !== null && (hi(l, a, D, k), fd(l, a, D));
  }, enqueueForceUpdate: function(a, l) {
    a = a._reactInternals;
    var m = fi(), k = xr(a), D = ks(m, k);
    D.tag = 2, l != null && (D.callback = l), l = so(a, D, k), l !== null && (hi(l, a, k, m), fd(l, a, k));
  } };
  function fv(a, l, m, k, D, z, G) {
    return a = a.stateNode, typeof a.shouldComponentUpdate == "function" ? a.shouldComponentUpdate(k, z, G) : l.prototype && l.prototype.isPureReactComponent ? !Hu(m, k) || !Hu(D, z) : !0;
  }
  function hv(a, l, m) {
    var k = !1, D = Ga, z = l.contextType;
    return typeof z == "object" && z !== null ? z = cr(z) : (D = qn(l) ? _i : Xt.current, k = l.contextTypes, z = (k = k != null) ? pa(a, D) : Ga), l = new l(m, z), a.memoizedState = l.state !== null && l.state !== void 0 ? l.state : null, l.updater = hd, a.stateNode = l, l._reactInternals = a, k && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = D, a.__reactInternalMemoizedMaskedChildContext = z), l;
  }
  function pv(a, l, m, k) {
    a = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(m, k), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(m, k), l.state !== a && hd.enqueueReplaceState(l, l.state, null);
  }
  function pd(a, l, m, k) {
    var D = a.stateNode;
    D.props = m, D.state = a.memoizedState, D.refs = dv, kh(a);
    var z = l.contextType;
    typeof z == "object" && z !== null ? D.context = cr(z) : (z = qn(l) ? _i : Xt.current, D.context = pa(a, z)), D.state = a.memoizedState, z = l.getDerivedStateFromProps, typeof z == "function" && (Ah(a, l, z, m), D.state = a.memoizedState), typeof l.getDerivedStateFromProps == "function" || typeof D.getSnapshotBeforeUpdate == "function" || typeof D.UNSAFE_componentWillMount != "function" && typeof D.componentWillMount != "function" || (l = D.state, typeof D.componentWillMount == "function" && D.componentWillMount(), typeof D.UNSAFE_componentWillMount == "function" && D.UNSAFE_componentWillMount(), l !== D.state && hd.enqueueReplaceState(D, D.state, null), oo(a, m, D, k), D.state = a.memoizedState), typeof D.componentDidMount == "function" && (a.flags |= 4194308);
  }
  function Ul(a, l, m) {
    if (a = m.ref, a !== null && typeof a != "function" && typeof a != "object") {
      if (m._owner) {
        if (m = m._owner, m) {
          if (m.tag !== 1)
            throw Error(h(309));
          var k = m.stateNode;
        }
        if (!k)
          throw Error(h(147, a));
        var D = k, z = "" + a;
        return l !== null && l.ref !== null && typeof l.ref == "function" && l.ref._stringRef === z ? l.ref : (l = function(G) {
          var ie = D.refs;
          ie === dv && (ie = D.refs = {}), G === null ? delete ie[z] : ie[z] = G;
        }, l._stringRef = z, l);
      }
      if (typeof a != "string")
        throw Error(h(284));
      if (!m._owner)
        throw Error(h(290, a));
    }
    return a;
  }
  function gd(a, l) {
    throw a = Object.prototype.toString.call(l), Error(h(31, a === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : a));
  }
  function gv(a) {
    var l = a._init;
    return l(a._payload);
  }
  function vv(a) {
    function l(me, pe) {
      if (a) {
        var Se = me.deletions;
        Se === null ? (me.deletions = [pe], me.flags |= 16) : Se.push(pe);
      }
    }
    function m(me, pe) {
      if (!a)
        return null;
      for (; pe !== null; )
        l(me, pe), pe = pe.sibling;
      return null;
    }
    function k(me, pe) {
      for (me = /* @__PURE__ */ new Map(); pe !== null; )
        pe.key !== null ? me.set(pe.key, pe) : me.set(pe.index, pe), pe = pe.sibling;
      return me;
    }
    function D(me, pe) {
      return me = vo(me, pe), me.index = 0, me.sibling = null, me;
    }
    function z(me, pe, Se) {
      return me.index = Se, a ? (Se = me.alternate, Se !== null ? (Se = Se.index, Se < pe ? (me.flags |= 2, pe) : Se) : (me.flags |= 2, pe)) : (me.flags |= 1048576, pe);
    }
    function G(me) {
      return a && me.alternate === null && (me.flags |= 2), me;
    }
    function ie(me, pe, Se, qe) {
      return pe === null || pe.tag !== 6 ? (pe = vc(Se, me.mode, qe), pe.return = me, pe) : (pe = D(pe, Se), pe.return = me, pe);
    }
    function ce(me, pe, Se, qe) {
      var Ct = Se.type;
      return Ct === Le ? He(me, pe, Se.props.children, qe, Se.key) : pe !== null && (pe.elementType === Ct || typeof Ct == "object" && Ct !== null && Ct.$$typeof === Mt && gv(Ct) === pe.type) ? (qe = D(pe, Se.props), qe.ref = Ul(me, pe, Se), qe.return = me, qe) : (qe = Gd(Se.type, Se.key, Se.props, null, me.mode, qe), qe.ref = Ul(me, pe, Se), qe.return = me, qe);
    }
    function Te(me, pe, Se, qe) {
      return pe === null || pe.tag !== 4 || pe.stateNode.containerInfo !== Se.containerInfo || pe.stateNode.implementation !== Se.implementation ? (pe = ol(Se, me.mode, qe), pe.return = me, pe) : (pe = D(pe, Se.children || []), pe.return = me, pe);
    }
    function He(me, pe, Se, qe, Ct) {
      return pe === null || pe.tag !== 7 ? (pe = sl(Se, me.mode, qe, Ct), pe.return = me, pe) : (pe = D(pe, Se), pe.return = me, pe);
    }
    function Ue(me, pe, Se) {
      if (typeof pe == "string" && pe !== "" || typeof pe == "number")
        return pe = vc("" + pe, me.mode, Se), pe.return = me, pe;
      if (typeof pe == "object" && pe !== null) {
        switch (pe.$$typeof) {
          case re:
            return Se = Gd(pe.type, pe.key, pe.props, null, me.mode, Se), Se.ref = Ul(me, null, pe), Se.return = me, Se;
          case ve:
            return pe = ol(pe, me.mode, Se), pe.return = me, pe;
          case Mt:
            var qe = pe._init;
            return Ue(me, qe(pe._payload), Se);
        }
        if (Oa(pe) || pt(pe))
          return pe = sl(pe, me.mode, Se, null), pe.return = me, pe;
        gd(me, pe);
      }
      return null;
    }
    function Fe(me, pe, Se, qe) {
      var Ct = pe !== null ? pe.key : null;
      if (typeof Se == "string" && Se !== "" || typeof Se == "number")
        return Ct !== null ? null : ie(me, pe, "" + Se, qe);
      if (typeof Se == "object" && Se !== null) {
        switch (Se.$$typeof) {
          case re:
            return Se.key === Ct ? ce(me, pe, Se, qe) : null;
          case ve:
            return Se.key === Ct ? Te(me, pe, Se, qe) : null;
          case Mt:
            return Ct = Se._init, Fe(
              me,
              pe,
              Ct(Se._payload),
              qe
            );
        }
        if (Oa(Se) || pt(Se))
          return Ct !== null ? null : He(me, pe, Se, qe, null);
        gd(me, Se);
      }
      return null;
    }
    function lt(me, pe, Se, qe, Ct) {
      if (typeof qe == "string" && qe !== "" || typeof qe == "number")
        return me = me.get(Se) || null, ie(pe, me, "" + qe, Ct);
      if (typeof qe == "object" && qe !== null) {
        switch (qe.$$typeof) {
          case re:
            return me = me.get(qe.key === null ? Se : qe.key) || null, ce(pe, me, qe, Ct);
          case ve:
            return me = me.get(qe.key === null ? Se : qe.key) || null, Te(pe, me, qe, Ct);
          case Mt:
            var xt = qe._init;
            return lt(me, pe, Se, xt(qe._payload), Ct);
        }
        if (Oa(qe) || pt(qe))
          return me = me.get(Se) || null, He(pe, me, qe, Ct, null);
        gd(pe, qe);
      }
      return null;
    }
    function yt(me, pe, Se, qe) {
      for (var Ct = null, xt = null, Lt = pe, Vt = pe = 0, Ir = null; Lt !== null && Vt < Se.length; Vt++) {
        Lt.index > Vt ? (Ir = Lt, Lt = null) : Ir = Lt.sibling;
        var gn = Fe(me, Lt, Se[Vt], qe);
        if (gn === null) {
          Lt === null && (Lt = Ir);
          break;
        }
        a && Lt && gn.alternate === null && l(me, Lt), pe = z(gn, pe, Vt), xt === null ? Ct = gn : xt.sibling = gn, xt = gn, Lt = Ir;
      }
      if (Vt === Se.length)
        return m(me, Lt), Wn && ea(me, Vt), Ct;
      if (Lt === null) {
        for (; Vt < Se.length; Vt++)
          Lt = Ue(me, Se[Vt], qe), Lt !== null && (pe = z(Lt, pe, Vt), xt === null ? Ct = Lt : xt.sibling = Lt, xt = Lt);
        return Wn && ea(me, Vt), Ct;
      }
      for (Lt = k(me, Lt); Vt < Se.length; Vt++)
        Ir = lt(Lt, me, Vt, Se[Vt], qe), Ir !== null && (a && Ir.alternate !== null && Lt.delete(Ir.key === null ? Vt : Ir.key), pe = z(Ir, pe, Vt), xt === null ? Ct = Ir : xt.sibling = Ir, xt = Ir);
      return a && Lt.forEach(function(mo) {
        return l(me, mo);
      }), Wn && ea(me, Vt), Ct;
    }
    function St(me, pe, Se, qe) {
      var Ct = pt(Se);
      if (typeof Ct != "function")
        throw Error(h(150));
      if (Se = Ct.call(Se), Se == null)
        throw Error(h(151));
      for (var xt = Ct = null, Lt = pe, Vt = pe = 0, Ir = null, gn = Se.next(); Lt !== null && !gn.done; Vt++, gn = Se.next()) {
        Lt.index > Vt ? (Ir = Lt, Lt = null) : Ir = Lt.sibling;
        var mo = Fe(me, Lt, gn.value, qe);
        if (mo === null) {
          Lt === null && (Lt = Ir);
          break;
        }
        a && Lt && mo.alternate === null && l(me, Lt), pe = z(mo, pe, Vt), xt === null ? Ct = mo : xt.sibling = mo, xt = mo, Lt = Ir;
      }
      if (gn.done)
        return m(
          me,
          Lt
        ), Wn && ea(me, Vt), Ct;
      if (Lt === null) {
        for (; !gn.done; Vt++, gn = Se.next())
          gn = Ue(me, gn.value, qe), gn !== null && (pe = z(gn, pe, Vt), xt === null ? Ct = gn : xt.sibling = gn, xt = gn);
        return Wn && ea(me, Vt), Ct;
      }
      for (Lt = k(me, Lt); !gn.done; Vt++, gn = Se.next())
        gn = lt(Lt, me, Vt, gn.value, qe), gn !== null && (a && gn.alternate !== null && Lt.delete(gn.key === null ? Vt : gn.key), pe = z(gn, pe, Vt), xt === null ? Ct = gn : xt.sibling = gn, xt = gn);
      return a && Lt.forEach(function(Xx) {
        return l(me, Xx);
      }), Wn && ea(me, Vt), Ct;
    }
    function dr(me, pe, Se, qe) {
      if (typeof Se == "object" && Se !== null && Se.type === Le && Se.key === null && (Se = Se.props.children), typeof Se == "object" && Se !== null) {
        switch (Se.$$typeof) {
          case re:
            e: {
              for (var Ct = Se.key, xt = pe; xt !== null; ) {
                if (xt.key === Ct) {
                  if (Ct = Se.type, Ct === Le) {
                    if (xt.tag === 7) {
                      m(me, xt.sibling), pe = D(xt, Se.props.children), pe.return = me, me = pe;
                      break e;
                    }
                  } else if (xt.elementType === Ct || typeof Ct == "object" && Ct !== null && Ct.$$typeof === Mt && gv(Ct) === xt.type) {
                    m(me, xt.sibling), pe = D(xt, Se.props), pe.ref = Ul(me, xt, Se), pe.return = me, me = pe;
                    break e;
                  }
                  m(me, xt);
                  break;
                } else
                  l(me, xt);
                xt = xt.sibling;
              }
              Se.type === Le ? (pe = sl(Se.props.children, me.mode, qe, Se.key), pe.return = me, me = pe) : (qe = Gd(Se.type, Se.key, Se.props, null, me.mode, qe), qe.ref = Ul(me, pe, Se), qe.return = me, me = qe);
            }
            return G(me);
          case ve:
            e: {
              for (xt = Se.key; pe !== null; ) {
                if (pe.key === xt)
                  if (pe.tag === 4 && pe.stateNode.containerInfo === Se.containerInfo && pe.stateNode.implementation === Se.implementation) {
                    m(me, pe.sibling), pe = D(pe, Se.children || []), pe.return = me, me = pe;
                    break e;
                  } else {
                    m(me, pe);
                    break;
                  }
                else
                  l(me, pe);
                pe = pe.sibling;
              }
              pe = ol(Se, me.mode, qe), pe.return = me, me = pe;
            }
            return G(me);
          case Mt:
            return xt = Se._init, dr(me, pe, xt(Se._payload), qe);
        }
        if (Oa(Se))
          return yt(me, pe, Se, qe);
        if (pt(Se))
          return St(me, pe, Se, qe);
        gd(me, Se);
      }
      return typeof Se == "string" && Se !== "" || typeof Se == "number" ? (Se = "" + Se, pe !== null && pe.tag === 6 ? (m(me, pe.sibling), pe = D(pe, Se), pe.return = me, me = pe) : (m(me, pe), pe = vc(Se, me.mode, qe), pe.return = me, me = pe), G(me)) : m(me, pe);
    }
    return dr;
  }
  var Bl = vv(!0), mv = vv(!1), Ku = {}, Ya = Jt(Ku), Ju = Jt(Ku), Wl = Jt(Ku);
  function Bo(a) {
    if (a === Ku)
      throw Error(h(174));
    return a;
  }
  function Th(a, l) {
    switch (An(Wl, l), An(Ju, a), An(Ya, Ku), a = l.nodeType, a) {
      case 9:
      case 11:
        l = (l = l.documentElement) ? l.namespaceURI : ir(null, "");
        break;
      default:
        a = a === 8 ? l.parentNode : l, l = a.namespaceURI || null, a = a.tagName, l = ir(l, a);
    }
    Sn(Ya), An(Ya, l);
  }
  function lo() {
    Sn(Ya), Sn(Ju), Sn(Wl);
  }
  function Nt(a) {
    Bo(Wl.current);
    var l = Bo(Ya.current), m = ir(l, a.type);
    l !== m && (An(Ju, a), An(Ya, m));
  }
  function nn(a) {
    Ju.current === a && (Sn(Ya), Sn(Ju));
  }
  var Ft = Jt(0);
  function Kn(a) {
    for (var l = a; l !== null; ) {
      if (l.tag === 13) {
        var m = l.memoizedState;
        if (m !== null && (m = m.dehydrated, m === null || m.data === "$?" || m.data === "$!"))
          return l;
      } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
        if (l.flags & 128)
          return l;
      } else if (l.child !== null) {
        l.child.return = l, l = l.child;
        continue;
      }
      if (l === a)
        break;
      for (; l.sibling === null; ) {
        if (l.return === null || l.return === a)
          return null;
        l = l.return;
      }
      l.sibling.return = l.return, l = l.sibling;
    }
    return null;
  }
  var ya = [];
  function vd() {
    for (var a = 0; a < ya.length; a++)
      ya[a]._workInProgressVersionPrimary = null;
    ya.length = 0;
  }
  var md = Ee.ReactCurrentDispatcher, Eh = Ee.ReactCurrentBatchConfig, Wo = 0, Xn = null, Pe = null, dn = null, Yt = !1, qa = !1, ra = 0, Xo = 0;
  function Vn() {
    throw Error(h(321));
  }
  function Vo(a, l) {
    if (l === null)
      return !1;
    for (var m = 0; m < l.length && m < a.length; m++)
      if (!fa(a[m], l[m]))
        return !1;
    return !0;
  }
  function uo(a, l, m, k, D, z) {
    if (Wo = z, Xn = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, md.current = a === null || a.memoizedState === null ? Ex : Rx, a = m(k, D), qa) {
      z = 0;
      do {
        if (qa = !1, ra = 0, 25 <= z)
          throw Error(h(301));
        z += 1, dn = Pe = null, l.updateQueue = null, md.current = Lh, a = m(k, D);
      } while (qa);
    }
    if (md.current = _d, l = Pe !== null && Pe.next !== null, Wo = 0, dn = Pe = Xn = null, Yt = !1, l)
      throw Error(h(300));
    return a;
  }
  function Go() {
    var a = ra !== 0;
    return ra = 0, a;
  }
  function xa() {
    var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return dn === null ? Xn.memoizedState = dn = a : dn = dn.next = a, dn;
  }
  function Fi() {
    if (Pe === null) {
      var a = Xn.alternate;
      a = a !== null ? a.memoizedState : null;
    } else
      a = Pe.next;
    var l = dn === null ? Xn.memoizedState : dn.next;
    if (l !== null)
      dn = l, Pe = a;
    else {
      if (a === null)
        throw Error(h(310));
      Pe = a, a = { memoizedState: Pe.memoizedState, baseState: Pe.baseState, baseQueue: Pe.baseQueue, queue: Pe.queue, next: null }, dn === null ? Xn.memoizedState = dn = a : dn = dn.next = a;
    }
    return dn;
  }
  function $o(a, l) {
    return typeof l == "function" ? l(a) : l;
  }
  function ec(a) {
    var l = Fi(), m = l.queue;
    if (m === null)
      throw Error(h(311));
    m.lastRenderedReducer = a;
    var k = Pe, D = k.baseQueue, z = m.pending;
    if (z !== null) {
      if (D !== null) {
        var G = D.next;
        D.next = z.next, z.next = G;
      }
      k.baseQueue = D = z, m.pending = null;
    }
    if (D !== null) {
      z = D.next, k = k.baseState;
      var ie = G = null, ce = null, Te = z;
      do {
        var He = Te.lane;
        if ((Wo & He) === He)
          ce !== null && (ce = ce.next = { lane: 0, action: Te.action, hasEagerState: Te.hasEagerState, eagerState: Te.eagerState, next: null }), k = Te.hasEagerState ? Te.eagerState : a(k, Te.action);
        else {
          var Ue = {
            lane: He,
            action: Te.action,
            hasEagerState: Te.hasEagerState,
            eagerState: Te.eagerState,
            next: null
          };
          ce === null ? (ie = ce = Ue, G = k) : ce = ce.next = Ue, Xn.lanes |= He, Es |= He;
        }
        Te = Te.next;
      } while (Te !== null && Te !== z);
      ce === null ? G = k : ce.next = ie, fa(k, l.memoizedState) || (yr = !0), l.memoizedState = k, l.baseState = G, l.baseQueue = ce, m.lastRenderedState = k;
    }
    if (a = m.interleaved, a !== null) {
      D = a;
      do
        z = D.lane, Xn.lanes |= z, Es |= z, D = D.next;
      while (D !== a);
    } else
      D === null && (m.lanes = 0);
    return [l.memoizedState, m.dispatch];
  }
  function tc(a) {
    var l = Fi(), m = l.queue;
    if (m === null)
      throw Error(h(311));
    m.lastRenderedReducer = a;
    var k = m.dispatch, D = m.pending, z = l.memoizedState;
    if (D !== null) {
      m.pending = null;
      var G = D = D.next;
      do
        z = a(z, G.action), G = G.next;
      while (G !== D);
      fa(z, l.memoizedState) || (yr = !0), l.memoizedState = z, l.baseQueue === null && (l.baseState = z), m.lastRenderedState = z;
    }
    return [z, k];
  }
  function yd() {
  }
  function xd(a, l) {
    var m = Xn, k = Fi(), D = l(), z = !fa(k.memoizedState, D);
    if (z && (k.memoizedState = D, yr = !0), k = k.queue, nc(Sd.bind(null, m, k, a), [a]), k.getSnapshot !== l || z || dn !== null && dn.memoizedState.tag & 1) {
      if (m.flags |= 2048, qo(9, wd.bind(null, m, k, D, l), void 0, null), Jn === null)
        throw Error(h(349));
      Wo & 30 || bd(m, l, D);
    }
    return D;
  }
  function bd(a, l, m) {
    a.flags |= 16384, a = { getSnapshot: l, value: m }, l = Xn.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, Xn.updateQueue = l, l.stores = [a]) : (m = l.stores, m === null ? l.stores = [a] : m.push(a));
  }
  function wd(a, l, m, k) {
    l.value = m, l.getSnapshot = k, kd(l) && Cd(a);
  }
  function Sd(a, l, m) {
    return m(function() {
      kd(l) && Cd(a);
    });
  }
  function kd(a) {
    var l = a.getSnapshot;
    a = a.value;
    try {
      var m = l();
      return !fa(a, m);
    } catch {
      return !0;
    }
  }
  function Cd(a) {
    var l = Ss(a, 1);
    l !== null && hi(l, a, 1, -1);
  }
  function Ad(a) {
    var l = xa();
    return typeof a == "function" && (a = a()), l.memoizedState = l.baseState = a, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: $o, lastRenderedState: a }, l.queue = a, a = a.dispatch = Od.bind(null, Xn, a), [l.memoizedState, a];
  }
  function qo(a, l, m, k) {
    return a = { tag: a, create: l, destroy: m, deps: k, next: null }, l = Xn.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, Xn.updateQueue = l, l.lastEffect = a.next = a) : (m = l.lastEffect, m === null ? l.lastEffect = a.next = a : (k = m.next, m.next = a, a.next = k, l.lastEffect = a)), a;
  }
  function Td() {
    return Fi().memoizedState;
  }
  function Zo(a, l, m, k) {
    var D = xa();
    Xn.flags |= a, D.memoizedState = qo(1 | l, m, void 0, k === void 0 ? null : k);
  }
  function Cs(a, l, m, k) {
    var D = Fi();
    k = k === void 0 ? null : k;
    var z = void 0;
    if (Pe !== null) {
      var G = Pe.memoizedState;
      if (z = G.destroy, k !== null && Vo(k, G.deps)) {
        D.memoizedState = qo(l, m, z, k);
        return;
      }
    }
    Xn.flags |= a, D.memoizedState = qo(1 | l, m, z, k);
  }
  function Ed(a, l) {
    return Zo(8390656, 8, a, l);
  }
  function nc(a, l) {
    return Cs(2048, 8, a, l);
  }
  function Rd(a, l) {
    return Cs(4, 2, a, l);
  }
  function Ld(a, l) {
    return Cs(4, 4, a, l);
  }
  function Rh(a, l) {
    if (typeof l == "function")
      return a = a(), l(a), function() {
        l(null);
      };
    if (l != null)
      return a = a(), l.current = a, function() {
        l.current = null;
      };
  }
  function Xl(a, l, m) {
    return m = m != null ? m.concat([a]) : null, Cs(4, 4, Rh.bind(null, l, a), m);
  }
  function Md() {
  }
  function Vl(a, l) {
    var m = Fi();
    l = l === void 0 ? null : l;
    var k = m.memoizedState;
    return k !== null && l !== null && Vo(l, k[1]) ? k[0] : (m.memoizedState = [a, l], a);
  }
  function co(a, l) {
    var m = Fi();
    l = l === void 0 ? null : l;
    var k = m.memoizedState;
    return k !== null && l !== null && Vo(l, k[1]) ? k[0] : (a = a(), m.memoizedState = [a, l], a);
  }
  function Yi(a, l, m) {
    return Wo & 21 ? (fa(m, l) || (m = oe(), Xn.lanes |= m, Es |= m, a.baseState = !0), l) : (a.baseState && (a.baseState = !1, yr = !0), a.memoizedState = m);
  }
  function Tx(a, l) {
    var m = Ie;
    Ie = m !== 0 && 4 > m ? m : 4, a(!0);
    var k = Eh.transition;
    Eh.transition = {};
    try {
      a(!1), l();
    } finally {
      Ie = m, Eh.transition = k;
    }
  }
  function Fn() {
    return Fi().memoizedState;
  }
  function Dd(a, l, m) {
    var k = xr(a);
    if (m = { lane: k, action: m, hasEagerState: !1, eagerState: null, next: null }, Gl(a))
      rc(l, m);
    else if (m = cv(a, l, m, k), m !== null) {
      var D = fi();
      hi(m, a, k, D), yv(m, l, k);
    }
  }
  function Od(a, l, m) {
    var k = xr(a), D = { lane: k, action: m, hasEagerState: !1, eagerState: null, next: null };
    if (Gl(a))
      rc(l, D);
    else {
      var z = a.alternate;
      if (a.lanes === 0 && (z === null || z.lanes === 0) && (z = l.lastRenderedReducer, z !== null))
        try {
          var G = l.lastRenderedState, ie = z(G, m);
          if (D.hasEagerState = !0, D.eagerState = ie, fa(ie, G)) {
            var ce = l.interleaved;
            ce === null ? (D.next = D, Sh(l)) : (D.next = ce.next, ce.next = D), l.interleaved = D;
            return;
          }
        } catch {
        } finally {
        }
      m = cv(a, l, D, k), m !== null && (D = fi(), hi(m, a, k, D), yv(m, l, k));
    }
  }
  function Gl(a) {
    var l = a.alternate;
    return a === Xn || l !== null && l === Xn;
  }
  function rc(a, l) {
    qa = Yt = !0;
    var m = a.pending;
    m === null ? l.next = l : (l.next = m.next, m.next = l), a.pending = l;
  }
  function yv(a, l, m) {
    if (m & 4194240) {
      var k = l.lanes;
      k &= a.pendingLanes, m |= k, l.lanes = m, Me(a, m);
    }
  }
  var _d = { readContext: cr, useCallback: Vn, useContext: Vn, useEffect: Vn, useImperativeHandle: Vn, useInsertionEffect: Vn, useLayoutEffect: Vn, useMemo: Vn, useReducer: Vn, useRef: Vn, useState: Vn, useDebugValue: Vn, useDeferredValue: Vn, useTransition: Vn, useMutableSource: Vn, useSyncExternalStore: Vn, useId: Vn, unstable_isNewReconciler: !1 }, Ex = { readContext: cr, useCallback: function(a, l) {
    return xa().memoizedState = [a, l === void 0 ? null : l], a;
  }, useContext: cr, useEffect: Ed, useImperativeHandle: function(a, l, m) {
    return m = m != null ? m.concat([a]) : null, Zo(
      4194308,
      4,
      Rh.bind(null, l, a),
      m
    );
  }, useLayoutEffect: function(a, l) {
    return Zo(4194308, 4, a, l);
  }, useInsertionEffect: function(a, l) {
    return Zo(4, 2, a, l);
  }, useMemo: function(a, l) {
    var m = xa();
    return l = l === void 0 ? null : l, a = a(), m.memoizedState = [a, l], a;
  }, useReducer: function(a, l, m) {
    var k = xa();
    return l = m !== void 0 ? m(l) : l, k.memoizedState = k.baseState = l, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: l }, k.queue = a, a = a.dispatch = Dd.bind(null, Xn, a), [k.memoizedState, a];
  }, useRef: function(a) {
    var l = xa();
    return a = { current: a }, l.memoizedState = a;
  }, useState: Ad, useDebugValue: Md, useDeferredValue: function(a) {
    return xa().memoizedState = a;
  }, useTransition: function() {
    var a = Ad(!1), l = a[0];
    return a = Tx.bind(null, a[1]), xa().memoizedState = a, [l, a];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a, l, m) {
    var k = Xn, D = xa();
    if (Wn) {
      if (m === void 0)
        throw Error(h(407));
      m = m();
    } else {
      if (m = l(), Jn === null)
        throw Error(h(349));
      Wo & 30 || bd(k, l, m);
    }
    D.memoizedState = m;
    var z = { value: m, getSnapshot: l };
    return D.queue = z, Ed(Sd.bind(
      null,
      k,
      z,
      a
    ), [a]), k.flags |= 2048, qo(9, wd.bind(null, k, z, m, l), void 0, null), m;
  }, useId: function() {
    var a = xa(), l = Jn.identifierPrefix;
    if (Wn) {
      var m = ws, k = Ur;
      m = (k & ~(1 << 32 - P(k) - 1)).toString(32) + m, l = ":" + l + "R" + m, m = ra++, 0 < m && (l += "H" + m.toString(32)), l += ":";
    } else
      m = Xo++, l = ":" + l + "r" + m.toString(32) + ":";
    return a.memoizedState = l;
  }, unstable_isNewReconciler: !1 }, Rx = {
    readContext: cr,
    useCallback: Vl,
    useContext: cr,
    useEffect: nc,
    useImperativeHandle: Xl,
    useInsertionEffect: Rd,
    useLayoutEffect: Ld,
    useMemo: co,
    useReducer: ec,
    useRef: Td,
    useState: function() {
      return ec($o);
    },
    useDebugValue: Md,
    useDeferredValue: function(a) {
      var l = Fi();
      return Yi(l, Pe.memoizedState, a);
    },
    useTransition: function() {
      var a = ec($o)[0], l = Fi().memoizedState;
      return [a, l];
    },
    useMutableSource: yd,
    useSyncExternalStore: xd,
    useId: Fn,
    unstable_isNewReconciler: !1
  }, Lh = { readContext: cr, useCallback: Vl, useContext: cr, useEffect: nc, useImperativeHandle: Xl, useInsertionEffect: Rd, useLayoutEffect: Ld, useMemo: co, useReducer: tc, useRef: Td, useState: function() {
    return tc($o);
  }, useDebugValue: Md, useDeferredValue: function(a) {
    var l = Fi();
    return Pe === null ? l.memoizedState = a : Yi(l, Pe.memoizedState, a);
  }, useTransition: function() {
    var a = tc($o)[0], l = Fi().memoizedState;
    return [a, l];
  }, useMutableSource: yd, useSyncExternalStore: xd, useId: Fn, unstable_isNewReconciler: !1 };
  function $l(a, l) {
    try {
      var m = "", k = l;
      do
        m += jt(k), k = k.return;
      while (k);
      var D = m;
    } catch (z) {
      D = `
Error generating stack: ` + z.message + `
` + z.stack;
    }
    return { value: a, source: l, stack: D, digest: null };
  }
  function ic(a, l, m) {
    return { value: a, source: null, stack: m ?? null, digest: l ?? null };
  }
  function Pd(a, l) {
    try {
      console.error(l.value);
    } catch (m) {
      setTimeout(function() {
        throw m;
      });
    }
  }
  var Lx = typeof WeakMap == "function" ? WeakMap : Map;
  function xv(a, l, m) {
    m = ks(-1, m), m.tag = 3, m.payload = { element: null };
    var k = l.value;
    return m.callback = function() {
      jd || (jd = !0, tl = k), Pd(a, l);
    }, m;
  }
  function ac(a, l, m) {
    m = ks(-1, m), m.tag = 3;
    var k = a.type.getDerivedStateFromError;
    if (typeof k == "function") {
      var D = l.value;
      m.payload = function() {
        return k(D);
      }, m.callback = function() {
        Pd(a, l);
      };
    }
    var z = a.stateNode;
    return z !== null && typeof z.componentDidCatch == "function" && (m.callback = function() {
      Pd(a, l), typeof k != "function" && (Ka === null ? Ka = /* @__PURE__ */ new Set([this]) : Ka.add(this));
      var G = l.stack;
      this.componentDidCatch(l.value, { componentStack: G !== null ? G : "" });
    }), m;
  }
  function bv(a, l, m) {
    var k = a.pingCache;
    if (k === null) {
      k = a.pingCache = new Lx();
      var D = /* @__PURE__ */ new Set();
      k.set(l, D);
    } else
      D = k.get(l), D === void 0 && (D = /* @__PURE__ */ new Set(), k.set(l, D));
    D.has(m) || (D.add(m), a = zx.bind(null, a, l, m), l.then(a, a));
  }
  function Mh(a) {
    do {
      var l;
      if ((l = a.tag === 13) && (l = a.memoizedState, l = l !== null ? l.dehydrated !== null : !0), l)
        return a;
      a = a.return;
    } while (a !== null);
    return null;
  }
  function Dh(a, l, m, k, D) {
    return a.mode & 1 ? (a.flags |= 65536, a.lanes = D, a) : (a === l ? a.flags |= 65536 : (a.flags |= 128, m.flags |= 131072, m.flags &= -52805, m.tag === 1 && (m.alternate === null ? m.tag = 17 : (l = ks(-1, 1), l.tag = 2, so(m, l, 1))), m.lanes |= 1), a);
  }
  var Mx = Ee.ReactCurrentOwner, yr = !1;
  function kr(a, l, m, k) {
    l.child = a === null ? mv(l, null, m, k) : Bl(l, a.child, m, k);
  }
  function fo(a, l, m, k, D) {
    m = m.render;
    var z = l.ref;
    return tt(l, D), k = uo(a, l, m, k, z, D), m = Go(), a !== null && !yr ? (l.updateQueue = a.updateQueue, l.flags &= -2053, a.lanes &= ~D, Wr(a, l, D)) : (Wn && m && sd(l), l.flags |= 1, kr(a, l, k, D), l.child);
  }
  function Nd(a, l, m, k, D) {
    if (a === null) {
      var z = m.type;
      return typeof z == "function" && !Zh(z) && z.defaultProps === void 0 && m.compare === null && m.defaultProps === void 0 ? (l.tag = 15, l.type = z, Hi(a, l, z, k, D)) : (a = Gd(m.type, null, k, l, l.mode, D), a.ref = l.ref, a.return = l, l.child = a);
    }
    if (z = a.child, !(a.lanes & D)) {
      var G = z.memoizedProps;
      if (m = m.compare, m = m !== null ? m : Hu, m(G, k) && a.ref === l.ref)
        return Wr(a, l, D);
    }
    return l.flags |= 1, a = vo(z, k), a.ref = l.ref, a.return = l, l.child = a;
  }
  function Hi(a, l, m, k, D) {
    if (a !== null) {
      var z = a.memoizedProps;
      if (Hu(z, k) && a.ref === l.ref)
        if (yr = !1, l.pendingProps = k = z, (a.lanes & D) !== 0)
          a.flags & 131072 && (yr = !0);
        else
          return l.lanes = a.lanes, Wr(a, l, D);
    }
    return ql(a, l, m, k, D);
  }
  function Qo(a, l, m) {
    var k = l.pendingProps, D = k.children, z = a !== null ? a.memoizedState : null;
    if (k.mode === "hidden")
      if (!(l.mode & 1))
        l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, An(tu, ia), ia |= m;
      else {
        if (!(m & 1073741824))
          return a = z !== null ? z.baseLanes | m : m, l.lanes = l.childLanes = 1073741824, l.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, l.updateQueue = null, An(tu, ia), ia |= a, null;
        l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, k = z !== null ? z.baseLanes : m, An(tu, ia), ia |= k;
      }
    else
      z !== null ? (k = z.baseLanes | m, l.memoizedState = null) : k = m, An(tu, ia), ia |= k;
    return kr(a, l, D, m), l.child;
  }
  function en(a, l) {
    var m = l.ref;
    (a === null && m !== null || a !== null && a.ref !== m) && (l.flags |= 512, l.flags |= 2097152);
  }
  function ql(a, l, m, k, D) {
    var z = qn(m) ? _i : Xt.current;
    return z = pa(l, z), tt(l, D), m = uo(a, l, m, k, z, D), k = Go(), a !== null && !yr ? (l.updateQueue = a.updateQueue, l.flags &= -2053, a.lanes &= ~D, Wr(a, l, D)) : (Wn && k && sd(l), l.flags |= 1, kr(a, l, m, D), l.child);
  }
  function Oh(a, l, m, k, D) {
    if (qn(m)) {
      var z = !0;
      ad(l);
    } else
      z = !1;
    if (tt(l, D), l.stateNode === null)
      ui(a, l), hv(l, m, k), pd(l, m, k, D), k = !0;
    else if (a === null) {
      var G = l.stateNode, ie = l.memoizedProps;
      G.props = ie;
      var ce = G.context, Te = m.contextType;
      typeof Te == "object" && Te !== null ? Te = cr(Te) : (Te = qn(m) ? _i : Xt.current, Te = pa(l, Te));
      var He = m.getDerivedStateFromProps, Ue = typeof He == "function" || typeof G.getSnapshotBeforeUpdate == "function";
      Ue || typeof G.UNSAFE_componentWillReceiveProps != "function" && typeof G.componentWillReceiveProps != "function" || (ie !== k || ce !== Te) && pv(l, G, k, Te), ao = !1;
      var Fe = l.memoizedState;
      G.state = Fe, oo(l, k, G, D), ce = l.memoizedState, ie !== k || Fe !== ce || sr.current || ao ? (typeof He == "function" && (Ah(l, m, He, k), ce = l.memoizedState), (ie = ao || fv(l, m, ie, k, Fe, ce, Te)) ? (Ue || typeof G.UNSAFE_componentWillMount != "function" && typeof G.componentWillMount != "function" || (typeof G.componentWillMount == "function" && G.componentWillMount(), typeof G.UNSAFE_componentWillMount == "function" && G.UNSAFE_componentWillMount()), typeof G.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof G.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = k, l.memoizedState = ce), G.props = k, G.state = ce, G.context = Te, k = ie) : (typeof G.componentDidMount == "function" && (l.flags |= 4194308), k = !1);
    } else {
      G = l.stateNode, Sr(a, l), ie = l.memoizedProps, Te = l.type === l.elementType ? ie : na(l.type, ie), G.props = Te, Ue = l.pendingProps, Fe = G.context, ce = m.contextType, typeof ce == "object" && ce !== null ? ce = cr(ce) : (ce = qn(m) ? _i : Xt.current, ce = pa(l, ce));
      var lt = m.getDerivedStateFromProps;
      (He = typeof lt == "function" || typeof G.getSnapshotBeforeUpdate == "function") || typeof G.UNSAFE_componentWillReceiveProps != "function" && typeof G.componentWillReceiveProps != "function" || (ie !== Ue || Fe !== ce) && pv(l, G, k, ce), ao = !1, Fe = l.memoizedState, G.state = Fe, oo(l, k, G, D);
      var yt = l.memoizedState;
      ie !== Ue || Fe !== yt || sr.current || ao ? (typeof lt == "function" && (Ah(l, m, lt, k), yt = l.memoizedState), (Te = ao || fv(l, m, Te, k, Fe, yt, ce) || !1) ? (He || typeof G.UNSAFE_componentWillUpdate != "function" && typeof G.componentWillUpdate != "function" || (typeof G.componentWillUpdate == "function" && G.componentWillUpdate(k, yt, ce), typeof G.UNSAFE_componentWillUpdate == "function" && G.UNSAFE_componentWillUpdate(k, yt, ce)), typeof G.componentDidUpdate == "function" && (l.flags |= 4), typeof G.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof G.componentDidUpdate != "function" || ie === a.memoizedProps && Fe === a.memoizedState || (l.flags |= 4), typeof G.getSnapshotBeforeUpdate != "function" || ie === a.memoizedProps && Fe === a.memoizedState || (l.flags |= 1024), l.memoizedProps = k, l.memoizedState = yt), G.props = k, G.state = yt, G.context = ce, k = Te) : (typeof G.componentDidUpdate != "function" || ie === a.memoizedProps && Fe === a.memoizedState || (l.flags |= 4), typeof G.getSnapshotBeforeUpdate != "function" || ie === a.memoizedProps && Fe === a.memoizedState || (l.flags |= 1024), k = !1);
    }
    return wv(a, l, m, k, z, D);
  }
  function wv(a, l, m, k, D, z) {
    en(a, l);
    var G = (l.flags & 128) !== 0;
    if (!k && !G)
      return D && sv(l, m, !1), Wr(a, l, z);
    k = l.stateNode, Mx.current = l;
    var ie = G && typeof m.getDerivedStateFromError != "function" ? null : k.render();
    return l.flags |= 1, a !== null && G ? (l.child = Bl(l, a.child, null, z), l.child = Bl(l, null, ie, z)) : kr(a, l, ie, z), l.memoizedState = k.state, D && sv(l, m, !0), l.child;
  }
  function Sv(a) {
    var l = a.stateNode;
    l.pendingContext ? to(a, l.pendingContext, l.pendingContext !== l.context) : l.context && to(a, l.context, !1), Th(a, l.containerInfo);
  }
  function zd(a, l, m, k, D) {
    return Qn(), xh(D), l.flags |= 256, kr(a, l, m, k), l.child;
  }
  var Ko = { dehydrated: null, treeContext: null, retryLane: 0 };
  function _h(a) {
    return { baseLanes: a, cachePool: null, transitions: null };
  }
  function Ph(a, l, m) {
    var k = l.pendingProps, D = Ft.current, z = !1, G = (l.flags & 128) !== 0, ie;
    if ((ie = G) || (ie = a !== null && a.memoizedState === null ? !1 : (D & 2) !== 0), ie ? (z = !0, l.flags &= -129) : (a === null || a.memoizedState !== null) && (D |= 1), An(Ft, D & 1), a === null)
      return ld(l), a = l.memoizedState, a !== null && (a = a.dehydrated, a !== null) ? (l.mode & 1 ? a.data === "$!" ? l.lanes = 8 : l.lanes = 1073741824 : l.lanes = 1, null) : (G = k.children, a = k.fallback, z ? (k = l.mode, z = l.child, G = { mode: "hidden", children: G }, !(k & 1) && z !== null ? (z.childLanes = 0, z.pendingProps = G) : z = gc(G, k, 0, null), a = sl(a, k, m, null), z.return = l, a.return = l, z.sibling = a, l.child = z, l.child.memoizedState = _h(m), l.memoizedState = Ko, a) : Nh(l, G));
    if (D = a.memoizedState, D !== null && (ie = D.dehydrated, ie !== null))
      return Dx(a, l, G, k, ie, D, m);
    if (z) {
      z = k.fallback, G = l.mode, D = a.child, ie = D.sibling;
      var ce = { mode: "hidden", children: k.children };
      return !(G & 1) && l.child !== D ? (k = l.child, k.childLanes = 0, k.pendingProps = ce, l.deletions = null) : (k = vo(D, ce), k.subtreeFlags = D.subtreeFlags & 14680064), ie !== null ? z = vo(ie, z) : (z = sl(z, G, m, null), z.flags |= 2), z.return = l, k.return = l, k.sibling = z, l.child = k, k = z, z = l.child, G = a.child.memoizedState, G = G === null ? _h(m) : { baseLanes: G.baseLanes | m, cachePool: null, transitions: G.transitions }, z.memoizedState = G, z.childLanes = a.childLanes & ~m, l.memoizedState = Ko, k;
    }
    return z = a.child, a = z.sibling, k = vo(z, { mode: "visible", children: k.children }), !(l.mode & 1) && (k.lanes = m), k.return = l, k.sibling = null, a !== null && (m = l.deletions, m === null ? (l.deletions = [a], l.flags |= 16) : m.push(a)), l.child = k, l.memoizedState = null, k;
  }
  function Nh(a, l) {
    return l = gc({ mode: "visible", children: l }, a.mode, 0, null), l.return = a, a.child = l;
  }
  function Zl(a, l, m, k) {
    return k !== null && xh(k), Bl(l, a.child, null, m), a = Nh(l, l.pendingProps.children), a.flags |= 2, l.memoizedState = null, a;
  }
  function Dx(a, l, m, k, D, z, G) {
    if (m)
      return l.flags & 256 ? (l.flags &= -257, k = ic(Error(h(422))), Zl(a, l, G, k)) : l.memoizedState !== null ? (l.child = a.child, l.flags |= 128, null) : (z = k.fallback, D = l.mode, k = gc({ mode: "visible", children: k.children }, D, 0, null), z = sl(z, D, G, null), z.flags |= 2, k.return = l, z.return = l, k.sibling = z, l.child = k, l.mode & 1 && Bl(l, a.child, null, G), l.child.memoizedState = _h(G), l.memoizedState = Ko, z);
    if (!(l.mode & 1))
      return Zl(a, l, G, null);
    if (D.data === "$!") {
      if (k = D.nextSibling && D.nextSibling.dataset, k)
        var ie = k.dgst;
      return k = ie, z = Error(h(419)), k = ic(z, k, void 0), Zl(a, l, G, k);
    }
    if (ie = (G & a.childLanes) !== 0, yr || ie) {
      if (k = Jn, k !== null) {
        switch (G & -G) {
          case 4:
            D = 2;
            break;
          case 16:
            D = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            D = 32;
            break;
          case 536870912:
            D = 268435456;
            break;
          default:
            D = 0;
        }
        D = D & (k.suspendedLanes | G) ? 0 : D, D !== 0 && D !== z.retryLane && (z.retryLane = D, Ss(a, D), hi(k, a, D, -1));
      }
      return Gh(), k = ic(Error(h(421))), Zl(a, l, G, k);
    }
    return D.data === "$?" ? (l.flags |= 128, l.child = a.child, l = Ix.bind(null, a), D._reactRetry = l, null) : (a = z.treeContext, Ii = Fa(D.nextSibling), ta = l, Wn = !0, ma = null, a !== null && (zi[li++] = Ur, zi[li++] = ws, zi[li++] = va, Ur = a.id, ws = a.overflow, va = l), l = Nh(l, k.children), l.flags |= 4096, l);
  }
  function zh(a, l, m) {
    a.lanes |= l;
    var k = a.alternate;
    k !== null && (k.lanes |= l), Pr(a.return, l, m);
  }
  function Id(a, l, m, k, D) {
    var z = a.memoizedState;
    z === null ? a.memoizedState = { isBackwards: l, rendering: null, renderingStartTime: 0, last: k, tail: m, tailMode: D } : (z.isBackwards = l, z.rendering = null, z.renderingStartTime = 0, z.last = k, z.tail = m, z.tailMode = D);
  }
  function Ih(a, l, m) {
    var k = l.pendingProps, D = k.revealOrder, z = k.tail;
    if (kr(a, l, k.children, m), k = Ft.current, k & 2)
      k = k & 1 | 2, l.flags |= 128;
    else {
      if (a !== null && a.flags & 128)
        e:
          for (a = l.child; a !== null; ) {
            if (a.tag === 13)
              a.memoizedState !== null && zh(a, m, l);
            else if (a.tag === 19)
              zh(a, m, l);
            else if (a.child !== null) {
              a.child.return = a, a = a.child;
              continue;
            }
            if (a === l)
              break e;
            for (; a.sibling === null; ) {
              if (a.return === null || a.return === l)
                break e;
              a = a.return;
            }
            a.sibling.return = a.return, a = a.sibling;
          }
      k &= 1;
    }
    if (An(Ft, k), !(l.mode & 1))
      l.memoizedState = null;
    else
      switch (D) {
        case "forwards":
          for (m = l.child, D = null; m !== null; )
            a = m.alternate, a !== null && Kn(a) === null && (D = m), m = m.sibling;
          m = D, m === null ? (D = l.child, l.child = null) : (D = m.sibling, m.sibling = null), Id(l, !1, D, m, z);
          break;
        case "backwards":
          for (m = null, D = l.child, l.child = null; D !== null; ) {
            if (a = D.alternate, a !== null && Kn(a) === null) {
              l.child = D;
              break;
            }
            a = D.sibling, D.sibling = m, m = D, D = a;
          }
          Id(l, !0, m, null, z);
          break;
        case "together":
          Id(l, !1, null, null, void 0);
          break;
        default:
          l.memoizedState = null;
      }
    return l.child;
  }
  function ui(a, l) {
    !(l.mode & 1) && a !== null && (a.alternate = null, l.alternate = null, l.flags |= 2);
  }
  function Wr(a, l, m) {
    if (a !== null && (l.dependencies = a.dependencies), Es |= l.lanes, !(m & l.childLanes))
      return null;
    if (a !== null && l.child !== a.child)
      throw Error(h(153));
    if (l.child !== null) {
      for (a = l.child, m = vo(a, a.pendingProps), l.child = m, m.return = l; a.sibling !== null; )
        a = a.sibling, m = m.sibling = vo(a, a.pendingProps), m.return = l;
      m.sibling = null;
    }
    return l.child;
  }
  function As(a, l, m) {
    switch (l.tag) {
      case 3:
        Sv(l), Qn();
        break;
      case 5:
        Nt(l);
        break;
      case 1:
        qn(l.type) && ad(l);
        break;
      case 4:
        Th(l, l.stateNode.containerInfo);
        break;
      case 10:
        var k = l.type._context, D = l.memoizedProps.value;
        An($a, k._currentValue), k._currentValue = D;
        break;
      case 13:
        if (k = l.memoizedState, k !== null)
          return k.dehydrated !== null ? (An(Ft, Ft.current & 1), l.flags |= 128, null) : m & l.child.childLanes ? Ph(a, l, m) : (An(Ft, Ft.current & 1), a = Wr(a, l, m), a !== null ? a.sibling : null);
        An(Ft, Ft.current & 1);
        break;
      case 19:
        if (k = (m & l.childLanes) !== 0, a.flags & 128) {
          if (k)
            return Ih(a, l, m);
          l.flags |= 128;
        }
        if (D = l.memoizedState, D !== null && (D.rendering = null, D.tail = null, D.lastEffect = null), An(Ft, Ft.current), k)
          break;
        return null;
      case 22:
      case 23:
        return l.lanes = 0, Qo(a, l, m);
    }
    return Wr(a, l, m);
  }
  var sc, Jo, ba, Cr;
  sc = function(a, l) {
    for (var m = l.child; m !== null; ) {
      if (m.tag === 5 || m.tag === 6)
        a.appendChild(m.stateNode);
      else if (m.tag !== 4 && m.child !== null) {
        m.child.return = m, m = m.child;
        continue;
      }
      if (m === l)
        break;
      for (; m.sibling === null; ) {
        if (m.return === null || m.return === l)
          return;
        m = m.return;
      }
      m.sibling.return = m.return, m = m.sibling;
    }
  }, Jo = function() {
  }, ba = function(a, l, m, k) {
    var D = a.memoizedProps;
    if (D !== k) {
      a = l.stateNode, Bo(Ya.current);
      var z = null;
      switch (m) {
        case "input":
          D = jn(a, D), k = jn(a, k), z = [];
          break;
        case "select":
          D = ye({}, D, { value: void 0 }), k = ye({}, k, { value: void 0 }), z = [];
          break;
        case "textarea":
          D = Zi(a, D), k = Zi(a, k), z = [];
          break;
        default:
          typeof D.onClick != "function" && typeof k.onClick == "function" && (a.onclick = id);
      }
      pr(m, k);
      var G;
      m = null;
      for (Te in D)
        if (!k.hasOwnProperty(Te) && D.hasOwnProperty(Te) && D[Te] != null)
          if (Te === "style") {
            var ie = D[Te];
            for (G in ie)
              ie.hasOwnProperty(G) && (m || (m = {}), m[G] = "");
          } else
            Te !== "dangerouslySetInnerHTML" && Te !== "children" && Te !== "suppressContentEditableWarning" && Te !== "suppressHydrationWarning" && Te !== "autoFocus" && (w.hasOwnProperty(Te) ? z || (z = []) : (z = z || []).push(Te, null));
      for (Te in k) {
        var ce = k[Te];
        if (ie = D != null ? D[Te] : void 0, k.hasOwnProperty(Te) && ce !== ie && (ce != null || ie != null))
          if (Te === "style")
            if (ie) {
              for (G in ie)
                !ie.hasOwnProperty(G) || ce && ce.hasOwnProperty(G) || (m || (m = {}), m[G] = "");
              for (G in ce)
                ce.hasOwnProperty(G) && ie[G] !== ce[G] && (m || (m = {}), m[G] = ce[G]);
            } else
              m || (z || (z = []), z.push(
                Te,
                m
              )), m = ce;
          else
            Te === "dangerouslySetInnerHTML" ? (ce = ce ? ce.__html : void 0, ie = ie ? ie.__html : void 0, ce != null && ie !== ce && (z = z || []).push(Te, ce)) : Te === "children" ? typeof ce != "string" && typeof ce != "number" || (z = z || []).push(Te, "" + ce) : Te !== "suppressContentEditableWarning" && Te !== "suppressHydrationWarning" && (w.hasOwnProperty(Te) ? (ce != null && Te === "onScroll" && In("scroll", a), z || ie === ce || (z = [])) : (z = z || []).push(Te, ce));
      }
      m && (z = z || []).push("style", m);
      var Te = z;
      (l.updateQueue = Te) && (l.flags |= 4);
    }
  }, Cr = function(a, l, m, k) {
    m !== k && (l.flags |= 4);
  };
  function oc(a, l) {
    if (!Wn)
      switch (a.tailMode) {
        case "hidden":
          l = a.tail;
          for (var m = null; l !== null; )
            l.alternate !== null && (m = l), l = l.sibling;
          m === null ? a.tail = null : m.sibling = null;
          break;
        case "collapsed":
          m = a.tail;
          for (var k = null; m !== null; )
            m.alternate !== null && (k = m), m = m.sibling;
          k === null ? l || a.tail === null ? a.tail = null : a.tail.sibling = null : k.sibling = null;
      }
  }
  function ci(a) {
    var l = a.alternate !== null && a.alternate.child === a.child, m = 0, k = 0;
    if (l)
      for (var D = a.child; D !== null; )
        m |= D.lanes | D.childLanes, k |= D.subtreeFlags & 14680064, k |= D.flags & 14680064, D.return = a, D = D.sibling;
    else
      for (D = a.child; D !== null; )
        m |= D.lanes | D.childLanes, k |= D.subtreeFlags, k |= D.flags, D.return = a, D = D.sibling;
    return a.subtreeFlags |= k, a.childLanes = m, l;
  }
  function Ox(a, l, m) {
    var k = l.pendingProps;
    switch (mh(l), l.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ci(l), null;
      case 1:
        return qn(l.type) && ga(), ci(l), null;
      case 3:
        return k = l.stateNode, lo(), Sn(sr), Sn(Xt), vd(), k.pendingContext && (k.context = k.pendingContext, k.pendingContext = null), (a === null || a.child === null) && (ud(l) ? l.flags |= 4 : a === null || a.memoizedState.isDehydrated && !(l.flags & 256) || (l.flags |= 1024, ma !== null && (pc(ma), ma = null))), Jo(a, l), ci(l), null;
      case 5:
        nn(l);
        var D = Bo(Wl.current);
        if (m = l.type, a !== null && l.stateNode != null)
          ba(a, l, m, k, D), a.ref !== l.ref && (l.flags |= 512, l.flags |= 2097152);
        else {
          if (!k) {
            if (l.stateNode === null)
              throw Error(h(166));
            return ci(l), null;
          }
          if (a = Bo(Ya.current), ud(l)) {
            k = l.stateNode, m = l.type;
            var z = l.memoizedProps;
            switch (k[Va] = l, k[Ho] = z, a = (l.mode & 1) !== 0, m) {
              case "dialog":
                In("cancel", k), In("close", k);
                break;
              case "iframe":
              case "object":
              case "embed":
                In("load", k);
                break;
              case "video":
              case "audio":
                for (D = 0; D < Wu.length; D++)
                  In(Wu[D], k);
                break;
              case "source":
                In("error", k);
                break;
              case "img":
              case "image":
              case "link":
                In(
                  "error",
                  k
                ), In("load", k);
                break;
              case "details":
                In("toggle", k);
                break;
              case "input":
                rr(k, z), In("invalid", k);
                break;
              case "select":
                k._wrapperState = { wasMultiple: !!z.multiple }, In("invalid", k);
                break;
              case "textarea":
                mi(k, z), In("invalid", k);
            }
            pr(m, z), D = null;
            for (var G in z)
              if (z.hasOwnProperty(G)) {
                var ie = z[G];
                G === "children" ? typeof ie == "string" ? k.textContent !== ie && (z.suppressHydrationWarning !== !0 && rd(k.textContent, ie, a), D = ["children", ie]) : typeof ie == "number" && k.textContent !== "" + ie && (z.suppressHydrationWarning !== !0 && rd(
                  k.textContent,
                  ie,
                  a
                ), D = ["children", "" + ie]) : w.hasOwnProperty(G) && ie != null && G === "onScroll" && In("scroll", k);
              }
            switch (m) {
              case "input":
                vn(k), ei(k, z, !0);
                break;
              case "textarea":
                vn(k), yi(k);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof z.onClick == "function" && (k.onclick = id);
            }
            k = D, l.updateQueue = k, k !== null && (l.flags |= 4);
          } else {
            G = D.nodeType === 9 ? D : D.ownerDocument, a === "http://www.w3.org/1999/xhtml" && (a = ti(m)), a === "http://www.w3.org/1999/xhtml" ? m === "script" ? (a = G.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : typeof k.is == "string" ? a = G.createElement(m, { is: k.is }) : (a = G.createElement(m), m === "select" && (G = a, k.multiple ? G.multiple = !0 : k.size && (G.size = k.size))) : a = G.createElementNS(a, m), a[Va] = l, a[Ho] = k, sc(a, l, !1, !1), l.stateNode = a;
            e: {
              switch (G = $n(m, k), m) {
                case "dialog":
                  In("cancel", a), In("close", a), D = k;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  In("load", a), D = k;
                  break;
                case "video":
                case "audio":
                  for (D = 0; D < Wu.length; D++)
                    In(Wu[D], a);
                  D = k;
                  break;
                case "source":
                  In("error", a), D = k;
                  break;
                case "img":
                case "image":
                case "link":
                  In(
                    "error",
                    a
                  ), In("load", a), D = k;
                  break;
                case "details":
                  In("toggle", a), D = k;
                  break;
                case "input":
                  rr(a, k), D = jn(a, k), In("invalid", a);
                  break;
                case "option":
                  D = k;
                  break;
                case "select":
                  a._wrapperState = { wasMultiple: !!k.multiple }, D = ye({}, k, { value: void 0 }), In("invalid", a);
                  break;
                case "textarea":
                  mi(a, k), D = Zi(a, k), In("invalid", a);
                  break;
                default:
                  D = k;
              }
              pr(m, D), ie = D;
              for (z in ie)
                if (ie.hasOwnProperty(z)) {
                  var ce = ie[z];
                  z === "style" ? bn(a, ce) : z === "dangerouslySetInnerHTML" ? (ce = ce ? ce.__html : void 0, ce != null && _a(a, ce)) : z === "children" ? typeof ce == "string" ? (m !== "textarea" || ce !== "") && Qi(a, ce) : typeof ce == "number" && Qi(a, "" + ce) : z !== "suppressContentEditableWarning" && z !== "suppressHydrationWarning" && z !== "autoFocus" && (w.hasOwnProperty(z) ? ce != null && z === "onScroll" && In("scroll", a) : ce != null && we(a, z, ce, G));
                }
              switch (m) {
                case "input":
                  vn(a), ei(a, k, !1);
                  break;
                case "textarea":
                  vn(a), yi(a);
                  break;
                case "option":
                  k.value != null && a.setAttribute("value", "" + Et(k.value));
                  break;
                case "select":
                  a.multiple = !!k.multiple, z = k.value, z != null ? ca(a, !!k.multiple, z, !1) : k.defaultValue != null && ca(
                    a,
                    !!k.multiple,
                    k.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof D.onClick == "function" && (a.onclick = id);
              }
              switch (m) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k = !!k.autoFocus;
                  break e;
                case "img":
                  k = !0;
                  break e;
                default:
                  k = !1;
              }
            }
            k && (l.flags |= 4);
          }
          l.ref !== null && (l.flags |= 512, l.flags |= 2097152);
        }
        return ci(l), null;
      case 6:
        if (a && l.stateNode != null)
          Cr(a, l, a.memoizedProps, k);
        else {
          if (typeof k != "string" && l.stateNode === null)
            throw Error(h(166));
          if (m = Bo(Wl.current), Bo(Ya.current), ud(l)) {
            if (k = l.stateNode, m = l.memoizedProps, k[Va] = l, (z = k.nodeValue !== m) && (a = ta, a !== null))
              switch (a.tag) {
                case 3:
                  rd(k.nodeValue, m, (a.mode & 1) !== 0);
                  break;
                case 5:
                  a.memoizedProps.suppressHydrationWarning !== !0 && rd(k.nodeValue, m, (a.mode & 1) !== 0);
              }
            z && (l.flags |= 4);
          } else
            k = (m.nodeType === 9 ? m : m.ownerDocument).createTextNode(k), k[Va] = l, l.stateNode = k;
        }
        return ci(l), null;
      case 13:
        if (Sn(Ft), k = l.memoizedState, a === null || a.memoizedState !== null && a.memoizedState.dehydrated !== null) {
          if (Wn && Ii !== null && l.mode & 1 && !(l.flags & 128))
            uv(), Qn(), l.flags |= 98560, z = !1;
          else if (z = ud(l), k !== null && k.dehydrated !== null) {
            if (a === null) {
              if (!z)
                throw Error(h(318));
              if (z = l.memoizedState, z = z !== null ? z.dehydrated : null, !z)
                throw Error(h(317));
              z[Va] = l;
            } else
              Qn(), !(l.flags & 128) && (l.memoizedState = null), l.flags |= 4;
            ci(l), z = !1;
          } else
            ma !== null && (pc(ma), ma = null), z = !0;
          if (!z)
            return l.flags & 65536 ? l : null;
        }
        return l.flags & 128 ? (l.lanes = m, l) : (k = k !== null, k !== (a !== null && a.memoizedState !== null) && k && (l.child.flags |= 8192, l.mode & 1 && (a === null || Ft.current & 1 ? Tr === 0 && (Tr = 3) : Gh())), l.updateQueue !== null && (l.flags |= 4), ci(l), null);
      case 4:
        return lo(), Jo(a, l), a === null && Yl(l.stateNode.containerInfo), ci(l), null;
      case 10:
        return io(l.type._context), ci(l), null;
      case 17:
        return qn(l.type) && ga(), ci(l), null;
      case 19:
        if (Sn(Ft), z = l.memoizedState, z === null)
          return ci(l), null;
        if (k = (l.flags & 128) !== 0, G = z.rendering, G === null)
          if (k)
            oc(z, !1);
          else {
            if (Tr !== 0 || a !== null && a.flags & 128)
              for (a = l.child; a !== null; ) {
                if (G = Kn(a), G !== null) {
                  for (l.flags |= 128, oc(z, !1), k = G.updateQueue, k !== null && (l.updateQueue = k, l.flags |= 4), l.subtreeFlags = 0, k = m, m = l.child; m !== null; )
                    z = m, a = k, z.flags &= 14680066, G = z.alternate, G === null ? (z.childLanes = 0, z.lanes = a, z.child = null, z.subtreeFlags = 0, z.memoizedProps = null, z.memoizedState = null, z.updateQueue = null, z.dependencies = null, z.stateNode = null) : (z.childLanes = G.childLanes, z.lanes = G.lanes, z.child = G.child, z.subtreeFlags = 0, z.deletions = null, z.memoizedProps = G.memoizedProps, z.memoizedState = G.memoizedState, z.updateQueue = G.updateQueue, z.type = G.type, a = G.dependencies, z.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }), m = m.sibling;
                  return An(Ft, Ft.current & 1 | 2), l.child;
                }
                a = a.sibling;
              }
            z.tail !== null && o() > ru && (l.flags |= 128, k = !0, oc(z, !1), l.lanes = 4194304);
          }
        else {
          if (!k)
            if (a = Kn(G), a !== null) {
              if (l.flags |= 128, k = !0, m = a.updateQueue, m !== null && (l.updateQueue = m, l.flags |= 4), oc(z, !0), z.tail === null && z.tailMode === "hidden" && !G.alternate && !Wn)
                return ci(l), null;
            } else
              2 * o() - z.renderingStartTime > ru && m !== 1073741824 && (l.flags |= 128, k = !0, oc(z, !1), l.lanes = 4194304);
          z.isBackwards ? (G.sibling = l.child, l.child = G) : (m = z.last, m !== null ? m.sibling = G : l.child = G, z.last = G);
        }
        return z.tail !== null ? (l = z.tail, z.rendering = l, z.tail = l.sibling, z.renderingStartTime = o(), l.sibling = null, m = Ft.current, An(Ft, k ? m & 1 | 2 : m & 1), l) : (ci(l), null);
      case 22:
      case 23:
        return Vh(), k = l.memoizedState !== null, a !== null && a.memoizedState !== null !== k && (l.flags |= 8192), k && l.mode & 1 ? ia & 1073741824 && (ci(l), l.subtreeFlags & 6 && (l.flags |= 8192)) : ci(l), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(h(156, l.tag));
  }
  function Fh(a, l) {
    switch (mh(l), l.tag) {
      case 1:
        return qn(l.type) && ga(), a = l.flags, a & 65536 ? (l.flags = a & -65537 | 128, l) : null;
      case 3:
        return lo(), Sn(sr), Sn(Xt), vd(), a = l.flags, a & 65536 && !(a & 128) ? (l.flags = a & -65537 | 128, l) : null;
      case 5:
        return nn(l), null;
      case 13:
        if (Sn(Ft), a = l.memoizedState, a !== null && a.dehydrated !== null) {
          if (l.alternate === null)
            throw Error(h(340));
          Qn();
        }
        return a = l.flags, a & 65536 ? (l.flags = a & -65537 | 128, l) : null;
      case 19:
        return Sn(Ft), null;
      case 4:
        return lo(), null;
      case 10:
        return io(l.type._context), null;
      case 22:
      case 23:
        return Vh(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var lc = !1, Ar = !1, kv = typeof WeakSet == "function" ? WeakSet : Set, ht = null;
  function Ql(a, l) {
    var m = a.ref;
    if (m !== null)
      if (typeof m == "function")
        try {
          m(null);
        } catch (k) {
          lr(a, l, k);
        }
      else
        m.current = null;
  }
  function uc(a, l, m) {
    try {
      m();
    } catch (k) {
      lr(a, l, k);
    }
  }
  var Cv = !1;
  function Av(a, l) {
    if (uh = _o, a = Kc(), ms(a)) {
      if ("selectionStart" in a)
        var m = { start: a.selectionStart, end: a.selectionEnd };
      else
        e: {
          m = (m = a.ownerDocument) && m.defaultView || window;
          var k = m.getSelection && m.getSelection();
          if (k && k.rangeCount !== 0) {
            m = k.anchorNode;
            var D = k.anchorOffset, z = k.focusNode;
            k = k.focusOffset;
            try {
              m.nodeType, z.nodeType;
            } catch {
              m = null;
              break e;
            }
            var G = 0, ie = -1, ce = -1, Te = 0, He = 0, Ue = a, Fe = null;
            t:
              for (; ; ) {
                for (var lt; Ue !== m || D !== 0 && Ue.nodeType !== 3 || (ie = G + D), Ue !== z || k !== 0 && Ue.nodeType !== 3 || (ce = G + k), Ue.nodeType === 3 && (G += Ue.nodeValue.length), (lt = Ue.firstChild) !== null; )
                  Fe = Ue, Ue = lt;
                for (; ; ) {
                  if (Ue === a)
                    break t;
                  if (Fe === m && ++Te === D && (ie = G), Fe === z && ++He === k && (ce = G), (lt = Ue.nextSibling) !== null)
                    break;
                  Ue = Fe, Fe = Ue.parentNode;
                }
                Ue = lt;
              }
            m = ie === -1 || ce === -1 ? null : { start: ie, end: ce };
          } else
            m = null;
        }
      m = m || { start: 0, end: 0 };
    } else
      m = null;
    for (Fo = { focusedElem: a, selectionRange: m }, _o = !1, ht = l; ht !== null; )
      if (l = ht, a = l.child, (l.subtreeFlags & 1028) !== 0 && a !== null)
        a.return = l, ht = a;
      else
        for (; ht !== null; ) {
          l = ht;
          try {
            var yt = l.alternate;
            if (l.flags & 1024)
              switch (l.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (yt !== null) {
                    var St = yt.memoizedProps, dr = yt.memoizedState, me = l.stateNode, pe = me.getSnapshotBeforeUpdate(l.elementType === l.type ? St : na(l.type, St), dr);
                    me.__reactInternalSnapshotBeforeUpdate = pe;
                  }
                  break;
                case 3:
                  var Se = l.stateNode.containerInfo;
                  Se.nodeType === 1 ? Se.textContent = "" : Se.nodeType === 9 && Se.documentElement && Se.removeChild(Se.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(h(163));
              }
          } catch (qe) {
            lr(l, l.return, qe);
          }
          if (a = l.sibling, a !== null) {
            a.return = l.return, ht = a;
            break;
          }
          ht = l.return;
        }
    return yt = Cv, Cv = !1, yt;
  }
  function cc(a, l, m) {
    var k = l.updateQueue;
    if (k = k !== null ? k.lastEffect : null, k !== null) {
      var D = k = k.next;
      do {
        if ((D.tag & a) === a) {
          var z = D.destroy;
          D.destroy = void 0, z !== void 0 && uc(l, m, z);
        }
        D = D.next;
      } while (D !== k);
    }
  }
  function dc(a, l) {
    if (l = l.updateQueue, l = l !== null ? l.lastEffect : null, l !== null) {
      var m = l = l.next;
      do {
        if ((m.tag & a) === a) {
          var k = m.create;
          m.destroy = k();
        }
        m = m.next;
      } while (m !== l);
    }
  }
  function Yh(a) {
    var l = a.ref;
    if (l !== null) {
      var m = a.stateNode;
      switch (a.tag) {
        case 5:
          a = m;
          break;
        default:
          a = m;
      }
      typeof l == "function" ? l(a) : l.current = a;
    }
  }
  function Hh(a) {
    var l = a.alternate;
    l !== null && (a.alternate = null, Hh(l)), a.child = null, a.deletions = null, a.sibling = null, a.tag === 5 && (l = a.stateNode, l !== null && (delete l[Va], delete l[Ho], delete l[fh], delete l[Ax], delete l[hh])), a.stateNode = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
  }
  function Tv(a) {
    return a.tag === 5 || a.tag === 3 || a.tag === 4;
  }
  function Fd(a) {
    e:
      for (; ; ) {
        for (; a.sibling === null; ) {
          if (a.return === null || Tv(a.return))
            return null;
          a = a.return;
        }
        for (a.sibling.return = a.return, a = a.sibling; a.tag !== 5 && a.tag !== 6 && a.tag !== 18; ) {
          if (a.flags & 2 || a.child === null || a.tag === 4)
            continue e;
          a.child.return = a, a = a.child;
        }
        if (!(a.flags & 2))
          return a.stateNode;
      }
  }
  function Kl(a, l, m) {
    var k = a.tag;
    if (k === 5 || k === 6)
      a = a.stateNode, l ? m.nodeType === 8 ? m.parentNode.insertBefore(a, l) : m.insertBefore(a, l) : (m.nodeType === 8 ? (l = m.parentNode, l.insertBefore(a, m)) : (l = m, l.appendChild(a)), m = m._reactRootContainer, m != null || l.onclick !== null || (l.onclick = id));
    else if (k !== 4 && (a = a.child, a !== null))
      for (Kl(a, l, m), a = a.sibling; a !== null; )
        Kl(a, l, m), a = a.sibling;
  }
  function Za(a, l, m) {
    var k = a.tag;
    if (k === 5 || k === 6)
      a = a.stateNode, l ? m.insertBefore(a, l) : m.appendChild(a);
    else if (k !== 4 && (a = a.child, a !== null))
      for (Za(a, l, m), a = a.sibling; a !== null; )
        Za(a, l, m), a = a.sibling;
  }
  var Zn = null, Nr = !1;
  function wa(a, l, m) {
    for (m = m.child; m !== null; )
      Jl(a, l, m), m = m.sibling;
  }
  function Jl(a, l, m) {
    if (L && typeof L.onCommitFiberUnmount == "function")
      try {
        L.onCommitFiberUnmount(E, m);
      } catch {
      }
    switch (m.tag) {
      case 5:
        Ar || Ql(m, l);
      case 6:
        var k = Zn, D = Nr;
        Zn = null, wa(a, l, m), Zn = k, Nr = D, Zn !== null && (Nr ? (a = Zn, m = m.stateNode, a.nodeType === 8 ? a.parentNode.removeChild(m) : a.removeChild(m)) : Zn.removeChild(m.stateNode));
        break;
      case 18:
        Zn !== null && (Nr ? (a = Zn, m = m.stateNode, a.nodeType === 8 ? Ks(a.parentNode, m) : a.nodeType === 1 && Ks(a, m), _u(a)) : Ks(Zn, m.stateNode));
        break;
      case 4:
        k = Zn, D = Nr, Zn = m.stateNode.containerInfo, Nr = !0, wa(a, l, m), Zn = k, Nr = D;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Ar && (k = m.updateQueue, k !== null && (k = k.lastEffect, k !== null))) {
          D = k = k.next;
          do {
            var z = D, G = z.destroy;
            z = z.tag, G !== void 0 && (z & 2 || z & 4) && uc(m, l, G), D = D.next;
          } while (D !== k);
        }
        wa(a, l, m);
        break;
      case 1:
        if (!Ar && (Ql(m, l), k = m.stateNode, typeof k.componentWillUnmount == "function"))
          try {
            k.props = m.memoizedProps, k.state = m.memoizedState, k.componentWillUnmount();
          } catch (ie) {
            lr(m, l, ie);
          }
        wa(a, l, m);
        break;
      case 21:
        wa(a, l, m);
        break;
      case 22:
        m.mode & 1 ? (Ar = (k = Ar) || m.memoizedState !== null, wa(a, l, m), Ar = k) : wa(a, l, m);
        break;
      default:
        wa(a, l, m);
    }
  }
  function Ts(a) {
    var l = a.updateQueue;
    if (l !== null) {
      a.updateQueue = null;
      var m = a.stateNode;
      m === null && (m = a.stateNode = new kv()), l.forEach(function(k) {
        var D = Fx.bind(null, a, k);
        m.has(k) || (m.add(k), k.then(D, D));
      });
    }
  }
  function Ha(a, l) {
    var m = l.deletions;
    if (m !== null)
      for (var k = 0; k < m.length; k++) {
        var D = m[k];
        try {
          var z = a, G = l, ie = G;
          e:
            for (; ie !== null; ) {
              switch (ie.tag) {
                case 5:
                  Zn = ie.stateNode, Nr = !1;
                  break e;
                case 3:
                  Zn = ie.stateNode.containerInfo, Nr = !0;
                  break e;
                case 4:
                  Zn = ie.stateNode.containerInfo, Nr = !0;
                  break e;
              }
              ie = ie.return;
            }
          if (Zn === null)
            throw Error(h(160));
          Jl(z, G, D), Zn = null, Nr = !1;
          var ce = D.alternate;
          ce !== null && (ce.return = null), D.return = null;
        } catch (Te) {
          lr(D, l, Te);
        }
      }
    if (l.subtreeFlags & 12854)
      for (l = l.child; l !== null; )
        Ev(l, a), l = l.sibling;
  }
  function Ev(a, l) {
    var m = a.alternate, k = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Ha(l, a), Qa(a), k & 4) {
          try {
            cc(3, a, a.return), dc(3, a);
          } catch (St) {
            lr(a, a.return, St);
          }
          try {
            cc(5, a, a.return);
          } catch (St) {
            lr(a, a.return, St);
          }
        }
        break;
      case 1:
        Ha(l, a), Qa(a), k & 512 && m !== null && Ql(m, m.return);
        break;
      case 5:
        if (Ha(l, a), Qa(a), k & 512 && m !== null && Ql(m, m.return), a.flags & 32) {
          var D = a.stateNode;
          try {
            Qi(D, "");
          } catch (St) {
            lr(a, a.return, St);
          }
        }
        if (k & 4 && (D = a.stateNode, D != null)) {
          var z = a.memoizedProps, G = m !== null ? m.memoizedProps : z, ie = a.type, ce = a.updateQueue;
          if (a.updateQueue = null, ce !== null)
            try {
              ie === "input" && z.type === "radio" && z.name != null && Lr(D, z), $n(ie, G);
              var Te = $n(ie, z);
              for (G = 0; G < ce.length; G += 2) {
                var He = ce[G], Ue = ce[G + 1];
                He === "style" ? bn(D, Ue) : He === "dangerouslySetInnerHTML" ? _a(D, Ue) : He === "children" ? Qi(D, Ue) : we(D, He, Ue, Te);
              }
              switch (ie) {
                case "input":
                  Mr(D, z);
                  break;
                case "textarea":
                  da(D, z);
                  break;
                case "select":
                  var Fe = D._wrapperState.wasMultiple;
                  D._wrapperState.wasMultiple = !!z.multiple;
                  var lt = z.value;
                  lt != null ? ca(D, !!z.multiple, lt, !1) : Fe !== !!z.multiple && (z.defaultValue != null ? ca(
                    D,
                    !!z.multiple,
                    z.defaultValue,
                    !0
                  ) : ca(D, !!z.multiple, z.multiple ? [] : "", !1));
              }
              D[Ho] = z;
            } catch (St) {
              lr(a, a.return, St);
            }
        }
        break;
      case 6:
        if (Ha(l, a), Qa(a), k & 4) {
          if (a.stateNode === null)
            throw Error(h(162));
          D = a.stateNode, z = a.memoizedProps;
          try {
            D.nodeValue = z;
          } catch (St) {
            lr(a, a.return, St);
          }
        }
        break;
      case 3:
        if (Ha(l, a), Qa(a), k & 4 && m !== null && m.memoizedState.isDehydrated)
          try {
            _u(l.containerInfo);
          } catch (St) {
            lr(a, a.return, St);
          }
        break;
      case 4:
        Ha(l, a), Qa(a);
        break;
      case 13:
        Ha(l, a), Qa(a), D = a.child, D.flags & 8192 && (z = D.memoizedState !== null, D.stateNode.isHidden = z, !z || D.alternate !== null && D.alternate.memoizedState !== null || (Bh = o())), k & 4 && Ts(a);
        break;
      case 22:
        if (He = m !== null && m.memoizedState !== null, a.mode & 1 ? (Ar = (Te = Ar) || He, Ha(l, a), Ar = Te) : Ha(l, a), Qa(a), k & 8192) {
          if (Te = a.memoizedState !== null, (a.stateNode.isHidden = Te) && !He && a.mode & 1)
            for (ht = a, He = a.child; He !== null; ) {
              for (Ue = ht = He; ht !== null; ) {
                switch (Fe = ht, lt = Fe.child, Fe.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    cc(4, Fe, Fe.return);
                    break;
                  case 1:
                    Ql(Fe, Fe.return);
                    var yt = Fe.stateNode;
                    if (typeof yt.componentWillUnmount == "function") {
                      k = Fe, m = Fe.return;
                      try {
                        l = k, yt.props = l.memoizedProps, yt.state = l.memoizedState, yt.componentWillUnmount();
                      } catch (St) {
                        lr(k, m, St);
                      }
                    }
                    break;
                  case 5:
                    Ql(Fe, Fe.return);
                    break;
                  case 22:
                    if (Fe.memoizedState !== null) {
                      jh(Ue);
                      continue;
                    }
                }
                lt !== null ? (lt.return = Fe, ht = lt) : jh(Ue);
              }
              He = He.sibling;
            }
          e:
            for (He = null, Ue = a; ; ) {
              if (Ue.tag === 5) {
                if (He === null) {
                  He = Ue;
                  try {
                    D = Ue.stateNode, Te ? (z = D.style, typeof z.setProperty == "function" ? z.setProperty("display", "none", "important") : z.display = "none") : (ie = Ue.stateNode, ce = Ue.memoizedProps.style, G = ce != null && ce.hasOwnProperty("display") ? ce.display : null, ie.style.display = tn("display", G));
                  } catch (St) {
                    lr(a, a.return, St);
                  }
                }
              } else if (Ue.tag === 6) {
                if (He === null)
                  try {
                    Ue.stateNode.nodeValue = Te ? "" : Ue.memoizedProps;
                  } catch (St) {
                    lr(a, a.return, St);
                  }
              } else if ((Ue.tag !== 22 && Ue.tag !== 23 || Ue.memoizedState === null || Ue === a) && Ue.child !== null) {
                Ue.child.return = Ue, Ue = Ue.child;
                continue;
              }
              if (Ue === a)
                break e;
              for (; Ue.sibling === null; ) {
                if (Ue.return === null || Ue.return === a)
                  break e;
                He === Ue && (He = null), Ue = Ue.return;
              }
              He === Ue && (He = null), Ue.sibling.return = Ue.return, Ue = Ue.sibling;
            }
        }
        break;
      case 19:
        Ha(l, a), Qa(a), k & 4 && Ts(a);
        break;
      case 21:
        break;
      default:
        Ha(
          l,
          a
        ), Qa(a);
    }
  }
  function Qa(a) {
    var l = a.flags;
    if (l & 2) {
      try {
        e: {
          for (var m = a.return; m !== null; ) {
            if (Tv(m)) {
              var k = m;
              break e;
            }
            m = m.return;
          }
          throw Error(h(160));
        }
        switch (k.tag) {
          case 5:
            var D = k.stateNode;
            k.flags & 32 && (Qi(D, ""), k.flags &= -33);
            var z = Fd(a);
            Za(a, z, D);
            break;
          case 3:
          case 4:
            var G = k.stateNode.containerInfo, ie = Fd(a);
            Kl(a, ie, G);
            break;
          default:
            throw Error(h(161));
        }
      } catch (ce) {
        lr(a, a.return, ce);
      }
      a.flags &= -3;
    }
    l & 4096 && (a.flags &= -4097);
  }
  function Rv(a, l, m) {
    ht = a, eu(a);
  }
  function eu(a, l, m) {
    for (var k = (a.mode & 1) !== 0; ht !== null; ) {
      var D = ht, z = D.child;
      if (D.tag === 22 && k) {
        var G = D.memoizedState !== null || lc;
        if (!G) {
          var ie = D.alternate, ce = ie !== null && ie.memoizedState !== null || Ar;
          ie = lc;
          var Te = Ar;
          if (lc = G, (Ar = ce) && !Te)
            for (ht = D; ht !== null; )
              G = ht, ce = G.child, G.tag === 22 && G.memoizedState !== null ? Mv(D) : ce !== null ? (ce.return = G, ht = ce) : Mv(D);
          for (; z !== null; )
            ht = z, eu(z), z = z.sibling;
          ht = D, lc = ie, Ar = Te;
        }
        Lv(a);
      } else
        D.subtreeFlags & 8772 && z !== null ? (z.return = D, ht = z) : Lv(a);
    }
  }
  function Lv(a) {
    for (; ht !== null; ) {
      var l = ht;
      if (l.flags & 8772) {
        var m = l.alternate;
        try {
          if (l.flags & 8772)
            switch (l.tag) {
              case 0:
              case 11:
              case 15:
                Ar || dc(5, l);
                break;
              case 1:
                var k = l.stateNode;
                if (l.flags & 4 && !Ar)
                  if (m === null)
                    k.componentDidMount();
                  else {
                    var D = l.elementType === l.type ? m.memoizedProps : na(l.type, m.memoizedProps);
                    k.componentDidUpdate(D, m.memoizedState, k.__reactInternalSnapshotBeforeUpdate);
                  }
                var z = l.updateQueue;
                z !== null && Uo(l, z, k);
                break;
              case 3:
                var G = l.updateQueue;
                if (G !== null) {
                  if (m = null, l.child !== null)
                    switch (l.child.tag) {
                      case 5:
                        m = l.child.stateNode;
                        break;
                      case 1:
                        m = l.child.stateNode;
                    }
                  Uo(l, G, m);
                }
                break;
              case 5:
                var ie = l.stateNode;
                if (m === null && l.flags & 4) {
                  m = ie;
                  var ce = l.memoizedProps;
                  switch (l.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      ce.autoFocus && m.focus();
                      break;
                    case "img":
                      ce.src && (m.src = ce.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (l.memoizedState === null) {
                  var Te = l.alternate;
                  if (Te !== null) {
                    var He = Te.memoizedState;
                    if (He !== null) {
                      var Ue = He.dehydrated;
                      Ue !== null && _u(Ue);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(h(163));
            }
          Ar || l.flags & 512 && Yh(l);
        } catch (Fe) {
          lr(l, l.return, Fe);
        }
      }
      if (l === a) {
        ht = null;
        break;
      }
      if (m = l.sibling, m !== null) {
        m.return = l.return, ht = m;
        break;
      }
      ht = l.return;
    }
  }
  function jh(a) {
    for (; ht !== null; ) {
      var l = ht;
      if (l === a) {
        ht = null;
        break;
      }
      var m = l.sibling;
      if (m !== null) {
        m.return = l.return, ht = m;
        break;
      }
      ht = l.return;
    }
  }
  function Mv(a) {
    for (; ht !== null; ) {
      var l = ht;
      try {
        switch (l.tag) {
          case 0:
          case 11:
          case 15:
            var m = l.return;
            try {
              dc(4, l);
            } catch (ce) {
              lr(l, m, ce);
            }
            break;
          case 1:
            var k = l.stateNode;
            if (typeof k.componentDidMount == "function") {
              var D = l.return;
              try {
                k.componentDidMount();
              } catch (ce) {
                lr(l, D, ce);
              }
            }
            var z = l.return;
            try {
              Yh(l);
            } catch (ce) {
              lr(l, z, ce);
            }
            break;
          case 5:
            var G = l.return;
            try {
              Yh(l);
            } catch (ce) {
              lr(l, G, ce);
            }
        }
      } catch (ce) {
        lr(l, l.return, ce);
      }
      if (l === a) {
        ht = null;
        break;
      }
      var ie = l.sibling;
      if (ie !== null) {
        ie.return = l.return, ht = ie;
        break;
      }
      ht = l.return;
    }
  }
  var Yd = Math.ceil, fc = Ee.ReactCurrentDispatcher, Uh = Ee.ReactCurrentOwner, di = Ee.ReactCurrentBatchConfig, sn = 0, Jn = null, or = null, zr = 0, ia = 0, tu = Jt(0), Tr = 0, hc = null, Es = 0, Hd = 0, nu = 0, el = null, bi = null, Bh = 0, ru = 1 / 0, Rs = null, jd = !1, tl = null, Ka = null, ho = !1, po = null, Ud = 0, iu = 0, Bd = null, nl = -1, rl = 0;
  function fi() {
    return sn & 6 ? o() : nl !== -1 ? nl : nl = o();
  }
  function xr(a) {
    return a.mode & 1 ? sn & 2 && zr !== 0 ? zr & -zr : cd.transition !== null ? (rl === 0 && (rl = oe()), rl) : (a = Ie, a !== 0 || (a = window.event, a = a === void 0 ? 16 : Bf(a.type)), a) : 1;
  }
  function hi(a, l, m, k) {
    if (50 < iu)
      throw iu = 0, Bd = null, Error(h(185));
    ke(a, m, k), (!(sn & 2) || a !== Jn) && (a === Jn && (!(sn & 2) && (Hd |= m), Tr === 4 && Sa(a, zr)), pi(a, k), m === 1 && sn === 0 && !(l.mode & 1) && (ru = o() + 500, _r && Pi()));
  }
  function pi(a, l) {
    var m = a.callbackNode;
    K(a, l);
    var k = N(a, a === Jn ? zr : 0);
    if (k === 0)
      m !== null && t(m), a.callbackNode = null, a.callbackPriority = 0;
    else if (l = k & -k, a.callbackPriority !== l) {
      if (m != null && t(m), l === 1)
        a.tag === 0 ? gh(Dv.bind(null, a)) : ph(Dv.bind(null, a)), dh(function() {
          !(sn & 6) && Pi();
        }), m = null;
      else {
        switch (rt(k)) {
          case 1:
            m = f;
            break;
          case 4:
            m = p;
            break;
          case 16:
            m = y;
            break;
          case 536870912:
            m = C;
            break;
          default:
            m = y;
        }
        m = qh(m, au.bind(null, a));
      }
      a.callbackPriority = l, a.callbackNode = m;
    }
  }
  function au(a, l) {
    if (nl = -1, rl = 0, sn & 6)
      throw Error(h(327));
    var m = a.callbackNode;
    if (ou() && a.callbackNode !== m)
      return null;
    var k = N(a, a === Jn ? zr : 0);
    if (k === 0)
      return null;
    if (k & 30 || k & a.expiredLanes || l)
      l = Xd(a, k);
    else {
      l = k;
      var D = sn;
      sn |= 2;
      var z = Wd();
      (Jn !== a || zr !== l) && (Rs = null, ru = o() + 500, il(a, l));
      do
        try {
          Px();
          break;
        } catch (ie) {
          Ov(a, ie);
        }
      while (1);
      wh(), fc.current = z, sn = D, or !== null ? l = 0 : (Jn = null, zr = 0, l = Tr);
    }
    if (l !== 0) {
      if (l === 2 && (D = ee(a), D !== 0 && (k = D, l = Wh(a, D))), l === 1)
        throw m = hc, il(a, 0), Sa(a, k), pi(a, o()), m;
      if (l === 6)
        Sa(a, k);
      else {
        if (D = a.current.alternate, !(k & 30) && !Xh(D) && (l = Xd(a, k), l === 2 && (z = ee(a), z !== 0 && (k = z, l = Wh(a, z))), l === 1))
          throw m = hc, il(a, 0), Sa(a, k), pi(a, o()), m;
        switch (a.finishedWork = D, a.finishedLanes = k, l) {
          case 0:
          case 1:
            throw Error(h(345));
          case 2:
            al(a, bi, Rs);
            break;
          case 3:
            if (Sa(a, k), (k & 130023424) === k && (l = Bh + 500 - o(), 10 < l)) {
              if (N(a, 0) !== 0)
                break;
              if (D = a.suspendedLanes, (D & k) !== k) {
                fi(), a.pingedLanes |= a.suspendedLanes & D;
                break;
              }
              a.timeoutHandle = Yo(al.bind(null, a, bi, Rs), l);
              break;
            }
            al(a, bi, Rs);
            break;
          case 4:
            if (Sa(a, k), (k & 4194240) === k)
              break;
            for (l = a.eventTimes, D = -1; 0 < k; ) {
              var G = 31 - P(k);
              z = 1 << G, G = l[G], G > D && (D = G), k &= ~z;
            }
            if (k = D, k = o() - k, k = (120 > k ? 120 : 480 > k ? 480 : 1080 > k ? 1080 : 1920 > k ? 1920 : 3e3 > k ? 3e3 : 4320 > k ? 4320 : 1960 * Yd(k / 1960)) - k, 10 < k) {
              a.timeoutHandle = Yo(al.bind(null, a, bi, Rs), k);
              break;
            }
            al(a, bi, Rs);
            break;
          case 5:
            al(a, bi, Rs);
            break;
          default:
            throw Error(h(329));
        }
      }
    }
    return pi(a, o()), a.callbackNode === m ? au.bind(null, a) : null;
  }
  function Wh(a, l) {
    var m = el;
    return a.current.memoizedState.isDehydrated && (il(a, l).flags |= 256), a = Xd(a, l), a !== 2 && (l = bi, bi = m, l !== null && pc(l)), a;
  }
  function pc(a) {
    bi === null ? bi = a : bi.push.apply(bi, a);
  }
  function Xh(a) {
    for (var l = a; ; ) {
      if (l.flags & 16384) {
        var m = l.updateQueue;
        if (m !== null && (m = m.stores, m !== null))
          for (var k = 0; k < m.length; k++) {
            var D = m[k], z = D.getSnapshot;
            D = D.value;
            try {
              if (!fa(z(), D))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (m = l.child, l.subtreeFlags & 16384 && m !== null)
        m.return = l, l = m;
      else {
        if (l === a)
          break;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === a)
            return !0;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    }
    return !0;
  }
  function Sa(a, l) {
    for (l &= ~nu, l &= ~Hd, a.suspendedLanes |= l, a.pingedLanes &= ~l, a = a.expirationTimes; 0 < l; ) {
      var m = 31 - P(l), k = 1 << m;
      a[m] = -1, l &= ~k;
    }
  }
  function Dv(a) {
    if (sn & 6)
      throw Error(h(327));
    ou();
    var l = N(a, 0);
    if (!(l & 1))
      return pi(a, o()), null;
    var m = Xd(a, l);
    if (a.tag !== 0 && m === 2) {
      var k = ee(a);
      k !== 0 && (l = k, m = Wh(a, k));
    }
    if (m === 1)
      throw m = hc, il(a, 0), Sa(a, l), pi(a, o()), m;
    if (m === 6)
      throw Error(h(345));
    return a.finishedWork = a.current.alternate, a.finishedLanes = l, al(a, bi, Rs), pi(a, o()), null;
  }
  function su(a, l) {
    var m = sn;
    sn |= 1;
    try {
      return a(l);
    } finally {
      sn = m, sn === 0 && (ru = o() + 500, _r && Pi());
    }
  }
  function go(a) {
    po !== null && po.tag === 0 && !(sn & 6) && ou();
    var l = sn;
    sn |= 1;
    var m = di.transition, k = Ie;
    try {
      if (di.transition = null, Ie = 1, a)
        return a();
    } finally {
      Ie = k, di.transition = m, sn = l, !(sn & 6) && Pi();
    }
  }
  function Vh() {
    ia = tu.current, Sn(tu);
  }
  function il(a, l) {
    a.finishedWork = null, a.finishedLanes = 0;
    var m = a.timeoutHandle;
    if (m !== -1 && (a.timeoutHandle = -1, av(m)), or !== null)
      for (m = or.return; m !== null; ) {
        var k = m;
        switch (mh(k), k.tag) {
          case 1:
            k = k.type.childContextTypes, k != null && ga();
            break;
          case 3:
            lo(), Sn(sr), Sn(Xt), vd();
            break;
          case 5:
            nn(k);
            break;
          case 4:
            lo();
            break;
          case 13:
            Sn(Ft);
            break;
          case 19:
            Sn(Ft);
            break;
          case 10:
            io(k.type._context);
            break;
          case 22:
          case 23:
            Vh();
        }
        m = m.return;
      }
    if (Jn = a, or = a = vo(a.current, null), zr = ia = l, Tr = 0, hc = null, nu = Hd = Es = 0, bi = el = null, Br !== null) {
      for (l = 0; l < Br.length; l++)
        if (m = Br[l], k = m.interleaved, k !== null) {
          m.interleaved = null;
          var D = k.next, z = m.pending;
          if (z !== null) {
            var G = z.next;
            z.next = D, k.next = G;
          }
          m.pending = k;
        }
      Br = null;
    }
    return a;
  }
  function Ov(a, l) {
    do {
      var m = or;
      try {
        if (wh(), md.current = _d, Yt) {
          for (var k = Xn.memoizedState; k !== null; ) {
            var D = k.queue;
            D !== null && (D.pending = null), k = k.next;
          }
          Yt = !1;
        }
        if (Wo = 0, dn = Pe = Xn = null, qa = !1, ra = 0, Uh.current = null, m === null || m.return === null) {
          Tr = 1, hc = l, or = null;
          break;
        }
        e: {
          var z = a, G = m.return, ie = m, ce = l;
          if (l = zr, ie.flags |= 32768, ce !== null && typeof ce == "object" && typeof ce.then == "function") {
            var Te = ce, He = ie, Ue = He.tag;
            if (!(He.mode & 1) && (Ue === 0 || Ue === 11 || Ue === 15)) {
              var Fe = He.alternate;
              Fe ? (He.updateQueue = Fe.updateQueue, He.memoizedState = Fe.memoizedState, He.lanes = Fe.lanes) : (He.updateQueue = null, He.memoizedState = null);
            }
            var lt = Mh(G);
            if (lt !== null) {
              lt.flags &= -257, Dh(lt, G, ie, z, l), lt.mode & 1 && bv(z, Te, l), l = lt, ce = Te;
              var yt = l.updateQueue;
              if (yt === null) {
                var St = /* @__PURE__ */ new Set();
                St.add(ce), l.updateQueue = St;
              } else
                yt.add(ce);
              break e;
            } else {
              if (!(l & 1)) {
                bv(z, Te, l), Gh();
                break e;
              }
              ce = Error(h(426));
            }
          } else if (Wn && ie.mode & 1) {
            var dr = Mh(G);
            if (dr !== null) {
              !(dr.flags & 65536) && (dr.flags |= 256), Dh(dr, G, ie, z, l), xh($l(ce, ie));
              break e;
            }
          }
          z = ce = $l(ce, ie), Tr !== 4 && (Tr = 2), el === null ? el = [z] : el.push(z), z = G;
          do {
            switch (z.tag) {
              case 3:
                z.flags |= 65536, l &= -l, z.lanes |= l;
                var me = xv(z, ce, l);
                Ch(z, me);
                break e;
              case 1:
                ie = ce;
                var pe = z.type, Se = z.stateNode;
                if (!(z.flags & 128) && (typeof pe.getDerivedStateFromError == "function" || Se !== null && typeof Se.componentDidCatch == "function" && (Ka === null || !Ka.has(Se)))) {
                  z.flags |= 65536, l &= -l, z.lanes |= l;
                  var qe = ac(z, ie, l);
                  Ch(z, qe);
                  break e;
                }
            }
            z = z.return;
          } while (z !== null);
        }
        $h(m);
      } catch (Ct) {
        l = Ct, or === m && m !== null && (or = m = m.return);
        continue;
      }
      break;
    } while (1);
  }
  function Wd() {
    var a = fc.current;
    return fc.current = _d, a === null ? _d : a;
  }
  function Gh() {
    (Tr === 0 || Tr === 3 || Tr === 2) && (Tr = 4), Jn === null || !(Es & 268435455) && !(Hd & 268435455) || Sa(Jn, zr);
  }
  function Xd(a, l) {
    var m = sn;
    sn |= 2;
    var k = Wd();
    (Jn !== a || zr !== l) && (Rs = null, il(a, l));
    do
      try {
        _x();
        break;
      } catch (D) {
        Ov(a, D);
      }
    while (1);
    if (wh(), sn = m, fc.current = k, or !== null)
      throw Error(h(261));
    return Jn = null, zr = 0, Tr;
  }
  function _x() {
    for (; or !== null; )
      _v(or);
  }
  function Px() {
    for (; or !== null && !n(); )
      _v(or);
  }
  function _v(a) {
    var l = Nv(a.alternate, a, ia);
    a.memoizedProps = a.pendingProps, l === null ? $h(a) : or = l, Uh.current = null;
  }
  function $h(a) {
    var l = a;
    do {
      var m = l.alternate;
      if (a = l.return, l.flags & 32768) {
        if (m = Fh(m, l), m !== null) {
          m.flags &= 32767, or = m;
          return;
        }
        if (a !== null)
          a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
        else {
          Tr = 6, or = null;
          return;
        }
      } else if (m = Ox(m, l, ia), m !== null) {
        or = m;
        return;
      }
      if (l = l.sibling, l !== null) {
        or = l;
        return;
      }
      or = l = a;
    } while (l !== null);
    Tr === 0 && (Tr = 5);
  }
  function al(a, l, m) {
    var k = Ie, D = di.transition;
    try {
      di.transition = null, Ie = 1, Nx(a, l, m, k);
    } finally {
      di.transition = D, Ie = k;
    }
    return null;
  }
  function Nx(a, l, m, k) {
    do
      ou();
    while (po !== null);
    if (sn & 6)
      throw Error(h(327));
    m = a.finishedWork;
    var D = a.finishedLanes;
    if (m === null)
      return null;
    if (a.finishedWork = null, a.finishedLanes = 0, m === a.current)
      throw Error(h(177));
    a.callbackNode = null, a.callbackPriority = 0;
    var z = m.lanes | m.childLanes;
    if (_e(a, z), a === Jn && (or = Jn = null, zr = 0), !(m.subtreeFlags & 2064) && !(m.flags & 2064) || ho || (ho = !0, qh(y, function() {
      return ou(), null;
    })), z = (m.flags & 15990) !== 0, m.subtreeFlags & 15990 || z) {
      z = di.transition, di.transition = null;
      var G = Ie;
      Ie = 1;
      var ie = sn;
      sn |= 4, Uh.current = null, Av(a, m), Ev(m, a), Jc(Fo), _o = !!uh, Fo = uh = null, a.current = m, Rv(m), i(), sn = ie, Ie = G, di.transition = z;
    } else
      a.current = m;
    if (ho && (ho = !1, po = a, Ud = D), z = a.pendingLanes, z === 0 && (Ka = null), O(m.stateNode), pi(a, o()), l !== null)
      for (k = a.onRecoverableError, m = 0; m < l.length; m++)
        D = l[m], k(D.value, { componentStack: D.stack, digest: D.digest });
    if (jd)
      throw jd = !1, a = tl, tl = null, a;
    return Ud & 1 && a.tag !== 0 && ou(), z = a.pendingLanes, z & 1 ? a === Bd ? iu++ : (iu = 0, Bd = a) : iu = 0, Pi(), null;
  }
  function ou() {
    if (po !== null) {
      var a = rt(Ud), l = di.transition, m = Ie;
      try {
        if (di.transition = null, Ie = 16 > a ? 16 : a, po === null)
          var k = !1;
        else {
          if (a = po, po = null, Ud = 0, sn & 6)
            throw Error(h(331));
          var D = sn;
          for (sn |= 4, ht = a.current; ht !== null; ) {
            var z = ht, G = z.child;
            if (ht.flags & 16) {
              var ie = z.deletions;
              if (ie !== null) {
                for (var ce = 0; ce < ie.length; ce++) {
                  var Te = ie[ce];
                  for (ht = Te; ht !== null; ) {
                    var He = ht;
                    switch (He.tag) {
                      case 0:
                      case 11:
                      case 15:
                        cc(8, He, z);
                    }
                    var Ue = He.child;
                    if (Ue !== null)
                      Ue.return = He, ht = Ue;
                    else
                      for (; ht !== null; ) {
                        He = ht;
                        var Fe = He.sibling, lt = He.return;
                        if (Hh(He), He === Te) {
                          ht = null;
                          break;
                        }
                        if (Fe !== null) {
                          Fe.return = lt, ht = Fe;
                          break;
                        }
                        ht = lt;
                      }
                  }
                }
                var yt = z.alternate;
                if (yt !== null) {
                  var St = yt.child;
                  if (St !== null) {
                    yt.child = null;
                    do {
                      var dr = St.sibling;
                      St.sibling = null, St = dr;
                    } while (St !== null);
                  }
                }
                ht = z;
              }
            }
            if (z.subtreeFlags & 2064 && G !== null)
              G.return = z, ht = G;
            else
              e:
                for (; ht !== null; ) {
                  if (z = ht, z.flags & 2048)
                    switch (z.tag) {
                      case 0:
                      case 11:
                      case 15:
                        cc(9, z, z.return);
                    }
                  var me = z.sibling;
                  if (me !== null) {
                    me.return = z.return, ht = me;
                    break e;
                  }
                  ht = z.return;
                }
          }
          var pe = a.current;
          for (ht = pe; ht !== null; ) {
            G = ht;
            var Se = G.child;
            if (G.subtreeFlags & 2064 && Se !== null)
              Se.return = G, ht = Se;
            else
              e:
                for (G = pe; ht !== null; ) {
                  if (ie = ht, ie.flags & 2048)
                    try {
                      switch (ie.tag) {
                        case 0:
                        case 11:
                        case 15:
                          dc(9, ie);
                      }
                    } catch (Ct) {
                      lr(ie, ie.return, Ct);
                    }
                  if (ie === G) {
                    ht = null;
                    break e;
                  }
                  var qe = ie.sibling;
                  if (qe !== null) {
                    qe.return = ie.return, ht = qe;
                    break e;
                  }
                  ht = ie.return;
                }
          }
          if (sn = D, Pi(), L && typeof L.onPostCommitFiberRoot == "function")
            try {
              L.onPostCommitFiberRoot(E, a);
            } catch {
            }
          k = !0;
        }
        return k;
      } finally {
        Ie = m, di.transition = l;
      }
    }
    return !1;
  }
  function Pv(a, l, m) {
    l = $l(m, l), l = xv(a, l, 1), a = so(a, l, 1), l = fi(), a !== null && (ke(a, 1, l), pi(a, l));
  }
  function lr(a, l, m) {
    if (a.tag === 3)
      Pv(a, a, m);
    else
      for (; l !== null; ) {
        if (l.tag === 3) {
          Pv(l, a, m);
          break;
        } else if (l.tag === 1) {
          var k = l.stateNode;
          if (typeof l.type.getDerivedStateFromError == "function" || typeof k.componentDidCatch == "function" && (Ka === null || !Ka.has(k))) {
            a = $l(m, a), a = ac(l, a, 1), l = so(l, a, 1), a = fi(), l !== null && (ke(l, 1, a), pi(l, a));
            break;
          }
        }
        l = l.return;
      }
  }
  function zx(a, l, m) {
    var k = a.pingCache;
    k !== null && k.delete(l), l = fi(), a.pingedLanes |= a.suspendedLanes & m, Jn === a && (zr & m) === m && (Tr === 4 || Tr === 3 && (zr & 130023424) === zr && 500 > o() - Bh ? il(a, 0) : nu |= m), pi(a, l);
  }
  function Vd(a, l) {
    l === 0 && (a.mode & 1 ? (l = b, b <<= 1, !(b & 130023424) && (b = 4194304)) : l = 1);
    var m = fi();
    a = Ss(a, l), a !== null && (ke(a, l, m), pi(a, m));
  }
  function Ix(a) {
    var l = a.memoizedState, m = 0;
    l !== null && (m = l.retryLane), Vd(a, m);
  }
  function Fx(a, l) {
    var m = 0;
    switch (a.tag) {
      case 13:
        var k = a.stateNode, D = a.memoizedState;
        D !== null && (m = D.retryLane);
        break;
      case 19:
        k = a.stateNode;
        break;
      default:
        throw Error(h(314));
    }
    k !== null && k.delete(l), Vd(a, m);
  }
  var Nv;
  Nv = function(a, l, m) {
    if (a !== null)
      if (a.memoizedProps !== l.pendingProps || sr.current)
        yr = !0;
      else {
        if (!(a.lanes & m) && !(l.flags & 128))
          return yr = !1, As(a, l, m);
        yr = !!(a.flags & 131072);
      }
    else
      yr = !1, Wn && l.flags & 1048576 && vh(l, jl, l.index);
    switch (l.lanes = 0, l.tag) {
      case 2:
        var k = l.type;
        ui(a, l), a = l.pendingProps;
        var D = pa(l, Xt.current);
        tt(l, m), D = uo(null, l, k, a, D, m);
        var z = Go();
        return l.flags |= 1, typeof D == "object" && D !== null && typeof D.render == "function" && D.$$typeof === void 0 ? (l.tag = 1, l.memoizedState = null, l.updateQueue = null, qn(k) ? (z = !0, ad(l)) : z = !1, l.memoizedState = D.state !== null && D.state !== void 0 ? D.state : null, kh(l), D.updater = hd, l.stateNode = D, D._reactInternals = l, pd(l, k, a, m), l = wv(null, l, k, !0, z, m)) : (l.tag = 0, Wn && z && sd(l), kr(null, l, D, m), l = l.child), l;
      case 16:
        k = l.elementType;
        e: {
          switch (ui(a, l), a = l.pendingProps, D = k._init, k = D(k._payload), l.type = k, D = l.tag = Hx(k), a = na(k, a), D) {
            case 0:
              l = ql(null, l, k, a, m);
              break e;
            case 1:
              l = Oh(null, l, k, a, m);
              break e;
            case 11:
              l = fo(null, l, k, a, m);
              break e;
            case 14:
              l = Nd(null, l, k, na(k.type, a), m);
              break e;
          }
          throw Error(h(
            306,
            k,
            ""
          ));
        }
        return l;
      case 0:
        return k = l.type, D = l.pendingProps, D = l.elementType === k ? D : na(k, D), ql(a, l, k, D, m);
      case 1:
        return k = l.type, D = l.pendingProps, D = l.elementType === k ? D : na(k, D), Oh(a, l, k, D, m);
      case 3:
        e: {
          if (Sv(l), a === null)
            throw Error(h(387));
          k = l.pendingProps, z = l.memoizedState, D = z.element, Sr(a, l), oo(l, k, null, m);
          var G = l.memoizedState;
          if (k = G.element, z.isDehydrated)
            if (z = { element: k, isDehydrated: !1, cache: G.cache, pendingSuspenseBoundaries: G.pendingSuspenseBoundaries, transitions: G.transitions }, l.updateQueue.baseState = z, l.memoizedState = z, l.flags & 256) {
              D = $l(Error(h(423)), l), l = zd(a, l, k, m, D);
              break e;
            } else if (k !== D) {
              D = $l(Error(h(424)), l), l = zd(a, l, k, m, D);
              break e;
            } else
              for (Ii = Fa(l.stateNode.containerInfo.firstChild), ta = l, Wn = !0, ma = null, m = mv(l, null, k, m), l.child = m; m; )
                m.flags = m.flags & -3 | 4096, m = m.sibling;
          else {
            if (Qn(), k === D) {
              l = Wr(a, l, m);
              break e;
            }
            kr(a, l, k, m);
          }
          l = l.child;
        }
        return l;
      case 5:
        return Nt(l), a === null && ld(l), k = l.type, D = l.pendingProps, z = a !== null ? a.memoizedProps : null, G = D.children, Gu(k, D) ? G = null : z !== null && Gu(k, z) && (l.flags |= 32), en(a, l), kr(a, l, G, m), l.child;
      case 6:
        return a === null && ld(l), null;
      case 13:
        return Ph(a, l, m);
      case 4:
        return Th(l, l.stateNode.containerInfo), k = l.pendingProps, a === null ? l.child = Bl(l, null, k, m) : kr(a, l, k, m), l.child;
      case 11:
        return k = l.type, D = l.pendingProps, D = l.elementType === k ? D : na(k, D), fo(a, l, k, D, m);
      case 7:
        return kr(a, l, l.pendingProps, m), l.child;
      case 8:
        return kr(a, l, l.pendingProps.children, m), l.child;
      case 12:
        return kr(a, l, l.pendingProps.children, m), l.child;
      case 10:
        e: {
          if (k = l.type._context, D = l.pendingProps, z = l.memoizedProps, G = D.value, An($a, k._currentValue), k._currentValue = G, z !== null)
            if (fa(z.value, G)) {
              if (z.children === D.children && !sr.current) {
                l = Wr(a, l, m);
                break e;
              }
            } else
              for (z = l.child, z !== null && (z.return = l); z !== null; ) {
                var ie = z.dependencies;
                if (ie !== null) {
                  G = z.child;
                  for (var ce = ie.firstContext; ce !== null; ) {
                    if (ce.context === k) {
                      if (z.tag === 1) {
                        ce = ks(-1, m & -m), ce.tag = 2;
                        var Te = z.updateQueue;
                        if (Te !== null) {
                          Te = Te.shared;
                          var He = Te.pending;
                          He === null ? ce.next = ce : (ce.next = He.next, He.next = ce), Te.pending = ce;
                        }
                      }
                      z.lanes |= m, ce = z.alternate, ce !== null && (ce.lanes |= m), Pr(
                        z.return,
                        m,
                        l
                      ), ie.lanes |= m;
                      break;
                    }
                    ce = ce.next;
                  }
                } else if (z.tag === 10)
                  G = z.type === l.type ? null : z.child;
                else if (z.tag === 18) {
                  if (G = z.return, G === null)
                    throw Error(h(341));
                  G.lanes |= m, ie = G.alternate, ie !== null && (ie.lanes |= m), Pr(G, m, l), G = z.sibling;
                } else
                  G = z.child;
                if (G !== null)
                  G.return = z;
                else
                  for (G = z; G !== null; ) {
                    if (G === l) {
                      G = null;
                      break;
                    }
                    if (z = G.sibling, z !== null) {
                      z.return = G.return, G = z;
                      break;
                    }
                    G = G.return;
                  }
                z = G;
              }
          kr(a, l, D.children, m), l = l.child;
        }
        return l;
      case 9:
        return D = l.type, k = l.pendingProps.children, tt(l, m), D = cr(D), k = k(D), l.flags |= 1, kr(a, l, k, m), l.child;
      case 14:
        return k = l.type, D = na(k, l.pendingProps), D = na(k.type, D), Nd(a, l, k, D, m);
      case 15:
        return Hi(a, l, l.type, l.pendingProps, m);
      case 17:
        return k = l.type, D = l.pendingProps, D = l.elementType === k ? D : na(k, D), ui(a, l), l.tag = 1, qn(k) ? (a = !0, ad(l)) : a = !1, tt(l, m), hv(l, k, D), pd(l, k, D, m), wv(null, l, k, !0, a, m);
      case 19:
        return Ih(a, l, m);
      case 22:
        return Qo(a, l, m);
    }
    throw Error(h(156, l.tag));
  };
  function qh(a, l) {
    return B(a, l);
  }
  function Yx(a, l, m, k) {
    this.tag = a, this.key = m, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = k, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function ka(a, l, m, k) {
    return new Yx(a, l, m, k);
  }
  function Zh(a) {
    return a = a.prototype, !(!a || !a.isReactComponent);
  }
  function Hx(a) {
    if (typeof a == "function")
      return Zh(a) ? 1 : 0;
    if (a != null) {
      if (a = a.$$typeof, a === wt)
        return 11;
      if (a === Ht)
        return 14;
    }
    return 2;
  }
  function vo(a, l) {
    var m = a.alternate;
    return m === null ? (m = ka(a.tag, l, a.key, a.mode), m.elementType = a.elementType, m.type = a.type, m.stateNode = a.stateNode, m.alternate = a, a.alternate = m) : (m.pendingProps = l, m.type = a.type, m.flags = 0, m.subtreeFlags = 0, m.deletions = null), m.flags = a.flags & 14680064, m.childLanes = a.childLanes, m.lanes = a.lanes, m.child = a.child, m.memoizedProps = a.memoizedProps, m.memoizedState = a.memoizedState, m.updateQueue = a.updateQueue, l = a.dependencies, m.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }, m.sibling = a.sibling, m.index = a.index, m.ref = a.ref, m;
  }
  function Gd(a, l, m, k, D, z) {
    var G = 2;
    if (k = a, typeof a == "function")
      Zh(a) && (G = 1);
    else if (typeof a == "string")
      G = 5;
    else
      e:
        switch (a) {
          case Le:
            return sl(m.children, D, z, l);
          case Qe:
            G = 8, D |= 8;
            break;
          case Be:
            return a = ka(12, m, l, D | 2), a.elementType = Be, a.lanes = z, a;
          case st:
            return a = ka(13, m, l, D), a.elementType = st, a.lanes = z, a;
          case it:
            return a = ka(19, m, l, D), a.elementType = it, a.lanes = z, a;
          case an:
            return gc(m, D, z, l);
          default:
            if (typeof a == "object" && a !== null)
              switch (a.$$typeof) {
                case Ge:
                  G = 10;
                  break e;
                case ft:
                  G = 9;
                  break e;
                case wt:
                  G = 11;
                  break e;
                case Ht:
                  G = 14;
                  break e;
                case Mt:
                  G = 16, k = null;
                  break e;
              }
            throw Error(h(130, a == null ? a : typeof a, ""));
        }
    return l = ka(G, m, l, D), l.elementType = a, l.type = k, l.lanes = z, l;
  }
  function sl(a, l, m, k) {
    return a = ka(7, a, k, l), a.lanes = m, a;
  }
  function gc(a, l, m, k) {
    return a = ka(22, a, k, l), a.elementType = an, a.lanes = m, a.stateNode = { isHidden: !1 }, a;
  }
  function vc(a, l, m) {
    return a = ka(6, a, null, l), a.lanes = m, a;
  }
  function ol(a, l, m) {
    return l = ka(4, a.children !== null ? a.children : [], a.key, l), l.lanes = m, l.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation }, l;
  }
  function jx(a, l, m, k, D) {
    this.tag = l, this.containerInfo = a, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = de(0), this.expirationTimes = de(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = de(0), this.identifierPrefix = k, this.onRecoverableError = D, this.mutableSourceEagerHydrationData = null;
  }
  function $d(a, l, m, k, D, z, G, ie, ce) {
    return a = new jx(a, l, m, ie, ce), l === 1 ? (l = 1, z === !0 && (l |= 8)) : l = 0, z = ka(3, null, null, l), a.current = z, z.stateNode = a, z.memoizedState = { element: k, isDehydrated: m, cache: null, transitions: null, pendingSuspenseBoundaries: null }, kh(z), a;
  }
  function zv(a, l, m) {
    var k = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: ve, key: k == null ? null : "" + k, children: a, containerInfo: l, implementation: m };
  }
  function Qh(a) {
    if (!a)
      return Ga;
    a = a._reactInternals;
    e: {
      if (qt(a) !== a || a.tag !== 1)
        throw Error(h(170));
      var l = a;
      do {
        switch (l.tag) {
          case 3:
            l = l.stateNode.context;
            break e;
          case 1:
            if (qn(l.type)) {
              l = l.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        l = l.return;
      } while (l !== null);
      throw Error(h(171));
    }
    if (a.tag === 1) {
      var m = a.type;
      if (qn(m))
        return Zu(a, m, l);
    }
    return l;
  }
  function Iv(a, l, m, k, D, z, G, ie, ce) {
    return a = $d(m, k, !0, a, D, z, G, ie, ce), a.context = Qh(null), m = a.current, k = fi(), D = xr(m), z = ks(k, D), z.callback = l ?? null, so(m, z, D), a.current.lanes = D, ke(a, D, k), pi(a, k), a;
  }
  function mc(a, l, m, k) {
    var D = l.current, z = fi(), G = xr(D);
    return m = Qh(m), l.context === null ? l.context = m : l.pendingContext = m, l = ks(z, G), l.payload = { element: a }, k = k === void 0 ? null : k, k !== null && (l.callback = k), a = so(D, l, G), a !== null && (hi(a, D, G, z), fd(a, D, G)), G;
  }
  function qd(a) {
    if (a = a.current, !a.child)
      return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function Fv(a, l) {
    if (a = a.memoizedState, a !== null && a.dehydrated !== null) {
      var m = a.retryLane;
      a.retryLane = m !== 0 && m < l ? m : l;
    }
  }
  function Kh(a, l) {
    Fv(a, l), (a = a.alternate) && Fv(a, l);
  }
  function Yv() {
    return null;
  }
  var Jh = typeof reportError == "function" ? reportError : function(a) {
    console.error(a);
  };
  function Zd(a) {
    this._internalRoot = a;
  }
  Ls.prototype.render = Zd.prototype.render = function(a) {
    var l = this._internalRoot;
    if (l === null)
      throw Error(h(409));
    mc(a, l, null, null);
  }, Ls.prototype.unmount = Zd.prototype.unmount = function() {
    var a = this._internalRoot;
    if (a !== null) {
      this._internalRoot = null;
      var l = a.containerInfo;
      go(function() {
        mc(null, a, null, null);
      }), l[bs] = null;
    }
  };
  function Ls(a) {
    this._internalRoot = a;
  }
  Ls.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var l = Mn();
      a = { blockedOn: null, target: a, priority: l };
      for (var m = 0; m < wn.length && l !== 0 && l < wn[m].priority; m++)
        ;
      wn.splice(m, 0, a), m === 0 && Cg(a);
    }
  };
  function ep(a) {
    return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11);
  }
  function Qd(a) {
    return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11 && (a.nodeType !== 8 || a.nodeValue !== " react-mount-point-unstable "));
  }
  function Hv() {
  }
  function Ux(a, l, m, k, D) {
    if (D) {
      if (typeof k == "function") {
        var z = k;
        k = function() {
          var Te = qd(G);
          z.call(Te);
        };
      }
      var G = Iv(l, k, a, 0, null, !1, !1, "", Hv);
      return a._reactRootContainer = G, a[bs] = G.current, Yl(a.nodeType === 8 ? a.parentNode : a), go(), G;
    }
    for (; D = a.lastChild; )
      a.removeChild(D);
    if (typeof k == "function") {
      var ie = k;
      k = function() {
        var Te = qd(ce);
        ie.call(Te);
      };
    }
    var ce = $d(a, 0, !1, null, null, !1, !1, "", Hv);
    return a._reactRootContainer = ce, a[bs] = ce.current, Yl(a.nodeType === 8 ? a.parentNode : a), go(function() {
      mc(l, ce, m, k);
    }), ce;
  }
  function Kd(a, l, m, k, D) {
    var z = m._reactRootContainer;
    if (z) {
      var G = z;
      if (typeof D == "function") {
        var ie = D;
        D = function() {
          var ce = qd(G);
          ie.call(ce);
        };
      }
      mc(l, G, a, D);
    } else
      G = Ux(m, l, a, D, k);
    return qd(G);
  }
  Qt = function(a) {
    switch (a.tag) {
      case 3:
        var l = a.stateNode;
        if (l.current.memoizedState.isDehydrated) {
          var m = M(l.pendingLanes);
          m !== 0 && (Me(l, m | 1), pi(l, o()), !(sn & 6) && (ru = o() + 500, Pi()));
        }
        break;
      case 13:
        go(function() {
          var k = Ss(a, 1);
          if (k !== null) {
            var D = fi();
            hi(k, a, 1, D);
          }
        }), Kh(a, 1);
    }
  }, Kt = function(a) {
    if (a.tag === 13) {
      var l = Ss(a, 134217728);
      if (l !== null) {
        var m = fi();
        hi(l, a, 134217728, m);
      }
      Kh(a, 134217728);
    }
  }, mt = function(a) {
    if (a.tag === 13) {
      var l = xr(a), m = Ss(a, l);
      if (m !== null) {
        var k = fi();
        hi(m, a, l, k);
      }
      Kh(a, l);
    }
  }, Mn = function() {
    return Ie;
  }, zn = function(a, l) {
    var m = Ie;
    try {
      return Ie = a, l();
    } finally {
      Ie = m;
    }
  }, gr = function(a, l, m) {
    switch (l) {
      case "input":
        if (Mr(a, m), l = m.name, m.type === "radio" && l != null) {
          for (m = a; m.parentNode; )
            m = m.parentNode;
          for (m = m.querySelectorAll("input[name=" + JSON.stringify("" + l) + '][type="radio"]'), l = 0; l < m.length; l++) {
            var k = m[l];
            if (k !== a && k.form === a.form) {
              var D = _t(k);
              if (!D)
                throw Error(h(90));
              Ze(k), Mr(k, D);
            }
          }
        }
        break;
      case "textarea":
        da(a, m);
        break;
      case "select":
        l = m.value, l != null && ca(a, !!m.multiple, l, !1);
    }
  }, Xs = su, Ll = go;
  var Bx = { usingClientEntryPoint: !1, Events: [qu, Hl, _t, cs, ds, su] }, lu = { findFiberByHostInstance: ha, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, Wx = { bundleType: lu.bundleType, version: lu.version, rendererPackageName: lu.rendererPackageName, rendererConfig: lu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Ee.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
    return a = ar(a), a === null ? null : a.stateNode;
  }, findFiberByHostInstance: lu.findFiberByHostInstance || Yv, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Jd = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Jd.isDisabled && Jd.supportsFiber)
      try {
        E = Jd.inject(Wx), L = Jd;
      } catch {
      }
  }
  return La.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Bx, La.createPortal = function(a, l) {
    var m = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!ep(l))
      throw Error(h(200));
    return zv(a, l, null, m);
  }, La.createRoot = function(a, l) {
    if (!ep(a))
      throw Error(h(299));
    var m = !1, k = "", D = Jh;
    return l != null && (l.unstable_strictMode === !0 && (m = !0), l.identifierPrefix !== void 0 && (k = l.identifierPrefix), l.onRecoverableError !== void 0 && (D = l.onRecoverableError)), l = $d(a, 1, !1, null, null, m, !1, k, D), a[bs] = l.current, Yl(a.nodeType === 8 ? a.parentNode : a), new Zd(l);
  }, La.findDOMNode = function(a) {
    if (a == null)
      return null;
    if (a.nodeType === 1)
      return a;
    var l = a._reactInternals;
    if (l === void 0)
      throw typeof a.render == "function" ? Error(h(188)) : (a = Object.keys(a).join(","), Error(h(268, a)));
    return a = ar(l), a = a === null ? null : a.stateNode, a;
  }, La.flushSync = function(a) {
    return go(a);
  }, La.hydrate = function(a, l, m) {
    if (!Qd(l))
      throw Error(h(200));
    return Kd(null, a, l, !0, m);
  }, La.hydrateRoot = function(a, l, m) {
    if (!ep(a))
      throw Error(h(405));
    var k = m != null && m.hydratedSources || null, D = !1, z = "", G = Jh;
    if (m != null && (m.unstable_strictMode === !0 && (D = !0), m.identifierPrefix !== void 0 && (z = m.identifierPrefix), m.onRecoverableError !== void 0 && (G = m.onRecoverableError)), l = Iv(l, null, a, 1, m ?? null, D, !1, z, G), a[bs] = l.current, Yl(a), k)
      for (a = 0; a < k.length; a++)
        m = k[a], D = m._getVersion, D = D(m._source), l.mutableSourceEagerHydrationData == null ? l.mutableSourceEagerHydrationData = [m, D] : l.mutableSourceEagerHydrationData.push(
          m,
          D
        );
    return new Ls(l);
  }, La.render = function(a, l, m) {
    if (!Qd(l))
      throw Error(h(200));
    return Kd(null, a, l, !1, m);
  }, La.unmountComponentAtNode = function(a) {
    if (!Qd(a))
      throw Error(h(40));
    return a._reactRootContainer ? (go(function() {
      Kd(null, null, a, !1, function() {
        a._reactRootContainer = null, a[bs] = null;
      });
    }), !0) : !1;
  }, La.unstable_batchedUpdates = su, La.unstable_renderSubtreeIntoContainer = function(a, l, m, k) {
    if (!Qd(m))
      throw Error(h(200));
    if (a == null || a._reactInternals === void 0)
      throw Error(h(38));
    return Kd(a, l, m, !1, k);
  }, La.version = "18.2.0-next-9e3b772b8-20220608", La;
}
var Ma = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var LT;
function FY() {
  return LT || (LT = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var s = vi, u = yR(), h = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, v = !1;
    function w(e) {
      v = e;
    }
    function A(e) {
      if (!v) {
        for (var r = arguments.length, c = new Array(r > 1 ? r - 1 : 0), g = 1; g < r; g++)
          c[g - 1] = arguments[g];
        F("warn", e, c);
      }
    }
    function T(e) {
      if (!v) {
        for (var r = arguments.length, c = new Array(r > 1 ? r - 1 : 0), g = 1; g < r; g++)
          c[g - 1] = arguments[g];
        F("error", e, c);
      }
    }
    function F(e, r, c) {
      {
        var g = h.ReactDebugCurrentFrame, x = g.getStackAddendum();
        x !== "" && (r += "%s", c = c.concat([x]));
        var R = c.map(function(_) {
          return String(_);
        });
        R.unshift("Warning: " + r), Function.prototype.apply.call(console[e], console, R);
      }
    }
    var H = 0, U = 1, $ = 2, q = 3, te = 4, se = 5, ae = 6, ue = 7, Re = 8, Ne = 9, Q = 10, we = 11, Ee = 12, re = 13, ve = 14, Le = 15, Qe = 16, Be = 17, Ge = 18, ft = 19, wt = 21, st = 22, it = 23, Ht = 24, Mt = 25, an = !0, We = !1, pt = !1, ye = !1, je = !1, Je = !0, kt = !1, At = !1, jt = !0, ot = !0, It = !0, Et = /* @__PURE__ */ new Set(), Ut = {}, Bt = {};
    function vn(e, r) {
      Ze(e, r), Ze(e + "Capture", r);
    }
    function Ze(e, r) {
      Ut[e] && T("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", e), Ut[e] = r;
      {
        var c = e.toLowerCase();
        Bt[c] = e, e === "onDoubleClick" && (Bt.ondblclick = e);
      }
      for (var g = 0; g < r.length; g++)
        Et.add(r[g]);
    }
    var pn = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", jn = Object.prototype.hasOwnProperty;
    function rr(e) {
      {
        var r = typeof Symbol == "function" && Symbol.toStringTag, c = r && e[Symbol.toStringTag] || e.constructor.name || "Object";
        return c;
      }
    }
    function Lr(e) {
      try {
        return Mr(e), !1;
      } catch {
        return !0;
      }
    }
    function Mr(e) {
      return "" + e;
    }
    function ei(e, r) {
      if (Lr(e))
        return T("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", r, rr(e)), Mr(e);
    }
    function qi(e) {
      if (Lr(e))
        return T("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", rr(e)), Mr(e);
    }
    function Oa(e, r) {
      if (Lr(e))
        return T("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", r, rr(e)), Mr(e);
    }
    function ca(e, r) {
      if (Lr(e))
        return T("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", r, rr(e)), Mr(e);
    }
    function Zi(e) {
      if (Lr(e))
        return T("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", rr(e)), Mr(e);
    }
    function mi(e) {
      if (Lr(e))
        return T("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", rr(e)), Mr(e);
    }
    var da = 0, yi = 1, ti = 2, ir = 3, ni = 4, _a = 5, Qi = 6, Ke = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Rt = Ke + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", tn = new RegExp("^[" + Ke + "][" + Rt + "]*$"), bn = {}, Un = {};
    function pr(e) {
      return jn.call(Un, e) ? !0 : jn.call(bn, e) ? !1 : tn.test(e) ? (Un[e] = !0, !0) : (bn[e] = !0, T("Invalid attribute name: `%s`", e), !1);
    }
    function $n(e, r, c) {
      return r !== null ? r.type === da : c ? !1 : e.length > 2 && (e[0] === "o" || e[0] === "O") && (e[1] === "n" || e[1] === "N");
    }
    function ri(e, r, c, g) {
      if (c !== null && c.type === da)
        return !1;
      switch (typeof r) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (g)
            return !1;
          if (c !== null)
            return !c.acceptsBooleans;
          var x = e.toLowerCase().slice(0, 5);
          return x !== "data-" && x !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Ln(e, r, c, g) {
      if (r === null || typeof r > "u" || ri(e, r, c, g))
        return !0;
      if (g)
        return !1;
      if (c !== null)
        switch (c.type) {
          case ir:
            return !r;
          case ni:
            return r === !1;
          case _a:
            return isNaN(r);
          case Qi:
            return isNaN(r) || r < 1;
        }
      return !1;
    }
    function gr(e) {
      return Cn.hasOwnProperty(e) ? Cn[e] : null;
    }
    function kn(e, r, c, g, x, R, _) {
      this.acceptsBooleans = r === ti || r === ir || r === ni, this.attributeName = g, this.attributeNamespace = x, this.mustUseProperty = c, this.propertyName = e, this.type = r, this.sanitizeURL = R, this.removeEmptyString = _;
    }
    var Cn = {}, us = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    us.forEach(function(e) {
      Cn[e] = new kn(
        e,
        da,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
      var r = e[0], c = e[1];
      Cn[r] = new kn(
        r,
        yi,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
      Cn[e] = new kn(
        e,
        ti,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
      Cn[e] = new kn(
        e,
        ti,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(e) {
      Cn[e] = new kn(
        e,
        ir,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      Cn[e] = new kn(
        e,
        ir,
        !0,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      Cn[e] = new kn(
        e,
        ni,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      Cn[e] = new kn(
        e,
        Qi,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(e) {
      Cn[e] = new kn(
        e,
        _a,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var cs = /[\-\:]([a-z])/g, ds = function(e) {
      return e[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var r = e.replace(cs, ds);
      Cn[r] = new kn(
        r,
        yi,
        !1,
        // mustUseProperty
        e,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var r = e.replace(cs, ds);
      Cn[r] = new kn(
        r,
        yi,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var r = e.replace(cs, ds);
      Cn[r] = new kn(
        r,
        yi,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(e) {
      Cn[e] = new kn(
        e,
        yi,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Xs = "xlinkHref";
    Cn[Xs] = new kn(
      "xlinkHref",
      yi,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(e) {
      Cn[e] = new kn(
        e,
        yi,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Ll = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, fs = !1;
    function Vs(e) {
      !fs && Ll.test(e) && (fs = !0, T("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(e)));
    }
    function hs(e, r, c, g) {
      if (g.mustUseProperty) {
        var x = g.propertyName;
        return e[x];
      } else {
        ei(c, r), g.sanitizeURL && Vs("" + c);
        var R = g.attributeName, _ = null;
        if (g.type === ni) {
          if (e.hasAttribute(R)) {
            var Y = e.getAttribute(R);
            return Y === "" ? !0 : Ln(r, c, g, !1) ? Y : Y === "" + c ? c : Y;
          }
        } else if (e.hasAttribute(R)) {
          if (Ln(r, c, g, !1))
            return e.getAttribute(R);
          if (g.type === ir)
            return c;
          _ = e.getAttribute(R);
        }
        return Ln(r, c, g, !1) ? _ === null ? c : _ : _ === "" + c ? c : _;
      }
    }
    function Gs(e, r, c, g) {
      {
        if (!pr(r))
          return;
        if (!e.hasAttribute(r))
          return c === void 0 ? void 0 : null;
        var x = e.getAttribute(r);
        return ei(c, r), x === "" + c ? c : x;
      }
    }
    function Di(e, r, c, g) {
      var x = gr(r);
      if (!$n(r, x, g)) {
        if (Ln(r, c, x, g) && (c = null), g || x === null) {
          if (pr(r)) {
            var R = r;
            c === null ? e.removeAttribute(R) : (ei(c, r), e.setAttribute(R, "" + c));
          }
          return;
        }
        var _ = x.mustUseProperty;
        if (_) {
          var Y = x.propertyName;
          if (c === null) {
            var W = x.type;
            e[Y] = W === ir ? !1 : "";
          } else
            e[Y] = c;
          return;
        }
        var J = x.attributeName, ne = x.attributeNamespace;
        if (c === null)
          e.removeAttribute(J);
        else {
          var ge = x.type, he;
          ge === ir || ge === ni && c === !0 ? he = "" : (ei(c, J), he = "" + c, x.sanitizeURL && Vs(he.toString())), ne ? e.setAttributeNS(ne, J, he) : e.setAttribute(J, he);
        }
      }
    }
    var Pa = Symbol.for("react.element"), Hr = Symbol.for("react.portal"), xi = Symbol.for("react.fragment"), ii = Symbol.for("react.strict_mode"), le = Symbol.for("react.profiler"), Ye = Symbol.for("react.provider"), et = Symbol.for("react.context"), Dt = Symbol.for("react.forward_ref"), qt = Symbol.for("react.suspense"), cn = Symbol.for("react.suspense_list"), Zt = Symbol.for("react.memo"), Ot = Symbol.for("react.lazy"), ar = Symbol.for("react.scope"), Yn = Symbol.for("react.debug_trace_mode"), B = Symbol.for("react.offscreen"), t = Symbol.for("react.legacy_hidden"), n = Symbol.for("react.cache"), i = Symbol.for("react.tracing_marker"), o = Symbol.iterator, d = "@@iterator";
    function f(e) {
      if (e === null || typeof e != "object")
        return null;
      var r = o && e[o] || e[d];
      return typeof r == "function" ? r : null;
    }
    var p = Object.assign, y = 0, S, C, E, L, O, P, I;
    function j() {
    }
    j.__reactDisabledLog = !0;
    function V() {
      {
        if (y === 0) {
          S = console.log, C = console.info, E = console.warn, L = console.error, O = console.group, P = console.groupCollapsed, I = console.groupEnd;
          var e = {
            configurable: !0,
            enumerable: !0,
            value: j,
            writable: !0
          };
          Object.defineProperties(console, {
            info: e,
            log: e,
            warn: e,
            error: e,
            group: e,
            groupCollapsed: e,
            groupEnd: e
          });
        }
        y++;
      }
    }
    function Z() {
      {
        if (y--, y === 0) {
          var e = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: p({}, e, {
              value: S
            }),
            info: p({}, e, {
              value: C
            }),
            warn: p({}, e, {
              value: E
            }),
            error: p({}, e, {
              value: L
            }),
            group: p({}, e, {
              value: O
            }),
            groupCollapsed: p({}, e, {
              value: P
            }),
            groupEnd: p({}, e, {
              value: I
            })
          });
        }
        y < 0 && T("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var b = h.ReactCurrentDispatcher, M;
    function N(e, r, c) {
      {
        if (M === void 0)
          try {
            throw Error();
          } catch (x) {
            var g = x.stack.trim().match(/\n( *(at )?)/);
            M = g && g[1] || "";
          }
        return `
` + M + e;
      }
    }
    var X = !1, K;
    {
      var ee = typeof WeakMap == "function" ? WeakMap : Map;
      K = new ee();
    }
    function oe(e, r) {
      if (!e || X)
        return "";
      {
        var c = K.get(e);
        if (c !== void 0)
          return c;
      }
      var g;
      X = !0;
      var x = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var R;
      R = b.current, b.current = null, V();
      try {
        if (r) {
          var _ = function() {
            throw Error();
          };
          if (Object.defineProperty(_.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(_, []);
            } catch (Ae) {
              g = Ae;
            }
            Reflect.construct(e, [], _);
          } else {
            try {
              _.call();
            } catch (Ae) {
              g = Ae;
            }
            e.call(_.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ae) {
            g = Ae;
          }
          e();
        }
      } catch (Ae) {
        if (Ae && g && typeof Ae.stack == "string") {
          for (var Y = Ae.stack.split(`
`), W = g.stack.split(`
`), J = Y.length - 1, ne = W.length - 1; J >= 1 && ne >= 0 && Y[J] !== W[ne]; )
            ne--;
          for (; J >= 1 && ne >= 0; J--, ne--)
            if (Y[J] !== W[ne]) {
              if (J !== 1 || ne !== 1)
                do
                  if (J--, ne--, ne < 0 || Y[J] !== W[ne]) {
                    var ge = `
` + Y[J].replace(" at new ", " at ");
                    return e.displayName && ge.includes("<anonymous>") && (ge = ge.replace("<anonymous>", e.displayName)), typeof e == "function" && K.set(e, ge), ge;
                  }
                while (J >= 1 && ne >= 0);
              break;
            }
        }
      } finally {
        X = !1, b.current = R, Z(), Error.prepareStackTrace = x;
      }
      var he = e ? e.displayName || e.name : "", Ce = he ? N(he) : "";
      return typeof e == "function" && K.set(e, Ce), Ce;
    }
    function de(e, r, c) {
      return oe(e, !0);
    }
    function ke(e, r, c) {
      return oe(e, !1);
    }
    function _e(e) {
      var r = e.prototype;
      return !!(r && r.isReactComponent);
    }
    function Me(e, r, c) {
      if (e == null)
        return "";
      if (typeof e == "function")
        return oe(e, _e(e));
      if (typeof e == "string")
        return N(e);
      switch (e) {
        case qt:
          return N("Suspense");
        case cn:
          return N("SuspenseList");
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case Dt:
            return ke(e.render);
          case Zt:
            return Me(e.type, r, c);
          case Ot: {
            var g = e, x = g._payload, R = g._init;
            try {
              return Me(R(x), r, c);
            } catch {
            }
          }
        }
      return "";
    }
    function Ie(e) {
      switch (e._debugOwner && e._debugOwner.type, e._debugSource, e.tag) {
        case se:
          return N(e.type);
        case Qe:
          return N("Lazy");
        case re:
          return N("Suspense");
        case ft:
          return N("SuspenseList");
        case H:
        case $:
        case Le:
          return ke(e.type);
        case we:
          return ke(e.type.render);
        case U:
          return de(e.type);
        default:
          return "";
      }
    }
    function rt(e) {
      try {
        var r = "", c = e;
        do
          r += Ie(c), c = c.return;
        while (c);
        return r;
      } catch (g) {
        return `
Error generating stack: ` + g.message + `
` + g.stack;
      }
    }
    function Qt(e, r, c) {
      var g = e.displayName;
      if (g)
        return g;
      var x = r.displayName || r.name || "";
      return x !== "" ? c + "(" + x + ")" : c;
    }
    function Kt(e) {
      return e.displayName || "Context";
    }
    function mt(e) {
      if (e == null)
        return null;
      if (typeof e.tag == "number" && T("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof e == "function")
        return e.displayName || e.name || null;
      if (typeof e == "string")
        return e;
      switch (e) {
        case xi:
          return "Fragment";
        case Hr:
          return "Portal";
        case le:
          return "Profiler";
        case ii:
          return "StrictMode";
        case qt:
          return "Suspense";
        case cn:
          return "SuspenseList";
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case et:
            var r = e;
            return Kt(r) + ".Consumer";
          case Ye:
            var c = e;
            return Kt(c._context) + ".Provider";
          case Dt:
            return Qt(e, e.render, "ForwardRef");
          case Zt:
            var g = e.displayName || null;
            return g !== null ? g : mt(e.type) || "Memo";
          case Ot: {
            var x = e, R = x._payload, _ = x._init;
            try {
              return mt(_(R));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Mn(e, r, c) {
      var g = r.displayName || r.name || "";
      return e.displayName || (g !== "" ? c + "(" + g + ")" : c);
    }
    function zn(e) {
      return e.displayName || "Context";
    }
    function gt(e) {
      var r = e.tag, c = e.type;
      switch (r) {
        case Ht:
          return "Cache";
        case Ne:
          var g = c;
          return zn(g) + ".Consumer";
        case Q:
          var x = c;
          return zn(x._context) + ".Provider";
        case Ge:
          return "DehydratedFragment";
        case we:
          return Mn(c, c.render, "ForwardRef");
        case ue:
          return "Fragment";
        case se:
          return c;
        case te:
          return "Portal";
        case q:
          return "Root";
        case ae:
          return "Text";
        case Qe:
          return mt(c);
        case Re:
          return c === ii ? "StrictMode" : "Mode";
        case st:
          return "Offscreen";
        case Ee:
          return "Profiler";
        case wt:
          return "Scope";
        case re:
          return "Suspense";
        case ft:
          return "SuspenseList";
        case Mt:
          return "TracingMarker";
        case U:
        case H:
        case Be:
        case $:
        case ve:
        case Le:
          if (typeof c == "function")
            return c.displayName || c.name || null;
          if (typeof c == "string")
            return c;
          break;
      }
      return null;
    }
    var jr = h.ReactDebugCurrentFrame, Dn = null, ai = !1;
    function si() {
      {
        if (Dn === null)
          return null;
        var e = Dn._debugOwner;
        if (e !== null && typeof e < "u")
          return gt(e);
      }
      return null;
    }
    function vr() {
      return Dn === null ? "" : rt(Dn);
    }
    function ln() {
      jr.getCurrentStack = null, Dn = null, ai = !1;
    }
    function wn(e) {
      jr.getCurrentStack = e === null ? null : vr, Dn = e, ai = !1;
    }
    function lx() {
      return Dn;
    }
    function Na(e) {
      ai = e;
    }
    function oi(e) {
      return "" + e;
    }
    function $s(e) {
      switch (typeof e) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return e;
        case "object":
          return mi(e), e;
        default:
          return "";
      }
    }
    var Cg = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Ml(e, r) {
      Cg[r.type] || r.onChange || r.onInput || r.readOnly || r.disabled || r.value == null || T("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), r.onChange || r.readOnly || r.disabled || r.checked == null || T("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Uf(e) {
      var r = e.type, c = e.nodeName;
      return c && c.toLowerCase() === "input" && (r === "checkbox" || r === "radio");
    }
    function Ag(e) {
      return e._valueTracker;
    }
    function Ou(e) {
      e._valueTracker = null;
    }
    function _u(e) {
      var r = "";
      return e && (Uf(e) ? r = e.checked ? "true" : "false" : r = e.value), r;
    }
    function Dl(e) {
      var r = Uf(e) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(e.constructor.prototype, r);
      mi(e[r]);
      var g = "" + e[r];
      if (!(e.hasOwnProperty(r) || typeof c > "u" || typeof c.get != "function" || typeof c.set != "function")) {
        var x = c.get, R = c.set;
        Object.defineProperty(e, r, {
          configurable: !0,
          get: function() {
            return x.call(this);
          },
          set: function(Y) {
            mi(Y), g = "" + Y, R.call(this, Y);
          }
        }), Object.defineProperty(e, r, {
          enumerable: c.enumerable
        });
        var _ = {
          getValue: function() {
            return g;
          },
          setValue: function(Y) {
            mi(Y), g = "" + Y;
          },
          stopTracking: function() {
            Ou(e), delete e[r];
          }
        };
        return _;
      }
    }
    function _o(e) {
      Ag(e) || (e._valueTracker = Dl(e));
    }
    function Tg(e) {
      if (!e)
        return !1;
      var r = Ag(e);
      if (!r)
        return !0;
      var c = r.getValue(), g = _u(e);
      return g !== c ? (r.setValue(g), !0) : !1;
    }
    function Uc(e) {
      if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u")
        return null;
      try {
        return e.activeElement || e.body;
      } catch {
        return e.body;
      }
    }
    var Bc = !1, Pu = !1, Wc = !1, Bf = !1;
    function ps(e) {
      var r = e.type === "checkbox" || e.type === "radio";
      return r ? e.checked != null : e.value != null;
    }
    function Nu(e, r) {
      var c = e, g = r.checked, x = p({}, r, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: g ?? c._wrapperState.initialChecked
      });
      return x;
    }
    function zu(e, r) {
      Ml("input", r), r.checked !== void 0 && r.defaultChecked !== void 0 && !Pu && (T("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", si() || "A component", r.type), Pu = !0), r.value !== void 0 && r.defaultValue !== void 0 && !Bc && (T("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", si() || "A component", r.type), Bc = !0);
      var c = e, g = r.defaultValue == null ? "" : r.defaultValue;
      c._wrapperState = {
        initialChecked: r.checked != null ? r.checked : r.defaultChecked,
        initialValue: $s(r.value != null ? r.value : g),
        controlled: ps(r)
      };
    }
    function Wf(e, r) {
      var c = e, g = r.checked;
      g != null && Di(c, "checked", g, !1);
    }
    function Ol(e, r) {
      var c = e;
      {
        var g = ps(r);
        !c._wrapperState.controlled && g && !Bf && (T("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Bf = !0), c._wrapperState.controlled && !g && !Wc && (T("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Wc = !0);
      }
      Wf(e, r);
      var x = $s(r.value), R = r.type;
      if (x != null)
        R === "number" ? (x === 0 && c.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        c.value != x) && (c.value = oi(x)) : c.value !== oi(x) && (c.value = oi(x));
      else if (R === "submit" || R === "reset") {
        c.removeAttribute("value");
        return;
      }
      r.hasOwnProperty("value") ? qs(c, r.type, x) : r.hasOwnProperty("defaultValue") && qs(c, r.type, $s(r.defaultValue)), r.checked == null && r.defaultChecked != null && (c.defaultChecked = !!r.defaultChecked);
    }
    function Iu(e, r, c) {
      var g = e;
      if (r.hasOwnProperty("value") || r.hasOwnProperty("defaultValue")) {
        var x = r.type, R = x === "submit" || x === "reset";
        if (R && (r.value === void 0 || r.value === null))
          return;
        var _ = oi(g._wrapperState.initialValue);
        c || _ !== g.value && (g.value = _), g.defaultValue = _;
      }
      var Y = g.name;
      Y !== "" && (g.name = ""), g.defaultChecked = !g.defaultChecked, g.defaultChecked = !!g._wrapperState.initialChecked, Y !== "" && (g.name = Y);
    }
    function Eg(e, r) {
      var c = e;
      Ol(c, r), Ki(c, r);
    }
    function Ki(e, r) {
      var c = r.name;
      if (r.type === "radio" && c != null) {
        for (var g = e; g.parentNode; )
          g = g.parentNode;
        ei(c, "name");
        for (var x = g.querySelectorAll("input[name=" + JSON.stringify("" + c) + '][type="radio"]'), R = 0; R < x.length; R++) {
          var _ = x[R];
          if (!(_ === e || _.form !== e.form)) {
            var Y = rm(_);
            if (!Y)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            Tg(_), Ol(_, Y);
          }
        }
      }
    }
    function qs(e, r, c) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (r !== "number" || Uc(e.ownerDocument) !== e) && (c == null ? e.defaultValue = oi(e._wrapperState.initialValue) : e.defaultValue !== oi(c) && (e.defaultValue = oi(c)));
    }
    var Xc = !1, _l = !1, Rg = !1;
    function Vc(e, r) {
      r.value == null && (typeof r.children == "object" && r.children !== null ? s.Children.forEach(r.children, function(c) {
        c != null && (typeof c == "string" || typeof c == "number" || _l || (_l = !0, T("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : r.dangerouslySetInnerHTML != null && (Rg || (Rg = !0, T("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), r.selected != null && !Xc && (T("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Xc = !0);
    }
    function Xf(e, r) {
      r.value != null && e.setAttribute("value", oi($s(r.value)));
    }
    var Fu = Array.isArray;
    function Dr(e) {
      return Fu(e);
    }
    var Gc;
    Gc = !1;
    function Lg() {
      var e = si();
      return e ? `

Check the render method of \`` + e + "`." : "";
    }
    var Mg = ["value", "defaultValue"];
    function ux(e) {
      {
        Ml("select", e);
        for (var r = 0; r < Mg.length; r++) {
          var c = Mg[r];
          if (e[c] != null) {
            var g = Dr(e[c]);
            e.multiple && !g ? T("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", c, Lg()) : !e.multiple && g && T("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", c, Lg());
          }
        }
      }
    }
    function Zs(e, r, c, g) {
      var x = e.options;
      if (r) {
        for (var R = c, _ = {}, Y = 0; Y < R.length; Y++)
          _["$" + R[Y]] = !0;
        for (var W = 0; W < x.length; W++) {
          var J = _.hasOwnProperty("$" + x[W].value);
          x[W].selected !== J && (x[W].selected = J), J && g && (x[W].defaultSelected = !0);
        }
      } else {
        for (var ne = oi($s(c)), ge = null, he = 0; he < x.length; he++) {
          if (x[he].value === ne) {
            x[he].selected = !0, g && (x[he].defaultSelected = !0);
            return;
          }
          ge === null && !x[he].disabled && (ge = x[he]);
        }
        ge !== null && (ge.selected = !0);
      }
    }
    function Vf(e, r) {
      return p({}, r, {
        value: void 0
      });
    }
    function Dg(e, r) {
      var c = e;
      ux(r), c._wrapperState = {
        wasMultiple: !!r.multiple
      }, r.value !== void 0 && r.defaultValue !== void 0 && !Gc && (T("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Gc = !0);
    }
    function cx(e, r) {
      var c = e;
      c.multiple = !!r.multiple;
      var g = r.value;
      g != null ? Zs(c, !!r.multiple, g, !1) : r.defaultValue != null && Zs(c, !!r.multiple, r.defaultValue, !0);
    }
    function dx(e, r) {
      var c = e, g = c._wrapperState.wasMultiple;
      c._wrapperState.wasMultiple = !!r.multiple;
      var x = r.value;
      x != null ? Zs(c, !!r.multiple, x, !1) : g !== !!r.multiple && (r.defaultValue != null ? Zs(c, !!r.multiple, r.defaultValue, !0) : Zs(c, !!r.multiple, r.multiple ? [] : "", !1));
    }
    function fx(e, r) {
      var c = e, g = r.value;
      g != null && Zs(c, !!r.multiple, g, !1);
    }
    var Gf = !1;
    function $f(e, r) {
      var c = e;
      if (r.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var g = p({}, r, {
        value: void 0,
        defaultValue: void 0,
        children: oi(c._wrapperState.initialValue)
      });
      return g;
    }
    function Og(e, r) {
      var c = e;
      Ml("textarea", r), r.value !== void 0 && r.defaultValue !== void 0 && !Gf && (T("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", si() || "A component"), Gf = !0);
      var g = r.value;
      if (g == null) {
        var x = r.children, R = r.defaultValue;
        if (x != null) {
          T("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (R != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Dr(x)) {
              if (x.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              x = x[0];
            }
            R = x;
          }
        }
        R == null && (R = ""), g = R;
      }
      c._wrapperState = {
        initialValue: $s(g)
      };
    }
    function _g(e, r) {
      var c = e, g = $s(r.value), x = $s(r.defaultValue);
      if (g != null) {
        var R = oi(g);
        R !== c.value && (c.value = R), r.defaultValue == null && c.defaultValue !== R && (c.defaultValue = R);
      }
      x != null && (c.defaultValue = oi(x));
    }
    function Pg(e, r) {
      var c = e, g = c.textContent;
      g === c._wrapperState.initialValue && g !== "" && g !== null && (c.value = g);
    }
    function qf(e, r) {
      _g(e, r);
    }
    var gs = "http://www.w3.org/1999/xhtml", hx = "http://www.w3.org/1998/Math/MathML", Zf = "http://www.w3.org/2000/svg";
    function $c(e) {
      switch (e) {
        case "svg":
          return Zf;
        case "math":
          return hx;
        default:
          return gs;
      }
    }
    function Qf(e, r) {
      return e == null || e === gs ? $c(r) : e === Zf && r === "foreignObject" ? gs : e;
    }
    var px = function(e) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(r, c, g, x) {
        MSApp.execUnsafeLocalFunction(function() {
          return e(r, c, g, x);
        });
      } : e;
    }, qc, Ng = px(function(e, r) {
      if (e.namespaceURI === Zf && !("innerHTML" in e)) {
        qc = qc || document.createElement("div"), qc.innerHTML = "<svg>" + r.valueOf().toString() + "</svg>";
        for (var c = qc.firstChild; e.firstChild; )
          e.removeChild(e.firstChild);
        for (; c.firstChild; )
          e.appendChild(c.firstChild);
        return;
      }
      e.innerHTML = r;
    }), Oi = 1, vs = 3, mr = 8, za = 9, Po = 11, Zc = function(e, r) {
      if (r) {
        var c = e.firstChild;
        if (c && c === e.lastChild && c.nodeType === vs) {
          c.nodeValue = r;
          return;
        }
      }
      e.textContent = r;
    }, zg = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, Pl = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Ig(e, r) {
      return e + r.charAt(0).toUpperCase() + r.substring(1);
    }
    var Fg = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Pl).forEach(function(e) {
      Fg.forEach(function(r) {
        Pl[Ig(r, e)] = Pl[e];
      });
    });
    function Qc(e, r, c) {
      var g = r == null || typeof r == "boolean" || r === "";
      return g ? "" : !c && typeof r == "number" && r !== 0 && !(Pl.hasOwnProperty(e) && Pl[e]) ? r + "px" : (ca(r, e), ("" + r).trim());
    }
    var Nl = /([A-Z])/g, gx = /^ms-/;
    function vx(e) {
      return e.replace(Nl, "-$1").toLowerCase().replace(gx, "-ms-");
    }
    var Yg = function() {
    };
    {
      var Hg = /^(?:webkit|moz|o)[A-Z]/, jg = /^-ms-/, Yu = /-(.)/g, zl = /;\s*$/, Il = {}, Fl = {}, Ug = !1, Kf = !1, Jf = function(e) {
        return e.replace(Yu, function(r, c) {
          return c.toUpperCase();
        });
      }, eh = function(e) {
        Il.hasOwnProperty(e) && Il[e] || (Il[e] = !0, T(
          "Unsupported style property %s. Did you mean %s?",
          e,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Jf(e.replace(jg, "ms-"))
        ));
      }, Bg = function(e) {
        Il.hasOwnProperty(e) && Il[e] || (Il[e] = !0, T("Unsupported vendor-prefixed style property %s. Did you mean %s?", e, e.charAt(0).toUpperCase() + e.slice(1)));
      }, Wg = function(e, r) {
        Fl.hasOwnProperty(r) && Fl[r] || (Fl[r] = !0, T(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, e, r.replace(zl, "")));
      }, Xg = function(e, r) {
        Ug || (Ug = !0, T("`NaN` is an invalid value for the `%s` css style property.", e));
      }, mx = function(e, r) {
        Kf || (Kf = !0, T("`Infinity` is an invalid value for the `%s` css style property.", e));
      };
      Yg = function(e, r) {
        e.indexOf("-") > -1 ? eh(e) : Hg.test(e) ? Bg(e) : zl.test(r) && Wg(e, r), typeof r == "number" && (isNaN(r) ? Xg(e, r) : isFinite(r) || mx(e, r));
      };
    }
    var yx = Yg;
    function xx(e) {
      {
        var r = "", c = "";
        for (var g in e)
          if (e.hasOwnProperty(g)) {
            var x = e[g];
            if (x != null) {
              var R = g.indexOf("--") === 0;
              r += c + (R ? g : vx(g)) + ":", r += Qc(g, x, R), c = ";";
            }
          }
        return r || null;
      }
    }
    function Vg(e, r) {
      var c = e.style;
      for (var g in r)
        if (r.hasOwnProperty(g)) {
          var x = g.indexOf("--") === 0;
          x || yx(g, r[g]);
          var R = Qc(g, r[g], x);
          g === "float" && (g = "cssFloat"), x ? c.setProperty(g, R) : c[g] = R;
        }
    }
    function bx(e) {
      return e == null || typeof e == "boolean" || e === "";
    }
    function fa(e) {
      var r = {};
      for (var c in e)
        for (var g = zg[c] || [c], x = 0; x < g.length; x++)
          r[g[x]] = c;
      return r;
    }
    function Hu(e, r) {
      {
        if (!r)
          return;
        var c = fa(e), g = fa(r), x = {};
        for (var R in c) {
          var _ = c[R], Y = g[R];
          if (Y && _ !== Y) {
            var W = _ + "," + Y;
            if (x[W])
              continue;
            x[W] = !0, T("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", bx(e[_]) ? "Removing" : "Updating", _, Y);
          }
        }
      }
    }
    var Gg = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, $g = p({
      menuitem: !0
    }, Gg), qg = "__html";
    function Kc(e, r) {
      if (r) {
        if ($g[e] && (r.children != null || r.dangerouslySetInnerHTML != null))
          throw new Error(e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (r.dangerouslySetInnerHTML != null) {
          if (r.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof r.dangerouslySetInnerHTML != "object" || !(qg in r.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!r.suppressContentEditableWarning && r.contentEditable && r.children != null && T("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), r.style != null && typeof r.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function ms(e, r) {
      if (e.indexOf("-") === -1)
        return typeof r.is == "string";
      switch (e) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Jc = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Zg = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Ia = {}, th = new RegExp("^(aria)-[" + Rt + "]*$"), ju = new RegExp("^(aria)[A-Z][" + Rt + "]*$");
    function nh(e, r) {
      {
        if (jn.call(Ia, r) && Ia[r])
          return !0;
        if (ju.test(r)) {
          var c = "aria-" + r.slice(4).toLowerCase(), g = Zg.hasOwnProperty(c) ? c : null;
          if (g == null)
            return T("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", r), Ia[r] = !0, !0;
          if (r !== g)
            return T("Invalid ARIA attribute `%s`. Did you mean `%s`?", r, g), Ia[r] = !0, !0;
        }
        if (th.test(r)) {
          var x = r.toLowerCase(), R = Zg.hasOwnProperty(x) ? x : null;
          if (R == null)
            return Ia[r] = !0, !1;
          if (r !== R)
            return T("Unknown ARIA attribute `%s`. Did you mean `%s`?", r, R), Ia[r] = !0, !0;
        }
      }
      return !0;
    }
    function Qg(e, r) {
      {
        var c = [];
        for (var g in r) {
          var x = nh(e, g);
          x || c.push(g);
        }
        var R = c.map(function(_) {
          return "`" + _ + "`";
        }).join(", ");
        c.length === 1 ? T("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", R, e) : c.length > 1 && T("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", R, e);
      }
    }
    function ed(e, r) {
      ms(e, r) || Qg(e, r);
    }
    var No = !1;
    function rh(e, r) {
      {
        if (e !== "input" && e !== "textarea" && e !== "select")
          return;
        r != null && r.value === null && !No && (No = !0, e === "select" && r.multiple ? T("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", e) : T("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", e));
      }
    }
    var ih = function() {
    };
    {
      var Or = {}, ah = /^on./, Kg = /^on[^A-Z]/, Jg = new RegExp("^(aria)-[" + Rt + "]*$"), ev = new RegExp("^(aria)[A-Z][" + Rt + "]*$");
      ih = function(e, r, c, g) {
        if (jn.call(Or, r) && Or[r])
          return !0;
        var x = r.toLowerCase();
        if (x === "onfocusin" || x === "onfocusout")
          return T("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Or[r] = !0, !0;
        if (g != null) {
          var R = g.registrationNameDependencies, _ = g.possibleRegistrationNames;
          if (R.hasOwnProperty(r))
            return !0;
          var Y = _.hasOwnProperty(x) ? _[x] : null;
          if (Y != null)
            return T("Invalid event handler property `%s`. Did you mean `%s`?", r, Y), Or[r] = !0, !0;
          if (ah.test(r))
            return T("Unknown event handler property `%s`. It will be ignored.", r), Or[r] = !0, !0;
        } else if (ah.test(r))
          return Kg.test(r) && T("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", r), Or[r] = !0, !0;
        if (Jg.test(r) || ev.test(r))
          return !0;
        if (x === "innerhtml")
          return T("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Or[r] = !0, !0;
        if (x === "aria")
          return T("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Or[r] = !0, !0;
        if (x === "is" && c !== null && c !== void 0 && typeof c != "string")
          return T("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof c), Or[r] = !0, !0;
        if (typeof c == "number" && isNaN(c))
          return T("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", r), Or[r] = !0, !0;
        var W = gr(r), J = W !== null && W.type === da;
        if (Jc.hasOwnProperty(x)) {
          var ne = Jc[x];
          if (ne !== r)
            return T("Invalid DOM property `%s`. Did you mean `%s`?", r, ne), Or[r] = !0, !0;
        } else if (!J && r !== x)
          return T("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", r, x), Or[r] = !0, !0;
        return typeof c == "boolean" && ri(r, c, W, !1) ? (c ? T('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', c, r, r, c, r) : T('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', c, r, r, c, r, r, r), Or[r] = !0, !0) : J ? !0 : ri(r, c, W, !1) ? (Or[r] = !0, !1) : ((c === "false" || c === "true") && W !== null && W.type === ir && (T("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", c, r, c === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', r, c), Or[r] = !0), !0);
      };
    }
    var tv = function(e, r, c) {
      {
        var g = [];
        for (var x in r) {
          var R = ih(e, x, r[x], c);
          R || g.push(x);
        }
        var _ = g.map(function(Y) {
          return "`" + Y + "`";
        }).join(", ");
        g.length === 1 ? T("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", _, e) : g.length > 1 && T("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", _, e);
      }
    };
    function nv(e, r, c) {
      ms(e, r) || tv(e, r, c);
    }
    var ys = 1, Uu = 2, zo = 4, wx = ys | Uu | zo, Bu = null;
    function Wu(e) {
      Bu !== null && T("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Bu = e;
    }
    function Sx() {
      Bu === null && T("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Bu = null;
    }
    function rv(e) {
      return e === Bu;
    }
    function td(e) {
      var r = e.target || e.srcElement || window;
      return r.correspondingUseElement && (r = r.correspondingUseElement), r.nodeType === vs ? r.parentNode : r;
    }
    var In = null, Qs = null, xs = null;
    function Yl(e) {
      var r = du(e);
      if (r) {
        if (typeof In != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var c = r.stateNode;
        if (c) {
          var g = rm(c);
          In(r.stateNode, r.type, g);
        }
      }
    }
    function iv(e) {
      In = e;
    }
    function nd(e) {
      Qs ? xs ? xs.push(e) : xs = [e] : Qs = e;
    }
    function Xu() {
      return Qs !== null || xs !== null;
    }
    function Vu() {
      if (Qs) {
        var e = Qs, r = xs;
        if (Qs = null, xs = null, Yl(e), r)
          for (var c = 0; c < r.length; c++)
            Yl(r[c]);
      }
    }
    var Io = function(e, r) {
      return e(r);
    }, sh = function() {
    }, oh = !1;
    function kx() {
      var e = Xu();
      e && (sh(), Vu());
    }
    function lh(e, r, c) {
      if (oh)
        return e(r, c);
      oh = !0;
      try {
        return Io(e, r, c);
      } finally {
        oh = !1, kx();
      }
    }
    function rd(e, r, c) {
      Io = e, sh = c;
    }
    function id(e) {
      return e === "button" || e === "input" || e === "select" || e === "textarea";
    }
    function uh(e, r, c) {
      switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(c.disabled && id(r));
        default:
          return !1;
      }
    }
    function Fo(e, r) {
      var c = e.stateNode;
      if (c === null)
        return null;
      var g = rm(c);
      if (g === null)
        return null;
      var x = g[r];
      if (uh(r, e.type, g))
        return null;
      if (x && typeof x != "function")
        throw new Error("Expected `" + r + "` listener to be a function, instead got a value of `" + typeof x + "` type.");
      return x;
    }
    var Gu = !1;
    if (pn)
      try {
        var Yo = {};
        Object.defineProperty(Yo, "passive", {
          get: function() {
            Gu = !0;
          }
        }), window.addEventListener("test", Yo, Yo), window.removeEventListener("test", Yo, Yo);
      } catch {
        Gu = !1;
      }
    function av(e, r, c, g, x, R, _, Y, W) {
      var J = Array.prototype.slice.call(arguments, 3);
      try {
        r.apply(c, J);
      } catch (ne) {
        this.onError(ne);
      }
    }
    var ch = av;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var dh = document.createElement("react");
      ch = function(r, c, g, x, R, _, Y, W, J) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var ne = document.createEvent("Event"), ge = !1, he = !0, Ce = window.event, Ae = Object.getOwnPropertyDescriptor(window, "event");
        function De() {
          dh.removeEventListener(Oe, Pt, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Ce);
        }
        var ct = Array.prototype.slice.call(arguments, 3);
        function Pt() {
          ge = !0, De(), c.apply(g, ct), he = !1;
        }
        var Tt, hn = !1, on = !1;
        function xe(be) {
          if (Tt = be.error, hn = !0, Tt === null && be.colno === 0 && be.lineno === 0 && (on = !0), be.defaultPrevented && Tt != null && typeof Tt == "object")
            try {
              Tt._suppressLogging = !0;
            } catch {
            }
        }
        var Oe = "react-" + (r || "invokeguardedcallback");
        if (window.addEventListener("error", xe), dh.addEventListener(Oe, Pt, !1), ne.initEvent(Oe, !1, !1), dh.dispatchEvent(ne), Ae && Object.defineProperty(window, "event", Ae), ge && he && (hn ? on && (Tt = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Tt = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Tt)), window.removeEventListener("error", xe), !ge)
          return De(), av.apply(this, arguments);
      };
    }
    var Cx = ch, Ks = !1, Fa = null, $u = !1, Js = null, Va = {
      onError: function(e) {
        Ks = !0, Fa = e;
      }
    };
    function Ho(e, r, c, g, x, R, _, Y, W) {
      Ks = !1, Fa = null, Cx.apply(Va, arguments);
    }
    function bs(e, r, c, g, x, R, _, Y, W) {
      if (Ho.apply(this, arguments), Ks) {
        var J = hh();
        $u || ($u = !0, Js = J);
      }
    }
    function fh() {
      if ($u) {
        var e = Js;
        throw $u = !1, Js = null, e;
      }
    }
    function Ax() {
      return Ks;
    }
    function hh() {
      if (Ks) {
        var e = Fa;
        return Ks = !1, Fa = null, e;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function ha(e) {
      return e._reactInternals;
    }
    function qu(e) {
      return e._reactInternals !== void 0;
    }
    function Hl(e, r) {
      e._reactInternals = r;
    }
    var _t = (
      /*                      */
      0
    ), eo = (
      /*                */
      1
    ), Bn = (
      /*                    */
      2
    ), Jt = (
      /*                       */
      4
    ), Sn = (
      /*                */
      16
    ), An = (
      /*                 */
      32
    ), Ga = (
      /*                     */
      64
    ), Xt = (
      /*                   */
      128
    ), sr = (
      /*            */
      256
    ), _i = (
      /*                          */
      512
    ), pa = (
      /*                     */
      1024
    ), qn = (
      /*                      */
      2048
    ), ga = (
      /*                    */
      4096
    ), to = (
      /*                   */
      8192
    ), Zu = (
      /*             */
      16384
    ), ad = qn | Jt | Ga | _i | pa | Zu, sv = (
      /*               */
      32767
    ), Ji = (
      /*                   */
      32768
    ), _r = (
      /*                */
      65536
    ), Qu = (
      /* */
      131072
    ), ph = (
      /*                       */
      1048576
    ), gh = (
      /*                    */
      2097152
    ), Pi = (
      /*                 */
      4194304
    ), no = (
      /*                */
      8388608
    ), Ni = (
      /*               */
      16777216
    ), jo = (
      /*              */
      33554432
    ), jl = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Jt | pa | 0
    ), zi = Bn | Jt | Sn | An | _i | ga | to, li = Jt | Ga | _i | to, va = qn | Sn, Ur = Pi | no | gh, ws = h.ReactCurrentOwner;
    function ea(e) {
      var r = e, c = e;
      if (e.alternate)
        for (; r.return; )
          r = r.return;
      else {
        var g = r;
        do
          r = g, (r.flags & (Bn | ga)) !== _t && (c = r.return), g = r.return;
        while (g);
      }
      return r.tag === q ? c : null;
    }
    function vh(e) {
      if (e.tag === re) {
        var r = e.memoizedState;
        if (r === null) {
          var c = e.alternate;
          c !== null && (r = c.memoizedState);
        }
        if (r !== null)
          return r.dehydrated;
      }
      return null;
    }
    function sd(e) {
      return e.tag === q ? e.stateNode.containerInfo : null;
    }
    function mh(e) {
      return ea(e) === e;
    }
    function ta(e) {
      {
        var r = ws.current;
        if (r !== null && r.tag === U) {
          var c = r, g = c.stateNode;
          g._warnedAboutRefsInRender || T("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", gt(c) || "A component"), g._warnedAboutRefsInRender = !0;
        }
      }
      var x = ha(e);
      return x ? ea(x) === x : !1;
    }
    function Ii(e) {
      if (ea(e) !== e)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Wn(e) {
      var r = e.alternate;
      if (!r) {
        var c = ea(e);
        if (c === null)
          throw new Error("Unable to find node on an unmounted component.");
        return c !== e ? null : e;
      }
      for (var g = e, x = r; ; ) {
        var R = g.return;
        if (R === null)
          break;
        var _ = R.alternate;
        if (_ === null) {
          var Y = R.return;
          if (Y !== null) {
            g = x = Y;
            continue;
          }
          break;
        }
        if (R.child === _.child) {
          for (var W = R.child; W; ) {
            if (W === g)
              return Ii(R), e;
            if (W === x)
              return Ii(R), r;
            W = W.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (g.return !== x.return)
          g = R, x = _;
        else {
          for (var J = !1, ne = R.child; ne; ) {
            if (ne === g) {
              J = !0, g = R, x = _;
              break;
            }
            if (ne === x) {
              J = !0, x = R, g = _;
              break;
            }
            ne = ne.sibling;
          }
          if (!J) {
            for (ne = _.child; ne; ) {
              if (ne === g) {
                J = !0, g = _, x = R;
                break;
              }
              if (ne === x) {
                J = !0, x = _, g = R;
                break;
              }
              ne = ne.sibling;
            }
            if (!J)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (g.alternate !== x)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (g.tag !== q)
        throw new Error("Unable to find node on an unmounted component.");
      return g.stateNode.current === g ? e : r;
    }
    function ma(e) {
      var r = Wn(e);
      return r !== null ? yh(r) : null;
    }
    function yh(e) {
      if (e.tag === se || e.tag === ae)
        return e;
      for (var r = e.child; r !== null; ) {
        var c = yh(r);
        if (c !== null)
          return c;
        r = r.sibling;
      }
      return null;
    }
    function ov(e) {
      var r = Wn(e);
      return r !== null ? od(r) : null;
    }
    function od(e) {
      if (e.tag === se || e.tag === ae)
        return e;
      for (var r = e.child; r !== null; ) {
        if (r.tag !== te) {
          var c = od(r);
          if (c !== null)
            return c;
        }
        r = r.sibling;
      }
      return null;
    }
    var ld = u.unstable_scheduleCallback, lv = u.unstable_cancelCallback, ud = u.unstable_shouldYield, uv = u.unstable_requestPaint, Qn = u.unstable_now, xh = u.unstable_getCurrentPriorityLevel, cd = u.unstable_ImmediatePriority, na = u.unstable_UserBlockingPriority, $a = u.unstable_NormalPriority, dd = u.unstable_LowPriority, ro = u.unstable_IdlePriority, bh = u.unstable_yieldValue, wh = u.unstable_setDisableYieldValue, io = null, Pr = null, tt = null, cr = !1, Br = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Sh(e) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var r = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (r.isDisabled)
        return !0;
      if (!r.supportsFiber)
        return T("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        jt && (e = p({}, e, {
          getLaneLabelMap: so,
          injectProfilingHooks: ks
        })), io = r.inject(e), Pr = r;
      } catch (c) {
        T("React instrumentation encountered an error: %s.", c);
      }
      return !!r.checkDCE;
    }
    function cv(e, r) {
      if (Pr && typeof Pr.onScheduleFiberRoot == "function")
        try {
          Pr.onScheduleFiberRoot(io, e, r);
        } catch (c) {
          cr || (cr = !0, T("React instrumentation encountered an error: %s", c));
        }
    }
    function Ss(e, r) {
      if (Pr && typeof Pr.onCommitFiberRoot == "function")
        try {
          var c = (e.current.flags & Xt) === Xt;
          if (ot) {
            var g;
            switch (r) {
              case ui:
                g = cd;
                break;
              case Wr:
                g = na;
                break;
              case As:
                g = $a;
                break;
              case sc:
                g = ro;
                break;
              default:
                g = $a;
                break;
            }
            Pr.onCommitFiberRoot(io, e, g, c);
          }
        } catch (x) {
          cr || (cr = !0, T("React instrumentation encountered an error: %s", x));
        }
    }
    function ao(e) {
      if (Pr && typeof Pr.onPostCommitFiberRoot == "function")
        try {
          Pr.onPostCommitFiberRoot(io, e);
        } catch (r) {
          cr || (cr = !0, T("React instrumentation encountered an error: %s", r));
        }
    }
    function kh(e) {
      if (Pr && typeof Pr.onCommitFiberUnmount == "function")
        try {
          Pr.onCommitFiberUnmount(io, e);
        } catch (r) {
          cr || (cr = !0, T("React instrumentation encountered an error: %s", r));
        }
    }
    function Sr(e) {
      if (typeof bh == "function" && (wh(e), w(e)), Pr && typeof Pr.setStrictMode == "function")
        try {
          Pr.setStrictMode(io, e);
        } catch (r) {
          cr || (cr = !0, T("React instrumentation encountered an error: %s", r));
        }
    }
    function ks(e) {
      tt = e;
    }
    function so() {
      {
        for (var e = /* @__PURE__ */ new Map(), r = 1, c = 0; c < Xn; c++) {
          var g = Tx(r);
          e.set(r, g), r *= 2;
        }
        return e;
      }
    }
    function fd(e) {
      tt !== null && typeof tt.markCommitStarted == "function" && tt.markCommitStarted(e);
    }
    function Ch() {
      tt !== null && typeof tt.markCommitStopped == "function" && tt.markCommitStopped();
    }
    function oo(e) {
      tt !== null && typeof tt.markComponentRenderStarted == "function" && tt.markComponentRenderStarted(e);
    }
    function Uo() {
      tt !== null && typeof tt.markComponentRenderStopped == "function" && tt.markComponentRenderStopped();
    }
    function dv(e) {
      tt !== null && typeof tt.markComponentPassiveEffectMountStarted == "function" && tt.markComponentPassiveEffectMountStarted(e);
    }
    function Ah() {
      tt !== null && typeof tt.markComponentPassiveEffectMountStopped == "function" && tt.markComponentPassiveEffectMountStopped();
    }
    function hd(e) {
      tt !== null && typeof tt.markComponentPassiveEffectUnmountStarted == "function" && tt.markComponentPassiveEffectUnmountStarted(e);
    }
    function fv() {
      tt !== null && typeof tt.markComponentPassiveEffectUnmountStopped == "function" && tt.markComponentPassiveEffectUnmountStopped();
    }
    function hv(e) {
      tt !== null && typeof tt.markComponentLayoutEffectMountStarted == "function" && tt.markComponentLayoutEffectMountStarted(e);
    }
    function pv() {
      tt !== null && typeof tt.markComponentLayoutEffectMountStopped == "function" && tt.markComponentLayoutEffectMountStopped();
    }
    function pd(e) {
      tt !== null && typeof tt.markComponentLayoutEffectUnmountStarted == "function" && tt.markComponentLayoutEffectUnmountStarted(e);
    }
    function Ul() {
      tt !== null && typeof tt.markComponentLayoutEffectUnmountStopped == "function" && tt.markComponentLayoutEffectUnmountStopped();
    }
    function gd(e, r, c) {
      tt !== null && typeof tt.markComponentErrored == "function" && tt.markComponentErrored(e, r, c);
    }
    function gv(e, r, c) {
      tt !== null && typeof tt.markComponentSuspended == "function" && tt.markComponentSuspended(e, r, c);
    }
    function vv(e) {
      tt !== null && typeof tt.markLayoutEffectsStarted == "function" && tt.markLayoutEffectsStarted(e);
    }
    function Bl() {
      tt !== null && typeof tt.markLayoutEffectsStopped == "function" && tt.markLayoutEffectsStopped();
    }
    function mv(e) {
      tt !== null && typeof tt.markPassiveEffectsStarted == "function" && tt.markPassiveEffectsStarted(e);
    }
    function Ku() {
      tt !== null && typeof tt.markPassiveEffectsStopped == "function" && tt.markPassiveEffectsStopped();
    }
    function Ya(e) {
      tt !== null && typeof tt.markRenderStarted == "function" && tt.markRenderStarted(e);
    }
    function Ju() {
      tt !== null && typeof tt.markRenderYielded == "function" && tt.markRenderYielded();
    }
    function Wl() {
      tt !== null && typeof tt.markRenderStopped == "function" && tt.markRenderStopped();
    }
    function Bo(e) {
      tt !== null && typeof tt.markRenderScheduled == "function" && tt.markRenderScheduled(e);
    }
    function Th(e, r) {
      tt !== null && typeof tt.markForceUpdateScheduled == "function" && tt.markForceUpdateScheduled(e, r);
    }
    function lo(e, r) {
      tt !== null && typeof tt.markStateUpdateScheduled == "function" && tt.markStateUpdateScheduled(e, r);
    }
    var Nt = (
      /*                         */
      0
    ), nn = (
      /*                 */
      1
    ), Ft = (
      /*                    */
      2
    ), Kn = (
      /*               */
      8
    ), ya = (
      /*              */
      16
    ), vd = Math.clz32 ? Math.clz32 : Wo, md = Math.log, Eh = Math.LN2;
    function Wo(e) {
      var r = e >>> 0;
      return r === 0 ? 32 : 31 - (md(r) / Eh | 0) | 0;
    }
    var Xn = 31, Pe = (
      /*                        */
      0
    ), dn = (
      /*                          */
      0
    ), Yt = (
      /*                        */
      1
    ), qa = (
      /*    */
      2
    ), ra = (
      /*             */
      4
    ), Xo = (
      /*            */
      8
    ), Vn = (
      /*                     */
      16
    ), Vo = (
      /*                */
      32
    ), uo = (
      /*                       */
      4194240
    ), Go = (
      /*                        */
      64
    ), xa = (
      /*                        */
      128
    ), Fi = (
      /*                        */
      256
    ), $o = (
      /*                        */
      512
    ), ec = (
      /*                        */
      1024
    ), tc = (
      /*                        */
      2048
    ), yd = (
      /*                        */
      4096
    ), xd = (
      /*                        */
      8192
    ), bd = (
      /*                        */
      16384
    ), wd = (
      /*                       */
      32768
    ), Sd = (
      /*                       */
      65536
    ), kd = (
      /*                       */
      131072
    ), Cd = (
      /*                       */
      262144
    ), Ad = (
      /*                       */
      524288
    ), qo = (
      /*                       */
      1048576
    ), Td = (
      /*                       */
      2097152
    ), Zo = (
      /*                            */
      130023424
    ), Cs = (
      /*                             */
      4194304
    ), Ed = (
      /*                             */
      8388608
    ), nc = (
      /*                             */
      16777216
    ), Rd = (
      /*                             */
      33554432
    ), Ld = (
      /*                             */
      67108864
    ), Rh = Cs, Xl = (
      /*          */
      134217728
    ), Md = (
      /*                          */
      268435455
    ), Vl = (
      /*               */
      268435456
    ), co = (
      /*                        */
      536870912
    ), Yi = (
      /*                   */
      1073741824
    );
    function Tx(e) {
      {
        if (e & Yt)
          return "Sync";
        if (e & qa)
          return "InputContinuousHydration";
        if (e & ra)
          return "InputContinuous";
        if (e & Xo)
          return "DefaultHydration";
        if (e & Vn)
          return "Default";
        if (e & Vo)
          return "TransitionHydration";
        if (e & uo)
          return "Transition";
        if (e & Zo)
          return "Retry";
        if (e & Xl)
          return "SelectiveHydration";
        if (e & Vl)
          return "IdleHydration";
        if (e & co)
          return "Idle";
        if (e & Yi)
          return "Offscreen";
      }
    }
    var Fn = -1, Dd = Go, Od = Cs;
    function Gl(e) {
      switch (yr(e)) {
        case Yt:
          return Yt;
        case qa:
          return qa;
        case ra:
          return ra;
        case Xo:
          return Xo;
        case Vn:
          return Vn;
        case Vo:
          return Vo;
        case Go:
        case xa:
        case Fi:
        case $o:
        case ec:
        case tc:
        case yd:
        case xd:
        case bd:
        case wd:
        case Sd:
        case kd:
        case Cd:
        case Ad:
        case qo:
        case Td:
          return e & uo;
        case Cs:
        case Ed:
        case nc:
        case Rd:
        case Ld:
          return e & Zo;
        case Xl:
          return Xl;
        case Vl:
          return Vl;
        case co:
          return co;
        case Yi:
          return Yi;
        default:
          return T("Should have found matching lanes. This is a bug in React."), e;
      }
    }
    function rc(e, r) {
      var c = e.pendingLanes;
      if (c === Pe)
        return Pe;
      var g = Pe, x = e.suspendedLanes, R = e.pingedLanes, _ = c & Md;
      if (_ !== Pe) {
        var Y = _ & ~x;
        if (Y !== Pe)
          g = Gl(Y);
        else {
          var W = _ & R;
          W !== Pe && (g = Gl(W));
        }
      } else {
        var J = c & ~x;
        J !== Pe ? g = Gl(J) : R !== Pe && (g = Gl(R));
      }
      if (g === Pe)
        return Pe;
      if (r !== Pe && r !== g && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (r & x) === Pe) {
        var ne = yr(g), ge = yr(r);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          ne >= ge || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          ne === Vn && (ge & uo) !== Pe
        )
          return r;
      }
      (g & ra) !== Pe && (g |= c & Vn);
      var he = e.entangledLanes;
      if (he !== Pe)
        for (var Ce = e.entanglements, Ae = g & he; Ae > 0; ) {
          var De = fo(Ae), ct = 1 << De;
          g |= Ce[De], Ae &= ~ct;
        }
      return g;
    }
    function yv(e, r) {
      for (var c = e.eventTimes, g = Fn; r > 0; ) {
        var x = fo(r), R = 1 << x, _ = c[x];
        _ > g && (g = _), r &= ~R;
      }
      return g;
    }
    function _d(e, r) {
      switch (e) {
        case Yt:
        case qa:
        case ra:
          return r + 250;
        case Xo:
        case Vn:
        case Vo:
        case Go:
        case xa:
        case Fi:
        case $o:
        case ec:
        case tc:
        case yd:
        case xd:
        case bd:
        case wd:
        case Sd:
        case kd:
        case Cd:
        case Ad:
        case qo:
        case Td:
          return r + 5e3;
        case Cs:
        case Ed:
        case nc:
        case Rd:
        case Ld:
          return Fn;
        case Xl:
        case Vl:
        case co:
        case Yi:
          return Fn;
        default:
          return T("Should have found matching lanes. This is a bug in React."), Fn;
      }
    }
    function Ex(e, r) {
      for (var c = e.pendingLanes, g = e.suspendedLanes, x = e.pingedLanes, R = e.expirationTimes, _ = c; _ > 0; ) {
        var Y = fo(_), W = 1 << Y, J = R[Y];
        J === Fn ? ((W & g) === Pe || (W & x) !== Pe) && (R[Y] = _d(W, r)) : J <= r && (e.expiredLanes |= W), _ &= ~W;
      }
    }
    function Rx(e) {
      return Gl(e.pendingLanes);
    }
    function Lh(e) {
      var r = e.pendingLanes & ~Yi;
      return r !== Pe ? r : r & Yi ? Yi : Pe;
    }
    function $l(e) {
      return (e & Yt) !== Pe;
    }
    function ic(e) {
      return (e & Md) !== Pe;
    }
    function Pd(e) {
      return (e & Zo) === e;
    }
    function Lx(e) {
      var r = Yt | ra | Vn;
      return (e & r) === Pe;
    }
    function xv(e) {
      return (e & uo) === e;
    }
    function ac(e, r) {
      var c = qa | ra | Xo | Vn;
      return (r & c) !== Pe;
    }
    function bv(e, r) {
      return (r & e.expiredLanes) !== Pe;
    }
    function Mh(e) {
      return (e & uo) !== Pe;
    }
    function Dh() {
      var e = Dd;
      return Dd <<= 1, (Dd & uo) === Pe && (Dd = Go), e;
    }
    function Mx() {
      var e = Od;
      return Od <<= 1, (Od & Zo) === Pe && (Od = Cs), e;
    }
    function yr(e) {
      return e & -e;
    }
    function kr(e) {
      return yr(e);
    }
    function fo(e) {
      return 31 - vd(e);
    }
    function Nd(e) {
      return fo(e);
    }
    function Hi(e, r) {
      return (e & r) !== Pe;
    }
    function Qo(e, r) {
      return (e & r) === r;
    }
    function en(e, r) {
      return e | r;
    }
    function ql(e, r) {
      return e & ~r;
    }
    function Oh(e, r) {
      return e & r;
    }
    function wv(e) {
      return e;
    }
    function Sv(e, r) {
      return e !== dn && e < r ? e : r;
    }
    function zd(e) {
      for (var r = [], c = 0; c < Xn; c++)
        r.push(e);
      return r;
    }
    function Ko(e, r, c) {
      e.pendingLanes |= r, r !== co && (e.suspendedLanes = Pe, e.pingedLanes = Pe);
      var g = e.eventTimes, x = Nd(r);
      g[x] = c;
    }
    function _h(e, r) {
      e.suspendedLanes |= r, e.pingedLanes &= ~r;
      for (var c = e.expirationTimes, g = r; g > 0; ) {
        var x = fo(g), R = 1 << x;
        c[x] = Fn, g &= ~R;
      }
    }
    function Ph(e, r, c) {
      e.pingedLanes |= e.suspendedLanes & r;
    }
    function Nh(e, r) {
      var c = e.pendingLanes & ~r;
      e.pendingLanes = r, e.suspendedLanes = Pe, e.pingedLanes = Pe, e.expiredLanes &= r, e.mutableReadLanes &= r, e.entangledLanes &= r;
      for (var g = e.entanglements, x = e.eventTimes, R = e.expirationTimes, _ = c; _ > 0; ) {
        var Y = fo(_), W = 1 << Y;
        g[Y] = Pe, x[Y] = Fn, R[Y] = Fn, _ &= ~W;
      }
    }
    function Zl(e, r) {
      for (var c = e.entangledLanes |= r, g = e.entanglements, x = c; x; ) {
        var R = fo(x), _ = 1 << R;
        // Is this one of the newly entangled lanes?
        _ & r | // Is this lane transitively entangled with the newly entangled lanes?
        g[R] & r && (g[R] |= r), x &= ~_;
      }
    }
    function Dx(e, r) {
      var c = yr(r), g;
      switch (c) {
        case ra:
          g = qa;
          break;
        case Vn:
          g = Xo;
          break;
        case Go:
        case xa:
        case Fi:
        case $o:
        case ec:
        case tc:
        case yd:
        case xd:
        case bd:
        case wd:
        case Sd:
        case kd:
        case Cd:
        case Ad:
        case qo:
        case Td:
        case Cs:
        case Ed:
        case nc:
        case Rd:
        case Ld:
          g = Vo;
          break;
        case co:
          g = Vl;
          break;
        default:
          g = dn;
          break;
      }
      return (g & (e.suspendedLanes | r)) !== dn ? dn : g;
    }
    function zh(e, r, c) {
      if (Br)
        for (var g = e.pendingUpdatersLaneMap; c > 0; ) {
          var x = Nd(c), R = 1 << x, _ = g[x];
          _.add(r), c &= ~R;
        }
    }
    function Id(e, r) {
      if (Br)
        for (var c = e.pendingUpdatersLaneMap, g = e.memoizedUpdaters; r > 0; ) {
          var x = Nd(r), R = 1 << x, _ = c[x];
          _.size > 0 && (_.forEach(function(Y) {
            var W = Y.alternate;
            (W === null || !g.has(W)) && g.add(Y);
          }), _.clear()), r &= ~R;
        }
    }
    function Ih(e, r) {
      return null;
    }
    var ui = Yt, Wr = ra, As = Vn, sc = co, Jo = dn;
    function ba() {
      return Jo;
    }
    function Cr(e) {
      Jo = e;
    }
    function oc(e, r) {
      var c = Jo;
      try {
        return Jo = e, r();
      } finally {
        Jo = c;
      }
    }
    function ci(e, r) {
      return e !== 0 && e < r ? e : r;
    }
    function Ox(e, r) {
      return e === 0 || e > r ? e : r;
    }
    function Fh(e, r) {
      return e !== 0 && e < r;
    }
    function lc(e) {
      var r = yr(e);
      return Fh(ui, r) ? Fh(Wr, r) ? ic(r) ? As : sc : Wr : ui;
    }
    function Ar(e) {
      var r = e.current.memoizedState;
      return r.isDehydrated;
    }
    var kv;
    function ht(e) {
      kv = e;
    }
    function Ql(e) {
      kv(e);
    }
    var uc;
    function Cv(e) {
      uc = e;
    }
    var Av;
    function cc(e) {
      Av = e;
    }
    var dc;
    function Yh(e) {
      dc = e;
    }
    var Hh;
    function Tv(e) {
      Hh = e;
    }
    var Fd = !1, Kl = [], Za = null, Zn = null, Nr = null, wa = /* @__PURE__ */ new Map(), Jl = /* @__PURE__ */ new Map(), Ts = [], Ha = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function Ev(e) {
      return Ha.indexOf(e) > -1;
    }
    function Qa(e, r, c, g, x) {
      return {
        blockedOn: e,
        domEventName: r,
        eventSystemFlags: c,
        nativeEvent: x,
        targetContainers: [g]
      };
    }
    function Rv(e, r) {
      switch (e) {
        case "focusin":
        case "focusout":
          Za = null;
          break;
        case "dragenter":
        case "dragleave":
          Zn = null;
          break;
        case "mouseover":
        case "mouseout":
          Nr = null;
          break;
        case "pointerover":
        case "pointerout": {
          var c = r.pointerId;
          wa.delete(c);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var g = r.pointerId;
          Jl.delete(g);
          break;
        }
      }
    }
    function eu(e, r, c, g, x, R) {
      if (e === null || e.nativeEvent !== R) {
        var _ = Qa(r, c, g, x, R);
        if (r !== null) {
          var Y = du(r);
          Y !== null && uc(Y);
        }
        return _;
      }
      e.eventSystemFlags |= g;
      var W = e.targetContainers;
      return x !== null && W.indexOf(x) === -1 && W.push(x), e;
    }
    function Lv(e, r, c, g, x) {
      switch (r) {
        case "focusin": {
          var R = x;
          return Za = eu(Za, e, r, c, g, R), !0;
        }
        case "dragenter": {
          var _ = x;
          return Zn = eu(Zn, e, r, c, g, _), !0;
        }
        case "mouseover": {
          var Y = x;
          return Nr = eu(Nr, e, r, c, g, Y), !0;
        }
        case "pointerover": {
          var W = x, J = W.pointerId;
          return wa.set(J, eu(wa.get(J) || null, e, r, c, g, W)), !0;
        }
        case "gotpointercapture": {
          var ne = x, ge = ne.pointerId;
          return Jl.set(ge, eu(Jl.get(ge) || null, e, r, c, g, ne)), !0;
        }
      }
      return !1;
    }
    function jh(e) {
      var r = bc(e.target);
      if (r !== null) {
        var c = ea(r);
        if (c !== null) {
          var g = c.tag;
          if (g === re) {
            var x = vh(c);
            if (x !== null) {
              e.blockedOn = x, Hh(e.priority, function() {
                Av(c);
              });
              return;
            }
          } else if (g === q) {
            var R = c.stateNode;
            if (Ar(R)) {
              e.blockedOn = sd(c);
              return;
            }
          }
        }
      }
      e.blockedOn = null;
    }
    function Mv(e) {
      for (var r = dc(), c = {
        blockedOn: null,
        target: e,
        priority: r
      }, g = 0; g < Ts.length && Fh(r, Ts[g].priority); g++)
        ;
      Ts.splice(g, 0, c), g === 0 && jh(c);
    }
    function Yd(e) {
      if (e.blockedOn !== null)
        return !1;
      for (var r = e.targetContainers; r.length > 0; ) {
        var c = r[0], g = el(e.domEventName, e.eventSystemFlags, c, e.nativeEvent);
        if (g === null) {
          var x = e.nativeEvent, R = new x.constructor(x.type, x);
          Wu(R), x.target.dispatchEvent(R), Sx();
        } else {
          var _ = du(g);
          return _ !== null && uc(_), e.blockedOn = g, !1;
        }
        r.shift();
      }
      return !0;
    }
    function fc(e, r, c) {
      Yd(e) && c.delete(r);
    }
    function Uh() {
      Fd = !1, Za !== null && Yd(Za) && (Za = null), Zn !== null && Yd(Zn) && (Zn = null), Nr !== null && Yd(Nr) && (Nr = null), wa.forEach(fc), Jl.forEach(fc);
    }
    function di(e, r) {
      e.blockedOn === r && (e.blockedOn = null, Fd || (Fd = !0, u.unstable_scheduleCallback(u.unstable_NormalPriority, Uh)));
    }
    function sn(e) {
      if (Kl.length > 0) {
        di(Kl[0], e);
        for (var r = 1; r < Kl.length; r++) {
          var c = Kl[r];
          c.blockedOn === e && (c.blockedOn = null);
        }
      }
      Za !== null && di(Za, e), Zn !== null && di(Zn, e), Nr !== null && di(Nr, e);
      var g = function(Y) {
        return di(Y, e);
      };
      wa.forEach(g), Jl.forEach(g);
      for (var x = 0; x < Ts.length; x++) {
        var R = Ts[x];
        R.blockedOn === e && (R.blockedOn = null);
      }
      for (; Ts.length > 0; ) {
        var _ = Ts[0];
        if (_.blockedOn !== null)
          break;
        jh(_), _.blockedOn === null && Ts.shift();
      }
    }
    var Jn = h.ReactCurrentBatchConfig, or = !0;
    function zr(e) {
      or = !!e;
    }
    function ia() {
      return or;
    }
    function tu(e, r, c) {
      var g = bi(r), x;
      switch (g) {
        case ui:
          x = Tr;
          break;
        case Wr:
          x = hc;
          break;
        case As:
        default:
          x = Es;
          break;
      }
      return x.bind(null, r, c, e);
    }
    function Tr(e, r, c, g) {
      var x = ba(), R = Jn.transition;
      Jn.transition = null;
      try {
        Cr(ui), Es(e, r, c, g);
      } finally {
        Cr(x), Jn.transition = R;
      }
    }
    function hc(e, r, c, g) {
      var x = ba(), R = Jn.transition;
      Jn.transition = null;
      try {
        Cr(Wr), Es(e, r, c, g);
      } finally {
        Cr(x), Jn.transition = R;
      }
    }
    function Es(e, r, c, g) {
      or && Hd(e, r, c, g);
    }
    function Hd(e, r, c, g) {
      var x = el(e, r, c, g);
      if (x === null) {
        Kx(e, r, g, nu, c), Rv(e, g);
        return;
      }
      if (Lv(x, e, r, c, g)) {
        g.stopPropagation();
        return;
      }
      if (Rv(e, g), r & zo && Ev(e)) {
        for (; x !== null; ) {
          var R = du(x);
          R !== null && Ql(R);
          var _ = el(e, r, c, g);
          if (_ === null && Kx(e, r, g, nu, c), _ === x)
            break;
          x = _;
        }
        x !== null && g.stopPropagation();
        return;
      }
      Kx(e, r, g, null, c);
    }
    var nu = null;
    function el(e, r, c, g) {
      nu = null;
      var x = td(g), R = bc(x);
      if (R !== null) {
        var _ = ea(R);
        if (_ === null)
          R = null;
        else {
          var Y = _.tag;
          if (Y === re) {
            var W = vh(_);
            if (W !== null)
              return W;
            R = null;
          } else if (Y === q) {
            var J = _.stateNode;
            if (Ar(J))
              return sd(_);
            R = null;
          } else
            _ !== R && (R = null);
        }
      }
      return nu = R, null;
    }
    function bi(e) {
      switch (e) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return ui;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Wr;
        case "message": {
          var r = xh();
          switch (r) {
            case cd:
              return ui;
            case na:
              return Wr;
            case $a:
            case dd:
              return As;
            case ro:
              return sc;
            default:
              return As;
          }
        }
        default:
          return As;
      }
    }
    function Bh(e, r, c) {
      return e.addEventListener(r, c, !1), c;
    }
    function ru(e, r, c) {
      return e.addEventListener(r, c, !0), c;
    }
    function Rs(e, r, c, g) {
      return e.addEventListener(r, c, {
        capture: !0,
        passive: g
      }), c;
    }
    function jd(e, r, c, g) {
      return e.addEventListener(r, c, {
        passive: g
      }), c;
    }
    var tl = null, Ka = null, ho = null;
    function po(e) {
      return tl = e, Ka = Bd(), !0;
    }
    function Ud() {
      tl = null, Ka = null, ho = null;
    }
    function iu() {
      if (ho)
        return ho;
      var e, r = Ka, c = r.length, g, x = Bd(), R = x.length;
      for (e = 0; e < c && r[e] === x[e]; e++)
        ;
      var _ = c - e;
      for (g = 1; g <= _ && r[c - g] === x[R - g]; g++)
        ;
      var Y = g > 1 ? 1 - g : void 0;
      return ho = x.slice(e, Y), ho;
    }
    function Bd() {
      return "value" in tl ? tl.value : tl.textContent;
    }
    function nl(e) {
      var r, c = e.keyCode;
      return "charCode" in e ? (r = e.charCode, r === 0 && c === 13 && (r = 13)) : r = c, r === 10 && (r = 13), r >= 32 || r === 13 ? r : 0;
    }
    function rl() {
      return !0;
    }
    function fi() {
      return !1;
    }
    function xr(e) {
      function r(c, g, x, R, _) {
        this._reactName = c, this._targetInst = x, this.type = g, this.nativeEvent = R, this.target = _, this.currentTarget = null;
        for (var Y in e)
          if (e.hasOwnProperty(Y)) {
            var W = e[Y];
            W ? this[Y] = W(R) : this[Y] = R[Y];
          }
        var J = R.defaultPrevented != null ? R.defaultPrevented : R.returnValue === !1;
        return J ? this.isDefaultPrevented = rl : this.isDefaultPrevented = fi, this.isPropagationStopped = fi, this;
      }
      return p(r.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var c = this.nativeEvent;
          c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = rl);
        },
        stopPropagation: function() {
          var c = this.nativeEvent;
          c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = rl);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: rl
      }), r;
    }
    var hi = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(e) {
        return e.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, pi = xr(hi), au = p({}, hi, {
      view: 0,
      detail: 0
    }), Wh = xr(au), pc, Xh, Sa;
    function Dv(e) {
      e !== Sa && (Sa && e.type === "mousemove" ? (pc = e.screenX - Sa.screenX, Xh = e.screenY - Sa.screenY) : (pc = 0, Xh = 0), Sa = e);
    }
    var su = p({}, au, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Vd,
      button: 0,
      buttons: 0,
      relatedTarget: function(e) {
        return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
      },
      movementX: function(e) {
        return "movementX" in e ? e.movementX : (Dv(e), pc);
      },
      movementY: function(e) {
        return "movementY" in e ? e.movementY : Xh;
      }
    }), go = xr(su), Vh = p({}, su, {
      dataTransfer: 0
    }), il = xr(Vh), Ov = p({}, au, {
      relatedTarget: 0
    }), Wd = xr(Ov), Gh = p({}, hi, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Xd = xr(Gh), _x = p({}, hi, {
      clipboardData: function(e) {
        return "clipboardData" in e ? e.clipboardData : window.clipboardData;
      }
    }), Px = xr(_x), _v = p({}, hi, {
      data: 0
    }), $h = xr(_v), al = $h, Nx = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, ou = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function Pv(e) {
      if (e.key) {
        var r = Nx[e.key] || e.key;
        if (r !== "Unidentified")
          return r;
      }
      if (e.type === "keypress") {
        var c = nl(e);
        return c === 13 ? "Enter" : String.fromCharCode(c);
      }
      return e.type === "keydown" || e.type === "keyup" ? ou[e.keyCode] || "Unidentified" : "";
    }
    var lr = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function zx(e) {
      var r = this, c = r.nativeEvent;
      if (c.getModifierState)
        return c.getModifierState(e);
      var g = lr[e];
      return g ? !!c[g] : !1;
    }
    function Vd(e) {
      return zx;
    }
    var Ix = p({}, au, {
      key: Pv,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Vd,
      // Legacy Interface
      charCode: function(e) {
        return e.type === "keypress" ? nl(e) : 0;
      },
      keyCode: function(e) {
        return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      },
      which: function(e) {
        return e.type === "keypress" ? nl(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      }
    }), Fx = xr(Ix), Nv = p({}, su, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), qh = xr(Nv), Yx = p({}, au, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Vd
    }), ka = xr(Yx), Zh = p({}, hi, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Hx = xr(Zh), vo = p({}, su, {
      deltaX: function(e) {
        return "deltaX" in e ? e.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in e ? -e.wheelDeltaX : 0
        );
      },
      deltaY: function(e) {
        return "deltaY" in e ? e.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in e ? -e.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in e ? -e.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), Gd = xr(vo), sl = [9, 13, 27, 32], gc = 229, vc = pn && "CompositionEvent" in window, ol = null;
    pn && "documentMode" in document && (ol = document.documentMode);
    var jx = pn && "TextEvent" in window && !ol, $d = pn && (!vc || ol && ol > 8 && ol <= 11), zv = 32, Qh = String.fromCharCode(zv);
    function Iv() {
      vn("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), vn("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), vn("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), vn("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var mc = !1;
    function qd(e) {
      return (e.ctrlKey || e.altKey || e.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(e.ctrlKey && e.altKey);
    }
    function Fv(e) {
      switch (e) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function Kh(e, r) {
      return e === "keydown" && r.keyCode === gc;
    }
    function Yv(e, r) {
      switch (e) {
        case "keyup":
          return sl.indexOf(r.keyCode) !== -1;
        case "keydown":
          return r.keyCode !== gc;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Jh(e) {
      var r = e.detail;
      return typeof r == "object" && "data" in r ? r.data : null;
    }
    function Zd(e) {
      return e.locale === "ko";
    }
    var Ls = !1;
    function ep(e, r, c, g, x) {
      var R, _;
      if (vc ? R = Fv(r) : Ls ? Yv(r, g) && (R = "onCompositionEnd") : Kh(r, g) && (R = "onCompositionStart"), !R)
        return null;
      $d && !Zd(g) && (!Ls && R === "onCompositionStart" ? Ls = po(x) : R === "onCompositionEnd" && Ls && (_ = iu()));
      var Y = Wv(c, R);
      if (Y.length > 0) {
        var W = new $h(R, r, null, g, x);
        if (e.push({
          event: W,
          listeners: Y
        }), _)
          W.data = _;
        else {
          var J = Jh(g);
          J !== null && (W.data = J);
        }
      }
    }
    function Qd(e, r) {
      switch (e) {
        case "compositionend":
          return Jh(r);
        case "keypress":
          var c = r.which;
          return c !== zv ? null : (mc = !0, Qh);
        case "textInput":
          var g = r.data;
          return g === Qh && mc ? null : g;
        default:
          return null;
      }
    }
    function Hv(e, r) {
      if (Ls) {
        if (e === "compositionend" || !vc && Yv(e, r)) {
          var c = iu();
          return Ud(), Ls = !1, c;
        }
        return null;
      }
      switch (e) {
        case "paste":
          return null;
        case "keypress":
          if (!qd(r)) {
            if (r.char && r.char.length > 1)
              return r.char;
            if (r.which)
              return String.fromCharCode(r.which);
          }
          return null;
        case "compositionend":
          return $d && !Zd(r) ? null : r.data;
        default:
          return null;
      }
    }
    function Ux(e, r, c, g, x) {
      var R;
      if (jx ? R = Qd(r, g) : R = Hv(r, g), !R)
        return null;
      var _ = Wv(c, "onBeforeInput");
      if (_.length > 0) {
        var Y = new al("onBeforeInput", "beforeinput", null, g, x);
        e.push({
          event: Y,
          listeners: _
        }), Y.data = R;
      }
    }
    function Kd(e, r, c, g, x, R, _) {
      ep(e, r, c, g, x), Ux(e, r, c, g, x);
    }
    var Bx = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function lu(e) {
      var r = e && e.nodeName && e.nodeName.toLowerCase();
      return r === "input" ? !!Bx[e.type] : r === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function Wx(e) {
      if (!pn)
        return !1;
      var r = "on" + e, c = r in document;
      if (!c) {
        var g = document.createElement("div");
        g.setAttribute(r, "return;"), c = typeof g[r] == "function";
      }
      return c;
    }
    function Jd() {
      vn("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function a(e, r, c, g) {
      nd(g);
      var x = Wv(r, "onChange");
      if (x.length > 0) {
        var R = new pi("onChange", "change", null, c, g);
        e.push({
          event: R,
          listeners: x
        });
      }
    }
    var l = null, m = null;
    function k(e) {
      var r = e.nodeName && e.nodeName.toLowerCase();
      return r === "select" || r === "input" && e.type === "file";
    }
    function D(e) {
      var r = [];
      a(r, m, e, td(e)), lh(z, r);
    }
    function z(e) {
      ES(e, 0);
    }
    function G(e) {
      var r = sf(e);
      if (Tg(r))
        return e;
    }
    function ie(e, r) {
      if (e === "change")
        return r;
    }
    var ce = !1;
    pn && (ce = Wx("input") && (!document.documentMode || document.documentMode > 9));
    function Te(e, r) {
      l = e, m = r, l.attachEvent("onpropertychange", Ue);
    }
    function He() {
      l && (l.detachEvent("onpropertychange", Ue), l = null, m = null);
    }
    function Ue(e) {
      e.propertyName === "value" && G(m) && D(e);
    }
    function Fe(e, r, c) {
      e === "focusin" ? (He(), Te(r, c)) : e === "focusout" && He();
    }
    function lt(e, r) {
      if (e === "selectionchange" || e === "keyup" || e === "keydown")
        return G(m);
    }
    function yt(e) {
      var r = e.nodeName;
      return r && r.toLowerCase() === "input" && (e.type === "checkbox" || e.type === "radio");
    }
    function St(e, r) {
      if (e === "click")
        return G(r);
    }
    function dr(e, r) {
      if (e === "input" || e === "change")
        return G(r);
    }
    function me(e) {
      var r = e._wrapperState;
      !r || !r.controlled || e.type !== "number" || qs(e, "number", e.value);
    }
    function pe(e, r, c, g, x, R, _) {
      var Y = c ? sf(c) : window, W, J;
      if (k(Y) ? W = ie : lu(Y) ? ce ? W = dr : (W = lt, J = Fe) : yt(Y) && (W = St), W) {
        var ne = W(r, c);
        if (ne) {
          a(e, ne, g, x);
          return;
        }
      }
      J && J(r, Y, c), r === "focusout" && me(Y);
    }
    function Se() {
      Ze("onMouseEnter", ["mouseout", "mouseover"]), Ze("onMouseLeave", ["mouseout", "mouseover"]), Ze("onPointerEnter", ["pointerout", "pointerover"]), Ze("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function qe(e, r, c, g, x, R, _) {
      var Y = r === "mouseover" || r === "pointerover", W = r === "mouseout" || r === "pointerout";
      if (Y && !rv(g)) {
        var J = g.relatedTarget || g.fromElement;
        if (J && (bc(J) || pp(J)))
          return;
      }
      if (!(!W && !Y)) {
        var ne;
        if (x.window === x)
          ne = x;
        else {
          var ge = x.ownerDocument;
          ge ? ne = ge.defaultView || ge.parentWindow : ne = window;
        }
        var he, Ce;
        if (W) {
          var Ae = g.relatedTarget || g.toElement;
          if (he = c, Ce = Ae ? bc(Ae) : null, Ce !== null) {
            var De = ea(Ce);
            (Ce !== De || Ce.tag !== se && Ce.tag !== ae) && (Ce = null);
          }
        } else
          he = null, Ce = c;
        if (he !== Ce) {
          var ct = go, Pt = "onMouseLeave", Tt = "onMouseEnter", hn = "mouse";
          (r === "pointerout" || r === "pointerover") && (ct = qh, Pt = "onPointerLeave", Tt = "onPointerEnter", hn = "pointer");
          var on = he == null ? ne : sf(he), xe = Ce == null ? ne : sf(Ce), Oe = new ct(Pt, hn + "leave", he, g, x);
          Oe.target = on, Oe.relatedTarget = xe;
          var be = null, Xe = bc(x);
          if (Xe === c) {
            var dt = new ct(Tt, hn + "enter", Ce, g, x);
            dt.target = xe, dt.relatedTarget = on, be = dt;
          }
          fL(e, Oe, be, he, Ce);
        }
      }
    }
    function Ct(e, r) {
      return e === r && (e !== 0 || 1 / e === 1 / r) || e !== e && r !== r;
    }
    var xt = typeof Object.is == "function" ? Object.is : Ct;
    function Lt(e, r) {
      if (xt(e, r))
        return !0;
      if (typeof e != "object" || e === null || typeof r != "object" || r === null)
        return !1;
      var c = Object.keys(e), g = Object.keys(r);
      if (c.length !== g.length)
        return !1;
      for (var x = 0; x < c.length; x++) {
        var R = c[x];
        if (!jn.call(r, R) || !xt(e[R], r[R]))
          return !1;
      }
      return !0;
    }
    function Vt(e) {
      for (; e && e.firstChild; )
        e = e.firstChild;
      return e;
    }
    function Ir(e) {
      for (; e; ) {
        if (e.nextSibling)
          return e.nextSibling;
        e = e.parentNode;
      }
    }
    function gn(e, r) {
      for (var c = Vt(e), g = 0, x = 0; c; ) {
        if (c.nodeType === vs) {
          if (x = g + c.textContent.length, g <= r && x >= r)
            return {
              node: c,
              offset: r - g
            };
          g = x;
        }
        c = Vt(Ir(c));
      }
    }
    function mo(e) {
      var r = e.ownerDocument, c = r && r.defaultView || window, g = c.getSelection && c.getSelection();
      if (!g || g.rangeCount === 0)
        return null;
      var x = g.anchorNode, R = g.anchorOffset, _ = g.focusNode, Y = g.focusOffset;
      try {
        x.nodeType, _.nodeType;
      } catch {
        return null;
      }
      return Xx(e, x, R, _, Y);
    }
    function Xx(e, r, c, g, x) {
      var R = 0, _ = -1, Y = -1, W = 0, J = 0, ne = e, ge = null;
      e:
        for (; ; ) {
          for (var he = null; ne === r && (c === 0 || ne.nodeType === vs) && (_ = R + c), ne === g && (x === 0 || ne.nodeType === vs) && (Y = R + x), ne.nodeType === vs && (R += ne.nodeValue.length), (he = ne.firstChild) !== null; )
            ge = ne, ne = he;
          for (; ; ) {
            if (ne === e)
              break e;
            if (ge === r && ++W === c && (_ = R), ge === g && ++J === x && (Y = R), (he = ne.nextSibling) !== null)
              break;
            ne = ge, ge = ne.parentNode;
          }
          ne = he;
        }
      return _ === -1 || Y === -1 ? null : {
        start: _,
        end: Y
      };
    }
    function GR(e, r) {
      var c = e.ownerDocument || document, g = c && c.defaultView || window;
      if (g.getSelection) {
        var x = g.getSelection(), R = e.textContent.length, _ = Math.min(r.start, R), Y = r.end === void 0 ? _ : Math.min(r.end, R);
        if (!x.extend && _ > Y) {
          var W = Y;
          Y = _, _ = W;
        }
        var J = gn(e, _), ne = gn(e, Y);
        if (J && ne) {
          if (x.rangeCount === 1 && x.anchorNode === J.node && x.anchorOffset === J.offset && x.focusNode === ne.node && x.focusOffset === ne.offset)
            return;
          var ge = c.createRange();
          ge.setStart(J.node, J.offset), x.removeAllRanges(), _ > Y ? (x.addRange(ge), x.extend(ne.node, ne.offset)) : (ge.setEnd(ne.node, ne.offset), x.addRange(ge));
        }
      }
    }
    function gS(e) {
      return e && e.nodeType === vs;
    }
    function vS(e, r) {
      return !e || !r ? !1 : e === r ? !0 : gS(e) ? !1 : gS(r) ? vS(e, r.parentNode) : "contains" in e ? e.contains(r) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(r) & 16) : !1;
    }
    function $R(e) {
      return e && e.ownerDocument && vS(e.ownerDocument.documentElement, e);
    }
    function qR(e) {
      try {
        return typeof e.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function mS() {
      for (var e = window, r = Uc(); r instanceof e.HTMLIFrameElement; ) {
        if (qR(r))
          e = r.contentWindow;
        else
          return r;
        r = Uc(e.document);
      }
      return r;
    }
    function Vx(e) {
      var r = e && e.nodeName && e.nodeName.toLowerCase();
      return r && (r === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || r === "textarea" || e.contentEditable === "true");
    }
    function ZR() {
      var e = mS();
      return {
        focusedElem: e,
        selectionRange: Vx(e) ? KR(e) : null
      };
    }
    function QR(e) {
      var r = mS(), c = e.focusedElem, g = e.selectionRange;
      if (r !== c && $R(c)) {
        g !== null && Vx(c) && JR(c, g);
        for (var x = [], R = c; R = R.parentNode; )
          R.nodeType === Oi && x.push({
            element: R,
            left: R.scrollLeft,
            top: R.scrollTop
          });
        typeof c.focus == "function" && c.focus();
        for (var _ = 0; _ < x.length; _++) {
          var Y = x[_];
          Y.element.scrollLeft = Y.left, Y.element.scrollTop = Y.top;
        }
      }
    }
    function KR(e) {
      var r;
      return "selectionStart" in e ? r = {
        start: e.selectionStart,
        end: e.selectionEnd
      } : r = mo(e), r || {
        start: 0,
        end: 0
      };
    }
    function JR(e, r) {
      var c = r.start, g = r.end;
      g === void 0 && (g = c), "selectionStart" in e ? (e.selectionStart = c, e.selectionEnd = Math.min(g, e.value.length)) : GR(e, r);
    }
    var eL = pn && "documentMode" in document && document.documentMode <= 11;
    function tL() {
      vn("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var ef = null, Gx = null, tp = null, $x = !1;
    function nL(e) {
      if ("selectionStart" in e && Vx(e))
        return {
          start: e.selectionStart,
          end: e.selectionEnd
        };
      var r = e.ownerDocument && e.ownerDocument.defaultView || window, c = r.getSelection();
      return {
        anchorNode: c.anchorNode,
        anchorOffset: c.anchorOffset,
        focusNode: c.focusNode,
        focusOffset: c.focusOffset
      };
    }
    function rL(e) {
      return e.window === e ? e.document : e.nodeType === za ? e : e.ownerDocument;
    }
    function yS(e, r, c) {
      var g = rL(c);
      if (!($x || ef == null || ef !== Uc(g))) {
        var x = nL(ef);
        if (!tp || !Lt(tp, x)) {
          tp = x;
          var R = Wv(Gx, "onSelect");
          if (R.length > 0) {
            var _ = new pi("onSelect", "select", null, r, c);
            e.push({
              event: _,
              listeners: R
            }), _.target = ef;
          }
        }
      }
    }
    function iL(e, r, c, g, x, R, _) {
      var Y = c ? sf(c) : window;
      switch (r) {
        case "focusin":
          (lu(Y) || Y.contentEditable === "true") && (ef = Y, Gx = c, tp = null);
          break;
        case "focusout":
          ef = null, Gx = null, tp = null;
          break;
        case "mousedown":
          $x = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          $x = !1, yS(e, g, x);
          break;
        case "selectionchange":
          if (eL)
            break;
        case "keydown":
        case "keyup":
          yS(e, g, x);
      }
    }
    function jv(e, r) {
      var c = {};
      return c[e.toLowerCase()] = r.toLowerCase(), c["Webkit" + e] = "webkit" + r, c["Moz" + e] = "moz" + r, c;
    }
    var tf = {
      animationend: jv("Animation", "AnimationEnd"),
      animationiteration: jv("Animation", "AnimationIteration"),
      animationstart: jv("Animation", "AnimationStart"),
      transitionend: jv("Transition", "TransitionEnd")
    }, qx = {}, xS = {};
    pn && (xS = document.createElement("div").style, "AnimationEvent" in window || (delete tf.animationend.animation, delete tf.animationiteration.animation, delete tf.animationstart.animation), "TransitionEvent" in window || delete tf.transitionend.transition);
    function Uv(e) {
      if (qx[e])
        return qx[e];
      if (!tf[e])
        return e;
      var r = tf[e];
      for (var c in r)
        if (r.hasOwnProperty(c) && c in xS)
          return qx[e] = r[c];
      return e;
    }
    var bS = Uv("animationend"), wS = Uv("animationiteration"), SS = Uv("animationstart"), kS = Uv("transitionend"), CS = /* @__PURE__ */ new Map(), AS = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function uu(e, r) {
      CS.set(e, r), vn(r, [e]);
    }
    function aL() {
      for (var e = 0; e < AS.length; e++) {
        var r = AS[e], c = r.toLowerCase(), g = r[0].toUpperCase() + r.slice(1);
        uu(c, "on" + g);
      }
      uu(bS, "onAnimationEnd"), uu(wS, "onAnimationIteration"), uu(SS, "onAnimationStart"), uu("dblclick", "onDoubleClick"), uu("focusin", "onFocus"), uu("focusout", "onBlur"), uu(kS, "onTransitionEnd");
    }
    function sL(e, r, c, g, x, R, _) {
      var Y = CS.get(r);
      if (Y !== void 0) {
        var W = pi, J = r;
        switch (r) {
          case "keypress":
            if (nl(g) === 0)
              return;
          case "keydown":
          case "keyup":
            W = Fx;
            break;
          case "focusin":
            J = "focus", W = Wd;
            break;
          case "focusout":
            J = "blur", W = Wd;
            break;
          case "beforeblur":
          case "afterblur":
            W = Wd;
            break;
          case "click":
            if (g.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            W = go;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            W = il;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            W = ka;
            break;
          case bS:
          case wS:
          case SS:
            W = Xd;
            break;
          case kS:
            W = Hx;
            break;
          case "scroll":
            W = Wh;
            break;
          case "wheel":
            W = Gd;
            break;
          case "copy":
          case "cut":
          case "paste":
            W = Px;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            W = qh;
            break;
        }
        var ne = (R & zo) !== 0;
        {
          var ge = !ne && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          r === "scroll", he = cL(c, Y, g.type, ne, ge);
          if (he.length > 0) {
            var Ce = new W(Y, J, null, g, x);
            e.push({
              event: Ce,
              listeners: he
            });
          }
        }
      }
    }
    aL(), Se(), Jd(), tL(), Iv();
    function oL(e, r, c, g, x, R, _) {
      sL(e, r, c, g, x, R);
      var Y = (R & wx) === 0;
      Y && (qe(e, r, c, g, x), pe(e, r, c, g, x), iL(e, r, c, g, x), Kd(e, r, c, g, x));
    }
    var np = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], Zx = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(np));
    function TS(e, r, c) {
      var g = e.type || "unknown-event";
      e.currentTarget = c, bs(g, r, void 0, e), e.currentTarget = null;
    }
    function lL(e, r, c) {
      var g;
      if (c)
        for (var x = r.length - 1; x >= 0; x--) {
          var R = r[x], _ = R.instance, Y = R.currentTarget, W = R.listener;
          if (_ !== g && e.isPropagationStopped())
            return;
          TS(e, W, Y), g = _;
        }
      else
        for (var J = 0; J < r.length; J++) {
          var ne = r[J], ge = ne.instance, he = ne.currentTarget, Ce = ne.listener;
          if (ge !== g && e.isPropagationStopped())
            return;
          TS(e, Ce, he), g = ge;
        }
    }
    function ES(e, r) {
      for (var c = (r & zo) !== 0, g = 0; g < e.length; g++) {
        var x = e[g], R = x.event, _ = x.listeners;
        lL(R, _, c);
      }
      fh();
    }
    function uL(e, r, c, g, x) {
      var R = td(c), _ = [];
      oL(_, e, g, c, R, r), ES(_, r);
    }
    function er(e, r) {
      Zx.has(e) || T('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', e);
      var c = !1, g = YM(r), x = hL(e, c);
      g.has(x) || (RS(r, e, Uu, c), g.add(x));
    }
    function Qx(e, r, c) {
      Zx.has(e) && !r && T('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', e);
      var g = 0;
      r && (g |= zo), RS(c, e, g, r);
    }
    var Bv = "_reactListening" + Math.random().toString(36).slice(2);
    function rp(e) {
      if (!e[Bv]) {
        e[Bv] = !0, Et.forEach(function(c) {
          c !== "selectionchange" && (Zx.has(c) || Qx(c, !1, e), Qx(c, !0, e));
        });
        var r = e.nodeType === za ? e : e.ownerDocument;
        r !== null && (r[Bv] || (r[Bv] = !0, Qx("selectionchange", !1, r)));
      }
    }
    function RS(e, r, c, g, x) {
      var R = tu(e, r, c), _ = void 0;
      Gu && (r === "touchstart" || r === "touchmove" || r === "wheel") && (_ = !0), e = e, g ? _ !== void 0 ? Rs(e, r, R, _) : ru(e, r, R) : _ !== void 0 ? jd(e, r, R, _) : Bh(e, r, R);
    }
    function LS(e, r) {
      return e === r || e.nodeType === mr && e.parentNode === r;
    }
    function Kx(e, r, c, g, x) {
      var R = g;
      if (!(r & ys) && !(r & Uu)) {
        var _ = x;
        if (g !== null) {
          var Y = g;
          e:
            for (; ; ) {
              if (Y === null)
                return;
              var W = Y.tag;
              if (W === q || W === te) {
                var J = Y.stateNode.containerInfo;
                if (LS(J, _))
                  break;
                if (W === te)
                  for (var ne = Y.return; ne !== null; ) {
                    var ge = ne.tag;
                    if (ge === q || ge === te) {
                      var he = ne.stateNode.containerInfo;
                      if (LS(he, _))
                        return;
                    }
                    ne = ne.return;
                  }
                for (; J !== null; ) {
                  var Ce = bc(J);
                  if (Ce === null)
                    return;
                  var Ae = Ce.tag;
                  if (Ae === se || Ae === ae) {
                    Y = R = Ce;
                    continue e;
                  }
                  J = J.parentNode;
                }
              }
              Y = Y.return;
            }
        }
      }
      lh(function() {
        return uL(e, r, c, R);
      });
    }
    function ip(e, r, c) {
      return {
        instance: e,
        listener: r,
        currentTarget: c
      };
    }
    function cL(e, r, c, g, x, R) {
      for (var _ = r !== null ? r + "Capture" : null, Y = g ? _ : r, W = [], J = e, ne = null; J !== null; ) {
        var ge = J, he = ge.stateNode, Ce = ge.tag;
        if (Ce === se && he !== null && (ne = he, Y !== null)) {
          var Ae = Fo(J, Y);
          Ae != null && W.push(ip(J, Ae, ne));
        }
        if (x)
          break;
        J = J.return;
      }
      return W;
    }
    function Wv(e, r) {
      for (var c = r + "Capture", g = [], x = e; x !== null; ) {
        var R = x, _ = R.stateNode, Y = R.tag;
        if (Y === se && _ !== null) {
          var W = _, J = Fo(x, c);
          J != null && g.unshift(ip(x, J, W));
          var ne = Fo(x, r);
          ne != null && g.push(ip(x, ne, W));
        }
        x = x.return;
      }
      return g;
    }
    function nf(e) {
      if (e === null)
        return null;
      do
        e = e.return;
      while (e && e.tag !== se);
      return e || null;
    }
    function dL(e, r) {
      for (var c = e, g = r, x = 0, R = c; R; R = nf(R))
        x++;
      for (var _ = 0, Y = g; Y; Y = nf(Y))
        _++;
      for (; x - _ > 0; )
        c = nf(c), x--;
      for (; _ - x > 0; )
        g = nf(g), _--;
      for (var W = x; W--; ) {
        if (c === g || g !== null && c === g.alternate)
          return c;
        c = nf(c), g = nf(g);
      }
      return null;
    }
    function MS(e, r, c, g, x) {
      for (var R = r._reactName, _ = [], Y = c; Y !== null && Y !== g; ) {
        var W = Y, J = W.alternate, ne = W.stateNode, ge = W.tag;
        if (J !== null && J === g)
          break;
        if (ge === se && ne !== null) {
          var he = ne;
          if (x) {
            var Ce = Fo(Y, R);
            Ce != null && _.unshift(ip(Y, Ce, he));
          } else if (!x) {
            var Ae = Fo(Y, R);
            Ae != null && _.push(ip(Y, Ae, he));
          }
        }
        Y = Y.return;
      }
      _.length !== 0 && e.push({
        event: r,
        listeners: _
      });
    }
    function fL(e, r, c, g, x) {
      var R = g && x ? dL(g, x) : null;
      g !== null && MS(e, r, g, R, !1), x !== null && c !== null && MS(e, c, x, R, !0);
    }
    function hL(e, r) {
      return e + "__" + (r ? "capture" : "bubble");
    }
    var Ca = !1, ap = "dangerouslySetInnerHTML", Xv = "suppressContentEditableWarning", cu = "suppressHydrationWarning", DS = "autoFocus", yc = "children", xc = "style", Vv = "__html", Jx, Gv, sp, OS, $v, _S, PS;
    Jx = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, Gv = function(e, r) {
      ed(e, r), rh(e, r), nv(e, r, {
        registrationNameDependencies: Ut,
        possibleRegistrationNames: Bt
      });
    }, _S = pn && !document.documentMode, sp = function(e, r, c) {
      if (!Ca) {
        var g = qv(c), x = qv(r);
        x !== g && (Ca = !0, T("Prop `%s` did not match. Server: %s Client: %s", e, JSON.stringify(x), JSON.stringify(g)));
      }
    }, OS = function(e) {
      if (!Ca) {
        Ca = !0;
        var r = [];
        e.forEach(function(c) {
          r.push(c);
        }), T("Extra attributes from the server: %s", r);
      }
    }, $v = function(e, r) {
      r === !1 ? T("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", e, e, e) : T("Expected `%s` listener to be a function, instead got a value of `%s` type.", e, typeof r);
    }, PS = function(e, r) {
      var c = e.namespaceURI === gs ? e.ownerDocument.createElement(e.tagName) : e.ownerDocument.createElementNS(e.namespaceURI, e.tagName);
      return c.innerHTML = r, c.innerHTML;
    };
    var pL = /\r\n?/g, gL = /\u0000|\uFFFD/g;
    function qv(e) {
      Zi(e);
      var r = typeof e == "string" ? e : "" + e;
      return r.replace(pL, `
`).replace(gL, "");
    }
    function Zv(e, r, c, g) {
      var x = qv(r), R = qv(e);
      if (R !== x && (g && (Ca || (Ca = !0, T('Text content did not match. Server: "%s" Client: "%s"', R, x))), c && an))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function NS(e) {
      return e.nodeType === za ? e : e.ownerDocument;
    }
    function vL() {
    }
    function Qv(e) {
      e.onclick = vL;
    }
    function mL(e, r, c, g, x) {
      for (var R in g)
        if (g.hasOwnProperty(R)) {
          var _ = g[R];
          if (R === xc)
            _ && Object.freeze(_), Vg(r, _);
          else if (R === ap) {
            var Y = _ ? _[Vv] : void 0;
            Y != null && Ng(r, Y);
          } else if (R === yc)
            if (typeof _ == "string") {
              var W = e !== "textarea" || _ !== "";
              W && Zc(r, _);
            } else
              typeof _ == "number" && Zc(r, "" + _);
          else
            R === Xv || R === cu || R === DS || (Ut.hasOwnProperty(R) ? _ != null && (typeof _ != "function" && $v(R, _), R === "onScroll" && er("scroll", r)) : _ != null && Di(r, R, _, x));
        }
    }
    function yL(e, r, c, g) {
      for (var x = 0; x < r.length; x += 2) {
        var R = r[x], _ = r[x + 1];
        R === xc ? Vg(e, _) : R === ap ? Ng(e, _) : R === yc ? Zc(e, _) : Di(e, R, _, g);
      }
    }
    function xL(e, r, c, g) {
      var x, R = NS(c), _, Y = g;
      if (Y === gs && (Y = $c(e)), Y === gs) {
        if (x = ms(e, r), !x && e !== e.toLowerCase() && T("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", e), e === "script") {
          var W = R.createElement("div");
          W.innerHTML = "<script><\/script>";
          var J = W.firstChild;
          _ = W.removeChild(J);
        } else if (typeof r.is == "string")
          _ = R.createElement(e, {
            is: r.is
          });
        else if (_ = R.createElement(e), e === "select") {
          var ne = _;
          r.multiple ? ne.multiple = !0 : r.size && (ne.size = r.size);
        }
      } else
        _ = R.createElementNS(Y, e);
      return Y === gs && !x && Object.prototype.toString.call(_) === "[object HTMLUnknownElement]" && !jn.call(Jx, e) && (Jx[e] = !0, T("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", e)), _;
    }
    function bL(e, r) {
      return NS(r).createTextNode(e);
    }
    function wL(e, r, c, g) {
      var x = ms(r, c);
      Gv(r, c);
      var R;
      switch (r) {
        case "dialog":
          er("cancel", e), er("close", e), R = c;
          break;
        case "iframe":
        case "object":
        case "embed":
          er("load", e), R = c;
          break;
        case "video":
        case "audio":
          for (var _ = 0; _ < np.length; _++)
            er(np[_], e);
          R = c;
          break;
        case "source":
          er("error", e), R = c;
          break;
        case "img":
        case "image":
        case "link":
          er("error", e), er("load", e), R = c;
          break;
        case "details":
          er("toggle", e), R = c;
          break;
        case "input":
          zu(e, c), R = Nu(e, c), er("invalid", e);
          break;
        case "option":
          Vc(e, c), R = c;
          break;
        case "select":
          Dg(e, c), R = Vf(e, c), er("invalid", e);
          break;
        case "textarea":
          Og(e, c), R = $f(e, c), er("invalid", e);
          break;
        default:
          R = c;
      }
      switch (Kc(r, R), mL(r, e, g, R, x), r) {
        case "input":
          _o(e), Iu(e, c, !1);
          break;
        case "textarea":
          _o(e), Pg(e);
          break;
        case "option":
          Xf(e, c);
          break;
        case "select":
          cx(e, c);
          break;
        default:
          typeof R.onClick == "function" && Qv(e);
          break;
      }
    }
    function SL(e, r, c, g, x) {
      Gv(r, g);
      var R = null, _, Y;
      switch (r) {
        case "input":
          _ = Nu(e, c), Y = Nu(e, g), R = [];
          break;
        case "select":
          _ = Vf(e, c), Y = Vf(e, g), R = [];
          break;
        case "textarea":
          _ = $f(e, c), Y = $f(e, g), R = [];
          break;
        default:
          _ = c, Y = g, typeof _.onClick != "function" && typeof Y.onClick == "function" && Qv(e);
          break;
      }
      Kc(r, Y);
      var W, J, ne = null;
      for (W in _)
        if (!(Y.hasOwnProperty(W) || !_.hasOwnProperty(W) || _[W] == null))
          if (W === xc) {
            var ge = _[W];
            for (J in ge)
              ge.hasOwnProperty(J) && (ne || (ne = {}), ne[J] = "");
          } else
            W === ap || W === yc || W === Xv || W === cu || W === DS || (Ut.hasOwnProperty(W) ? R || (R = []) : (R = R || []).push(W, null));
      for (W in Y) {
        var he = Y[W], Ce = _ != null ? _[W] : void 0;
        if (!(!Y.hasOwnProperty(W) || he === Ce || he == null && Ce == null))
          if (W === xc)
            if (he && Object.freeze(he), Ce) {
              for (J in Ce)
                Ce.hasOwnProperty(J) && (!he || !he.hasOwnProperty(J)) && (ne || (ne = {}), ne[J] = "");
              for (J in he)
                he.hasOwnProperty(J) && Ce[J] !== he[J] && (ne || (ne = {}), ne[J] = he[J]);
            } else
              ne || (R || (R = []), R.push(W, ne)), ne = he;
          else if (W === ap) {
            var Ae = he ? he[Vv] : void 0, De = Ce ? Ce[Vv] : void 0;
            Ae != null && De !== Ae && (R = R || []).push(W, Ae);
          } else
            W === yc ? (typeof he == "string" || typeof he == "number") && (R = R || []).push(W, "" + he) : W === Xv || W === cu || (Ut.hasOwnProperty(W) ? (he != null && (typeof he != "function" && $v(W, he), W === "onScroll" && er("scroll", e)), !R && Ce !== he && (R = [])) : (R = R || []).push(W, he));
      }
      return ne && (Hu(ne, Y[xc]), (R = R || []).push(xc, ne)), R;
    }
    function kL(e, r, c, g, x) {
      c === "input" && x.type === "radio" && x.name != null && Wf(e, x);
      var R = ms(c, g), _ = ms(c, x);
      switch (yL(e, r, R, _), c) {
        case "input":
          Ol(e, x);
          break;
        case "textarea":
          _g(e, x);
          break;
        case "select":
          dx(e, x);
          break;
      }
    }
    function CL(e) {
      {
        var r = e.toLowerCase();
        return Jc.hasOwnProperty(r) && Jc[r] || null;
      }
    }
    function AL(e, r, c, g, x, R, _) {
      var Y, W;
      switch (Y = ms(r, c), Gv(r, c), r) {
        case "dialog":
          er("cancel", e), er("close", e);
          break;
        case "iframe":
        case "object":
        case "embed":
          er("load", e);
          break;
        case "video":
        case "audio":
          for (var J = 0; J < np.length; J++)
            er(np[J], e);
          break;
        case "source":
          er("error", e);
          break;
        case "img":
        case "image":
        case "link":
          er("error", e), er("load", e);
          break;
        case "details":
          er("toggle", e);
          break;
        case "input":
          zu(e, c), er("invalid", e);
          break;
        case "option":
          Vc(e, c);
          break;
        case "select":
          Dg(e, c), er("invalid", e);
          break;
        case "textarea":
          Og(e, c), er("invalid", e);
          break;
      }
      Kc(r, c);
      {
        W = /* @__PURE__ */ new Set();
        for (var ne = e.attributes, ge = 0; ge < ne.length; ge++) {
          var he = ne[ge].name.toLowerCase();
          switch (he) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              W.add(ne[ge].name);
          }
        }
      }
      var Ce = null;
      for (var Ae in c)
        if (c.hasOwnProperty(Ae)) {
          var De = c[Ae];
          if (Ae === yc)
            typeof De == "string" ? e.textContent !== De && (c[cu] !== !0 && Zv(e.textContent, De, R, _), Ce = [yc, De]) : typeof De == "number" && e.textContent !== "" + De && (c[cu] !== !0 && Zv(e.textContent, De, R, _), Ce = [yc, "" + De]);
          else if (Ut.hasOwnProperty(Ae))
            De != null && (typeof De != "function" && $v(Ae, De), Ae === "onScroll" && er("scroll", e));
          else if (_ && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof Y == "boolean") {
            var ct = void 0, Pt = Y && kt ? null : gr(Ae);
            if (c[cu] !== !0) {
              if (!(Ae === Xv || Ae === cu || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              Ae === "value" || Ae === "checked" || Ae === "selected")) {
                if (Ae === ap) {
                  var Tt = e.innerHTML, hn = De ? De[Vv] : void 0;
                  if (hn != null) {
                    var on = PS(e, hn);
                    on !== Tt && sp(Ae, Tt, on);
                  }
                } else if (Ae === xc) {
                  if (W.delete(Ae), _S) {
                    var xe = xx(De);
                    ct = e.getAttribute("style"), xe !== ct && sp(Ae, ct, xe);
                  }
                } else if (Y && !kt)
                  W.delete(Ae.toLowerCase()), ct = Gs(e, Ae, De), De !== ct && sp(Ae, ct, De);
                else if (!$n(Ae, Pt, Y) && !Ln(Ae, De, Pt, Y)) {
                  var Oe = !1;
                  if (Pt !== null)
                    W.delete(Pt.attributeName), ct = hs(e, Ae, De, Pt);
                  else {
                    var be = g;
                    if (be === gs && (be = $c(r)), be === gs)
                      W.delete(Ae.toLowerCase());
                    else {
                      var Xe = CL(Ae);
                      Xe !== null && Xe !== Ae && (Oe = !0, W.delete(Xe)), W.delete(Ae);
                    }
                    ct = Gs(e, Ae, De);
                  }
                  var dt = kt;
                  !dt && De !== ct && !Oe && sp(Ae, ct, De);
                }
              }
            }
          }
        }
      switch (_ && // $FlowFixMe - Should be inferred as not undefined.
      W.size > 0 && c[cu] !== !0 && OS(W), r) {
        case "input":
          _o(e), Iu(e, c, !0);
          break;
        case "textarea":
          _o(e), Pg(e);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof c.onClick == "function" && Qv(e);
          break;
      }
      return Ce;
    }
    function TL(e, r, c) {
      var g = e.nodeValue !== r;
      return g;
    }
    function eb(e, r) {
      {
        if (Ca)
          return;
        Ca = !0, T("Did not expect server HTML to contain a <%s> in <%s>.", r.nodeName.toLowerCase(), e.nodeName.toLowerCase());
      }
    }
    function tb(e, r) {
      {
        if (Ca)
          return;
        Ca = !0, T('Did not expect server HTML to contain the text node "%s" in <%s>.', r.nodeValue, e.nodeName.toLowerCase());
      }
    }
    function nb(e, r, c) {
      {
        if (Ca)
          return;
        Ca = !0, T("Expected server HTML to contain a matching <%s> in <%s>.", r, e.nodeName.toLowerCase());
      }
    }
    function rb(e, r) {
      {
        if (r === "" || Ca)
          return;
        Ca = !0, T('Expected server HTML to contain a matching text node for "%s" in <%s>.', r, e.nodeName.toLowerCase());
      }
    }
    function EL(e, r, c) {
      switch (r) {
        case "input":
          Eg(e, c);
          return;
        case "textarea":
          qf(e, c);
          return;
        case "select":
          fx(e, c);
          return;
      }
    }
    var op = function() {
    }, lp = function() {
    };
    {
      var RL = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], zS = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], LL = zS.concat(["button"]), ML = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], IS = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      lp = function(e, r) {
        var c = p({}, e || IS), g = {
          tag: r
        };
        return zS.indexOf(r) !== -1 && (c.aTagInScope = null, c.buttonTagInScope = null, c.nobrTagInScope = null), LL.indexOf(r) !== -1 && (c.pTagInButtonScope = null), RL.indexOf(r) !== -1 && r !== "address" && r !== "div" && r !== "p" && (c.listItemTagAutoclosing = null, c.dlItemTagAutoclosing = null), c.current = g, r === "form" && (c.formTag = g), r === "a" && (c.aTagInScope = g), r === "button" && (c.buttonTagInScope = g), r === "nobr" && (c.nobrTagInScope = g), r === "p" && (c.pTagInButtonScope = g), r === "li" && (c.listItemTagAutoclosing = g), (r === "dd" || r === "dt") && (c.dlItemTagAutoclosing = g), c;
      };
      var DL = function(e, r) {
        switch (r) {
          case "select":
            return e === "option" || e === "optgroup" || e === "#text";
          case "optgroup":
            return e === "option" || e === "#text";
          case "option":
            return e === "#text";
          case "tr":
            return e === "th" || e === "td" || e === "style" || e === "script" || e === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return e === "tr" || e === "style" || e === "script" || e === "template";
          case "colgroup":
            return e === "col" || e === "template";
          case "table":
            return e === "caption" || e === "colgroup" || e === "tbody" || e === "tfoot" || e === "thead" || e === "style" || e === "script" || e === "template";
          case "head":
            return e === "base" || e === "basefont" || e === "bgsound" || e === "link" || e === "meta" || e === "title" || e === "noscript" || e === "noframes" || e === "style" || e === "script" || e === "template";
          case "html":
            return e === "head" || e === "body" || e === "frameset";
          case "frameset":
            return e === "frame";
          case "#document":
            return e === "html";
        }
        switch (e) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return r !== "h1" && r !== "h2" && r !== "h3" && r !== "h4" && r !== "h5" && r !== "h6";
          case "rp":
          case "rt":
            return ML.indexOf(r) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return r == null;
        }
        return !0;
      }, OL = function(e, r) {
        switch (e) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return r.pTagInButtonScope;
          case "form":
            return r.formTag || r.pTagInButtonScope;
          case "li":
            return r.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return r.dlItemTagAutoclosing;
          case "button":
            return r.buttonTagInScope;
          case "a":
            return r.aTagInScope;
          case "nobr":
            return r.nobrTagInScope;
        }
        return null;
      }, FS = {};
      op = function(e, r, c) {
        c = c || IS;
        var g = c.current, x = g && g.tag;
        r != null && (e != null && T("validateDOMNesting: when childText is passed, childTag should be null"), e = "#text");
        var R = DL(e, x) ? null : g, _ = R ? null : OL(e, c), Y = R || _;
        if (Y) {
          var W = Y.tag, J = !!R + "|" + e + "|" + W;
          if (!FS[J]) {
            FS[J] = !0;
            var ne = e, ge = "";
            if (e === "#text" ? /\S/.test(r) ? ne = "Text nodes" : (ne = "Whitespace text nodes", ge = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : ne = "<" + e + ">", R) {
              var he = "";
              W === "table" && e === "tr" && (he += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), T("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", ne, W, ge, he);
            } else
              T("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", ne, W);
          }
        }
      };
    }
    var Kv = "suppressHydrationWarning", Jv = "$", em = "/$", up = "$?", cp = "$!", _L = "style", ib = null, ab = null;
    function PL(e) {
      var r, c, g = e.nodeType;
      switch (g) {
        case za:
        case Po: {
          r = g === za ? "#document" : "#fragment";
          var x = e.documentElement;
          c = x ? x.namespaceURI : Qf(null, "");
          break;
        }
        default: {
          var R = g === mr ? e.parentNode : e, _ = R.namespaceURI || null;
          r = R.tagName, c = Qf(_, r);
          break;
        }
      }
      {
        var Y = r.toLowerCase(), W = lp(null, Y);
        return {
          namespace: c,
          ancestorInfo: W
        };
      }
    }
    function NL(e, r, c) {
      {
        var g = e, x = Qf(g.namespace, r), R = lp(g.ancestorInfo, r);
        return {
          namespace: x,
          ancestorInfo: R
        };
      }
    }
    function Dj(e) {
      return e;
    }
    function zL(e) {
      ib = ia(), ab = ZR();
      var r = null;
      return zr(!1), r;
    }
    function IL(e) {
      QR(ab), zr(ib), ib = null, ab = null;
    }
    function FL(e, r, c, g, x) {
      var R;
      {
        var _ = g;
        if (op(e, null, _.ancestorInfo), typeof r.children == "string" || typeof r.children == "number") {
          var Y = "" + r.children, W = lp(_.ancestorInfo, e);
          op(null, Y, W);
        }
        R = _.namespace;
      }
      var J = xL(e, r, c, R);
      return hp(x, J), hb(J, r), J;
    }
    function YL(e, r) {
      e.appendChild(r);
    }
    function HL(e, r, c, g, x) {
      switch (wL(e, r, c, g), r) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!c.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function jL(e, r, c, g, x, R) {
      {
        var _ = R;
        if (typeof g.children != typeof c.children && (typeof g.children == "string" || typeof g.children == "number")) {
          var Y = "" + g.children, W = lp(_.ancestorInfo, r);
          op(null, Y, W);
        }
      }
      return SL(e, r, c, g);
    }
    function sb(e, r) {
      return e === "textarea" || e === "noscript" || typeof r.children == "string" || typeof r.children == "number" || typeof r.dangerouslySetInnerHTML == "object" && r.dangerouslySetInnerHTML !== null && r.dangerouslySetInnerHTML.__html != null;
    }
    function UL(e, r, c, g) {
      {
        var x = c;
        op(null, e, x.ancestorInfo);
      }
      var R = bL(e, r);
      return hp(g, R), R;
    }
    function BL() {
      var e = window.event;
      return e === void 0 ? As : bi(e.type);
    }
    var ob = typeof setTimeout == "function" ? setTimeout : void 0, WL = typeof clearTimeout == "function" ? clearTimeout : void 0, lb = -1, YS = typeof Promise == "function" ? Promise : void 0, XL = typeof queueMicrotask == "function" ? queueMicrotask : typeof YS < "u" ? function(e) {
      return YS.resolve(null).then(e).catch(VL);
    } : ob;
    function VL(e) {
      setTimeout(function() {
        throw e;
      });
    }
    function GL(e, r, c, g) {
      switch (r) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          c.autoFocus && e.focus();
          return;
        case "img": {
          c.src && (e.src = c.src);
          return;
        }
      }
    }
    function $L(e, r, c, g, x, R) {
      kL(e, r, c, g, x), hb(e, x);
    }
    function HS(e) {
      Zc(e, "");
    }
    function qL(e, r, c) {
      e.nodeValue = c;
    }
    function ZL(e, r) {
      e.appendChild(r);
    }
    function QL(e, r) {
      var c;
      e.nodeType === mr ? (c = e.parentNode, c.insertBefore(r, e)) : (c = e, c.appendChild(r));
      var g = e._reactRootContainer;
      g == null && c.onclick === null && Qv(c);
    }
    function KL(e, r, c) {
      e.insertBefore(r, c);
    }
    function JL(e, r, c) {
      e.nodeType === mr ? e.parentNode.insertBefore(r, c) : e.insertBefore(r, c);
    }
    function eM(e, r) {
      e.removeChild(r);
    }
    function tM(e, r) {
      e.nodeType === mr ? e.parentNode.removeChild(r) : e.removeChild(r);
    }
    function ub(e, r) {
      var c = r, g = 0;
      do {
        var x = c.nextSibling;
        if (e.removeChild(c), x && x.nodeType === mr) {
          var R = x.data;
          if (R === em)
            if (g === 0) {
              e.removeChild(x), sn(r);
              return;
            } else
              g--;
          else
            (R === Jv || R === up || R === cp) && g++;
        }
        c = x;
      } while (c);
      sn(r);
    }
    function nM(e, r) {
      e.nodeType === mr ? ub(e.parentNode, r) : e.nodeType === Oi && ub(e, r), sn(e);
    }
    function rM(e) {
      e = e;
      var r = e.style;
      typeof r.setProperty == "function" ? r.setProperty("display", "none", "important") : r.display = "none";
    }
    function iM(e) {
      e.nodeValue = "";
    }
    function aM(e, r) {
      e = e;
      var c = r[_L], g = c != null && c.hasOwnProperty("display") ? c.display : null;
      e.style.display = Qc("display", g);
    }
    function sM(e, r) {
      e.nodeValue = r;
    }
    function oM(e) {
      e.nodeType === Oi ? e.textContent = "" : e.nodeType === za && e.documentElement && e.removeChild(e.documentElement);
    }
    function lM(e, r, c) {
      return e.nodeType !== Oi || r.toLowerCase() !== e.nodeName.toLowerCase() ? null : e;
    }
    function uM(e, r) {
      return r === "" || e.nodeType !== vs ? null : e;
    }
    function cM(e) {
      return e.nodeType !== mr ? null : e;
    }
    function jS(e) {
      return e.data === up;
    }
    function cb(e) {
      return e.data === cp;
    }
    function dM(e) {
      var r = e.nextSibling && e.nextSibling.dataset, c, g, x;
      return r && (c = r.dgst, g = r.msg, x = r.stck), {
        message: g,
        digest: c,
        stack: x
      };
    }
    function fM(e, r) {
      e._reactRetry = r;
    }
    function tm(e) {
      for (; e != null; e = e.nextSibling) {
        var r = e.nodeType;
        if (r === Oi || r === vs)
          break;
        if (r === mr) {
          var c = e.data;
          if (c === Jv || c === cp || c === up)
            break;
          if (c === em)
            return null;
        }
      }
      return e;
    }
    function dp(e) {
      return tm(e.nextSibling);
    }
    function hM(e) {
      return tm(e.firstChild);
    }
    function pM(e) {
      return tm(e.firstChild);
    }
    function gM(e) {
      return tm(e.nextSibling);
    }
    function vM(e, r, c, g, x, R, _) {
      hp(R, e), hb(e, c);
      var Y;
      {
        var W = x;
        Y = W.namespace;
      }
      var J = (R.mode & nn) !== Nt;
      return AL(e, r, c, Y, g, J, _);
    }
    function mM(e, r, c, g) {
      return hp(c, e), c.mode & nn, TL(e, r);
    }
    function yM(e, r) {
      hp(r, e);
    }
    function xM(e) {
      for (var r = e.nextSibling, c = 0; r; ) {
        if (r.nodeType === mr) {
          var g = r.data;
          if (g === em) {
            if (c === 0)
              return dp(r);
            c--;
          } else
            (g === Jv || g === cp || g === up) && c++;
        }
        r = r.nextSibling;
      }
      return null;
    }
    function US(e) {
      for (var r = e.previousSibling, c = 0; r; ) {
        if (r.nodeType === mr) {
          var g = r.data;
          if (g === Jv || g === cp || g === up) {
            if (c === 0)
              return r;
            c--;
          } else
            g === em && c++;
        }
        r = r.previousSibling;
      }
      return null;
    }
    function bM(e) {
      sn(e);
    }
    function wM(e) {
      sn(e);
    }
    function SM(e) {
      return e !== "head" && e !== "body";
    }
    function kM(e, r, c, g) {
      var x = !0;
      Zv(r.nodeValue, c, g, x);
    }
    function CM(e, r, c, g, x, R) {
      if (r[Kv] !== !0) {
        var _ = !0;
        Zv(g.nodeValue, x, R, _);
      }
    }
    function AM(e, r) {
      r.nodeType === Oi ? eb(e, r) : r.nodeType === mr || tb(e, r);
    }
    function TM(e, r) {
      {
        var c = e.parentNode;
        c !== null && (r.nodeType === Oi ? eb(c, r) : r.nodeType === mr || tb(c, r));
      }
    }
    function EM(e, r, c, g, x) {
      (x || r[Kv] !== !0) && (g.nodeType === Oi ? eb(c, g) : g.nodeType === mr || tb(c, g));
    }
    function RM(e, r, c) {
      nb(e, r);
    }
    function LM(e, r) {
      rb(e, r);
    }
    function MM(e, r, c) {
      {
        var g = e.parentNode;
        g !== null && nb(g, r);
      }
    }
    function DM(e, r) {
      {
        var c = e.parentNode;
        c !== null && rb(c, r);
      }
    }
    function OM(e, r, c, g, x, R) {
      (R || r[Kv] !== !0) && nb(c, g);
    }
    function _M(e, r, c, g, x) {
      (x || r[Kv] !== !0) && rb(c, g);
    }
    function PM(e) {
      T("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", e.nodeName.toLowerCase());
    }
    function NM(e) {
      rp(e);
    }
    var rf = Math.random().toString(36).slice(2), af = "__reactFiber$" + rf, db = "__reactProps$" + rf, fp = "__reactContainer$" + rf, fb = "__reactEvents$" + rf, zM = "__reactListeners$" + rf, IM = "__reactHandles$" + rf;
    function FM(e) {
      delete e[af], delete e[db], delete e[fb], delete e[zM], delete e[IM];
    }
    function hp(e, r) {
      r[af] = e;
    }
    function nm(e, r) {
      r[fp] = e;
    }
    function BS(e) {
      e[fp] = null;
    }
    function pp(e) {
      return !!e[fp];
    }
    function bc(e) {
      var r = e[af];
      if (r)
        return r;
      for (var c = e.parentNode; c; ) {
        if (r = c[fp] || c[af], r) {
          var g = r.alternate;
          if (r.child !== null || g !== null && g.child !== null)
            for (var x = US(e); x !== null; ) {
              var R = x[af];
              if (R)
                return R;
              x = US(x);
            }
          return r;
        }
        e = c, c = e.parentNode;
      }
      return null;
    }
    function du(e) {
      var r = e[af] || e[fp];
      return r && (r.tag === se || r.tag === ae || r.tag === re || r.tag === q) ? r : null;
    }
    function sf(e) {
      if (e.tag === se || e.tag === ae)
        return e.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function rm(e) {
      return e[db] || null;
    }
    function hb(e, r) {
      e[db] = r;
    }
    function YM(e) {
      var r = e[fb];
      return r === void 0 && (r = e[fb] = /* @__PURE__ */ new Set()), r;
    }
    var WS = {}, XS = h.ReactDebugCurrentFrame;
    function im(e) {
      if (e) {
        var r = e._owner, c = Me(e.type, e._source, r ? r.type : null);
        XS.setExtraStackFrame(c);
      } else
        XS.setExtraStackFrame(null);
    }
    function Ms(e, r, c, g, x) {
      {
        var R = Function.call.bind(jn);
        for (var _ in e)
          if (R(e, _)) {
            var Y = void 0;
            try {
              if (typeof e[_] != "function") {
                var W = Error((g || "React class") + ": " + c + " type `" + _ + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e[_] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw W.name = "Invariant Violation", W;
              }
              Y = e[_](r, _, g, c, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (J) {
              Y = J;
            }
            Y && !(Y instanceof Error) && (im(x), T("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", g || "React class", c, _, typeof Y), im(null)), Y instanceof Error && !(Y.message in WS) && (WS[Y.message] = !0, im(x), T("Failed %s type: %s", c, Y.message), im(null));
          }
      }
    }
    var pb = [], am;
    am = [];
    var ll = -1;
    function fu(e) {
      return {
        current: e
      };
    }
    function ji(e, r) {
      if (ll < 0) {
        T("Unexpected pop.");
        return;
      }
      r !== am[ll] && T("Unexpected Fiber popped."), e.current = pb[ll], pb[ll] = null, am[ll] = null, ll--;
    }
    function Ui(e, r, c) {
      ll++, pb[ll] = e.current, am[ll] = c, e.current = r;
    }
    var gb;
    gb = {};
    var ja = {};
    Object.freeze(ja);
    var ul = fu(ja), yo = fu(!1), vb = ja;
    function of(e, r, c) {
      return c && xo(r) ? vb : ul.current;
    }
    function VS(e, r, c) {
      {
        var g = e.stateNode;
        g.__reactInternalMemoizedUnmaskedChildContext = r, g.__reactInternalMemoizedMaskedChildContext = c;
      }
    }
    function lf(e, r) {
      {
        var c = e.type, g = c.contextTypes;
        if (!g)
          return ja;
        var x = e.stateNode;
        if (x && x.__reactInternalMemoizedUnmaskedChildContext === r)
          return x.__reactInternalMemoizedMaskedChildContext;
        var R = {};
        for (var _ in g)
          R[_] = r[_];
        {
          var Y = gt(e) || "Unknown";
          Ms(g, R, "context", Y);
        }
        return x && VS(e, r, R), R;
      }
    }
    function sm() {
      return yo.current;
    }
    function xo(e) {
      {
        var r = e.childContextTypes;
        return r != null;
      }
    }
    function om(e) {
      ji(yo, e), ji(ul, e);
    }
    function mb(e) {
      ji(yo, e), ji(ul, e);
    }
    function GS(e, r, c) {
      {
        if (ul.current !== ja)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Ui(ul, r, e), Ui(yo, c, e);
      }
    }
    function $S(e, r, c) {
      {
        var g = e.stateNode, x = r.childContextTypes;
        if (typeof g.getChildContext != "function") {
          {
            var R = gt(e) || "Unknown";
            gb[R] || (gb[R] = !0, T("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", R, R));
          }
          return c;
        }
        var _ = g.getChildContext();
        for (var Y in _)
          if (!(Y in x))
            throw new Error((gt(e) || "Unknown") + '.getChildContext(): key "' + Y + '" is not defined in childContextTypes.');
        {
          var W = gt(e) || "Unknown";
          Ms(x, _, "child context", W);
        }
        return p({}, c, _);
      }
    }
    function lm(e) {
      {
        var r = e.stateNode, c = r && r.__reactInternalMemoizedMergedChildContext || ja;
        return vb = ul.current, Ui(ul, c, e), Ui(yo, yo.current, e), !0;
      }
    }
    function qS(e, r, c) {
      {
        var g = e.stateNode;
        if (!g)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (c) {
          var x = $S(e, r, vb);
          g.__reactInternalMemoizedMergedChildContext = x, ji(yo, e), ji(ul, e), Ui(ul, x, e), Ui(yo, c, e);
        } else
          ji(yo, e), Ui(yo, c, e);
      }
    }
    function HM(e) {
      {
        if (!mh(e) || e.tag !== U)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var r = e;
        do {
          switch (r.tag) {
            case q:
              return r.stateNode.context;
            case U: {
              var c = r.type;
              if (xo(c))
                return r.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          r = r.return;
        } while (r !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var hu = 0, um = 1, cl = null, yb = !1, xb = !1;
    function ZS(e) {
      cl === null ? cl = [e] : cl.push(e);
    }
    function jM(e) {
      yb = !0, ZS(e);
    }
    function QS() {
      yb && pu();
    }
    function pu() {
      if (!xb && cl !== null) {
        xb = !0;
        var e = 0, r = ba();
        try {
          var c = !0, g = cl;
          for (Cr(ui); e < g.length; e++) {
            var x = g[e];
            do
              x = x(c);
            while (x !== null);
          }
          cl = null, yb = !1;
        } catch (R) {
          throw cl !== null && (cl = cl.slice(e + 1)), ld(cd, pu), R;
        } finally {
          Cr(r), xb = !1;
        }
      }
      return null;
    }
    var uf = [], cf = 0, cm = null, dm = 0, Ja = [], es = 0, wc = null, dl = 1, fl = "";
    function UM(e) {
      return kc(), (e.flags & ph) !== _t;
    }
    function BM(e) {
      return kc(), dm;
    }
    function WM() {
      var e = fl, r = dl, c = r & ~XM(r);
      return c.toString(32) + e;
    }
    function Sc(e, r) {
      kc(), uf[cf++] = dm, uf[cf++] = cm, cm = e, dm = r;
    }
    function KS(e, r, c) {
      kc(), Ja[es++] = dl, Ja[es++] = fl, Ja[es++] = wc, wc = e;
      var g = dl, x = fl, R = fm(g) - 1, _ = g & ~(1 << R), Y = c + 1, W = fm(r) + R;
      if (W > 30) {
        var J = R - R % 5, ne = (1 << J) - 1, ge = (_ & ne).toString(32), he = _ >> J, Ce = R - J, Ae = fm(r) + Ce, De = Y << Ce, ct = De | he, Pt = ge + x;
        dl = 1 << Ae | ct, fl = Pt;
      } else {
        var Tt = Y << R, hn = Tt | _, on = x;
        dl = 1 << W | hn, fl = on;
      }
    }
    function bb(e) {
      kc();
      var r = e.return;
      if (r !== null) {
        var c = 1, g = 0;
        Sc(e, c), KS(e, c, g);
      }
    }
    function fm(e) {
      return 32 - vd(e);
    }
    function XM(e) {
      return 1 << fm(e) - 1;
    }
    function wb(e) {
      for (; e === cm; )
        cm = uf[--cf], uf[cf] = null, dm = uf[--cf], uf[cf] = null;
      for (; e === wc; )
        wc = Ja[--es], Ja[es] = null, fl = Ja[--es], Ja[es] = null, dl = Ja[--es], Ja[es] = null;
    }
    function VM() {
      return kc(), wc !== null ? {
        id: dl,
        overflow: fl
      } : null;
    }
    function GM(e, r) {
      kc(), Ja[es++] = dl, Ja[es++] = fl, Ja[es++] = wc, dl = r.id, fl = r.overflow, wc = e;
    }
    function kc() {
      Si() || T("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var wi = null, ts = null, Ds = !1, Cc = !1, gu = null;
    function $M() {
      Ds && T("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function JS() {
      Cc = !0;
    }
    function qM() {
      return Cc;
    }
    function ZM(e) {
      var r = e.stateNode.containerInfo;
      return ts = pM(r), wi = e, Ds = !0, gu = null, Cc = !1, !0;
    }
    function QM(e, r, c) {
      return ts = gM(r), wi = e, Ds = !0, gu = null, Cc = !1, c !== null && GM(e, c), !0;
    }
    function ek(e, r) {
      switch (e.tag) {
        case q: {
          AM(e.stateNode.containerInfo, r);
          break;
        }
        case se: {
          var c = (e.mode & nn) !== Nt;
          EM(
            e.type,
            e.memoizedProps,
            e.stateNode,
            r,
            // TODO: Delete this argument when we remove the legacy root API.
            c
          );
          break;
        }
        case re: {
          var g = e.memoizedState;
          g.dehydrated !== null && TM(g.dehydrated, r);
          break;
        }
      }
    }
    function tk(e, r) {
      ek(e, r);
      var c = e_();
      c.stateNode = r, c.return = e;
      var g = e.deletions;
      g === null ? (e.deletions = [c], e.flags |= Sn) : g.push(c);
    }
    function Sb(e, r) {
      {
        if (Cc)
          return;
        switch (e.tag) {
          case q: {
            var c = e.stateNode.containerInfo;
            switch (r.tag) {
              case se:
                var g = r.type;
                r.pendingProps, RM(c, g);
                break;
              case ae:
                var x = r.pendingProps;
                LM(c, x);
                break;
            }
            break;
          }
          case se: {
            var R = e.type, _ = e.memoizedProps, Y = e.stateNode;
            switch (r.tag) {
              case se: {
                var W = r.type, J = r.pendingProps, ne = (e.mode & nn) !== Nt;
                OM(
                  R,
                  _,
                  Y,
                  W,
                  J,
                  // TODO: Delete this argument when we remove the legacy root API.
                  ne
                );
                break;
              }
              case ae: {
                var ge = r.pendingProps, he = (e.mode & nn) !== Nt;
                _M(
                  R,
                  _,
                  Y,
                  ge,
                  // TODO: Delete this argument when we remove the legacy root API.
                  he
                );
                break;
              }
            }
            break;
          }
          case re: {
            var Ce = e.memoizedState, Ae = Ce.dehydrated;
            if (Ae !== null)
              switch (r.tag) {
                case se:
                  var De = r.type;
                  r.pendingProps, MM(Ae, De);
                  break;
                case ae:
                  var ct = r.pendingProps;
                  DM(Ae, ct);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function nk(e, r) {
      r.flags = r.flags & ~ga | Bn, Sb(e, r);
    }
    function rk(e, r) {
      switch (e.tag) {
        case se: {
          var c = e.type;
          e.pendingProps;
          var g = lM(r, c);
          return g !== null ? (e.stateNode = g, wi = e, ts = hM(g), !0) : !1;
        }
        case ae: {
          var x = e.pendingProps, R = uM(r, x);
          return R !== null ? (e.stateNode = R, wi = e, ts = null, !0) : !1;
        }
        case re: {
          var _ = cM(r);
          if (_ !== null) {
            var Y = {
              dehydrated: _,
              treeContext: VM(),
              retryLane: Yi
            };
            e.memoizedState = Y;
            var W = t_(_);
            return W.return = e, e.child = W, wi = e, ts = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function kb(e) {
      return (e.mode & nn) !== Nt && (e.flags & Xt) === _t;
    }
    function Cb(e) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function Ab(e) {
      if (Ds) {
        var r = ts;
        if (!r) {
          kb(e) && (Sb(wi, e), Cb()), nk(wi, e), Ds = !1, wi = e;
          return;
        }
        var c = r;
        if (!rk(e, r)) {
          kb(e) && (Sb(wi, e), Cb()), r = dp(c);
          var g = wi;
          if (!r || !rk(e, r)) {
            nk(wi, e), Ds = !1, wi = e;
            return;
          }
          tk(g, c);
        }
      }
    }
    function KM(e, r, c) {
      var g = e.stateNode, x = !Cc, R = vM(g, e.type, e.memoizedProps, r, c, e, x);
      return e.updateQueue = R, R !== null;
    }
    function JM(e) {
      var r = e.stateNode, c = e.memoizedProps, g = mM(r, c, e);
      if (g) {
        var x = wi;
        if (x !== null)
          switch (x.tag) {
            case q: {
              var R = x.stateNode.containerInfo, _ = (x.mode & nn) !== Nt;
              kM(
                R,
                r,
                c,
                // TODO: Delete this argument when we remove the legacy root API.
                _
              );
              break;
            }
            case se: {
              var Y = x.type, W = x.memoizedProps, J = x.stateNode, ne = (x.mode & nn) !== Nt;
              CM(
                Y,
                W,
                J,
                r,
                c,
                // TODO: Delete this argument when we remove the legacy root API.
                ne
              );
              break;
            }
          }
      }
      return g;
    }
    function eD(e) {
      var r = e.memoizedState, c = r !== null ? r.dehydrated : null;
      if (!c)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      yM(c, e);
    }
    function tD(e) {
      var r = e.memoizedState, c = r !== null ? r.dehydrated : null;
      if (!c)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return xM(c);
    }
    function ik(e) {
      for (var r = e.return; r !== null && r.tag !== se && r.tag !== q && r.tag !== re; )
        r = r.return;
      wi = r;
    }
    function hm(e) {
      if (e !== wi)
        return !1;
      if (!Ds)
        return ik(e), Ds = !0, !1;
      if (e.tag !== q && (e.tag !== se || SM(e.type) && !sb(e.type, e.memoizedProps))) {
        var r = ts;
        if (r)
          if (kb(e))
            ak(e), Cb();
          else
            for (; r; )
              tk(e, r), r = dp(r);
      }
      return ik(e), e.tag === re ? ts = tD(e) : ts = wi ? dp(e.stateNode) : null, !0;
    }
    function nD() {
      return Ds && ts !== null;
    }
    function ak(e) {
      for (var r = ts; r; )
        ek(e, r), r = dp(r);
    }
    function df() {
      wi = null, ts = null, Ds = !1, Cc = !1;
    }
    function sk() {
      gu !== null && (eA(gu), gu = null);
    }
    function Si() {
      return Ds;
    }
    function Tb(e) {
      gu === null ? gu = [e] : gu.push(e);
    }
    var rD = h.ReactCurrentBatchConfig, iD = null;
    function aD() {
      return rD.transition;
    }
    var Os = {
      recordUnsafeLifecycleWarnings: function(e, r) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(e, r) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var sD = function(e) {
        for (var r = null, c = e; c !== null; )
          c.mode & Kn && (r = c), c = c.return;
        return r;
      }, Ac = function(e) {
        var r = [];
        return e.forEach(function(c) {
          r.push(c);
        }), r.sort().join(", ");
      }, gp = [], vp = [], mp = [], yp = [], xp = [], bp = [], Tc = /* @__PURE__ */ new Set();
      Os.recordUnsafeLifecycleWarnings = function(e, r) {
        Tc.has(e.type) || (typeof r.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        r.componentWillMount.__suppressDeprecationWarning !== !0 && gp.push(e), e.mode & Kn && typeof r.UNSAFE_componentWillMount == "function" && vp.push(e), typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && mp.push(e), e.mode & Kn && typeof r.UNSAFE_componentWillReceiveProps == "function" && yp.push(e), typeof r.componentWillUpdate == "function" && r.componentWillUpdate.__suppressDeprecationWarning !== !0 && xp.push(e), e.mode & Kn && typeof r.UNSAFE_componentWillUpdate == "function" && bp.push(e));
      }, Os.flushPendingUnsafeLifecycleWarnings = function() {
        var e = /* @__PURE__ */ new Set();
        gp.length > 0 && (gp.forEach(function(he) {
          e.add(gt(he) || "Component"), Tc.add(he.type);
        }), gp = []);
        var r = /* @__PURE__ */ new Set();
        vp.length > 0 && (vp.forEach(function(he) {
          r.add(gt(he) || "Component"), Tc.add(he.type);
        }), vp = []);
        var c = /* @__PURE__ */ new Set();
        mp.length > 0 && (mp.forEach(function(he) {
          c.add(gt(he) || "Component"), Tc.add(he.type);
        }), mp = []);
        var g = /* @__PURE__ */ new Set();
        yp.length > 0 && (yp.forEach(function(he) {
          g.add(gt(he) || "Component"), Tc.add(he.type);
        }), yp = []);
        var x = /* @__PURE__ */ new Set();
        xp.length > 0 && (xp.forEach(function(he) {
          x.add(gt(he) || "Component"), Tc.add(he.type);
        }), xp = []);
        var R = /* @__PURE__ */ new Set();
        if (bp.length > 0 && (bp.forEach(function(he) {
          R.add(gt(he) || "Component"), Tc.add(he.type);
        }), bp = []), r.size > 0) {
          var _ = Ac(r);
          T(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, _);
        }
        if (g.size > 0) {
          var Y = Ac(g);
          T(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, Y);
        }
        if (R.size > 0) {
          var W = Ac(R);
          T(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, W);
        }
        if (e.size > 0) {
          var J = Ac(e);
          A(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, J);
        }
        if (c.size > 0) {
          var ne = Ac(c);
          A(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ne);
        }
        if (x.size > 0) {
          var ge = Ac(x);
          A(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ge);
        }
      };
      var pm = /* @__PURE__ */ new Map(), ok = /* @__PURE__ */ new Set();
      Os.recordLegacyContextWarning = function(e, r) {
        var c = sD(e);
        if (c === null) {
          T("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!ok.has(e.type)) {
          var g = pm.get(c);
          (e.type.contextTypes != null || e.type.childContextTypes != null || r !== null && typeof r.getChildContext == "function") && (g === void 0 && (g = [], pm.set(c, g)), g.push(e));
        }
      }, Os.flushLegacyContextWarning = function() {
        pm.forEach(function(e, r) {
          if (e.length !== 0) {
            var c = e[0], g = /* @__PURE__ */ new Set();
            e.forEach(function(R) {
              g.add(gt(R) || "Component"), ok.add(R.type);
            });
            var x = Ac(g);
            try {
              wn(c), T(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, x);
            } finally {
              ln();
            }
          }
        });
      }, Os.discardPendingWarnings = function() {
        gp = [], vp = [], mp = [], yp = [], xp = [], bp = [], pm = /* @__PURE__ */ new Map();
      };
    }
    function _s(e, r) {
      if (e && e.defaultProps) {
        var c = p({}, r), g = e.defaultProps;
        for (var x in g)
          c[x] === void 0 && (c[x] = g[x]);
        return c;
      }
      return r;
    }
    var Eb = fu(null), Rb;
    Rb = {};
    var gm = null, ff = null, Lb = null, vm = !1;
    function mm() {
      gm = null, ff = null, Lb = null, vm = !1;
    }
    function lk() {
      vm = !0;
    }
    function uk() {
      vm = !1;
    }
    function ck(e, r, c) {
      Ui(Eb, r._currentValue, e), r._currentValue = c, r._currentRenderer !== void 0 && r._currentRenderer !== null && r._currentRenderer !== Rb && T("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), r._currentRenderer = Rb;
    }
    function Mb(e, r) {
      var c = Eb.current;
      ji(Eb, r), e._currentValue = c;
    }
    function Db(e, r, c) {
      for (var g = e; g !== null; ) {
        var x = g.alternate;
        if (Qo(g.childLanes, r) ? x !== null && !Qo(x.childLanes, r) && (x.childLanes = en(x.childLanes, r)) : (g.childLanes = en(g.childLanes, r), x !== null && (x.childLanes = en(x.childLanes, r))), g === c)
          break;
        g = g.return;
      }
      g !== c && T("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function oD(e, r, c) {
      lD(e, r, c);
    }
    function lD(e, r, c) {
      var g = e.child;
      for (g !== null && (g.return = e); g !== null; ) {
        var x = void 0, R = g.dependencies;
        if (R !== null) {
          x = g.child;
          for (var _ = R.firstContext; _ !== null; ) {
            if (_.context === r) {
              if (g.tag === U) {
                var Y = kr(c), W = hl(Fn, Y);
                W.tag = xm;
                var J = g.updateQueue;
                if (J !== null) {
                  var ne = J.shared, ge = ne.pending;
                  ge === null ? W.next = W : (W.next = ge.next, ge.next = W), ne.pending = W;
                }
              }
              g.lanes = en(g.lanes, c);
              var he = g.alternate;
              he !== null && (he.lanes = en(he.lanes, c)), Db(g.return, c, e), R.lanes = en(R.lanes, c);
              break;
            }
            _ = _.next;
          }
        } else if (g.tag === Q)
          x = g.type === e.type ? null : g.child;
        else if (g.tag === Ge) {
          var Ce = g.return;
          if (Ce === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Ce.lanes = en(Ce.lanes, c);
          var Ae = Ce.alternate;
          Ae !== null && (Ae.lanes = en(Ae.lanes, c)), Db(Ce, c, e), x = g.sibling;
        } else
          x = g.child;
        if (x !== null)
          x.return = g;
        else
          for (x = g; x !== null; ) {
            if (x === e) {
              x = null;
              break;
            }
            var De = x.sibling;
            if (De !== null) {
              De.return = x.return, x = De;
              break;
            }
            x = x.return;
          }
        g = x;
      }
    }
    function hf(e, r) {
      gm = e, ff = null, Lb = null;
      var c = e.dependencies;
      if (c !== null) {
        var g = c.firstContext;
        g !== null && (Hi(c.lanes, r) && Pp(), c.firstContext = null);
      }
    }
    function Fr(e) {
      vm && T("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var r = e._currentValue;
      if (Lb !== e) {
        var c = {
          context: e,
          memoizedValue: r,
          next: null
        };
        if (ff === null) {
          if (gm === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          ff = c, gm.dependencies = {
            lanes: Pe,
            firstContext: c
          };
        } else
          ff = ff.next = c;
      }
      return r;
    }
    var Ec = null;
    function Ob(e) {
      Ec === null ? Ec = [e] : Ec.push(e);
    }
    function uD() {
      if (Ec !== null) {
        for (var e = 0; e < Ec.length; e++) {
          var r = Ec[e], c = r.interleaved;
          if (c !== null) {
            r.interleaved = null;
            var g = c.next, x = r.pending;
            if (x !== null) {
              var R = x.next;
              x.next = g, c.next = R;
            }
            r.pending = c;
          }
        }
        Ec = null;
      }
    }
    function dk(e, r, c, g) {
      var x = r.interleaved;
      return x === null ? (c.next = c, Ob(r)) : (c.next = x.next, x.next = c), r.interleaved = c, ym(e, g);
    }
    function cD(e, r, c, g) {
      var x = r.interleaved;
      x === null ? (c.next = c, Ob(r)) : (c.next = x.next, x.next = c), r.interleaved = c;
    }
    function dD(e, r, c, g) {
      var x = r.interleaved;
      return x === null ? (c.next = c, Ob(r)) : (c.next = x.next, x.next = c), r.interleaved = c, ym(e, g);
    }
    function Aa(e, r) {
      return ym(e, r);
    }
    var fD = ym;
    function ym(e, r) {
      e.lanes = en(e.lanes, r);
      var c = e.alternate;
      c !== null && (c.lanes = en(c.lanes, r)), c === null && (e.flags & (Bn | ga)) !== _t && fA(e);
      for (var g = e, x = e.return; x !== null; )
        x.childLanes = en(x.childLanes, r), c = x.alternate, c !== null ? c.childLanes = en(c.childLanes, r) : (x.flags & (Bn | ga)) !== _t && fA(e), g = x, x = x.return;
      if (g.tag === q) {
        var R = g.stateNode;
        return R;
      } else
        return null;
    }
    var fk = 0, hk = 1, xm = 2, _b = 3, bm = !1, Pb, wm;
    Pb = !1, wm = null;
    function Nb(e) {
      var r = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Pe
        },
        effects: null
      };
      e.updateQueue = r;
    }
    function pk(e, r) {
      var c = r.updateQueue, g = e.updateQueue;
      if (c === g) {
        var x = {
          baseState: g.baseState,
          firstBaseUpdate: g.firstBaseUpdate,
          lastBaseUpdate: g.lastBaseUpdate,
          shared: g.shared,
          effects: g.effects
        };
        r.updateQueue = x;
      }
    }
    function hl(e, r) {
      var c = {
        eventTime: e,
        lane: r,
        tag: fk,
        payload: null,
        callback: null,
        next: null
      };
      return c;
    }
    function vu(e, r, c) {
      var g = e.updateQueue;
      if (g === null)
        return null;
      var x = g.shared;
      if (wm === x && !Pb && (T("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), Pb = !0), f2()) {
        var R = x.pending;
        return R === null ? r.next = r : (r.next = R.next, R.next = r), x.pending = r, fD(e, c);
      } else
        return dD(e, x, r, c);
    }
    function Sm(e, r, c) {
      var g = r.updateQueue;
      if (g !== null) {
        var x = g.shared;
        if (Mh(c)) {
          var R = x.lanes;
          R = Oh(R, e.pendingLanes);
          var _ = en(R, c);
          x.lanes = _, Zl(e, _);
        }
      }
    }
    function zb(e, r) {
      var c = e.updateQueue, g = e.alternate;
      if (g !== null) {
        var x = g.updateQueue;
        if (c === x) {
          var R = null, _ = null, Y = c.firstBaseUpdate;
          if (Y !== null) {
            var W = Y;
            do {
              var J = {
                eventTime: W.eventTime,
                lane: W.lane,
                tag: W.tag,
                payload: W.payload,
                callback: W.callback,
                next: null
              };
              _ === null ? R = _ = J : (_.next = J, _ = J), W = W.next;
            } while (W !== null);
            _ === null ? R = _ = r : (_.next = r, _ = r);
          } else
            R = _ = r;
          c = {
            baseState: x.baseState,
            firstBaseUpdate: R,
            lastBaseUpdate: _,
            shared: x.shared,
            effects: x.effects
          }, e.updateQueue = c;
          return;
        }
      }
      var ne = c.lastBaseUpdate;
      ne === null ? c.firstBaseUpdate = r : ne.next = r, c.lastBaseUpdate = r;
    }
    function hD(e, r, c, g, x, R) {
      switch (c.tag) {
        case hk: {
          var _ = c.payload;
          if (typeof _ == "function") {
            lk();
            var Y = _.call(R, g, x);
            {
              if (e.mode & Kn) {
                Sr(!0);
                try {
                  _.call(R, g, x);
                } finally {
                  Sr(!1);
                }
              }
              uk();
            }
            return Y;
          }
          return _;
        }
        case _b:
          e.flags = e.flags & ~_r | Xt;
        case fk: {
          var W = c.payload, J;
          if (typeof W == "function") {
            lk(), J = W.call(R, g, x);
            {
              if (e.mode & Kn) {
                Sr(!0);
                try {
                  W.call(R, g, x);
                } finally {
                  Sr(!1);
                }
              }
              uk();
            }
          } else
            J = W;
          return J == null ? g : p({}, g, J);
        }
        case xm:
          return bm = !0, g;
      }
      return g;
    }
    function km(e, r, c, g) {
      var x = e.updateQueue;
      bm = !1, wm = x.shared;
      var R = x.firstBaseUpdate, _ = x.lastBaseUpdate, Y = x.shared.pending;
      if (Y !== null) {
        x.shared.pending = null;
        var W = Y, J = W.next;
        W.next = null, _ === null ? R = J : _.next = J, _ = W;
        var ne = e.alternate;
        if (ne !== null) {
          var ge = ne.updateQueue, he = ge.lastBaseUpdate;
          he !== _ && (he === null ? ge.firstBaseUpdate = J : he.next = J, ge.lastBaseUpdate = W);
        }
      }
      if (R !== null) {
        var Ce = x.baseState, Ae = Pe, De = null, ct = null, Pt = null, Tt = R;
        do {
          var hn = Tt.lane, on = Tt.eventTime;
          if (Qo(g, hn)) {
            if (Pt !== null) {
              var Oe = {
                eventTime: on,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: dn,
                tag: Tt.tag,
                payload: Tt.payload,
                callback: Tt.callback,
                next: null
              };
              Pt = Pt.next = Oe;
            }
            Ce = hD(e, x, Tt, Ce, r, c);
            var be = Tt.callback;
            if (be !== null && // If the update was already committed, we should not queue its
            // callback again.
            Tt.lane !== dn) {
              e.flags |= Ga;
              var Xe = x.effects;
              Xe === null ? x.effects = [Tt] : Xe.push(Tt);
            }
          } else {
            var xe = {
              eventTime: on,
              lane: hn,
              tag: Tt.tag,
              payload: Tt.payload,
              callback: Tt.callback,
              next: null
            };
            Pt === null ? (ct = Pt = xe, De = Ce) : Pt = Pt.next = xe, Ae = en(Ae, hn);
          }
          if (Tt = Tt.next, Tt === null) {
            if (Y = x.shared.pending, Y === null)
              break;
            var dt = Y, at = dt.next;
            dt.next = null, Tt = at, x.lastBaseUpdate = dt, x.shared.pending = null;
          }
        } while (!0);
        Pt === null && (De = Ce), x.baseState = De, x.firstBaseUpdate = ct, x.lastBaseUpdate = Pt;
        var Wt = x.shared.interleaved;
        if (Wt !== null) {
          var $t = Wt;
          do
            Ae = en(Ae, $t.lane), $t = $t.next;
          while ($t !== Wt);
        } else
          R === null && (x.shared.lanes = Pe);
        Vp(Ae), e.lanes = Ae, e.memoizedState = Ce;
      }
      wm = null;
    }
    function pD(e, r) {
      if (typeof e != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + e));
      e.call(r);
    }
    function gk() {
      bm = !1;
    }
    function Cm() {
      return bm;
    }
    function vk(e, r, c) {
      var g = r.effects;
      if (r.effects = null, g !== null)
        for (var x = 0; x < g.length; x++) {
          var R = g[x], _ = R.callback;
          _ !== null && (R.callback = null, pD(_, c));
        }
    }
    var Ib = {}, mk = new s.Component().refs, Fb, Yb, Hb, jb, Ub, yk, Am, Bb, Wb, Xb;
    {
      Fb = /* @__PURE__ */ new Set(), Yb = /* @__PURE__ */ new Set(), Hb = /* @__PURE__ */ new Set(), jb = /* @__PURE__ */ new Set(), Bb = /* @__PURE__ */ new Set(), Ub = /* @__PURE__ */ new Set(), Wb = /* @__PURE__ */ new Set(), Xb = /* @__PURE__ */ new Set();
      var xk = /* @__PURE__ */ new Set();
      Am = function(e, r) {
        if (!(e === null || typeof e == "function")) {
          var c = r + "_" + e;
          xk.has(c) || (xk.add(c), T("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", r, e));
        }
      }, yk = function(e, r) {
        if (r === void 0) {
          var c = mt(e) || "Component";
          Ub.has(c) || (Ub.add(c), T("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", c));
        }
      }, Object.defineProperty(Ib, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(Ib);
    }
    function Vb(e, r, c, g) {
      var x = e.memoizedState, R = c(g, x);
      {
        if (e.mode & Kn) {
          Sr(!0);
          try {
            R = c(g, x);
          } finally {
            Sr(!1);
          }
        }
        yk(r, R);
      }
      var _ = R == null ? x : p({}, x, R);
      if (e.memoizedState = _, e.lanes === Pe) {
        var Y = e.updateQueue;
        Y.baseState = _;
      }
    }
    var Gb = {
      isMounted: ta,
      enqueueSetState: function(e, r, c) {
        var g = ha(e), x = oa(), R = Cu(g), _ = hl(x, R);
        _.payload = r, c != null && (Am(c, "setState"), _.callback = c);
        var Y = vu(g, _, R);
        Y !== null && (Kr(Y, g, R, x), Sm(Y, g, R)), lo(g, R);
      },
      enqueueReplaceState: function(e, r, c) {
        var g = ha(e), x = oa(), R = Cu(g), _ = hl(x, R);
        _.tag = hk, _.payload = r, c != null && (Am(c, "replaceState"), _.callback = c);
        var Y = vu(g, _, R);
        Y !== null && (Kr(Y, g, R, x), Sm(Y, g, R)), lo(g, R);
      },
      enqueueForceUpdate: function(e, r) {
        var c = ha(e), g = oa(), x = Cu(c), R = hl(g, x);
        R.tag = xm, r != null && (Am(r, "forceUpdate"), R.callback = r);
        var _ = vu(c, R, x);
        _ !== null && (Kr(_, c, x, g), Sm(_, c, x)), Th(c, x);
      }
    };
    function bk(e, r, c, g, x, R, _) {
      var Y = e.stateNode;
      if (typeof Y.shouldComponentUpdate == "function") {
        var W = Y.shouldComponentUpdate(g, R, _);
        {
          if (e.mode & Kn) {
            Sr(!0);
            try {
              W = Y.shouldComponentUpdate(g, R, _);
            } finally {
              Sr(!1);
            }
          }
          W === void 0 && T("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", mt(r) || "Component");
        }
        return W;
      }
      return r.prototype && r.prototype.isPureReactComponent ? !Lt(c, g) || !Lt(x, R) : !0;
    }
    function gD(e, r, c) {
      var g = e.stateNode;
      {
        var x = mt(r) || "Component", R = g.render;
        R || (r.prototype && typeof r.prototype.render == "function" ? T("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", x) : T("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", x)), g.getInitialState && !g.getInitialState.isReactClassApproved && !g.state && T("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", x), g.getDefaultProps && !g.getDefaultProps.isReactClassApproved && T("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", x), g.propTypes && T("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", x), g.contextType && T("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", x), g.contextTypes && T("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", x), r.contextType && r.contextTypes && !Wb.has(r) && (Wb.add(r), T("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", x)), typeof g.componentShouldUpdate == "function" && T("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", x), r.prototype && r.prototype.isPureReactComponent && typeof g.shouldComponentUpdate < "u" && T("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", mt(r) || "A pure component"), typeof g.componentDidUnmount == "function" && T("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", x), typeof g.componentDidReceiveProps == "function" && T("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", x), typeof g.componentWillRecieveProps == "function" && T("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", x), typeof g.UNSAFE_componentWillRecieveProps == "function" && T("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", x);
        var _ = g.props !== c;
        g.props !== void 0 && _ && T("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", x, x), g.defaultProps && T("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", x, x), typeof g.getSnapshotBeforeUpdate == "function" && typeof g.componentDidUpdate != "function" && !Hb.has(r) && (Hb.add(r), T("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", mt(r))), typeof g.getDerivedStateFromProps == "function" && T("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", x), typeof g.getDerivedStateFromError == "function" && T("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", x), typeof r.getSnapshotBeforeUpdate == "function" && T("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", x);
        var Y = g.state;
        Y && (typeof Y != "object" || Dr(Y)) && T("%s.state: must be set to an object or null", x), typeof g.getChildContext == "function" && typeof r.childContextTypes != "object" && T("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", x);
      }
    }
    function wk(e, r) {
      r.updater = Gb, e.stateNode = r, Hl(r, e), r._reactInternalInstance = Ib;
    }
    function Sk(e, r, c) {
      var g = !1, x = ja, R = ja, _ = r.contextType;
      if ("contextType" in r) {
        var Y = (
          // Allow null for conditional declaration
          _ === null || _ !== void 0 && _.$$typeof === et && _._context === void 0
        );
        if (!Y && !Xb.has(r)) {
          Xb.add(r);
          var W = "";
          _ === void 0 ? W = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof _ != "object" ? W = " However, it is set to a " + typeof _ + "." : _.$$typeof === Ye ? W = " Did you accidentally pass the Context.Provider instead?" : _._context !== void 0 ? W = " Did you accidentally pass the Context.Consumer instead?" : W = " However, it is set to an object with keys {" + Object.keys(_).join(", ") + "}.", T("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", mt(r) || "Component", W);
        }
      }
      if (typeof _ == "object" && _ !== null)
        R = Fr(_);
      else {
        x = of(e, r, !0);
        var J = r.contextTypes;
        g = J != null, R = g ? lf(e, x) : ja;
      }
      var ne = new r(c, R);
      if (e.mode & Kn) {
        Sr(!0);
        try {
          ne = new r(c, R);
        } finally {
          Sr(!1);
        }
      }
      var ge = e.memoizedState = ne.state !== null && ne.state !== void 0 ? ne.state : null;
      wk(e, ne);
      {
        if (typeof r.getDerivedStateFromProps == "function" && ge === null) {
          var he = mt(r) || "Component";
          Yb.has(he) || (Yb.add(he), T("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", he, ne.state === null ? "null" : "undefined", he));
        }
        if (typeof r.getDerivedStateFromProps == "function" || typeof ne.getSnapshotBeforeUpdate == "function") {
          var Ce = null, Ae = null, De = null;
          if (typeof ne.componentWillMount == "function" && ne.componentWillMount.__suppressDeprecationWarning !== !0 ? Ce = "componentWillMount" : typeof ne.UNSAFE_componentWillMount == "function" && (Ce = "UNSAFE_componentWillMount"), typeof ne.componentWillReceiveProps == "function" && ne.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Ae = "componentWillReceiveProps" : typeof ne.UNSAFE_componentWillReceiveProps == "function" && (Ae = "UNSAFE_componentWillReceiveProps"), typeof ne.componentWillUpdate == "function" && ne.componentWillUpdate.__suppressDeprecationWarning !== !0 ? De = "componentWillUpdate" : typeof ne.UNSAFE_componentWillUpdate == "function" && (De = "UNSAFE_componentWillUpdate"), Ce !== null || Ae !== null || De !== null) {
            var ct = mt(r) || "Component", Pt = typeof r.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            jb.has(ct) || (jb.add(ct), T(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, ct, Pt, Ce !== null ? `
  ` + Ce : "", Ae !== null ? `
  ` + Ae : "", De !== null ? `
  ` + De : ""));
          }
        }
      }
      return g && VS(e, x, R), ne;
    }
    function vD(e, r) {
      var c = r.state;
      typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), c !== r.state && (T("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", gt(e) || "Component"), Gb.enqueueReplaceState(r, r.state, null));
    }
    function kk(e, r, c, g) {
      var x = r.state;
      if (typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps(c, g), typeof r.UNSAFE_componentWillReceiveProps == "function" && r.UNSAFE_componentWillReceiveProps(c, g), r.state !== x) {
        {
          var R = gt(e) || "Component";
          Fb.has(R) || (Fb.add(R), T("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", R));
        }
        Gb.enqueueReplaceState(r, r.state, null);
      }
    }
    function $b(e, r, c, g) {
      gD(e, r, c);
      var x = e.stateNode;
      x.props = c, x.state = e.memoizedState, x.refs = mk, Nb(e);
      var R = r.contextType;
      if (typeof R == "object" && R !== null)
        x.context = Fr(R);
      else {
        var _ = of(e, r, !0);
        x.context = lf(e, _);
      }
      {
        if (x.state === c) {
          var Y = mt(r) || "Component";
          Bb.has(Y) || (Bb.add(Y), T("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", Y));
        }
        e.mode & Kn && Os.recordLegacyContextWarning(e, x), Os.recordUnsafeLifecycleWarnings(e, x);
      }
      x.state = e.memoizedState;
      var W = r.getDerivedStateFromProps;
      if (typeof W == "function" && (Vb(e, r, W, c), x.state = e.memoizedState), typeof r.getDerivedStateFromProps != "function" && typeof x.getSnapshotBeforeUpdate != "function" && (typeof x.UNSAFE_componentWillMount == "function" || typeof x.componentWillMount == "function") && (vD(e, x), km(e, c, x, g), x.state = e.memoizedState), typeof x.componentDidMount == "function") {
        var J = Jt;
        J |= Pi, (e.mode & ya) !== Nt && (J |= Ni), e.flags |= J;
      }
    }
    function mD(e, r, c, g) {
      var x = e.stateNode, R = e.memoizedProps;
      x.props = R;
      var _ = x.context, Y = r.contextType, W = ja;
      if (typeof Y == "object" && Y !== null)
        W = Fr(Y);
      else {
        var J = of(e, r, !0);
        W = lf(e, J);
      }
      var ne = r.getDerivedStateFromProps, ge = typeof ne == "function" || typeof x.getSnapshotBeforeUpdate == "function";
      !ge && (typeof x.UNSAFE_componentWillReceiveProps == "function" || typeof x.componentWillReceiveProps == "function") && (R !== c || _ !== W) && kk(e, x, c, W), gk();
      var he = e.memoizedState, Ce = x.state = he;
      if (km(e, c, x, g), Ce = e.memoizedState, R === c && he === Ce && !sm() && !Cm()) {
        if (typeof x.componentDidMount == "function") {
          var Ae = Jt;
          Ae |= Pi, (e.mode & ya) !== Nt && (Ae |= Ni), e.flags |= Ae;
        }
        return !1;
      }
      typeof ne == "function" && (Vb(e, r, ne, c), Ce = e.memoizedState);
      var De = Cm() || bk(e, r, R, c, he, Ce, W);
      if (De) {
        if (!ge && (typeof x.UNSAFE_componentWillMount == "function" || typeof x.componentWillMount == "function") && (typeof x.componentWillMount == "function" && x.componentWillMount(), typeof x.UNSAFE_componentWillMount == "function" && x.UNSAFE_componentWillMount()), typeof x.componentDidMount == "function") {
          var ct = Jt;
          ct |= Pi, (e.mode & ya) !== Nt && (ct |= Ni), e.flags |= ct;
        }
      } else {
        if (typeof x.componentDidMount == "function") {
          var Pt = Jt;
          Pt |= Pi, (e.mode & ya) !== Nt && (Pt |= Ni), e.flags |= Pt;
        }
        e.memoizedProps = c, e.memoizedState = Ce;
      }
      return x.props = c, x.state = Ce, x.context = W, De;
    }
    function yD(e, r, c, g, x) {
      var R = r.stateNode;
      pk(e, r);
      var _ = r.memoizedProps, Y = r.type === r.elementType ? _ : _s(r.type, _);
      R.props = Y;
      var W = r.pendingProps, J = R.context, ne = c.contextType, ge = ja;
      if (typeof ne == "object" && ne !== null)
        ge = Fr(ne);
      else {
        var he = of(r, c, !0);
        ge = lf(r, he);
      }
      var Ce = c.getDerivedStateFromProps, Ae = typeof Ce == "function" || typeof R.getSnapshotBeforeUpdate == "function";
      !Ae && (typeof R.UNSAFE_componentWillReceiveProps == "function" || typeof R.componentWillReceiveProps == "function") && (_ !== W || J !== ge) && kk(r, R, g, ge), gk();
      var De = r.memoizedState, ct = R.state = De;
      if (km(r, g, R, x), ct = r.memoizedState, _ === W && De === ct && !sm() && !Cm() && !pt)
        return typeof R.componentDidUpdate == "function" && (_ !== e.memoizedProps || De !== e.memoizedState) && (r.flags |= Jt), typeof R.getSnapshotBeforeUpdate == "function" && (_ !== e.memoizedProps || De !== e.memoizedState) && (r.flags |= pa), !1;
      typeof Ce == "function" && (Vb(r, c, Ce, g), ct = r.memoizedState);
      var Pt = Cm() || bk(r, c, Y, g, De, ct, ge) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      pt;
      return Pt ? (!Ae && (typeof R.UNSAFE_componentWillUpdate == "function" || typeof R.componentWillUpdate == "function") && (typeof R.componentWillUpdate == "function" && R.componentWillUpdate(g, ct, ge), typeof R.UNSAFE_componentWillUpdate == "function" && R.UNSAFE_componentWillUpdate(g, ct, ge)), typeof R.componentDidUpdate == "function" && (r.flags |= Jt), typeof R.getSnapshotBeforeUpdate == "function" && (r.flags |= pa)) : (typeof R.componentDidUpdate == "function" && (_ !== e.memoizedProps || De !== e.memoizedState) && (r.flags |= Jt), typeof R.getSnapshotBeforeUpdate == "function" && (_ !== e.memoizedProps || De !== e.memoizedState) && (r.flags |= pa), r.memoizedProps = g, r.memoizedState = ct), R.props = g, R.state = ct, R.context = ge, Pt;
    }
    var qb, Zb, Qb, Kb, Jb, Ck = function(e, r) {
    };
    qb = !1, Zb = !1, Qb = {}, Kb = {}, Jb = {}, Ck = function(e, r) {
      if (!(e === null || typeof e != "object") && !(!e._store || e._store.validated || e.key != null)) {
        if (typeof e._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        e._store.validated = !0;
        var c = gt(r) || "Component";
        Kb[c] || (Kb[c] = !0, T('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function wp(e, r, c) {
      var g = c.ref;
      if (g !== null && typeof g != "function" && typeof g != "object") {
        if ((e.mode & Kn || At) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(c._owner && c._self && c._owner.stateNode !== c._self)) {
          var x = gt(e) || "Component";
          Qb[x] || (T('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', g), Qb[x] = !0);
        }
        if (c._owner) {
          var R = c._owner, _;
          if (R) {
            var Y = R;
            if (Y.tag !== U)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            _ = Y.stateNode;
          }
          if (!_)
            throw new Error("Missing owner for string ref " + g + ". This error is likely caused by a bug in React. Please file an issue.");
          var W = _;
          Oa(g, "ref");
          var J = "" + g;
          if (r !== null && r.ref !== null && typeof r.ref == "function" && r.ref._stringRef === J)
            return r.ref;
          var ne = function(ge) {
            var he = W.refs;
            he === mk && (he = W.refs = {}), ge === null ? delete he[J] : he[J] = ge;
          };
          return ne._stringRef = J, ne;
        } else {
          if (typeof g != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!c._owner)
            throw new Error("Element ref was specified as a string (" + g + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return g;
    }
    function Tm(e, r) {
      var c = Object.prototype.toString.call(r);
      throw new Error("Objects are not valid as a React child (found: " + (c === "[object Object]" ? "object with keys {" + Object.keys(r).join(", ") + "}" : c) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Em(e) {
      {
        var r = gt(e) || "Component";
        if (Jb[r])
          return;
        Jb[r] = !0, T("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function Ak(e) {
      var r = e._payload, c = e._init;
      return c(r);
    }
    function Tk(e) {
      function r(xe, Oe) {
        if (e) {
          var be = xe.deletions;
          be === null ? (xe.deletions = [Oe], xe.flags |= Sn) : be.push(Oe);
        }
      }
      function c(xe, Oe) {
        if (!e)
          return null;
        for (var be = Oe; be !== null; )
          r(xe, be), be = be.sibling;
        return null;
      }
      function g(xe, Oe) {
        for (var be = /* @__PURE__ */ new Map(), Xe = Oe; Xe !== null; )
          Xe.key !== null ? be.set(Xe.key, Xe) : be.set(Xe.index, Xe), Xe = Xe.sibling;
        return be;
      }
      function x(xe, Oe) {
        var be = Nc(xe, Oe);
        return be.index = 0, be.sibling = null, be;
      }
      function R(xe, Oe, be) {
        if (xe.index = be, !e)
          return xe.flags |= ph, Oe;
        var Xe = xe.alternate;
        if (Xe !== null) {
          var dt = Xe.index;
          return dt < Oe ? (xe.flags |= Bn, Oe) : dt;
        } else
          return xe.flags |= Bn, Oe;
      }
      function _(xe) {
        return e && xe.alternate === null && (xe.flags |= Bn), xe;
      }
      function Y(xe, Oe, be, Xe) {
        if (Oe === null || Oe.tag !== ae) {
          var dt = Tw(be, xe.mode, Xe);
          return dt.return = xe, dt;
        } else {
          var at = x(Oe, be);
          return at.return = xe, at;
        }
      }
      function W(xe, Oe, be, Xe) {
        var dt = be.type;
        if (dt === xi)
          return ne(xe, Oe, be.props.children, Xe, be.key);
        if (Oe !== null && (Oe.elementType === dt || // Keep this check inline so it only runs on the false path:
        vA(Oe, be) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof dt == "object" && dt !== null && dt.$$typeof === Ot && Ak(dt) === Oe.type)) {
          var at = x(Oe, be.props);
          return at.ref = wp(xe, Oe, be), at.return = xe, at._debugSource = be._source, at._debugOwner = be._owner, at;
        }
        var Wt = Aw(be, xe.mode, Xe);
        return Wt.ref = wp(xe, Oe, be), Wt.return = xe, Wt;
      }
      function J(xe, Oe, be, Xe) {
        if (Oe === null || Oe.tag !== te || Oe.stateNode.containerInfo !== be.containerInfo || Oe.stateNode.implementation !== be.implementation) {
          var dt = Ew(be, xe.mode, Xe);
          return dt.return = xe, dt;
        } else {
          var at = x(Oe, be.children || []);
          return at.return = xe, at;
        }
      }
      function ne(xe, Oe, be, Xe, dt) {
        if (Oe === null || Oe.tag !== ue) {
          var at = Tu(be, xe.mode, Xe, dt);
          return at.return = xe, at;
        } else {
          var Wt = x(Oe, be);
          return Wt.return = xe, Wt;
        }
      }
      function ge(xe, Oe, be) {
        if (typeof Oe == "string" && Oe !== "" || typeof Oe == "number") {
          var Xe = Tw("" + Oe, xe.mode, be);
          return Xe.return = xe, Xe;
        }
        if (typeof Oe == "object" && Oe !== null) {
          switch (Oe.$$typeof) {
            case Pa: {
              var dt = Aw(Oe, xe.mode, be);
              return dt.ref = wp(xe, null, Oe), dt.return = xe, dt;
            }
            case Hr: {
              var at = Ew(Oe, xe.mode, be);
              return at.return = xe, at;
            }
            case Ot: {
              var Wt = Oe._payload, $t = Oe._init;
              return ge(xe, $t(Wt), be);
            }
          }
          if (Dr(Oe) || f(Oe)) {
            var _n = Tu(Oe, xe.mode, be, null);
            return _n.return = xe, _n;
          }
          Tm(xe, Oe);
        }
        return typeof Oe == "function" && Em(xe), null;
      }
      function he(xe, Oe, be, Xe) {
        var dt = Oe !== null ? Oe.key : null;
        if (typeof be == "string" && be !== "" || typeof be == "number")
          return dt !== null ? null : Y(xe, Oe, "" + be, Xe);
        if (typeof be == "object" && be !== null) {
          switch (be.$$typeof) {
            case Pa:
              return be.key === dt ? W(xe, Oe, be, Xe) : null;
            case Hr:
              return be.key === dt ? J(xe, Oe, be, Xe) : null;
            case Ot: {
              var at = be._payload, Wt = be._init;
              return he(xe, Oe, Wt(at), Xe);
            }
          }
          if (Dr(be) || f(be))
            return dt !== null ? null : ne(xe, Oe, be, Xe, null);
          Tm(xe, be);
        }
        return typeof be == "function" && Em(xe), null;
      }
      function Ce(xe, Oe, be, Xe, dt) {
        if (typeof Xe == "string" && Xe !== "" || typeof Xe == "number") {
          var at = xe.get(be) || null;
          return Y(Oe, at, "" + Xe, dt);
        }
        if (typeof Xe == "object" && Xe !== null) {
          switch (Xe.$$typeof) {
            case Pa: {
              var Wt = xe.get(Xe.key === null ? be : Xe.key) || null;
              return W(Oe, Wt, Xe, dt);
            }
            case Hr: {
              var $t = xe.get(Xe.key === null ? be : Xe.key) || null;
              return J(Oe, $t, Xe, dt);
            }
            case Ot:
              var _n = Xe._payload, mn = Xe._init;
              return Ce(xe, Oe, be, mn(_n), dt);
          }
          if (Dr(Xe) || f(Xe)) {
            var Er = xe.get(be) || null;
            return ne(Oe, Er, Xe, dt, null);
          }
          Tm(Oe, Xe);
        }
        return typeof Xe == "function" && Em(Oe), null;
      }
      function Ae(xe, Oe, be) {
        {
          if (typeof xe != "object" || xe === null)
            return Oe;
          switch (xe.$$typeof) {
            case Pa:
            case Hr:
              Ck(xe, be);
              var Xe = xe.key;
              if (typeof Xe != "string")
                break;
              if (Oe === null) {
                Oe = /* @__PURE__ */ new Set(), Oe.add(Xe);
                break;
              }
              if (!Oe.has(Xe)) {
                Oe.add(Xe);
                break;
              }
              T("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", Xe);
              break;
            case Ot:
              var dt = xe._payload, at = xe._init;
              Ae(at(dt), Oe, be);
              break;
          }
        }
        return Oe;
      }
      function De(xe, Oe, be, Xe) {
        for (var dt = null, at = 0; at < be.length; at++) {
          var Wt = be[at];
          dt = Ae(Wt, dt, xe);
        }
        for (var $t = null, _n = null, mn = Oe, Er = 0, yn = 0, br = null; mn !== null && yn < be.length; yn++) {
          mn.index > yn ? (br = mn, mn = null) : br = mn.sibling;
          var Wi = he(xe, mn, be[yn], Xe);
          if (Wi === null) {
            mn === null && (mn = br);
            break;
          }
          e && mn && Wi.alternate === null && r(xe, mn), Er = R(Wi, Er, yn), _n === null ? $t = Wi : _n.sibling = Wi, _n = Wi, mn = br;
        }
        if (yn === be.length) {
          if (c(xe, mn), Si()) {
            var Li = yn;
            Sc(xe, Li);
          }
          return $t;
        }
        if (mn === null) {
          for (; yn < be.length; yn++) {
            var Ba = ge(xe, be[yn], Xe);
            Ba !== null && (Er = R(Ba, Er, yn), _n === null ? $t = Ba : _n.sibling = Ba, _n = Ba);
          }
          if (Si()) {
            var la = yn;
            Sc(xe, la);
          }
          return $t;
        }
        for (var ua = g(xe, mn); yn < be.length; yn++) {
          var Xi = Ce(ua, xe, yn, be[yn], Xe);
          Xi !== null && (e && Xi.alternate !== null && ua.delete(Xi.key === null ? yn : Xi.key), Er = R(Xi, Er, yn), _n === null ? $t = Xi : _n.sibling = Xi, _n = Xi);
        }
        if (e && ua.forEach(function(Mf) {
          return r(xe, Mf);
        }), Si()) {
          var xl = yn;
          Sc(xe, xl);
        }
        return $t;
      }
      function ct(xe, Oe, be, Xe) {
        var dt = f(be);
        if (typeof dt != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          be[Symbol.toStringTag] === "Generator" && (Zb || T("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Zb = !0), be.entries === dt && (qb || T("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), qb = !0);
          var at = dt.call(be);
          if (at)
            for (var Wt = null, $t = at.next(); !$t.done; $t = at.next()) {
              var _n = $t.value;
              Wt = Ae(_n, Wt, xe);
            }
        }
        var mn = dt.call(be);
        if (mn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Er = null, yn = null, br = Oe, Wi = 0, Li = 0, Ba = null, la = mn.next(); br !== null && !la.done; Li++, la = mn.next()) {
          br.index > Li ? (Ba = br, br = null) : Ba = br.sibling;
          var ua = he(xe, br, la.value, Xe);
          if (ua === null) {
            br === null && (br = Ba);
            break;
          }
          e && br && ua.alternate === null && r(xe, br), Wi = R(ua, Wi, Li), yn === null ? Er = ua : yn.sibling = ua, yn = ua, br = Ba;
        }
        if (la.done) {
          if (c(xe, br), Si()) {
            var Xi = Li;
            Sc(xe, Xi);
          }
          return Er;
        }
        if (br === null) {
          for (; !la.done; Li++, la = mn.next()) {
            var xl = ge(xe, la.value, Xe);
            xl !== null && (Wi = R(xl, Wi, Li), yn === null ? Er = xl : yn.sibling = xl, yn = xl);
          }
          if (Si()) {
            var Mf = Li;
            Sc(xe, Mf);
          }
          return Er;
        }
        for (var Qp = g(xe, br); !la.done; Li++, la = mn.next()) {
          var Eo = Ce(Qp, xe, Li, la.value, Xe);
          Eo !== null && (e && Eo.alternate !== null && Qp.delete(Eo.key === null ? Li : Eo.key), Wi = R(Eo, Wi, Li), yn === null ? Er = Eo : yn.sibling = Eo, yn = Eo);
        }
        if (e && Qp.forEach(function(O_) {
          return r(xe, O_);
        }), Si()) {
          var D_ = Li;
          Sc(xe, D_);
        }
        return Er;
      }
      function Pt(xe, Oe, be, Xe) {
        if (Oe !== null && Oe.tag === ae) {
          c(xe, Oe.sibling);
          var dt = x(Oe, be);
          return dt.return = xe, dt;
        }
        c(xe, Oe);
        var at = Tw(be, xe.mode, Xe);
        return at.return = xe, at;
      }
      function Tt(xe, Oe, be, Xe) {
        for (var dt = be.key, at = Oe; at !== null; ) {
          if (at.key === dt) {
            var Wt = be.type;
            if (Wt === xi) {
              if (at.tag === ue) {
                c(xe, at.sibling);
                var $t = x(at, be.props.children);
                return $t.return = xe, $t._debugSource = be._source, $t._debugOwner = be._owner, $t;
              }
            } else if (at.elementType === Wt || // Keep this check inline so it only runs on the false path:
            vA(at, be) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Wt == "object" && Wt !== null && Wt.$$typeof === Ot && Ak(Wt) === at.type) {
              c(xe, at.sibling);
              var _n = x(at, be.props);
              return _n.ref = wp(xe, at, be), _n.return = xe, _n._debugSource = be._source, _n._debugOwner = be._owner, _n;
            }
            c(xe, at);
            break;
          } else
            r(xe, at);
          at = at.sibling;
        }
        if (be.type === xi) {
          var mn = Tu(be.props.children, xe.mode, Xe, be.key);
          return mn.return = xe, mn;
        } else {
          var Er = Aw(be, xe.mode, Xe);
          return Er.ref = wp(xe, Oe, be), Er.return = xe, Er;
        }
      }
      function hn(xe, Oe, be, Xe) {
        for (var dt = be.key, at = Oe; at !== null; ) {
          if (at.key === dt)
            if (at.tag === te && at.stateNode.containerInfo === be.containerInfo && at.stateNode.implementation === be.implementation) {
              c(xe, at.sibling);
              var Wt = x(at, be.children || []);
              return Wt.return = xe, Wt;
            } else {
              c(xe, at);
              break;
            }
          else
            r(xe, at);
          at = at.sibling;
        }
        var $t = Ew(be, xe.mode, Xe);
        return $t.return = xe, $t;
      }
      function on(xe, Oe, be, Xe) {
        var dt = typeof be == "object" && be !== null && be.type === xi && be.key === null;
        if (dt && (be = be.props.children), typeof be == "object" && be !== null) {
          switch (be.$$typeof) {
            case Pa:
              return _(Tt(xe, Oe, be, Xe));
            case Hr:
              return _(hn(xe, Oe, be, Xe));
            case Ot:
              var at = be._payload, Wt = be._init;
              return on(xe, Oe, Wt(at), Xe);
          }
          if (Dr(be))
            return De(xe, Oe, be, Xe);
          if (f(be))
            return ct(xe, Oe, be, Xe);
          Tm(xe, be);
        }
        return typeof be == "string" && be !== "" || typeof be == "number" ? _(Pt(xe, Oe, "" + be, Xe)) : (typeof be == "function" && Em(xe), c(xe, Oe));
      }
      return on;
    }
    var pf = Tk(!0), Ek = Tk(!1);
    function xD(e, r) {
      if (e !== null && r.child !== e.child)
        throw new Error("Resuming work not yet implemented.");
      if (r.child !== null) {
        var c = r.child, g = Nc(c, c.pendingProps);
        for (r.child = g, g.return = r; c.sibling !== null; )
          c = c.sibling, g = g.sibling = Nc(c, c.pendingProps), g.return = r;
        g.sibling = null;
      }
    }
    function bD(e, r) {
      for (var c = e.child; c !== null; )
        q2(c, r), c = c.sibling;
    }
    var Sp = {}, mu = fu(Sp), kp = fu(Sp), Rm = fu(Sp);
    function Lm(e) {
      if (e === Sp)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return e;
    }
    function Rk() {
      var e = Lm(Rm.current);
      return e;
    }
    function e0(e, r) {
      Ui(Rm, r, e), Ui(kp, e, e), Ui(mu, Sp, e);
      var c = PL(r);
      ji(mu, e), Ui(mu, c, e);
    }
    function gf(e) {
      ji(mu, e), ji(kp, e), ji(Rm, e);
    }
    function t0() {
      var e = Lm(mu.current);
      return e;
    }
    function Lk(e) {
      Lm(Rm.current);
      var r = Lm(mu.current), c = NL(r, e.type);
      r !== c && (Ui(kp, e, e), Ui(mu, c, e));
    }
    function n0(e) {
      kp.current === e && (ji(mu, e), ji(kp, e));
    }
    var wD = 0, Mk = 1, Dk = 1, Cp = 2, Ps = fu(wD);
    function r0(e, r) {
      return (e & r) !== 0;
    }
    function vf(e) {
      return e & Mk;
    }
    function i0(e, r) {
      return e & Mk | r;
    }
    function SD(e, r) {
      return e | r;
    }
    function yu(e, r) {
      Ui(Ps, r, e);
    }
    function mf(e) {
      ji(Ps, e);
    }
    function kD(e, r) {
      var c = e.memoizedState;
      return c !== null ? c.dehydrated !== null : (e.memoizedProps, !0);
    }
    function Mm(e) {
      for (var r = e; r !== null; ) {
        if (r.tag === re) {
          var c = r.memoizedState;
          if (c !== null) {
            var g = c.dehydrated;
            if (g === null || jS(g) || cb(g))
              return r;
          }
        } else if (r.tag === ft && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        r.memoizedProps.revealOrder !== void 0) {
          var x = (r.flags & Xt) !== _t;
          if (x)
            return r;
        } else if (r.child !== null) {
          r.child.return = r, r = r.child;
          continue;
        }
        if (r === e)
          return null;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === e)
            return null;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
      return null;
    }
    var Ta = (
      /*   */
      0
    ), Xr = (
      /* */
      1
    ), bo = (
      /*  */
      2
    ), Vr = (
      /*    */
      4
    ), ki = (
      /*   */
      8
    ), a0 = [];
    function s0() {
      for (var e = 0; e < a0.length; e++) {
        var r = a0[e];
        r._workInProgressVersionPrimary = null;
      }
      a0.length = 0;
    }
    function CD(e, r) {
      var c = r._getVersion, g = c(r._source);
      e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [r, g] : e.mutableSourceEagerHydrationData.push(r, g);
    }
    var ut = h.ReactCurrentDispatcher, Ap = h.ReactCurrentBatchConfig, o0, yf;
    o0 = /* @__PURE__ */ new Set();
    var Rc = Pe, On = null, Gr = null, $r = null, Dm = !1, Tp = !1, Ep = 0, AD = 0, TD = 25, ze = null, ns = null, xu = -1, l0 = !1;
    function Tn() {
      {
        var e = ze;
        ns === null ? ns = [e] : ns.push(e);
      }
    }
    function nt() {
      {
        var e = ze;
        ns !== null && (xu++, ns[xu] !== e && ED(e));
      }
    }
    function xf(e) {
      e != null && !Dr(e) && T("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", ze, typeof e);
    }
    function ED(e) {
      {
        var r = gt(On);
        if (!o0.has(r) && (o0.add(r), ns !== null)) {
          for (var c = "", g = 30, x = 0; x <= xu; x++) {
            for (var R = ns[x], _ = x === xu ? e : R, Y = x + 1 + ". " + R; Y.length < g; )
              Y += " ";
            Y += _ + `
`, c += Y;
          }
          T(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, r, c);
        }
      }
    }
    function Bi() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function u0(e, r) {
      if (l0)
        return !1;
      if (r === null)
        return T("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", ze), !1;
      e.length !== r.length && T(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, ze, "[" + r.join(", ") + "]", "[" + e.join(", ") + "]");
      for (var c = 0; c < r.length && c < e.length; c++)
        if (!xt(e[c], r[c]))
          return !1;
      return !0;
    }
    function bf(e, r, c, g, x, R) {
      Rc = R, On = r, ns = e !== null ? e._debugHookTypes : null, xu = -1, l0 = e !== null && e.type !== r.type, r.memoizedState = null, r.updateQueue = null, r.lanes = Pe, e !== null && e.memoizedState !== null ? ut.current = Jk : ns !== null ? ut.current = Kk : ut.current = Qk;
      var _ = c(g, x);
      if (Tp) {
        var Y = 0;
        do {
          if (Tp = !1, Ep = 0, Y >= TD)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          Y += 1, l0 = !1, Gr = null, $r = null, r.updateQueue = null, xu = -1, ut.current = eC, _ = c(g, x);
        } while (Tp);
      }
      ut.current = Wm, r._debugHookTypes = ns;
      var W = Gr !== null && Gr.next !== null;
      if (Rc = Pe, On = null, Gr = null, $r = null, ze = null, ns = null, xu = -1, e !== null && (e.flags & Ur) !== (r.flags & Ur) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (e.mode & nn) !== Nt && T("Internal React error: Expected static flag was missing. Please notify the React team."), Dm = !1, W)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return _;
    }
    function wf() {
      var e = Ep !== 0;
      return Ep = 0, e;
    }
    function Ok(e, r, c) {
      r.updateQueue = e.updateQueue, (r.mode & ya) !== Nt ? r.flags &= ~(jo | Ni | qn | Jt) : r.flags &= ~(qn | Jt), e.lanes = ql(e.lanes, c);
    }
    function _k() {
      if (ut.current = Wm, Dm) {
        for (var e = On.memoizedState; e !== null; ) {
          var r = e.queue;
          r !== null && (r.pending = null), e = e.next;
        }
        Dm = !1;
      }
      Rc = Pe, On = null, Gr = null, $r = null, ns = null, xu = -1, ze = null, Vk = !1, Tp = !1, Ep = 0;
    }
    function wo() {
      var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return $r === null ? On.memoizedState = $r = e : $r = $r.next = e, $r;
    }
    function rs() {
      var e;
      if (Gr === null) {
        var r = On.alternate;
        r !== null ? e = r.memoizedState : e = null;
      } else
        e = Gr.next;
      var c;
      if ($r === null ? c = On.memoizedState : c = $r.next, c !== null)
        $r = c, c = $r.next, Gr = e;
      else {
        if (e === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Gr = e;
        var g = {
          memoizedState: Gr.memoizedState,
          baseState: Gr.baseState,
          baseQueue: Gr.baseQueue,
          queue: Gr.queue,
          next: null
        };
        $r === null ? On.memoizedState = $r = g : $r = $r.next = g;
      }
      return $r;
    }
    function Pk() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function c0(e, r) {
      return typeof r == "function" ? r(e) : r;
    }
    function d0(e, r, c) {
      var g = wo(), x;
      c !== void 0 ? x = c(r) : x = r, g.memoizedState = g.baseState = x;
      var R = {
        pending: null,
        interleaved: null,
        lanes: Pe,
        dispatch: null,
        lastRenderedReducer: e,
        lastRenderedState: x
      };
      g.queue = R;
      var _ = R.dispatch = DD.bind(null, On, R);
      return [g.memoizedState, _];
    }
    function f0(e, r, c) {
      var g = rs(), x = g.queue;
      if (x === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      x.lastRenderedReducer = e;
      var R = Gr, _ = R.baseQueue, Y = x.pending;
      if (Y !== null) {
        if (_ !== null) {
          var W = _.next, J = Y.next;
          _.next = J, Y.next = W;
        }
        R.baseQueue !== _ && T("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), R.baseQueue = _ = Y, x.pending = null;
      }
      if (_ !== null) {
        var ne = _.next, ge = R.baseState, he = null, Ce = null, Ae = null, De = ne;
        do {
          var ct = De.lane;
          if (Qo(Rc, ct)) {
            if (Ae !== null) {
              var Tt = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: dn,
                action: De.action,
                hasEagerState: De.hasEagerState,
                eagerState: De.eagerState,
                next: null
              };
              Ae = Ae.next = Tt;
            }
            if (De.hasEagerState)
              ge = De.eagerState;
            else {
              var hn = De.action;
              ge = e(ge, hn);
            }
          } else {
            var Pt = {
              lane: ct,
              action: De.action,
              hasEagerState: De.hasEagerState,
              eagerState: De.eagerState,
              next: null
            };
            Ae === null ? (Ce = Ae = Pt, he = ge) : Ae = Ae.next = Pt, On.lanes = en(On.lanes, ct), Vp(ct);
          }
          De = De.next;
        } while (De !== null && De !== ne);
        Ae === null ? he = ge : Ae.next = Ce, xt(ge, g.memoizedState) || Pp(), g.memoizedState = ge, g.baseState = he, g.baseQueue = Ae, x.lastRenderedState = ge;
      }
      var on = x.interleaved;
      if (on !== null) {
        var xe = on;
        do {
          var Oe = xe.lane;
          On.lanes = en(On.lanes, Oe), Vp(Oe), xe = xe.next;
        } while (xe !== on);
      } else
        _ === null && (x.lanes = Pe);
      var be = x.dispatch;
      return [g.memoizedState, be];
    }
    function h0(e, r, c) {
      var g = rs(), x = g.queue;
      if (x === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      x.lastRenderedReducer = e;
      var R = x.dispatch, _ = x.pending, Y = g.memoizedState;
      if (_ !== null) {
        x.pending = null;
        var W = _.next, J = W;
        do {
          var ne = J.action;
          Y = e(Y, ne), J = J.next;
        } while (J !== W);
        xt(Y, g.memoizedState) || Pp(), g.memoizedState = Y, g.baseQueue === null && (g.baseState = Y), x.lastRenderedState = Y;
      }
      return [Y, R];
    }
    function Oj(e, r, c) {
    }
    function _j(e, r, c) {
    }
    function p0(e, r, c) {
      var g = On, x = wo(), R, _ = Si();
      if (_) {
        if (c === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        R = c(), yf || R !== c() && (T("The result of getServerSnapshot should be cached to avoid an infinite loop"), yf = !0);
      } else {
        if (R = r(), !yf) {
          var Y = r();
          xt(R, Y) || (T("The result of getSnapshot should be cached to avoid an infinite loop"), yf = !0);
        }
        var W = ly();
        if (W === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        ac(W, Rc) || Nk(g, r, R);
      }
      x.memoizedState = R;
      var J = {
        value: R,
        getSnapshot: r
      };
      return x.queue = J, zm(Ik.bind(null, g, J, e), [e]), g.flags |= qn, Rp(Xr | ki, zk.bind(null, g, J, R, r), void 0, null), R;
    }
    function Om(e, r, c) {
      var g = On, x = rs(), R = r();
      if (!yf) {
        var _ = r();
        xt(R, _) || (T("The result of getSnapshot should be cached to avoid an infinite loop"), yf = !0);
      }
      var Y = x.memoizedState, W = !xt(Y, R);
      W && (x.memoizedState = R, Pp());
      var J = x.queue;
      if (Mp(Ik.bind(null, g, J, e), [e]), J.getSnapshot !== r || W || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      $r !== null && $r.memoizedState.tag & Xr) {
        g.flags |= qn, Rp(Xr | ki, zk.bind(null, g, J, R, r), void 0, null);
        var ne = ly();
        if (ne === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        ac(ne, Rc) || Nk(g, r, R);
      }
      return R;
    }
    function Nk(e, r, c) {
      e.flags |= Zu;
      var g = {
        getSnapshot: r,
        value: c
      }, x = On.updateQueue;
      if (x === null)
        x = Pk(), On.updateQueue = x, x.stores = [g];
      else {
        var R = x.stores;
        R === null ? x.stores = [g] : R.push(g);
      }
    }
    function zk(e, r, c, g) {
      r.value = c, r.getSnapshot = g, Fk(r) && Yk(e);
    }
    function Ik(e, r, c) {
      var g = function() {
        Fk(r) && Yk(e);
      };
      return c(g);
    }
    function Fk(e) {
      var r = e.getSnapshot, c = e.value;
      try {
        var g = r();
        return !xt(c, g);
      } catch {
        return !0;
      }
    }
    function Yk(e) {
      var r = Aa(e, Yt);
      r !== null && Kr(r, e, Yt, Fn);
    }
    function _m(e) {
      var r = wo();
      typeof e == "function" && (e = e()), r.memoizedState = r.baseState = e;
      var c = {
        pending: null,
        interleaved: null,
        lanes: Pe,
        dispatch: null,
        lastRenderedReducer: c0,
        lastRenderedState: e
      };
      r.queue = c;
      var g = c.dispatch = OD.bind(null, On, c);
      return [r.memoizedState, g];
    }
    function g0(e) {
      return f0(c0);
    }
    function v0(e) {
      return h0(c0);
    }
    function Rp(e, r, c, g) {
      var x = {
        tag: e,
        create: r,
        destroy: c,
        deps: g,
        // Circular
        next: null
      }, R = On.updateQueue;
      if (R === null)
        R = Pk(), On.updateQueue = R, R.lastEffect = x.next = x;
      else {
        var _ = R.lastEffect;
        if (_ === null)
          R.lastEffect = x.next = x;
        else {
          var Y = _.next;
          _.next = x, x.next = Y, R.lastEffect = x;
        }
      }
      return x;
    }
    function m0(e) {
      var r = wo();
      {
        var c = {
          current: e
        };
        return r.memoizedState = c, c;
      }
    }
    function Pm(e) {
      var r = rs();
      return r.memoizedState;
    }
    function Lp(e, r, c, g) {
      var x = wo(), R = g === void 0 ? null : g;
      On.flags |= e, x.memoizedState = Rp(Xr | r, c, void 0, R);
    }
    function Nm(e, r, c, g) {
      var x = rs(), R = g === void 0 ? null : g, _ = void 0;
      if (Gr !== null) {
        var Y = Gr.memoizedState;
        if (_ = Y.destroy, R !== null) {
          var W = Y.deps;
          if (u0(R, W)) {
            x.memoizedState = Rp(r, c, _, R);
            return;
          }
        }
      }
      On.flags |= e, x.memoizedState = Rp(Xr | r, c, _, R);
    }
    function zm(e, r) {
      return (On.mode & ya) !== Nt ? Lp(jo | qn | no, ki, e, r) : Lp(qn | no, ki, e, r);
    }
    function Mp(e, r) {
      return Nm(qn, ki, e, r);
    }
    function y0(e, r) {
      return Lp(Jt, bo, e, r);
    }
    function Im(e, r) {
      return Nm(Jt, bo, e, r);
    }
    function x0(e, r) {
      var c = Jt;
      return c |= Pi, (On.mode & ya) !== Nt && (c |= Ni), Lp(c, Vr, e, r);
    }
    function Fm(e, r) {
      return Nm(Jt, Vr, e, r);
    }
    function Hk(e, r) {
      if (typeof r == "function") {
        var c = r, g = e();
        return c(g), function() {
          c(null);
        };
      } else if (r != null) {
        var x = r;
        x.hasOwnProperty("current") || T("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(x).join(", ") + "}");
        var R = e();
        return x.current = R, function() {
          x.current = null;
        };
      }
    }
    function b0(e, r, c) {
      typeof r != "function" && T("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", r !== null ? typeof r : "null");
      var g = c != null ? c.concat([e]) : null, x = Jt;
      return x |= Pi, (On.mode & ya) !== Nt && (x |= Ni), Lp(x, Vr, Hk.bind(null, r, e), g);
    }
    function Ym(e, r, c) {
      typeof r != "function" && T("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", r !== null ? typeof r : "null");
      var g = c != null ? c.concat([e]) : null;
      return Nm(Jt, Vr, Hk.bind(null, r, e), g);
    }
    function RD(e, r) {
    }
    var Hm = RD;
    function w0(e, r) {
      var c = wo(), g = r === void 0 ? null : r;
      return c.memoizedState = [e, g], e;
    }
    function jm(e, r) {
      var c = rs(), g = r === void 0 ? null : r, x = c.memoizedState;
      if (x !== null && g !== null) {
        var R = x[1];
        if (u0(g, R))
          return x[0];
      }
      return c.memoizedState = [e, g], e;
    }
    function S0(e, r) {
      var c = wo(), g = r === void 0 ? null : r, x = e();
      return c.memoizedState = [x, g], x;
    }
    function Um(e, r) {
      var c = rs(), g = r === void 0 ? null : r, x = c.memoizedState;
      if (x !== null && g !== null) {
        var R = x[1];
        if (u0(g, R))
          return x[0];
      }
      var _ = e();
      return c.memoizedState = [_, g], _;
    }
    function k0(e) {
      var r = wo();
      return r.memoizedState = e, e;
    }
    function jk(e) {
      var r = rs(), c = Gr, g = c.memoizedState;
      return Bk(r, g, e);
    }
    function Uk(e) {
      var r = rs();
      if (Gr === null)
        return r.memoizedState = e, e;
      var c = Gr.memoizedState;
      return Bk(r, c, e);
    }
    function Bk(e, r, c) {
      var g = !Lx(Rc);
      if (g) {
        if (!xt(c, r)) {
          var x = Dh();
          On.lanes = en(On.lanes, x), Vp(x), e.baseState = !0;
        }
        return r;
      } else
        return e.baseState && (e.baseState = !1, Pp()), e.memoizedState = c, c;
    }
    function LD(e, r, c) {
      var g = ba();
      Cr(ci(g, Wr)), e(!0);
      var x = Ap.transition;
      Ap.transition = {};
      var R = Ap.transition;
      Ap.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        e(!1), r();
      } finally {
        if (Cr(g), Ap.transition = x, x === null && R._updatedFibers) {
          var _ = R._updatedFibers.size;
          _ > 10 && A("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), R._updatedFibers.clear();
        }
      }
    }
    function C0() {
      var e = _m(!1), r = e[0], c = e[1], g = LD.bind(null, c), x = wo();
      return x.memoizedState = g, [r, g];
    }
    function Wk() {
      var e = g0(), r = e[0], c = rs(), g = c.memoizedState;
      return [r, g];
    }
    function Xk() {
      var e = v0(), r = e[0], c = rs(), g = c.memoizedState;
      return [r, g];
    }
    var Vk = !1;
    function MD() {
      return Vk;
    }
    function A0() {
      var e = wo(), r = ly(), c = r.identifierPrefix, g;
      if (Si()) {
        var x = WM();
        g = ":" + c + "R" + x;
        var R = Ep++;
        R > 0 && (g += "H" + R.toString(32)), g += ":";
      } else {
        var _ = AD++;
        g = ":" + c + "r" + _.toString(32) + ":";
      }
      return e.memoizedState = g, g;
    }
    function Bm() {
      var e = rs(), r = e.memoizedState;
      return r;
    }
    function DD(e, r, c) {
      typeof arguments[3] == "function" && T("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var g = Cu(e), x = {
        lane: g,
        action: c,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Gk(e))
        $k(r, x);
      else {
        var R = dk(e, r, x, g);
        if (R !== null) {
          var _ = oa();
          Kr(R, e, g, _), qk(R, r, g);
        }
      }
      Zk(e, g);
    }
    function OD(e, r, c) {
      typeof arguments[3] == "function" && T("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var g = Cu(e), x = {
        lane: g,
        action: c,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Gk(e))
        $k(r, x);
      else {
        var R = e.alternate;
        if (e.lanes === Pe && (R === null || R.lanes === Pe)) {
          var _ = r.lastRenderedReducer;
          if (_ !== null) {
            var Y;
            Y = ut.current, ut.current = Ns;
            try {
              var W = r.lastRenderedState, J = _(W, c);
              if (x.hasEagerState = !0, x.eagerState = J, xt(J, W)) {
                cD(e, r, x, g);
                return;
              }
            } catch {
            } finally {
              ut.current = Y;
            }
          }
        }
        var ne = dk(e, r, x, g);
        if (ne !== null) {
          var ge = oa();
          Kr(ne, e, g, ge), qk(ne, r, g);
        }
      }
      Zk(e, g);
    }
    function Gk(e) {
      var r = e.alternate;
      return e === On || r !== null && r === On;
    }
    function $k(e, r) {
      Tp = Dm = !0;
      var c = e.pending;
      c === null ? r.next = r : (r.next = c.next, c.next = r), e.pending = r;
    }
    function qk(e, r, c) {
      if (Mh(c)) {
        var g = r.lanes;
        g = Oh(g, e.pendingLanes);
        var x = en(g, c);
        r.lanes = x, Zl(e, x);
      }
    }
    function Zk(e, r, c) {
      lo(e, r);
    }
    var Wm = {
      readContext: Fr,
      useCallback: Bi,
      useContext: Bi,
      useEffect: Bi,
      useImperativeHandle: Bi,
      useInsertionEffect: Bi,
      useLayoutEffect: Bi,
      useMemo: Bi,
      useReducer: Bi,
      useRef: Bi,
      useState: Bi,
      useDebugValue: Bi,
      useDeferredValue: Bi,
      useTransition: Bi,
      useMutableSource: Bi,
      useSyncExternalStore: Bi,
      useId: Bi,
      unstable_isNewReconciler: We
    }, Qk = null, Kk = null, Jk = null, eC = null, So = null, Ns = null, Xm = null;
    {
      var T0 = function() {
        T("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Gt = function() {
        T("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      Qk = {
        readContext: function(e) {
          return Fr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", Tn(), xf(r), w0(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", Tn(), Fr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", Tn(), xf(r), zm(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", Tn(), xf(c), b0(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", Tn(), xf(r), y0(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", Tn(), xf(r), x0(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", Tn(), xf(r);
          var c = ut.current;
          ut.current = So;
          try {
            return S0(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", Tn();
          var g = ut.current;
          ut.current = So;
          try {
            return d0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", Tn(), m0(e);
        },
        useState: function(e) {
          ze = "useState", Tn();
          var r = ut.current;
          ut.current = So;
          try {
            return _m(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", Tn(), void 0;
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", Tn(), k0(e);
        },
        useTransition: function() {
          return ze = "useTransition", Tn(), C0();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", Tn(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", Tn(), p0(e, r, c);
        },
        useId: function() {
          return ze = "useId", Tn(), A0();
        },
        unstable_isNewReconciler: We
      }, Kk = {
        readContext: function(e) {
          return Fr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", nt(), w0(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", nt(), Fr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", nt(), zm(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", nt(), b0(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", nt(), y0(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", nt(), x0(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", nt();
          var c = ut.current;
          ut.current = So;
          try {
            return S0(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", nt();
          var g = ut.current;
          ut.current = So;
          try {
            return d0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", nt(), m0(e);
        },
        useState: function(e) {
          ze = "useState", nt();
          var r = ut.current;
          ut.current = So;
          try {
            return _m(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", nt(), void 0;
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", nt(), k0(e);
        },
        useTransition: function() {
          return ze = "useTransition", nt(), C0();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", nt(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", nt(), p0(e, r, c);
        },
        useId: function() {
          return ze = "useId", nt(), A0();
        },
        unstable_isNewReconciler: We
      }, Jk = {
        readContext: function(e) {
          return Fr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", nt(), jm(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", nt(), Fr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", nt(), Mp(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", nt(), Ym(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", nt(), Im(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", nt(), Fm(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", nt();
          var c = ut.current;
          ut.current = Ns;
          try {
            return Um(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", nt();
          var g = ut.current;
          ut.current = Ns;
          try {
            return f0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", nt(), Pm();
        },
        useState: function(e) {
          ze = "useState", nt();
          var r = ut.current;
          ut.current = Ns;
          try {
            return g0(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", nt(), Hm();
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", nt(), jk(e);
        },
        useTransition: function() {
          return ze = "useTransition", nt(), Wk();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", nt(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", nt(), Om(e, r);
        },
        useId: function() {
          return ze = "useId", nt(), Bm();
        },
        unstable_isNewReconciler: We
      }, eC = {
        readContext: function(e) {
          return Fr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", nt(), jm(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", nt(), Fr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", nt(), Mp(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", nt(), Ym(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", nt(), Im(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", nt(), Fm(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", nt();
          var c = ut.current;
          ut.current = Xm;
          try {
            return Um(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", nt();
          var g = ut.current;
          ut.current = Xm;
          try {
            return h0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", nt(), Pm();
        },
        useState: function(e) {
          ze = "useState", nt();
          var r = ut.current;
          ut.current = Xm;
          try {
            return v0(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", nt(), Hm();
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", nt(), Uk(e);
        },
        useTransition: function() {
          return ze = "useTransition", nt(), Xk();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", nt(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", nt(), Om(e, r);
        },
        useId: function() {
          return ze = "useId", nt(), Bm();
        },
        unstable_isNewReconciler: We
      }, So = {
        readContext: function(e) {
          return T0(), Fr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", Gt(), Tn(), w0(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", Gt(), Tn(), Fr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", Gt(), Tn(), zm(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", Gt(), Tn(), b0(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", Gt(), Tn(), y0(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", Gt(), Tn(), x0(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", Gt(), Tn();
          var c = ut.current;
          ut.current = So;
          try {
            return S0(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", Gt(), Tn();
          var g = ut.current;
          ut.current = So;
          try {
            return d0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", Gt(), Tn(), m0(e);
        },
        useState: function(e) {
          ze = "useState", Gt(), Tn();
          var r = ut.current;
          ut.current = So;
          try {
            return _m(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", Gt(), Tn(), void 0;
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", Gt(), Tn(), k0(e);
        },
        useTransition: function() {
          return ze = "useTransition", Gt(), Tn(), C0();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", Gt(), Tn(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", Gt(), Tn(), p0(e, r, c);
        },
        useId: function() {
          return ze = "useId", Gt(), Tn(), A0();
        },
        unstable_isNewReconciler: We
      }, Ns = {
        readContext: function(e) {
          return T0(), Fr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", Gt(), nt(), jm(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", Gt(), nt(), Fr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", Gt(), nt(), Mp(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", Gt(), nt(), Ym(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", Gt(), nt(), Im(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", Gt(), nt(), Fm(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", Gt(), nt();
          var c = ut.current;
          ut.current = Ns;
          try {
            return Um(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", Gt(), nt();
          var g = ut.current;
          ut.current = Ns;
          try {
            return f0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", Gt(), nt(), Pm();
        },
        useState: function(e) {
          ze = "useState", Gt(), nt();
          var r = ut.current;
          ut.current = Ns;
          try {
            return g0(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", Gt(), nt(), Hm();
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", Gt(), nt(), jk(e);
        },
        useTransition: function() {
          return ze = "useTransition", Gt(), nt(), Wk();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", Gt(), nt(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", Gt(), nt(), Om(e, r);
        },
        useId: function() {
          return ze = "useId", Gt(), nt(), Bm();
        },
        unstable_isNewReconciler: We
      }, Xm = {
        readContext: function(e) {
          return T0(), Fr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", Gt(), nt(), jm(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", Gt(), nt(), Fr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", Gt(), nt(), Mp(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", Gt(), nt(), Ym(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", Gt(), nt(), Im(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", Gt(), nt(), Fm(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", Gt(), nt();
          var c = ut.current;
          ut.current = Ns;
          try {
            return Um(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", Gt(), nt();
          var g = ut.current;
          ut.current = Ns;
          try {
            return h0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", Gt(), nt(), Pm();
        },
        useState: function(e) {
          ze = "useState", Gt(), nt();
          var r = ut.current;
          ut.current = Ns;
          try {
            return v0(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", Gt(), nt(), Hm();
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", Gt(), nt(), Uk(e);
        },
        useTransition: function() {
          return ze = "useTransition", Gt(), nt(), Xk();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", Gt(), nt(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", Gt(), nt(), Om(e, r);
        },
        useId: function() {
          return ze = "useId", Gt(), nt(), Bm();
        },
        unstable_isNewReconciler: We
      };
    }
    var bu = u.unstable_now, tC = 0, Vm = -1, Dp = -1, Gm = -1, E0 = !1, $m = !1;
    function nC() {
      return E0;
    }
    function _D() {
      $m = !0;
    }
    function PD() {
      E0 = !1, $m = !1;
    }
    function ND() {
      E0 = $m, $m = !1;
    }
    function rC() {
      return tC;
    }
    function iC() {
      tC = bu();
    }
    function R0(e) {
      Dp = bu(), e.actualStartTime < 0 && (e.actualStartTime = bu());
    }
    function aC(e) {
      Dp = -1;
    }
    function qm(e, r) {
      if (Dp >= 0) {
        var c = bu() - Dp;
        e.actualDuration += c, r && (e.selfBaseDuration = c), Dp = -1;
      }
    }
    function ko(e) {
      if (Vm >= 0) {
        var r = bu() - Vm;
        Vm = -1;
        for (var c = e.return; c !== null; ) {
          switch (c.tag) {
            case q:
              var g = c.stateNode;
              g.effectDuration += r;
              return;
            case Ee:
              var x = c.stateNode;
              x.effectDuration += r;
              return;
          }
          c = c.return;
        }
      }
    }
    function L0(e) {
      if (Gm >= 0) {
        var r = bu() - Gm;
        Gm = -1;
        for (var c = e.return; c !== null; ) {
          switch (c.tag) {
            case q:
              var g = c.stateNode;
              g !== null && (g.passiveEffectDuration += r);
              return;
            case Ee:
              var x = c.stateNode;
              x !== null && (x.passiveEffectDuration += r);
              return;
          }
          c = c.return;
        }
      }
    }
    function Co() {
      Vm = bu();
    }
    function M0() {
      Gm = bu();
    }
    function D0(e) {
      for (var r = e.child; r; )
        e.actualDuration += r.actualDuration, r = r.sibling;
    }
    function Lc(e, r) {
      return {
        value: e,
        source: r,
        stack: rt(r),
        digest: null
      };
    }
    function O0(e, r, c) {
      return {
        value: e,
        source: null,
        stack: c ?? null,
        digest: r ?? null
      };
    }
    function zD(e, r) {
      return !0;
    }
    function _0(e, r) {
      try {
        var c = zD(e, r);
        if (c === !1)
          return;
        var g = r.value, x = r.source, R = r.stack, _ = R !== null ? R : "";
        if (g != null && g._suppressLogging) {
          if (e.tag === U)
            return;
          console.error(g);
        }
        var Y = x ? gt(x) : null, W = Y ? "The above error occurred in the <" + Y + "> component:" : "The above error occurred in one of your React components:", J;
        if (e.tag === q)
          J = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var ne = gt(e) || "Anonymous";
          J = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + ne + ".");
        }
        var ge = W + `
` + _ + `

` + ("" + J);
        console.error(ge);
      } catch (he) {
        setTimeout(function() {
          throw he;
        });
      }
    }
    var ID = typeof WeakMap == "function" ? WeakMap : Map;
    function sC(e, r, c) {
      var g = hl(Fn, c);
      g.tag = _b, g.payload = {
        element: null
      };
      var x = r.value;
      return g.callback = function() {
        L2(x), _0(e, r);
      }, g;
    }
    function P0(e, r, c) {
      var g = hl(Fn, c);
      g.tag = _b;
      var x = e.type.getDerivedStateFromError;
      if (typeof x == "function") {
        var R = r.value;
        g.payload = function() {
          return x(R);
        }, g.callback = function() {
          mA(e), _0(e, r);
        };
      }
      var _ = e.stateNode;
      return _ !== null && typeof _.componentDidCatch == "function" && (g.callback = function() {
        mA(e), _0(e, r), typeof x != "function" && E2(this);
        var W = r.value, J = r.stack;
        this.componentDidCatch(W, {
          componentStack: J !== null ? J : ""
        }), typeof x != "function" && (Hi(e.lanes, Yt) || T("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", gt(e) || "Unknown"));
      }), g;
    }
    function oC(e, r, c) {
      var g = e.pingCache, x;
      if (g === null ? (g = e.pingCache = new ID(), x = /* @__PURE__ */ new Set(), g.set(r, x)) : (x = g.get(r), x === void 0 && (x = /* @__PURE__ */ new Set(), g.set(r, x))), !x.has(c)) {
        x.add(c);
        var R = M2.bind(null, e, r, c);
        Br && Gp(e, c), r.then(R, R);
      }
    }
    function FD(e, r, c, g) {
      var x = e.updateQueue;
      if (x === null) {
        var R = /* @__PURE__ */ new Set();
        R.add(c), e.updateQueue = R;
      } else
        x.add(c);
    }
    function YD(e, r) {
      var c = e.tag;
      if ((e.mode & nn) === Nt && (c === H || c === we || c === Le)) {
        var g = e.alternate;
        g ? (e.updateQueue = g.updateQueue, e.memoizedState = g.memoizedState, e.lanes = g.lanes) : (e.updateQueue = null, e.memoizedState = null);
      }
    }
    function lC(e) {
      var r = e;
      do {
        if (r.tag === re && kD(r))
          return r;
        r = r.return;
      } while (r !== null);
      return null;
    }
    function uC(e, r, c, g, x) {
      if ((e.mode & nn) === Nt) {
        if (e === r)
          e.flags |= _r;
        else {
          if (e.flags |= Xt, c.flags |= Qu, c.flags &= ~(ad | Ji), c.tag === U) {
            var R = c.alternate;
            if (R === null)
              c.tag = Be;
            else {
              var _ = hl(Fn, Yt);
              _.tag = xm, vu(c, _, Yt);
            }
          }
          c.lanes = en(c.lanes, Yt);
        }
        return e;
      }
      return e.flags |= _r, e.lanes = x, e;
    }
    function HD(e, r, c, g, x) {
      if (c.flags |= Ji, Br && Gp(e, x), g !== null && typeof g == "object" && typeof g.then == "function") {
        var R = g;
        YD(c), Si() && c.mode & nn && JS();
        var _ = lC(r);
        if (_ !== null) {
          _.flags &= ~sr, uC(_, r, c, e, x), _.mode & nn && oC(e, R, x), FD(_, e, R);
          return;
        } else {
          if (!$l(x)) {
            oC(e, R, x), hw();
            return;
          }
          var Y = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          g = Y;
        }
      } else if (Si() && c.mode & nn) {
        JS();
        var W = lC(r);
        if (W !== null) {
          (W.flags & _r) === _t && (W.flags |= sr), uC(W, r, c, e, x), Tb(Lc(g, c));
          return;
        }
      }
      g = Lc(g, c), x2(g);
      var J = r;
      do {
        switch (J.tag) {
          case q: {
            var ne = g;
            J.flags |= _r;
            var ge = kr(x);
            J.lanes = en(J.lanes, ge);
            var he = sC(J, ne, ge);
            zb(J, he);
            return;
          }
          case U:
            var Ce = g, Ae = J.type, De = J.stateNode;
            if ((J.flags & Xt) === _t && (typeof Ae.getDerivedStateFromError == "function" || De !== null && typeof De.componentDidCatch == "function" && !lA(De))) {
              J.flags |= _r;
              var ct = kr(x);
              J.lanes = en(J.lanes, ct);
              var Pt = P0(J, Ce, ct);
              zb(J, Pt);
              return;
            }
            break;
        }
        J = J.return;
      } while (J !== null);
    }
    function jD() {
      return null;
    }
    var Op = h.ReactCurrentOwner, zs = !1, N0, _p, z0, I0, F0, Mc, Y0, Zm;
    N0 = {}, _p = {}, z0 = {}, I0 = {}, F0 = {}, Mc = !1, Y0 = {}, Zm = {};
    function aa(e, r, c, g) {
      e === null ? r.child = Ek(r, null, c, g) : r.child = pf(r, e.child, c, g);
    }
    function UD(e, r, c, g) {
      r.child = pf(r, e.child, null, g), r.child = pf(r, null, c, g);
    }
    function cC(e, r, c, g, x) {
      if (r.type !== r.elementType) {
        var R = c.propTypes;
        R && Ms(
          R,
          g,
          // Resolved props
          "prop",
          mt(c)
        );
      }
      var _ = c.render, Y = r.ref, W, J;
      hf(r, x), oo(r);
      {
        if (Op.current = r, Na(!0), W = bf(e, r, _, g, Y, x), J = wf(), r.mode & Kn) {
          Sr(!0);
          try {
            W = bf(e, r, _, g, Y, x), J = wf();
          } finally {
            Sr(!1);
          }
        }
        Na(!1);
      }
      return Uo(), e !== null && !zs ? (Ok(e, r, x), pl(e, r, x)) : (Si() && J && bb(r), r.flags |= eo, aa(e, r, W, x), r.child);
    }
    function dC(e, r, c, g, x) {
      if (e === null) {
        var R = c.type;
        if (G2(R) && c.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        c.defaultProps === void 0) {
          var _ = R;
          return _ = Lf(R), r.tag = Le, r.type = _, U0(r, R), fC(e, r, _, g, x);
        }
        {
          var Y = R.propTypes;
          Y && Ms(
            Y,
            g,
            // Resolved props
            "prop",
            mt(R)
          );
        }
        var W = Cw(c.type, null, g, r, r.mode, x);
        return W.ref = r.ref, W.return = r, r.child = W, W;
      }
      {
        var J = c.type, ne = J.propTypes;
        ne && Ms(
          ne,
          g,
          // Resolved props
          "prop",
          mt(J)
        );
      }
      var ge = e.child, he = $0(e, x);
      if (!he) {
        var Ce = ge.memoizedProps, Ae = c.compare;
        if (Ae = Ae !== null ? Ae : Lt, Ae(Ce, g) && e.ref === r.ref)
          return pl(e, r, x);
      }
      r.flags |= eo;
      var De = Nc(ge, g);
      return De.ref = r.ref, De.return = r, r.child = De, De;
    }
    function fC(e, r, c, g, x) {
      if (r.type !== r.elementType) {
        var R = r.elementType;
        if (R.$$typeof === Ot) {
          var _ = R, Y = _._payload, W = _._init;
          try {
            R = W(Y);
          } catch {
            R = null;
          }
          var J = R && R.propTypes;
          J && Ms(
            J,
            g,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            mt(R)
          );
        }
      }
      if (e !== null) {
        var ne = e.memoizedProps;
        if (Lt(ne, g) && e.ref === r.ref && // Prevent bailout if the implementation changed due to hot reload.
        r.type === e.type)
          if (zs = !1, r.pendingProps = g = ne, $0(e, x))
            (e.flags & Qu) !== _t && (zs = !0);
          else
            return r.lanes = e.lanes, pl(e, r, x);
      }
      return H0(e, r, c, g, x);
    }
    function hC(e, r, c) {
      var g = r.pendingProps, x = g.children, R = e !== null ? e.memoizedState : null;
      if (g.mode === "hidden" || ye)
        if ((r.mode & nn) === Nt) {
          var _ = {
            baseLanes: Pe,
            cachePool: null,
            transitions: null
          };
          r.memoizedState = _, uy(r, c);
        } else if (Hi(c, Yi)) {
          var ge = {
            baseLanes: Pe,
            cachePool: null,
            transitions: null
          };
          r.memoizedState = ge;
          var he = R !== null ? R.baseLanes : c;
          uy(r, he);
        } else {
          var Y = null, W;
          if (R !== null) {
            var J = R.baseLanes;
            W = en(J, c);
          } else
            W = c;
          r.lanes = r.childLanes = Yi;
          var ne = {
            baseLanes: W,
            cachePool: Y,
            transitions: null
          };
          return r.memoizedState = ne, r.updateQueue = null, uy(r, W), null;
        }
      else {
        var Ce;
        R !== null ? (Ce = en(R.baseLanes, c), r.memoizedState = null) : Ce = c, uy(r, Ce);
      }
      return aa(e, r, x, c), r.child;
    }
    function BD(e, r, c) {
      var g = r.pendingProps;
      return aa(e, r, g, c), r.child;
    }
    function WD(e, r, c) {
      var g = r.pendingProps.children;
      return aa(e, r, g, c), r.child;
    }
    function XD(e, r, c) {
      {
        r.flags |= Jt;
        {
          var g = r.stateNode;
          g.effectDuration = 0, g.passiveEffectDuration = 0;
        }
      }
      var x = r.pendingProps, R = x.children;
      return aa(e, r, R, c), r.child;
    }
    function pC(e, r) {
      var c = r.ref;
      (e === null && c !== null || e !== null && e.ref !== c) && (r.flags |= _i, r.flags |= gh);
    }
    function H0(e, r, c, g, x) {
      if (r.type !== r.elementType) {
        var R = c.propTypes;
        R && Ms(
          R,
          g,
          // Resolved props
          "prop",
          mt(c)
        );
      }
      var _;
      {
        var Y = of(r, c, !0);
        _ = lf(r, Y);
      }
      var W, J;
      hf(r, x), oo(r);
      {
        if (Op.current = r, Na(!0), W = bf(e, r, c, g, _, x), J = wf(), r.mode & Kn) {
          Sr(!0);
          try {
            W = bf(e, r, c, g, _, x), J = wf();
          } finally {
            Sr(!1);
          }
        }
        Na(!1);
      }
      return Uo(), e !== null && !zs ? (Ok(e, r, x), pl(e, r, x)) : (Si() && J && bb(r), r.flags |= eo, aa(e, r, W, x), r.child);
    }
    function gC(e, r, c, g, x) {
      {
        switch (l_(r)) {
          case !1: {
            var R = r.stateNode, _ = r.type, Y = new _(r.memoizedProps, R.context), W = Y.state;
            R.updater.enqueueSetState(R, W, null);
            break;
          }
          case !0: {
            r.flags |= Xt, r.flags |= _r;
            var J = new Error("Simulated error coming from DevTools"), ne = kr(x);
            r.lanes = en(r.lanes, ne);
            var ge = P0(r, Lc(J, r), ne);
            zb(r, ge);
            break;
          }
        }
        if (r.type !== r.elementType) {
          var he = c.propTypes;
          he && Ms(
            he,
            g,
            // Resolved props
            "prop",
            mt(c)
          );
        }
      }
      var Ce;
      xo(c) ? (Ce = !0, lm(r)) : Ce = !1, hf(r, x);
      var Ae = r.stateNode, De;
      Ae === null ? (Km(e, r), Sk(r, c, g), $b(r, c, g, x), De = !0) : e === null ? De = mD(r, c, g, x) : De = yD(e, r, c, g, x);
      var ct = j0(e, r, c, De, Ce, x);
      {
        var Pt = r.stateNode;
        De && Pt.props !== g && (Mc || T("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", gt(r) || "a component"), Mc = !0);
      }
      return ct;
    }
    function j0(e, r, c, g, x, R) {
      pC(e, r);
      var _ = (r.flags & Xt) !== _t;
      if (!g && !_)
        return x && qS(r, c, !1), pl(e, r, R);
      var Y = r.stateNode;
      Op.current = r;
      var W;
      if (_ && typeof c.getDerivedStateFromError != "function")
        W = null, aC();
      else {
        oo(r);
        {
          if (Na(!0), W = Y.render(), r.mode & Kn) {
            Sr(!0);
            try {
              Y.render();
            } finally {
              Sr(!1);
            }
          }
          Na(!1);
        }
        Uo();
      }
      return r.flags |= eo, e !== null && _ ? UD(e, r, W, R) : aa(e, r, W, R), r.memoizedState = Y.state, x && qS(r, c, !0), r.child;
    }
    function vC(e) {
      var r = e.stateNode;
      r.pendingContext ? GS(e, r.pendingContext, r.pendingContext !== r.context) : r.context && GS(e, r.context, !1), e0(e, r.containerInfo);
    }
    function VD(e, r, c) {
      if (vC(r), e === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var g = r.pendingProps, x = r.memoizedState, R = x.element;
      pk(e, r), km(r, g, null, c);
      var _ = r.memoizedState;
      r.stateNode;
      var Y = _.element;
      if (x.isDehydrated) {
        var W = {
          element: Y,
          isDehydrated: !1,
          cache: _.cache,
          pendingSuspenseBoundaries: _.pendingSuspenseBoundaries,
          transitions: _.transitions
        }, J = r.updateQueue;
        if (J.baseState = W, r.memoizedState = W, r.flags & sr) {
          var ne = Lc(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), r);
          return mC(e, r, Y, c, ne);
        } else if (Y !== R) {
          var ge = Lc(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), r);
          return mC(e, r, Y, c, ge);
        } else {
          ZM(r);
          var he = Ek(r, null, Y, c);
          r.child = he;
          for (var Ce = he; Ce; )
            Ce.flags = Ce.flags & ~Bn | ga, Ce = Ce.sibling;
        }
      } else {
        if (df(), Y === R)
          return pl(e, r, c);
        aa(e, r, Y, c);
      }
      return r.child;
    }
    function mC(e, r, c, g, x) {
      return df(), Tb(x), r.flags |= sr, aa(e, r, c, g), r.child;
    }
    function GD(e, r, c) {
      Lk(r), e === null && Ab(r);
      var g = r.type, x = r.pendingProps, R = e !== null ? e.memoizedProps : null, _ = x.children, Y = sb(g, x);
      return Y ? _ = null : R !== null && sb(g, R) && (r.flags |= An), pC(e, r), aa(e, r, _, c), r.child;
    }
    function $D(e, r) {
      return e === null && Ab(r), null;
    }
    function qD(e, r, c, g) {
      Km(e, r);
      var x = r.pendingProps, R = c, _ = R._payload, Y = R._init, W = Y(_);
      r.type = W;
      var J = r.tag = $2(W), ne = _s(W, x), ge;
      switch (J) {
        case H:
          return U0(r, W), r.type = W = Lf(W), ge = H0(null, r, W, ne, g), ge;
        case U:
          return r.type = W = yw(W), ge = gC(null, r, W, ne, g), ge;
        case we:
          return r.type = W = xw(W), ge = cC(null, r, W, ne, g), ge;
        case ve: {
          if (r.type !== r.elementType) {
            var he = W.propTypes;
            he && Ms(
              he,
              ne,
              // Resolved for outer only
              "prop",
              mt(W)
            );
          }
          return ge = dC(
            null,
            r,
            W,
            _s(W.type, ne),
            // The inner type can have defaults too
            g
          ), ge;
        }
      }
      var Ce = "";
      throw W !== null && typeof W == "object" && W.$$typeof === Ot && (Ce = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + W + ". " + ("Lazy element type must resolve to a class or function." + Ce));
    }
    function ZD(e, r, c, g, x) {
      Km(e, r), r.tag = U;
      var R;
      return xo(c) ? (R = !0, lm(r)) : R = !1, hf(r, x), Sk(r, c, g), $b(r, c, g, x), j0(null, r, c, !0, R, x);
    }
    function QD(e, r, c, g) {
      Km(e, r);
      var x = r.pendingProps, R;
      {
        var _ = of(r, c, !1);
        R = lf(r, _);
      }
      hf(r, g);
      var Y, W;
      oo(r);
      {
        if (c.prototype && typeof c.prototype.render == "function") {
          var J = mt(c) || "Unknown";
          N0[J] || (T("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", J, J), N0[J] = !0);
        }
        r.mode & Kn && Os.recordLegacyContextWarning(r, null), Na(!0), Op.current = r, Y = bf(null, r, c, x, R, g), W = wf(), Na(!1);
      }
      if (Uo(), r.flags |= eo, typeof Y == "object" && Y !== null && typeof Y.render == "function" && Y.$$typeof === void 0) {
        var ne = mt(c) || "Unknown";
        _p[ne] || (T("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ne, ne, ne), _p[ne] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof Y == "object" && Y !== null && typeof Y.render == "function" && Y.$$typeof === void 0
      ) {
        {
          var ge = mt(c) || "Unknown";
          _p[ge] || (T("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ge, ge, ge), _p[ge] = !0);
        }
        r.tag = U, r.memoizedState = null, r.updateQueue = null;
        var he = !1;
        return xo(c) ? (he = !0, lm(r)) : he = !1, r.memoizedState = Y.state !== null && Y.state !== void 0 ? Y.state : null, Nb(r), wk(r, Y), $b(r, c, x, g), j0(null, r, c, !0, he, g);
      } else {
        if (r.tag = H, r.mode & Kn) {
          Sr(!0);
          try {
            Y = bf(null, r, c, x, R, g), W = wf();
          } finally {
            Sr(!1);
          }
        }
        return Si() && W && bb(r), aa(null, r, Y, g), U0(r, c), r.child;
      }
    }
    function U0(e, r) {
      {
        if (r && r.childContextTypes && T("%s(...): childContextTypes cannot be defined on a function component.", r.displayName || r.name || "Component"), e.ref !== null) {
          var c = "", g = si();
          g && (c += `

Check the render method of \`` + g + "`.");
          var x = g || "", R = e._debugSource;
          R && (x = R.fileName + ":" + R.lineNumber), F0[x] || (F0[x] = !0, T("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", c));
        }
        if (typeof r.getDerivedStateFromProps == "function") {
          var _ = mt(r) || "Unknown";
          I0[_] || (T("%s: Function components do not support getDerivedStateFromProps.", _), I0[_] = !0);
        }
        if (typeof r.contextType == "object" && r.contextType !== null) {
          var Y = mt(r) || "Unknown";
          z0[Y] || (T("%s: Function components do not support contextType.", Y), z0[Y] = !0);
        }
      }
    }
    var B0 = {
      dehydrated: null,
      treeContext: null,
      retryLane: dn
    };
    function W0(e) {
      return {
        baseLanes: e,
        cachePool: jD(),
        transitions: null
      };
    }
    function KD(e, r) {
      var c = null;
      return {
        baseLanes: en(e.baseLanes, r),
        cachePool: c,
        transitions: e.transitions
      };
    }
    function JD(e, r, c, g) {
      if (r !== null) {
        var x = r.memoizedState;
        if (x === null)
          return !1;
      }
      return r0(e, Cp);
    }
    function eO(e, r) {
      return ql(e.childLanes, r);
    }
    function yC(e, r, c) {
      var g = r.pendingProps;
      u_(r) && (r.flags |= Xt);
      var x = Ps.current, R = !1, _ = (r.flags & Xt) !== _t;
      if (_ || JD(x, e) ? (R = !0, r.flags &= ~Xt) : (e === null || e.memoizedState !== null) && (x = SD(x, Dk)), x = vf(x), yu(r, x), e === null) {
        Ab(r);
        var Y = r.memoizedState;
        if (Y !== null) {
          var W = Y.dehydrated;
          if (W !== null)
            return aO(r, W);
        }
        var J = g.children, ne = g.fallback;
        if (R) {
          var ge = tO(r, J, ne, c), he = r.child;
          return he.memoizedState = W0(c), r.memoizedState = B0, ge;
        } else
          return X0(r, J);
      } else {
        var Ce = e.memoizedState;
        if (Ce !== null) {
          var Ae = Ce.dehydrated;
          if (Ae !== null)
            return sO(e, r, _, g, Ae, Ce, c);
        }
        if (R) {
          var De = g.fallback, ct = g.children, Pt = rO(e, r, ct, De, c), Tt = r.child, hn = e.child.memoizedState;
          return Tt.memoizedState = hn === null ? W0(c) : KD(hn, c), Tt.childLanes = eO(e, c), r.memoizedState = B0, Pt;
        } else {
          var on = g.children, xe = nO(e, r, on, c);
          return r.memoizedState = null, xe;
        }
      }
    }
    function X0(e, r, c) {
      var g = e.mode, x = {
        mode: "visible",
        children: r
      }, R = V0(x, g);
      return R.return = e, e.child = R, R;
    }
    function tO(e, r, c, g) {
      var x = e.mode, R = e.child, _ = {
        mode: "hidden",
        children: r
      }, Y, W;
      return (x & nn) === Nt && R !== null ? (Y = R, Y.childLanes = Pe, Y.pendingProps = _, e.mode & Ft && (Y.actualDuration = 0, Y.actualStartTime = -1, Y.selfBaseDuration = 0, Y.treeBaseDuration = 0), W = Tu(c, x, g, null)) : (Y = V0(_, x), W = Tu(c, x, g, null)), Y.return = e, W.return = e, Y.sibling = W, e.child = Y, W;
    }
    function V0(e, r, c) {
      return xA(e, r, Pe, null);
    }
    function xC(e, r) {
      return Nc(e, r);
    }
    function nO(e, r, c, g) {
      var x = e.child, R = x.sibling, _ = xC(x, {
        mode: "visible",
        children: c
      });
      if ((r.mode & nn) === Nt && (_.lanes = g), _.return = r, _.sibling = null, R !== null) {
        var Y = r.deletions;
        Y === null ? (r.deletions = [R], r.flags |= Sn) : Y.push(R);
      }
      return r.child = _, _;
    }
    function rO(e, r, c, g, x) {
      var R = r.mode, _ = e.child, Y = _.sibling, W = {
        mode: "hidden",
        children: c
      }, J;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (R & nn) === Nt && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        r.child !== _
      ) {
        var ne = r.child;
        J = ne, J.childLanes = Pe, J.pendingProps = W, r.mode & Ft && (J.actualDuration = 0, J.actualStartTime = -1, J.selfBaseDuration = _.selfBaseDuration, J.treeBaseDuration = _.treeBaseDuration), r.deletions = null;
      } else
        J = xC(_, W), J.subtreeFlags = _.subtreeFlags & Ur;
      var ge;
      return Y !== null ? ge = Nc(Y, g) : (ge = Tu(g, R, x, null), ge.flags |= Bn), ge.return = r, J.return = r, J.sibling = ge, r.child = J, ge;
    }
    function Qm(e, r, c, g) {
      g !== null && Tb(g), pf(r, e.child, null, c);
      var x = r.pendingProps, R = x.children, _ = X0(r, R);
      return _.flags |= Bn, r.memoizedState = null, _;
    }
    function iO(e, r, c, g, x) {
      var R = r.mode, _ = {
        mode: "visible",
        children: c
      }, Y = V0(_, R), W = Tu(g, R, x, null);
      return W.flags |= Bn, Y.return = r, W.return = r, Y.sibling = W, r.child = Y, (r.mode & nn) !== Nt && pf(r, e.child, null, x), W;
    }
    function aO(e, r, c) {
      return (e.mode & nn) === Nt ? (T("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), e.lanes = Yt) : cb(r) ? e.lanes = Xo : e.lanes = Yi, null;
    }
    function sO(e, r, c, g, x, R, _) {
      if (c)
        if (r.flags & sr) {
          r.flags &= ~sr;
          var xe = O0(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return Qm(e, r, _, xe);
        } else {
          if (r.memoizedState !== null)
            return r.child = e.child, r.flags |= Xt, null;
          var Oe = g.children, be = g.fallback, Xe = iO(e, r, Oe, be, _), dt = r.child;
          return dt.memoizedState = W0(_), r.memoizedState = B0, Xe;
        }
      else {
        if ($M(), (r.mode & nn) === Nt)
          return Qm(
            e,
            r,
            _,
            // TODO: When we delete legacy mode, we should make this error argument
            // required — every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (cb(x)) {
          var Y, W, J;
          {
            var ne = dM(x);
            Y = ne.digest, W = ne.message, J = ne.stack;
          }
          var ge;
          W ? ge = new Error(W) : ge = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var he = O0(ge, Y, J);
          return Qm(e, r, _, he);
        }
        var Ce = Hi(_, e.childLanes);
        if (zs || Ce) {
          var Ae = ly();
          if (Ae !== null) {
            var De = Dx(Ae, _);
            if (De !== dn && De !== R.retryLane) {
              R.retryLane = De;
              var ct = Fn;
              Aa(e, De), Kr(Ae, e, De, ct);
            }
          }
          hw();
          var Pt = O0(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return Qm(e, r, _, Pt);
        } else if (jS(x)) {
          r.flags |= Xt, r.child = e.child;
          var Tt = D2.bind(null, e);
          return fM(x, Tt), null;
        } else {
          QM(r, x, R.treeContext);
          var hn = g.children, on = X0(r, hn);
          return on.flags |= ga, on;
        }
      }
    }
    function bC(e, r, c) {
      e.lanes = en(e.lanes, r);
      var g = e.alternate;
      g !== null && (g.lanes = en(g.lanes, r)), Db(e.return, r, c);
    }
    function oO(e, r, c) {
      for (var g = r; g !== null; ) {
        if (g.tag === re) {
          var x = g.memoizedState;
          x !== null && bC(g, c, e);
        } else if (g.tag === ft)
          bC(g, c, e);
        else if (g.child !== null) {
          g.child.return = g, g = g.child;
          continue;
        }
        if (g === e)
          return;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === e)
            return;
          g = g.return;
        }
        g.sibling.return = g.return, g = g.sibling;
      }
    }
    function lO(e) {
      for (var r = e, c = null; r !== null; ) {
        var g = r.alternate;
        g !== null && Mm(g) === null && (c = r), r = r.sibling;
      }
      return c;
    }
    function uO(e) {
      if (e !== void 0 && e !== "forwards" && e !== "backwards" && e !== "together" && !Y0[e])
        if (Y0[e] = !0, typeof e == "string")
          switch (e.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              T('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', e, e.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              T('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', e, e.toLowerCase());
              break;
            }
            default:
              T('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
              break;
          }
        else
          T('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
    }
    function cO(e, r) {
      e !== void 0 && !Zm[e] && (e !== "collapsed" && e !== "hidden" ? (Zm[e] = !0, T('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', e)) : r !== "forwards" && r !== "backwards" && (Zm[e] = !0, T('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', e)));
    }
    function wC(e, r) {
      {
        var c = Dr(e), g = !c && typeof f(e) == "function";
        if (c || g) {
          var x = c ? "array" : "iterable";
          return T("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", x, r, x), !1;
        }
      }
      return !0;
    }
    function dO(e, r) {
      if ((r === "forwards" || r === "backwards") && e !== void 0 && e !== null && e !== !1)
        if (Dr(e)) {
          for (var c = 0; c < e.length; c++)
            if (!wC(e[c], c))
              return;
        } else {
          var g = f(e);
          if (typeof g == "function") {
            var x = g.call(e);
            if (x)
              for (var R = x.next(), _ = 0; !R.done; R = x.next()) {
                if (!wC(R.value, _))
                  return;
                _++;
              }
          } else
            T('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', r);
        }
    }
    function G0(e, r, c, g, x) {
      var R = e.memoizedState;
      R === null ? e.memoizedState = {
        isBackwards: r,
        rendering: null,
        renderingStartTime: 0,
        last: g,
        tail: c,
        tailMode: x
      } : (R.isBackwards = r, R.rendering = null, R.renderingStartTime = 0, R.last = g, R.tail = c, R.tailMode = x);
    }
    function SC(e, r, c) {
      var g = r.pendingProps, x = g.revealOrder, R = g.tail, _ = g.children;
      uO(x), cO(R, x), dO(_, x), aa(e, r, _, c);
      var Y = Ps.current, W = r0(Y, Cp);
      if (W)
        Y = i0(Y, Cp), r.flags |= Xt;
      else {
        var J = e !== null && (e.flags & Xt) !== _t;
        J && oO(r, r.child, c), Y = vf(Y);
      }
      if (yu(r, Y), (r.mode & nn) === Nt)
        r.memoizedState = null;
      else
        switch (x) {
          case "forwards": {
            var ne = lO(r.child), ge;
            ne === null ? (ge = r.child, r.child = null) : (ge = ne.sibling, ne.sibling = null), G0(
              r,
              !1,
              // isBackwards
              ge,
              ne,
              R
            );
            break;
          }
          case "backwards": {
            var he = null, Ce = r.child;
            for (r.child = null; Ce !== null; ) {
              var Ae = Ce.alternate;
              if (Ae !== null && Mm(Ae) === null) {
                r.child = Ce;
                break;
              }
              var De = Ce.sibling;
              Ce.sibling = he, he = Ce, Ce = De;
            }
            G0(
              r,
              !0,
              // isBackwards
              he,
              null,
              // last
              R
            );
            break;
          }
          case "together": {
            G0(
              r,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            r.memoizedState = null;
        }
      return r.child;
    }
    function fO(e, r, c) {
      e0(r, r.stateNode.containerInfo);
      var g = r.pendingProps;
      return e === null ? r.child = pf(r, null, g, c) : aa(e, r, g, c), r.child;
    }
    var kC = !1;
    function hO(e, r, c) {
      var g = r.type, x = g._context, R = r.pendingProps, _ = r.memoizedProps, Y = R.value;
      {
        "value" in R || kC || (kC = !0, T("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var W = r.type.propTypes;
        W && Ms(W, R, "prop", "Context.Provider");
      }
      if (ck(r, x, Y), _ !== null) {
        var J = _.value;
        if (xt(J, Y)) {
          if (_.children === R.children && !sm())
            return pl(e, r, c);
        } else
          oD(r, x, c);
      }
      var ne = R.children;
      return aa(e, r, ne, c), r.child;
    }
    var CC = !1;
    function pO(e, r, c) {
      var g = r.type;
      g._context === void 0 ? g !== g.Consumer && (CC || (CC = !0, T("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : g = g._context;
      var x = r.pendingProps, R = x.children;
      typeof R != "function" && T("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), hf(r, c);
      var _ = Fr(g);
      oo(r);
      var Y;
      return Op.current = r, Na(!0), Y = R(_), Na(!1), Uo(), r.flags |= eo, aa(e, r, Y, c), r.child;
    }
    function Pp() {
      zs = !0;
    }
    function Km(e, r) {
      (r.mode & nn) === Nt && e !== null && (e.alternate = null, r.alternate = null, r.flags |= Bn);
    }
    function pl(e, r, c) {
      return e !== null && (r.dependencies = e.dependencies), aC(), Vp(r.lanes), Hi(c, r.childLanes) ? (xD(e, r), r.child) : null;
    }
    function gO(e, r, c) {
      {
        var g = r.return;
        if (g === null)
          throw new Error("Cannot swap the root fiber.");
        if (e.alternate = null, r.alternate = null, c.index = r.index, c.sibling = r.sibling, c.return = r.return, c.ref = r.ref, r === g.child)
          g.child = c;
        else {
          var x = g.child;
          if (x === null)
            throw new Error("Expected parent to have a child.");
          for (; x.sibling !== r; )
            if (x = x.sibling, x === null)
              throw new Error("Expected to find the previous sibling.");
          x.sibling = c;
        }
        var R = g.deletions;
        return R === null ? (g.deletions = [e], g.flags |= Sn) : R.push(e), c.flags |= Bn, c;
      }
    }
    function $0(e, r) {
      var c = e.lanes;
      return !!Hi(c, r);
    }
    function vO(e, r, c) {
      switch (r.tag) {
        case q:
          vC(r), r.stateNode, df();
          break;
        case se:
          Lk(r);
          break;
        case U: {
          var g = r.type;
          xo(g) && lm(r);
          break;
        }
        case te:
          e0(r, r.stateNode.containerInfo);
          break;
        case Q: {
          var x = r.memoizedProps.value, R = r.type._context;
          ck(r, R, x);
          break;
        }
        case Ee:
          {
            var _ = Hi(c, r.childLanes);
            _ && (r.flags |= Jt);
            {
              var Y = r.stateNode;
              Y.effectDuration = 0, Y.passiveEffectDuration = 0;
            }
          }
          break;
        case re: {
          var W = r.memoizedState;
          if (W !== null) {
            if (W.dehydrated !== null)
              return yu(r, vf(Ps.current)), r.flags |= Xt, null;
            var J = r.child, ne = J.childLanes;
            if (Hi(c, ne))
              return yC(e, r, c);
            yu(r, vf(Ps.current));
            var ge = pl(e, r, c);
            return ge !== null ? ge.sibling : null;
          } else
            yu(r, vf(Ps.current));
          break;
        }
        case ft: {
          var he = (e.flags & Xt) !== _t, Ce = Hi(c, r.childLanes);
          if (he) {
            if (Ce)
              return SC(e, r, c);
            r.flags |= Xt;
          }
          var Ae = r.memoizedState;
          if (Ae !== null && (Ae.rendering = null, Ae.tail = null, Ae.lastEffect = null), yu(r, Ps.current), Ce)
            break;
          return null;
        }
        case st:
        case it:
          return r.lanes = Pe, hC(e, r, c);
      }
      return pl(e, r, c);
    }
    function AC(e, r, c) {
      if (r._debugNeedsRemount && e !== null)
        return gO(e, r, Cw(r.type, r.key, r.pendingProps, r._debugOwner || null, r.mode, r.lanes));
      if (e !== null) {
        var g = e.memoizedProps, x = r.pendingProps;
        if (g !== x || sm() || // Force a re-render if the implementation changed due to hot reload:
        r.type !== e.type)
          zs = !0;
        else {
          var R = $0(e, c);
          if (!R && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (r.flags & Xt) === _t)
            return zs = !1, vO(e, r, c);
          (e.flags & Qu) !== _t ? zs = !0 : zs = !1;
        }
      } else if (zs = !1, Si() && UM(r)) {
        var _ = r.index, Y = BM();
        KS(r, Y, _);
      }
      switch (r.lanes = Pe, r.tag) {
        case $:
          return QD(e, r, r.type, c);
        case Qe: {
          var W = r.elementType;
          return qD(e, r, W, c);
        }
        case H: {
          var J = r.type, ne = r.pendingProps, ge = r.elementType === J ? ne : _s(J, ne);
          return H0(e, r, J, ge, c);
        }
        case U: {
          var he = r.type, Ce = r.pendingProps, Ae = r.elementType === he ? Ce : _s(he, Ce);
          return gC(e, r, he, Ae, c);
        }
        case q:
          return VD(e, r, c);
        case se:
          return GD(e, r, c);
        case ae:
          return $D(e, r);
        case re:
          return yC(e, r, c);
        case te:
          return fO(e, r, c);
        case we: {
          var De = r.type, ct = r.pendingProps, Pt = r.elementType === De ? ct : _s(De, ct);
          return cC(e, r, De, Pt, c);
        }
        case ue:
          return BD(e, r, c);
        case Re:
          return WD(e, r, c);
        case Ee:
          return XD(e, r, c);
        case Q:
          return hO(e, r, c);
        case Ne:
          return pO(e, r, c);
        case ve: {
          var Tt = r.type, hn = r.pendingProps, on = _s(Tt, hn);
          if (r.type !== r.elementType) {
            var xe = Tt.propTypes;
            xe && Ms(
              xe,
              on,
              // Resolved for outer only
              "prop",
              mt(Tt)
            );
          }
          return on = _s(Tt.type, on), dC(e, r, Tt, on, c);
        }
        case Le:
          return fC(e, r, r.type, r.pendingProps, c);
        case Be: {
          var Oe = r.type, be = r.pendingProps, Xe = r.elementType === Oe ? be : _s(Oe, be);
          return ZD(e, r, Oe, Xe, c);
        }
        case ft:
          return SC(e, r, c);
        case wt:
          break;
        case st:
          return hC(e, r, c);
      }
      throw new Error("Unknown unit of work tag (" + r.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Sf(e) {
      e.flags |= Jt;
    }
    function TC(e) {
      e.flags |= _i, e.flags |= gh;
    }
    var EC, q0, RC, LC;
    EC = function(e, r, c, g) {
      for (var x = r.child; x !== null; ) {
        if (x.tag === se || x.tag === ae)
          YL(e, x.stateNode);
        else if (x.tag !== te) {
          if (x.child !== null) {
            x.child.return = x, x = x.child;
            continue;
          }
        }
        if (x === r)
          return;
        for (; x.sibling === null; ) {
          if (x.return === null || x.return === r)
            return;
          x = x.return;
        }
        x.sibling.return = x.return, x = x.sibling;
      }
    }, q0 = function(e, r) {
    }, RC = function(e, r, c, g, x) {
      var R = e.memoizedProps;
      if (R !== g) {
        var _ = r.stateNode, Y = t0(), W = jL(_, c, R, g, x, Y);
        r.updateQueue = W, W && Sf(r);
      }
    }, LC = function(e, r, c, g) {
      c !== g && Sf(r);
    };
    function Np(e, r) {
      if (!Si())
        switch (e.tailMode) {
          case "hidden": {
            for (var c = e.tail, g = null; c !== null; )
              c.alternate !== null && (g = c), c = c.sibling;
            g === null ? e.tail = null : g.sibling = null;
            break;
          }
          case "collapsed": {
            for (var x = e.tail, R = null; x !== null; )
              x.alternate !== null && (R = x), x = x.sibling;
            R === null ? !r && e.tail !== null ? e.tail.sibling = null : e.tail = null : R.sibling = null;
            break;
          }
        }
    }
    function Ci(e) {
      var r = e.alternate !== null && e.alternate.child === e.child, c = Pe, g = _t;
      if (r) {
        if ((e.mode & Ft) !== Nt) {
          for (var W = e.selfBaseDuration, J = e.child; J !== null; )
            c = en(c, en(J.lanes, J.childLanes)), g |= J.subtreeFlags & Ur, g |= J.flags & Ur, W += J.treeBaseDuration, J = J.sibling;
          e.treeBaseDuration = W;
        } else
          for (var ne = e.child; ne !== null; )
            c = en(c, en(ne.lanes, ne.childLanes)), g |= ne.subtreeFlags & Ur, g |= ne.flags & Ur, ne.return = e, ne = ne.sibling;
        e.subtreeFlags |= g;
      } else {
        if ((e.mode & Ft) !== Nt) {
          for (var x = e.actualDuration, R = e.selfBaseDuration, _ = e.child; _ !== null; )
            c = en(c, en(_.lanes, _.childLanes)), g |= _.subtreeFlags, g |= _.flags, x += _.actualDuration, R += _.treeBaseDuration, _ = _.sibling;
          e.actualDuration = x, e.treeBaseDuration = R;
        } else
          for (var Y = e.child; Y !== null; )
            c = en(c, en(Y.lanes, Y.childLanes)), g |= Y.subtreeFlags, g |= Y.flags, Y.return = e, Y = Y.sibling;
        e.subtreeFlags |= g;
      }
      return e.childLanes = c, r;
    }
    function mO(e, r, c) {
      if (nD() && (r.mode & nn) !== Nt && (r.flags & Xt) === _t)
        return ak(r), df(), r.flags |= sr | Ji | _r, !1;
      var g = hm(r);
      if (c !== null && c.dehydrated !== null)
        if (e === null) {
          if (!g)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (eD(r), Ci(r), (r.mode & Ft) !== Nt) {
            var x = c !== null;
            if (x) {
              var R = r.child;
              R !== null && (r.treeBaseDuration -= R.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (df(), (r.flags & Xt) === _t && (r.memoizedState = null), r.flags |= Jt, Ci(r), (r.mode & Ft) !== Nt) {
            var _ = c !== null;
            if (_) {
              var Y = r.child;
              Y !== null && (r.treeBaseDuration -= Y.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return sk(), !0;
    }
    function MC(e, r, c) {
      var g = r.pendingProps;
      switch (wb(r), r.tag) {
        case $:
        case Qe:
        case Le:
        case H:
        case we:
        case ue:
        case Re:
        case Ee:
        case Ne:
        case ve:
          return Ci(r), null;
        case U: {
          var x = r.type;
          return xo(x) && om(r), Ci(r), null;
        }
        case q: {
          var R = r.stateNode;
          if (gf(r), mb(r), s0(), R.pendingContext && (R.context = R.pendingContext, R.pendingContext = null), e === null || e.child === null) {
            var _ = hm(r);
            if (_)
              Sf(r);
            else if (e !== null) {
              var Y = e.memoizedState;
              // Check if this is a client root
              (!Y.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (r.flags & sr) !== _t) && (r.flags |= pa, sk());
            }
          }
          return q0(e, r), Ci(r), null;
        }
        case se: {
          n0(r);
          var W = Rk(), J = r.type;
          if (e !== null && r.stateNode != null)
            RC(e, r, J, g, W), e.ref !== r.ref && TC(r);
          else {
            if (!g) {
              if (r.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Ci(r), null;
            }
            var ne = t0(), ge = hm(r);
            if (ge)
              KM(r, W, ne) && Sf(r);
            else {
              var he = FL(J, g, W, ne, r);
              EC(he, r, !1, !1), r.stateNode = he, HL(he, J, g, W) && Sf(r);
            }
            r.ref !== null && TC(r);
          }
          return Ci(r), null;
        }
        case ae: {
          var Ce = g;
          if (e && r.stateNode != null) {
            var Ae = e.memoizedProps;
            LC(e, r, Ae, Ce);
          } else {
            if (typeof Ce != "string" && r.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var De = Rk(), ct = t0(), Pt = hm(r);
            Pt ? JM(r) && Sf(r) : r.stateNode = UL(Ce, De, ct, r);
          }
          return Ci(r), null;
        }
        case re: {
          mf(r);
          var Tt = r.memoizedState;
          if (e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
            var hn = mO(e, r, Tt);
            if (!hn)
              return r.flags & _r ? r : null;
          }
          if ((r.flags & Xt) !== _t)
            return r.lanes = c, (r.mode & Ft) !== Nt && D0(r), r;
          var on = Tt !== null, xe = e !== null && e.memoizedState !== null;
          if (on !== xe && on) {
            var Oe = r.child;
            if (Oe.flags |= to, (r.mode & nn) !== Nt) {
              var be = e === null && (r.memoizedProps.unstable_avoidThisFallback !== !0 || !je);
              be || r0(Ps.current, Dk) ? y2() : hw();
            }
          }
          var Xe = r.updateQueue;
          if (Xe !== null && (r.flags |= Jt), Ci(r), (r.mode & Ft) !== Nt && on) {
            var dt = r.child;
            dt !== null && (r.treeBaseDuration -= dt.treeBaseDuration);
          }
          return null;
        }
        case te:
          return gf(r), q0(e, r), e === null && NM(r.stateNode.containerInfo), Ci(r), null;
        case Q:
          var at = r.type._context;
          return Mb(at, r), Ci(r), null;
        case Be: {
          var Wt = r.type;
          return xo(Wt) && om(r), Ci(r), null;
        }
        case ft: {
          mf(r);
          var $t = r.memoizedState;
          if ($t === null)
            return Ci(r), null;
          var _n = (r.flags & Xt) !== _t, mn = $t.rendering;
          if (mn === null)
            if (_n)
              Np($t, !1);
            else {
              var Er = b2() && (e === null || (e.flags & Xt) === _t);
              if (!Er)
                for (var yn = r.child; yn !== null; ) {
                  var br = Mm(yn);
                  if (br !== null) {
                    _n = !0, r.flags |= Xt, Np($t, !1);
                    var Wi = br.updateQueue;
                    return Wi !== null && (r.updateQueue = Wi, r.flags |= Jt), r.subtreeFlags = _t, bD(r, c), yu(r, i0(Ps.current, Cp)), r.child;
                  }
                  yn = yn.sibling;
                }
              $t.tail !== null && Qn() > QC() && (r.flags |= Xt, _n = !0, Np($t, !1), r.lanes = Rh);
            }
          else {
            if (!_n) {
              var Li = Mm(mn);
              if (Li !== null) {
                r.flags |= Xt, _n = !0;
                var Ba = Li.updateQueue;
                if (Ba !== null && (r.updateQueue = Ba, r.flags |= Jt), Np($t, !0), $t.tail === null && $t.tailMode === "hidden" && !mn.alternate && !Si())
                  return Ci(r), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                Qn() * 2 - $t.renderingStartTime > QC() && c !== Yi && (r.flags |= Xt, _n = !0, Np($t, !1), r.lanes = Rh);
            }
            if ($t.isBackwards)
              mn.sibling = r.child, r.child = mn;
            else {
              var la = $t.last;
              la !== null ? la.sibling = mn : r.child = mn, $t.last = mn;
            }
          }
          if ($t.tail !== null) {
            var ua = $t.tail;
            $t.rendering = ua, $t.tail = ua.sibling, $t.renderingStartTime = Qn(), ua.sibling = null;
            var Xi = Ps.current;
            return _n ? Xi = i0(Xi, Cp) : Xi = vf(Xi), yu(r, Xi), ua;
          }
          return Ci(r), null;
        }
        case wt:
          break;
        case st:
        case it: {
          fw(r);
          var xl = r.memoizedState, Mf = xl !== null;
          if (e !== null) {
            var Qp = e.memoizedState, Eo = Qp !== null;
            Eo !== Mf && // LegacyHidden doesn't do any hiding — it only pre-renders.
            !ye && (r.flags |= to);
          }
          return !Mf || (r.mode & nn) === Nt ? Ci(r) : Hi(To, Yi) && (Ci(r), r.subtreeFlags & (Bn | Jt) && (r.flags |= to)), null;
        }
        case Ht:
          return null;
        case Mt:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + r.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function yO(e, r, c) {
      switch (wb(r), r.tag) {
        case U: {
          var g = r.type;
          xo(g) && om(r);
          var x = r.flags;
          return x & _r ? (r.flags = x & ~_r | Xt, (r.mode & Ft) !== Nt && D0(r), r) : null;
        }
        case q: {
          r.stateNode, gf(r), mb(r), s0();
          var R = r.flags;
          return (R & _r) !== _t && (R & Xt) === _t ? (r.flags = R & ~_r | Xt, r) : null;
        }
        case se:
          return n0(r), null;
        case re: {
          mf(r);
          var _ = r.memoizedState;
          if (_ !== null && _.dehydrated !== null) {
            if (r.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            df();
          }
          var Y = r.flags;
          return Y & _r ? (r.flags = Y & ~_r | Xt, (r.mode & Ft) !== Nt && D0(r), r) : null;
        }
        case ft:
          return mf(r), null;
        case te:
          return gf(r), null;
        case Q:
          var W = r.type._context;
          return Mb(W, r), null;
        case st:
        case it:
          return fw(r), null;
        case Ht:
          return null;
        default:
          return null;
      }
    }
    function DC(e, r, c) {
      switch (wb(r), r.tag) {
        case U: {
          var g = r.type.childContextTypes;
          g != null && om(r);
          break;
        }
        case q: {
          r.stateNode, gf(r), mb(r), s0();
          break;
        }
        case se: {
          n0(r);
          break;
        }
        case te:
          gf(r);
          break;
        case re:
          mf(r);
          break;
        case ft:
          mf(r);
          break;
        case Q:
          var x = r.type._context;
          Mb(x, r);
          break;
        case st:
        case it:
          fw(r);
          break;
      }
    }
    var OC = null;
    OC = /* @__PURE__ */ new Set();
    var Jm = !1, Ai = !1, xO = typeof WeakSet == "function" ? WeakSet : Set, bt = null, kf = null, Cf = null;
    function bO(e) {
      Ho(null, function() {
        throw e;
      }), hh();
    }
    var wO = function(e, r) {
      if (r.props = e.memoizedProps, r.state = e.memoizedState, e.mode & Ft)
        try {
          Co(), r.componentWillUnmount();
        } finally {
          ko(e);
        }
      else
        r.componentWillUnmount();
    };
    function _C(e, r) {
      try {
        wu(Vr, e);
      } catch (c) {
        Gn(e, r, c);
      }
    }
    function Z0(e, r, c) {
      try {
        wO(e, c);
      } catch (g) {
        Gn(e, r, g);
      }
    }
    function SO(e, r, c) {
      try {
        c.componentDidMount();
      } catch (g) {
        Gn(e, r, g);
      }
    }
    function PC(e, r) {
      try {
        zC(e);
      } catch (c) {
        Gn(e, r, c);
      }
    }
    function Af(e, r) {
      var c = e.ref;
      if (c !== null)
        if (typeof c == "function") {
          var g;
          try {
            if (ot && It && e.mode & Ft)
              try {
                Co(), g = c(null);
              } finally {
                ko(e);
              }
            else
              g = c(null);
          } catch (x) {
            Gn(e, r, x);
          }
          typeof g == "function" && T("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", gt(e));
        } else
          c.current = null;
    }
    function ey(e, r, c) {
      try {
        c();
      } catch (g) {
        Gn(e, r, g);
      }
    }
    var NC = !1;
    function kO(e, r) {
      zL(e.containerInfo), bt = r, CO();
      var c = NC;
      return NC = !1, c;
    }
    function CO() {
      for (; bt !== null; ) {
        var e = bt, r = e.child;
        (e.subtreeFlags & jl) !== _t && r !== null ? (r.return = e, bt = r) : AO();
      }
    }
    function AO() {
      for (; bt !== null; ) {
        var e = bt;
        wn(e);
        try {
          TO(e);
        } catch (c) {
          Gn(e, e.return, c);
        }
        ln();
        var r = e.sibling;
        if (r !== null) {
          r.return = e.return, bt = r;
          return;
        }
        bt = e.return;
      }
    }
    function TO(e) {
      var r = e.alternate, c = e.flags;
      if ((c & pa) !== _t) {
        switch (wn(e), e.tag) {
          case H:
          case we:
          case Le:
            break;
          case U: {
            if (r !== null) {
              var g = r.memoizedProps, x = r.memoizedState, R = e.stateNode;
              e.type === e.elementType && !Mc && (R.props !== e.memoizedProps && T("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", gt(e) || "instance"), R.state !== e.memoizedState && T("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", gt(e) || "instance"));
              var _ = R.getSnapshotBeforeUpdate(e.elementType === e.type ? g : _s(e.type, g), x);
              {
                var Y = OC;
                _ === void 0 && !Y.has(e.type) && (Y.add(e.type), T("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", gt(e)));
              }
              R.__reactInternalSnapshotBeforeUpdate = _;
            }
            break;
          }
          case q: {
            {
              var W = e.stateNode;
              oM(W.containerInfo);
            }
            break;
          }
          case se:
          case ae:
          case te:
          case Be:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        ln();
      }
    }
    function Is(e, r, c) {
      var g = r.updateQueue, x = g !== null ? g.lastEffect : null;
      if (x !== null) {
        var R = x.next, _ = R;
        do {
          if ((_.tag & e) === e) {
            var Y = _.destroy;
            _.destroy = void 0, Y !== void 0 && ((e & ki) !== Ta ? hd(r) : (e & Vr) !== Ta && pd(r), (e & bo) !== Ta && $p(!0), ey(r, c, Y), (e & bo) !== Ta && $p(!1), (e & ki) !== Ta ? fv() : (e & Vr) !== Ta && Ul());
          }
          _ = _.next;
        } while (_ !== R);
      }
    }
    function wu(e, r) {
      var c = r.updateQueue, g = c !== null ? c.lastEffect : null;
      if (g !== null) {
        var x = g.next, R = x;
        do {
          if ((R.tag & e) === e) {
            (e & ki) !== Ta ? dv(r) : (e & Vr) !== Ta && hv(r);
            var _ = R.create;
            (e & bo) !== Ta && $p(!0), R.destroy = _(), (e & bo) !== Ta && $p(!1), (e & ki) !== Ta ? Ah() : (e & Vr) !== Ta && pv();
            {
              var Y = R.destroy;
              if (Y !== void 0 && typeof Y != "function") {
                var W = void 0;
                (R.tag & Vr) !== _t ? W = "useLayoutEffect" : (R.tag & bo) !== _t ? W = "useInsertionEffect" : W = "useEffect";
                var J = void 0;
                Y === null ? J = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof Y.then == "function" ? J = `

It looks like you wrote ` + W + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + W + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : J = " You returned: " + Y, T("%s must not return anything besides a function, which is used for clean-up.%s", W, J);
              }
            }
          }
          R = R.next;
        } while (R !== x);
      }
    }
    function EO(e, r) {
      if ((r.flags & Jt) !== _t)
        switch (r.tag) {
          case Ee: {
            var c = r.stateNode.passiveEffectDuration, g = r.memoizedProps, x = g.id, R = g.onPostCommit, _ = rC(), Y = r.alternate === null ? "mount" : "update";
            nC() && (Y = "nested-update"), typeof R == "function" && R(x, Y, c, _);
            var W = r.return;
            e:
              for (; W !== null; ) {
                switch (W.tag) {
                  case q:
                    var J = W.stateNode;
                    J.passiveEffectDuration += c;
                    break e;
                  case Ee:
                    var ne = W.stateNode;
                    ne.passiveEffectDuration += c;
                    break e;
                }
                W = W.return;
              }
            break;
          }
        }
    }
    function RO(e, r, c, g) {
      if ((c.flags & li) !== _t)
        switch (c.tag) {
          case H:
          case we:
          case Le: {
            if (!Ai)
              if (c.mode & Ft)
                try {
                  Co(), wu(Vr | Xr, c);
                } finally {
                  ko(c);
                }
              else
                wu(Vr | Xr, c);
            break;
          }
          case U: {
            var x = c.stateNode;
            if (c.flags & Jt && !Ai)
              if (r === null)
                if (c.type === c.elementType && !Mc && (x.props !== c.memoizedProps && T("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", gt(c) || "instance"), x.state !== c.memoizedState && T("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", gt(c) || "instance")), c.mode & Ft)
                  try {
                    Co(), x.componentDidMount();
                  } finally {
                    ko(c);
                  }
                else
                  x.componentDidMount();
              else {
                var R = c.elementType === c.type ? r.memoizedProps : _s(c.type, r.memoizedProps), _ = r.memoizedState;
                if (c.type === c.elementType && !Mc && (x.props !== c.memoizedProps && T("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", gt(c) || "instance"), x.state !== c.memoizedState && T("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", gt(c) || "instance")), c.mode & Ft)
                  try {
                    Co(), x.componentDidUpdate(R, _, x.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    ko(c);
                  }
                else
                  x.componentDidUpdate(R, _, x.__reactInternalSnapshotBeforeUpdate);
              }
            var Y = c.updateQueue;
            Y !== null && (c.type === c.elementType && !Mc && (x.props !== c.memoizedProps && T("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", gt(c) || "instance"), x.state !== c.memoizedState && T("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", gt(c) || "instance")), vk(c, Y, x));
            break;
          }
          case q: {
            var W = c.updateQueue;
            if (W !== null) {
              var J = null;
              if (c.child !== null)
                switch (c.child.tag) {
                  case se:
                    J = c.child.stateNode;
                    break;
                  case U:
                    J = c.child.stateNode;
                    break;
                }
              vk(c, W, J);
            }
            break;
          }
          case se: {
            var ne = c.stateNode;
            if (r === null && c.flags & Jt) {
              var ge = c.type, he = c.memoizedProps;
              GL(ne, ge, he);
            }
            break;
          }
          case ae:
            break;
          case te:
            break;
          case Ee: {
            {
              var Ce = c.memoizedProps, Ae = Ce.onCommit, De = Ce.onRender, ct = c.stateNode.effectDuration, Pt = rC(), Tt = r === null ? "mount" : "update";
              nC() && (Tt = "nested-update"), typeof De == "function" && De(c.memoizedProps.id, Tt, c.actualDuration, c.treeBaseDuration, c.actualStartTime, Pt);
              {
                typeof Ae == "function" && Ae(c.memoizedProps.id, Tt, ct, Pt), A2(c);
                var hn = c.return;
                e:
                  for (; hn !== null; ) {
                    switch (hn.tag) {
                      case q:
                        var on = hn.stateNode;
                        on.effectDuration += ct;
                        break e;
                      case Ee:
                        var xe = hn.stateNode;
                        xe.effectDuration += ct;
                        break e;
                    }
                    hn = hn.return;
                  }
              }
            }
            break;
          }
          case re: {
            zO(e, c);
            break;
          }
          case ft:
          case Be:
          case wt:
          case st:
          case it:
          case Mt:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Ai || c.flags & _i && zC(c);
    }
    function LO(e) {
      switch (e.tag) {
        case H:
        case we:
        case Le: {
          if (e.mode & Ft)
            try {
              Co(), _C(e, e.return);
            } finally {
              ko(e);
            }
          else
            _C(e, e.return);
          break;
        }
        case U: {
          var r = e.stateNode;
          typeof r.componentDidMount == "function" && SO(e, e.return, r), PC(e, e.return);
          break;
        }
        case se: {
          PC(e, e.return);
          break;
        }
      }
    }
    function MO(e, r) {
      for (var c = null, g = e; ; ) {
        if (g.tag === se) {
          if (c === null) {
            c = g;
            try {
              var x = g.stateNode;
              r ? rM(x) : aM(g.stateNode, g.memoizedProps);
            } catch (_) {
              Gn(e, e.return, _);
            }
          }
        } else if (g.tag === ae) {
          if (c === null)
            try {
              var R = g.stateNode;
              r ? iM(R) : sM(R, g.memoizedProps);
            } catch (_) {
              Gn(e, e.return, _);
            }
        } else if (!((g.tag === st || g.tag === it) && g.memoizedState !== null && g !== e)) {
          if (g.child !== null) {
            g.child.return = g, g = g.child;
            continue;
          }
        }
        if (g === e)
          return;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === e)
            return;
          c === g && (c = null), g = g.return;
        }
        c === g && (c = null), g.sibling.return = g.return, g = g.sibling;
      }
    }
    function zC(e) {
      var r = e.ref;
      if (r !== null) {
        var c = e.stateNode, g;
        switch (e.tag) {
          case se:
            g = c;
            break;
          default:
            g = c;
        }
        if (typeof r == "function") {
          var x;
          if (e.mode & Ft)
            try {
              Co(), x = r(g);
            } finally {
              ko(e);
            }
          else
            x = r(g);
          typeof x == "function" && T("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", gt(e));
        } else
          r.hasOwnProperty("current") || T("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", gt(e)), r.current = g;
      }
    }
    function DO(e) {
      var r = e.alternate;
      r !== null && (r.return = null), e.return = null;
    }
    function IC(e) {
      var r = e.alternate;
      r !== null && (e.alternate = null, IC(r));
      {
        if (e.child = null, e.deletions = null, e.sibling = null, e.tag === se) {
          var c = e.stateNode;
          c !== null && FM(c);
        }
        e.stateNode = null, e._debugOwner = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
      }
    }
    function OO(e) {
      for (var r = e.return; r !== null; ) {
        if (FC(r))
          return r;
        r = r.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function FC(e) {
      return e.tag === se || e.tag === q || e.tag === te;
    }
    function YC(e) {
      var r = e;
      e:
        for (; ; ) {
          for (; r.sibling === null; ) {
            if (r.return === null || FC(r.return))
              return null;
            r = r.return;
          }
          for (r.sibling.return = r.return, r = r.sibling; r.tag !== se && r.tag !== ae && r.tag !== Ge; ) {
            if (r.flags & Bn || r.child === null || r.tag === te)
              continue e;
            r.child.return = r, r = r.child;
          }
          if (!(r.flags & Bn))
            return r.stateNode;
        }
    }
    function _O(e) {
      var r = OO(e);
      switch (r.tag) {
        case se: {
          var c = r.stateNode;
          r.flags & An && (HS(c), r.flags &= ~An);
          var g = YC(e);
          K0(e, g, c);
          break;
        }
        case q:
        case te: {
          var x = r.stateNode.containerInfo, R = YC(e);
          Q0(e, R, x);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function Q0(e, r, c) {
      var g = e.tag, x = g === se || g === ae;
      if (x) {
        var R = e.stateNode;
        r ? JL(c, R, r) : QL(c, R);
      } else if (g !== te) {
        var _ = e.child;
        if (_ !== null) {
          Q0(_, r, c);
          for (var Y = _.sibling; Y !== null; )
            Q0(Y, r, c), Y = Y.sibling;
        }
      }
    }
    function K0(e, r, c) {
      var g = e.tag, x = g === se || g === ae;
      if (x) {
        var R = e.stateNode;
        r ? KL(c, R, r) : ZL(c, R);
      } else if (g !== te) {
        var _ = e.child;
        if (_ !== null) {
          K0(_, r, c);
          for (var Y = _.sibling; Y !== null; )
            K0(Y, r, c), Y = Y.sibling;
        }
      }
    }
    var Ti = null, Fs = !1;
    function PO(e, r, c) {
      {
        var g = r;
        e:
          for (; g !== null; ) {
            switch (g.tag) {
              case se: {
                Ti = g.stateNode, Fs = !1;
                break e;
              }
              case q: {
                Ti = g.stateNode.containerInfo, Fs = !0;
                break e;
              }
              case te: {
                Ti = g.stateNode.containerInfo, Fs = !0;
                break e;
              }
            }
            g = g.return;
          }
        if (Ti === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        HC(e, r, c), Ti = null, Fs = !1;
      }
      DO(c);
    }
    function Su(e, r, c) {
      for (var g = c.child; g !== null; )
        HC(e, r, g), g = g.sibling;
    }
    function HC(e, r, c) {
      switch (kh(c), c.tag) {
        case se:
          Ai || Af(c, r);
        case ae: {
          {
            var g = Ti, x = Fs;
            Ti = null, Su(e, r, c), Ti = g, Fs = x, Ti !== null && (Fs ? tM(Ti, c.stateNode) : eM(Ti, c.stateNode));
          }
          return;
        }
        case Ge: {
          Ti !== null && (Fs ? nM(Ti, c.stateNode) : ub(Ti, c.stateNode));
          return;
        }
        case te: {
          {
            var R = Ti, _ = Fs;
            Ti = c.stateNode.containerInfo, Fs = !0, Su(e, r, c), Ti = R, Fs = _;
          }
          return;
        }
        case H:
        case we:
        case ve:
        case Le: {
          if (!Ai) {
            var Y = c.updateQueue;
            if (Y !== null) {
              var W = Y.lastEffect;
              if (W !== null) {
                var J = W.next, ne = J;
                do {
                  var ge = ne, he = ge.destroy, Ce = ge.tag;
                  he !== void 0 && ((Ce & bo) !== Ta ? ey(c, r, he) : (Ce & Vr) !== Ta && (pd(c), c.mode & Ft ? (Co(), ey(c, r, he), ko(c)) : ey(c, r, he), Ul())), ne = ne.next;
                } while (ne !== J);
              }
            }
          }
          Su(e, r, c);
          return;
        }
        case U: {
          if (!Ai) {
            Af(c, r);
            var Ae = c.stateNode;
            typeof Ae.componentWillUnmount == "function" && Z0(c, r, Ae);
          }
          Su(e, r, c);
          return;
        }
        case wt: {
          Su(e, r, c);
          return;
        }
        case st: {
          if (
            // TODO: Remove this dead flag
            c.mode & nn
          ) {
            var De = Ai;
            Ai = De || c.memoizedState !== null, Su(e, r, c), Ai = De;
          } else
            Su(e, r, c);
          break;
        }
        default: {
          Su(e, r, c);
          return;
        }
      }
    }
    function NO(e) {
      e.memoizedState;
    }
    function zO(e, r) {
      var c = r.memoizedState;
      if (c === null) {
        var g = r.alternate;
        if (g !== null) {
          var x = g.memoizedState;
          if (x !== null) {
            var R = x.dehydrated;
            R !== null && wM(R);
          }
        }
      }
    }
    function jC(e) {
      var r = e.updateQueue;
      if (r !== null) {
        e.updateQueue = null;
        var c = e.stateNode;
        c === null && (c = e.stateNode = new xO()), r.forEach(function(g) {
          var x = O2.bind(null, e, g);
          if (!c.has(g)) {
            if (c.add(g), Br)
              if (kf !== null && Cf !== null)
                Gp(Cf, kf);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            g.then(x, x);
          }
        });
      }
    }
    function IO(e, r, c) {
      kf = c, Cf = e, wn(r), UC(r, e), wn(r), kf = null, Cf = null;
    }
    function Ys(e, r, c) {
      var g = r.deletions;
      if (g !== null)
        for (var x = 0; x < g.length; x++) {
          var R = g[x];
          try {
            PO(e, r, R);
          } catch (W) {
            Gn(R, r, W);
          }
        }
      var _ = lx();
      if (r.subtreeFlags & zi)
        for (var Y = r.child; Y !== null; )
          wn(Y), UC(Y, e), Y = Y.sibling;
      wn(_);
    }
    function UC(e, r, c) {
      var g = e.alternate, x = e.flags;
      switch (e.tag) {
        case H:
        case we:
        case ve:
        case Le: {
          if (Ys(r, e), Ao(e), x & Jt) {
            try {
              Is(bo | Xr, e, e.return), wu(bo | Xr, e);
            } catch (Wt) {
              Gn(e, e.return, Wt);
            }
            if (e.mode & Ft) {
              try {
                Co(), Is(Vr | Xr, e, e.return);
              } catch (Wt) {
                Gn(e, e.return, Wt);
              }
              ko(e);
            } else
              try {
                Is(Vr | Xr, e, e.return);
              } catch (Wt) {
                Gn(e, e.return, Wt);
              }
          }
          return;
        }
        case U: {
          Ys(r, e), Ao(e), x & _i && g !== null && Af(g, g.return);
          return;
        }
        case se: {
          Ys(r, e), Ao(e), x & _i && g !== null && Af(g, g.return);
          {
            if (e.flags & An) {
              var R = e.stateNode;
              try {
                HS(R);
              } catch (Wt) {
                Gn(e, e.return, Wt);
              }
            }
            if (x & Jt) {
              var _ = e.stateNode;
              if (_ != null) {
                var Y = e.memoizedProps, W = g !== null ? g.memoizedProps : Y, J = e.type, ne = e.updateQueue;
                if (e.updateQueue = null, ne !== null)
                  try {
                    $L(_, ne, J, W, Y, e);
                  } catch (Wt) {
                    Gn(e, e.return, Wt);
                  }
              }
            }
          }
          return;
        }
        case ae: {
          if (Ys(r, e), Ao(e), x & Jt) {
            if (e.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var ge = e.stateNode, he = e.memoizedProps, Ce = g !== null ? g.memoizedProps : he;
            try {
              qL(ge, Ce, he);
            } catch (Wt) {
              Gn(e, e.return, Wt);
            }
          }
          return;
        }
        case q: {
          if (Ys(r, e), Ao(e), x & Jt && g !== null) {
            var Ae = g.memoizedState;
            if (Ae.isDehydrated)
              try {
                bM(r.containerInfo);
              } catch (Wt) {
                Gn(e, e.return, Wt);
              }
          }
          return;
        }
        case te: {
          Ys(r, e), Ao(e);
          return;
        }
        case re: {
          Ys(r, e), Ao(e);
          var De = e.child;
          if (De.flags & to) {
            var ct = De.stateNode, Pt = De.memoizedState, Tt = Pt !== null;
            if (ct.isHidden = Tt, Tt) {
              var hn = De.alternate !== null && De.alternate.memoizedState !== null;
              hn || m2();
            }
          }
          if (x & Jt) {
            try {
              NO(e);
            } catch (Wt) {
              Gn(e, e.return, Wt);
            }
            jC(e);
          }
          return;
        }
        case st: {
          var on = g !== null && g.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            e.mode & nn
          ) {
            var xe = Ai;
            Ai = xe || on, Ys(r, e), Ai = xe;
          } else
            Ys(r, e);
          if (Ao(e), x & to) {
            var Oe = e.stateNode, be = e.memoizedState, Xe = be !== null, dt = e;
            if (Oe.isHidden = Xe, Xe && !on && (dt.mode & nn) !== Nt) {
              bt = dt;
              for (var at = dt.child; at !== null; )
                bt = at, YO(at), at = at.sibling;
            }
            MO(dt, Xe);
          }
          return;
        }
        case ft: {
          Ys(r, e), Ao(e), x & Jt && jC(e);
          return;
        }
        case wt:
          return;
        default: {
          Ys(r, e), Ao(e);
          return;
        }
      }
    }
    function Ao(e) {
      var r = e.flags;
      if (r & Bn) {
        try {
          _O(e);
        } catch (c) {
          Gn(e, e.return, c);
        }
        e.flags &= ~Bn;
      }
      r & ga && (e.flags &= ~ga);
    }
    function FO(e, r, c) {
      kf = c, Cf = r, bt = e, BC(e, r, c), kf = null, Cf = null;
    }
    function BC(e, r, c) {
      for (var g = (e.mode & nn) !== Nt; bt !== null; ) {
        var x = bt, R = x.child;
        if (x.tag === st && g) {
          var _ = x.memoizedState !== null, Y = _ || Jm;
          if (Y) {
            J0(e, r, c);
            continue;
          } else {
            var W = x.alternate, J = W !== null && W.memoizedState !== null, ne = J || Ai, ge = Jm, he = Ai;
            Jm = Y, Ai = ne, Ai && !he && (bt = x, HO(x));
            for (var Ce = R; Ce !== null; )
              bt = Ce, BC(
                Ce,
                // New root; bubble back up to here and stop.
                r,
                c
              ), Ce = Ce.sibling;
            bt = x, Jm = ge, Ai = he, J0(e, r, c);
            continue;
          }
        }
        (x.subtreeFlags & li) !== _t && R !== null ? (R.return = x, bt = R) : J0(e, r, c);
      }
    }
    function J0(e, r, c) {
      for (; bt !== null; ) {
        var g = bt;
        if ((g.flags & li) !== _t) {
          var x = g.alternate;
          wn(g);
          try {
            RO(r, x, g, c);
          } catch (_) {
            Gn(g, g.return, _);
          }
          ln();
        }
        if (g === e) {
          bt = null;
          return;
        }
        var R = g.sibling;
        if (R !== null) {
          R.return = g.return, bt = R;
          return;
        }
        bt = g.return;
      }
    }
    function YO(e) {
      for (; bt !== null; ) {
        var r = bt, c = r.child;
        switch (r.tag) {
          case H:
          case we:
          case ve:
          case Le: {
            if (r.mode & Ft)
              try {
                Co(), Is(Vr, r, r.return);
              } finally {
                ko(r);
              }
            else
              Is(Vr, r, r.return);
            break;
          }
          case U: {
            Af(r, r.return);
            var g = r.stateNode;
            typeof g.componentWillUnmount == "function" && Z0(r, r.return, g);
            break;
          }
          case se: {
            Af(r, r.return);
            break;
          }
          case st: {
            var x = r.memoizedState !== null;
            if (x) {
              WC(e);
              continue;
            }
            break;
          }
        }
        c !== null ? (c.return = r, bt = c) : WC(e);
      }
    }
    function WC(e) {
      for (; bt !== null; ) {
        var r = bt;
        if (r === e) {
          bt = null;
          return;
        }
        var c = r.sibling;
        if (c !== null) {
          c.return = r.return, bt = c;
          return;
        }
        bt = r.return;
      }
    }
    function HO(e) {
      for (; bt !== null; ) {
        var r = bt, c = r.child;
        if (r.tag === st) {
          var g = r.memoizedState !== null;
          if (g) {
            XC(e);
            continue;
          }
        }
        c !== null ? (c.return = r, bt = c) : XC(e);
      }
    }
    function XC(e) {
      for (; bt !== null; ) {
        var r = bt;
        wn(r);
        try {
          LO(r);
        } catch (g) {
          Gn(r, r.return, g);
        }
        if (ln(), r === e) {
          bt = null;
          return;
        }
        var c = r.sibling;
        if (c !== null) {
          c.return = r.return, bt = c;
          return;
        }
        bt = r.return;
      }
    }
    function jO(e, r, c, g) {
      bt = r, UO(r, e, c, g);
    }
    function UO(e, r, c, g) {
      for (; bt !== null; ) {
        var x = bt, R = x.child;
        (x.subtreeFlags & va) !== _t && R !== null ? (R.return = x, bt = R) : BO(e, r, c, g);
      }
    }
    function BO(e, r, c, g) {
      for (; bt !== null; ) {
        var x = bt;
        if ((x.flags & qn) !== _t) {
          wn(x);
          try {
            WO(r, x, c, g);
          } catch (_) {
            Gn(x, x.return, _);
          }
          ln();
        }
        if (x === e) {
          bt = null;
          return;
        }
        var R = x.sibling;
        if (R !== null) {
          R.return = x.return, bt = R;
          return;
        }
        bt = x.return;
      }
    }
    function WO(e, r, c, g) {
      switch (r.tag) {
        case H:
        case we:
        case Le: {
          if (r.mode & Ft) {
            M0();
            try {
              wu(ki | Xr, r);
            } finally {
              L0(r);
            }
          } else
            wu(ki | Xr, r);
          break;
        }
      }
    }
    function XO(e) {
      bt = e, VO();
    }
    function VO() {
      for (; bt !== null; ) {
        var e = bt, r = e.child;
        if ((bt.flags & Sn) !== _t) {
          var c = e.deletions;
          if (c !== null) {
            for (var g = 0; g < c.length; g++) {
              var x = c[g];
              bt = x, qO(x, e);
            }
            {
              var R = e.alternate;
              if (R !== null) {
                var _ = R.child;
                if (_ !== null) {
                  R.child = null;
                  do {
                    var Y = _.sibling;
                    _.sibling = null, _ = Y;
                  } while (_ !== null);
                }
              }
            }
            bt = e;
          }
        }
        (e.subtreeFlags & va) !== _t && r !== null ? (r.return = e, bt = r) : GO();
      }
    }
    function GO() {
      for (; bt !== null; ) {
        var e = bt;
        (e.flags & qn) !== _t && (wn(e), $O(e), ln());
        var r = e.sibling;
        if (r !== null) {
          r.return = e.return, bt = r;
          return;
        }
        bt = e.return;
      }
    }
    function $O(e) {
      switch (e.tag) {
        case H:
        case we:
        case Le: {
          e.mode & Ft ? (M0(), Is(ki | Xr, e, e.return), L0(e)) : Is(ki | Xr, e, e.return);
          break;
        }
      }
    }
    function qO(e, r) {
      for (; bt !== null; ) {
        var c = bt;
        wn(c), QO(c, r), ln();
        var g = c.child;
        g !== null ? (g.return = c, bt = g) : ZO(e);
      }
    }
    function ZO(e) {
      for (; bt !== null; ) {
        var r = bt, c = r.sibling, g = r.return;
        if (IC(r), r === e) {
          bt = null;
          return;
        }
        if (c !== null) {
          c.return = g, bt = c;
          return;
        }
        bt = g;
      }
    }
    function QO(e, r) {
      switch (e.tag) {
        case H:
        case we:
        case Le: {
          e.mode & Ft ? (M0(), Is(ki, e, r), L0(e)) : Is(ki, e, r);
          break;
        }
      }
    }
    function KO(e) {
      switch (e.tag) {
        case H:
        case we:
        case Le: {
          try {
            wu(Vr | Xr, e);
          } catch (c) {
            Gn(e, e.return, c);
          }
          break;
        }
        case U: {
          var r = e.stateNode;
          try {
            r.componentDidMount();
          } catch (c) {
            Gn(e, e.return, c);
          }
          break;
        }
      }
    }
    function JO(e) {
      switch (e.tag) {
        case H:
        case we:
        case Le: {
          try {
            wu(ki | Xr, e);
          } catch (r) {
            Gn(e, e.return, r);
          }
          break;
        }
      }
    }
    function e2(e) {
      switch (e.tag) {
        case H:
        case we:
        case Le: {
          try {
            Is(Vr | Xr, e, e.return);
          } catch (c) {
            Gn(e, e.return, c);
          }
          break;
        }
        case U: {
          var r = e.stateNode;
          typeof r.componentWillUnmount == "function" && Z0(e, e.return, r);
          break;
        }
      }
    }
    function t2(e) {
      switch (e.tag) {
        case H:
        case we:
        case Le:
          try {
            Is(ki | Xr, e, e.return);
          } catch (r) {
            Gn(e, e.return, r);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var zp = Symbol.for;
      zp("selector.component"), zp("selector.has_pseudo_class"), zp("selector.role"), zp("selector.test_id"), zp("selector.text");
    }
    var n2 = [];
    function r2() {
      n2.forEach(function(e) {
        return e();
      });
    }
    var i2 = h.ReactCurrentActQueue;
    function a2(e) {
      {
        var r = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), c = typeof jest < "u";
        return c && r !== !1;
      }
    }
    function VC() {
      {
        var e = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !e && i2.current !== null && T("The current testing environment is not configured to support act(...)"), e;
      }
    }
    var s2 = Math.ceil, ew = h.ReactCurrentDispatcher, tw = h.ReactCurrentOwner, Ei = h.ReactCurrentBatchConfig, Hs = h.ReactCurrentActQueue, qr = (
      /*             */
      0
    ), GC = (
      /*               */
      1
    ), Ri = (
      /*                */
      2
    ), is = (
      /*                */
      4
    ), gl = 0, Ip = 1, Dc = 2, ty = 3, Fp = 4, $C = 5, nw = 6, fn = qr, sa = null, fr = null, Zr = Pe, To = Pe, rw = fu(Pe), Qr = gl, Yp = null, ny = Pe, Hp = Pe, ry = Pe, jp = null, Ea = null, iw = 0, qC = 500, ZC = 1 / 0, o2 = 500, vl = null;
    function Up() {
      ZC = Qn() + o2;
    }
    function QC() {
      return ZC;
    }
    var iy = !1, aw = null, Tf = null, Oc = !1, ku = null, Bp = Pe, sw = [], ow = null, l2 = 50, Wp = 0, lw = null, uw = !1, ay = !1, u2 = 50, Ef = 0, sy = null, Xp = Fn, oy = Pe, KC = !1;
    function ly() {
      return sa;
    }
    function oa() {
      return (fn & (Ri | is)) !== qr ? Qn() : (Xp !== Fn || (Xp = Qn()), Xp);
    }
    function Cu(e) {
      var r = e.mode;
      if ((r & nn) === Nt)
        return Yt;
      if ((fn & Ri) !== qr && Zr !== Pe)
        return kr(Zr);
      var c = aD() !== iD;
      if (c) {
        if (Ei.transition !== null) {
          var g = Ei.transition;
          g._updatedFibers || (g._updatedFibers = /* @__PURE__ */ new Set()), g._updatedFibers.add(e);
        }
        return oy === dn && (oy = Dh()), oy;
      }
      var x = ba();
      if (x !== dn)
        return x;
      var R = BL();
      return R;
    }
    function c2(e) {
      var r = e.mode;
      return (r & nn) === Nt ? Yt : Mx();
    }
    function Kr(e, r, c, g) {
      P2(), KC && T("useInsertionEffect must not schedule updates."), uw && (ay = !0), Ko(e, c, g), (fn & Ri) !== Pe && e === sa ? I2(r) : (Br && zh(e, r, c), F2(r), e === sa && ((fn & Ri) === qr && (Hp = en(Hp, c)), Qr === Fp && Au(e, Zr)), Ra(e, g), c === Yt && fn === qr && (r.mode & nn) === Nt && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !Hs.isBatchingLegacy && (Up(), QS()));
    }
    function d2(e, r, c) {
      var g = e.current;
      g.lanes = r, Ko(e, r, c), Ra(e, c);
    }
    function f2(e) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (fn & Ri) !== qr
      );
    }
    function Ra(e, r) {
      var c = e.callbackNode;
      Ex(e, r);
      var g = rc(e, e === sa ? Zr : Pe);
      if (g === Pe) {
        c !== null && pA(c), e.callbackNode = null, e.callbackPriority = dn;
        return;
      }
      var x = yr(g), R = e.callbackPriority;
      if (R === x && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(Hs.current !== null && c !== vw)) {
        c == null && R !== Yt && T("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      c != null && pA(c);
      var _;
      if (x === Yt)
        e.tag === hu ? (Hs.isBatchingLegacy !== null && (Hs.didScheduleLegacyUpdate = !0), jM(tA.bind(null, e))) : ZS(tA.bind(null, e)), Hs.current !== null ? Hs.current.push(pu) : XL(function() {
          (fn & (Ri | is)) === qr && pu();
        }), _ = null;
      else {
        var Y;
        switch (lc(g)) {
          case ui:
            Y = cd;
            break;
          case Wr:
            Y = na;
            break;
          case As:
            Y = $a;
            break;
          case sc:
            Y = ro;
            break;
          default:
            Y = $a;
            break;
        }
        _ = mw(Y, JC.bind(null, e));
      }
      e.callbackPriority = x, e.callbackNode = _;
    }
    function JC(e, r) {
      if (PD(), Xp = Fn, oy = Pe, (fn & (Ri | is)) !== qr)
        throw new Error("Should not already be working.");
      var c = e.callbackNode, g = yl();
      if (g && e.callbackNode !== c)
        return null;
      var x = rc(e, e === sa ? Zr : Pe);
      if (x === Pe)
        return null;
      var R = !ac(e, x) && !bv(e, x) && !r, _ = R ? S2(e, x) : cy(e, x);
      if (_ !== gl) {
        if (_ === Dc) {
          var Y = Lh(e);
          Y !== Pe && (x = Y, _ = cw(e, Y));
        }
        if (_ === Ip) {
          var W = Yp;
          throw _c(e, Pe), Au(e, x), Ra(e, Qn()), W;
        }
        if (_ === nw)
          Au(e, x);
        else {
          var J = !ac(e, x), ne = e.current.alternate;
          if (J && !p2(ne)) {
            if (_ = cy(e, x), _ === Dc) {
              var ge = Lh(e);
              ge !== Pe && (x = ge, _ = cw(e, ge));
            }
            if (_ === Ip) {
              var he = Yp;
              throw _c(e, Pe), Au(e, x), Ra(e, Qn()), he;
            }
          }
          e.finishedWork = ne, e.finishedLanes = x, h2(e, _, x);
        }
      }
      return Ra(e, Qn()), e.callbackNode === c ? JC.bind(null, e) : null;
    }
    function cw(e, r) {
      var c = jp;
      if (Ar(e)) {
        var g = _c(e, r);
        g.flags |= sr, PM(e.containerInfo);
      }
      var x = cy(e, r);
      if (x !== Dc) {
        var R = Ea;
        Ea = c, R !== null && eA(R);
      }
      return x;
    }
    function eA(e) {
      Ea === null ? Ea = e : Ea.push.apply(Ea, e);
    }
    function h2(e, r, c) {
      switch (r) {
        case gl:
        case Ip:
          throw new Error("Root did not complete. This is a bug in React.");
        case Dc: {
          Pc(e, Ea, vl);
          break;
        }
        case ty: {
          if (Au(e, c), Pd(c) && // do not delay if we're inside an act() scope
          !gA()) {
            var g = iw + qC - Qn();
            if (g > 10) {
              var x = rc(e, Pe);
              if (x !== Pe)
                break;
              var R = e.suspendedLanes;
              if (!Qo(R, c)) {
                oa(), Ph(e, R);
                break;
              }
              e.timeoutHandle = ob(Pc.bind(null, e, Ea, vl), g);
              break;
            }
          }
          Pc(e, Ea, vl);
          break;
        }
        case Fp: {
          if (Au(e, c), xv(c))
            break;
          if (!gA()) {
            var _ = yv(e, c), Y = _, W = Qn() - Y, J = _2(W) - W;
            if (J > 10) {
              e.timeoutHandle = ob(Pc.bind(null, e, Ea, vl), J);
              break;
            }
          }
          Pc(e, Ea, vl);
          break;
        }
        case $C: {
          Pc(e, Ea, vl);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function p2(e) {
      for (var r = e; ; ) {
        if (r.flags & Zu) {
          var c = r.updateQueue;
          if (c !== null) {
            var g = c.stores;
            if (g !== null)
              for (var x = 0; x < g.length; x++) {
                var R = g[x], _ = R.getSnapshot, Y = R.value;
                try {
                  if (!xt(_(), Y))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var W = r.child;
        if (r.subtreeFlags & Zu && W !== null) {
          W.return = r, r = W;
          continue;
        }
        if (r === e)
          return !0;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === e)
            return !0;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
      return !0;
    }
    function Au(e, r) {
      r = ql(r, ry), r = ql(r, Hp), _h(e, r);
    }
    function tA(e) {
      if (ND(), (fn & (Ri | is)) !== qr)
        throw new Error("Should not already be working.");
      yl();
      var r = rc(e, Pe);
      if (!Hi(r, Yt))
        return Ra(e, Qn()), null;
      var c = cy(e, r);
      if (e.tag !== hu && c === Dc) {
        var g = Lh(e);
        g !== Pe && (r = g, c = cw(e, g));
      }
      if (c === Ip) {
        var x = Yp;
        throw _c(e, Pe), Au(e, r), Ra(e, Qn()), x;
      }
      if (c === nw)
        throw new Error("Root did not complete. This is a bug in React.");
      var R = e.current.alternate;
      return e.finishedWork = R, e.finishedLanes = r, Pc(e, Ea, vl), Ra(e, Qn()), null;
    }
    function g2(e, r) {
      r !== Pe && (Zl(e, en(r, Yt)), Ra(e, Qn()), (fn & (Ri | is)) === qr && (Up(), pu()));
    }
    function dw(e, r) {
      var c = fn;
      fn |= GC;
      try {
        return e(r);
      } finally {
        fn = c, fn === qr && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !Hs.isBatchingLegacy && (Up(), QS());
      }
    }
    function v2(e, r, c, g, x) {
      var R = ba(), _ = Ei.transition;
      try {
        return Ei.transition = null, Cr(ui), e(r, c, g, x);
      } finally {
        Cr(R), Ei.transition = _, fn === qr && Up();
      }
    }
    function ml(e) {
      ku !== null && ku.tag === hu && (fn & (Ri | is)) === qr && yl();
      var r = fn;
      fn |= GC;
      var c = Ei.transition, g = ba();
      try {
        return Ei.transition = null, Cr(ui), e ? e() : void 0;
      } finally {
        Cr(g), Ei.transition = c, fn = r, (fn & (Ri | is)) === qr && pu();
      }
    }
    function nA() {
      return (fn & (Ri | is)) !== qr;
    }
    function uy(e, r) {
      Ui(rw, To, e), To = en(To, r);
    }
    function fw(e) {
      To = rw.current, ji(rw, e);
    }
    function _c(e, r) {
      e.finishedWork = null, e.finishedLanes = Pe;
      var c = e.timeoutHandle;
      if (c !== lb && (e.timeoutHandle = lb, WL(c)), fr !== null)
        for (var g = fr.return; g !== null; ) {
          var x = g.alternate;
          DC(x, g), g = g.return;
        }
      sa = e;
      var R = Nc(e.current, null);
      return fr = R, Zr = To = r, Qr = gl, Yp = null, ny = Pe, Hp = Pe, ry = Pe, jp = null, Ea = null, uD(), Os.discardPendingWarnings(), R;
    }
    function rA(e, r) {
      do {
        var c = fr;
        try {
          if (mm(), _k(), ln(), tw.current = null, c === null || c.return === null) {
            Qr = Ip, Yp = r, fr = null;
            return;
          }
          if (ot && c.mode & Ft && qm(c, !0), jt)
            if (Uo(), r !== null && typeof r == "object" && typeof r.then == "function") {
              var g = r;
              gv(c, g, Zr);
            } else
              gd(c, r, Zr);
          HD(e, c.return, c, r, Zr), oA(c);
        } catch (x) {
          r = x, fr === c && c !== null ? (c = c.return, fr = c) : c = fr;
          continue;
        }
        return;
      } while (!0);
    }
    function iA() {
      var e = ew.current;
      return ew.current = Wm, e === null ? Wm : e;
    }
    function aA(e) {
      ew.current = e;
    }
    function m2() {
      iw = Qn();
    }
    function Vp(e) {
      ny = en(e, ny);
    }
    function y2() {
      Qr === gl && (Qr = ty);
    }
    function hw() {
      (Qr === gl || Qr === ty || Qr === Dc) && (Qr = Fp), sa !== null && (ic(ny) || ic(Hp)) && Au(sa, Zr);
    }
    function x2(e) {
      Qr !== Fp && (Qr = Dc), jp === null ? jp = [e] : jp.push(e);
    }
    function b2() {
      return Qr === gl;
    }
    function cy(e, r) {
      var c = fn;
      fn |= Ri;
      var g = iA();
      if (sa !== e || Zr !== r) {
        if (Br) {
          var x = e.memoizedUpdaters;
          x.size > 0 && (Gp(e, Zr), x.clear()), Id(e, r);
        }
        vl = Ih(), _c(e, r);
      }
      Ya(r);
      do
        try {
          w2();
          break;
        } catch (R) {
          rA(e, R);
        }
      while (!0);
      if (mm(), fn = c, aA(g), fr !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Wl(), sa = null, Zr = Pe, Qr;
    }
    function w2() {
      for (; fr !== null; )
        sA(fr);
    }
    function S2(e, r) {
      var c = fn;
      fn |= Ri;
      var g = iA();
      if (sa !== e || Zr !== r) {
        if (Br) {
          var x = e.memoizedUpdaters;
          x.size > 0 && (Gp(e, Zr), x.clear()), Id(e, r);
        }
        vl = Ih(), Up(), _c(e, r);
      }
      Ya(r);
      do
        try {
          k2();
          break;
        } catch (R) {
          rA(e, R);
        }
      while (!0);
      return mm(), aA(g), fn = c, fr !== null ? (Ju(), gl) : (Wl(), sa = null, Zr = Pe, Qr);
    }
    function k2() {
      for (; fr !== null && !ud(); )
        sA(fr);
    }
    function sA(e) {
      var r = e.alternate;
      wn(e);
      var c;
      (e.mode & Ft) !== Nt ? (R0(e), c = pw(r, e, To), qm(e, !0)) : c = pw(r, e, To), ln(), e.memoizedProps = e.pendingProps, c === null ? oA(e) : fr = c, tw.current = null;
    }
    function oA(e) {
      var r = e;
      do {
        var c = r.alternate, g = r.return;
        if ((r.flags & Ji) === _t) {
          wn(r);
          var x = void 0;
          if ((r.mode & Ft) === Nt ? x = MC(c, r, To) : (R0(r), x = MC(c, r, To), qm(r, !1)), ln(), x !== null) {
            fr = x;
            return;
          }
        } else {
          var R = yO(c, r);
          if (R !== null) {
            R.flags &= sv, fr = R;
            return;
          }
          if ((r.mode & Ft) !== Nt) {
            qm(r, !1);
            for (var _ = r.actualDuration, Y = r.child; Y !== null; )
              _ += Y.actualDuration, Y = Y.sibling;
            r.actualDuration = _;
          }
          if (g !== null)
            g.flags |= Ji, g.subtreeFlags = _t, g.deletions = null;
          else {
            Qr = nw, fr = null;
            return;
          }
        }
        var W = r.sibling;
        if (W !== null) {
          fr = W;
          return;
        }
        r = g, fr = r;
      } while (r !== null);
      Qr === gl && (Qr = $C);
    }
    function Pc(e, r, c) {
      var g = ba(), x = Ei.transition;
      try {
        Ei.transition = null, Cr(ui), C2(e, r, c, g);
      } finally {
        Ei.transition = x, Cr(g);
      }
      return null;
    }
    function C2(e, r, c, g) {
      do
        yl();
      while (ku !== null);
      if (N2(), (fn & (Ri | is)) !== qr)
        throw new Error("Should not already be working.");
      var x = e.finishedWork, R = e.finishedLanes;
      if (fd(R), x === null)
        return Ch(), null;
      if (R === Pe && T("root.finishedLanes should not be empty during a commit. This is a bug in React."), e.finishedWork = null, e.finishedLanes = Pe, x === e.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      e.callbackNode = null, e.callbackPriority = dn;
      var _ = en(x.lanes, x.childLanes);
      Nh(e, _), e === sa && (sa = null, fr = null, Zr = Pe), ((x.subtreeFlags & va) !== _t || (x.flags & va) !== _t) && (Oc || (Oc = !0, ow = c, mw($a, function() {
        return yl(), null;
      })));
      var Y = (x.subtreeFlags & (jl | zi | li | va)) !== _t, W = (x.flags & (jl | zi | li | va)) !== _t;
      if (Y || W) {
        var J = Ei.transition;
        Ei.transition = null;
        var ne = ba();
        Cr(ui);
        var ge = fn;
        fn |= is, tw.current = null, kO(e, x), iC(), IO(e, x, R), IL(e.containerInfo), e.current = x, vv(R), FO(x, e, R), Bl(), uv(), fn = ge, Cr(ne), Ei.transition = J;
      } else
        e.current = x, iC();
      var he = Oc;
      if (Oc ? (Oc = !1, ku = e, Bp = R) : (Ef = 0, sy = null), _ = e.pendingLanes, _ === Pe && (Tf = null), he || dA(e.current, !1), Ss(x.stateNode, g), Br && e.memoizedUpdaters.clear(), r2(), Ra(e, Qn()), r !== null)
        for (var Ce = e.onRecoverableError, Ae = 0; Ae < r.length; Ae++) {
          var De = r[Ae], ct = De.stack, Pt = De.digest;
          Ce(De.value, {
            componentStack: ct,
            digest: Pt
          });
        }
      if (iy) {
        iy = !1;
        var Tt = aw;
        throw aw = null, Tt;
      }
      return Hi(Bp, Yt) && e.tag !== hu && yl(), _ = e.pendingLanes, Hi(_, Yt) ? (_D(), e === lw ? Wp++ : (Wp = 0, lw = e)) : Wp = 0, pu(), Ch(), null;
    }
    function yl() {
      if (ku !== null) {
        var e = lc(Bp), r = Ox(As, e), c = Ei.transition, g = ba();
        try {
          return Ei.transition = null, Cr(r), T2();
        } finally {
          Cr(g), Ei.transition = c;
        }
      }
      return !1;
    }
    function A2(e) {
      sw.push(e), Oc || (Oc = !0, mw($a, function() {
        return yl(), null;
      }));
    }
    function T2() {
      if (ku === null)
        return !1;
      var e = ow;
      ow = null;
      var r = ku, c = Bp;
      if (ku = null, Bp = Pe, (fn & (Ri | is)) !== qr)
        throw new Error("Cannot flush passive effects while already rendering.");
      uw = !0, ay = !1, mv(c);
      var g = fn;
      fn |= is, XO(r.current), jO(r, r.current, c, e);
      {
        var x = sw;
        sw = [];
        for (var R = 0; R < x.length; R++) {
          var _ = x[R];
          EO(r, _);
        }
      }
      Ku(), dA(r.current, !0), fn = g, pu(), ay ? r === sy ? Ef++ : (Ef = 0, sy = r) : Ef = 0, uw = !1, ay = !1, ao(r);
      {
        var Y = r.current.stateNode;
        Y.effectDuration = 0, Y.passiveEffectDuration = 0;
      }
      return !0;
    }
    function lA(e) {
      return Tf !== null && Tf.has(e);
    }
    function E2(e) {
      Tf === null ? Tf = /* @__PURE__ */ new Set([e]) : Tf.add(e);
    }
    function R2(e) {
      iy || (iy = !0, aw = e);
    }
    var L2 = R2;
    function uA(e, r, c) {
      var g = Lc(c, r), x = sC(e, g, Yt), R = vu(e, x, Yt), _ = oa();
      R !== null && (Ko(R, Yt, _), Ra(R, _));
    }
    function Gn(e, r, c) {
      if (bO(c), $p(!1), e.tag === q) {
        uA(e, e, c);
        return;
      }
      var g = null;
      for (g = r; g !== null; ) {
        if (g.tag === q) {
          uA(g, e, c);
          return;
        } else if (g.tag === U) {
          var x = g.type, R = g.stateNode;
          if (typeof x.getDerivedStateFromError == "function" || typeof R.componentDidCatch == "function" && !lA(R)) {
            var _ = Lc(c, e), Y = P0(g, _, Yt), W = vu(g, Y, Yt), J = oa();
            W !== null && (Ko(W, Yt, J), Ra(W, J));
            return;
          }
        }
        g = g.return;
      }
      T(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, c);
    }
    function M2(e, r, c) {
      var g = e.pingCache;
      g !== null && g.delete(r);
      var x = oa();
      Ph(e, c), Y2(e), sa === e && Qo(Zr, c) && (Qr === Fp || Qr === ty && Pd(Zr) && Qn() - iw < qC ? _c(e, Pe) : ry = en(ry, c)), Ra(e, x);
    }
    function cA(e, r) {
      r === dn && (r = c2(e));
      var c = oa(), g = Aa(e, r);
      g !== null && (Ko(g, r, c), Ra(g, c));
    }
    function D2(e) {
      var r = e.memoizedState, c = dn;
      r !== null && (c = r.retryLane), cA(e, c);
    }
    function O2(e, r) {
      var c = dn, g;
      switch (e.tag) {
        case re:
          g = e.stateNode;
          var x = e.memoizedState;
          x !== null && (c = x.retryLane);
          break;
        case ft:
          g = e.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      g !== null && g.delete(r), cA(e, c);
    }
    function _2(e) {
      return e < 120 ? 120 : e < 480 ? 480 : e < 1080 ? 1080 : e < 1920 ? 1920 : e < 3e3 ? 3e3 : e < 4320 ? 4320 : s2(e / 1960) * 1960;
    }
    function P2() {
      if (Wp > l2)
        throw Wp = 0, lw = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Ef > u2 && (Ef = 0, sy = null, T("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function N2() {
      Os.flushLegacyContextWarning(), Os.flushPendingUnsafeLifecycleWarnings();
    }
    function dA(e, r) {
      wn(e), dy(e, Ni, e2), r && dy(e, jo, t2), dy(e, Ni, KO), r && dy(e, jo, JO), ln();
    }
    function dy(e, r, c) {
      for (var g = e, x = null; g !== null; ) {
        var R = g.subtreeFlags & r;
        g !== x && g.child !== null && R !== _t ? g = g.child : ((g.flags & r) !== _t && c(g), g.sibling !== null ? g = g.sibling : g = x = g.return);
      }
    }
    var fy = null;
    function fA(e) {
      {
        if ((fn & Ri) !== qr || !(e.mode & nn))
          return;
        var r = e.tag;
        if (r !== $ && r !== q && r !== U && r !== H && r !== we && r !== ve && r !== Le)
          return;
        var c = gt(e) || "ReactComponent";
        if (fy !== null) {
          if (fy.has(c))
            return;
          fy.add(c);
        } else
          fy = /* @__PURE__ */ new Set([c]);
        var g = Dn;
        try {
          wn(e), T("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          g ? wn(e) : ln();
        }
      }
    }
    var pw;
    {
      var z2 = null;
      pw = function(e, r, c) {
        var g = bA(z2, r);
        try {
          return AC(e, r, c);
        } catch (R) {
          if (qM() || R !== null && typeof R == "object" && typeof R.then == "function")
            throw R;
          if (mm(), _k(), DC(e, r), bA(r, g), r.mode & Ft && R0(r), Ho(null, AC, null, e, r, c), Ax()) {
            var x = hh();
            typeof x == "object" && x !== null && x._suppressLogging && typeof R == "object" && R !== null && !R._suppressLogging && (R._suppressLogging = !0);
          }
          throw R;
        }
      };
    }
    var hA = !1, gw;
    gw = /* @__PURE__ */ new Set();
    function I2(e) {
      if (ai && !MD())
        switch (e.tag) {
          case H:
          case we:
          case Le: {
            var r = fr && gt(fr) || "Unknown", c = r;
            if (!gw.has(c)) {
              gw.add(c);
              var g = gt(e) || "Unknown";
              T("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", g, r, r);
            }
            break;
          }
          case U: {
            hA || (T("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), hA = !0);
            break;
          }
        }
    }
    function Gp(e, r) {
      if (Br) {
        var c = e.memoizedUpdaters;
        c.forEach(function(g) {
          zh(e, g, r);
        });
      }
    }
    var vw = {};
    function mw(e, r) {
      {
        var c = Hs.current;
        return c !== null ? (c.push(r), vw) : ld(e, r);
      }
    }
    function pA(e) {
      if (e !== vw)
        return lv(e);
    }
    function gA() {
      return Hs.current !== null;
    }
    function F2(e) {
      {
        if (e.mode & nn) {
          if (!VC())
            return;
        } else if (!a2() || fn !== qr || e.tag !== H && e.tag !== we && e.tag !== Le)
          return;
        if (Hs.current === null) {
          var r = Dn;
          try {
            wn(e), T(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, gt(e));
          } finally {
            r ? wn(e) : ln();
          }
        }
      }
    }
    function Y2(e) {
      e.tag !== hu && VC() && Hs.current === null && T(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function $p(e) {
      KC = e;
    }
    var as = null, Rf = null, H2 = function(e) {
      as = e;
    };
    function Lf(e) {
      {
        if (as === null)
          return e;
        var r = as(e);
        return r === void 0 ? e : r.current;
      }
    }
    function yw(e) {
      return Lf(e);
    }
    function xw(e) {
      {
        if (as === null)
          return e;
        var r = as(e);
        if (r === void 0) {
          if (e != null && typeof e.render == "function") {
            var c = Lf(e.render);
            if (e.render !== c) {
              var g = {
                $$typeof: Dt,
                render: c
              };
              return e.displayName !== void 0 && (g.displayName = e.displayName), g;
            }
          }
          return e;
        }
        return r.current;
      }
    }
    function vA(e, r) {
      {
        if (as === null)
          return !1;
        var c = e.elementType, g = r.type, x = !1, R = typeof g == "object" && g !== null ? g.$$typeof : null;
        switch (e.tag) {
          case U: {
            typeof g == "function" && (x = !0);
            break;
          }
          case H: {
            (typeof g == "function" || R === Ot) && (x = !0);
            break;
          }
          case we: {
            (R === Dt || R === Ot) && (x = !0);
            break;
          }
          case ve:
          case Le: {
            (R === Zt || R === Ot) && (x = !0);
            break;
          }
          default:
            return !1;
        }
        if (x) {
          var _ = as(c);
          if (_ !== void 0 && _ === as(g))
            return !0;
        }
        return !1;
      }
    }
    function mA(e) {
      {
        if (as === null || typeof WeakSet != "function")
          return;
        Rf === null && (Rf = /* @__PURE__ */ new WeakSet()), Rf.add(e);
      }
    }
    var j2 = function(e, r) {
      {
        if (as === null)
          return;
        var c = r.staleFamilies, g = r.updatedFamilies;
        yl(), ml(function() {
          bw(e.current, g, c);
        });
      }
    }, U2 = function(e, r) {
      {
        if (e.context !== ja)
          return;
        yl(), ml(function() {
          qp(r, e, null, null);
        });
      }
    };
    function bw(e, r, c) {
      {
        var g = e.alternate, x = e.child, R = e.sibling, _ = e.tag, Y = e.type, W = null;
        switch (_) {
          case H:
          case Le:
          case U:
            W = Y;
            break;
          case we:
            W = Y.render;
            break;
        }
        if (as === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var J = !1, ne = !1;
        if (W !== null) {
          var ge = as(W);
          ge !== void 0 && (c.has(ge) ? ne = !0 : r.has(ge) && (_ === U ? ne = !0 : J = !0));
        }
        if (Rf !== null && (Rf.has(e) || g !== null && Rf.has(g)) && (ne = !0), ne && (e._debugNeedsRemount = !0), ne || J) {
          var he = Aa(e, Yt);
          he !== null && Kr(he, e, Yt, Fn);
        }
        x !== null && !ne && bw(x, r, c), R !== null && bw(R, r, c);
      }
    }
    var B2 = function(e, r) {
      {
        var c = /* @__PURE__ */ new Set(), g = new Set(r.map(function(x) {
          return x.current;
        }));
        return ww(e.current, g, c), c;
      }
    };
    function ww(e, r, c) {
      {
        var g = e.child, x = e.sibling, R = e.tag, _ = e.type, Y = null;
        switch (R) {
          case H:
          case Le:
          case U:
            Y = _;
            break;
          case we:
            Y = _.render;
            break;
        }
        var W = !1;
        Y !== null && r.has(Y) && (W = !0), W ? W2(e, c) : g !== null && ww(g, r, c), x !== null && ww(x, r, c);
      }
    }
    function W2(e, r) {
      {
        var c = X2(e, r);
        if (c)
          return;
        for (var g = e; ; ) {
          switch (g.tag) {
            case se:
              r.add(g.stateNode);
              return;
            case te:
              r.add(g.stateNode.containerInfo);
              return;
            case q:
              r.add(g.stateNode.containerInfo);
              return;
          }
          if (g.return === null)
            throw new Error("Expected to reach root first.");
          g = g.return;
        }
      }
    }
    function X2(e, r) {
      for (var c = e, g = !1; ; ) {
        if (c.tag === se)
          g = !0, r.add(c.stateNode);
        else if (c.child !== null) {
          c.child.return = c, c = c.child;
          continue;
        }
        if (c === e)
          return g;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === e)
            return g;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
      return !1;
    }
    var Sw;
    {
      Sw = !1;
      try {
        var yA = Object.preventExtensions({});
      } catch {
        Sw = !0;
      }
    }
    function V2(e, r, c, g) {
      this.tag = e, this.key = c, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = r, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = g, this.flags = _t, this.subtreeFlags = _t, this.deletions = null, this.lanes = Pe, this.childLanes = Pe, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !Sw && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Ua = function(e, r, c, g) {
      return new V2(e, r, c, g);
    };
    function kw(e) {
      var r = e.prototype;
      return !!(r && r.isReactComponent);
    }
    function G2(e) {
      return typeof e == "function" && !kw(e) && e.defaultProps === void 0;
    }
    function $2(e) {
      if (typeof e == "function")
        return kw(e) ? U : H;
      if (e != null) {
        var r = e.$$typeof;
        if (r === Dt)
          return we;
        if (r === Zt)
          return ve;
      }
      return $;
    }
    function Nc(e, r) {
      var c = e.alternate;
      c === null ? (c = Ua(e.tag, r, e.key, e.mode), c.elementType = e.elementType, c.type = e.type, c.stateNode = e.stateNode, c._debugSource = e._debugSource, c._debugOwner = e._debugOwner, c._debugHookTypes = e._debugHookTypes, c.alternate = e, e.alternate = c) : (c.pendingProps = r, c.type = e.type, c.flags = _t, c.subtreeFlags = _t, c.deletions = null, c.actualDuration = 0, c.actualStartTime = -1), c.flags = e.flags & Ur, c.childLanes = e.childLanes, c.lanes = e.lanes, c.child = e.child, c.memoizedProps = e.memoizedProps, c.memoizedState = e.memoizedState, c.updateQueue = e.updateQueue;
      var g = e.dependencies;
      switch (c.dependencies = g === null ? null : {
        lanes: g.lanes,
        firstContext: g.firstContext
      }, c.sibling = e.sibling, c.index = e.index, c.ref = e.ref, c.selfBaseDuration = e.selfBaseDuration, c.treeBaseDuration = e.treeBaseDuration, c._debugNeedsRemount = e._debugNeedsRemount, c.tag) {
        case $:
        case H:
        case Le:
          c.type = Lf(e.type);
          break;
        case U:
          c.type = yw(e.type);
          break;
        case we:
          c.type = xw(e.type);
          break;
      }
      return c;
    }
    function q2(e, r) {
      e.flags &= Ur | Bn;
      var c = e.alternate;
      if (c === null)
        e.childLanes = Pe, e.lanes = r, e.child = null, e.subtreeFlags = _t, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null, e.selfBaseDuration = 0, e.treeBaseDuration = 0;
      else {
        e.childLanes = c.childLanes, e.lanes = c.lanes, e.child = c.child, e.subtreeFlags = _t, e.deletions = null, e.memoizedProps = c.memoizedProps, e.memoizedState = c.memoizedState, e.updateQueue = c.updateQueue, e.type = c.type;
        var g = c.dependencies;
        e.dependencies = g === null ? null : {
          lanes: g.lanes,
          firstContext: g.firstContext
        }, e.selfBaseDuration = c.selfBaseDuration, e.treeBaseDuration = c.treeBaseDuration;
      }
      return e;
    }
    function Z2(e, r, c) {
      var g;
      return e === um ? (g = nn, r === !0 && (g |= Kn, g |= ya)) : g = Nt, Br && (g |= Ft), Ua(q, null, null, g);
    }
    function Cw(e, r, c, g, x, R) {
      var _ = $, Y = e;
      if (typeof e == "function")
        kw(e) ? (_ = U, Y = yw(Y)) : Y = Lf(Y);
      else if (typeof e == "string")
        _ = se;
      else
        e:
          switch (e) {
            case xi:
              return Tu(c.children, x, R, r);
            case ii:
              _ = Re, x |= Kn, (x & nn) !== Nt && (x |= ya);
              break;
            case le:
              return Q2(c, x, R, r);
            case qt:
              return K2(c, x, R, r);
            case cn:
              return J2(c, x, R, r);
            case B:
              return xA(c, x, R, r);
            case t:
            case ar:
            case n:
            case i:
            case Yn:
            default: {
              if (typeof e == "object" && e !== null)
                switch (e.$$typeof) {
                  case Ye:
                    _ = Q;
                    break e;
                  case et:
                    _ = Ne;
                    break e;
                  case Dt:
                    _ = we, Y = xw(Y);
                    break e;
                  case Zt:
                    _ = ve;
                    break e;
                  case Ot:
                    _ = Qe, Y = null;
                    break e;
                }
              var W = "";
              {
                (e === void 0 || typeof e == "object" && e !== null && Object.keys(e).length === 0) && (W += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var J = g ? gt(g) : null;
                J && (W += `

Check the render method of \`` + J + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (e == null ? e : typeof e) + "." + W));
            }
          }
      var ne = Ua(_, c, r, x);
      return ne.elementType = e, ne.type = Y, ne.lanes = R, ne._debugOwner = g, ne;
    }
    function Aw(e, r, c) {
      var g = null;
      g = e._owner;
      var x = e.type, R = e.key, _ = e.props, Y = Cw(x, R, _, g, r, c);
      return Y._debugSource = e._source, Y._debugOwner = e._owner, Y;
    }
    function Tu(e, r, c, g) {
      var x = Ua(ue, e, g, r);
      return x.lanes = c, x;
    }
    function Q2(e, r, c, g) {
      typeof e.id != "string" && T('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof e.id);
      var x = Ua(Ee, e, g, r | Ft);
      return x.elementType = le, x.lanes = c, x.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, x;
    }
    function K2(e, r, c, g) {
      var x = Ua(re, e, g, r);
      return x.elementType = qt, x.lanes = c, x;
    }
    function J2(e, r, c, g) {
      var x = Ua(ft, e, g, r);
      return x.elementType = cn, x.lanes = c, x;
    }
    function xA(e, r, c, g) {
      var x = Ua(st, e, g, r);
      x.elementType = B, x.lanes = c;
      var R = {
        isHidden: !1
      };
      return x.stateNode = R, x;
    }
    function Tw(e, r, c) {
      var g = Ua(ae, e, null, r);
      return g.lanes = c, g;
    }
    function e_() {
      var e = Ua(se, null, null, Nt);
      return e.elementType = "DELETED", e;
    }
    function t_(e) {
      var r = Ua(Ge, null, null, Nt);
      return r.stateNode = e, r;
    }
    function Ew(e, r, c) {
      var g = e.children !== null ? e.children : [], x = Ua(te, g, e.key, r);
      return x.lanes = c, x.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: e.implementation
      }, x;
    }
    function bA(e, r) {
      return e === null && (e = Ua($, null, null, Nt)), e.tag = r.tag, e.key = r.key, e.elementType = r.elementType, e.type = r.type, e.stateNode = r.stateNode, e.return = r.return, e.child = r.child, e.sibling = r.sibling, e.index = r.index, e.ref = r.ref, e.pendingProps = r.pendingProps, e.memoizedProps = r.memoizedProps, e.updateQueue = r.updateQueue, e.memoizedState = r.memoizedState, e.dependencies = r.dependencies, e.mode = r.mode, e.flags = r.flags, e.subtreeFlags = r.subtreeFlags, e.deletions = r.deletions, e.lanes = r.lanes, e.childLanes = r.childLanes, e.alternate = r.alternate, e.actualDuration = r.actualDuration, e.actualStartTime = r.actualStartTime, e.selfBaseDuration = r.selfBaseDuration, e.treeBaseDuration = r.treeBaseDuration, e._debugSource = r._debugSource, e._debugOwner = r._debugOwner, e._debugNeedsRemount = r._debugNeedsRemount, e._debugHookTypes = r._debugHookTypes, e;
    }
    function n_(e, r, c, g, x) {
      this.tag = r, this.containerInfo = e, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = lb, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = dn, this.eventTimes = zd(Pe), this.expirationTimes = zd(Fn), this.pendingLanes = Pe, this.suspendedLanes = Pe, this.pingedLanes = Pe, this.expiredLanes = Pe, this.mutableReadLanes = Pe, this.finishedLanes = Pe, this.entangledLanes = Pe, this.entanglements = zd(Pe), this.identifierPrefix = g, this.onRecoverableError = x, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var R = this.pendingUpdatersLaneMap = [], _ = 0; _ < Xn; _++)
          R.push(/* @__PURE__ */ new Set());
      }
      switch (r) {
        case um:
          this._debugRootType = c ? "hydrateRoot()" : "createRoot()";
          break;
        case hu:
          this._debugRootType = c ? "hydrate()" : "render()";
          break;
      }
    }
    function wA(e, r, c, g, x, R, _, Y, W, J) {
      var ne = new n_(e, r, c, Y, W), ge = Z2(r, R);
      ne.current = ge, ge.stateNode = ne;
      {
        var he = {
          element: g,
          isDehydrated: c,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        ge.memoizedState = he;
      }
      return Nb(ge), ne;
    }
    var Rw = "18.2.0";
    function r_(e, r, c) {
      var g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return qi(g), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: Hr,
        key: g == null ? null : "" + g,
        children: e,
        containerInfo: r,
        implementation: c
      };
    }
    var Lw, Mw;
    Lw = !1, Mw = {};
    function SA(e) {
      if (!e)
        return ja;
      var r = ha(e), c = HM(r);
      if (r.tag === U) {
        var g = r.type;
        if (xo(g))
          return $S(r, g, c);
      }
      return c;
    }
    function i_(e, r) {
      {
        var c = ha(e);
        if (c === void 0) {
          if (typeof e.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var g = Object.keys(e).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + g);
        }
        var x = ma(c);
        if (x === null)
          return null;
        if (x.mode & Kn) {
          var R = gt(c) || "Component";
          if (!Mw[R]) {
            Mw[R] = !0;
            var _ = Dn;
            try {
              wn(x), c.mode & Kn ? T("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", r, r, R) : T("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", r, r, R);
            } finally {
              _ ? wn(_) : ln();
            }
          }
        }
        return x.stateNode;
      }
    }
    function kA(e, r, c, g, x, R, _, Y) {
      var W = !1, J = null;
      return wA(e, r, W, J, c, g, x, R, _);
    }
    function CA(e, r, c, g, x, R, _, Y, W, J) {
      var ne = !0, ge = wA(c, g, ne, e, x, R, _, Y, W);
      ge.context = SA(null);
      var he = ge.current, Ce = oa(), Ae = Cu(he), De = hl(Ce, Ae);
      return De.callback = r ?? null, vu(he, De, Ae), d2(ge, Ae, Ce), ge;
    }
    function qp(e, r, c, g) {
      cv(r, e);
      var x = r.current, R = oa(), _ = Cu(x);
      Bo(_);
      var Y = SA(c);
      r.context === null ? r.context = Y : r.pendingContext = Y, ai && Dn !== null && !Lw && (Lw = !0, T(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, gt(Dn) || "Unknown"));
      var W = hl(R, _);
      W.payload = {
        element: e
      }, g = g === void 0 ? null : g, g !== null && (typeof g != "function" && T("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", g), W.callback = g);
      var J = vu(x, W, _);
      return J !== null && (Kr(J, x, _, R), Sm(J, x, _)), _;
    }
    function hy(e) {
      var r = e.current;
      if (!r.child)
        return null;
      switch (r.child.tag) {
        case se:
          return r.child.stateNode;
        default:
          return r.child.stateNode;
      }
    }
    function a_(e) {
      switch (e.tag) {
        case q: {
          var r = e.stateNode;
          if (Ar(r)) {
            var c = Rx(r);
            g2(r, c);
          }
          break;
        }
        case re: {
          ml(function() {
            var x = Aa(e, Yt);
            if (x !== null) {
              var R = oa();
              Kr(x, e, Yt, R);
            }
          });
          var g = Yt;
          Dw(e, g);
          break;
        }
      }
    }
    function AA(e, r) {
      var c = e.memoizedState;
      c !== null && c.dehydrated !== null && (c.retryLane = Sv(c.retryLane, r));
    }
    function Dw(e, r) {
      AA(e, r);
      var c = e.alternate;
      c && AA(c, r);
    }
    function s_(e) {
      if (e.tag === re) {
        var r = Xl, c = Aa(e, r);
        if (c !== null) {
          var g = oa();
          Kr(c, e, r, g);
        }
        Dw(e, r);
      }
    }
    function o_(e) {
      if (e.tag === re) {
        var r = Cu(e), c = Aa(e, r);
        if (c !== null) {
          var g = oa();
          Kr(c, e, r, g);
        }
        Dw(e, r);
      }
    }
    function TA(e) {
      var r = ov(e);
      return r === null ? null : r.stateNode;
    }
    var EA = function(e) {
      return null;
    };
    function l_(e) {
      return EA(e);
    }
    var RA = function(e) {
      return !1;
    };
    function u_(e) {
      return RA(e);
    }
    var LA = null, MA = null, DA = null, OA = null, _A = null, PA = null, NA = null, zA = null, IA = null;
    {
      var FA = function(e, r, c) {
        var g = r[c], x = Dr(e) ? e.slice() : p({}, e);
        return c + 1 === r.length ? (Dr(x) ? x.splice(g, 1) : delete x[g], x) : (x[g] = FA(e[g], r, c + 1), x);
      }, YA = function(e, r) {
        return FA(e, r, 0);
      }, HA = function(e, r, c, g) {
        var x = r[g], R = Dr(e) ? e.slice() : p({}, e);
        if (g + 1 === r.length) {
          var _ = c[g];
          R[_] = R[x], Dr(R) ? R.splice(x, 1) : delete R[x];
        } else
          R[x] = HA(
            // $FlowFixMe number or string is fine here
            e[x],
            r,
            c,
            g + 1
          );
        return R;
      }, jA = function(e, r, c) {
        if (r.length !== c.length) {
          A("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var g = 0; g < c.length - 1; g++)
            if (r[g] !== c[g]) {
              A("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return HA(e, r, c, 0);
      }, UA = function(e, r, c, g) {
        if (c >= r.length)
          return g;
        var x = r[c], R = Dr(e) ? e.slice() : p({}, e);
        return R[x] = UA(e[x], r, c + 1, g), R;
      }, BA = function(e, r, c) {
        return UA(e, r, 0, c);
      }, Ow = function(e, r) {
        for (var c = e.memoizedState; c !== null && r > 0; )
          c = c.next, r--;
        return c;
      };
      LA = function(e, r, c, g) {
        var x = Ow(e, r);
        if (x !== null) {
          var R = BA(x.memoizedState, c, g);
          x.memoizedState = R, x.baseState = R, e.memoizedProps = p({}, e.memoizedProps);
          var _ = Aa(e, Yt);
          _ !== null && Kr(_, e, Yt, Fn);
        }
      }, MA = function(e, r, c) {
        var g = Ow(e, r);
        if (g !== null) {
          var x = YA(g.memoizedState, c);
          g.memoizedState = x, g.baseState = x, e.memoizedProps = p({}, e.memoizedProps);
          var R = Aa(e, Yt);
          R !== null && Kr(R, e, Yt, Fn);
        }
      }, DA = function(e, r, c, g) {
        var x = Ow(e, r);
        if (x !== null) {
          var R = jA(x.memoizedState, c, g);
          x.memoizedState = R, x.baseState = R, e.memoizedProps = p({}, e.memoizedProps);
          var _ = Aa(e, Yt);
          _ !== null && Kr(_, e, Yt, Fn);
        }
      }, OA = function(e, r, c) {
        e.pendingProps = BA(e.memoizedProps, r, c), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var g = Aa(e, Yt);
        g !== null && Kr(g, e, Yt, Fn);
      }, _A = function(e, r) {
        e.pendingProps = YA(e.memoizedProps, r), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var c = Aa(e, Yt);
        c !== null && Kr(c, e, Yt, Fn);
      }, PA = function(e, r, c) {
        e.pendingProps = jA(e.memoizedProps, r, c), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var g = Aa(e, Yt);
        g !== null && Kr(g, e, Yt, Fn);
      }, NA = function(e) {
        var r = Aa(e, Yt);
        r !== null && Kr(r, e, Yt, Fn);
      }, zA = function(e) {
        EA = e;
      }, IA = function(e) {
        RA = e;
      };
    }
    function c_(e) {
      var r = ma(e);
      return r === null ? null : r.stateNode;
    }
    function d_(e) {
      return null;
    }
    function f_() {
      return Dn;
    }
    function h_(e) {
      var r = e.findFiberByHostInstance, c = h.ReactCurrentDispatcher;
      return Sh({
        bundleType: e.bundleType,
        version: e.version,
        rendererPackageName: e.rendererPackageName,
        rendererConfig: e.rendererConfig,
        overrideHookState: LA,
        overrideHookStateDeletePath: MA,
        overrideHookStateRenamePath: DA,
        overrideProps: OA,
        overridePropsDeletePath: _A,
        overridePropsRenamePath: PA,
        setErrorHandler: zA,
        setSuspenseHandler: IA,
        scheduleUpdate: NA,
        currentDispatcherRef: c,
        findHostInstanceByFiber: c_,
        findFiberByHostInstance: r || d_,
        // React Refresh
        findHostInstancesForRefresh: B2,
        scheduleRefresh: j2,
        scheduleRoot: U2,
        setRefreshHandler: H2,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: f_,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: Rw
      });
    }
    var WA = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(e) {
      console.error(e);
    };
    function _w(e) {
      this._internalRoot = e;
    }
    py.prototype.render = _w.prototype.render = function(e) {
      var r = this._internalRoot;
      if (r === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? T("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : gy(arguments[1]) ? T("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && T("You passed a second argument to root.render(...) but it only accepts one argument.");
        var c = r.containerInfo;
        if (c.nodeType !== mr) {
          var g = TA(r.current);
          g && g.parentNode !== c && T("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      qp(e, r, null, null);
    }, py.prototype.unmount = _w.prototype.unmount = function() {
      typeof arguments[0] == "function" && T("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var e = this._internalRoot;
      if (e !== null) {
        this._internalRoot = null;
        var r = e.containerInfo;
        nA() && T("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), ml(function() {
          qp(null, e, null, null);
        }), BS(r);
      }
    };
    function p_(e, r) {
      if (!gy(e))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      XA(e);
      var c = !1, g = !1, x = "", R = WA;
      r != null && (r.hydrate ? A("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof r == "object" && r !== null && r.$$typeof === Pa && T(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), r.unstable_strictMode === !0 && (c = !0), r.identifierPrefix !== void 0 && (x = r.identifierPrefix), r.onRecoverableError !== void 0 && (R = r.onRecoverableError), r.transitionCallbacks !== void 0 && r.transitionCallbacks);
      var _ = kA(e, um, null, c, g, x, R);
      nm(_.current, e);
      var Y = e.nodeType === mr ? e.parentNode : e;
      return rp(Y), new _w(_);
    }
    function py(e) {
      this._internalRoot = e;
    }
    function g_(e) {
      e && Mv(e);
    }
    py.prototype.unstable_scheduleHydration = g_;
    function v_(e, r, c) {
      if (!gy(e))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      XA(e), r === void 0 && T("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var g = c ?? null, x = c != null && c.hydratedSources || null, R = !1, _ = !1, Y = "", W = WA;
      c != null && (c.unstable_strictMode === !0 && (R = !0), c.identifierPrefix !== void 0 && (Y = c.identifierPrefix), c.onRecoverableError !== void 0 && (W = c.onRecoverableError));
      var J = CA(r, null, e, um, g, R, _, Y, W);
      if (nm(J.current, e), rp(e), x)
        for (var ne = 0; ne < x.length; ne++) {
          var ge = x[ne];
          CD(J, ge);
        }
      return new py(J);
    }
    function gy(e) {
      return !!(e && (e.nodeType === Oi || e.nodeType === za || e.nodeType === Po || !Je));
    }
    function Zp(e) {
      return !!(e && (e.nodeType === Oi || e.nodeType === za || e.nodeType === Po || e.nodeType === mr && e.nodeValue === " react-mount-point-unstable "));
    }
    function XA(e) {
      e.nodeType === Oi && e.tagName && e.tagName.toUpperCase() === "BODY" && T("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), pp(e) && (e._reactRootContainer ? T("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : T("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var m_ = h.ReactCurrentOwner, VA;
    VA = function(e) {
      if (e._reactRootContainer && e.nodeType !== mr) {
        var r = TA(e._reactRootContainer.current);
        r && r.parentNode !== e && T("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var c = !!e._reactRootContainer, g = Pw(e), x = !!(g && du(g));
      x && !c && T("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), e.nodeType === Oi && e.tagName && e.tagName.toUpperCase() === "BODY" && T("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function Pw(e) {
      return e ? e.nodeType === za ? e.documentElement : e.firstChild : null;
    }
    function GA() {
    }
    function y_(e, r, c, g, x) {
      if (x) {
        if (typeof g == "function") {
          var R = g;
          g = function() {
            var he = hy(_);
            R.call(he);
          };
        }
        var _ = CA(
          r,
          g,
          e,
          hu,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          GA
        );
        e._reactRootContainer = _, nm(_.current, e);
        var Y = e.nodeType === mr ? e.parentNode : e;
        return rp(Y), ml(), _;
      } else {
        for (var W; W = e.lastChild; )
          e.removeChild(W);
        if (typeof g == "function") {
          var J = g;
          g = function() {
            var he = hy(ne);
            J.call(he);
          };
        }
        var ne = kA(
          e,
          hu,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          GA
        );
        e._reactRootContainer = ne, nm(ne.current, e);
        var ge = e.nodeType === mr ? e.parentNode : e;
        return rp(ge), ml(function() {
          qp(r, ne, c, g);
        }), ne;
      }
    }
    function x_(e, r) {
      e !== null && typeof e != "function" && T("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", r, e);
    }
    function vy(e, r, c, g, x) {
      VA(c), x_(x === void 0 ? null : x, "render");
      var R = c._reactRootContainer, _;
      if (!R)
        _ = y_(c, r, e, x, g);
      else {
        if (_ = R, typeof x == "function") {
          var Y = x;
          x = function() {
            var W = hy(_);
            Y.call(W);
          };
        }
        qp(r, _, e, x);
      }
      return hy(_);
    }
    function b_(e) {
      {
        var r = m_.current;
        if (r !== null && r.stateNode !== null) {
          var c = r.stateNode._warnedAboutRefsInRender;
          c || T("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", mt(r.type) || "A component"), r.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return e == null ? null : e.nodeType === Oi ? e : i_(e, "findDOMNode");
    }
    function w_(e, r, c) {
      if (T("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Zp(r))
        throw new Error("Target container is not a DOM element.");
      {
        var g = pp(r) && r._reactRootContainer === void 0;
        g && T("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return vy(null, e, r, !0, c);
    }
    function S_(e, r, c) {
      if (T("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Zp(r))
        throw new Error("Target container is not a DOM element.");
      {
        var g = pp(r) && r._reactRootContainer === void 0;
        g && T("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return vy(null, e, r, !1, c);
    }
    function k_(e, r, c, g) {
      if (T("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Zp(c))
        throw new Error("Target container is not a DOM element.");
      if (e == null || !qu(e))
        throw new Error("parentComponent must be a valid React Component");
      return vy(e, r, c, !1, g);
    }
    function C_(e) {
      if (!Zp(e))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var r = pp(e) && e._reactRootContainer === void 0;
        r && T("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (e._reactRootContainer) {
        {
          var c = Pw(e), g = c && !du(c);
          g && T("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return ml(function() {
          vy(null, null, e, !1, function() {
            e._reactRootContainer = null, BS(e);
          });
        }), !0;
      } else {
        {
          var x = Pw(e), R = !!(x && du(x)), _ = e.nodeType === Oi && Zp(e.parentNode) && !!e.parentNode._reactRootContainer;
          R && T("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", _ ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    ht(a_), Cv(s_), cc(o_), Yh(ba), Tv(oc), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && T("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), iv(EL), rd(dw, v2, ml);
    function A_(e, r) {
      var c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!gy(r))
        throw new Error("Target container is not a DOM element.");
      return r_(e, r, null, c);
    }
    function T_(e, r, c, g) {
      return k_(e, r, c, g);
    }
    var Nw = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [du, sf, rm, nd, Vu, dw]
    };
    function E_(e, r) {
      return Nw.usingClientEntryPoint || T('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), p_(e, r);
    }
    function R_(e, r, c) {
      return Nw.usingClientEntryPoint || T('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), v_(e, r, c);
    }
    function L_(e) {
      return nA() && T("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), ml(e);
    }
    var M_ = h_({
      findFiberByHostInstance: bc,
      bundleType: 1,
      version: Rw,
      rendererPackageName: "react-dom"
    });
    if (!M_ && pn && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var $A = window.location.protocol;
      /^(https?|file):$/.test($A) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + ($A === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    Ma.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Nw, Ma.createPortal = A_, Ma.createRoot = E_, Ma.findDOMNode = b_, Ma.flushSync = L_, Ma.hydrate = w_, Ma.hydrateRoot = R_, Ma.render = S_, Ma.unmountComponentAtNode = C_, Ma.unstable_batchedUpdates = dw, Ma.unstable_renderSubtreeIntoContainer = T_, Ma.version = Rw, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Ma;
}
function xR() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(xR);
    } catch (s) {
      console.error(s);
    }
  }
}
process.env.NODE_ENV === "production" ? (xR(), x1.exports = IY()) : x1.exports = FY();
var YY = x1.exports;
const cg = /^[a-z0-9]+(-[a-z0-9]+)*$/, sx = (s, u, h, v = "") => {
  const w = s.split(":");
  if (s.slice(0, 1) === "@") {
    if (w.length < 2 || w.length > 3)
      return null;
    v = w.shift().slice(1);
  }
  if (w.length > 3 || !w.length)
    return null;
  if (w.length > 1) {
    const F = w.pop(), H = w.pop(), U = {
      // Allow provider without '@': "provider:prefix:name"
      provider: w.length > 0 ? w[0] : v,
      prefix: H,
      name: F
    };
    return u && !My(U) ? null : U;
  }
  const A = w[0], T = A.split("-");
  if (T.length > 1) {
    const F = {
      provider: v,
      prefix: T.shift(),
      name: T.join("-")
    };
    return u && !My(F) ? null : F;
  }
  if (h && v === "") {
    const F = {
      provider: v,
      prefix: "",
      name: A
    };
    return u && !My(F, h) ? null : F;
  }
  return null;
}, My = (s, u) => s ? !!((s.provider === "" || s.provider.match(cg)) && (u && s.prefix === "" || s.prefix.match(cg)) && s.name.match(cg)) : !1, bR = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), Wy = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), sS = Object.freeze({
  ...bR,
  ...Wy
}), b1 = Object.freeze({
  ...sS,
  body: "",
  hidden: !1
});
function HY(s, u) {
  const h = {};
  !s.hFlip != !u.hFlip && (h.hFlip = !0), !s.vFlip != !u.vFlip && (h.vFlip = !0);
  const v = ((s.rotate || 0) + (u.rotate || 0)) % 4;
  return v && (h.rotate = v), h;
}
function MT(s, u) {
  const h = HY(s, u);
  for (const v in b1)
    v in Wy ? v in s && !(v in h) && (h[v] = Wy[v]) : v in u ? h[v] = u[v] : v in s && (h[v] = s[v]);
  return h;
}
function jY(s, u) {
  const h = s.icons, v = s.aliases || /* @__PURE__ */ Object.create(null), w = /* @__PURE__ */ Object.create(null);
  function A(T) {
    if (h[T])
      return w[T] = [];
    if (!(T in w)) {
      w[T] = null;
      const F = v[T] && v[T].parent, H = F && A(F);
      H && (w[T] = [F].concat(H));
    }
    return w[T];
  }
  return (u || Object.keys(h).concat(Object.keys(v))).forEach(A), w;
}
function UY(s, u, h) {
  const v = s.icons, w = s.aliases || /* @__PURE__ */ Object.create(null);
  let A = {};
  function T(F) {
    A = MT(
      v[F] || w[F],
      A
    );
  }
  return T(u), h.forEach(T), MT(s, A);
}
function wR(s, u) {
  const h = [];
  if (typeof s != "object" || typeof s.icons != "object")
    return h;
  s.not_found instanceof Array && s.not_found.forEach((w) => {
    u(w, null), h.push(w);
  });
  const v = jY(s);
  for (const w in v) {
    const A = v[w];
    A && (u(w, UY(s, w, A)), h.push(w));
  }
  return h;
}
const BY = {
  provider: "",
  aliases: {},
  not_found: {},
  ...bR
};
function Vw(s, u) {
  for (const h in u)
    if (h in s && typeof s[h] != typeof u[h])
      return !1;
  return !0;
}
function SR(s) {
  if (typeof s != "object" || s === null)
    return null;
  const u = s;
  if (typeof u.prefix != "string" || !s.icons || typeof s.icons != "object" || !Vw(s, BY))
    return null;
  const h = u.icons;
  for (const w in h) {
    const A = h[w];
    if (!w.match(cg) || typeof A.body != "string" || !Vw(
      A,
      b1
    ))
      return null;
  }
  const v = u.aliases || /* @__PURE__ */ Object.create(null);
  for (const w in v) {
    const A = v[w], T = A.parent;
    if (!w.match(cg) || typeof T != "string" || !h[T] && !v[T] || !Vw(
      A,
      b1
    ))
      return null;
  }
  return u;
}
const DT = /* @__PURE__ */ Object.create(null);
function WY(s, u) {
  return {
    provider: s,
    prefix: u,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function Hc(s, u) {
  const h = DT[s] || (DT[s] = /* @__PURE__ */ Object.create(null));
  return h[u] || (h[u] = WY(s, u));
}
function oS(s, u) {
  return SR(u) ? wR(u, (h, v) => {
    v ? s.icons[h] = v : s.missing.add(h);
  }) : [];
}
function XY(s, u, h) {
  try {
    if (typeof h.body == "string")
      return s.icons[u] = { ...h }, !0;
  } catch {
  }
  return !1;
}
let yg = !1;
function kR(s) {
  return typeof s == "boolean" && (yg = s), yg;
}
function VY(s) {
  const u = typeof s == "string" ? sx(s, !0, yg) : s;
  if (u) {
    const h = Hc(u.provider, u.prefix), v = u.name;
    return h.icons[v] || (h.missing.has(v) ? null : void 0);
  }
}
function GY(s, u) {
  const h = sx(s, !0, yg);
  if (!h)
    return !1;
  const v = Hc(h.provider, h.prefix);
  return XY(v, h.name, u);
}
function $Y(s, u) {
  if (typeof s != "object")
    return !1;
  if (typeof u != "string" && (u = s.provider || ""), yg && !u && !s.prefix) {
    let w = !1;
    return SR(s) && (s.prefix = "", wR(s, (A, T) => {
      T && GY(A, T) && (w = !0);
    })), w;
  }
  const h = s.prefix;
  if (!My({
    provider: u,
    prefix: h,
    name: "a"
  }))
    return !1;
  const v = Hc(u, h);
  return !!oS(v, s);
}
const CR = Object.freeze({
  width: null,
  height: null
}), AR = Object.freeze({
  // Dimensions
  ...CR,
  // Transformations
  ...Wy
}), qY = /(-?[0-9.]*[0-9]+[0-9.]*)/g, ZY = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function OT(s, u, h) {
  if (u === 1)
    return s;
  if (h = h || 100, typeof s == "number")
    return Math.ceil(s * u * h) / h;
  if (typeof s != "string")
    return s;
  const v = s.split(qY);
  if (v === null || !v.length)
    return s;
  const w = [];
  let A = v.shift(), T = ZY.test(A);
  for (; ; ) {
    if (T) {
      const F = parseFloat(A);
      isNaN(F) ? w.push(A) : w.push(Math.ceil(F * u * h) / h);
    } else
      w.push(A);
    if (A = v.shift(), A === void 0)
      return w.join("");
    T = !T;
  }
}
const QY = (s) => s === "unset" || s === "undefined" || s === "none";
function KY(s, u) {
  const h = {
    ...sS,
    ...s
  }, v = {
    ...AR,
    ...u
  }, w = {
    left: h.left,
    top: h.top,
    width: h.width,
    height: h.height
  };
  let A = h.body;
  [h, v].forEach((ae) => {
    const ue = [], Re = ae.hFlip, Ne = ae.vFlip;
    let Q = ae.rotate;
    Re ? Ne ? Q += 2 : (ue.push(
      "translate(" + (w.width + w.left).toString() + " " + (0 - w.top).toString() + ")"
    ), ue.push("scale(-1 1)"), w.top = w.left = 0) : Ne && (ue.push(
      "translate(" + (0 - w.left).toString() + " " + (w.height + w.top).toString() + ")"
    ), ue.push("scale(1 -1)"), w.top = w.left = 0);
    let we;
    switch (Q < 0 && (Q -= Math.floor(Q / 4) * 4), Q = Q % 4, Q) {
      case 1:
        we = w.height / 2 + w.top, ue.unshift(
          "rotate(90 " + we.toString() + " " + we.toString() + ")"
        );
        break;
      case 2:
        ue.unshift(
          "rotate(180 " + (w.width / 2 + w.left).toString() + " " + (w.height / 2 + w.top).toString() + ")"
        );
        break;
      case 3:
        we = w.width / 2 + w.left, ue.unshift(
          "rotate(-90 " + we.toString() + " " + we.toString() + ")"
        );
        break;
    }
    Q % 2 === 1 && (w.left !== w.top && (we = w.left, w.left = w.top, w.top = we), w.width !== w.height && (we = w.width, w.width = w.height, w.height = we)), ue.length && (A = '<g transform="' + ue.join(" ") + '">' + A + "</g>");
  });
  const T = v.width, F = v.height, H = w.width, U = w.height;
  let $, q;
  T === null ? (q = F === null ? "1em" : F === "auto" ? U : F, $ = OT(q, H / U)) : ($ = T === "auto" ? H : T, q = F === null ? OT($, U / H) : F === "auto" ? U : F);
  const te = {}, se = (ae, ue) => {
    QY(ue) || (te[ae] = ue.toString());
  };
  return se("width", $), se("height", q), te.viewBox = w.left.toString() + " " + w.top.toString() + " " + H.toString() + " " + U.toString(), {
    attributes: te,
    body: A
  };
}
const JY = /\sid="(\S+)"/g, eH = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let tH = 0;
function nH(s, u = eH) {
  const h = [];
  let v;
  for (; v = JY.exec(s); )
    h.push(v[1]);
  if (!h.length)
    return s;
  const w = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return h.forEach((A) => {
    const T = typeof u == "function" ? u(A) : u + (tH++).toString(), F = A.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    s = s.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + F + ')([")]|\\.[a-z])', "g"),
      "$1" + T + w + "$3"
    );
  }), s = s.replace(new RegExp(w, "g"), ""), s;
}
const w1 = /* @__PURE__ */ Object.create(null);
function rH(s, u) {
  w1[s] = u;
}
function S1(s) {
  return w1[s] || w1[""];
}
function lS(s) {
  let u;
  if (typeof s.resources == "string")
    u = [s.resources];
  else if (u = s.resources, !(u instanceof Array) || !u.length)
    return null;
  return {
    // API hosts
    resources: u,
    // Root path
    path: s.path || "/",
    // URL length limit
    maxURL: s.maxURL || 500,
    // Timeout before next host is used.
    rotate: s.rotate || 750,
    // Timeout before failing query.
    timeout: s.timeout || 5e3,
    // Randomise default API end point.
    random: s.random === !0,
    // Start index
    index: s.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: s.dataAfterTimeout !== !1
  };
}
const uS = /* @__PURE__ */ Object.create(null), ig = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], Dy = [];
for (; ig.length > 0; )
  ig.length === 1 || Math.random() > 0.5 ? Dy.push(ig.shift()) : Dy.push(ig.pop());
uS[""] = lS({
  resources: ["https://api.iconify.design"].concat(Dy)
});
function iH(s, u) {
  const h = lS(u);
  return h === null ? !1 : (uS[s] = h, !0);
}
function cS(s) {
  return uS[s];
}
const aH = () => {
  let s;
  try {
    if (s = fetch, typeof s == "function")
      return s;
  } catch {
  }
};
let _T = aH();
function sH(s, u) {
  const h = cS(s);
  if (!h)
    return 0;
  let v;
  if (!h.maxURL)
    v = 0;
  else {
    let w = 0;
    h.resources.forEach((T) => {
      w = Math.max(w, T.length);
    });
    const A = u + ".json?icons=";
    v = h.maxURL - w - h.path.length - A.length;
  }
  return v;
}
function oH(s) {
  return s === 404;
}
const lH = (s, u, h) => {
  const v = [], w = sH(s, u), A = "icons";
  let T = {
    type: A,
    provider: s,
    prefix: u,
    icons: []
  }, F = 0;
  return h.forEach((H, U) => {
    F += H.length + 1, F >= w && U > 0 && (v.push(T), T = {
      type: A,
      provider: s,
      prefix: u,
      icons: []
    }, F = H.length), T.icons.push(H);
  }), v.push(T), v;
};
function uH(s) {
  if (typeof s == "string") {
    const u = cS(s);
    if (u)
      return u.path;
  }
  return "/";
}
const cH = (s, u, h) => {
  if (!_T) {
    h("abort", 424);
    return;
  }
  let v = uH(u.provider);
  switch (u.type) {
    case "icons": {
      const A = u.prefix, F = u.icons.join(","), H = new URLSearchParams({
        icons: F
      });
      v += A + ".json?" + H.toString();
      break;
    }
    case "custom": {
      const A = u.uri;
      v += A.slice(0, 1) === "/" ? A.slice(1) : A;
      break;
    }
    default:
      h("abort", 400);
      return;
  }
  let w = 503;
  _T(s + v).then((A) => {
    const T = A.status;
    if (T !== 200) {
      setTimeout(() => {
        h(oH(T) ? "abort" : "next", T);
      });
      return;
    }
    return w = 501, A.json();
  }).then((A) => {
    if (typeof A != "object" || A === null) {
      setTimeout(() => {
        A === 404 ? h("abort", A) : h("next", w);
      });
      return;
    }
    setTimeout(() => {
      h("success", A);
    });
  }).catch(() => {
    h("next", w);
  });
}, dH = {
  prepare: lH,
  send: cH
};
function fH(s) {
  const u = {
    loaded: [],
    missing: [],
    pending: []
  }, h = /* @__PURE__ */ Object.create(null);
  s.sort((w, A) => w.provider !== A.provider ? w.provider.localeCompare(A.provider) : w.prefix !== A.prefix ? w.prefix.localeCompare(A.prefix) : w.name.localeCompare(A.name));
  let v = {
    provider: "",
    prefix: "",
    name: ""
  };
  return s.forEach((w) => {
    if (v.name === w.name && v.prefix === w.prefix && v.provider === w.provider)
      return;
    v = w;
    const A = w.provider, T = w.prefix, F = w.name, H = h[A] || (h[A] = /* @__PURE__ */ Object.create(null)), U = H[T] || (H[T] = Hc(A, T));
    let $;
    F in U.icons ? $ = u.loaded : T === "" || U.missing.has(F) ? $ = u.missing : $ = u.pending;
    const q = {
      provider: A,
      prefix: T,
      name: F
    };
    $.push(q);
  }), u;
}
function TR(s, u) {
  s.forEach((h) => {
    const v = h.loaderCallbacks;
    v && (h.loaderCallbacks = v.filter((w) => w.id !== u));
  });
}
function hH(s) {
  s.pendingCallbacksFlag || (s.pendingCallbacksFlag = !0, setTimeout(() => {
    s.pendingCallbacksFlag = !1;
    const u = s.loaderCallbacks ? s.loaderCallbacks.slice(0) : [];
    if (!u.length)
      return;
    let h = !1;
    const v = s.provider, w = s.prefix;
    u.forEach((A) => {
      const T = A.icons, F = T.pending.length;
      T.pending = T.pending.filter((H) => {
        if (H.prefix !== w)
          return !0;
        const U = H.name;
        if (s.icons[U])
          T.loaded.push({
            provider: v,
            prefix: w,
            name: U
          });
        else if (s.missing.has(U))
          T.missing.push({
            provider: v,
            prefix: w,
            name: U
          });
        else
          return h = !0, !0;
        return !1;
      }), T.pending.length !== F && (h || TR([s], A.id), A.callback(
        T.loaded.slice(0),
        T.missing.slice(0),
        T.pending.slice(0),
        A.abort
      ));
    });
  }));
}
let pH = 0;
function gH(s, u, h) {
  const v = pH++, w = TR.bind(null, h, v);
  if (!u.pending.length)
    return w;
  const A = {
    id: v,
    icons: u,
    callback: s,
    abort: w
  };
  return h.forEach((T) => {
    (T.loaderCallbacks || (T.loaderCallbacks = [])).push(A);
  }), w;
}
function vH(s, u = !0, h = !1) {
  const v = [];
  return s.forEach((w) => {
    const A = typeof w == "string" ? sx(w, u, h) : w;
    A && v.push(A);
  }), v;
}
var mH = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function yH(s, u, h, v) {
  const w = s.resources.length, A = s.random ? Math.floor(Math.random() * w) : s.index;
  let T;
  if (s.random) {
    let ve = s.resources.slice(0);
    for (T = []; ve.length > 1; ) {
      const Le = Math.floor(Math.random() * ve.length);
      T.push(ve[Le]), ve = ve.slice(0, Le).concat(ve.slice(Le + 1));
    }
    T = T.concat(ve);
  } else
    T = s.resources.slice(A).concat(s.resources.slice(0, A));
  const F = Date.now();
  let H = "pending", U = 0, $, q = null, te = [], se = [];
  typeof v == "function" && se.push(v);
  function ae() {
    q && (clearTimeout(q), q = null);
  }
  function ue() {
    H === "pending" && (H = "aborted"), ae(), te.forEach((ve) => {
      ve.status === "pending" && (ve.status = "aborted");
    }), te = [];
  }
  function Re(ve, Le) {
    Le && (se = []), typeof ve == "function" && se.push(ve);
  }
  function Ne() {
    return {
      startTime: F,
      payload: u,
      status: H,
      queriesSent: U,
      queriesPending: te.length,
      subscribe: Re,
      abort: ue
    };
  }
  function Q() {
    H = "failed", se.forEach((ve) => {
      ve(void 0, $);
    });
  }
  function we() {
    te.forEach((ve) => {
      ve.status === "pending" && (ve.status = "aborted");
    }), te = [];
  }
  function Ee(ve, Le, Qe) {
    const Be = Le !== "success";
    switch (te = te.filter((Ge) => Ge !== ve), H) {
      case "pending":
        break;
      case "failed":
        if (Be || !s.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (Le === "abort") {
      $ = Qe, Q();
      return;
    }
    if (Be) {
      $ = Qe, te.length || (T.length ? re() : Q());
      return;
    }
    if (ae(), we(), !s.random) {
      const Ge = s.resources.indexOf(ve.resource);
      Ge !== -1 && Ge !== s.index && (s.index = Ge);
    }
    H = "completed", se.forEach((Ge) => {
      Ge(Qe);
    });
  }
  function re() {
    if (H !== "pending")
      return;
    ae();
    const ve = T.shift();
    if (ve === void 0) {
      if (te.length) {
        q = setTimeout(() => {
          ae(), H === "pending" && (we(), Q());
        }, s.timeout);
        return;
      }
      Q();
      return;
    }
    const Le = {
      status: "pending",
      resource: ve,
      callback: (Qe, Be) => {
        Ee(Le, Qe, Be);
      }
    };
    te.push(Le), U++, q = setTimeout(re, s.rotate), h(ve, u, Le.callback);
  }
  return setTimeout(re), Ne;
}
function ER(s) {
  const u = {
    ...mH,
    ...s
  };
  let h = [];
  function v() {
    h = h.filter((F) => F().status === "pending");
  }
  function w(F, H, U) {
    const $ = yH(
      u,
      F,
      H,
      (q, te) => {
        v(), U && U(q, te);
      }
    );
    return h.push($), $;
  }
  function A(F) {
    return h.find((H) => F(H)) || null;
  }
  return {
    query: w,
    find: A,
    setIndex: (F) => {
      u.index = F;
    },
    getIndex: () => u.index,
    cleanup: v
  };
}
function PT() {
}
const Gw = /* @__PURE__ */ Object.create(null);
function xH(s) {
  if (!Gw[s]) {
    const u = cS(s);
    if (!u)
      return;
    const h = ER(u), v = {
      config: u,
      redundancy: h
    };
    Gw[s] = v;
  }
  return Gw[s];
}
function bH(s, u, h) {
  let v, w;
  if (typeof s == "string") {
    const A = S1(s);
    if (!A)
      return h(void 0, 424), PT;
    w = A.send;
    const T = xH(s);
    T && (v = T.redundancy);
  } else {
    const A = lS(s);
    if (A) {
      v = ER(A);
      const T = s.resources ? s.resources[0] : "", F = S1(T);
      F && (w = F.send);
    }
  }
  return !v || !w ? (h(void 0, 424), PT) : v.query(u, w, h)().abort;
}
const NT = "iconify2", xg = "iconify", RR = xg + "-count", zT = xg + "-version", LR = 36e5, wH = 168;
function k1(s, u) {
  try {
    return s.getItem(u);
  } catch {
  }
}
function dS(s, u, h) {
  try {
    return s.setItem(u, h), !0;
  } catch {
  }
}
function IT(s, u) {
  try {
    s.removeItem(u);
  } catch {
  }
}
function C1(s, u) {
  return dS(s, RR, u.toString());
}
function A1(s) {
  return parseInt(k1(s, RR)) || 0;
}
const ox = {
  local: !0,
  session: !0
}, MR = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let fS = !1;
function SH(s) {
  fS = s;
}
let Sy = typeof window > "u" ? {} : window;
function DR(s) {
  const u = s + "Storage";
  try {
    if (Sy && Sy[u] && typeof Sy[u].length == "number")
      return Sy[u];
  } catch {
  }
  ox[s] = !1;
}
function OR(s, u) {
  const h = DR(s);
  if (!h)
    return;
  const v = k1(h, zT);
  if (v !== NT) {
    if (v) {
      const F = A1(h);
      for (let H = 0; H < F; H++)
        IT(h, xg + H.toString());
    }
    dS(h, zT, NT), C1(h, 0);
    return;
  }
  const w = Math.floor(Date.now() / LR) - wH, A = (F) => {
    const H = xg + F.toString(), U = k1(h, H);
    if (typeof U == "string") {
      try {
        const $ = JSON.parse(U);
        if (typeof $ == "object" && typeof $.cached == "number" && $.cached > w && typeof $.provider == "string" && typeof $.data == "object" && typeof $.data.prefix == "string" && // Valid item: run callback
        u($, F))
          return !0;
      } catch {
      }
      IT(h, H);
    }
  };
  let T = A1(h);
  for (let F = T - 1; F >= 0; F--)
    A(F) || (F === T - 1 ? (T--, C1(h, T)) : MR[s].add(F));
}
function _R() {
  if (!fS) {
    SH(!0);
    for (const s in ox)
      OR(s, (u) => {
        const h = u.data, v = u.provider, w = h.prefix, A = Hc(
          v,
          w
        );
        if (!oS(A, h).length)
          return !1;
        const T = h.lastModified || -1;
        return A.lastModifiedCached = A.lastModifiedCached ? Math.min(A.lastModifiedCached, T) : T, !0;
      });
  }
}
function kH(s, u) {
  const h = s.lastModifiedCached;
  if (
    // Matches or newer
    h && h >= u
  )
    return h === u;
  if (s.lastModifiedCached = u, h)
    for (const v in ox)
      OR(v, (w) => {
        const A = w.data;
        return w.provider !== s.provider || A.prefix !== s.prefix || A.lastModified === u;
      });
  return !0;
}
function CH(s, u) {
  fS || _R();
  function h(v) {
    let w;
    if (!ox[v] || !(w = DR(v)))
      return;
    const A = MR[v];
    let T;
    if (A.size)
      A.delete(T = Array.from(A).shift());
    else if (T = A1(w), !C1(w, T + 1))
      return;
    const F = {
      cached: Math.floor(Date.now() / LR),
      provider: s.provider,
      data: u
    };
    return dS(
      w,
      xg + T.toString(),
      JSON.stringify(F)
    );
  }
  u.lastModified && !kH(s, u.lastModified) || Object.keys(u.icons).length && (u.not_found && (u = Object.assign({}, u), delete u.not_found), h("local") || h("session"));
}
function FT() {
}
function AH(s) {
  s.iconsLoaderFlag || (s.iconsLoaderFlag = !0, setTimeout(() => {
    s.iconsLoaderFlag = !1, hH(s);
  }));
}
function TH(s, u) {
  s.iconsToLoad ? s.iconsToLoad = s.iconsToLoad.concat(u).sort() : s.iconsToLoad = u, s.iconsQueueFlag || (s.iconsQueueFlag = !0, setTimeout(() => {
    s.iconsQueueFlag = !1;
    const { provider: h, prefix: v } = s, w = s.iconsToLoad;
    delete s.iconsToLoad;
    let A;
    if (!w || !(A = S1(h)))
      return;
    A.prepare(h, v, w).forEach((F) => {
      bH(h, F, (H) => {
        if (typeof H != "object")
          F.icons.forEach((U) => {
            s.missing.add(U);
          });
        else
          try {
            const U = oS(
              s,
              H
            );
            if (!U.length)
              return;
            const $ = s.pendingIcons;
            $ && U.forEach((q) => {
              $.delete(q);
            }), CH(s, H);
          } catch (U) {
            console.error(U);
          }
        AH(s);
      });
    });
  }));
}
const EH = (s, u) => {
  const h = vH(s, !0, kR()), v = fH(h);
  if (!v.pending.length) {
    let H = !0;
    return u && setTimeout(() => {
      H && u(
        v.loaded,
        v.missing,
        v.pending,
        FT
      );
    }), () => {
      H = !1;
    };
  }
  const w = /* @__PURE__ */ Object.create(null), A = [];
  let T, F;
  return v.pending.forEach((H) => {
    const { provider: U, prefix: $ } = H;
    if ($ === F && U === T)
      return;
    T = U, F = $, A.push(Hc(U, $));
    const q = w[U] || (w[U] = /* @__PURE__ */ Object.create(null));
    q[$] || (q[$] = []);
  }), v.pending.forEach((H) => {
    const { provider: U, prefix: $, name: q } = H, te = Hc(U, $), se = te.pendingIcons || (te.pendingIcons = /* @__PURE__ */ new Set());
    se.has(q) || (se.add(q), w[U][$].push(q));
  }), A.forEach((H) => {
    const { provider: U, prefix: $ } = H;
    w[U][$].length && TH(H, w[U][$]);
  }), u ? gH(u, v, A) : FT;
};
function RH(s, u) {
  const h = {
    ...s
  };
  for (const v in u) {
    const w = u[v], A = typeof w;
    v in CR ? (w === null || w && (A === "string" || A === "number")) && (h[v] = w) : A === typeof h[v] && (h[v] = v === "rotate" ? w % 4 : w);
  }
  return h;
}
const LH = /[\s,]+/;
function MH(s, u) {
  u.split(LH).forEach((h) => {
    switch (h.trim()) {
      case "horizontal":
        s.hFlip = !0;
        break;
      case "vertical":
        s.vFlip = !0;
        break;
    }
  });
}
function DH(s, u = 0) {
  const h = s.replace(/^-?[0-9.]*/, "");
  function v(w) {
    for (; w < 0; )
      w += 4;
    return w % 4;
  }
  if (h === "") {
    const w = parseInt(s);
    return isNaN(w) ? 0 : v(w);
  } else if (h !== s) {
    let w = 0;
    switch (h) {
      case "%":
        w = 25;
        break;
      case "deg":
        w = 90;
    }
    if (w) {
      let A = parseFloat(s.slice(0, s.length - h.length));
      return isNaN(A) ? 0 : (A = A / w, A % 1 === 0 ? v(A) : 0);
    }
  }
  return u;
}
function OH(s, u) {
  let h = s.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const v in u)
    h += " " + v + '="' + u[v] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + h + ">" + s + "</svg>";
}
function _H(s) {
  return s.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function PH(s) {
  return "data:image/svg+xml," + _H(s);
}
function NH(s) {
  return 'url("' + PH(s) + '")';
}
let dg;
function zH() {
  try {
    dg = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (s) => s
    });
  } catch {
    dg = null;
  }
}
function IH(s) {
  return dg === void 0 && zH(), dg ? dg.createHTML(s) : s;
}
const PR = {
  ...AR,
  inline: !1
}, FH = {
  xmlns: "http://www.w3.org/2000/svg",
  xmlnsXlink: "http://www.w3.org/1999/xlink",
  "aria-hidden": !0,
  role: "img"
}, YH = {
  display: "inline-block"
}, T1 = {
  backgroundColor: "currentColor"
}, NR = {
  backgroundColor: "transparent"
}, YT = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
}, HT = {
  WebkitMask: T1,
  mask: T1,
  background: NR
};
for (const s in HT) {
  const u = HT[s];
  for (const h in YT)
    u[s + h] = YT[h];
}
const HH = {
  ...PR,
  inline: !0
};
function jT(s) {
  return s + (s.match(/^[-0-9.]+$/) ? "px" : "");
}
const jH = (s, u, h, v) => {
  const w = h ? HH : PR, A = RH(w, u), T = u.mode || "svg", F = {}, H = u.style || {}, U = {
    ...T === "svg" ? FH : {},
    ref: v
  };
  for (let Ne in u) {
    const Q = u[Ne];
    if (Q !== void 0)
      switch (Ne) {
        case "icon":
        case "style":
        case "children":
        case "onLoad":
        case "mode":
        case "_ref":
        case "_inline":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          A[Ne] = Q === !0 || Q === "true" || Q === 1;
          break;
        case "flip":
          typeof Q == "string" && MH(A, Q);
          break;
        case "color":
          F.color = Q;
          break;
        case "rotate":
          typeof Q == "string" ? A[Ne] = DH(Q) : typeof Q == "number" && (A[Ne] = Q);
          break;
        case "ariaHidden":
        case "aria-hidden":
          Q !== !0 && Q !== "true" && delete U["aria-hidden"];
          break;
        default:
          w[Ne] === void 0 && (U[Ne] = Q);
      }
  }
  const $ = KY(s, A), q = $.attributes;
  if (A.inline && (F.verticalAlign = "-0.125em"), T === "svg") {
    U.style = {
      ...F,
      ...H
    }, Object.assign(U, q);
    let Ne = 0, Q = u.id;
    return typeof Q == "string" && (Q = Q.replace(/-/g, "_")), U.dangerouslySetInnerHTML = {
      __html: IH(nH($.body, Q ? () => Q + "ID" + Ne++ : "iconifyReact"))
    }, vi.createElement("svg", U);
  }
  const { body: te, width: se, height: ae } = s, ue = T === "mask" || (T === "bg" ? !1 : te.indexOf("currentColor") !== -1), Re = OH(te, {
    ...q,
    width: se + "",
    height: ae + ""
  });
  return U.style = {
    ...F,
    "--svg": NH(Re),
    width: jT(q.width),
    height: jT(q.height),
    ...YH,
    ...ue ? T1 : NR,
    ...H
  }, vi.createElement("span", U);
};
kR(!0);
rH("", dH);
if (typeof document < "u" && typeof window < "u") {
  _R();
  const s = window;
  if (s.IconifyPreload !== void 0) {
    const u = s.IconifyPreload, h = "Invalid IconifyPreload syntax.";
    typeof u == "object" && u !== null && (u instanceof Array ? u : [u]).forEach((v) => {
      try {
        // Check if item is an object and not null/array
        (typeof v != "object" || v === null || v instanceof Array || // Check for 'icons' and 'prefix'
        typeof v.icons != "object" || typeof v.prefix != "string" || // Add icon set
        !$Y(v)) && console.error(h);
      } catch {
        console.error(h);
      }
    });
  }
  if (s.IconifyProviders !== void 0) {
    const u = s.IconifyProviders;
    if (typeof u == "object" && u !== null)
      for (let h in u) {
        const v = "IconifyProviders[" + h + "] is invalid.";
        try {
          const w = u[h];
          if (typeof w != "object" || !w || w.resources === void 0)
            continue;
          iH(h, w) || console.error(v);
        } catch {
          console.error(v);
        }
      }
  }
}
class zR extends vi.Component {
  constructor(u) {
    super(u), this.state = {
      // Render placeholder before component is mounted
      icon: null
    };
  }
  /**
   * Abort loading icon
   */
  _abortLoading() {
    this._loading && (this._loading.abort(), this._loading = null);
  }
  /**
   * Update state
   */
  _setData(u) {
    this.state.icon !== u && this.setState({
      icon: u
    });
  }
  /**
   * Check if icon should be loaded
   */
  _checkIcon(u) {
    const h = this.state, v = this.props.icon;
    if (typeof v == "object" && v !== null && typeof v.body == "string") {
      this._icon = "", this._abortLoading(), (u || h.icon === null) && this._setData({
        data: v
      });
      return;
    }
    let w;
    if (typeof v != "string" || (w = sx(v, !1, !0)) === null) {
      this._abortLoading(), this._setData(null);
      return;
    }
    const A = VY(w);
    if (!A) {
      (!this._loading || this._loading.name !== v) && (this._abortLoading(), this._icon = "", this._setData(null), A !== null && (this._loading = {
        name: v,
        abort: EH([w], this._checkIcon.bind(this, !1))
      }));
      return;
    }
    if (this._icon !== v || h.icon === null) {
      this._abortLoading(), this._icon = v;
      const T = ["iconify"];
      w.prefix !== "" && T.push("iconify--" + w.prefix), w.provider !== "" && T.push("iconify--" + w.provider), this._setData({
        data: A,
        classes: T
      }), this.props.onLoad && this.props.onLoad(v);
    }
  }
  /**
   * Component mounted
   */
  componentDidMount() {
    this._checkIcon(!1);
  }
  /**
   * Component updated
   */
  componentDidUpdate(u) {
    u.icon !== this.props.icon && this._checkIcon(!0);
  }
  /**
   * Abort loading
   */
  componentWillUnmount() {
    this._abortLoading();
  }
  /**
   * Render
   */
  render() {
    const u = this.props, h = this.state.icon;
    if (h === null)
      return u.children ? u.children : vi.createElement("span", {});
    let v = u;
    return h.classes && (v = {
      ...u,
      className: (typeof u.className == "string" ? u.className + " " : "") + h.classes.join(" ")
    }), jH({
      ...sS,
      ...h.data
    }, v, u._inline, u._ref);
  }
}
const UH = vi.forwardRef(function(u, h) {
  const v = {
    ...u,
    _ref: h,
    _inline: !1
  };
  return vi.createElement(zR, v);
});
vi.forwardRef(function(u, h) {
  const v = {
    ...u,
    _ref: h,
    _inline: !0
  };
  return vi.createElement(zR, v);
});
const UT = (s) => {
  let u;
  const h = /* @__PURE__ */ new Set(), v = (H, U) => {
    const $ = typeof H == "function" ? H(u) : H;
    if (!Object.is($, u)) {
      const q = u;
      u = U ?? typeof $ != "object" ? $ : Object.assign({}, u, $), h.forEach((te) => te(u, q));
    }
  }, w = () => u, F = { setState: v, getState: w, subscribe: (H) => (h.add(H), () => h.delete(H)), destroy: () => {
    h.clear();
  } };
  return u = s(v, w, F), F;
}, BH = (s) => s ? UT(s) : UT;
var E1 = { exports: {} }, $w = {}, ky = { exports: {} }, qw = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var BT;
function WH() {
  if (BT)
    return qw;
  BT = 1;
  var s = vi;
  function u(q, te) {
    return q === te && (q !== 0 || 1 / q === 1 / te) || q !== q && te !== te;
  }
  var h = typeof Object.is == "function" ? Object.is : u, v = s.useState, w = s.useEffect, A = s.useLayoutEffect, T = s.useDebugValue;
  function F(q, te) {
    var se = te(), ae = v({ inst: { value: se, getSnapshot: te } }), ue = ae[0].inst, Re = ae[1];
    return A(function() {
      ue.value = se, ue.getSnapshot = te, H(ue) && Re({ inst: ue });
    }, [q, se, te]), w(function() {
      return H(ue) && Re({ inst: ue }), q(function() {
        H(ue) && Re({ inst: ue });
      });
    }, [q]), T(se), se;
  }
  function H(q) {
    var te = q.getSnapshot;
    q = q.value;
    try {
      var se = te();
      return !h(q, se);
    } catch {
      return !0;
    }
  }
  function U(q, te) {
    return te();
  }
  var $ = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? U : F;
  return qw.useSyncExternalStore = s.useSyncExternalStore !== void 0 ? s.useSyncExternalStore : $, qw;
}
var Zw = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WT;
function XH() {
  return WT || (WT = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var s = vi, u = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function h(we) {
      {
        for (var Ee = arguments.length, re = new Array(Ee > 1 ? Ee - 1 : 0), ve = 1; ve < Ee; ve++)
          re[ve - 1] = arguments[ve];
        v("error", we, re);
      }
    }
    function v(we, Ee, re) {
      {
        var ve = u.ReactDebugCurrentFrame, Le = ve.getStackAddendum();
        Le !== "" && (Ee += "%s", re = re.concat([Le]));
        var Qe = re.map(function(Be) {
          return String(Be);
        });
        Qe.unshift("Warning: " + Ee), Function.prototype.apply.call(console[we], console, Qe);
      }
    }
    function w(we, Ee) {
      return we === Ee && (we !== 0 || 1 / we === 1 / Ee) || we !== we && Ee !== Ee;
    }
    var A = typeof Object.is == "function" ? Object.is : w, T = s.useState, F = s.useEffect, H = s.useLayoutEffect, U = s.useDebugValue, $ = !1, q = !1;
    function te(we, Ee, re) {
      $ || s.startTransition !== void 0 && ($ = !0, h("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var ve = Ee();
      if (!q) {
        var Le = Ee();
        A(ve, Le) || (h("The result of getSnapshot should be cached to avoid an infinite loop"), q = !0);
      }
      var Qe = T({
        inst: {
          value: ve,
          getSnapshot: Ee
        }
      }), Be = Qe[0].inst, Ge = Qe[1];
      return H(function() {
        Be.value = ve, Be.getSnapshot = Ee, se(Be) && Ge({
          inst: Be
        });
      }, [we, ve, Ee]), F(function() {
        se(Be) && Ge({
          inst: Be
        });
        var ft = function() {
          se(Be) && Ge({
            inst: Be
          });
        };
        return we(ft);
      }, [we]), U(ve), ve;
    }
    function se(we) {
      var Ee = we.getSnapshot, re = we.value;
      try {
        var ve = Ee();
        return !A(re, ve);
      } catch {
        return !0;
      }
    }
    function ae(we, Ee, re) {
      return Ee();
    }
    var ue = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Re = !ue, Ne = Re ? ae : te, Q = s.useSyncExternalStore !== void 0 ? s.useSyncExternalStore : Ne;
    Zw.useSyncExternalStore = Q, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Zw;
}
var XT;
function IR() {
  return XT || (XT = 1, process.env.NODE_ENV === "production" ? ky.exports = WH() : ky.exports = XH()), ky.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VT;
function VH() {
  if (VT)
    return $w;
  VT = 1;
  var s = vi, u = IR();
  function h(U, $) {
    return U === $ && (U !== 0 || 1 / U === 1 / $) || U !== U && $ !== $;
  }
  var v = typeof Object.is == "function" ? Object.is : h, w = u.useSyncExternalStore, A = s.useRef, T = s.useEffect, F = s.useMemo, H = s.useDebugValue;
  return $w.useSyncExternalStoreWithSelector = function(U, $, q, te, se) {
    var ae = A(null);
    if (ae.current === null) {
      var ue = { hasValue: !1, value: null };
      ae.current = ue;
    } else
      ue = ae.current;
    ae = F(function() {
      function Ne(ve) {
        if (!Q) {
          if (Q = !0, we = ve, ve = te(ve), se !== void 0 && ue.hasValue) {
            var Le = ue.value;
            if (se(Le, ve))
              return Ee = Le;
          }
          return Ee = ve;
        }
        if (Le = Ee, v(we, ve))
          return Le;
        var Qe = te(ve);
        return se !== void 0 && se(Le, Qe) ? Le : (we = ve, Ee = Qe);
      }
      var Q = !1, we, Ee, re = q === void 0 ? null : q;
      return [function() {
        return Ne($());
      }, re === null ? void 0 : function() {
        return Ne(re());
      }];
    }, [$, q, te, se]);
    var Re = w(U, ae[0], ae[1]);
    return T(function() {
      ue.hasValue = !0, ue.value = Re;
    }, [Re]), H(Re), Re;
  }, $w;
}
var Qw = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var GT;
function GH() {
  return GT || (GT = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var s = vi, u = IR();
    function h($, q) {
      return $ === q && ($ !== 0 || 1 / $ === 1 / q) || $ !== $ && q !== q;
    }
    var v = typeof Object.is == "function" ? Object.is : h, w = u.useSyncExternalStore, A = s.useRef, T = s.useEffect, F = s.useMemo, H = s.useDebugValue;
    function U($, q, te, se, ae) {
      var ue = A(null), Re;
      ue.current === null ? (Re = {
        hasValue: !1,
        value: null
      }, ue.current = Re) : Re = ue.current;
      var Ne = F(function() {
        var re = !1, ve, Le, Qe = function(wt) {
          if (!re) {
            re = !0, ve = wt;
            var st = se(wt);
            if (ae !== void 0 && Re.hasValue) {
              var it = Re.value;
              if (ae(it, st))
                return Le = it, it;
            }
            return Le = st, st;
          }
          var Ht = ve, Mt = Le;
          if (v(Ht, wt))
            return Mt;
          var an = se(wt);
          return ae !== void 0 && ae(Mt, an) ? Mt : (ve = wt, Le = an, an);
        }, Be = te === void 0 ? null : te, Ge = function() {
          return Qe(q());
        }, ft = Be === null ? void 0 : function() {
          return Qe(Be());
        };
        return [Ge, ft];
      }, [q, te, se, ae]), Q = Ne[0], we = Ne[1], Ee = w($, Q, we);
      return T(function() {
        Re.hasValue = !0, Re.value = Ee;
      }, [Ee]), H(Ee), Ee;
    }
    Qw.useSyncExternalStoreWithSelector = U, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Qw;
}
process.env.NODE_ENV === "production" ? E1.exports = VH() : E1.exports = GH();
var $H = E1.exports;
const qH = /* @__PURE__ */ P_($H), { useSyncExternalStoreWithSelector: ZH } = qH;
function QH(s, u = s.getState, h) {
  const v = ZH(
    s.subscribe,
    s.getState,
    s.getServerState || s.getState,
    u,
    h
  );
  return __(v), v;
}
const $T = (s) => {
  const u = typeof s == "function" ? BH(s) : s, h = (v, w) => QH(u, v, w);
  return Object.assign(h, u), h;
}, FR = (s) => s ? $T(s) : $T, YR = (s, u) => (...h) => Object.assign({}, s, u(...h)), HR = FR(
  YR(
    {
      currentOpen: []
    },
    (s, u) => ({
      openModal: (h) => {
        if (u().currentOpen.includes(h))
          return;
        const v = [...u().currentOpen, h];
        console.log("Updated openModal: ", v), s({ currentOpen: v });
      },
      closeModal: () => {
        const h = document.querySelector("#modal-root");
        h && (h.classList.add("closed"), setTimeout(() => {
          h.classList.remove("closed");
          const v = u().currentOpen.slice(
            0,
            u().currentOpen.length - 1
          );
          console.log("Updated openModal: ", v), s({ currentOpen: v });
        }, 190));
      },
      closeAllModals: () => {
        const h = document.querySelector("#modal-root");
        h && (h.classList.add("closed"), setTimeout(() => {
          h.classList.remove("closed"), s({ currentOpen: [] });
        }, 190));
      }
    })
  )
), KH = ({
  children: s,
  currentName: u,
  variant: h = "neutral",
  size: v = "normal",
  closeButton: w = !1,
  onClose: A = () => {
  }
}) => {
  const { currentOpen: T, closeModal: F } = HR(), H = document.querySelector("#modal-root"), U = hr(null);
  return Yf(() => {
    T.length > 0 && U.current && (U.current.focus(), H.style.display = "block"), T.length === 0 && (H.style.display = "none");
  }, [T, H]), T.includes(u) && H ? YY.createPortal(
    /* @__PURE__ */ fe.jsxs(
      "div",
      {
        tabIndex: 0,
        ref: U,
        onKeyDown: ($) => {
          $.key === "Escape" && (A(), F());
        },
        className: "modal",
        children: [
          /* @__PURE__ */ fe.jsx(
            "div",
            {
              className: "modal-overlay",
              onClick: () => {
                A(), F();
              }
            }
          ),
          /* @__PURE__ */ fe.jsxs(
            "div",
            {
              className: `modal-body container rounded-box bg-${h} ${v}`,
              children: [
                w && /* @__PURE__ */ fe.jsx(
                  "button",
                  {
                    type: "button",
                    className: "close-btn",
                    onClick: () => {
                      A(), F();
                    },
                    children: /* @__PURE__ */ fe.jsx(UH, { icon: "mingcute:close-fill", height: 16 })
                  }
                ),
                s
              ]
            }
          )
        ]
      }
    ),
    H
  ) : null;
}, JH = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100], ej = ({
  children: s,
  data: u,
  itemsPerPage: h = 30
}) => {
  const v = Mu(() => u.length, [u]), [w, A] = wr(1), [T, F] = wr(h), H = Mu(() => u.slice(
    (w - 1) * T,
    w * T
  ), [u, w, T]);
  return /* @__PURE__ */ fe.jsxs(fe.Fragment, { children: [
    /* @__PURE__ */ fe.jsx("div", { className: "table-content custom-scroll", children: s({ data: H() }) }),
    /* @__PURE__ */ fe.jsxs("footer", { className: "table-footer", children: [
      /* @__PURE__ */ fe.jsx(
        "button",
        {
          className: "btn btn-icon btn-square btn-sm ring-info",
          title: "First Page",
          disabled: w === 1,
          onClick: () => A(1),
          children: /* @__PURE__ */ fe.jsx(gi, { hFlip: !0, icon: "ic:round-fast-forward" })
        }
      ),
      /* @__PURE__ */ fe.jsx(
        "button",
        {
          className: "btn btn-icon btn-square btn-sm ring-info",
          title: "Previous Page",
          disabled: w === 1,
          onClick: () => A((U) => U - 1),
          children: /* @__PURE__ */ fe.jsx(gi, { hFlip: !0, icon: "ic:round-skip-next" })
        }
      ),
      /* @__PURE__ */ fe.jsxs("span", { children: [
        Yr("table.page"),
        " ",
        /* @__PURE__ */ fe.jsx("span", { className: "page", children: w }),
        " ",
        Yr("table.of"),
        " ",
        /* @__PURE__ */ fe.jsx("span", { className: "page", children: Math.ceil(v() / T) })
      ] }),
      /* @__PURE__ */ fe.jsx(
        iS,
        {
          items: JH,
          currentSelected: h,
          labelExtractor: (U) => `${Yr("table.per-page")} ${U}`,
          keyExtractor: (U) => U,
          showQty: 3,
          position: "bottom",
          onChange: (U, $) => {
            const q = Math.ceil(v() / $), te = w * T, ae = (w > q ? q * $ : w * $) / te, ue = ae !== 1 ? Math.floor(w / ae) : w;
            w > q ? A(q) : A(ue < 1 ? 1 : ue), F($);
          }
        }
      ),
      /* @__PURE__ */ fe.jsx(
        "button",
        {
          className: "btn btn-icon btn-square btn-sm ring-info",
          title: "Next Page",
          disabled: Math.ceil(v() / T) === w,
          onClick: () => A((U) => U + 1),
          children: /* @__PURE__ */ fe.jsx(gi, { icon: "ic:round-skip-next" })
        }
      ),
      /* @__PURE__ */ fe.jsx(
        "button",
        {
          className: "btn btn-icon btn-square btn-sm ring-info",
          disabled: Math.ceil(v() / T) === w,
          onClick: () => A(Math.ceil(v() / T)),
          title: "Last Page",
          children: /* @__PURE__ */ fe.jsx(gi, { icon: "ic:round-fast-forward" })
        }
      ),
      /* @__PURE__ */ fe.jsxs("span", { children: [
        v(),
        " ",
        Yr("table.items")
      ] })
    ] })
  ] });
}, tj = (s) => {
  const [u, h] = wr(s ?? null), [v, w] = wr({
    top: (u == null ? void 0 : u.scrollTop) ?? 0,
    scrollHeight: (u == null ? void 0 : u.scrollHeight) ?? 0,
    height: (u == null ? void 0 : u.clientHeight) ?? 0
  });
  return Yf(() => {
    const A = () => {
      u && w({
        top: u.scrollTop,
        scrollHeight: u.scrollHeight,
        height: u.clientHeight
      });
    };
    if (u)
      return u == null || u.addEventListener("scroll", aS(A, 150)), () => {
        u == null || u.removeEventListener("scroll", A);
      };
  }, [u]), u ? { ...v, scrollTo: u.scrollTo, root: u, setRoot: h, changeScrollData: w } : {
    top: 0,
    scrollHeight: 0,
    height: 0,
    scrollTo: () => {
    },
    root: u,
    setRoot: h,
    changeScrollData: w
  };
}, nj = ({
  children: s,
  data: u,
  tableContainerRef: h
}) => {
  const { height: v, scrollHeight: w, top: A, root: T, setRoot: F, changeScrollData: H } = tj(h == null ? void 0 : h.current), U = hr(0), $ = hr(U.current * 2), q = 40, te = Mu(() => h.current === null ? 10 : Math.ceil(h.current.clientHeight / q), [h]);
  Yf(() => (T === null && F(h.current), U.current = te(), () => {
  }), [te, h, T, F, H]);
  const se = Mu(() => {
    let ae = 0;
    return T === null ? [] : (U.current < 10 && (U.current = te() * 2), Math.ceil(v + A) === w && ($.current += U.current, T.scrollTo({
      top: U.current * q
    })), $.current > U.current * 3 && A > 0 && (ae = $.current - U.current * 3), A === 0 && $.current > U.current * 3 && ($.current -= U.current, ae = $.current - U.current * 3, T.scrollTo({
      top: U.current * q
    })), u.slice(ae, $.current));
  }, [u, v, te, w, A, T, U]);
  return s({ data: se() });
}, rj = {
  scroll: nj,
  pagination: ej
}, ij = ({
  mode: s,
  children: u,
  data: h
}) => {
  const v = hr(null), w = rj[s];
  return /* @__PURE__ */ fe.jsx("div", { className: `table-container ${s}`, ref: v, children: /* @__PURE__ */ fe.jsx(w, { tableContainerRef: v, data: h, children: u }) });
}, aj = ({
  closeModal: s,
  config: u
}) => /* @__PURE__ */ fe.jsxs(KH, { currentName: "table-config-modal", children: [
  u.map((h) => /* @__PURE__ */ fe.jsxs("div", { className: "container row between-center", children: [
    /* @__PURE__ */ fe.jsx("span", { children: h }),
    /* @__PURE__ */ fe.jsx(
      iS,
      {
        variant: "neutral",
        items: ["Expected", "Overhelmed", "Below Expectation"]
      }
    )
  ] }, h)),
  /* @__PURE__ */ fe.jsx("button", { className: "btn btn-primary ring-info", onClick: s, children: "Save" })
] }), sj = ({
  index: s,
  columns: u,
  translation: h,
  column: v,
  ordersType: w,
  orderedHeader: A,
  order: T,
  setOrder: F,
  tBodyRef: H,
  mousePosition: U
}) => /* @__PURE__ */ fe.jsx("th", { children: /* @__PURE__ */ fe.jsxs("div", { className: "table-column", children: [
  /* @__PURE__ */ fe.jsx("span", { children: Yr(
    `data.${h}.${v}`
  ) }),
  /* @__PURE__ */ fe.jsxs("div", { className: "group-vertical rounded-box no-print", children: [
    /* @__PURE__ */ fe.jsx(
      "button",
      {
        className: `btn btn-square btn-xs ${w[T] === "asc" && A.current === v ? "active" : ""}`,
        onClick: () => {
          F(
            ($) => $ === 1 && A.current === v ? 0 : 1
          ), A.current = v;
        },
        children: /* @__PURE__ */ fe.jsx(gi, { icon: "eva:arrow-up-fill" })
      }
    ),
    /* @__PURE__ */ fe.jsx(
      "button",
      {
        className: `btn btn-square btn-xs ${w[T] === "desc" && A.current === v ? "active" : ""}`,
        onClick: () => {
          F(
            ($) => $ === 2 && A.current === v ? 0 : 2
          ), A.current = v;
        },
        children: /* @__PURE__ */ fe.jsx(gi, { icon: "eva:arrow-down-fill" })
      }
    )
  ] }),
  u.length - 1 !== s && /* @__PURE__ */ fe.jsxs(
    "button",
    {
      className: "handler",
      title: "Resize Column",
      onMouseDown: ($) => {
        U.current.startPosition = $.clientX;
      },
      onMouseMove: ($) => {
        var ae;
        if (H.current === null || U.current.startPosition === 0)
          return;
        U.current.currentPosition = $.clientX;
        const q = (ae = H.current.firstChild) == null ? void 0 : ae.childNodes[s];
        if (q === null)
          return;
        const te = q.getBoundingClientRect().width, se = U.current.currentPosition - U.current.startPosition;
        q.style.width = `${te + se}px`, U.current.startPosition = U.current.currentPosition;
      },
      onMouseUp: () => {
        U.current = {
          startPosition: 0,
          currentPosition: 0,
          endPosition: 0
        };
      },
      onMouseLeave: () => {
        U.current = {
          startPosition: 0,
          currentPosition: 0,
          endPosition: 0
        };
      },
      onClick: ($) => {
        var te;
        if ($.detail < 2 || H.current === null)
          return;
        const q = (te = H.current.firstChild) == null ? void 0 : te.childNodes[s];
        q !== null && (q.style.width = "auto");
      },
      children: [
        /* @__PURE__ */ fe.jsx("span", {}),
        /* @__PURE__ */ fe.jsx("span", {})
      ]
    }
  )
] }) }), oj = (s, u, h = "asc") => {
  if (h === "default" || u === null)
    return s;
  const v = h === "asc" ? 1 : -1;
  return s.slice().sort((w, A) => {
    const T = w[u], F = A[u];
    return T < F ? -1 * v : T > F ? 1 * v : 0;
  });
}, qT = ["default", "asc", "desc"], Bj = ({
  headers: s,
  data: u,
  dataConfig: h,
  showObject: v,
  // headersConfig,
  translation: w = "workgroups",
  action: A,
  loading: T = !1,
  hideColumn: F = [],
  mode: H = "pagination"
}) => {
  const { closeModal: U, openModal: $ } = HR(), [q] = wr(H), [te, se] = wr(0), ae = hr(null), ue = hr(null), Re = hr({
    startPosition: 0,
    currentPosition: 0,
    endPosition: 0
  }), [Ne, Q] = wr(""), we = Mu(() => T ? [] : u.filter((re) => {
    if (Ne.trim() === "")
      return u;
    const ve = Ne.toLowerCase().trim();
    return Object.entries(re).some(([Qe, Be]) => {
      var Ge;
      return F.includes(Qe) ? !1 : typeof Be == "object" && Object.hasOwnProperty.call(h, Qe) ? String(
        (Ge = h == null ? void 0 : h[Qe]) == null ? void 0 : Ge.call(h, Be, re)
      ).toLowerCase().includes(ve) : typeof Be == "object" ? String(Object.values(Be)[0]).toLowerCase().includes(ve) : String(Be).toLowerCase().includes(ve);
    });
  }), [Ne, F, u, h, T]), Ee = Mu(() => oj(we(), ae.current, qT[te]), [te, we, ae]);
  return /* @__PURE__ */ fe.jsxs("div", { className: "table-full", children: [
    /* @__PURE__ */ fe.jsxs("div", { className: "group rounded-box no-print", children: [
      /* @__PURE__ */ fe.jsx("label", { className: "bg-primary", htmlFor: "find-all-table", children: Yr("common.search") }),
      /* @__PURE__ */ fe.jsx(
        "input",
        {
          className: "input input-neutral ring-info",
          id: "find-all-table",
          placeholder: "Filtrar por....",
          style: { flex: "1" },
          onChange: aS((re) => {
            Q(re.target.value);
          }, 300)
        }
      ),
      /* @__PURE__ */ fe.jsx(
        "button",
        {
          className: "btn btn-primary btn-icon",
          style: { flex: "0" },
          onClick: () => $("table-config-modal"),
          children: /* @__PURE__ */ fe.jsx(gi, { icon: "mdi:filter" })
        }
      )
    ] }),
    /* @__PURE__ */ fe.jsx(ij, { mode: q, data: Ee(), children: ({ data: re }) => {
      let ve = 0;
      return /* @__PURE__ */ fe.jsxs("table", { className: "table", children: [
        /* @__PURE__ */ fe.jsx("thead", { children: /* @__PURE__ */ fe.jsxs("tr", { children: [
          s && s.map((Le, Qe) => F.includes(Le) ? null : (Qe++, /* @__PURE__ */ fe.jsx("th", { children: Le }, Qe))),
          s === void 0 && re.length > 0 && Object.keys(re[0]).map((Le) => F.includes(Le) ? null : (ve++, /* @__PURE__ */ fe.jsx(
            sj,
            {
              tBodyRef: ue,
              mousePosition: Re,
              orderedHeader: ae,
              order: te,
              setOrder: se,
              column: Le,
              index: ve - 1,
              columns: Object.keys(re[0]),
              ordersType: qT,
              translation: w
            },
            ve - 1
          ))),
          T && /* @__PURE__ */ fe.jsx("th", {}),
          A && /* @__PURE__ */ fe.jsx("th", { children: Yr("common.action") })
        ] }) }),
        /* @__PURE__ */ fe.jsxs("tbody", { ref: ue, children: [
          T && /* @__PURE__ */ fe.jsxs(
            "span",
            {
              className: "subtitle",
              style: {
                margin: "auto",
                marginTop: "1rem",
                width: "fit-content"
              },
              children: [
                Yr("common.loading"),
                "..."
              ]
            }
          ),
          !T && re.map((Le, Qe) => /* @__PURE__ */ fe.jsxs("tr", { tabIndex: 0, children: [
            Object.entries(Le).map(([Be, Ge], ft) => {
              var st;
              let wt;
              return F.includes(Be) ? null : (typeof Ge == "object" && (h == null ? void 0 : h[Be]) === void 0 ? wt = Object.values(Ge)[0] : Object.hasOwnProperty.call(h ?? {}, Be) ? wt = (st = h == null ? void 0 : h[Be]) == null ? void 0 : st.call(
                h,
                Ge,
                Le
              ) : wt = Ge, /* @__PURE__ */ fe.jsx(
                "td",
                {
                  title: "Click to copy",
                  style: { width: "auto" },
                  children: typeof Ge != "object" || !(v != null && v[Be]) ? wt : /* @__PURE__ */ fe.jsx("div", { className: "cell-container", children: /* @__PURE__ */ fe.jsxs("div", { className: "cell-container--header", children: [
                    wt,
                    /* @__PURE__ */ fe.jsx(
                      "button",
                      {
                        className: "btn btn-primary btn-icon btn-xs btn-square",
                        onClick: (it) => {
                          var an;
                          const Ht = (an = it.currentTarget.parentNode) == null ? void 0 : an.parentNode;
                          if (Ht === null)
                            return;
                          if (Ht.lastChild.className === "content") {
                            Ht.removeChild(
                              Ht.lastChild
                            );
                            return;
                          }
                          const Mt = document.createElement("ul");
                          Mt.className = "content", Object.entries(Ge).forEach(
                            ([We, pt]) => {
                              const ye = document.createElement("li");
                              ye.innerText = `${Yr(
                                `data.${w}.${We}`
                              )}: ${pt}`, Mt.appendChild(ye);
                            }
                          ), Ht.appendChild(
                            Mt
                          );
                        },
                        children: /* @__PURE__ */ fe.jsx(gi, { icon: "eva:arrow-down-fill" })
                      }
                    )
                  ] }) })
                },
                ft
              ));
            }),
            A && A(Le, Qe)
          ] }, Qe))
        ] })
      ] });
    } }),
    !T && u.length > 0 && /* @__PURE__ */ fe.jsx(
      aj,
      {
        config: Object.keys(u[0]),
        closeModal: U
      }
    )
  ] });
}, lj = {
  small: "4rem",
  medium: "6rem",
  large: "8rem"
}, Wj = FR(
  YR(
    {
      currentOpen: []
    },
    () => ({
      dispatch: (s) => {
        const u = document.querySelector("#toast-root"), h = document.createElement("div");
        h.className = "toast";
        const v = document.createElement("div");
        v.className = `toast-body shadow-md container rounded-box bg-${(s == null ? void 0 : s.variant) ?? "neutral"}`, h.append(v), h.style.setProperty(
          "--toast-size",
          `${lj[(s == null ? void 0 : s.size) ?? "small"]}`
        );
        const w = document.createElement("span");
        w.innerText = s.message;
        const A = document.createElement("button");
        A.className = "close-btn", A.innerText = "x", A.addEventListener("click", () => {
          h.classList.add("closed"), setTimeout(() => {
            h.remove();
          }, 200);
        });
        const T = document.createElement("div");
        T.className = "fill-bar", T.style.setProperty(
          "--fill-color",
          `var(--${(s == null ? void 0 : s.type) ?? "info"})`
        ), setTimeout(() => {
          h.classList.add("closed");
        }, 2.8 * 1e3), setTimeout(() => {
          h.remove();
        }, 3 * 1e3), v.append(w, A, T), u == null || u.appendChild(h);
      }
    })
  )
), Xj = uE, Vj = oP;
var jR = {}, R1 = { exports: {} };
/*!
 * ApexCharts v3.42.0
 * (c) 2018-2023 ApexCharts
 * Released under the MIT License.
 */
(function(s, u) {
  function h(B, t) {
    var n = Object.keys(B);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(B);
      t && (i = i.filter(function(o) {
        return Object.getOwnPropertyDescriptor(B, o).enumerable;
      })), n.push.apply(n, i);
    }
    return n;
  }
  function v(B) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t] != null ? arguments[t] : {};
      t % 2 ? h(Object(n), !0).forEach(function(i) {
        H(B, i, n[i]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(B, Object.getOwnPropertyDescriptors(n)) : h(Object(n)).forEach(function(i) {
        Object.defineProperty(B, i, Object.getOwnPropertyDescriptor(n, i));
      });
    }
    return B;
  }
  function w(B) {
    return w = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t;
    } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, w(B);
  }
  function A(B, t) {
    if (!(B instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  function T(B, t) {
    for (var n = 0; n < t.length; n++) {
      var i = t[n];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(B, i.key, i);
    }
  }
  function F(B, t, n) {
    return t && T(B.prototype, t), n && T(B, n), B;
  }
  function H(B, t, n) {
    return t in B ? Object.defineProperty(B, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : B[t] = n, B;
  }
  function U(B, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    B.prototype = Object.create(t && t.prototype, { constructor: { value: B, writable: !0, configurable: !0 } }), t && q(B, t);
  }
  function $(B) {
    return $ = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, $(B);
  }
  function q(B, t) {
    return q = Object.setPrototypeOf || function(n, i) {
      return n.__proto__ = i, n;
    }, q(B, t);
  }
  function te(B, t) {
    if (t && (typeof t == "object" || typeof t == "function"))
      return t;
    if (t !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return function(n) {
      if (n === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return n;
    }(B);
  }
  function se(B) {
    var t = function() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }();
    return function() {
      var n, i = $(B);
      if (t) {
        var o = $(this).constructor;
        n = Reflect.construct(i, arguments, o);
      } else
        n = i.apply(this, arguments);
      return te(this, n);
    };
  }
  function ae(B, t) {
    return function(n) {
      if (Array.isArray(n))
        return n;
    }(B) || function(n, i) {
      var o = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
      if (o != null) {
        var d, f, p = [], y = !0, S = !1;
        try {
          for (o = o.call(n); !(y = (d = o.next()).done) && (p.push(d.value), !i || p.length !== i); y = !0)
            ;
        } catch (C) {
          S = !0, f = C;
        } finally {
          try {
            y || o.return == null || o.return();
          } finally {
            if (S)
              throw f;
          }
        }
        return p;
      }
    }(B, t) || Re(B, t) || function() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }();
  }
  function ue(B) {
    return function(t) {
      if (Array.isArray(t))
        return Ne(t);
    }(B) || function(t) {
      if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
        return Array.from(t);
    }(B) || Re(B) || function() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }();
  }
  function Re(B, t) {
    if (B) {
      if (typeof B == "string")
        return Ne(B, t);
      var n = Object.prototype.toString.call(B).slice(8, -1);
      return n === "Object" && B.constructor && (n = B.constructor.name), n === "Map" || n === "Set" ? Array.from(B) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Ne(B, t) : void 0;
    }
  }
  function Ne(B, t) {
    (t == null || t > B.length) && (t = B.length);
    for (var n = 0, i = new Array(t); n < t; n++)
      i[n] = B[n];
    return i;
  }
  var Q = function() {
    function B() {
      A(this, B);
    }
    return F(B, [{ key: "shadeRGBColor", value: function(t, n) {
      var i = n.split(","), o = t < 0 ? 0 : 255, d = t < 0 ? -1 * t : t, f = parseInt(i[0].slice(4), 10), p = parseInt(i[1], 10), y = parseInt(i[2], 10);
      return "rgb(" + (Math.round((o - f) * d) + f) + "," + (Math.round((o - p) * d) + p) + "," + (Math.round((o - y) * d) + y) + ")";
    } }, { key: "shadeHexColor", value: function(t, n) {
      var i = parseInt(n.slice(1), 16), o = t < 0 ? 0 : 255, d = t < 0 ? -1 * t : t, f = i >> 16, p = i >> 8 & 255, y = 255 & i;
      return "#" + (16777216 + 65536 * (Math.round((o - f) * d) + f) + 256 * (Math.round((o - p) * d) + p) + (Math.round((o - y) * d) + y)).toString(16).slice(1);
    } }, { key: "shadeColor", value: function(t, n) {
      return B.isColorHex(n) ? this.shadeHexColor(t, n) : this.shadeRGBColor(t, n);
    } }], [{ key: "bind", value: function(t, n) {
      return function() {
        return t.apply(n, arguments);
      };
    } }, { key: "isObject", value: function(t) {
      return t && w(t) === "object" && !Array.isArray(t) && t != null;
    } }, { key: "is", value: function(t, n) {
      return Object.prototype.toString.call(n) === "[object " + t + "]";
    } }, { key: "listToArray", value: function(t) {
      var n, i = [];
      for (n = 0; n < t.length; n++)
        i[n] = t[n];
      return i;
    } }, { key: "extend", value: function(t, n) {
      var i = this;
      typeof Object.assign != "function" && (Object.assign = function(d) {
        if (d == null)
          throw new TypeError("Cannot convert undefined or null to object");
        for (var f = Object(d), p = 1; p < arguments.length; p++) {
          var y = arguments[p];
          if (y != null)
            for (var S in y)
              y.hasOwnProperty(S) && (f[S] = y[S]);
        }
        return f;
      });
      var o = Object.assign({}, t);
      return this.isObject(t) && this.isObject(n) && Object.keys(n).forEach(function(d) {
        i.isObject(n[d]) && d in t ? o[d] = i.extend(t[d], n[d]) : Object.assign(o, H({}, d, n[d]));
      }), o;
    } }, { key: "extendArray", value: function(t, n) {
      var i = [];
      return t.map(function(o) {
        i.push(B.extend(n, o));
      }), t = i;
    } }, { key: "monthMod", value: function(t) {
      return t % 12;
    } }, { key: "clone", value: function(t) {
      if (B.is("Array", t)) {
        for (var n = [], i = 0; i < t.length; i++)
          n[i] = this.clone(t[i]);
        return n;
      }
      if (B.is("Null", t))
        return null;
      if (B.is("Date", t))
        return t;
      if (w(t) === "object") {
        var o = {};
        for (var d in t)
          t.hasOwnProperty(d) && (o[d] = this.clone(t[d]));
        return o;
      }
      return t;
    } }, { key: "log10", value: function(t) {
      return Math.log(t) / Math.LN10;
    } }, { key: "roundToBase10", value: function(t) {
      return Math.pow(10, Math.floor(Math.log10(t)));
    } }, { key: "roundToBase", value: function(t, n) {
      return Math.pow(n, Math.floor(Math.log(t) / Math.log(n)));
    } }, { key: "parseNumber", value: function(t) {
      return t === null ? t : parseFloat(t);
    } }, { key: "stripNumber", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
      return parseFloat(t.toPrecision(n));
    } }, { key: "randomId", value: function() {
      return (Math.random() + 1).toString(36).substring(4);
    } }, { key: "noExponents", value: function(t) {
      var n = String(t).split(/[eE]/);
      if (n.length === 1)
        return n[0];
      var i = "", o = t < 0 ? "-" : "", d = n[0].replace(".", ""), f = Number(n[1]) + 1;
      if (f < 0) {
        for (i = o + "0."; f++; )
          i += "0";
        return i + d.replace(/^-/, "");
      }
      for (f -= d.length; f--; )
        i += "0";
      return d + i;
    } }, { key: "getDimensions", value: function(t) {
      var n = getComputedStyle(t, null), i = t.clientHeight, o = t.clientWidth;
      return i -= parseFloat(n.paddingTop) + parseFloat(n.paddingBottom), [o -= parseFloat(n.paddingLeft) + parseFloat(n.paddingRight), i];
    } }, { key: "getBoundingClientRect", value: function(t) {
      var n = t.getBoundingClientRect();
      return { top: n.top, right: n.right, bottom: n.bottom, left: n.left, width: t.clientWidth, height: t.clientHeight, x: n.left, y: n.top };
    } }, { key: "getLargestStringFromArr", value: function(t) {
      return t.reduce(function(n, i) {
        return Array.isArray(i) && (i = i.reduce(function(o, d) {
          return o.length > d.length ? o : d;
        })), n.length > i.length ? n : i;
      }, 0);
    } }, { key: "hexToRgba", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "#999999", n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.6;
      t.substring(0, 1) !== "#" && (t = "#999999");
      var i = t.replace("#", "");
      i = i.match(new RegExp("(.{" + i.length / 3 + "})", "g"));
      for (var o = 0; o < i.length; o++)
        i[o] = parseInt(i[o].length === 1 ? i[o] + i[o] : i[o], 16);
      return n !== void 0 && i.push(n), "rgba(" + i.join(",") + ")";
    } }, { key: "getOpacityFromRGBA", value: function(t) {
      return parseFloat(t.replace(/^.*,(.+)\)/, "$1"));
    } }, { key: "rgb2hex", value: function(t) {
      return (t = t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && t.length === 4 ? "#" + ("0" + parseInt(t[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t[3], 10).toString(16)).slice(-2) : "";
    } }, { key: "isColorHex", value: function(t) {
      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t);
    } }, { key: "getPolygonPos", value: function(t, n) {
      for (var i = [], o = 2 * Math.PI / n, d = 0; d < n; d++) {
        var f = {};
        f.x = t * Math.sin(d * o), f.y = -t * Math.cos(d * o), i.push(f);
      }
      return i;
    } }, { key: "polarToCartesian", value: function(t, n, i, o) {
      var d = (o - 90) * Math.PI / 180;
      return { x: t + i * Math.cos(d), y: n + i * Math.sin(d) };
    } }, { key: "escapeString", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x", i = t.toString().slice();
      return i = i.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, n);
    } }, { key: "negToZero", value: function(t) {
      return t < 0 ? 0 : t;
    } }, { key: "moveIndexInArray", value: function(t, n, i) {
      if (i >= t.length)
        for (var o = i - t.length + 1; o--; )
          t.push(void 0);
      return t.splice(i, 0, t.splice(n, 1)[0]), t;
    } }, { key: "extractNumber", value: function(t) {
      return parseFloat(t.replace(/[^\d.]*/g, ""));
    } }, { key: "findAncestor", value: function(t, n) {
      for (; (t = t.parentElement) && !t.classList.contains(n); )
        ;
      return t;
    } }, { key: "setELstyles", value: function(t, n) {
      for (var i in n)
        n.hasOwnProperty(i) && (t.style.key = n[i]);
    } }, { key: "isNumber", value: function(t) {
      return !isNaN(t) && parseFloat(Number(t)) === t && !isNaN(parseInt(t, 10));
    } }, { key: "isFloat", value: function(t) {
      return Number(t) === t && t % 1 != 0;
    } }, { key: "isSafari", value: function() {
      return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    } }, { key: "isFirefox", value: function() {
      return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
    } }, { key: "isIE11", value: function() {
      if (window.navigator.userAgent.indexOf("MSIE") !== -1 || window.navigator.appVersion.indexOf("Trident/") > -1)
        return !0;
    } }, { key: "isIE", value: function() {
      var t = window.navigator.userAgent, n = t.indexOf("MSIE ");
      if (n > 0)
        return parseInt(t.substring(n + 5, t.indexOf(".", n)), 10);
      if (t.indexOf("Trident/") > 0) {
        var i = t.indexOf("rv:");
        return parseInt(t.substring(i + 3, t.indexOf(".", i)), 10);
      }
      var o = t.indexOf("Edge/");
      return o > 0 && parseInt(t.substring(o + 5, t.indexOf(".", o)), 10);
    } }]), B;
  }(), we = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w, this.setEasingFunctions();
    }
    return F(B, [{ key: "setEasingFunctions", value: function() {
      var t;
      if (!this.w.globals.easing) {
        switch (this.w.config.chart.animations.easing) {
          case "linear":
            t = "-";
            break;
          case "easein":
            t = "<";
            break;
          case "easeout":
            t = ">";
            break;
          case "easeinout":
          default:
            t = "<>";
            break;
          case "swing":
            t = function(n) {
              var i = 1.70158;
              return (n -= 1) * n * ((i + 1) * n + i) + 1;
            };
            break;
          case "bounce":
            t = function(n) {
              return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375;
            };
            break;
          case "elastic":
            t = function(n) {
              return n === !!n ? n : Math.pow(2, -10 * n) * Math.sin((n - 0.075) * (2 * Math.PI) / 0.3) + 1;
            };
        }
        this.w.globals.easing = t;
      }
    } }, { key: "animateLine", value: function(t, n, i, o) {
      t.attr(n).animate(o).attr(i);
    } }, { key: "animateMarker", value: function(t, n, i, o, d, f) {
      n || (n = 0), t.attr({ r: n, width: n, height: n }).animate(o, d).attr({ r: i, width: i.width, height: i.height }).afterAll(function() {
        f();
      });
    } }, { key: "animateCircle", value: function(t, n, i, o, d) {
      t.attr({ r: n.r, cx: n.cx, cy: n.cy }).animate(o, d).attr({ r: i.r, cx: i.cx, cy: i.cy });
    } }, { key: "animateRect", value: function(t, n, i, o, d) {
      t.attr(n).animate(o).attr(i).afterAll(function() {
        return d();
      });
    } }, { key: "animatePathsGradually", value: function(t) {
      var n = t.el, i = t.realIndex, o = t.j, d = t.fill, f = t.pathFrom, p = t.pathTo, y = t.speed, S = t.delay, C = this.w, E = 0;
      C.config.chart.animations.animateGradually.enabled && (E = C.config.chart.animations.animateGradually.delay), C.config.chart.animations.dynamicAnimation.enabled && C.globals.dataChanged && C.config.chart.type !== "bar" && (E = 0), this.morphSVG(n, i, o, C.config.chart.type !== "line" || C.globals.comboCharts ? d : "stroke", f, p, y, S * E);
    } }, { key: "showDelayedElements", value: function() {
      this.w.globals.delayedElements.forEach(function(t) {
        var n = t.el;
        n.classList.remove("apexcharts-element-hidden"), n.classList.add("apexcharts-hidden-element-shown");
      });
    } }, { key: "animationCompleted", value: function(t) {
      var n = this.w;
      n.globals.animationEnded || (n.globals.animationEnded = !0, this.showDelayedElements(), typeof n.config.chart.events.animationEnd == "function" && n.config.chart.events.animationEnd(this.ctx, { el: t, w: n }));
    } }, { key: "morphSVG", value: function(t, n, i, o, d, f, p, y) {
      var S = this, C = this.w;
      d || (d = t.attr("pathFrom")), f || (f = t.attr("pathTo"));
      var E = function(L) {
        return C.config.chart.type === "radar" && (p = 1), "M 0 ".concat(C.globals.gridHeight);
      };
      (!d || d.indexOf("undefined") > -1 || d.indexOf("NaN") > -1) && (d = E()), (!f || f.indexOf("undefined") > -1 || f.indexOf("NaN") > -1) && (f = E()), C.globals.shouldAnimate || (p = 1), t.plot(d).animate(1, C.globals.easing, y).plot(d).animate(p, C.globals.easing, y).plot(f).afterAll(function() {
        Q.isNumber(i) ? i === C.globals.series[C.globals.maxValsInArrayIndex].length - 2 && C.globals.shouldAnimate && S.animationCompleted(t) : o !== "none" && C.globals.shouldAnimate && (!C.globals.comboCharts && n === C.globals.series.length - 1 || C.globals.comboCharts) && S.animationCompleted(t), S.showDelayedElements();
      });
    } }]), B;
  }(), Ee = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "getDefaultFilter", value: function(t, n) {
      var i = this.w;
      t.unfilter(!0), new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"), i.config.states.normal.filter !== "none" ? this.applyFilter(t, n, i.config.states.normal.filter.type, i.config.states.normal.filter.value) : i.config.chart.dropShadow.enabled && this.dropShadow(t, i.config.chart.dropShadow, n);
    } }, { key: "addNormalFilter", value: function(t, n) {
      var i = this.w;
      i.config.chart.dropShadow.enabled && !t.node.classList.contains("apexcharts-marker") && this.dropShadow(t, i.config.chart.dropShadow, n);
    } }, { key: "addLightenFilter", value: function(t, n, i) {
      var o = this, d = this.w, f = i.intensity;
      t.unfilter(!0), new window.SVG.Filter(), t.filter(function(p) {
        var y = d.config.chart.dropShadow;
        (y.enabled ? o.addShadow(p, n, y) : p).componentTransfer({ rgb: { type: "linear", slope: 1.5, intercept: f } });
      }), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node);
    } }, { key: "addDarkenFilter", value: function(t, n, i) {
      var o = this, d = this.w, f = i.intensity;
      t.unfilter(!0), new window.SVG.Filter(), t.filter(function(p) {
        var y = d.config.chart.dropShadow;
        (y.enabled ? o.addShadow(p, n, y) : p).componentTransfer({ rgb: { type: "linear", slope: f } });
      }), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node);
    } }, { key: "applyFilter", value: function(t, n, i) {
      var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.5;
      switch (i) {
        case "none":
          this.addNormalFilter(t, n);
          break;
        case "lighten":
          this.addLightenFilter(t, n, { intensity: o });
          break;
        case "darken":
          this.addDarkenFilter(t, n, { intensity: o });
      }
    } }, { key: "addShadow", value: function(t, n, i) {
      var o = i.blur, d = i.top, f = i.left, p = i.color, y = i.opacity, S = t.flood(Array.isArray(p) ? p[n] : p, y).composite(t.sourceAlpha, "in").offset(f, d).gaussianBlur(o).merge(t.source);
      return t.blend(t.source, S);
    } }, { key: "dropShadow", value: function(t, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, o = n.top, d = n.left, f = n.blur, p = n.color, y = n.opacity, S = n.noUserSpaceOnUse, C = this.w;
      return t.unfilter(!0), Q.isIE() && C.config.chart.type === "radialBar" || (p = Array.isArray(p) ? p[i] : p, t.filter(function(E) {
        var L = null;
        L = Q.isSafari() || Q.isFirefox() || Q.isIE() ? E.flood(p, y).composite(E.sourceAlpha, "in").offset(d, o).gaussianBlur(f) : E.flood(p, y).composite(E.sourceAlpha, "in").offset(d, o).gaussianBlur(f).merge(E.source), E.blend(E.source, L);
      }), S || t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)), t;
    } }, { key: "setSelectionFilter", value: function(t, n, i) {
      var o = this.w;
      if (o.globals.selectedDataPoints[n] !== void 0 && o.globals.selectedDataPoints[n].indexOf(i) > -1) {
        t.node.setAttribute("selected", !0);
        var d = o.config.states.active.filter;
        d !== "none" && this.applyFilter(t, n, d.type, d.value);
      }
    } }, { key: "_scaleFilterSize", value: function(t) {
      (function(n) {
        for (var i in n)
          n.hasOwnProperty(i) && t.setAttribute(i, n[i]);
      })({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
    } }]), B;
  }(), re = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "roundPathCorners", value: function(t, n) {
      function i(ee, oe, de) {
        var ke = oe.x - ee.x, _e = oe.y - ee.y, Me = Math.sqrt(ke * ke + _e * _e);
        return o(ee, oe, Math.min(1, de / Me));
      }
      function o(ee, oe, de) {
        return { x: ee.x + (oe.x - ee.x) * de, y: ee.y + (oe.y - ee.y) * de };
      }
      function d(ee, oe) {
        ee.length > 2 && (ee[ee.length - 2] = oe.x, ee[ee.length - 1] = oe.y);
      }
      function f(ee) {
        return { x: parseFloat(ee[ee.length - 2]), y: parseFloat(ee[ee.length - 1]) };
      }
      t.indexOf("NaN") > -1 && (t = "");
      var p = t.split(/[,\s]/).reduce(function(ee, oe) {
        var de = oe.match("([a-zA-Z])(.+)");
        return de ? (ee.push(de[1]), ee.push(de[2])) : ee.push(oe), ee;
      }, []).reduce(function(ee, oe) {
        return parseFloat(oe) == oe && ee.length ? ee[ee.length - 1].push(oe) : ee.push([oe]), ee;
      }, []), y = [];
      if (p.length > 1) {
        var S = f(p[0]), C = null;
        p[p.length - 1][0] == "Z" && p[0].length > 2 && (C = ["L", S.x, S.y], p[p.length - 1] = C), y.push(p[0]);
        for (var E = 1; E < p.length; E++) {
          var L = y[y.length - 1], O = p[E], P = O == C ? p[1] : p[E + 1];
          if (P && L && L.length > 2 && O[0] == "L" && P.length > 2 && P[0] == "L") {
            var I, j, V = f(L), Z = f(O), b = f(P);
            I = i(Z, V, n), j = i(Z, b, n), d(O, I), O.origPoint = Z, y.push(O);
            var M = o(I, Z, 0.5), N = o(Z, j, 0.5), X = ["C", M.x, M.y, N.x, N.y, j.x, j.y];
            X.origPoint = Z, y.push(X);
          } else
            y.push(O);
        }
        if (C) {
          var K = f(y[y.length - 1]);
          y.push(["Z"]), d(y[0], K);
        }
      } else
        y = p;
      return y.reduce(function(ee, oe) {
        return ee + oe.join(" ") + " ";
      }, "");
    } }, { key: "drawLine", value: function(t, n, i, o) {
      var d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "#a8a8a8", f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0, p = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, y = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "butt";
      return this.w.globals.dom.Paper.line().attr({ x1: t, y1: n, x2: i, y2: o, stroke: d, "stroke-dasharray": f, "stroke-width": p, "stroke-linecap": y });
    } }, { key: "drawRect", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "#fefefe", p = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1, y = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null, S = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : null, C = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 0, E = this.w.globals.dom.Paper.rect();
      return E.attr({ x: t, y: n, width: i > 0 ? i : 0, height: o > 0 ? o : 0, rx: d, ry: d, opacity: p, "stroke-width": y !== null ? y : 0, stroke: S !== null ? S : "none", "stroke-dasharray": C }), E.node.setAttribute("fill", f), E;
    } }, { key: "drawPolygon", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "#e1e1e1", i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "none";
      return this.w.globals.dom.Paper.polygon(t).attr({ fill: o, stroke: n, "stroke-width": i });
    } }, { key: "drawCircle", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      t < 0 && (t = 0);
      var i = this.w.globals.dom.Paper.circle(2 * t);
      return n !== null && i.attr(n), i;
    } }, { key: "drawPath", value: function(t) {
      var n = t.d, i = n === void 0 ? "" : n, o = t.stroke, d = o === void 0 ? "#a8a8a8" : o, f = t.strokeWidth, p = f === void 0 ? 1 : f, y = t.fill, S = t.fillOpacity, C = S === void 0 ? 1 : S, E = t.strokeOpacity, L = E === void 0 ? 1 : E, O = t.classes, P = t.strokeLinecap, I = P === void 0 ? null : P, j = t.strokeDashArray, V = j === void 0 ? 0 : j, Z = this.w;
      return I === null && (I = Z.config.stroke.lineCap), (i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = "M 0 ".concat(Z.globals.gridHeight)), Z.globals.dom.Paper.path(i).attr({ fill: y, "fill-opacity": C, stroke: d, "stroke-opacity": L, "stroke-linecap": I, "stroke-width": p, "stroke-dasharray": V, class: O });
    } }, { key: "group", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, n = this.w.globals.dom.Paper.group();
      return t !== null && n.attr(t), n;
    } }, { key: "move", value: function(t, n) {
      var i = ["M", t, n].join(" ");
      return i;
    } }, { key: "line", value: function(t, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, o = null;
      return i === null ? o = [" L", t, n].join(" ") : i === "H" ? o = [" H", t].join(" ") : i === "V" && (o = [" V", n].join(" ")), o;
    } }, { key: "curve", value: function(t, n, i, o, d, f) {
      var p = ["C", t, n, i, o, d, f].join(" ");
      return p;
    } }, { key: "quadraticCurve", value: function(t, n, i, o) {
      return ["Q", t, n, i, o].join(" ");
    } }, { key: "arc", value: function(t, n, i, o, d, f, p) {
      var y = "A";
      arguments.length > 7 && arguments[7] !== void 0 && arguments[7] && (y = "a");
      var S = [y, t, n, i, o, d, f, p].join(" ");
      return S;
    } }, { key: "renderPaths", value: function(t) {
      var n, i = t.j, o = t.realIndex, d = t.pathFrom, f = t.pathTo, p = t.stroke, y = t.strokeWidth, S = t.strokeLinecap, C = t.fill, E = t.animationDelay, L = t.initialSpeed, O = t.dataChangeSpeed, P = t.className, I = t.shouldClipToGrid, j = I === void 0 || I, V = t.bindEventsOnPaths, Z = V === void 0 || V, b = t.drawShadow, M = b === void 0 || b, N = this.w, X = new Ee(this.ctx), K = new we(this.ctx), ee = this.w.config.chart.animations.enabled, oe = ee && this.w.config.chart.animations.dynamicAnimation.enabled, de = !!(ee && !N.globals.resized || oe && N.globals.dataChanged && N.globals.shouldAnimate);
      de ? n = d : (n = f, N.globals.animationEnded = !0);
      var ke = N.config.stroke.dashArray, _e = 0;
      _e = Array.isArray(ke) ? ke[o] : N.config.stroke.dashArray;
      var Me = this.drawPath({ d: n, stroke: p, strokeWidth: y, fill: C, fillOpacity: 1, classes: P, strokeLinecap: S, strokeDashArray: _e });
      if (Me.attr("index", o), j && Me.attr({ "clip-path": "url(#gridRectMask".concat(N.globals.cuid, ")") }), N.config.states.normal.filter.type !== "none")
        X.getDefaultFilter(Me, o);
      else if (N.config.chart.dropShadow.enabled && M && (!N.config.chart.dropShadow.enabledOnSeries || N.config.chart.dropShadow.enabledOnSeries && N.config.chart.dropShadow.enabledOnSeries.indexOf(o) !== -1)) {
        var Ie = N.config.chart.dropShadow;
        X.dropShadow(Me, Ie, o);
      }
      Z && (Me.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, Me)), Me.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, Me)), Me.node.addEventListener("mousedown", this.pathMouseDown.bind(this, Me))), Me.attr({ pathTo: f, pathFrom: d });
      var rt = { el: Me, j: i, realIndex: o, pathFrom: d, pathTo: f, fill: C, strokeWidth: y, delay: E };
      return !ee || N.globals.resized || N.globals.dataChanged ? !N.globals.resized && N.globals.dataChanged || K.showDelayedElements() : K.animatePathsGradually(v(v({}, rt), {}, { speed: L })), N.globals.dataChanged && oe && de && K.animatePathsGradually(v(v({}, rt), {}, { speed: O })), Me;
    } }, { key: "drawPattern", value: function(t, n, i) {
      var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "#a8a8a8", d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
      return this.w.globals.dom.Paper.pattern(n, i, function(f) {
        t === "horizontalLines" ? f.line(0, 0, i, 0).stroke({ color: o, width: d + 1 }) : t === "verticalLines" ? f.line(0, 0, 0, n).stroke({ color: o, width: d + 1 }) : t === "slantedLines" ? f.line(0, 0, n, i).stroke({ color: o, width: d }) : t === "squares" ? f.rect(n, i).fill("none").stroke({ color: o, width: d }) : t === "circles" && f.circle(n).fill("none").stroke({ color: o, width: d });
      });
    } }, { key: "drawGradient", value: function(t, n, i, o, d) {
      var f, p = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, y = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, S = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null, C = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 0, E = this.w;
      n.length < 9 && n.indexOf("#") === 0 && (n = Q.hexToRgba(n, o)), i.length < 9 && i.indexOf("#") === 0 && (i = Q.hexToRgba(i, d));
      var L = 0, O = 1, P = 1, I = null;
      y !== null && (L = y[0] !== void 0 ? y[0] / 100 : 0, O = y[1] !== void 0 ? y[1] / 100 : 1, P = y[2] !== void 0 ? y[2] / 100 : 1, I = y[3] !== void 0 ? y[3] / 100 : null);
      var j = !(E.config.chart.type !== "donut" && E.config.chart.type !== "pie" && E.config.chart.type !== "polarArea" && E.config.chart.type !== "bubble");
      if (f = S === null || S.length === 0 ? E.globals.dom.Paper.gradient(j ? "radial" : "linear", function(b) {
        b.at(L, n, o), b.at(O, i, d), b.at(P, i, d), I !== null && b.at(I, n, o);
      }) : E.globals.dom.Paper.gradient(j ? "radial" : "linear", function(b) {
        (Array.isArray(S[C]) ? S[C] : S).forEach(function(M) {
          b.at(M.offset / 100, M.color, M.opacity);
        });
      }), j) {
        var V = E.globals.gridWidth / 2, Z = E.globals.gridHeight / 2;
        E.config.chart.type !== "bubble" ? f.attr({ gradientUnits: "userSpaceOnUse", cx: V, cy: Z, r: p }) : f.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
      } else
        t === "vertical" ? f.from(0, 0).to(0, 1) : t === "diagonal" ? f.from(0, 0).to(1, 1) : t === "horizontal" ? f.from(0, 1).to(1, 1) : t === "diagonal2" && f.from(1, 0).to(0, 1);
      return f;
    } }, { key: "getTextBasedOnMaxWidth", value: function(t) {
      var n = t.text, i = t.maxWidth, o = t.fontSize, d = t.fontFamily, f = this.getTextRects(n, o, d), p = f.width / n.length, y = Math.floor(i / p);
      return i < f.width ? n.slice(0, y - 3) + "..." : n;
    } }, { key: "drawText", value: function(t) {
      var n = this, i = t.x, o = t.y, d = t.text, f = t.textAnchor, p = t.fontSize, y = t.fontFamily, S = t.fontWeight, C = t.foreColor, E = t.opacity, L = t.maxWidth, O = t.cssClass, P = O === void 0 ? "" : O, I = t.isPlainText, j = I === void 0 || I, V = this.w;
      d === void 0 && (d = "");
      var Z = d;
      f || (f = "start"), C && C.length || (C = V.config.chart.foreColor), y = y || V.config.chart.fontFamily, S = S || "regular";
      var b, M = { maxWidth: L, fontSize: p = p || "11px", fontFamily: y };
      return Array.isArray(d) ? b = V.globals.dom.Paper.text(function(N) {
        for (var X = 0; X < d.length; X++)
          Z = d[X], L && (Z = n.getTextBasedOnMaxWidth(v({ text: d[X] }, M))), X === 0 ? N.tspan(Z) : N.tspan(Z).newLine();
      }) : (L && (Z = this.getTextBasedOnMaxWidth(v({ text: d }, M))), b = j ? V.globals.dom.Paper.plain(d) : V.globals.dom.Paper.text(function(N) {
        return N.tspan(Z);
      })), b.attr({ x: i, y: o, "text-anchor": f, "dominant-baseline": "auto", "font-size": p, "font-family": y, "font-weight": S, fill: C, class: "apexcharts-text " + P }), b.node.style.fontFamily = y, b.node.style.opacity = E, b;
    } }, { key: "drawMarker", value: function(t, n, i) {
      t = t || 0;
      var o = i.pSize || 0, d = null;
      if (i.shape === "square" || i.shape === "rect") {
        var f = i.pRadius === void 0 ? o / 2 : i.pRadius;
        n !== null && o || (o = 0, f = 0);
        var p = 1.2 * o + f, y = this.drawRect(p, p, p, p, f);
        y.attr({ x: t - p / 2, y: n - p / 2, cx: t, cy: n, class: i.class ? i.class : "", fill: i.pointFillColor, "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1, stroke: i.pointStrokeColor, "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0, "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1 }), d = y;
      } else
        i.shape !== "circle" && i.shape || (Q.isNumber(n) || (o = 0, n = 0), d = this.drawCircle(o, { cx: t, cy: n, class: i.class ? i.class : "", stroke: i.pointStrokeColor, fill: i.pointFillColor, "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1, "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0, "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1 }));
      return d;
    } }, { key: "pathMouseEnter", value: function(t, n) {
      var i = this.w, o = new Ee(this.ctx), d = parseInt(t.node.getAttribute("index"), 10), f = parseInt(t.node.getAttribute("j"), 10);
      if (typeof i.config.chart.events.dataPointMouseEnter == "function" && i.config.chart.events.dataPointMouseEnter(n, this.ctx, { seriesIndex: d, dataPointIndex: f, w: i }), this.ctx.events.fireEvent("dataPointMouseEnter", [n, this.ctx, { seriesIndex: d, dataPointIndex: f, w: i }]), (i.config.states.active.filter.type === "none" || t.node.getAttribute("selected") !== "true") && i.config.states.hover.filter.type !== "none" && !i.globals.isTouchDevice) {
        var p = i.config.states.hover.filter;
        o.applyFilter(t, d, p.type, p.value);
      }
    } }, { key: "pathMouseLeave", value: function(t, n) {
      var i = this.w, o = new Ee(this.ctx), d = parseInt(t.node.getAttribute("index"), 10), f = parseInt(t.node.getAttribute("j"), 10);
      typeof i.config.chart.events.dataPointMouseLeave == "function" && i.config.chart.events.dataPointMouseLeave(n, this.ctx, { seriesIndex: d, dataPointIndex: f, w: i }), this.ctx.events.fireEvent("dataPointMouseLeave", [n, this.ctx, { seriesIndex: d, dataPointIndex: f, w: i }]), i.config.states.active.filter.type !== "none" && t.node.getAttribute("selected") === "true" || i.config.states.hover.filter.type !== "none" && o.getDefaultFilter(t, d);
    } }, { key: "pathMouseDown", value: function(t, n) {
      var i = this.w, o = new Ee(this.ctx), d = parseInt(t.node.getAttribute("index"), 10), f = parseInt(t.node.getAttribute("j"), 10), p = "false";
      if (t.node.getAttribute("selected") === "true") {
        if (t.node.setAttribute("selected", "false"), i.globals.selectedDataPoints[d].indexOf(f) > -1) {
          var y = i.globals.selectedDataPoints[d].indexOf(f);
          i.globals.selectedDataPoints[d].splice(y, 1);
        }
      } else {
        if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) {
          i.globals.selectedDataPoints = [];
          var S = i.globals.dom.Paper.select(".apexcharts-series path").members, C = i.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members, E = function(P) {
            Array.prototype.forEach.call(P, function(I) {
              I.node.setAttribute("selected", "false"), o.getDefaultFilter(I, d);
            });
          };
          E(S), E(C);
        }
        t.node.setAttribute("selected", "true"), p = "true", i.globals.selectedDataPoints[d] === void 0 && (i.globals.selectedDataPoints[d] = []), i.globals.selectedDataPoints[d].push(f);
      }
      if (p === "true") {
        var L = i.config.states.active.filter;
        if (L !== "none")
          o.applyFilter(t, d, L.type, L.value);
        else if (i.config.states.hover.filter !== "none" && !i.globals.isTouchDevice) {
          var O = i.config.states.hover.filter;
          o.applyFilter(t, d, O.type, O.value);
        }
      } else
        i.config.states.active.filter.type !== "none" && (i.config.states.hover.filter.type === "none" || i.globals.isTouchDevice ? o.getDefaultFilter(t, d) : (O = i.config.states.hover.filter, o.applyFilter(t, d, O.type, O.value)));
      typeof i.config.chart.events.dataPointSelection == "function" && i.config.chart.events.dataPointSelection(n, this.ctx, { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: d, dataPointIndex: f, w: i }), n && this.ctx.events.fireEvent("dataPointSelection", [n, this.ctx, { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: d, dataPointIndex: f, w: i }]);
    } }, { key: "rotateAroundCenter", value: function(t) {
      var n = {};
      return t && typeof t.getBBox == "function" && (n = t.getBBox()), { x: n.x + n.width / 2, y: n.y + n.height / 2 };
    } }, { key: "getTextRects", value: function(t, n, i, o) {
      var d = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], f = this.w, p = this.drawText({ x: -200, y: -200, text: t, textAnchor: "start", fontSize: n, fontFamily: i, foreColor: "#fff", opacity: 0 });
      o && p.attr("transform", o), f.globals.dom.Paper.add(p);
      var y = p.bbox();
      return d || (y = p.node.getBoundingClientRect()), p.remove(), { width: y.width, height: y.height };
    } }, { key: "placeTextWithEllipsis", value: function(t, n, i) {
      if (typeof t.getComputedTextLength == "function" && (t.textContent = n, n.length > 0 && t.getComputedTextLength() >= i / 1.1)) {
        for (var o = n.length - 3; o > 0; o -= 3)
          if (t.getSubStringLength(0, o) <= i / 1.1)
            return void (t.textContent = n.substring(0, o) + "...");
        t.textContent = ".";
      }
    } }], [{ key: "setAttrs", value: function(t, n) {
      for (var i in n)
        n.hasOwnProperty(i) && t.setAttribute(i, n[i]);
    } }]), B;
  }(), ve = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "getStackedSeriesTotals", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = this.w, i = [];
      if (n.globals.series.length === 0)
        return i;
      for (var o = 0; o < n.globals.series[n.globals.maxValsInArrayIndex].length; o++) {
        for (var d = 0, f = 0; f < n.globals.series.length; f++)
          n.globals.series[f][o] !== void 0 && t.indexOf(f) === -1 && (d += n.globals.series[f][o]);
        i.push(d);
      }
      return i;
    } }, { key: "getSeriesTotalByIndex", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return t === null ? this.w.config.series.reduce(function(n, i) {
        return n + i;
      }, 0) : this.w.globals.series[t].reduce(function(n, i) {
        return n + i;
      }, 0);
    } }, { key: "isSeriesNull", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return (t === null ? this.w.config.series.filter(function(n) {
        return n !== null;
      }) : this.w.config.series[t].data.filter(function(n) {
        return n !== null;
      })).length === 0;
    } }, { key: "seriesHaveSameValues", value: function(t) {
      return this.w.globals.series[t].every(function(n, i, o) {
        return n === o[0];
      });
    } }, { key: "getCategoryLabels", value: function(t) {
      var n = this.w, i = t.slice();
      return n.config.xaxis.convertedCatToNumeric && (i = t.map(function(o, d) {
        return n.config.xaxis.labels.formatter(o - n.globals.minX + 1);
      })), i;
    } }, { key: "getLargestSeries", value: function() {
      var t = this.w;
      t.globals.maxValsInArrayIndex = t.globals.series.map(function(n) {
        return n.length;
      }).indexOf(Math.max.apply(Math, t.globals.series.map(function(n) {
        return n.length;
      })));
    } }, { key: "getLargestMarkerSize", value: function() {
      var t = this.w, n = 0;
      return t.globals.markers.size.forEach(function(i) {
        n = Math.max(n, i);
      }), t.config.markers.discrete && t.config.markers.discrete.length && t.config.markers.discrete.forEach(function(i) {
        n = Math.max(n, i.size);
      }), n > 0 && (n += t.config.markers.hover.sizeOffset + 1), t.globals.markers.largestSize = n, n;
    } }, { key: "getSeriesTotals", value: function() {
      var t = this.w;
      t.globals.seriesTotals = t.globals.series.map(function(n, i) {
        var o = 0;
        if (Array.isArray(n))
          for (var d = 0; d < n.length; d++)
            o += n[d];
        else
          o += n;
        return o;
      });
    } }, { key: "getSeriesTotalsXRange", value: function(t, n) {
      var i = this.w;
      return i.globals.series.map(function(o, d) {
        for (var f = 0, p = 0; p < o.length; p++)
          i.globals.seriesX[d][p] > t && i.globals.seriesX[d][p] < n && (f += o[p]);
        return f;
      });
    } }, { key: "getPercentSeries", value: function() {
      var t = this.w;
      t.globals.seriesPercent = t.globals.series.map(function(n, i) {
        var o = [];
        if (Array.isArray(n))
          for (var d = 0; d < n.length; d++) {
            var f = t.globals.stackedSeriesTotals[d], p = 0;
            f && (p = 100 * n[d] / f), o.push(p);
          }
        else {
          var y = 100 * n / t.globals.seriesTotals.reduce(function(S, C) {
            return S + C;
          }, 0);
          o.push(y);
        }
        return o;
      });
    } }, { key: "getCalculatedRatios", value: function() {
      var t, n, i, o, d = this.w.globals, f = [], p = 0, y = [], S = 0.1, C = 0;
      if (d.yRange = [], d.isMultipleYAxis)
        for (var E = 0; E < d.minYArr.length; E++)
          d.yRange.push(Math.abs(d.minYArr[E] - d.maxYArr[E])), y.push(0);
      else
        d.yRange.push(Math.abs(d.minY - d.maxY));
      d.xRange = Math.abs(d.maxX - d.minX), d.zRange = Math.abs(d.maxZ - d.minZ);
      for (var L = 0; L < d.yRange.length; L++)
        f.push(d.yRange[L] / d.gridHeight);
      if (n = d.xRange / d.gridWidth, i = Math.abs(d.initialMaxX - d.initialMinX) / d.gridWidth, t = d.yRange / d.gridWidth, o = d.xRange / d.gridHeight, (p = d.zRange / d.gridHeight * 16) || (p = 1), d.minY !== Number.MIN_VALUE && Math.abs(d.minY) !== 0 && (d.hasNegs = !0), d.isMultipleYAxis) {
        y = [];
        for (var O = 0; O < f.length; O++)
          y.push(-d.minYArr[O] / f[O]);
      } else
        y.push(-d.minY / f[0]), d.minY !== Number.MIN_VALUE && Math.abs(d.minY) !== 0 && (S = -d.minY / t, C = d.minX / n);
      return { yRatio: f, invertedYRatio: t, zRatio: p, xRatio: n, initialXRatio: i, invertedXRatio: o, baseLineInvertedY: S, baseLineY: y, baseLineX: C };
    } }, { key: "getLogSeries", value: function(t) {
      var n = this, i = this.w;
      return i.globals.seriesLog = t.map(function(o, d) {
        return i.config.yaxis[d] && i.config.yaxis[d].logarithmic ? o.map(function(f) {
          return f === null ? null : n.getLogVal(i.config.yaxis[d].logBase, f, d);
        }) : o;
      }), i.globals.invalidLogScale ? t : i.globals.seriesLog;
    } }, { key: "getBaseLog", value: function(t, n) {
      return Math.log(n) / Math.log(t);
    } }, { key: "getLogVal", value: function(t, n, i) {
      if (n === 0)
        return 0;
      var o = this.w, d = o.globals.minYArr[i] === 0 ? -1 : this.getBaseLog(t, o.globals.minYArr[i]), f = (o.globals.maxYArr[i] === 0 ? 0 : this.getBaseLog(t, o.globals.maxYArr[i])) - d;
      return n < 1 ? n / f : (this.getBaseLog(t, n) - d) / f;
    } }, { key: "getLogYRatios", value: function(t) {
      var n = this, i = this.w, o = this.w.globals;
      return o.yLogRatio = t.slice(), o.logYRange = o.yRange.map(function(d, f) {
        if (i.config.yaxis[f] && n.w.config.yaxis[f].logarithmic) {
          var p, y = -Number.MAX_VALUE, S = Number.MIN_VALUE;
          return o.seriesLog.forEach(function(C, E) {
            C.forEach(function(L) {
              i.config.yaxis[E] && i.config.yaxis[E].logarithmic && (y = Math.max(L, y), S = Math.min(L, S));
            });
          }), p = Math.pow(o.yRange[f], Math.abs(S - y) / o.yRange[f]), o.yLogRatio[f] = p / o.gridHeight, p;
        }
      }), o.invalidLogScale ? t.slice() : o.yLogRatio;
    } }], [{ key: "checkComboSeries", value: function(t) {
      var n = !1, i = 0, o = 0;
      return t.length && t[0].type !== void 0 && t.forEach(function(d) {
        d.type !== "bar" && d.type !== "column" && d.type !== "candlestick" && d.type !== "boxPlot" || i++, d.type !== void 0 && o++;
      }), o > 0 && (n = !0), { comboBarCount: i, comboCharts: n };
    } }, { key: "extendArrayProps", value: function(t, n, i) {
      return n.yaxis && (n = t.extendYAxis(n, i)), n.annotations && (n.annotations.yaxis && (n = t.extendYAxisAnnotations(n)), n.annotations.xaxis && (n = t.extendXAxisAnnotations(n)), n.annotations.points && (n = t.extendPointAnnotations(n))), n;
    } }]), B;
  }(), Le = function() {
    function B(t) {
      A(this, B), this.w = t.w, this.annoCtx = t;
    }
    return F(B, [{ key: "setOrientations", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = this.w;
      if (t.label.orientation === "vertical") {
        var o = n !== null ? n : 0, d = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(o, "']"));
        if (d !== null) {
          var f = d.getBoundingClientRect();
          d.setAttribute("x", parseFloat(d.getAttribute("x")) - f.height + 4), t.label.position === "top" ? d.setAttribute("y", parseFloat(d.getAttribute("y")) + f.width) : d.setAttribute("y", parseFloat(d.getAttribute("y")) - f.width);
          var p = this.annoCtx.graphics.rotateAroundCenter(d), y = p.x, S = p.y;
          d.setAttribute("transform", "rotate(-90 ".concat(y, " ").concat(S, ")"));
        }
      }
    } }, { key: "addBackgroundToAnno", value: function(t, n) {
      var i = this.w;
      if (!t || n.label.text === void 0 || n.label.text !== void 0 && !String(n.label.text).trim())
        return null;
      var o = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), d = t.getBoundingClientRect(), f = n.label.style.padding.left, p = n.label.style.padding.right, y = n.label.style.padding.top, S = n.label.style.padding.bottom;
      n.label.orientation === "vertical" && (y = n.label.style.padding.left, S = n.label.style.padding.right, f = n.label.style.padding.top, p = n.label.style.padding.bottom);
      var C = d.left - o.left - f, E = d.top - o.top - y, L = this.annoCtx.graphics.drawRect(C - i.globals.barPadForNumericAxis, E, d.width + f + p, d.height + y + S, n.label.borderRadius, n.label.style.background, 1, n.label.borderWidth, n.label.borderColor, 0);
      return n.id && L.node.classList.add(n.id), L;
    } }, { key: "annotationsBackground", value: function() {
      var t = this, n = this.w, i = function(o, d, f) {
        var p = n.globals.dom.baseEl.querySelector(".apexcharts-".concat(f, "-annotations .apexcharts-").concat(f, "-annotation-label[rel='").concat(d, "']"));
        if (p) {
          var y = p.parentNode, S = t.addBackgroundToAnno(p, o);
          S && (y.insertBefore(S.node, p), o.label.mouseEnter && S.node.addEventListener("mouseenter", o.label.mouseEnter.bind(t, o)), o.label.mouseLeave && S.node.addEventListener("mouseleave", o.label.mouseLeave.bind(t, o)), o.label.click && S.node.addEventListener("click", o.label.click.bind(t, o)));
        }
      };
      n.config.annotations.xaxis.map(function(o, d) {
        i(o, d, "xaxis");
      }), n.config.annotations.yaxis.map(function(o, d) {
        i(o, d, "yaxis");
      }), n.config.annotations.points.map(function(o, d) {
        i(o, d, "point");
      });
    } }, { key: "getY1Y2", value: function(t, n) {
      var i, o = t === "y1" ? n.y : n.y2, d = this.w;
      if (this.annoCtx.invertAxis) {
        var f = d.globals.labels.indexOf(o);
        d.config.xaxis.convertedCatToNumeric && (f = d.globals.categoryLabels.indexOf(o));
        var p = d.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (f + 1) + ")");
        p && (i = parseFloat(p.getAttribute("y")));
      } else {
        var y;
        d.config.yaxis[n.yAxisIndex].logarithmic ? y = (o = new ve(this.annoCtx.ctx).getLogVal(o, n.yAxisIndex)) / d.globals.yLogRatio[n.yAxisIndex] : y = (o - d.globals.minYArr[n.yAxisIndex]) / (d.globals.yRange[n.yAxisIndex] / d.globals.gridHeight), i = d.globals.gridHeight - y, !n.marker || n.y !== void 0 && n.y !== null || (i = 0), d.config.yaxis[n.yAxisIndex] && d.config.yaxis[n.yAxisIndex].reversed && (i = y);
      }
      return typeof o == "string" && o.indexOf("px") > -1 && (i = parseFloat(o)), i;
    } }, { key: "getX1X2", value: function(t, n) {
      var i = this.w, o = this.annoCtx.invertAxis ? i.globals.minY : i.globals.minX, d = this.annoCtx.invertAxis ? i.globals.maxY : i.globals.maxX, f = this.annoCtx.invertAxis ? i.globals.yRange[0] : i.globals.xRange, p = (n.x - o) / (f / i.globals.gridWidth);
      this.annoCtx.inversedReversedAxis && (p = (d - n.x) / (f / i.globals.gridWidth)), i.config.xaxis.type !== "category" && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || (p = this.getStringX(n.x));
      var y = (n.x2 - o) / (f / i.globals.gridWidth);
      return this.annoCtx.inversedReversedAxis && (y = (d - n.x2) / (f / i.globals.gridWidth)), i.config.xaxis.type !== "category" && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || (y = this.getStringX(n.x2)), n.x !== void 0 && n.x !== null || !n.marker || (p = i.globals.gridWidth), t === "x1" && typeof n.x == "string" && n.x.indexOf("px") > -1 && (p = parseFloat(n.x)), t === "x2" && typeof n.x2 == "string" && n.x2.indexOf("px") > -1 && (y = parseFloat(n.x2)), t === "x1" ? p : y;
    } }, { key: "getStringX", value: function(t) {
      var n = this.w, i = t;
      n.config.xaxis.convertedCatToNumeric && n.globals.categoryLabels.length && (t = n.globals.categoryLabels.indexOf(t) + 1);
      var o = n.globals.labels.indexOf(t), d = n.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (o + 1) + ")");
      return d && (i = parseFloat(d.getAttribute("x"))), i;
    } }]), B;
  }(), Qe = function() {
    function B(t) {
      A(this, B), this.w = t.w, this.annoCtx = t, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new Le(this.annoCtx);
    }
    return F(B, [{ key: "addXaxisAnnotation", value: function(t, n, i) {
      var o, d = this.w, f = this.helpers.getX1X2("x1", t), p = t.label.text, y = t.strokeDashArray;
      if (Q.isNumber(f)) {
        if (t.x2 === null || t.x2 === void 0) {
          var S = this.annoCtx.graphics.drawLine(f + t.offsetX, 0 + t.offsetY, f + t.offsetX, d.globals.gridHeight + t.offsetY, t.borderColor, y, t.borderWidth);
          n.appendChild(S.node), t.id && S.node.classList.add(t.id);
        } else {
          if ((o = this.helpers.getX1X2("x2", t)) < f) {
            var C = f;
            f = o, o = C;
          }
          var E = this.annoCtx.graphics.drawRect(f + t.offsetX, 0 + t.offsetY, o - f, d.globals.gridHeight + t.offsetY, 0, t.fillColor, t.opacity, 1, t.borderColor, y);
          E.node.classList.add("apexcharts-annotation-rect"), E.attr("clip-path", "url(#gridRectMask".concat(d.globals.cuid, ")")), n.appendChild(E.node), t.id && E.node.classList.add(t.id);
        }
        var L = this.annoCtx.graphics.getTextRects(p, parseFloat(t.label.style.fontSize)), O = t.label.position === "top" ? 4 : t.label.position === "center" ? d.globals.gridHeight / 2 + (t.label.orientation === "vertical" ? L.width / 2 : 0) : d.globals.gridHeight, P = this.annoCtx.graphics.drawText({ x: f + t.label.offsetX, y: O + t.label.offsetY - (t.label.orientation === "vertical" ? t.label.position === "top" ? L.width / 2 - 12 : -L.width / 2 : 0), text: p, textAnchor: t.label.textAnchor, fontSize: t.label.style.fontSize, fontFamily: t.label.style.fontFamily, fontWeight: t.label.style.fontWeight, foreColor: t.label.style.color, cssClass: "apexcharts-xaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "") });
        P.attr({ rel: i }), n.appendChild(P.node), this.annoCtx.helpers.setOrientations(t, i);
      }
    } }, { key: "drawXAxisAnnotations", value: function() {
      var t = this, n = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
      return n.config.annotations.xaxis.map(function(o, d) {
        t.addXaxisAnnotation(o, i.node, d);
      }), i;
    } }]), B;
  }(), Be = function() {
    function B(t) {
      A(this, B), this.w = t.w, this.annoCtx = t, this.helpers = new Le(this.annoCtx);
    }
    return F(B, [{ key: "addYaxisAnnotation", value: function(t, n, i) {
      var o, d = this.w, f = t.strokeDashArray, p = this.helpers.getY1Y2("y1", t), y = t.label.text;
      if (t.y2 === null || t.y2 === void 0) {
        var S = this.annoCtx.graphics.drawLine(0 + t.offsetX, p + t.offsetY, this._getYAxisAnnotationWidth(t), p + t.offsetY, t.borderColor, f, t.borderWidth);
        n.appendChild(S.node), t.id && S.node.classList.add(t.id);
      } else {
        if ((o = this.helpers.getY1Y2("y2", t)) > p) {
          var C = p;
          p = o, o = C;
        }
        var E = this.annoCtx.graphics.drawRect(0 + t.offsetX, o + t.offsetY, this._getYAxisAnnotationWidth(t), p - o, 0, t.fillColor, t.opacity, 1, t.borderColor, f);
        E.node.classList.add("apexcharts-annotation-rect"), E.attr("clip-path", "url(#gridRectMask".concat(d.globals.cuid, ")")), n.appendChild(E.node), t.id && E.node.classList.add(t.id);
      }
      var L = t.label.position === "right" ? d.globals.gridWidth : t.label.position === "center" ? d.globals.gridWidth / 2 : 0, O = this.annoCtx.graphics.drawText({ x: L + t.label.offsetX, y: (o ?? p) + t.label.offsetY - 3, text: y, textAnchor: t.label.textAnchor, fontSize: t.label.style.fontSize, fontFamily: t.label.style.fontFamily, fontWeight: t.label.style.fontWeight, foreColor: t.label.style.color, cssClass: "apexcharts-yaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "") });
      O.attr({ rel: i }), n.appendChild(O.node);
    } }, { key: "_getYAxisAnnotationWidth", value: function(t) {
      var n = this.w;
      return n.globals.gridWidth, (t.width.indexOf("%") > -1 ? n.globals.gridWidth * parseInt(t.width, 10) / 100 : parseInt(t.width, 10)) + t.offsetX;
    } }, { key: "drawYAxisAnnotations", value: function() {
      var t = this, n = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
      return n.config.annotations.yaxis.map(function(o, d) {
        t.addYaxisAnnotation(o, i.node, d);
      }), i;
    } }]), B;
  }(), Ge = function() {
    function B(t) {
      A(this, B), this.w = t.w, this.annoCtx = t, this.helpers = new Le(this.annoCtx);
    }
    return F(B, [{ key: "addPointAnnotation", value: function(t, n, i) {
      this.w;
      var o = this.helpers.getX1X2("x1", t), d = this.helpers.getY1Y2("y1", t);
      if (Q.isNumber(o)) {
        var f = { pSize: t.marker.size, pointStrokeWidth: t.marker.strokeWidth, pointFillColor: t.marker.fillColor, pointStrokeColor: t.marker.strokeColor, shape: t.marker.shape, pRadius: t.marker.radius, class: "apexcharts-point-annotation-marker ".concat(t.marker.cssClass, " ").concat(t.id ? t.id : "") }, p = this.annoCtx.graphics.drawMarker(o + t.marker.offsetX, d + t.marker.offsetY, f);
        n.appendChild(p.node);
        var y = t.label.text ? t.label.text : "", S = this.annoCtx.graphics.drawText({ x: o + t.label.offsetX, y: d + t.label.offsetY - t.marker.size - parseFloat(t.label.style.fontSize) / 1.6, text: y, textAnchor: t.label.textAnchor, fontSize: t.label.style.fontSize, fontFamily: t.label.style.fontFamily, fontWeight: t.label.style.fontWeight, foreColor: t.label.style.color, cssClass: "apexcharts-point-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "") });
        if (S.attr({ rel: i }), n.appendChild(S.node), t.customSVG.SVG) {
          var C = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + t.customSVG.cssClass });
          C.attr({ transform: "translate(".concat(o + t.customSVG.offsetX, ", ").concat(d + t.customSVG.offsetY, ")") }), C.node.innerHTML = t.customSVG.SVG, n.appendChild(C.node);
        }
        if (t.image.path) {
          var E = t.image.width ? t.image.width : 20, L = t.image.height ? t.image.height : 20;
          p = this.annoCtx.addImage({ x: o + t.image.offsetX - E / 2, y: d + t.image.offsetY - L / 2, width: E, height: L, path: t.image.path, appendTo: ".apexcharts-point-annotations" });
        }
        t.mouseEnter && p.node.addEventListener("mouseenter", t.mouseEnter.bind(this, t)), t.mouseLeave && p.node.addEventListener("mouseleave", t.mouseLeave.bind(this, t)), t.click && p.node.addEventListener("click", t.click.bind(this, t));
      }
    } }, { key: "drawPointAnnotations", value: function() {
      var t = this, n = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
      return n.config.annotations.points.map(function(o, d) {
        t.addPointAnnotation(o, i.node, d);
      }), i;
    } }]), B;
  }(), ft = { name: "en", options: { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", exportToCSV: "Download CSV", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } } }, wt = function() {
    function B() {
      A(this, B), this.yAxis = { show: !0, showAlways: !1, showForNullSeries: !0, seriesName: void 0, opposite: !1, reversed: !1, logarithmic: !1, logBase: 10, tickAmount: void 0, forceNiceScale: !1, max: void 0, min: void 0, floating: !1, decimalsInFloat: void 0, labels: { show: !0, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, formatter: void 0 }, axisBorder: { show: !1, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: !1, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: -90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, tooltip: { enabled: !1, offsetX: 0 }, crosshairs: { show: !0, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: void 0, x: 0, y: null, yAxisIndex: 0, seriesIndex: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, radius: 2, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 }, image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: void 0, y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: "100%", yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: void 0, x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: "", textAnchor: "start", foreColor: void 0, fontSize: "13px", fontFamily: void 0, fontWeight: 400, appendTo: ".apexcharts-annotations", backgroundColor: "transparent", borderColor: "#c2c2c2", borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
    }
    return F(B, [{ key: "init", value: function() {
      return { annotations: { yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: !0, easing: "easeinout", speed: 800, animateGradually: { delay: 150, enabled: !0 }, dynamicAnimation: { enabled: !0, speed: 350 } }, background: "transparent", locales: [ft], defaultLocale: "en", dropShadow: { enabled: !1, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.35 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, mouseLeave: void 0, xAxisLabelClick: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, beforeResetZoom: void 0, zoomed: void 0, scrolled: void 0, brushScrolled: void 0 }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, redrawOnParentResize: !0, redrawOnWindowResize: !0, id: void 0, group: void 0, offsetX: 0, offsetY: 0, selection: { enabled: !1, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: !1 }, brush: { enabled: !1, autoScaleYaxis: !0, target: void 0, targets: void 0 }, stacked: !1, stackType: "normal", toolbar: { show: !0, offsetX: 0, offsetY: 0, tools: { download: !0, selection: !0, zoom: !0, zoomin: !0, zoomout: !0, pan: !0, reset: !0, customIcons: [] }, export: { csv: { filename: void 0, columnDelimiter: ",", headerCategory: "category", headerValue: "value", dateFormatter: function(t) {
        return new Date(t).toDateString();
      } }, png: { filename: void 0 }, svg: { filename: void 0 } }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: !0, type: "x", autoScaleYaxis: !1, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { area: { fillTo: "origin" }, bar: { horizontal: !1, columnWidth: "70%", barHeight: "70%", distributed: !1, borderRadius: 0, borderRadiusApplication: "around", borderRadiusWhenStacked: "last", rangeBarOverlap: !0, rangeBarGroupRows: !1, hideZeroBarsWhenGrouped: !1, isDumbbell: !1, dumbbellColors: void 0, isFunnel: !1, isFunnel3d: !0, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: "top", maxItems: 100, hideOverflowingLabels: !0, orientation: "horizontal", total: { enabled: !1, formatter: void 0, offsetX: 0, offsetY: 0, style: { color: "#373d3f", fontSize: "12px", fontFamily: void 0, fontWeight: 600 } } } }, bubble: { zScaling: !0, minBubbleRadius: void 0, maxBubbleRadius: void 0 }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: !0 } }, boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } }, heatmap: { radius: 2, enableShades: !0, shadeIntensity: 0.5, reverseNegativeShade: !1, distributed: !1, useFillColorAsStroke: !1, colorScale: { inverse: !1, ranges: [], min: void 0, max: void 0 } }, treemap: { enableShades: !0, shadeIntensity: 0.5, distributed: !1, reverseNegativeShade: !1, useFillColorAsStroke: !1, dataLabels: { format: "scale" }, colorScale: { inverse: !1, ranges: [], min: void 0, max: void 0 } }, radialBar: { inverseOrder: !1, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: !0, position: "front", dropShadow: { enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: !0, startAngle: void 0, endAngle: void 0, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: !0, name: { show: !0, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter: function(t) {
        return t;
      } }, value: { show: !0, fontSize: "14px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter: function(t) {
        return t + "%";
      } }, total: { show: !1, label: "Total", fontSize: "16px", fontWeight: 600, fontFamily: void 0, color: void 0, formatter: function(t) {
        return t.globals.seriesTotals.reduce(function(n, i) {
          return n + i;
        }, 0) / t.globals.series.length + "%";
      } } } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: !0, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: !1, name: { show: !0, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter: function(t) {
        return t;
      } }, value: { show: !0, fontSize: "20px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter: function(t) {
        return t;
      } }, total: { show: !1, showAlways: !1, label: "Total", fontSize: "16px", fontWeight: 400, fontFamily: void 0, color: void 0, formatter: function(t) {
        return t.globals.seriesTotals.reduce(function(n, i) {
          return n + i;
        }, 0);
      } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: "#e8e8e8" }, spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: !0, enabledOnSeries: void 0, formatter: function(t) {
        return t !== null ? t : "";
      }, textAnchor: "middle", distributed: !1, offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0 }, background: { enabled: !0, foreColor: "#fff", borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: "#fff", dropShadow: { enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, dropShadow: { enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: !0, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 }, grid: { show: !0, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: !1 } }, yaxis: { lines: { show: !0 } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: !0, showForSingleSeries: !1, showForNullSeries: !0, showForZeroSeries: !0, floating: !1, position: "bottom", horizontalAlign: "center", inverseOrder: !1, fontSize: "12px", fontFamily: void 0, fontWeight: 400, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 4, customLegendItems: [], labels: { colors: void 0, useSeriesColors: !1 }, markers: { width: 12, height: 12, strokeWidth: 0, fillColors: void 0, strokeColor: "#fff", radius: 12, customHTML: void 0, offsetX: 0, offsetY: 0, onClick: void 0 }, itemMargin: { horizontal: 5, vertical: 2 }, onItemClick: { toggleDataSeries: !0 }, onItemHover: { highlightDataSeries: !0 } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: "circle", width: 8, height: 8, radius: 2, offsetX: 0, offsetY: 0, onClick: void 0, onDblClick: void 0, showNullDataPoints: !0, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "14px", fontFamily: void 0 } }, responsive: [], series: void 0, states: { normal: { filter: { type: "none", value: 0 } }, hover: { filter: { type: "lighten", value: 0.1 } }, active: { allowMultipleDataPointsSelection: !1, filter: { type: "darken", value: 0.5 } } }, title: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 0, floating: !1, style: { fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 30, floating: !1, style: { fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0 } }, stroke: { show: !0, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: !0, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] } } }, tooltip: { enabled: !0, enabledOnSeries: void 0, shared: !0, followCursor: !1, intersect: !1, inverseOrder: !1, custom: void 0, fillSeriesColor: !1, theme: "light", cssClass: "", style: { fontSize: "12px", fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: !1 }, x: { show: !0, format: "dd MMM", formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(t) {
        return t ? t + ": " : "";
      } } }, z: { formatter: void 0, title: "Size: " }, marker: { show: !0, fillColors: void 0 }, items: { display: "flex" }, fixed: { enabled: !1, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], convertedCatToNumeric: !1, offsetX: 0, offsetY: 0, overwriteCategories: void 0, labels: { show: !0, rotate: -45, rotateAlways: !1, hideOverlappingLabels: !0, trim: !1, minHeight: void 0, maxHeight: 120, showDuplicates: !0, style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeUTC: !0, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss", second: "HH:mm:ss" } }, group: { groups: [], style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" } }, axisBorder: { show: !0, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: !0, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 }, tickAmount: void 0, tickPlacement: "on", min: void 0, max: void 0, range: void 0, floating: !1, decimalsInFloat: void 0, position: "bottom", title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, crosshairs: { show: !0, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: !1, left: 0, top: 0, blur: 1, opacity: 0.4 } }, tooltip: { enabled: !0, offsetY: 0, formatter: void 0, style: { fontSize: "12px", fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: "light", palette: "palette1", monochrome: { enabled: !1, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
    } }]), B;
  }(), st = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w, this.graphics = new re(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new Le(this), this.xAxisAnnotations = new Qe(this), this.yAxisAnnotations = new Be(this), this.pointsAnnotations = new Ge(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
    }
    return F(B, [{ key: "drawAxesAnnotations", value: function() {
      var t = this.w;
      if (t.globals.axisCharts) {
        for (var n = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), o = this.pointsAnnotations.drawPointAnnotations(), d = t.config.chart.animations.enabled, f = [n, i, o], p = [i.node, n.node, o.node], y = 0; y < 3; y++)
          t.globals.dom.elGraphical.add(f[y]), !d || t.globals.resized || t.globals.dataChanged || t.config.chart.type !== "scatter" && t.config.chart.type !== "bubble" && t.globals.dataPoints > 1 && p[y].classList.add("apexcharts-element-hidden"), t.globals.delayedElements.push({ el: p[y], index: 0 });
        this.helpers.annotationsBackground();
      }
    } }, { key: "drawImageAnnos", value: function() {
      var t = this;
      this.w.config.annotations.images.map(function(n, i) {
        t.addImage(n, i);
      });
    } }, { key: "drawTextAnnos", value: function() {
      var t = this;
      this.w.config.annotations.texts.map(function(n, i) {
        t.addText(n, i);
      });
    } }, { key: "addXaxisAnnotation", value: function(t, n, i) {
      this.xAxisAnnotations.addXaxisAnnotation(t, n, i);
    } }, { key: "addYaxisAnnotation", value: function(t, n, i) {
      this.yAxisAnnotations.addYaxisAnnotation(t, n, i);
    } }, { key: "addPointAnnotation", value: function(t, n, i) {
      this.pointsAnnotations.addPointAnnotation(t, n, i);
    } }, { key: "addText", value: function(t, n) {
      var i = t.x, o = t.y, d = t.text, f = t.textAnchor, p = t.foreColor, y = t.fontSize, S = t.fontFamily, C = t.fontWeight, E = t.cssClass, L = t.backgroundColor, O = t.borderWidth, P = t.strokeDashArray, I = t.borderRadius, j = t.borderColor, V = t.appendTo, Z = V === void 0 ? ".apexcharts-annotations" : V, b = t.paddingLeft, M = b === void 0 ? 4 : b, N = t.paddingRight, X = N === void 0 ? 4 : N, K = t.paddingBottom, ee = K === void 0 ? 2 : K, oe = t.paddingTop, de = oe === void 0 ? 2 : oe, ke = this.w, _e = this.graphics.drawText({ x: i, y: o, text: d, textAnchor: f || "start", fontSize: y || "12px", fontWeight: C || "regular", fontFamily: S || ke.config.chart.fontFamily, foreColor: p || ke.config.chart.foreColor, cssClass: E }), Me = ke.globals.dom.baseEl.querySelector(Z);
      Me && Me.appendChild(_e.node);
      var Ie = _e.bbox();
      if (d) {
        var rt = this.graphics.drawRect(Ie.x - M, Ie.y - de, Ie.width + M + X, Ie.height + ee + de, I, L || "transparent", 1, O, j, P);
        Me.insertBefore(rt.node, _e.node);
      }
    } }, { key: "addImage", value: function(t, n) {
      var i = this.w, o = t.path, d = t.x, f = d === void 0 ? 0 : d, p = t.y, y = p === void 0 ? 0 : p, S = t.width, C = S === void 0 ? 20 : S, E = t.height, L = E === void 0 ? 20 : E, O = t.appendTo, P = O === void 0 ? ".apexcharts-annotations" : O, I = i.globals.dom.Paper.image(o);
      I.size(C, L).move(f, y);
      var j = i.globals.dom.baseEl.querySelector(P);
      return j && j.appendChild(I.node), I;
    } }, { key: "addXaxisAnnotationExternal", value: function(t, n, i) {
      return this.addAnnotationExternal({ params: t, pushToMemory: n, context: i, type: "xaxis", contextMethod: i.addXaxisAnnotation }), i;
    } }, { key: "addYaxisAnnotationExternal", value: function(t, n, i) {
      return this.addAnnotationExternal({ params: t, pushToMemory: n, context: i, type: "yaxis", contextMethod: i.addYaxisAnnotation }), i;
    } }, { key: "addPointAnnotationExternal", value: function(t, n, i) {
      return this.invertAxis === void 0 && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: t, pushToMemory: n, context: i, type: "point", contextMethod: i.addPointAnnotation }), i;
    } }, { key: "addAnnotationExternal", value: function(t) {
      var n = t.params, i = t.pushToMemory, o = t.context, d = t.type, f = t.contextMethod, p = o, y = p.w, S = y.globals.dom.baseEl.querySelector(".apexcharts-".concat(d, "-annotations")), C = S.childNodes.length + 1, E = new wt(), L = Object.assign({}, d === "xaxis" ? E.xAxisAnnotation : d === "yaxis" ? E.yAxisAnnotation : E.pointAnnotation), O = Q.extend(L, n);
      switch (d) {
        case "xaxis":
          this.addXaxisAnnotation(O, S, C);
          break;
        case "yaxis":
          this.addYaxisAnnotation(O, S, C);
          break;
        case "point":
          this.addPointAnnotation(O, S, C);
      }
      var P = y.globals.dom.baseEl.querySelector(".apexcharts-".concat(d, "-annotations .apexcharts-").concat(d, "-annotation-label[rel='").concat(C, "']")), I = this.helpers.addBackgroundToAnno(P, O);
      return I && S.insertBefore(I.node, P), i && y.globals.memory.methodsToExec.push({ context: p, id: O.id ? O.id : Q.randomId(), method: f, label: "addAnnotation", params: n }), o;
    } }, { key: "clearAnnotations", value: function(t) {
      var n = t.w, i = n.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
      n.globals.memory.methodsToExec.map(function(o, d) {
        o.label !== "addText" && o.label !== "addAnnotation" || n.globals.memory.methodsToExec.splice(d, 1);
      }), i = Q.listToArray(i), Array.prototype.forEach.call(i, function(o) {
        for (; o.firstChild; )
          o.removeChild(o.firstChild);
      });
    } }, { key: "removeAnnotation", value: function(t, n) {
      var i = t.w, o = i.globals.dom.baseEl.querySelectorAll(".".concat(n));
      o && (i.globals.memory.methodsToExec.map(function(d, f) {
        d.id === n && i.globals.memory.methodsToExec.splice(f, 1);
      }), Array.prototype.forEach.call(o, function(d) {
        d.parentElement.removeChild(d);
      }));
    } }]), B;
  }(), it = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    }
    return F(B, [{ key: "isValidDate", value: function(t) {
      return !isNaN(this.parseDate(t));
    } }, { key: "getTimeStamp", value: function(t) {
      return Date.parse(t) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toISOString().substr(0, 25)).getTime() : new Date(t).getTime() : t;
    } }, { key: "getDate", value: function(t) {
      return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toUTCString()) : new Date(t);
    } }, { key: "parseDate", value: function(t) {
      var n = Date.parse(t);
      if (!isNaN(n))
        return this.getTimeStamp(t);
      var i = Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
      return i = this.getTimeStamp(i);
    } }, { key: "parseDateWithTimezone", value: function(t) {
      return Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
    } }, { key: "formatDate", value: function(t, n) {
      var i = this.w.globals.locale, o = this.w.config.xaxis.labels.datetimeUTC, d = ["\0"].concat(ue(i.months)), f = [""].concat(ue(i.shortMonths)), p = [""].concat(ue(i.days)), y = [""].concat(ue(i.shortDays));
      function S(ee, oe) {
        var de = ee + "";
        for (oe = oe || 2; de.length < oe; )
          de = "0" + de;
        return de;
      }
      var C = o ? t.getUTCFullYear() : t.getFullYear();
      n = (n = (n = n.replace(/(^|[^\\])yyyy+/g, "$1" + C)).replace(/(^|[^\\])yy/g, "$1" + C.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + C);
      var E = (o ? t.getUTCMonth() : t.getMonth()) + 1;
      n = (n = (n = (n = n.replace(/(^|[^\\])MMMM+/g, "$1" + d[0])).replace(/(^|[^\\])MMM/g, "$1" + f[0])).replace(/(^|[^\\])MM/g, "$1" + S(E))).replace(/(^|[^\\])M/g, "$1" + E);
      var L = o ? t.getUTCDate() : t.getDate();
      n = (n = (n = (n = n.replace(/(^|[^\\])dddd+/g, "$1" + p[0])).replace(/(^|[^\\])ddd/g, "$1" + y[0])).replace(/(^|[^\\])dd/g, "$1" + S(L))).replace(/(^|[^\\])d/g, "$1" + L);
      var O = o ? t.getUTCHours() : t.getHours(), P = O > 12 ? O - 12 : O === 0 ? 12 : O;
      n = (n = (n = (n = n.replace(/(^|[^\\])HH+/g, "$1" + S(O))).replace(/(^|[^\\])H/g, "$1" + O)).replace(/(^|[^\\])hh+/g, "$1" + S(P))).replace(/(^|[^\\])h/g, "$1" + P);
      var I = o ? t.getUTCMinutes() : t.getMinutes();
      n = (n = n.replace(/(^|[^\\])mm+/g, "$1" + S(I))).replace(/(^|[^\\])m/g, "$1" + I);
      var j = o ? t.getUTCSeconds() : t.getSeconds();
      n = (n = n.replace(/(^|[^\\])ss+/g, "$1" + S(j))).replace(/(^|[^\\])s/g, "$1" + j);
      var V = o ? t.getUTCMilliseconds() : t.getMilliseconds();
      n = n.replace(/(^|[^\\])fff+/g, "$1" + S(V, 3)), V = Math.round(V / 10), n = n.replace(/(^|[^\\])ff/g, "$1" + S(V)), V = Math.round(V / 10);
      var Z = O < 12 ? "AM" : "PM";
      n = (n = (n = n.replace(/(^|[^\\])f/g, "$1" + V)).replace(/(^|[^\\])TT+/g, "$1" + Z)).replace(/(^|[^\\])T/g, "$1" + Z.charAt(0));
      var b = Z.toLowerCase();
      n = (n = n.replace(/(^|[^\\])tt+/g, "$1" + b)).replace(/(^|[^\\])t/g, "$1" + b.charAt(0));
      var M = -t.getTimezoneOffset(), N = o || !M ? "Z" : M > 0 ? "+" : "-";
      if (!o) {
        var X = (M = Math.abs(M)) % 60;
        N += S(Math.floor(M / 60)) + ":" + S(X);
      }
      n = n.replace(/(^|[^\\])K/g, "$1" + N);
      var K = (o ? t.getUTCDay() : t.getDay()) + 1;
      return n = (n = (n = (n = (n = n.replace(new RegExp(p[0], "g"), p[K])).replace(new RegExp(y[0], "g"), y[K])).replace(new RegExp(d[0], "g"), d[E])).replace(new RegExp(f[0], "g"), f[E])).replace(/\\(.)/g, "$1");
    } }, { key: "getTimeUnitsfromTimestamp", value: function(t, n, i) {
      var o = this.w;
      o.config.xaxis.min !== void 0 && (t = o.config.xaxis.min), o.config.xaxis.max !== void 0 && (n = o.config.xaxis.max);
      var d = this.getDate(t), f = this.getDate(n), p = this.formatDate(d, "yyyy MM dd HH mm ss fff").split(" "), y = this.formatDate(f, "yyyy MM dd HH mm ss fff").split(" ");
      return { minMillisecond: parseInt(p[6], 10), maxMillisecond: parseInt(y[6], 10), minSecond: parseInt(p[5], 10), maxSecond: parseInt(y[5], 10), minMinute: parseInt(p[4], 10), maxMinute: parseInt(y[4], 10), minHour: parseInt(p[3], 10), maxHour: parseInt(y[3], 10), minDate: parseInt(p[2], 10), maxDate: parseInt(y[2], 10), minMonth: parseInt(p[1], 10) - 1, maxMonth: parseInt(y[1], 10) - 1, minYear: parseInt(p[0], 10), maxYear: parseInt(y[0], 10) };
    } }, { key: "isLeapYear", value: function(t) {
      return t % 4 == 0 && t % 100 != 0 || t % 400 == 0;
    } }, { key: "calculcateLastDaysOfMonth", value: function(t, n, i) {
      return this.determineDaysOfMonths(t, n) - i;
    } }, { key: "determineDaysOfYear", value: function(t) {
      var n = 365;
      return this.isLeapYear(t) && (n = 366), n;
    } }, { key: "determineRemainingDaysOfYear", value: function(t, n, i) {
      var o = this.daysCntOfYear[n] + i;
      return n > 1 && this.isLeapYear() && o++, o;
    } }, { key: "determineDaysOfMonths", value: function(t, n) {
      var i = 30;
      switch (t = Q.monthMod(t), !0) {
        case this.months30.indexOf(t) > -1:
          t === 2 && (i = this.isLeapYear(n) ? 29 : 28);
          break;
        case this.months31.indexOf(t) > -1:
        default:
          i = 31;
      }
      return i;
    } }]), B;
  }(), Ht = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w, this.tooltipKeyFormat = "dd MMM";
    }
    return F(B, [{ key: "xLabelFormat", value: function(t, n, i, o) {
      var d = this.w;
      if (d.config.xaxis.type === "datetime" && d.config.xaxis.labels.formatter === void 0 && d.config.tooltip.x.formatter === void 0) {
        var f = new it(this.ctx);
        return f.formatDate(f.getDate(n), d.config.tooltip.x.format);
      }
      return t(n, i, o);
    } }, { key: "defaultGeneralFormatter", value: function(t) {
      return Array.isArray(t) ? t.map(function(n) {
        return n;
      }) : t;
    } }, { key: "defaultYFormatter", value: function(t, n, i) {
      var o = this.w;
      return Q.isNumber(t) && (t = o.globals.yValueDecimal !== 0 ? t.toFixed(n.decimalsInFloat !== void 0 ? n.decimalsInFloat : o.globals.yValueDecimal) : o.globals.maxYArr[i] - o.globals.minYArr[i] < 5 ? t.toFixed(1) : t.toFixed(0)), t;
    } }, { key: "setLabelFormatters", value: function() {
      var t = this, n = this.w;
      return n.globals.xaxisTooltipFormatter = function(i) {
        return t.defaultGeneralFormatter(i);
      }, n.globals.ttKeyFormatter = function(i) {
        return t.defaultGeneralFormatter(i);
      }, n.globals.ttZFormatter = function(i) {
        return i;
      }, n.globals.legendFormatter = function(i) {
        return t.defaultGeneralFormatter(i);
      }, n.config.xaxis.labels.formatter !== void 0 ? n.globals.xLabelFormatter = n.config.xaxis.labels.formatter : n.globals.xLabelFormatter = function(i) {
        if (Q.isNumber(i)) {
          if (!n.config.xaxis.convertedCatToNumeric && n.config.xaxis.type === "numeric") {
            if (Q.isNumber(n.config.xaxis.decimalsInFloat))
              return i.toFixed(n.config.xaxis.decimalsInFloat);
            var o = n.globals.maxX - n.globals.minX;
            return o > 0 && o < 100 ? i.toFixed(1) : i.toFixed(0);
          }
          return n.globals.isBarHorizontal && n.globals.maxY - n.globals.minYArr < 4 ? i.toFixed(1) : i.toFixed(0);
        }
        return i;
      }, typeof n.config.tooltip.x.formatter == "function" ? n.globals.ttKeyFormatter = n.config.tooltip.x.formatter : n.globals.ttKeyFormatter = n.globals.xLabelFormatter, typeof n.config.xaxis.tooltip.formatter == "function" && (n.globals.xaxisTooltipFormatter = n.config.xaxis.tooltip.formatter), (Array.isArray(n.config.tooltip.y) || n.config.tooltip.y.formatter !== void 0) && (n.globals.ttVal = n.config.tooltip.y), n.config.tooltip.z.formatter !== void 0 && (n.globals.ttZFormatter = n.config.tooltip.z.formatter), n.config.legend.formatter !== void 0 && (n.globals.legendFormatter = n.config.legend.formatter), n.config.yaxis.forEach(function(i, o) {
        i.labels.formatter !== void 0 ? n.globals.yLabelFormatters[o] = i.labels.formatter : n.globals.yLabelFormatters[o] = function(d) {
          return n.globals.xyCharts ? Array.isArray(d) ? d.map(function(f) {
            return t.defaultYFormatter(f, i, o);
          }) : t.defaultYFormatter(d, i, o) : d;
        };
      }), n.globals;
    } }, { key: "heatmapLabelFormatters", value: function() {
      var t = this.w;
      if (t.config.chart.type === "heatmap") {
        t.globals.yAxisScale[0].result = t.globals.seriesNames.slice();
        var n = t.globals.seriesNames.reduce(function(i, o) {
          return i.length > o.length ? i : o;
        }, 0);
        t.globals.yAxisScale[0].niceMax = n, t.globals.yAxisScale[0].niceMin = n;
      }
    } }]), B;
  }(), Mt = function(B) {
    var t, n = B.isTimeline, i = B.ctx, o = B.seriesIndex, d = B.dataPointIndex, f = B.y1, p = B.y2, y = B.w, S = y.globals.seriesRangeStart[o][d], C = y.globals.seriesRangeEnd[o][d], E = y.globals.labels[d], L = y.config.series[o].name ? y.config.series[o].name : "", O = y.globals.ttKeyFormatter, P = y.config.tooltip.y.title.formatter, I = { w: y, seriesIndex: o, dataPointIndex: d, start: S, end: C };
    typeof P == "function" && (L = P(L, I)), (t = y.config.series[o].data[d]) !== null && t !== void 0 && t.x && (E = y.config.series[o].data[d].x), n || y.config.xaxis.type === "datetime" && (E = new Ht(i).xLabelFormat(y.globals.ttKeyFormatter, E, E, { i: void 0, dateFormatter: new it(i).formatDate, w: y })), typeof O == "function" && (E = O(E, I)), Number.isFinite(f) && Number.isFinite(p) && (S = f, C = p);
    var j = "", V = "", Z = y.globals.colors[o];
    if (y.config.tooltip.x.formatter === void 0)
      if (y.config.xaxis.type === "datetime") {
        var b = new it(i);
        j = b.formatDate(b.getDate(S), y.config.tooltip.x.format), V = b.formatDate(b.getDate(C), y.config.tooltip.x.format);
      } else
        j = S, V = C;
    else
      j = y.config.tooltip.x.formatter(S), V = y.config.tooltip.x.formatter(C);
    return { start: S, end: C, startVal: j, endVal: V, ylabel: E, color: Z, seriesName: L };
  }, an = function(B) {
    var t = B.color, n = B.seriesName, i = B.ylabel, o = B.start, d = B.end, f = B.seriesIndex, p = B.dataPointIndex, y = B.ctx.tooltip.tooltipLabels.getFormatters(f);
    o = y.yLbFormatter(o), d = y.yLbFormatter(d);
    var S = y.yLbFormatter(B.w.globals.series[f][p]), C = `<span class="value start-value">
  `.concat(o, `
  </span> <span class="separator">-</span> <span class="value end-value">
  `).concat(d, `
  </span>`);
    return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + t + '">' + (n || "") + '</span></div><div> <span class="category">' + i + ": </span> " + (B.w.globals.comboCharts ? B.w.config.series[f].type === "rangeArea" || B.w.config.series[f].type === "rangeBar" ? C : "<span>".concat(S, "</span>") : C) + " </div></div>";
  }, We = function() {
    function B(t) {
      A(this, B), this.opts = t;
    }
    return F(B, [{ key: "hideYAxis", value: function() {
      this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0;
    } }, { key: "line", value: function() {
      return { chart: { animations: { easing: "swing" } }, dataLabels: { enabled: !1 }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "sparkline", value: function(t) {
      return this.hideYAxis(), Q.extend(t, { grid: { show: !1, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: !1 }, xaxis: { labels: { show: !1 }, tooltip: { enabled: !1 }, axisBorder: { show: !1 }, axisTicks: { show: !1 } }, chart: { toolbar: { show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !1 } });
    } }, { key: "bar", value: function() {
      return { chart: { stacked: !1, animations: { easing: "swing" } }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] }, background: { enabled: !1 } }, stroke: { width: 0, lineCap: "round" }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square", radius: 2, size: 8 } }, tooltip: { shared: !1, intersect: !0 }, xaxis: { tooltip: { enabled: !1 }, tickPlacement: "between", crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: !1 }, stroke: { width: 0 } } } };
    } }, { key: "funnel", value: function() {
      return this.hideYAxis(), v(v({}, this.bar()), {}, { chart: { animations: { easing: "linear", speed: 800, animateGradually: { enabled: !1 } } }, plotOptions: { bar: { horizontal: !0, borderRadiusApplication: "around", borderRadius: 0, dataLabels: { position: "center" } } }, grid: { show: !1, padding: { left: 0, right: 0 } }, xaxis: { labels: { show: !1 }, tooltip: { enabled: !1 }, axisBorder: { show: !1 }, axisTicks: { show: !1 } } });
    } }, { key: "candlestick", value: function() {
      var t = this;
      return { stroke: { width: 1, colors: ["#333"] }, fill: { opacity: 1 }, dataLabels: { enabled: !1 }, tooltip: { shared: !0, custom: function(n) {
        var i = n.seriesIndex, o = n.dataPointIndex, d = n.w;
        return t._getBoxTooltip(d, i, o, ["Open", "High", "", "Low", "Close"], "candlestick");
      } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "boxPlot", value: function() {
      var t = this;
      return { chart: { animations: { dynamicAnimation: { enabled: !1 } } }, stroke: { width: 1, colors: ["#24292e"] }, dataLabels: { enabled: !1 }, tooltip: { shared: !0, custom: function(n) {
        var i = n.seriesIndex, o = n.dataPointIndex, d = n.w;
        return t._getBoxTooltip(d, i, o, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
      } }, markers: { size: 5, strokeWidth: 1, strokeColors: "#111" }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "rangeBar", value: function() {
      return { chart: { animations: { animateGradually: !1 } }, stroke: { width: 0, lineCap: "square" }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } }, dataLabels: { enabled: !1, formatter: function(t, n) {
        n.ctx;
        var i = n.seriesIndex, o = n.dataPointIndex, d = n.w, f = function() {
          var p = d.globals.seriesRangeStart[i][o];
          return d.globals.seriesRangeEnd[i][o] - p;
        };
        return d.globals.comboCharts ? d.config.series[i].type === "rangeBar" || d.config.series[i].type === "rangeArea" ? f() : t : f();
      }, background: { enabled: !1 }, style: { colors: ["#fff"] } }, markers: { size: 10 }, tooltip: { shared: !1, followCursor: !0, custom: function(t) {
        return t.w.config.plotOptions && t.w.config.plotOptions.bar && t.w.config.plotOptions.bar.horizontal ? function(n) {
          var i = Mt(v(v({}, n), {}, { isTimeline: !0 })), o = i.color, d = i.seriesName, f = i.ylabel, p = i.startVal, y = i.endVal;
          return an(v(v({}, n), {}, { color: o, seriesName: d, ylabel: f, start: p, end: y }));
        }(t) : function(n) {
          var i = Mt(n), o = i.color, d = i.seriesName, f = i.ylabel, p = i.start, y = i.end;
          return an(v(v({}, n), {}, { color: o, seriesName: d, ylabel: f, start: p, end: y }));
        }(t);
      } }, xaxis: { tickPlacement: "between", tooltip: { enabled: !1 }, crosshairs: { stroke: { width: 0 } } } };
    } }, { key: "dumbbell", value: function(t) {
      var n, i;
      return (n = t.plotOptions.bar) !== null && n !== void 0 && n.barHeight || (t.plotOptions.bar.barHeight = 2), (i = t.plotOptions.bar) !== null && i !== void 0 && i.columnWidth || (t.plotOptions.bar.columnWidth = 2), t;
    } }, { key: "area", value: function() {
      return { stroke: { width: 4, fill: { type: "solid", gradient: { inverseColors: !1, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } } }, fill: { type: "gradient", gradient: { inverseColors: !1, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: !1 } };
    } }, { key: "rangeArea", value: function() {
      return { stroke: { curve: "straight", width: 0 }, fill: { type: "solid", opacity: 0.6 }, markers: { size: 0 }, states: { hover: { filter: { type: "none" } }, active: { filter: { type: "none" } } }, tooltip: { intersect: !1, shared: !0, followCursor: !0, custom: function(t) {
        return function(n) {
          var i = Mt(n), o = i.color, d = i.seriesName, f = i.ylabel, p = i.start, y = i.end;
          return an(v(v({}, n), {}, { color: o, seriesName: d, ylabel: f, start: p, end: y }));
        }(t);
      } } };
    } }, { key: "brush", value: function(t) {
      return Q.extend(t, { chart: { toolbar: { autoSelected: "selection", show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !1 }, stroke: { width: 1 }, tooltip: { enabled: !1 }, xaxis: { tooltip: { enabled: !1 } } });
    } }, { key: "stacked100", value: function(t) {
      t.dataLabels = t.dataLabels || {}, t.dataLabels.formatter = t.dataLabels.formatter || void 0;
      var n = t.dataLabels.formatter;
      return t.yaxis.forEach(function(i, o) {
        t.yaxis[o].min = 0, t.yaxis[o].max = 100;
      }), t.chart.type === "bar" && (t.dataLabels.formatter = n || function(i) {
        return typeof i == "number" && i ? i.toFixed(0) + "%" : i;
      }), t;
    } }, { key: "stackedBars", value: function() {
      var t = this.bar();
      return v(v({}, t), {}, { plotOptions: v(v({}, t.plotOptions), {}, { bar: v(v({}, t.plotOptions.bar), {}, { borderRadiusApplication: "end", borderRadiusWhenStacked: "last" }) }) });
    } }, { key: "convertCatToNumeric", value: function(t) {
      return t.xaxis.convertedCatToNumeric = !0, t;
    } }, { key: "convertCatToNumericXaxis", value: function(t, n, i) {
      t.xaxis.type = "numeric", t.xaxis.labels = t.xaxis.labels || {}, t.xaxis.labels.formatter = t.xaxis.labels.formatter || function(f) {
        return Q.isNumber(f) ? Math.floor(f) : f;
      };
      var o = t.xaxis.labels.formatter, d = t.xaxis.categories && t.xaxis.categories.length ? t.xaxis.categories : t.labels;
      return i && i.length && (d = i.map(function(f) {
        return Array.isArray(f) ? f : String(f);
      })), d && d.length && (t.xaxis.labels.formatter = function(f) {
        return Q.isNumber(f) ? o(d[Math.floor(f) - 1]) : o(f);
      }), t.xaxis.categories = [], t.labels = [], t.xaxis.tickAmount = t.xaxis.tickAmount || "dataPoints", t;
    } }, { key: "bubble", value: function() {
      return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: !1, intersect: !0 }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: !0, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
    } }, { key: "scatter", value: function() {
      return { dataLabels: { enabled: !1 }, tooltip: { shared: !1, intersect: !0 }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
    } }, { key: "heatmap", value: function() {
      return { chart: { stacked: !1 }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: !0, marker: { show: !1 }, x: { show: !1 } }, legend: { position: "top", markers: { shape: "square", size: 10, offsetY: 2 } }, grid: { padding: { right: 20 } } };
    } }, { key: "treemap", value: function() {
      return { chart: { zoom: { enabled: !1 } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } }, stroke: { show: !0, width: 2, colors: ["#fff"] }, legend: { show: !1 }, fill: { gradient: { stops: [0, 100] } }, tooltip: { followCursor: !0, x: { show: !1 } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: !1 }, tooltip: { enabled: !1 } } };
    } }, { key: "pie", value: function() {
      return { chart: { toolbar: { show: !1 } }, plotOptions: { pie: { donut: { labels: { show: !1 } } } }, dataLabels: { formatter: function(t) {
        return t.toFixed(1) + "%";
      }, style: { colors: ["#fff"] }, background: { enabled: !1 }, dropShadow: { enabled: !0 } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" } };
    } }, { key: "donut", value: function() {
      return { chart: { toolbar: { show: !1 } }, dataLabels: { formatter: function(t) {
        return t.toFixed(1) + "%";
      }, style: { colors: ["#fff"] }, background: { enabled: !1 }, dropShadow: { enabled: !0 } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" } };
    } }, { key: "polarArea", value: function() {
      return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6, { chart: { toolbar: { show: !1 } }, dataLabels: { formatter: function(t) {
        return t.toFixed(1) + "%";
      }, enabled: !1 }, stroke: { show: !0, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" } };
    } }, { key: "radar", value: function() {
      return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: !1, style: { fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 3, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: !1, intersect: !0, followCursor: !0 }, grid: { show: !1 }, xaxis: { labels: { formatter: function(t) {
        return t;
      }, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, tooltip: { enabled: !1 }, crosshairs: { show: !1 } } };
    } }, { key: "radialBar", value: function() {
      return { chart: { animations: { dynamicAnimation: { enabled: !0, speed: 800 } }, toolbar: { show: !1 } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: !1, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: !1, position: "right" }, tooltip: { enabled: !1, fillSeriesColor: !0 } };
    } }, { key: "_getBoxTooltip", value: function(t, n, i, o, d) {
      var f = t.globals.seriesCandleO[n][i], p = t.globals.seriesCandleH[n][i], y = t.globals.seriesCandleM[n][i], S = t.globals.seriesCandleL[n][i], C = t.globals.seriesCandleC[n][i];
      return t.config.series[n].type && t.config.series[n].type !== d ? `<div class="apexcharts-custom-tooltip">
          `.concat(t.config.series[n].name ? t.config.series[n].name : "series-" + (n + 1), ": <strong>").concat(t.globals.series[n][i], `</strong>
        </div>`) : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t.config.chart.type, '">') + "<div>".concat(o[0], ': <span class="value">') + f + "</span></div>" + "<div>".concat(o[1], ': <span class="value">') + p + "</span></div>" + (y ? "<div>".concat(o[2], ': <span class="value">') + y + "</span></div>" : "") + "<div>".concat(o[3], ': <span class="value">') + S + "</span></div>" + "<div>".concat(o[4], ': <span class="value">') + C + "</span></div></div>";
    } }]), B;
  }(), pt = function() {
    function B(t) {
      A(this, B), this.opts = t;
    }
    return F(B, [{ key: "init", value: function(t) {
      var n = t.responsiveOverride, i = this.opts, o = new wt(), d = new We(i);
      this.chartType = i.chart.type, i = this.extendYAxis(i), i = this.extendAnnotations(i);
      var f = o.init(), p = {};
      if (i && w(i) === "object") {
        var y, S, C, E, L, O, P, I, j = {};
        j = ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(i.chart.type) !== -1 ? d[i.chart.type]() : d.line(), (y = i.plotOptions) !== null && y !== void 0 && (S = y.bar) !== null && S !== void 0 && S.isFunnel && (j = d.funnel()), i.chart.stacked && i.chart.type === "bar" && (j = d.stackedBars()), (C = i.chart.brush) !== null && C !== void 0 && C.enabled && (j = d.brush(j)), i.chart.stacked && i.chart.stackType === "100%" && (i = d.stacked100(i)), (E = i.plotOptions) !== null && E !== void 0 && (L = E.bar) !== null && L !== void 0 && L.isDumbbell && (i = d.dumbbell(i)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(i), i.xaxis = i.xaxis || window.Apex.xaxis || {}, n || (i.xaxis.convertedCatToNumeric = !1), ((O = (i = this.checkForCatToNumericXAxis(this.chartType, j, i)).chart.sparkline) !== null && O !== void 0 && O.enabled || (P = window.Apex.chart) !== null && P !== void 0 && (I = P.sparkline) !== null && I !== void 0 && I.enabled) && (j = d.sparkline(j)), p = Q.extend(f, j);
      }
      var V = Q.extend(p, window.Apex);
      return f = Q.extend(V, i), f = this.handleUserInputErrors(f);
    } }, { key: "checkForCatToNumericXAxis", value: function(t, n, i) {
      var o, d, f = new We(i), p = (t === "bar" || t === "boxPlot") && ((o = i.plotOptions) === null || o === void 0 || (d = o.bar) === null || d === void 0 ? void 0 : d.horizontal), y = t === "pie" || t === "polarArea" || t === "donut" || t === "radar" || t === "radialBar" || t === "heatmap", S = i.xaxis.type !== "datetime" && i.xaxis.type !== "numeric", C = i.xaxis.tickPlacement ? i.xaxis.tickPlacement : n.xaxis && n.xaxis.tickPlacement;
      return p || y || !S || C === "between" || (i = f.convertCatToNumeric(i)), i;
    } }, { key: "extendYAxis", value: function(t, n) {
      var i = new wt();
      (t.yaxis === void 0 || !t.yaxis || Array.isArray(t.yaxis) && t.yaxis.length === 0) && (t.yaxis = {}), t.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t.yaxis = Q.extend(t.yaxis, window.Apex.yaxis)), t.yaxis.constructor !== Array ? t.yaxis = [Q.extend(i.yAxis, t.yaxis)] : t.yaxis = Q.extendArray(t.yaxis, i.yAxis);
      var o = !1;
      t.yaxis.forEach(function(f) {
        f.logarithmic && (o = !0);
      });
      var d = t.series;
      return n && !d && (d = n.config.series), o && d.length !== t.yaxis.length && d.length && (t.yaxis = d.map(function(f, p) {
        if (f.name || (d[p].name = "series-".concat(p + 1)), t.yaxis[p])
          return t.yaxis[p].seriesName = d[p].name, t.yaxis[p];
        var y = Q.extend(i.yAxis, t.yaxis[0]);
        return y.show = !1, y;
      })), o && d.length > 1 && d.length !== t.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes. Please make sure to equalize both."), t;
    } }, { key: "extendAnnotations", value: function(t) {
      return t.annotations === void 0 && (t.annotations = {}, t.annotations.yaxis = [], t.annotations.xaxis = [], t.annotations.points = []), t = this.extendYAxisAnnotations(t), t = this.extendXAxisAnnotations(t), t = this.extendPointAnnotations(t);
    } }, { key: "extendYAxisAnnotations", value: function(t) {
      var n = new wt();
      return t.annotations.yaxis = Q.extendArray(t.annotations.yaxis !== void 0 ? t.annotations.yaxis : [], n.yAxisAnnotation), t;
    } }, { key: "extendXAxisAnnotations", value: function(t) {
      var n = new wt();
      return t.annotations.xaxis = Q.extendArray(t.annotations.xaxis !== void 0 ? t.annotations.xaxis : [], n.xAxisAnnotation), t;
    } }, { key: "extendPointAnnotations", value: function(t) {
      var n = new wt();
      return t.annotations.points = Q.extendArray(t.annotations.points !== void 0 ? t.annotations.points : [], n.pointAnnotation), t;
    } }, { key: "checkForDarkTheme", value: function(t) {
      t.theme && t.theme.mode === "dark" && (t.tooltip || (t.tooltip = {}), t.tooltip.theme !== "light" && (t.tooltip.theme = "dark"), t.chart.foreColor || (t.chart.foreColor = "#f6f7f8"), t.chart.background || (t.chart.background = "#424242"), t.theme.palette || (t.theme.palette = "palette4"));
    } }, { key: "handleUserInputErrors", value: function(t) {
      var n = t;
      if (n.tooltip.shared && n.tooltip.intersect)
        throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
      if (n.chart.type === "bar" && n.plotOptions.bar.horizontal) {
        if (n.yaxis.length > 1)
          throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
        n.yaxis[0].reversed && (n.yaxis[0].opposite = !0), n.xaxis.tooltip.enabled = !1, n.yaxis[0].tooltip.enabled = !1, n.chart.zoom.enabled = !1;
      }
      return n.chart.type !== "bar" && n.chart.type !== "rangeBar" || n.tooltip.shared && n.xaxis.crosshairs.width === "barWidth" && n.series.length > 1 && (n.xaxis.crosshairs.width = "tickWidth"), n.chart.type !== "candlestick" && n.chart.type !== "boxPlot" || n.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(n.chart.type, " chart is not supported.")), n.yaxis[0].reversed = !1), n;
    } }]), B;
  }(), ye = function() {
    function B() {
      A(this, B);
    }
    return F(B, [{ key: "initGlobalVars", value: function(t) {
      t.series = [], t.seriesCandleO = [], t.seriesCandleH = [], t.seriesCandleM = [], t.seriesCandleL = [], t.seriesCandleC = [], t.seriesRangeStart = [], t.seriesRangeEnd = [], t.seriesRange = [], t.seriesPercent = [], t.seriesGoals = [], t.seriesX = [], t.seriesZ = [], t.seriesNames = [], t.seriesTotals = [], t.seriesLog = [], t.seriesColors = [], t.stackedSeriesTotals = [], t.seriesXvalues = [], t.seriesYvalues = [], t.labels = [], t.hasXaxisGroups = !1, t.groups = [], t.hasSeriesGroups = !1, t.seriesGroups = [], t.categoryLabels = [], t.timescaleLabels = [], t.noLabelsProvided = !1, t.resizeTimer = null, t.selectionResizeTimer = null, t.delayedElements = [], t.pointsArray = [], t.dataLabelsRects = [], t.isXNumeric = !1, t.skipLastTimelinelabel = !1, t.skipFirstTimelinelabel = !1, t.isDataXYZ = !1, t.isMultiLineX = !1, t.isMultipleYAxis = !1, t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE, t.minYArr = [], t.maxYArr = [], t.maxX = -Number.MAX_VALUE, t.minX = Number.MAX_VALUE, t.initialMaxX = -Number.MAX_VALUE, t.initialMinX = Number.MAX_VALUE, t.maxDate = 0, t.minDate = Number.MAX_VALUE, t.minZ = Number.MAX_VALUE, t.maxZ = -Number.MAX_VALUE, t.minXDiff = Number.MAX_VALUE, t.yAxisScale = [], t.xAxisScale = null, t.xAxisTicksPositions = [], t.yLabelsCoords = [], t.yTitleCoords = [], t.barPadForNumericAxis = 0, t.padHorizontal = 0, t.xRange = 0, t.yRange = [], t.zRange = 0, t.dataPoints = 0, t.xTickAmount = 0;
    } }, { key: "globalVars", value: function(t) {
      return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: t.markers.size, largestSize: 0 }, animationEnded: !1, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: !1, isExecCalled: !1, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: !1, allSeriesCollapsed: !1, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: !1, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], goldenPadding: 35, invalidLogScale: !1, ignoreYAxisIndexes: [], yAxisSameScaleIndices: [], maxValsInArrayIndex: 0, radialSize: 0, selection: void 0, zoomEnabled: t.chart.toolbar.autoSelected === "zoom" && t.chart.toolbar.tools.zoom && t.chart.zoom.enabled, panEnabled: t.chart.toolbar.autoSelected === "pan" && t.chart.toolbar.tools.pan, selectionEnabled: t.chart.toolbar.autoSelected === "selection" && t.chart.toolbar.tools.selection, yaxis: null, mousedown: !1, lastClientPosition: {}, visibleXRange: void 0, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: !1, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: !0, skipLastTimelinelabel: !1, skipFirstTimelinelabel: !1, delayedElements: [], axisCharts: !0, isDataXYZ: !1, resized: !1, resizeTimer: null, comboCharts: !1, dataChanged: !1, previousPaths: [], allSeriesHasEqualX: !0, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: !1, easing: null, zoomed: !1, gridWidth: 0, gridHeight: 0, rotateXLabels: !1, defaultLabels: !1, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null };
    } }, { key: "init", value: function(t) {
      var n = this.globalVars(t);
      return this.initGlobalVars(n), n.initialConfig = Q.extend({}, t), n.initialSeries = Q.clone(t.series), n.lastXAxis = Q.clone(n.initialConfig.xaxis), n.lastYAxis = Q.clone(n.initialConfig.yaxis), n;
    } }]), B;
  }(), je = function() {
    function B(t) {
      A(this, B), this.opts = t;
    }
    return F(B, [{ key: "init", value: function() {
      var t = new pt(this.opts).init({ responsiveOverride: !1 });
      return { config: t, globals: new ye().init(t) };
    } }]), B;
  }(), Je = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w, this.opts = null, this.seriesIndex = 0;
    }
    return F(B, [{ key: "clippedImgArea", value: function(t) {
      var n = this.w, i = n.config, o = parseInt(n.globals.gridWidth, 10), d = parseInt(n.globals.gridHeight, 10), f = o > d ? o : d, p = t.image, y = 0, S = 0;
      t.width === void 0 && t.height === void 0 ? i.fill.image.width !== void 0 && i.fill.image.height !== void 0 ? (y = i.fill.image.width + 1, S = i.fill.image.height) : (y = f + 1, S = f) : (y = t.width, S = t.height);
      var C = document.createElementNS(n.globals.SVGNS, "pattern");
      re.setAttrs(C, { id: t.patternID, patternUnits: t.patternUnits ? t.patternUnits : "userSpaceOnUse", width: y + "px", height: S + "px" });
      var E = document.createElementNS(n.globals.SVGNS, "image");
      C.appendChild(E), E.setAttributeNS(window.SVG.xlink, "href", p), re.setAttrs(E, { x: 0, y: 0, preserveAspectRatio: "none", width: y + "px", height: S + "px" }), E.style.opacity = t.opacity, n.globals.dom.elDefs.node.appendChild(C);
    } }, { key: "getSeriesIndex", value: function(t) {
      var n = this.w, i = n.config.chart.type;
      return (i === "bar" || i === "rangeBar") && n.config.plotOptions.bar.distributed || i === "heatmap" || i === "treemap" ? this.seriesIndex = t.seriesNumber : this.seriesIndex = t.seriesNumber % n.globals.series.length, this.seriesIndex;
    } }, { key: "fillPath", value: function(t) {
      var n = this.w;
      this.opts = t;
      var i, o, d, f = this.w.config;
      this.seriesIndex = this.getSeriesIndex(t);
      var p = this.getFillColors()[this.seriesIndex];
      n.globals.seriesColors[this.seriesIndex] !== void 0 && (p = n.globals.seriesColors[this.seriesIndex]), typeof p == "function" && (p = p({ seriesIndex: this.seriesIndex, dataPointIndex: t.dataPointIndex, value: t.value, w: n }));
      var y = t.fillType ? t.fillType : this.getFillType(this.seriesIndex), S = Array.isArray(f.fill.opacity) ? f.fill.opacity[this.seriesIndex] : f.fill.opacity;
      t.color && (p = t.color);
      var C = p;
      if (p.indexOf("rgb") === -1 ? p.length < 9 && (C = Q.hexToRgba(p, S)) : p.indexOf("rgba") > -1 && (S = Q.getOpacityFromRGBA(p)), t.opacity && (S = t.opacity), y === "pattern" && (o = this.handlePatternFill({ fillConfig: t.fillConfig, patternFill: o, fillColor: p, fillOpacity: S, defaultColor: C })), y === "gradient" && (d = this.handleGradientFill({ fillConfig: t.fillConfig, fillColor: p, fillOpacity: S, i: this.seriesIndex })), y === "image") {
        var E = f.fill.image.src, L = t.patternID ? t.patternID : "";
        this.clippedImgArea({ opacity: S, image: Array.isArray(E) ? t.seriesNumber < E.length ? E[t.seriesNumber] : E[0] : E, width: t.width ? t.width : void 0, height: t.height ? t.height : void 0, patternUnits: t.patternUnits, patternID: "pattern".concat(n.globals.cuid).concat(t.seriesNumber + 1).concat(L) }), i = "url(#pattern".concat(n.globals.cuid).concat(t.seriesNumber + 1).concat(L, ")");
      } else
        i = y === "gradient" ? d : y === "pattern" ? o : C;
      return t.solid && (i = C), i;
    } }, { key: "getFillType", value: function(t) {
      var n = this.w;
      return Array.isArray(n.config.fill.type) ? n.config.fill.type[t] : n.config.fill.type;
    } }, { key: "getFillColors", value: function() {
      var t = this.w, n = t.config, i = this.opts, o = [];
      return t.globals.comboCharts ? t.config.series[this.seriesIndex].type === "line" ? Array.isArray(t.globals.stroke.colors) ? o = t.globals.stroke.colors : o.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? o = t.globals.fill.colors : o.push(t.globals.fill.colors) : n.chart.type === "line" ? Array.isArray(t.globals.stroke.colors) ? o = t.globals.stroke.colors : o.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? o = t.globals.fill.colors : o.push(t.globals.fill.colors), i.fillColors !== void 0 && (o = [], Array.isArray(i.fillColors) ? o = i.fillColors.slice() : o.push(i.fillColors)), o;
    } }, { key: "handlePatternFill", value: function(t) {
      var n = t.fillConfig, i = t.patternFill, o = t.fillColor, d = t.fillOpacity, f = t.defaultColor, p = this.w.config.fill;
      n && (p = n);
      var y = this.opts, S = new re(this.ctx), C = Array.isArray(p.pattern.strokeWidth) ? p.pattern.strokeWidth[this.seriesIndex] : p.pattern.strokeWidth, E = o;
      return Array.isArray(p.pattern.style) ? i = p.pattern.style[y.seriesNumber] !== void 0 ? S.drawPattern(p.pattern.style[y.seriesNumber], p.pattern.width, p.pattern.height, E, C, d) : f : i = S.drawPattern(p.pattern.style, p.pattern.width, p.pattern.height, E, C, d), i;
    } }, { key: "handleGradientFill", value: function(t) {
      var n = t.fillColor, i = t.fillOpacity, o = t.fillConfig, d = t.i, f = this.w.config.fill;
      o && (f = v(v({}, f), o));
      var p, y = this.opts, S = new re(this.ctx), C = new Q(), E = f.gradient.type, L = n, O = f.gradient.opacityFrom === void 0 ? i : Array.isArray(f.gradient.opacityFrom) ? f.gradient.opacityFrom[d] : f.gradient.opacityFrom;
      L.indexOf("rgba") > -1 && (O = Q.getOpacityFromRGBA(L));
      var P = f.gradient.opacityTo === void 0 ? i : Array.isArray(f.gradient.opacityTo) ? f.gradient.opacityTo[d] : f.gradient.opacityTo;
      if (f.gradient.gradientToColors === void 0 || f.gradient.gradientToColors.length === 0)
        p = f.gradient.shade === "dark" ? C.shadeColor(-1 * parseFloat(f.gradient.shadeIntensity), n.indexOf("rgb") > -1 ? Q.rgb2hex(n) : n) : C.shadeColor(parseFloat(f.gradient.shadeIntensity), n.indexOf("rgb") > -1 ? Q.rgb2hex(n) : n);
      else if (f.gradient.gradientToColors[y.seriesNumber]) {
        var I = f.gradient.gradientToColors[y.seriesNumber];
        p = I, I.indexOf("rgba") > -1 && (P = Q.getOpacityFromRGBA(I));
      } else
        p = n;
      if (f.gradient.gradientFrom && (L = f.gradient.gradientFrom), f.gradient.gradientTo && (p = f.gradient.gradientTo), f.gradient.inverseColors) {
        var j = L;
        L = p, p = j;
      }
      return L.indexOf("rgb") > -1 && (L = Q.rgb2hex(L)), p.indexOf("rgb") > -1 && (p = Q.rgb2hex(p)), S.drawGradient(E, L, p, O, P, y.size, f.gradient.stops, f.gradient.colorStops, d);
    } }]), B;
  }(), kt = function() {
    function B(t, n) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "setGlobalMarkerSize", value: function() {
      var t = this.w;
      if (t.globals.markers.size = Array.isArray(t.config.markers.size) ? t.config.markers.size : [t.config.markers.size], t.globals.markers.size.length > 0) {
        if (t.globals.markers.size.length < t.globals.series.length + 1)
          for (var n = 0; n <= t.globals.series.length; n++)
            t.globals.markers.size[n] === void 0 && t.globals.markers.size.push(t.globals.markers.size[0]);
      } else
        t.globals.markers.size = t.config.series.map(function(i) {
          return t.config.markers.size;
        });
    } }, { key: "plotChartMarkers", value: function(t, n, i, o) {
      var d, f = arguments.length > 4 && arguments[4] !== void 0 && arguments[4], p = this.w, y = n, S = t, C = null, E = new re(this.ctx), L = p.config.markers.discrete && p.config.markers.discrete.length;
      if ((p.globals.markers.size[n] > 0 || f || L) && (C = E.group({ class: f || L ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(p.globals.cuid, ")")), Array.isArray(S.x))
        for (var O = 0; O < S.x.length; O++) {
          var P = i;
          i === 1 && O === 0 && (P = 0), i === 1 && O === 1 && (P = 1);
          var I = "apexcharts-marker";
          if (p.config.chart.type !== "line" && p.config.chart.type !== "area" || p.globals.comboCharts || p.config.tooltip.intersect || (I += " no-pointer-events"), (Array.isArray(p.config.markers.size) ? p.globals.markers.size[n] > 0 : p.config.markers.size > 0) || f || L) {
            Q.isNumber(S.y[O]) ? I += " w".concat(Q.randomId()) : I = "apexcharts-nullpoint";
            var j = this.getMarkerConfig({ cssClass: I, seriesIndex: n, dataPointIndex: P });
            p.config.series[y].data[P] && (p.config.series[y].data[P].fillColor && (j.pointFillColor = p.config.series[y].data[P].fillColor), p.config.series[y].data[P].strokeColor && (j.pointStrokeColor = p.config.series[y].data[P].strokeColor)), o && (j.pSize = o), (S.x[O] < 0 || S.x[O] > p.globals.gridWidth || S.y[O] < 0 || S.y[O] > p.globals.gridHeight) && (j.pSize = 0), (d = E.drawMarker(S.x[O], S.y[O], j)).attr("rel", P), d.attr("j", P), d.attr("index", n), d.node.setAttribute("default-marker-size", j.pSize), new Ee(this.ctx).setSelectionFilter(d, n, P), this.addEvents(d), C && C.add(d);
          } else
            p.globals.pointsArray[n] === void 0 && (p.globals.pointsArray[n] = []), p.globals.pointsArray[n].push([S.x[O], S.y[O]]);
        }
      return C;
    } }, { key: "getMarkerConfig", value: function(t) {
      var n = t.cssClass, i = t.seriesIndex, o = t.dataPointIndex, d = o === void 0 ? null : o, f = t.finishRadius, p = f === void 0 ? null : f, y = this.w, S = this.getMarkerStyle(i), C = y.globals.markers.size[i], E = y.config.markers;
      return d !== null && E.discrete.length && E.discrete.map(function(L) {
        L.seriesIndex === i && L.dataPointIndex === d && (S.pointStrokeColor = L.strokeColor, S.pointFillColor = L.fillColor, C = L.size, S.pointShape = L.shape);
      }), { pSize: p === null ? C : p, pRadius: E.radius, width: Array.isArray(E.width) ? E.width[i] : E.width, height: Array.isArray(E.height) ? E.height[i] : E.height, pointStrokeWidth: Array.isArray(E.strokeWidth) ? E.strokeWidth[i] : E.strokeWidth, pointStrokeColor: S.pointStrokeColor, pointFillColor: S.pointFillColor, shape: S.pointShape || (Array.isArray(E.shape) ? E.shape[i] : E.shape), class: n, pointStrokeOpacity: Array.isArray(E.strokeOpacity) ? E.strokeOpacity[i] : E.strokeOpacity, pointStrokeDashArray: Array.isArray(E.strokeDashArray) ? E.strokeDashArray[i] : E.strokeDashArray, pointFillOpacity: Array.isArray(E.fillOpacity) ? E.fillOpacity[i] : E.fillOpacity, seriesIndex: i };
    } }, { key: "addEvents", value: function(t) {
      var n = this.w, i = new re(this.ctx);
      t.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, t)), t.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, t)), t.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, t)), t.node.addEventListener("click", n.config.markers.onClick), t.node.addEventListener("dblclick", n.config.markers.onDblClick), t.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, t), { passive: !0 });
    } }, { key: "getMarkerStyle", value: function(t) {
      var n = this.w, i = n.globals.markers.colors, o = n.config.markers.strokeColor || n.config.markers.strokeColors;
      return { pointStrokeColor: Array.isArray(o) ? o[t] : o, pointFillColor: Array.isArray(i) ? i[t] : i };
    } }]), B;
  }(), At = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
    }
    return F(B, [{ key: "draw", value: function(t, n, i) {
      var o = this.w, d = new re(this.ctx), f = i.realIndex, p = i.pointsPos, y = i.zRatio, S = i.elParent, C = d.group({ class: "apexcharts-series-markers apexcharts-series-".concat(o.config.chart.type) });
      if (C.attr("clip-path", "url(#gridRectMarkerMask".concat(o.globals.cuid, ")")), Array.isArray(p.x))
        for (var E = 0; E < p.x.length; E++) {
          var L = n + 1, O = !0;
          n === 0 && E === 0 && (L = 0), n === 0 && E === 1 && (L = 1);
          var P = 0, I = o.globals.markers.size[f];
          if (y !== 1 / 0) {
            var j = o.config.plotOptions.bubble;
            I = o.globals.seriesZ[f][L], j.zScaling && (I /= y), j.minBubbleRadius && I < j.minBubbleRadius && (I = j.minBubbleRadius), j.maxBubbleRadius && I > j.maxBubbleRadius && (I = j.maxBubbleRadius);
          }
          o.config.chart.animations.enabled || (P = I);
          var V = p.x[E], Z = p.y[E];
          if (P = P || 0, Z !== null && o.globals.series[f][L] !== void 0 || (O = !1), O) {
            var b = this.drawPoint(V, Z, P, I, f, L, n);
            C.add(b);
          }
          S.add(C);
        }
    } }, { key: "drawPoint", value: function(t, n, i, o, d, f, p) {
      var y = this.w, S = d, C = new we(this.ctx), E = new Ee(this.ctx), L = new Je(this.ctx), O = new kt(this.ctx), P = new re(this.ctx), I = O.getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: S, dataPointIndex: f, finishRadius: y.config.chart.type === "bubble" || y.globals.comboCharts && y.config.series[d] && y.config.series[d].type === "bubble" ? o : null });
      o = I.pSize;
      var j, V = L.fillPath({ seriesNumber: d, dataPointIndex: f, color: I.pointFillColor, patternUnits: "objectBoundingBox", value: y.globals.series[d][p] });
      if (I.shape === "circle" ? j = P.drawCircle(i) : I.shape !== "square" && I.shape !== "rect" || (j = P.drawRect(0, 0, I.width - I.pointStrokeWidth / 2, I.height - I.pointStrokeWidth / 2, I.pRadius)), y.config.series[S].data[f] && y.config.series[S].data[f].fillColor && (V = y.config.series[S].data[f].fillColor), j.attr({ x: t - I.width / 2 - I.pointStrokeWidth / 2, y: n - I.height / 2 - I.pointStrokeWidth / 2, cx: t, cy: n, fill: V, "fill-opacity": I.pointFillOpacity, stroke: I.pointStrokeColor, r: o, "stroke-width": I.pointStrokeWidth, "stroke-dasharray": I.pointStrokeDashArray, "stroke-opacity": I.pointStrokeOpacity }), y.config.chart.dropShadow.enabled) {
        var Z = y.config.chart.dropShadow;
        E.dropShadow(j, Z, d);
      }
      if (!this.initialAnim || y.globals.dataChanged || y.globals.resized)
        y.globals.animationEnded = !0;
      else {
        var b = y.config.chart.animations.speed;
        C.animateMarker(j, 0, I.shape === "circle" ? o : { width: I.width, height: I.height }, b, y.globals.easing, function() {
          window.setTimeout(function() {
            C.animationCompleted(j);
          }, 100);
        });
      }
      if (y.globals.dataChanged && I.shape === "circle")
        if (this.dynamicAnim) {
          var M, N, X, K, ee = y.config.chart.animations.dynamicAnimation.speed;
          (K = y.globals.previousPaths[d] && y.globals.previousPaths[d][p]) != null && (M = K.x, N = K.y, X = K.r !== void 0 ? K.r : o);
          for (var oe = 0; oe < y.globals.collapsedSeries.length; oe++)
            y.globals.collapsedSeries[oe].index === d && (ee = 1, o = 0);
          t === 0 && n === 0 && (o = 0), C.animateCircle(j, { cx: M, cy: N, r: X }, { cx: t, cy: n, r: o }, ee, y.globals.easing);
        } else
          j.attr({ r: o });
      return j.attr({ rel: f, j: f, index: d, "default-marker-size": o }), E.setSelectionFilter(j, d, f), O.addEvents(j), j.node.classList.add("apexcharts-marker"), j;
    } }, { key: "centerTextInBubble", value: function(t) {
      var n = this.w;
      return { y: t += parseInt(n.config.dataLabels.style.fontSize, 10) / 4 };
    } }]), B;
  }(), jt = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "dataLabelsCorrection", value: function(t, n, i, o, d, f, p) {
      var y = this.w, S = !1, C = new re(this.ctx).getTextRects(i, p), E = C.width, L = C.height;
      n < 0 && (n = 0), n > y.globals.gridHeight + L && (n = y.globals.gridHeight + L / 2), y.globals.dataLabelsRects[o] === void 0 && (y.globals.dataLabelsRects[o] = []), y.globals.dataLabelsRects[o].push({ x: t, y: n, width: E, height: L });
      var O = y.globals.dataLabelsRects[o].length - 2, P = y.globals.lastDrawnDataLabelsIndexes[o] !== void 0 ? y.globals.lastDrawnDataLabelsIndexes[o][y.globals.lastDrawnDataLabelsIndexes[o].length - 1] : 0;
      if (y.globals.dataLabelsRects[o][O] !== void 0) {
        var I = y.globals.dataLabelsRects[o][P];
        (t > I.x + I.width + 2 || n > I.y + I.height + 2 || t + E < I.x) && (S = !0);
      }
      return (d === 0 || f) && (S = !0), { x: t, y: n, textRects: C, drawnextLabel: S };
    } }, { key: "drawDataLabel", value: function(t) {
      var n = this, i = t.type, o = t.pos, d = t.i, f = t.j, p = t.isRangeStart, y = t.strokeWidth, S = y === void 0 ? 2 : y, C = this.w, E = new re(this.ctx), L = C.config.dataLabels, O = 0, P = 0, I = f, j = null;
      if (!L.enabled || !Array.isArray(o.x))
        return j;
      j = E.group({ class: "apexcharts-data-labels" });
      for (var V = 0; V < o.x.length; V++)
        if (O = o.x[V] + L.offsetX, P = o.y[V] + L.offsetY + S, !isNaN(O)) {
          f === 1 && V === 0 && (I = 0), f === 1 && V === 1 && (I = 1);
          var Z = C.globals.series[d][I];
          i === "rangeArea" && (Z = p ? C.globals.seriesRangeStart[d][I] : C.globals.seriesRangeEnd[d][I]);
          var b = "", M = function(N) {
            return C.config.dataLabels.formatter(N, { ctx: n.ctx, seriesIndex: d, dataPointIndex: I, w: C });
          };
          C.config.chart.type === "bubble" ? (b = M(Z = C.globals.seriesZ[d][I]), P = o.y[V], P = new At(this.ctx).centerTextInBubble(P, d, I).y) : Z !== void 0 && (b = M(Z)), this.plotDataLabelsText({ x: O, y: P, text: b, i: d, j: I, parent: j, offsetCorrection: !0, dataLabelsConfig: C.config.dataLabels });
        }
      return j;
    } }, { key: "plotDataLabelsText", value: function(t) {
      var n = this.w, i = new re(this.ctx), o = t.x, d = t.y, f = t.i, p = t.j, y = t.text, S = t.textAnchor, C = t.fontSize, E = t.parent, L = t.dataLabelsConfig, O = t.color, P = t.alwaysDrawDataLabel, I = t.offsetCorrection;
      if (!(Array.isArray(n.config.dataLabels.enabledOnSeries) && n.config.dataLabels.enabledOnSeries.indexOf(f) < 0)) {
        var j = { x: o, y: d, drawnextLabel: !0, textRects: null };
        I && (j = this.dataLabelsCorrection(o, d, y, f, p, P, parseInt(L.style.fontSize, 10))), n.globals.zoomed || (o = j.x, d = j.y), j.textRects && (o < -10 - j.textRects.width || o > n.globals.gridWidth + j.textRects.width + 10) && (y = "");
        var V = n.globals.dataLabels.style.colors[f];
        ((n.config.chart.type === "bar" || n.config.chart.type === "rangeBar") && n.config.plotOptions.bar.distributed || n.config.dataLabels.distributed) && (V = n.globals.dataLabels.style.colors[p]), typeof V == "function" && (V = V({ series: n.globals.series, seriesIndex: f, dataPointIndex: p, w: n })), O && (V = O);
        var Z = L.offsetX, b = L.offsetY;
        if (n.config.chart.type !== "bar" && n.config.chart.type !== "rangeBar" || (Z = 0, b = 0), j.drawnextLabel) {
          var M = i.drawText({ width: 100, height: parseInt(L.style.fontSize, 10), x: o + Z, y: d + b, foreColor: V, textAnchor: S || L.textAnchor, text: y, fontSize: C || L.style.fontSize, fontFamily: L.style.fontFamily, fontWeight: L.style.fontWeight || "normal" });
          if (M.attr({ class: "apexcharts-datalabel", cx: o, cy: d }), L.dropShadow.enabled) {
            var N = L.dropShadow;
            new Ee(this.ctx).dropShadow(M, N);
          }
          E.add(M), n.globals.lastDrawnDataLabelsIndexes[f] === void 0 && (n.globals.lastDrawnDataLabelsIndexes[f] = []), n.globals.lastDrawnDataLabelsIndexes[f].push(p);
        }
      }
    } }, { key: "addBackgroundToDataLabel", value: function(t, n) {
      var i = this.w, o = i.config.dataLabels.background, d = o.padding, f = o.padding / 2, p = n.width, y = n.height, S = new re(this.ctx).drawRect(n.x - d, n.y - f / 2, p + 2 * d, y + f, o.borderRadius, i.config.chart.background === "transparent" ? "#fff" : i.config.chart.background, o.opacity, o.borderWidth, o.borderColor);
      return o.dropShadow.enabled && new Ee(this.ctx).dropShadow(S, o.dropShadow), S;
    } }, { key: "dataLabelsBackground", value: function() {
      var t = this.w;
      if (t.config.chart.type !== "bubble")
        for (var n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i = 0; i < n.length; i++) {
          var o = n[i], d = o.getBBox(), f = null;
          if (d.width && d.height && (f = this.addBackgroundToDataLabel(o, d)), f) {
            o.parentNode.insertBefore(f.node, o);
            var p = o.getAttribute("fill");
            t.config.chart.animations.enabled && !t.globals.resized && !t.globals.dataChanged ? f.animate().attr({ fill: p }) : f.attr({ fill: p }), o.setAttribute("fill", t.config.dataLabels.background.foreColor);
          }
        }
    } }, { key: "bringForward", value: function() {
      for (var t = this.w, n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i = t.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), o = 0; o < n.length; o++)
        i && i.insertBefore(n[o], i.nextSibling);
    } }]), B;
  }(), ot = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w, this.legendInactiveClass = "legend-mouseover-inactive";
    }
    return F(B, [{ key: "getAllSeriesEls", value: function() {
      return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
    } }, { key: "getSeriesByName", value: function(t) {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(Q.escapeString(t), "']"));
    } }, { key: "isSeriesHidden", value: function(t) {
      var n = this.getSeriesByName(t), i = parseInt(n.getAttribute("data:realIndex"), 10);
      return { isHidden: n.classList.contains("apexcharts-series-collapsed"), realIndex: i };
    } }, { key: "addCollapsedClassToSeries", value: function(t, n) {
      var i = this.w;
      function o(d) {
        for (var f = 0; f < d.length; f++)
          d[f].index === n && t.node.classList.add("apexcharts-series-collapsed");
      }
      o(i.globals.collapsedSeries), o(i.globals.ancillaryCollapsedSeries);
    } }, { key: "toggleSeries", value: function(t) {
      var n = this.isSeriesHidden(t);
      return this.ctx.legend.legendHelpers.toggleDataSeries(n.realIndex, n.isHidden), n.isHidden;
    } }, { key: "showSeries", value: function(t) {
      var n = this.isSeriesHidden(t);
      n.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(n.realIndex, !0);
    } }, { key: "hideSeries", value: function(t) {
      var n = this.isSeriesHidden(t);
      n.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(n.realIndex, !1);
    } }, { key: "resetSeries", value: function() {
      var t = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], o = this.w, d = Q.clone(o.globals.initialSeries);
      o.globals.previousPaths = [], i ? (o.globals.collapsedSeries = [], o.globals.ancillaryCollapsedSeries = [], o.globals.collapsedSeriesIndices = [], o.globals.ancillaryCollapsedSeriesIndices = []) : d = this.emptyCollapsedSeries(d), o.config.series = d, t && (n && (o.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(d, o.config.chart.animations.dynamicAnimation.enabled));
    } }, { key: "emptyCollapsedSeries", value: function(t) {
      for (var n = this.w, i = 0; i < t.length; i++)
        n.globals.collapsedSeriesIndices.indexOf(i) > -1 && (t[i].data = []);
      return t;
    } }, { key: "toggleSeriesOnHover", value: function(t, n) {
      var i = this.w;
      n || (n = t.target);
      var o = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
      if (t.type === "mousemove") {
        var d = parseInt(n.getAttribute("rel"), 10) - 1, f = null, p = null;
        i.globals.axisCharts || i.config.chart.type === "radialBar" ? i.globals.axisCharts ? (f = i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(d, "']")), p = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(d, "']"))) : f = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(d + 1, "']")) : f = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(d + 1, "'] path"));
        for (var y = 0; y < o.length; y++)
          o[y].classList.add(this.legendInactiveClass);
        f !== null && (i.globals.axisCharts || f.parentNode.classList.remove(this.legendInactiveClass), f.classList.remove(this.legendInactiveClass), p !== null && p.classList.remove(this.legendInactiveClass));
      } else if (t.type === "mouseout")
        for (var S = 0; S < o.length; S++)
          o[S].classList.remove(this.legendInactiveClass);
    } }, { key: "highlightRangeInSeries", value: function(t, n) {
      var i = this, o = this.w, d = o.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), f = function(y) {
        for (var S = 0; S < d.length; S++)
          d[S].classList[y](i.legendInactiveClass);
      };
      if (t.type === "mousemove") {
        var p = parseInt(n.getAttribute("rel"), 10) - 1;
        f("add"), function(y) {
          for (var S = 0; S < d.length; S++) {
            var C = parseInt(d[S].getAttribute("val"), 10);
            C >= y.from && C <= y.to && d[S].classList.remove(i.legendInactiveClass);
          }
        }(o.config.plotOptions.heatmap.colorScale.ranges[p]);
      } else
        t.type === "mouseout" && f("remove");
    } }, { key: "getActiveConfigSeriesIndex", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "asc", n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], i = this.w, o = 0;
      if (i.config.series.length > 1) {
        for (var d = i.config.series.map(function(p, y) {
          return p.data && p.data.length > 0 && i.globals.collapsedSeriesIndices.indexOf(y) === -1 && (!i.globals.comboCharts || n.length === 0 || n.length && n.indexOf(i.config.series[y].type) > -1) ? y : -1;
        }), f = t === "asc" ? 0 : d.length - 1; t === "asc" ? f < d.length : f >= 0; t === "asc" ? f++ : f--)
          if (d[f] !== -1) {
            o = d[f];
            break;
          }
      }
      return o;
    } }, { key: "getBarSeriesIndices", value: function() {
      return this.w.globals.comboCharts ? this.w.config.series.map(function(t, n) {
        return t.type === "bar" || t.type === "column" ? n : -1;
      }).filter(function(t) {
        return t !== -1;
      }) : this.w.config.series.map(function(t, n) {
        return n;
      });
    } }, { key: "getPreviousPaths", value: function() {
      var t = this.w;
      function n(f, p, y) {
        for (var S = f[p].childNodes, C = { type: y, paths: [], realIndex: f[p].getAttribute("data:realIndex") }, E = 0; E < S.length; E++)
          if (S[E].hasAttribute("pathTo")) {
            var L = S[E].getAttribute("pathTo");
            C.paths.push({ d: L });
          }
        t.globals.previousPaths.push(C);
      }
      t.globals.previousPaths = [], ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function(f) {
        for (var p, y = (p = f, t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(p, "-series .apexcharts-series"))), S = 0; S < y.length; S++)
          n(y, S, f);
      }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
      var i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type, " .apexcharts-series"));
      if (i.length > 0)
        for (var o = function(f) {
          for (var p = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(f, "'] rect")), y = [], S = function(E) {
            var L = function(P) {
              return p[E].getAttribute(P);
            }, O = { x: parseFloat(L("x")), y: parseFloat(L("y")), width: parseFloat(L("width")), height: parseFloat(L("height")) };
            y.push({ rect: O, color: p[E].getAttribute("color") });
          }, C = 0; C < p.length; C++)
            S(C);
          t.globals.previousPaths.push(y);
        }, d = 0; d < i.length; d++)
          o(d);
      t.globals.axisCharts || (t.globals.previousPaths = t.globals.series);
    } }, { key: "handlePrevBubbleScatterPaths", value: function(t) {
      var n = this.w, i = n.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series"));
      if (i.length > 0)
        for (var o = 0; o < i.length; o++) {
          for (var d = n.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series[data\\:realIndex='").concat(o, "'] circle")), f = [], p = 0; p < d.length; p++)
            f.push({ x: d[p].getAttribute("cx"), y: d[p].getAttribute("cy"), r: d[p].getAttribute("r") });
          n.globals.previousPaths.push(f);
        }
    } }, { key: "clearPreviousPaths", value: function() {
      var t = this.w;
      t.globals.previousPaths = [], t.globals.allSeriesCollapsed = !1;
    } }, { key: "handleNoData", value: function() {
      var t = this.w, n = t.config.noData, i = new re(this.ctx), o = t.globals.svgWidth / 2, d = t.globals.svgHeight / 2, f = "middle";
      if (t.globals.noData = !0, t.globals.animationEnded = !0, n.align === "left" ? (o = 10, f = "start") : n.align === "right" && (o = t.globals.svgWidth - 10, f = "end"), n.verticalAlign === "top" ? d = 50 : n.verticalAlign === "bottom" && (d = t.globals.svgHeight - 50), o += n.offsetX, d = d + parseInt(n.style.fontSize, 10) + 2 + n.offsetY, n.text !== void 0 && n.text !== "") {
        var p = i.drawText({ x: o, y: d, text: n.text, textAnchor: f, fontSize: n.style.fontSize, fontFamily: n.style.fontFamily, foreColor: n.style.color, opacity: 1, class: "apexcharts-text-nodata" });
        t.globals.dom.Paper.add(p);
      }
    } }, { key: "setNullSeriesToZeroValues", value: function(t) {
      for (var n = this.w, i = 0; i < t.length; i++)
        if (t[i].length === 0)
          for (var o = 0; o < t[n.globals.maxValsInArrayIndex].length; o++)
            t[i].push(0);
      return t;
    } }, { key: "hasAllSeriesEqualX", value: function() {
      for (var t = !0, n = this.w, i = this.filteredSeriesX(), o = 0; o < i.length - 1; o++)
        if (i[o][0] !== i[o + 1][0]) {
          t = !1;
          break;
        }
      return n.globals.allSeriesHasEqualX = t, t;
    } }, { key: "filteredSeriesX", value: function() {
      var t = this.w.globals.seriesX.map(function(n) {
        return n.length > 0 ? n : [];
      });
      return t;
    } }]), B;
  }(), It = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new ve(this.ctx);
    }
    return F(B, [{ key: "isMultiFormat", value: function() {
      return this.isFormatXY() || this.isFormat2DArray();
    } }, { key: "isFormatXY", value: function() {
      var t = this.w.config.series.slice(), n = new ot(this.ctx);
      if (this.activeSeriesIndex = n.getActiveConfigSeriesIndex(), t[this.activeSeriesIndex].data !== void 0 && t[this.activeSeriesIndex].data.length > 0 && t[this.activeSeriesIndex].data[0] !== null && t[this.activeSeriesIndex].data[0].x !== void 0 && t[this.activeSeriesIndex].data[0] !== null)
        return !0;
    } }, { key: "isFormat2DArray", value: function() {
      var t = this.w.config.series.slice(), n = new ot(this.ctx);
      if (this.activeSeriesIndex = n.getActiveConfigSeriesIndex(), t[this.activeSeriesIndex].data !== void 0 && t[this.activeSeriesIndex].data.length > 0 && t[this.activeSeriesIndex].data[0] !== void 0 && t[this.activeSeriesIndex].data[0] !== null && t[this.activeSeriesIndex].data[0].constructor === Array)
        return !0;
    } }, { key: "handleFormat2DArray", value: function(t, n) {
      for (var i = this.w.config, o = this.w.globals, d = i.chart.type === "boxPlot" || i.series[n].type === "boxPlot", f = 0; f < t[n].data.length; f++)
        if (t[n].data[f][1] !== void 0 && (Array.isArray(t[n].data[f][1]) && t[n].data[f][1].length === 4 && !d ? this.twoDSeries.push(Q.parseNumber(t[n].data[f][1][3])) : t[n].data[f].length >= 5 ? this.twoDSeries.push(Q.parseNumber(t[n].data[f][4])) : this.twoDSeries.push(Q.parseNumber(t[n].data[f][1])), o.dataFormatXNumeric = !0), i.xaxis.type === "datetime") {
          var p = new Date(t[n].data[f][0]);
          p = new Date(p).getTime(), this.twoDSeriesX.push(p);
        } else
          this.twoDSeriesX.push(t[n].data[f][0]);
      for (var y = 0; y < t[n].data.length; y++)
        t[n].data[y][2] !== void 0 && (this.threeDSeries.push(t[n].data[y][2]), o.isDataXYZ = !0);
    } }, { key: "handleFormatXY", value: function(t, n) {
      var i = this.w.config, o = this.w.globals, d = new it(this.ctx), f = n;
      o.collapsedSeriesIndices.indexOf(n) > -1 && (f = this.activeSeriesIndex);
      for (var p = 0; p < t[n].data.length; p++)
        t[n].data[p].y !== void 0 && (Array.isArray(t[n].data[p].y) ? this.twoDSeries.push(Q.parseNumber(t[n].data[p].y[t[n].data[p].y.length - 1])) : this.twoDSeries.push(Q.parseNumber(t[n].data[p].y))), t[n].data[p].goals !== void 0 && Array.isArray(t[n].data[p].goals) ? (this.seriesGoals[n] === void 0 && (this.seriesGoals[n] = []), this.seriesGoals[n].push(t[n].data[p].goals)) : (this.seriesGoals[n] === void 0 && (this.seriesGoals[n] = []), this.seriesGoals[n].push(null));
      for (var y = 0; y < t[f].data.length; y++) {
        var S = typeof t[f].data[y].x == "string", C = Array.isArray(t[f].data[y].x), E = !C && !!d.isValidDate(t[f].data[y].x.toString());
        if (S || E)
          if (S || i.xaxis.convertedCatToNumeric) {
            var L = o.isBarHorizontal && o.isRangeData;
            i.xaxis.type !== "datetime" || L ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[f].data[y].x)) : this.twoDSeriesX.push(d.parseDate(t[f].data[y].x));
          } else
            i.xaxis.type === "datetime" ? this.twoDSeriesX.push(d.parseDate(t[f].data[y].x.toString())) : (o.dataFormatXNumeric = !0, o.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(t[f].data[y].x)));
        else
          C ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[f].data[y].x)) : (o.isXNumeric = !0, o.dataFormatXNumeric = !0, this.twoDSeriesX.push(t[f].data[y].x));
      }
      if (t[n].data[0] && t[n].data[0].z !== void 0) {
        for (var O = 0; O < t[n].data.length; O++)
          this.threeDSeries.push(t[n].data[O].z);
        o.isDataXYZ = !0;
      }
    } }, { key: "handleRangeData", value: function(t, n) {
      var i = this.w.globals, o = {};
      return this.isFormat2DArray() ? o = this.handleRangeDataFormat("array", t, n) : this.isFormatXY() && (o = this.handleRangeDataFormat("xy", t, n)), i.seriesRangeStart.push(o.start), i.seriesRangeEnd.push(o.end), i.seriesRange.push(o.rangeUniques), i.seriesRange.forEach(function(d, f) {
        d && d.forEach(function(p, y) {
          p.y.forEach(function(S, C) {
            for (var E = 0; E < p.y.length; E++)
              if (C !== E) {
                var L = S.y1, O = S.y2, P = p.y[E].y1;
                L <= p.y[E].y2 && P <= O && (p.overlaps.indexOf(S.rangeName) < 0 && p.overlaps.push(S.rangeName), p.overlaps.indexOf(p.y[E].rangeName) < 0 && p.overlaps.push(p.y[E].rangeName));
              }
          });
        });
      }), o;
    } }, { key: "handleCandleStickBoxData", value: function(t, n) {
      var i = this.w.globals, o = {};
      return this.isFormat2DArray() ? o = this.handleCandleStickBoxDataFormat("array", t, n) : this.isFormatXY() && (o = this.handleCandleStickBoxDataFormat("xy", t, n)), i.seriesCandleO[n] = o.o, i.seriesCandleH[n] = o.h, i.seriesCandleM[n] = o.m, i.seriesCandleL[n] = o.l, i.seriesCandleC[n] = o.c, o;
    } }, { key: "handleRangeDataFormat", value: function(t, n, i) {
      var o = [], d = [], f = n[i].data.filter(function(C, E, L) {
        return E === L.findIndex(function(O) {
          return O.x === C.x;
        });
      }).map(function(C, E) {
        return { x: C.x, overlaps: [], y: [] };
      });
      if (t === "array")
        for (var p = 0; p < n[i].data.length; p++)
          Array.isArray(n[i].data[p]) ? (o.push(n[i].data[p][1][0]), d.push(n[i].data[p][1][1])) : (o.push(n[i].data[p]), d.push(n[i].data[p]));
      else if (t === "xy")
        for (var y = function(C) {
          var E = Array.isArray(n[i].data[C].y), L = Q.randomId(), O = n[i].data[C].x, P = { y1: E ? n[i].data[C].y[0] : n[i].data[C].y, y2: E ? n[i].data[C].y[1] : n[i].data[C].y, rangeName: L };
          n[i].data[C].rangeName = L;
          var I = f.findIndex(function(j) {
            return j.x === O;
          });
          f[I].y.push(P), o.push(P.y1), d.push(P.y2);
        }, S = 0; S < n[i].data.length; S++)
          y(S);
      return { start: o, end: d, rangeUniques: f };
    } }, { key: "handleCandleStickBoxDataFormat", value: function(t, n, i) {
      var o = this.w, d = o.config.chart.type === "boxPlot" || o.config.series[i].type === "boxPlot", f = [], p = [], y = [], S = [], C = [];
      if (t === "array")
        if (d && n[i].data[0].length === 6 || !d && n[i].data[0].length === 5)
          for (var E = 0; E < n[i].data.length; E++)
            f.push(n[i].data[E][1]), p.push(n[i].data[E][2]), d ? (y.push(n[i].data[E][3]), S.push(n[i].data[E][4]), C.push(n[i].data[E][5])) : (S.push(n[i].data[E][3]), C.push(n[i].data[E][4]));
        else
          for (var L = 0; L < n[i].data.length; L++)
            Array.isArray(n[i].data[L][1]) && (f.push(n[i].data[L][1][0]), p.push(n[i].data[L][1][1]), d ? (y.push(n[i].data[L][1][2]), S.push(n[i].data[L][1][3]), C.push(n[i].data[L][1][4])) : (S.push(n[i].data[L][1][2]), C.push(n[i].data[L][1][3])));
      else if (t === "xy")
        for (var O = 0; O < n[i].data.length; O++)
          Array.isArray(n[i].data[O].y) && (f.push(n[i].data[O].y[0]), p.push(n[i].data[O].y[1]), d ? (y.push(n[i].data[O].y[2]), S.push(n[i].data[O].y[3]), C.push(n[i].data[O].y[4])) : (S.push(n[i].data[O].y[2]), C.push(n[i].data[O].y[3])));
      return { o: f, h: p, m: y, l: S, c: C };
    } }, { key: "parseDataAxisCharts", value: function(t) {
      var n, i = this, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.ctx, d = this.w.config, f = this.w.globals, p = new it(o), y = d.labels.length > 0 ? d.labels.slice() : d.xaxis.categories.slice();
      if (f.isRangeBar = d.chart.type === "rangeBar" && f.isBarHorizontal, f.hasXaxisGroups = d.xaxis.type === "category" && d.xaxis.group.groups.length > 0, f.hasXaxisGroups && (f.groups = d.xaxis.group.groups), f.hasSeriesGroups = (n = t[0]) === null || n === void 0 ? void 0 : n.group, f.hasSeriesGroups) {
        var S = [], C = ue(new Set(t.map(function(P) {
          return P.group;
        })));
        t.forEach(function(P, I) {
          var j = C.indexOf(P.group);
          S[j] || (S[j] = []), S[j].push(P.name);
        }), f.seriesGroups = S;
      }
      for (var E = function() {
        for (var P = 0; P < y.length; P++)
          if (typeof y[P] == "string") {
            if (!p.isValidDate(y[P]))
              throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
            i.twoDSeriesX.push(p.parseDate(y[P]));
          } else
            i.twoDSeriesX.push(y[P]);
      }, L = 0; L < t.length; L++) {
        if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], t[L].data === void 0)
          return void console.error("It is a possibility that you may have not included 'data' property in series.");
        if (d.chart.type !== "rangeBar" && d.chart.type !== "rangeArea" && t[L].type !== "rangeBar" && t[L].type !== "rangeArea" || (f.isRangeData = !0, f.isComboCharts ? t[L].type !== "rangeBar" && t[L].type !== "rangeArea" || this.handleRangeData(t, L) : d.chart.type !== "rangeBar" && d.chart.type !== "rangeArea" || this.handleRangeData(t, L)), this.isMultiFormat())
          this.isFormat2DArray() ? this.handleFormat2DArray(t, L) : this.isFormatXY() && this.handleFormatXY(t, L), d.chart.type !== "candlestick" && t[L].type !== "candlestick" && d.chart.type !== "boxPlot" && t[L].type !== "boxPlot" || this.handleCandleStickBoxData(t, L), f.series.push(this.twoDSeries), f.labels.push(this.twoDSeriesX), f.seriesX.push(this.twoDSeriesX), f.seriesGoals = this.seriesGoals, L !== this.activeSeriesIndex || this.fallbackToCategory || (f.isXNumeric = !0);
        else {
          d.xaxis.type === "datetime" ? (f.isXNumeric = !0, E(), f.seriesX.push(this.twoDSeriesX)) : d.xaxis.type === "numeric" && (f.isXNumeric = !0, y.length > 0 && (this.twoDSeriesX = y, f.seriesX.push(this.twoDSeriesX))), f.labels.push(this.twoDSeriesX);
          var O = t[L].data.map(function(P) {
            return Q.parseNumber(P);
          });
          f.series.push(O);
        }
        f.seriesZ.push(this.threeDSeries), t[L].name !== void 0 ? f.seriesNames.push(t[L].name) : f.seriesNames.push("series-" + parseInt(L + 1, 10)), t[L].color !== void 0 ? f.seriesColors.push(t[L].color) : f.seriesColors.push(void 0);
      }
      return this.w;
    } }, { key: "parseDataNonAxisCharts", value: function(t) {
      var n = this.w.globals, i = this.w.config;
      n.series = t.slice(), n.seriesNames = i.labels.slice();
      for (var o = 0; o < n.series.length; o++)
        n.seriesNames[o] === void 0 && n.seriesNames.push("series-" + (o + 1));
      return this.w;
    } }, { key: "handleExternalLabelsData", value: function(t) {
      var n = this.w.config, i = this.w.globals;
      n.xaxis.categories.length > 0 ? i.labels = n.xaxis.categories : n.labels.length > 0 ? i.labels = n.labels.slice() : this.fallbackToCategory ? (i.labels = i.labels[0], i.seriesRange.length && (i.seriesRange.map(function(o) {
        o.forEach(function(d) {
          i.labels.indexOf(d.x) < 0 && d.x && i.labels.push(d.x);
        });
      }), i.labels = Array.from(new Set(i.labels.map(JSON.stringify)), JSON.parse)), n.xaxis.convertedCatToNumeric && (new We(n).convertCatToNumericXaxis(n, this.ctx, i.seriesX[0]), this._generateExternalLabels(t))) : this._generateExternalLabels(t);
    } }, { key: "_generateExternalLabels", value: function(t) {
      var n = this.w.globals, i = this.w.config, o = [];
      if (n.axisCharts) {
        if (n.series.length > 0)
          if (this.isFormatXY())
            for (var d = i.series.map(function(E, L) {
              return E.data.filter(function(O, P, I) {
                return I.findIndex(function(j) {
                  return j.x === O.x;
                }) === P;
              });
            }), f = d.reduce(function(E, L, O, P) {
              return P[E].length > L.length ? E : O;
            }, 0), p = 0; p < d[f].length; p++)
              o.push(p + 1);
          else
            for (var y = 0; y < n.series[n.maxValsInArrayIndex].length; y++)
              o.push(y + 1);
        n.seriesX = [];
        for (var S = 0; S < t.length; S++)
          n.seriesX.push(o);
        this.w.globals.isBarHorizontal || (n.isXNumeric = !0);
      }
      if (o.length === 0) {
        o = n.axisCharts ? [] : n.series.map(function(E, L) {
          return L + 1;
        });
        for (var C = 0; C < t.length; C++)
          n.seriesX.push(o);
      }
      n.labels = o, i.xaxis.convertedCatToNumeric && (n.categoryLabels = o.map(function(E) {
        return i.xaxis.labels.formatter(E);
      })), n.noLabelsProvided = !0;
    } }, { key: "parseData", value: function(t) {
      var n = this.w, i = n.config, o = n.globals;
      if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), o.axisCharts ? (this.parseDataAxisCharts(t), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(t), i.chart.stacked) {
        var d = new ot(this.ctx);
        o.series = d.setNullSeriesToZeroValues(o.series);
      }
      this.coreUtils.getSeriesTotals(), o.axisCharts && (o.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals()), this.coreUtils.getPercentSeries(), o.dataFormatXNumeric || o.isXNumeric && (i.xaxis.type !== "numeric" || i.labels.length !== 0 || i.xaxis.categories.length !== 0) || this.handleExternalLabelsData(t);
      for (var f = this.coreUtils.getCategoryLabels(o.labels), p = 0; p < f.length; p++)
        if (Array.isArray(f[p])) {
          o.isMultiLineX = !0;
          break;
        }
    } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
      var t = this, n = this.w;
      n.globals.ignoreYAxisIndexes = n.globals.collapsedSeries.map(function(i, o) {
        if (t.w.globals.isMultipleYAxis && !n.config.chart.stacked)
          return i.index;
      });
    } }]), B;
  }(), Et = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "getLabel", value: function(t, n, i, o) {
      var d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "12px", p = !(arguments.length > 6 && arguments[6] !== void 0) || arguments[6], y = this.w, S = t[o] === void 0 ? "" : t[o], C = S, E = y.globals.xLabelFormatter, L = y.config.xaxis.labels.formatter, O = !1, P = new Ht(this.ctx), I = S;
      p && (C = P.xLabelFormat(E, S, I, { i: o, dateFormatter: new it(this.ctx).formatDate, w: y }), L !== void 0 && (C = L(S, t[o], { i: o, dateFormatter: new it(this.ctx).formatDate, w: y })));
      var j, V;
      n.length > 0 ? (j = n[o].unit, V = null, n.forEach(function(N) {
        N.unit === "month" ? V = "year" : N.unit === "day" ? V = "month" : N.unit === "hour" ? V = "day" : N.unit === "minute" && (V = "hour");
      }), O = V === j, i = n[o].position, C = n[o].value) : y.config.xaxis.type === "datetime" && L === void 0 && (C = ""), C === void 0 && (C = ""), C = Array.isArray(C) ? C : C.toString();
      var Z = new re(this.ctx), b = {};
      b = y.globals.rotateXLabels && p ? Z.getTextRects(C, parseInt(f, 10), null, "rotate(".concat(y.config.xaxis.labels.rotate, " 0 0)"), !1) : Z.getTextRects(C, parseInt(f, 10));
      var M = !y.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
      return !Array.isArray(C) && (C.indexOf("NaN") === 0 || C.toLowerCase().indexOf("invalid") === 0 || C.toLowerCase().indexOf("infinity") >= 0 || d.indexOf(C) >= 0 && M) && (C = ""), { x: i, text: C, textRect: b, isBold: O };
    } }, { key: "checkLabelBasedOnTickamount", value: function(t, n, i) {
      var o = this.w, d = o.config.xaxis.tickAmount;
      return d === "dataPoints" && (d = Math.round(o.globals.gridWidth / 120)), d > i || t % Math.round(i / (d + 1)) == 0 || (n.text = ""), n;
    } }, { key: "checkForOverflowingLabels", value: function(t, n, i, o, d) {
      var f = this.w;
      if (t === 0 && f.globals.skipFirstTimelinelabel && (n.text = ""), t === i - 1 && f.globals.skipLastTimelinelabel && (n.text = ""), f.config.xaxis.labels.hideOverlappingLabels && o.length > 0) {
        var p = d[d.length - 1];
        n.x < p.textRect.width / (f.globals.rotateXLabels ? Math.abs(f.config.xaxis.labels.rotate) / 12 : 1.01) + p.x && (n.text = "");
      }
      return n;
    } }, { key: "checkForReversedLabels", value: function(t, n) {
      var i = this.w;
      return i.config.yaxis[t] && i.config.yaxis[t].reversed && n.reverse(), n;
    } }, { key: "isYAxisHidden", value: function(t) {
      var n = this.w, i = new ve(this.ctx);
      return !n.config.yaxis[t].show || !n.config.yaxis[t].showForNullSeries && i.isSeriesNull(t) && n.globals.collapsedSeriesIndices.indexOf(t) === -1;
    } }, { key: "getYAxisForeColor", value: function(t, n) {
      var i = this.w;
      return Array.isArray(t) && i.globals.yAxisScale[n] && this.ctx.theme.pushExtraColors(t, i.globals.yAxisScale[n].result.length, !1), t;
    } }, { key: "drawYAxisTicks", value: function(t, n, i, o, d, f, p) {
      var y = this.w, S = new re(this.ctx), C = y.globals.translateY;
      if (o.show && n > 0) {
        y.config.yaxis[d].opposite === !0 && (t += o.width);
        for (var E = n; E >= 0; E--) {
          var L = C + n / 10 + y.config.yaxis[d].labels.offsetY - 1;
          y.globals.isBarHorizontal && (L = f * E), y.config.chart.type === "heatmap" && (L += f / 2);
          var O = S.drawLine(t + i.offsetX - o.width + o.offsetX, L + o.offsetY, t + i.offsetX + o.offsetX, L + o.offsetY, o.color);
          p.add(O), C += f;
        }
      }
    } }]), B;
  }(), Ut = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "scaleSvgNode", value: function(t, n) {
      var i = parseFloat(t.getAttributeNS(null, "width")), o = parseFloat(t.getAttributeNS(null, "height"));
      t.setAttributeNS(null, "width", i * n), t.setAttributeNS(null, "height", o * n), t.setAttributeNS(null, "viewBox", "0 0 " + i + " " + o);
    } }, { key: "fixSvgStringForIe11", value: function(t) {
      if (!Q.isIE11())
        return t.replace(/&nbsp;/g, "&#160;");
      var n = 0, i = t.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function(o) {
        return ++n === 2 ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : o;
      });
      return i = (i = i.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1");
    } }, { key: "getSvgString", value: function(t) {
      t == null && (t = 1);
      var n = this.w.globals.dom.Paper.svg();
      if (t !== 1) {
        var i = this.w.globals.dom.Paper.node.cloneNode(!0);
        this.scaleSvgNode(i, t), n = new XMLSerializer().serializeToString(i);
      }
      return this.fixSvgStringForIe11(n);
    } }, { key: "cleanup", value: function() {
      var t = this.w, n = t.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"), i = t.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"), o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
      Array.prototype.forEach.call(o, function(d) {
        d.setAttribute("width", 0);
      }), n && n[0] && (n[0].setAttribute("x", -500), n[0].setAttribute("x1", -500), n[0].setAttribute("x2", -500)), i && i[0] && (i[0].setAttribute("y", -100), i[0].setAttribute("y1", -100), i[0].setAttribute("y2", -100));
    } }, { key: "svgUrl", value: function() {
      this.cleanup();
      var t = this.getSvgString(), n = new Blob([t], { type: "image/svg+xml;charset=utf-8" });
      return URL.createObjectURL(n);
    } }, { key: "dataURI", value: function(t) {
      var n = this;
      return new Promise(function(i) {
        var o = n.w, d = t ? t.scale || t.width / o.globals.svgWidth : 1;
        n.cleanup();
        var f = document.createElement("canvas");
        f.width = o.globals.svgWidth * d, f.height = parseInt(o.globals.dom.elWrap.style.height, 10) * d;
        var p = o.config.chart.background === "transparent" ? "#fff" : o.config.chart.background, y = f.getContext("2d");
        y.fillStyle = p, y.fillRect(0, 0, f.width * d, f.height * d);
        var S = n.getSvgString(d);
        if (window.canvg && Q.isIE11()) {
          var C = window.canvg.Canvg.fromString(y, S, { ignoreClear: !0, ignoreDimensions: !0 });
          C.start();
          var E = f.msToBlob();
          C.stop(), i({ blob: E });
        } else {
          var L = "data:image/svg+xml," + encodeURIComponent(S), O = new Image();
          O.crossOrigin = "anonymous", O.onload = function() {
            if (y.drawImage(O, 0, 0), f.msToBlob) {
              var P = f.msToBlob();
              i({ blob: P });
            } else {
              var I = f.toDataURL("image/png");
              i({ imgURI: I });
            }
          }, O.src = L;
        }
      });
    } }, { key: "exportToSVG", value: function() {
      this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg");
    } }, { key: "exportToPng", value: function() {
      var t = this;
      this.dataURI().then(function(n) {
        var i = n.imgURI, o = n.blob;
        o ? navigator.msSaveOrOpenBlob(o, t.w.globals.chartID + ".png") : t.triggerDownload(i, t.w.config.chart.toolbar.export.png.filename, ".png");
      });
    } }, { key: "exportToCSV", value: function(t) {
      var n = this, i = t.series, o = t.fileName, d = t.columnDelimiter, f = d === void 0 ? "," : d, p = t.lineDelimiter, y = p === void 0 ? `
` : p, S = this.w;
      i || (i = S.config.series);
      var C = [], E = [], L = "", O = S.globals.series.map(function(b, M) {
        return S.globals.collapsedSeriesIndices.indexOf(M) === -1 ? b : [];
      }), P = Math.max.apply(Math, ue(i.map(function(b) {
        return b.data ? b.data.length : 0;
      }))), I = new It(this.ctx), j = new Et(this.ctx), V = function(b) {
        var M = "";
        if (S.globals.axisCharts) {
          if (S.config.xaxis.type === "category" || S.config.xaxis.convertedCatToNumeric)
            if (S.globals.isBarHorizontal) {
              var N = S.globals.yLabelFormatters[0], X = new ot(n.ctx).getActiveConfigSeriesIndex();
              M = N(S.globals.labels[b], { seriesIndex: X, dataPointIndex: b, w: S });
            } else
              M = j.getLabel(S.globals.labels, S.globals.timescaleLabels, 0, b).text;
          S.config.xaxis.type === "datetime" && (S.config.xaxis.categories.length ? M = S.config.xaxis.categories[b] : S.config.labels.length && (M = S.config.labels[b]));
        } else
          M = S.config.labels[b];
        return Array.isArray(M) && (M = M.join(" ")), Q.isNumber(M) ? M : M.split(f).join("");
      }, Z = function(b, M) {
        if (C.length && M === 0 && E.push(C.join(f)), b.data) {
          b.data = b.data.length && b.data || ue(Array(P)).map(function() {
            return "";
          });
          for (var N = 0; N < b.data.length; N++) {
            C = [];
            var X = V(N);
            if (X || (I.isFormatXY() ? X = i[M].data[N].x : I.isFormat2DArray() && (X = i[M].data[N] ? i[M].data[N][0] : "")), M === 0) {
              C.push((oe = X, S.config.xaxis.type === "datetime" && String(oe).length >= 10 ? S.config.chart.toolbar.export.csv.dateFormatter(X) : Q.isNumber(X) ? X : X.split(f).join("")));
              for (var K = 0; K < S.globals.series.length; K++) {
                var ee;
                I.isFormatXY() ? C.push((ee = i[K].data[N]) === null || ee === void 0 ? void 0 : ee.y) : C.push(O[K][N]);
              }
            }
            (S.config.chart.type === "candlestick" || b.type && b.type === "candlestick") && (C.pop(), C.push(S.globals.seriesCandleO[M][N]), C.push(S.globals.seriesCandleH[M][N]), C.push(S.globals.seriesCandleL[M][N]), C.push(S.globals.seriesCandleC[M][N])), (S.config.chart.type === "boxPlot" || b.type && b.type === "boxPlot") && (C.pop(), C.push(S.globals.seriesCandleO[M][N]), C.push(S.globals.seriesCandleH[M][N]), C.push(S.globals.seriesCandleM[M][N]), C.push(S.globals.seriesCandleL[M][N]), C.push(S.globals.seriesCandleC[M][N])), S.config.chart.type === "rangeBar" && (C.pop(), C.push(S.globals.seriesRangeStart[M][N]), C.push(S.globals.seriesRangeEnd[M][N])), C.length && E.push(C.join(f));
          }
        }
        var oe;
      };
      C.push(S.config.chart.toolbar.export.csv.headerCategory), S.config.chart.type === "boxPlot" ? (C.push("minimum"), C.push("q1"), C.push("median"), C.push("q3"), C.push("maximum")) : S.config.chart.type === "candlestick" ? (C.push("open"), C.push("high"), C.push("low"), C.push("close")) : S.config.chart.type === "rangeBar" ? (C.push("minimum"), C.push("maximum")) : i.map(function(b, M) {
        var N = (b.name ? b.name : "series-".concat(M)) + "";
        S.globals.axisCharts && C.push(N.split(f).join("") ? N.split(f).join("") : "series-".concat(M));
      }), S.globals.axisCharts || (C.push(S.config.chart.toolbar.export.csv.headerValue), E.push(C.join(f))), i.map(function(b, M) {
        S.globals.axisCharts ? Z(b, M) : ((C = []).push(S.globals.labels[M].split(f).join("")), C.push(O[M]), E.push(C.join(f)));
      }), L += E.join(y), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + L), o || S.config.chart.toolbar.export.csv.filename, ".csv");
    } }, { key: "triggerDownload", value: function(t, n, i) {
      var o = document.createElement("a");
      o.href = t, o.download = (n || this.w.globals.chartID) + i, document.body.appendChild(o), o.click(), document.body.removeChild(o);
    } }]), B;
  }(), Bt = function() {
    function B(t, n) {
      A(this, B), this.ctx = t, this.elgrid = n, this.w = t.w;
      var i = this.w;
      this.axesUtils = new Et(t), this.xaxisLabels = i.globals.labels.slice(), i.globals.timescaleLabels.length > 0 && !i.globals.isBarHorizontal && (this.xaxisLabels = i.globals.timescaleLabels.slice()), i.config.xaxis.overwriteCategories && (this.xaxisLabels = i.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], i.config.xaxis.position === "top" ? this.offY = 0 : this.offY = i.globals.gridHeight + 1, this.offY = this.offY + i.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = i.config.chart.type === "bar" && i.config.plotOptions.bar.horizontal, this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.xaxisBorderWidth = i.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = i.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = i.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = i.config.xaxis.axisBorder.height, this.yaxis = i.config.yaxis[0];
    }
    return F(B, [{ key: "drawXaxis", value: function() {
      var t = this.w, n = new re(this.ctx), i = n.group({ class: "apexcharts-xaxis", transform: "translate(".concat(t.config.xaxis.offsetX, ", ").concat(t.config.xaxis.offsetY, ")") }), o = n.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(t.globals.translateXAxisX, ", ").concat(t.globals.translateXAxisY, ")") });
      i.add(o);
      for (var d = [], f = 0; f < this.xaxisLabels.length; f++)
        d.push(this.xaxisLabels[f]);
      if (this.drawXAxisLabelAndGroup(!0, n, o, d, t.globals.isXNumeric, function(P, I) {
        return I;
      }), t.globals.hasXaxisGroups) {
        var p = t.globals.groups;
        d = [];
        for (var y = 0; y < p.length; y++)
          d.push(p[y].title);
        var S = {};
        t.config.xaxis.group.style && (S.xaxisFontSize = t.config.xaxis.group.style.fontSize, S.xaxisFontFamily = t.config.xaxis.group.style.fontFamily, S.xaxisForeColors = t.config.xaxis.group.style.colors, S.fontWeight = t.config.xaxis.group.style.fontWeight, S.cssClass = t.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(!1, n, o, d, !1, function(P, I) {
          return p[P].cols * I;
        }, S);
      }
      if (t.config.xaxis.title.text !== void 0) {
        var C = n.group({ class: "apexcharts-xaxis-title" }), E = n.drawText({ x: t.globals.gridWidth / 2 + t.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + (t.config.xaxis.position === "bottom" ? t.globals.xAxisLabelsHeight : -t.globals.xAxisLabelsHeight - 10) + t.config.xaxis.title.offsetY, text: t.config.xaxis.title.text, textAnchor: "middle", fontSize: t.config.xaxis.title.style.fontSize, fontFamily: t.config.xaxis.title.style.fontFamily, fontWeight: t.config.xaxis.title.style.fontWeight, foreColor: t.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + t.config.xaxis.title.style.cssClass });
        C.add(E), i.add(C);
      }
      if (t.config.xaxis.axisBorder.show) {
        var L = t.globals.barPadForNumericAxis, O = n.drawLine(t.globals.padHorizontal + t.config.xaxis.axisBorder.offsetX - L, this.offY, this.xaxisBorderWidth + L, this.offY, t.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
        this.elgrid && this.elgrid.elGridBorders && t.config.grid.show ? this.elgrid.elGridBorders.add(O) : i.add(O);
      }
      return i;
    } }, { key: "drawXAxisLabelAndGroup", value: function(t, n, i, o, d, f) {
      var p, y = this, S = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : {}, C = [], E = [], L = this.w, O = S.xaxisFontSize || this.xaxisFontSize, P = S.xaxisFontFamily || this.xaxisFontFamily, I = S.xaxisForeColors || this.xaxisForeColors, j = S.fontWeight || L.config.xaxis.labels.style.fontWeight, V = S.cssClass || L.config.xaxis.labels.style.cssClass, Z = L.globals.padHorizontal, b = o.length, M = L.config.xaxis.type === "category" ? L.globals.dataPoints : b;
      if (M === 0 && b > M && (M = b), d) {
        var N = M > 1 ? M - 1 : M;
        p = L.globals.gridWidth / N, Z = Z + f(0, p) / 2 + L.config.xaxis.labels.offsetX;
      } else
        p = L.globals.gridWidth / M, Z = Z + f(0, p) + L.config.xaxis.labels.offsetX;
      for (var X = function(ee) {
        var oe = Z - f(ee, p) / 2 + L.config.xaxis.labels.offsetX;
        ee === 0 && b === 1 && p / 2 === Z && M === 1 && (oe = L.globals.gridWidth / 2);
        var de = y.axesUtils.getLabel(o, L.globals.timescaleLabels, oe, ee, C, O, t), ke = 28;
        if (L.globals.rotateXLabels && t && (ke = 22), L.config.xaxis.title.text && L.config.xaxis.position === "top" && (ke += parseFloat(L.config.xaxis.title.style.fontSize) + 2), t || (ke = ke + parseFloat(O) + (L.globals.xAxisLabelsHeight - L.globals.xAxisGroupLabelsHeight) + (L.globals.rotateXLabels ? 10 : 0)), de = L.config.xaxis.tickAmount !== void 0 && L.config.xaxis.tickAmount !== "dataPoints" && L.config.xaxis.type !== "datetime" ? y.axesUtils.checkLabelBasedOnTickamount(ee, de, b) : y.axesUtils.checkForOverflowingLabels(ee, de, b, C, E), L.config.xaxis.labels.show) {
          var _e = n.drawText({ x: de.x, y: y.offY + L.config.xaxis.labels.offsetY + ke - (L.config.xaxis.position === "top" ? L.globals.xAxisHeight + L.config.xaxis.axisTicks.height - 2 : 0), text: de.text, textAnchor: "middle", fontWeight: de.isBold ? 600 : j, fontSize: O, fontFamily: P, foreColor: Array.isArray(I) ? t && L.config.xaxis.convertedCatToNumeric ? I[L.globals.minX + ee - 1] : I[ee] : I, isPlainText: !1, cssClass: (t ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + V });
          if (i.add(_e), _e.on("click", function(Ie) {
            if (typeof L.config.chart.events.xAxisLabelClick == "function") {
              var rt = Object.assign({}, L, { labelIndex: ee });
              L.config.chart.events.xAxisLabelClick(Ie, y.ctx, rt);
            }
          }), t) {
            var Me = document.createElementNS(L.globals.SVGNS, "title");
            Me.textContent = Array.isArray(de.text) ? de.text.join(" ") : de.text, _e.node.appendChild(Me), de.text !== "" && (C.push(de.text), E.push(de));
          }
        }
        ee < b - 1 && (Z += f(ee + 1, p));
      }, K = 0; K <= b - 1; K++)
        X(K);
    } }, { key: "drawXaxisInversed", value: function(t) {
      var n, i, o = this, d = this.w, f = new re(this.ctx), p = d.config.yaxis[0].opposite ? d.globals.translateYAxisX[t] : 0, y = f.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: t }), S = f.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + p + ", 0)" });
      y.add(S);
      var C = [];
      if (d.config.yaxis[t].show)
        for (var E = 0; E < this.xaxisLabels.length; E++)
          C.push(this.xaxisLabels[E]);
      n = d.globals.gridHeight / C.length, i = -n / 2.2;
      var L = d.globals.yLabelFormatters[0], O = d.config.yaxis[0].labels;
      if (O.show)
        for (var P = function(N) {
          var X = C[N] === void 0 ? "" : C[N];
          X = L(X, { seriesIndex: t, dataPointIndex: N, w: d });
          var K = o.axesUtils.getYAxisForeColor(O.style.colors, t), ee = 0;
          Array.isArray(X) && (ee = X.length / 2 * parseInt(O.style.fontSize, 10));
          var oe = O.offsetX - 15, de = "end";
          o.yaxis.opposite && (de = "start"), d.config.yaxis[0].labels.align === "left" ? (oe = O.offsetX, de = "start") : d.config.yaxis[0].labels.align === "center" ? (oe = O.offsetX, de = "middle") : d.config.yaxis[0].labels.align === "right" && (de = "end");
          var ke = f.drawText({ x: oe, y: i + n + O.offsetY - ee, text: X, textAnchor: de, foreColor: Array.isArray(K) ? K[N] : K, fontSize: O.style.fontSize, fontFamily: O.style.fontFamily, fontWeight: O.style.fontWeight, isPlainText: !1, cssClass: "apexcharts-yaxis-label " + O.style.cssClass, maxWidth: O.maxWidth });
          S.add(ke), ke.on("click", function(Ie) {
            if (typeof d.config.chart.events.xAxisLabelClick == "function") {
              var rt = Object.assign({}, d, { labelIndex: N });
              d.config.chart.events.xAxisLabelClick(Ie, o.ctx, rt);
            }
          });
          var _e = document.createElementNS(d.globals.SVGNS, "title");
          if (_e.textContent = Array.isArray(X) ? X.join(" ") : X, ke.node.appendChild(_e), d.config.yaxis[t].labels.rotate !== 0) {
            var Me = f.rotateAroundCenter(ke.node);
            ke.node.setAttribute("transform", "rotate(".concat(d.config.yaxis[t].labels.rotate, " 0 ").concat(Me.y, ")"));
          }
          i += n;
        }, I = 0; I <= C.length - 1; I++)
          P(I);
      if (d.config.yaxis[0].title.text !== void 0) {
        var j = f.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + p + ", 0)" }), V = f.drawText({ x: d.config.yaxis[0].title.offsetX, y: d.globals.gridHeight / 2 + d.config.yaxis[0].title.offsetY, text: d.config.yaxis[0].title.text, textAnchor: "middle", foreColor: d.config.yaxis[0].title.style.color, fontSize: d.config.yaxis[0].title.style.fontSize, fontWeight: d.config.yaxis[0].title.style.fontWeight, fontFamily: d.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + d.config.yaxis[0].title.style.cssClass });
        j.add(V), y.add(j);
      }
      var Z = 0;
      this.isCategoryBarHorizontal && d.config.yaxis[0].opposite && (Z = d.globals.gridWidth);
      var b = d.config.xaxis.axisBorder;
      if (b.show) {
        var M = f.drawLine(d.globals.padHorizontal + b.offsetX + Z, 1 + b.offsetY, d.globals.padHorizontal + b.offsetX + Z, d.globals.gridHeight + b.offsetY, b.color, 0);
        this.elgrid && this.elgrid.elGridBorders && d.config.grid.show ? this.elgrid.elGridBorders.add(M) : y.add(M);
      }
      return d.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(Z, C.length, d.config.yaxis[0].axisBorder, d.config.yaxis[0].axisTicks, 0, n, y), y;
    } }, { key: "drawXaxisTicks", value: function(t, n, i) {
      var o = this.w, d = t;
      if (!(t < 0 || t - 2 > o.globals.gridWidth)) {
        var f = this.offY + o.config.xaxis.axisTicks.offsetY;
        if (n = n + f + o.config.xaxis.axisTicks.height, o.config.xaxis.position === "top" && (n = f - o.config.xaxis.axisTicks.height), o.config.xaxis.axisTicks.show) {
          var p = new re(this.ctx).drawLine(t + o.config.xaxis.axisTicks.offsetX, f + o.config.xaxis.offsetY, d + o.config.xaxis.axisTicks.offsetX, n + o.config.xaxis.offsetY, o.config.xaxis.axisTicks.color);
          i.add(p), p.node.classList.add("apexcharts-xaxis-tick");
        }
      }
    } }, { key: "getXAxisTicksPositions", value: function() {
      var t = this.w, n = [], i = this.xaxisLabels.length, o = t.globals.padHorizontal;
      if (t.globals.timescaleLabels.length > 0)
        for (var d = 0; d < i; d++)
          o = this.xaxisLabels[d].position, n.push(o);
      else
        for (var f = i, p = 0; p < f; p++) {
          var y = f;
          t.globals.isXNumeric && t.config.chart.type !== "bar" && (y -= 1), o += t.globals.gridWidth / y, n.push(o);
        }
      return n;
    } }, { key: "xAxisLabelCorrections", value: function() {
      var t = this.w, n = new re(this.ctx), i = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), d = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), f = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
      if (t.globals.rotateXLabels || t.config.xaxis.labels.rotateAlways)
        for (var p = 0; p < o.length; p++) {
          var y = n.rotateAroundCenter(o[p]);
          y.y = y.y - 1, y.x = y.x + 1, o[p].setAttribute("transform", "rotate(".concat(t.config.xaxis.labels.rotate, " ").concat(y.x, " ").concat(y.y, ")")), o[p].setAttribute("text-anchor", "end"), i.setAttribute("transform", "translate(0, ".concat(-10, ")"));
          var S = o[p].childNodes;
          t.config.xaxis.labels.trim && Array.prototype.forEach.call(S, function(O) {
            n.placeTextWithEllipsis(O, O.textContent, t.globals.xAxisLabelsHeight - (t.config.legend.position === "bottom" ? 20 : 10));
          });
        }
      else
        (function() {
          for (var O = t.globals.gridWidth / (t.globals.labels.length + 1), P = 0; P < o.length; P++) {
            var I = o[P].childNodes;
            t.config.xaxis.labels.trim && t.config.xaxis.type !== "datetime" && Array.prototype.forEach.call(I, function(j) {
              n.placeTextWithEllipsis(j, j.textContent, O);
            });
          }
        })();
      if (d.length > 0) {
        var C = d[d.length - 1].getBBox(), E = d[0].getBBox();
        C.x < -20 && d[d.length - 1].parentNode.removeChild(d[d.length - 1]), E.x + E.width > t.globals.gridWidth && !t.globals.isBarHorizontal && d[0].parentNode.removeChild(d[0]);
        for (var L = 0; L < f.length; L++)
          n.placeTextWithEllipsis(f[L], f[L].textContent, t.config.yaxis[0].labels.maxWidth - (t.config.yaxis[0].title.text ? 2 * parseFloat(t.config.yaxis[0].title.style.fontSize) : 0) - 15);
      }
    } }]), B;
  }(), vn = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
      var n = this.w;
      this.xaxisLabels = n.globals.labels.slice(), this.axesUtils = new Et(t), this.isRangeBar = n.globals.seriesRange.length && n.globals.isBarHorizontal, n.globals.timescaleLabels.length > 0 && (this.xaxisLabels = n.globals.timescaleLabels.slice());
    }
    return F(B, [{ key: "drawGridArea", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, n = this.w, i = new re(this.ctx);
      t === null && (t = i.group({ class: "apexcharts-grid" }));
      var o = i.drawLine(n.globals.padHorizontal, 1, n.globals.padHorizontal, n.globals.gridHeight, "transparent"), d = i.drawLine(n.globals.padHorizontal, n.globals.gridHeight, n.globals.gridWidth, n.globals.gridHeight, "transparent");
      return t.add(d), t.add(o), t;
    } }, { key: "drawGrid", value: function() {
      var t = null;
      return this.w.globals.axisCharts && (t = this.renderGrid(), this.drawGridArea(t.el)), t;
    } }, { key: "createGridMask", value: function() {
      var t = this.w, n = t.globals, i = new re(this.ctx), o = Array.isArray(t.config.stroke.width) ? 0 : t.config.stroke.width;
      if (Array.isArray(t.config.stroke.width)) {
        var d = 0;
        t.config.stroke.width.forEach(function(E) {
          d = Math.max(d, E);
        }), o = d;
      }
      n.dom.elGridRectMask = document.createElementNS(n.SVGNS, "clipPath"), n.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(n.cuid)), n.dom.elGridRectMarkerMask = document.createElementNS(n.SVGNS, "clipPath"), n.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(n.cuid)), n.dom.elForecastMask = document.createElementNS(n.SVGNS, "clipPath"), n.dom.elForecastMask.setAttribute("id", "forecastMask".concat(n.cuid)), n.dom.elNonForecastMask = document.createElementNS(n.SVGNS, "clipPath"), n.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(n.cuid));
      var f = t.config.chart.type, p = 0, y = 0;
      (f === "bar" || f === "rangeBar" || f === "candlestick" || f === "boxPlot" || t.globals.comboBarCount > 0) && t.globals.isXNumeric && !t.globals.isBarHorizontal && (p = t.config.grid.padding.left, y = t.config.grid.padding.right, n.barPadForNumericAxis > p && (p = n.barPadForNumericAxis, y = n.barPadForNumericAxis)), n.dom.elGridRect = i.drawRect(-o / 2 - p - 2, -o / 2, n.gridWidth + o + y + p + 4, n.gridHeight + o, 0, "#fff");
      var S = t.globals.markers.largestSize + 1;
      n.dom.elGridRectMarker = i.drawRect(2 * -S, 2 * -S, n.gridWidth + 4 * S, n.gridHeight + 4 * S, 0, "#fff"), n.dom.elGridRectMask.appendChild(n.dom.elGridRect.node), n.dom.elGridRectMarkerMask.appendChild(n.dom.elGridRectMarker.node);
      var C = n.dom.baseEl.querySelector("defs");
      C.appendChild(n.dom.elGridRectMask), C.appendChild(n.dom.elForecastMask), C.appendChild(n.dom.elNonForecastMask), C.appendChild(n.dom.elGridRectMarkerMask);
    } }, { key: "_drawGridLines", value: function(t) {
      var n = t.i, i = t.x1, o = t.y1, d = t.x2, f = t.y2, p = t.xCount, y = t.parent, S = this.w;
      if (!(n === 0 && S.globals.skipFirstTimelinelabel || n === p - 1 && S.globals.skipLastTimelinelabel && !S.config.xaxis.labels.formatter || S.config.chart.type === "radar")) {
        S.config.grid.xaxis.lines.show && this._drawGridLine({ i: n, x1: i, y1: o, x2: d, y2: f, xCount: p, parent: y });
        var C = 0;
        if (S.globals.hasXaxisGroups && S.config.xaxis.tickPlacement === "between") {
          var E = S.globals.groups;
          if (E) {
            for (var L = 0, O = 0; L < n && O < E.length; O++)
              L += E[O].cols;
            L === n && (C = 0.6 * S.globals.xAxisLabelsHeight);
          }
        }
        new Bt(this.ctx).drawXaxisTicks(i, C, S.globals.dom.elGraphical);
      }
    } }, { key: "_drawGridLine", value: function(t) {
      var n = t.i, i = t.x1, o = t.y1, d = t.x2, f = t.y2, p = t.xCount, y = t.parent, S = this.w, C = !1, E = y.node.classList.contains("apexcharts-gridlines-horizontal"), L = S.config.grid.strokeDashArray, O = S.globals.barPadForNumericAxis;
      (o === 0 && f === 0 || i === 0 && d === 0) && (C = !0), o === S.globals.gridHeight && f === S.globals.gridHeight && (C = !0), !S.globals.isBarHorizontal || n !== 0 && n !== p - 1 || (C = !0);
      var P = new re(this).drawLine(i - (E ? O : 0), o, d + (E ? O : 0), f, S.config.grid.borderColor, L);
      P.node.classList.add("apexcharts-gridline"), C && S.config.grid.show ? this.elGridBorders.add(P) : y.add(P);
    } }, { key: "_drawGridBandRect", value: function(t) {
      var n = t.c, i = t.x1, o = t.y1, d = t.x2, f = t.y2, p = t.type, y = this.w, S = new re(this.ctx), C = y.globals.barPadForNumericAxis;
      if (p !== "column" || y.config.xaxis.type !== "datetime") {
        var E = y.config.grid[p].colors[n], L = S.drawRect(i - (p === "row" ? C : 0), o, d + (p === "row" ? 2 * C : 0), f, 0, E, y.config.grid[p].opacity);
        this.elg.add(L), L.attr("clip-path", "url(#gridRectMask".concat(y.globals.cuid, ")")), L.node.classList.add("apexcharts-grid-".concat(p));
      }
    } }, { key: "_drawXYLines", value: function(t) {
      var n = this, i = t.xCount, o = t.tickAmount, d = this.w;
      if (d.config.grid.xaxis.lines.show || d.config.xaxis.axisTicks.show) {
        var f, p = d.globals.padHorizontal, y = d.globals.gridHeight;
        d.globals.timescaleLabels.length ? function(P) {
          for (var I = P.xC, j = P.x1, V = P.y1, Z = P.x2, b = P.y2, M = 0; M < I; M++)
            j = n.xaxisLabels[M].position, Z = n.xaxisLabels[M].position, n._drawGridLines({ i: M, x1: j, y1: V, x2: Z, y2: b, xCount: i, parent: n.elgridLinesV });
        }({ xC: i, x1: p, y1: 0, x2: f, y2: y }) : (d.globals.isXNumeric && (i = d.globals.xAxisScale.result.length), function(P) {
          for (var I = P.xC, j = P.x1, V = P.y1, Z = P.x2, b = P.y2, M = 0; M < I + (d.globals.isXNumeric ? 0 : 1); M++)
            M === 0 && I === 1 && d.globals.dataPoints === 1 && (Z = j = d.globals.gridWidth / 2), n._drawGridLines({ i: M, x1: j, y1: V, x2: Z, y2: b, xCount: i, parent: n.elgridLinesV }), Z = j += d.globals.gridWidth / (d.globals.isXNumeric ? I - 1 : I);
        }({ xC: i, x1: p, y1: 0, x2: f, y2: y }));
      }
      if (d.config.grid.yaxis.lines.show) {
        var S = 0, C = 0, E = d.globals.gridWidth, L = o + 1;
        this.isRangeBar && (L = d.globals.labels.length);
        for (var O = 0; O < L + (this.isRangeBar ? 1 : 0); O++)
          this._drawGridLine({ i: O, xCount: L + (this.isRangeBar ? 1 : 0), x1: 0, y1: S, x2: E, y2: C, parent: this.elgridLinesH }), C = S += d.globals.gridHeight / (this.isRangeBar ? L : o);
      }
    } }, { key: "_drawInvertedXYLines", value: function(t) {
      var n = t.xCount, i = this.w;
      if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show)
        for (var o, d = i.globals.padHorizontal, f = i.globals.gridHeight, p = 0; p < n + 1; p++)
          i.config.grid.xaxis.lines.show && this._drawGridLine({ i: p, xCount: n + 1, x1: d, y1: 0, x2: o, y2: f, parent: this.elgridLinesV }), new Bt(this.ctx).drawXaxisTicks(d, 0, i.globals.dom.elGraphical), o = d = d + i.globals.gridWidth / n + 0.3;
      if (i.config.grid.yaxis.lines.show)
        for (var y = 0, S = 0, C = i.globals.gridWidth, E = 0; E < i.globals.dataPoints + 1; E++)
          this._drawGridLine({ i: E, xCount: i.globals.dataPoints + 1, x1: 0, y1: y, x2: C, y2: S, parent: this.elgridLinesH }), S = y += i.globals.gridHeight / i.globals.dataPoints;
    } }, { key: "renderGrid", value: function() {
      var t = this.w, n = new re(this.ctx);
      this.elg = n.group({ class: "apexcharts-grid" }), this.elgridLinesH = n.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = n.group({ class: "apexcharts-gridlines-vertical" }), this.elGridBorders = n.group({ class: "apexcharts-grid-borders" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
      for (var i, o = t.globals.yAxisScale.length ? t.globals.yAxisScale[0].result.length - 1 : 5, d = 0; d < t.globals.series.length && (t.globals.yAxisScale[d] !== void 0 && (o = t.globals.yAxisScale[d].result.length - 1), !(o > 2)); d++)
        ;
      return !t.globals.isBarHorizontal || this.isRangeBar ? (i = this.xaxisLabels.length, this.isRangeBar && (i--, o = t.globals.labels.length, t.config.xaxis.tickAmount && t.config.xaxis.labels.formatter && (i = t.config.xaxis.tickAmount)), this._drawXYLines({ xCount: i, tickAmount: o })) : (i = o, o = t.globals.xTickAmount, this._drawInvertedXYLines({ xCount: i, tickAmount: o })), this.drawGridBands(i, o), { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: t.globals.gridWidth / i };
    } }, { key: "drawGridBands", value: function(t, n) {
      var i = this.w;
      if (i.config.grid.row.colors !== void 0 && i.config.grid.row.colors.length > 0)
        for (var o = 0, d = i.globals.gridHeight / n, f = i.globals.gridWidth, p = 0, y = 0; p < n; p++, y++)
          y >= i.config.grid.row.colors.length && (y = 0), this._drawGridBandRect({ c: y, x1: 0, y1: o, x2: f, y2: d, type: "row" }), o += i.globals.gridHeight / n;
      if (i.config.grid.column.colors !== void 0 && i.config.grid.column.colors.length > 0)
        for (var S = i.globals.isBarHorizontal || i.config.xaxis.type !== "category" && !i.config.xaxis.convertedCatToNumeric ? t : t - 1, C = i.globals.padHorizontal, E = i.globals.padHorizontal + i.globals.gridWidth / S, L = i.globals.gridHeight, O = 0, P = 0; O < t; O++, P++)
          P >= i.config.grid.column.colors.length && (P = 0), this._drawGridBandRect({ c: P, x1: C, y1: 0, x2: E, y2: L, type: "column" }), C += i.globals.gridWidth / S;
    } }]), B;
  }(), Ze = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "niceScale", value: function(t, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, d = arguments.length > 4 ? arguments[4] : void 0, f = this.w, p = Math.abs(n - t);
      if ((i = this._adjustTicksForSmallRange(i, o, p)) === "dataPoints" && (i = f.globals.dataPoints - 1), t === Number.MIN_VALUE && n === 0 || !Q.isNumber(t) && !Q.isNumber(n) || t === Number.MIN_VALUE && n === -Number.MAX_VALUE)
        return t = 0, n = i, this.linearScale(t, n, i);
      t > n ? (console.warn("axis.min cannot be greater than axis.max"), n = t + 0.1) : t === n && (t = t === 0 ? 0 : t - 0.5, n = n === 0 ? 2 : n + 0.5);
      var y = [];
      p < 1 && d && (f.config.chart.type === "candlestick" || f.config.series[o].type === "candlestick" || f.config.chart.type === "boxPlot" || f.config.series[o].type === "boxPlot" || f.globals.isRangeData) && (n *= 1.01);
      var S = i + 1;
      S < 2 ? S = 2 : S > 2 && (S -= 2);
      var C = p / S, E = Math.floor(Q.log10(C)), L = Math.pow(10, E), O = Math.round(C / L);
      O < 1 && (O = 1);
      var P = O * L, I = P * Math.floor(t / P), j = P * Math.ceil(n / P), V = I;
      if (d && p > 2) {
        for (; y.push(Q.stripNumber(V, 7)), !((V += P) > j); )
          ;
        return { result: y, niceMin: y[0], niceMax: y[y.length - 1] };
      }
      var Z = t;
      (y = []).push(Q.stripNumber(Z, 7));
      for (var b = Math.abs(n - t) / i, M = 0; M <= i; M++)
        Z += b, y.push(Z);
      return y[y.length - 2] >= n && y.pop(), { result: y, niceMin: y[0], niceMax: y[y.length - 1] };
    } }, { key: "linearScale", value: function(t, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, o = arguments.length > 3 ? arguments[3] : void 0, d = Math.abs(n - t);
      (i = this._adjustTicksForSmallRange(i, o, d)) === "dataPoints" && (i = this.w.globals.dataPoints - 1);
      var f = d / i;
      i === Number.MAX_VALUE && (i = 10, f = 1);
      for (var p = [], y = t; i >= 0; )
        p.push(y), y += f, i -= 1;
      return { result: p, niceMin: p[0], niceMax: p[p.length - 1] };
    } }, { key: "logarithmicScaleNice", value: function(t, n, i) {
      n <= 0 && (n = Math.max(t, i)), t <= 0 && (t = Math.min(n, i));
      for (var o = [], d = Math.ceil(Math.log(n) / Math.log(i) + 1), f = Math.floor(Math.log(t) / Math.log(i)); f < d; f++)
        o.push(Math.pow(i, f));
      return { result: o, niceMin: o[0], niceMax: o[o.length - 1] };
    } }, { key: "logarithmicScale", value: function(t, n, i) {
      n <= 0 && (n = Math.max(t, i)), t <= 0 && (t = Math.min(n, i));
      for (var o = [], d = Math.log(n) / Math.log(i), f = Math.log(t) / Math.log(i), p = d - f, y = Math.round(p), S = p / y, C = 0, E = f; C < y; C++, E += S)
        o.push(Math.pow(i, E));
      return o.push(Math.pow(i, d)), { result: o, niceMin: t, niceMax: n };
    } }, { key: "_adjustTicksForSmallRange", value: function(t, n, i) {
      var o = t;
      if (n !== void 0 && this.w.config.yaxis[n].labels.formatter && this.w.config.yaxis[n].tickAmount === void 0) {
        var d = Number(this.w.config.yaxis[n].labels.formatter(1));
        Q.isNumber(d) && this.w.globals.yValueDecimal === 0 && (o = Math.ceil(i));
      }
      return o < t ? o : t;
    } }, { key: "setYScaleForIndex", value: function(t, n, i) {
      var o = this.w.globals, d = this.w.config, f = o.isBarHorizontal ? d.xaxis : d.yaxis[t];
      o.yAxisScale[t] === void 0 && (o.yAxisScale[t] = []);
      var p = Math.abs(i - n);
      if (f.logarithmic && p <= 5 && (o.invalidLogScale = !0), f.logarithmic && p > 5)
        o.allSeriesCollapsed = !1, o.yAxisScale[t] = this.logarithmicScale(n, i, f.logBase), o.yAxisScale[t] = f.forceNiceScale ? this.logarithmicScaleNice(n, i, f.logBase) : this.logarithmicScale(n, i, f.logBase);
      else if (i !== -Number.MAX_VALUE && Q.isNumber(i))
        if (o.allSeriesCollapsed = !1, f.min === void 0 && f.max === void 0 || f.forceNiceScale) {
          var y = d.yaxis[t].max === void 0 && d.yaxis[t].min === void 0 || d.yaxis[t].forceNiceScale;
          o.yAxisScale[t] = this.niceScale(n, i, f.tickAmount ? f.tickAmount : p < 5 && p > 1 ? p + 1 : 5, t, y);
        } else
          o.yAxisScale[t] = this.linearScale(n, i, f.tickAmount, t);
      else
        o.yAxisScale[t] = this.linearScale(0, 5, 5);
    } }, { key: "setXScale", value: function(t, n) {
      var i = this.w, o = i.globals, d = i.config.xaxis, f = Math.abs(n - t);
      return n !== -Number.MAX_VALUE && Q.isNumber(n) ? o.xAxisScale = this.linearScale(t, n, d.tickAmount ? d.tickAmount : f < 5 && f > 1 ? f + 1 : 5, 0) : o.xAxisScale = this.linearScale(0, 5, 5), o.xAxisScale;
    } }, { key: "setMultipleYScales", value: function() {
      var t = this, n = this.w.globals, i = this.w.config, o = n.minYArr.concat([]), d = n.maxYArr.concat([]), f = [];
      i.yaxis.forEach(function(p, y) {
        var S = y;
        i.series.forEach(function(L, O) {
          L.name === p.seriesName && (S = O, y !== O ? f.push({ index: O, similarIndex: y, alreadyExists: !0 }) : f.push({ index: O }));
        });
        var C = o[S], E = d[S];
        t.setYScaleForIndex(y, C, E);
      }), this.sameScaleInMultipleAxes(o, d, f);
    } }, { key: "sameScaleInMultipleAxes", value: function(t, n, i) {
      var o = this, d = this.w.config, f = this.w.globals, p = [];
      i.forEach(function(I) {
        I.alreadyExists && (p[I.index] === void 0 && (p[I.index] = []), p[I.index].push(I.index), p[I.index].push(I.similarIndex));
      }), f.yAxisSameScaleIndices = p, p.forEach(function(I, j) {
        p.forEach(function(V, Z) {
          var b, M;
          j !== Z && (b = I, M = V, b.filter(function(N) {
            return M.indexOf(N) !== -1;
          })).length > 0 && (p[j] = p[j].concat(p[Z]));
        });
      });
      var y = p.map(function(I) {
        return I.filter(function(j, V) {
          return I.indexOf(j) === V;
        });
      }).map(function(I) {
        return I.sort();
      });
      p = p.filter(function(I) {
        return !!I;
      });
      var S = y.slice(), C = S.map(function(I) {
        return JSON.stringify(I);
      });
      S = S.filter(function(I, j) {
        return C.indexOf(JSON.stringify(I)) === j;
      });
      var E = [], L = [];
      t.forEach(function(I, j) {
        S.forEach(function(V, Z) {
          V.indexOf(j) > -1 && (E[Z] === void 0 && (E[Z] = [], L[Z] = []), E[Z].push({ key: j, value: I }), L[Z].push({ key: j, value: n[j] }));
        });
      });
      var O = Array.apply(null, Array(S.length)).map(Number.prototype.valueOf, Number.MIN_VALUE), P = Array.apply(null, Array(S.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
      E.forEach(function(I, j) {
        I.forEach(function(V, Z) {
          O[j] = Math.min(V.value, O[j]);
        });
      }), L.forEach(function(I, j) {
        I.forEach(function(V, Z) {
          P[j] = Math.max(V.value, P[j]);
        });
      }), t.forEach(function(I, j) {
        L.forEach(function(V, Z) {
          var b = O[Z], M = P[Z];
          d.chart.stacked && (M = 0, V.forEach(function(N, X) {
            N.value !== -Number.MAX_VALUE && (M += N.value), b !== Number.MIN_VALUE && (b += E[Z][X].value);
          })), V.forEach(function(N, X) {
            V[X].key === j && (d.yaxis[j].min !== void 0 && (b = typeof d.yaxis[j].min == "function" ? d.yaxis[j].min(f.minY) : d.yaxis[j].min), d.yaxis[j].max !== void 0 && (M = typeof d.yaxis[j].max == "function" ? d.yaxis[j].max(f.maxY) : d.yaxis[j].max), o.setYScaleForIndex(j, b, M));
          });
        });
      });
    } }, { key: "autoScaleY", value: function(t, n, i) {
      t || (t = this);
      var o = t.w;
      if (o.globals.isMultipleYAxis || o.globals.collapsedSeries.length)
        return console.warn("autoScaleYaxis is not supported in a multi-yaxis chart."), n;
      var d = o.globals.seriesX[0], f = o.config.chart.stacked;
      return n.forEach(function(p, y) {
        for (var S = 0, C = 0; C < d.length; C++)
          if (d[C] >= i.xaxis.min) {
            S = C;
            break;
          }
        var E, L, O = o.globals.minYArr[y], P = o.globals.maxYArr[y], I = o.globals.stackedSeriesTotals;
        o.globals.series.forEach(function(j, V) {
          var Z = j[S];
          f ? (Z = I[S], E = L = Z, I.forEach(function(b, M) {
            d[M] <= i.xaxis.max && d[M] >= i.xaxis.min && (b > L && b !== null && (L = b), j[M] < E && j[M] !== null && (E = j[M]));
          })) : (E = L = Z, j.forEach(function(b, M) {
            if (d[M] <= i.xaxis.max && d[M] >= i.xaxis.min) {
              var N = b, X = b;
              o.globals.series.forEach(function(K, ee) {
                b !== null && (N = Math.min(K[M], N), X = Math.max(K[M], X));
              }), X > L && X !== null && (L = X), N < E && N !== null && (E = N);
            }
          })), E === void 0 && L === void 0 && (E = O, L = P), L *= L < 0 ? 0.9 : 1.1, (E *= E < 0 ? 1.1 : 0.9) === 0 && L === 0 && (E = -1, L = 1), L < 0 && L < P && (L = P), E < 0 && E > O && (E = O), n.length > 1 ? (n[V].min = p.min === void 0 ? E : p.min, n[V].max = p.max === void 0 ? L : p.max) : (n[0].min = p.min === void 0 ? E : p.min, n[0].max = p.max === void 0 ? L : p.max);
        });
      }), n;
    } }]), B;
  }(), pn = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w, this.scales = new Ze(t);
    }
    return F(B, [{ key: "init", value: function() {
      this.setYRange(), this.setXRange(), this.setZRange();
    } }, { key: "getMinYMaxY", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -Number.MAX_VALUE, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, d = this.w.config, f = this.w.globals, p = -Number.MAX_VALUE, y = Number.MIN_VALUE;
      o === null && (o = t + 1);
      var S = f.series, C = S, E = S;
      d.chart.type === "candlestick" ? (C = f.seriesCandleL, E = f.seriesCandleH) : d.chart.type === "boxPlot" ? (C = f.seriesCandleO, E = f.seriesCandleC) : f.isRangeData && (C = f.seriesRangeStart, E = f.seriesRangeEnd);
      for (var L = t; L < o; L++) {
        f.dataPoints = Math.max(f.dataPoints, S[L].length), f.categoryLabels.length && (f.dataPoints = f.categoryLabels.filter(function(I) {
          return I !== void 0;
        }).length), f.labels.length && d.xaxis.type !== "datetime" && f.series.reduce(function(I, j) {
          return I + j.length;
        }, 0) !== 0 && (f.dataPoints = Math.max(f.dataPoints, f.labels.length));
        for (var O = 0; O < f.series[L].length; O++) {
          var P = S[L][O];
          P !== null && Q.isNumber(P) ? (E[L][O] !== void 0 && (p = Math.max(p, E[L][O]), n = Math.min(n, E[L][O])), C[L][O] !== void 0 && (n = Math.min(n, C[L][O]), i = Math.max(i, C[L][O])), this.w.config.chart.type !== "candlestick" && this.w.config.chart.type !== "boxPlot" && this.w.config.chart.type === "rangeArea" && this.w.config.chart.type === "rangeBar" || (this.w.config.chart.type !== "candlestick" && this.w.config.chart.type !== "boxPlot" || f.seriesCandleC[L][O] !== void 0 && (p = Math.max(p, f.seriesCandleO[L][O]), p = Math.max(p, f.seriesCandleH[L][O]), p = Math.max(p, f.seriesCandleL[L][O]), p = Math.max(p, f.seriesCandleC[L][O]), this.w.config.chart.type === "boxPlot" && (p = Math.max(p, f.seriesCandleM[L][O]))), !d.series[L].type || d.series[L].type === "candlestick" && d.series[L].type === "boxPlot" && d.series[L].type === "rangeArea" && d.series[L].type === "rangeBar" || (p = Math.max(p, f.series[L][O]), n = Math.min(n, f.series[L][O])), i = p), f.seriesGoals[L] && f.seriesGoals[L][O] && Array.isArray(f.seriesGoals[L][O]) && f.seriesGoals[L][O].forEach(function(I) {
            y !== Number.MIN_VALUE && (y = Math.min(y, I.value), n = y), p = Math.max(p, I.value), i = p;
          }), Q.isFloat(P) && (P = Q.noExponents(P), f.yValueDecimal = Math.max(f.yValueDecimal, P.toString().split(".")[1].length)), y > C[L][O] && C[L][O] < 0 && (y = C[L][O])) : f.hasNullValues = !0;
        }
      }
      return d.chart.type === "rangeBar" && f.seriesRangeStart.length && f.isBarHorizontal && (y = n), d.chart.type === "bar" && (y < 0 && p < 0 && (p = 0), y === Number.MIN_VALUE && (y = 0)), { minY: y, maxY: p, lowestY: n, highestY: i };
    } }, { key: "setYRange", value: function() {
      var t = this.w.globals, n = this.w.config;
      t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE;
      var i = Number.MAX_VALUE;
      if (t.isMultipleYAxis)
        for (var o = 0; o < t.series.length; o++) {
          var d = this.getMinYMaxY(o, i, null, o + 1);
          t.minYArr.push(d.minY), t.maxYArr.push(d.maxY), i = d.lowestY;
        }
      var f = this.getMinYMaxY(0, i, null, t.series.length);
      if (t.minY = f.minY, t.maxY = f.maxY, i = f.lowestY, n.chart.stacked && this._setStackedMinMax(), (n.chart.type === "line" || n.chart.type === "area" || n.chart.type === "candlestick" || n.chart.type === "boxPlot" || n.chart.type === "rangeBar" && !t.isBarHorizontal) && t.minY === Number.MIN_VALUE && i !== -Number.MAX_VALUE && i !== t.maxY) {
        var p = t.maxY - i;
        (i >= 0 && i <= 10 || n.yaxis[0].min !== void 0 || n.yaxis[0].max !== void 0) && (p = 0), t.minY = i - 5 * p / 100, i > 0 && t.minY < 0 && (t.minY = 0), t.maxY = t.maxY + 5 * p / 100;
      }
      return n.yaxis.forEach(function(y, S) {
        y.max !== void 0 && (typeof y.max == "number" ? t.maxYArr[S] = y.max : typeof y.max == "function" && (t.maxYArr[S] = y.max(t.isMultipleYAxis ? t.maxYArr[S] : t.maxY)), t.maxY = t.maxYArr[S]), y.min !== void 0 && (typeof y.min == "number" ? t.minYArr[S] = y.min : typeof y.min == "function" && (t.minYArr[S] = y.min(t.isMultipleYAxis ? t.minYArr[S] === Number.MIN_VALUE ? 0 : t.minYArr[S] : t.minY)), t.minY = t.minYArr[S]);
      }), t.isBarHorizontal && ["min", "max"].forEach(function(y) {
        n.xaxis[y] !== void 0 && typeof n.xaxis[y] == "number" && (y === "min" ? t.minY = n.xaxis[y] : t.maxY = n.xaxis[y]);
      }), t.isMultipleYAxis ? (this.scales.setMultipleYScales(), t.minY = i, t.yAxisScale.forEach(function(y, S) {
        t.minYArr[S] = y.niceMin, t.maxYArr[S] = y.niceMax;
      })) : (this.scales.setYScaleForIndex(0, t.minY, t.maxY), t.minY = t.yAxisScale[0].niceMin, t.maxY = t.yAxisScale[0].niceMax, t.minYArr[0] = t.yAxisScale[0].niceMin, t.maxYArr[0] = t.yAxisScale[0].niceMax), { minY: t.minY, maxY: t.maxY, minYArr: t.minYArr, maxYArr: t.maxYArr, yAxisScale: t.yAxisScale };
    } }, { key: "setXRange", value: function() {
      var t = this.w.globals, n = this.w.config, i = n.xaxis.type === "numeric" || n.xaxis.type === "datetime" || n.xaxis.type === "category" && !t.noLabelsProvided || t.noLabelsProvided || t.isXNumeric;
      if (t.isXNumeric && function() {
        for (var p = 0; p < t.series.length; p++)
          if (t.labels[p])
            for (var y = 0; y < t.labels[p].length; y++)
              t.labels[p][y] !== null && Q.isNumber(t.labels[p][y]) && (t.maxX = Math.max(t.maxX, t.labels[p][y]), t.initialMaxX = Math.max(t.maxX, t.labels[p][y]), t.minX = Math.min(t.minX, t.labels[p][y]), t.initialMinX = Math.min(t.minX, t.labels[p][y]));
      }(), t.noLabelsProvided && n.xaxis.categories.length === 0 && (t.maxX = t.labels[t.labels.length - 1], t.initialMaxX = t.labels[t.labels.length - 1], t.minX = 1, t.initialMinX = 1), t.isXNumeric || t.noLabelsProvided || t.dataFormatXNumeric) {
        var o;
        if (n.xaxis.tickAmount === void 0 ? (o = Math.round(t.svgWidth / 150), n.xaxis.type === "numeric" && t.dataPoints < 30 && (o = t.dataPoints - 1), o > t.dataPoints && t.dataPoints !== 0 && (o = t.dataPoints - 1)) : n.xaxis.tickAmount === "dataPoints" ? (t.series.length > 1 && (o = t.series[t.maxValsInArrayIndex].length - 1), t.isXNumeric && (o = t.maxX - t.minX - 1)) : o = n.xaxis.tickAmount, t.xTickAmount = o, n.xaxis.max !== void 0 && typeof n.xaxis.max == "number" && (t.maxX = n.xaxis.max), n.xaxis.min !== void 0 && typeof n.xaxis.min == "number" && (t.minX = n.xaxis.min), n.xaxis.range !== void 0 && (t.minX = t.maxX - n.xaxis.range), t.minX !== Number.MAX_VALUE && t.maxX !== -Number.MAX_VALUE)
          if (n.xaxis.convertedCatToNumeric && !t.dataFormatXNumeric) {
            for (var d = [], f = t.minX - 1; f < t.maxX; f++)
              d.push(f + 1);
            t.xAxisScale = { result: d, niceMin: d[0], niceMax: d[d.length - 1] };
          } else
            t.xAxisScale = this.scales.setXScale(t.minX, t.maxX);
        else
          t.xAxisScale = this.scales.linearScale(1, o, o), t.noLabelsProvided && t.labels.length > 0 && (t.xAxisScale = this.scales.linearScale(1, t.labels.length, o - 1), t.seriesX = t.labels.slice());
        i && (t.labels = t.xAxisScale.result.slice());
      }
      return t.isBarHorizontal && t.labels.length && (t.xTickAmount = t.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: t.minX, maxX: t.maxX };
    } }, { key: "setZRange", value: function() {
      var t = this.w.globals;
      if (t.isDataXYZ) {
        for (var n = 0; n < t.series.length; n++)
          if (t.seriesZ[n] !== void 0)
            for (var i = 0; i < t.seriesZ[n].length; i++)
              t.seriesZ[n][i] !== null && Q.isNumber(t.seriesZ[n][i]) && (t.maxZ = Math.max(t.maxZ, t.seriesZ[n][i]), t.minZ = Math.min(t.minZ, t.seriesZ[n][i]));
      }
    } }, { key: "_handleSingleDataPoint", value: function() {
      var t = this.w.globals, n = this.w.config;
      if (t.minX === t.maxX) {
        var i = new it(this.ctx);
        if (n.xaxis.type === "datetime") {
          var o = i.getDate(t.minX);
          n.xaxis.labels.datetimeUTC ? o.setUTCDate(o.getUTCDate() - 2) : o.setDate(o.getDate() - 2), t.minX = new Date(o).getTime();
          var d = i.getDate(t.maxX);
          n.xaxis.labels.datetimeUTC ? d.setUTCDate(d.getUTCDate() + 2) : d.setDate(d.getDate() + 2), t.maxX = new Date(d).getTime();
        } else
          (n.xaxis.type === "numeric" || n.xaxis.type === "category" && !t.noLabelsProvided) && (t.minX = t.minX - 2, t.initialMinX = t.minX, t.maxX = t.maxX + 2, t.initialMaxX = t.maxX);
      }
    } }, { key: "_getMinXDiff", value: function() {
      var t = this.w.globals;
      t.isXNumeric && t.seriesX.forEach(function(n, i) {
        n.length === 1 && n.push(t.seriesX[t.maxValsInArrayIndex][t.seriesX[t.maxValsInArrayIndex].length - 1]);
        var o = n.slice();
        o.sort(function(d, f) {
          return d - f;
        }), o.forEach(function(d, f) {
          if (f > 0) {
            var p = d - o[f - 1];
            p > 0 && (t.minXDiff = Math.min(p, t.minXDiff));
          }
        }), t.dataPoints !== 1 && t.minXDiff !== Number.MAX_VALUE || (t.minXDiff = 0.5);
      });
    } }, { key: "_setStackedMinMax", value: function() {
      var t = this, n = this.w.globals;
      if (n.series.length) {
        var i = n.seriesGroups;
        i.length || (i = [this.w.config.series.map(function(f) {
          return f.name;
        })]);
        var o = {}, d = {};
        i.forEach(function(f) {
          o[f] = [], d[f] = [], t.w.config.series.map(function(p, y) {
            return f.indexOf(p.name) > -1 ? y : null;
          }).filter(function(p) {
            return p !== null;
          }).forEach(function(p) {
            for (var y = 0; y < n.series[n.maxValsInArrayIndex].length; y++)
              o[f][y] === void 0 && (o[f][y] = 0, d[f][y] = 0), n.series[p][y] !== null && Q.isNumber(n.series[p][y]) && (n.series[p][y] > 0 ? o[f][y] += parseFloat(n.series[p][y]) + 1e-4 : d[f][y] += parseFloat(n.series[p][y]));
          });
        }), Object.entries(o).forEach(function(f) {
          var p = ae(f, 1)[0];
          o[p].forEach(function(y, S) {
            n.maxY = Math.max(n.maxY, o[p][S]), n.minY = Math.min(n.minY, d[p][S]);
          });
        });
      }
    } }]), B;
  }(), jn = function() {
    function B(t, n) {
      A(this, B), this.ctx = t, this.elgrid = n, this.w = t.w;
      var i = this.w;
      this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.axisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = i.config.chart.type === "bar" && i.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, i.config.xaxis.position === "bottom" && (this.xAxisoffX = i.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new Et(t);
    }
    return F(B, [{ key: "drawYaxis", value: function(t) {
      var n = this, i = this.w, o = new re(this.ctx), d = i.config.yaxis[t].labels.style, f = d.fontSize, p = d.fontFamily, y = d.fontWeight, S = o.group({ class: "apexcharts-yaxis", rel: t, transform: "translate(" + i.globals.translateYAxisX[t] + ", 0)" });
      if (this.axesUtils.isYAxisHidden(t))
        return S;
      var C = o.group({ class: "apexcharts-yaxis-texts-g" });
      S.add(C);
      var E = i.globals.yAxisScale[t].result.length - 1, L = i.globals.gridHeight / E, O = i.globals.translateY, P = i.globals.yLabelFormatters[t], I = i.globals.yAxisScale[t].result.slice();
      I = this.axesUtils.checkForReversedLabels(t, I);
      var j = "";
      if (i.config.yaxis[t].labels.show)
        for (var V = function(oe) {
          var de = I[oe];
          de = P(de, oe, i);
          var ke = i.config.yaxis[t].labels.padding;
          i.config.yaxis[t].opposite && i.config.yaxis.length !== 0 && (ke *= -1);
          var _e = "end";
          i.config.yaxis[t].opposite && (_e = "start"), i.config.yaxis[t].labels.align === "left" ? _e = "start" : i.config.yaxis[t].labels.align === "center" ? _e = "middle" : i.config.yaxis[t].labels.align === "right" && (_e = "end");
          var Me = n.axesUtils.getYAxisForeColor(d.colors, t), Ie = o.drawText({ x: ke, y: O + E / 10 + i.config.yaxis[t].labels.offsetY + 1, text: de, textAnchor: _e, fontSize: f, fontFamily: p, fontWeight: y, maxWidth: i.config.yaxis[t].labels.maxWidth, foreColor: Array.isArray(Me) ? Me[oe] : Me, isPlainText: !1, cssClass: "apexcharts-yaxis-label " + d.cssClass });
          oe === E && (j = Ie), C.add(Ie);
          var rt = document.createElementNS(i.globals.SVGNS, "title");
          if (rt.textContent = Array.isArray(de) ? de.join(" ") : de, Ie.node.appendChild(rt), i.config.yaxis[t].labels.rotate !== 0) {
            var Qt = o.rotateAroundCenter(j.node), Kt = o.rotateAroundCenter(Ie.node);
            Ie.node.setAttribute("transform", "rotate(".concat(i.config.yaxis[t].labels.rotate, " ").concat(Qt.x, " ").concat(Kt.y, ")"));
          }
          O += L;
        }, Z = E; Z >= 0; Z--)
          V(Z);
      if (i.config.yaxis[t].title.text !== void 0) {
        var b = o.group({ class: "apexcharts-yaxis-title" }), M = 0;
        i.config.yaxis[t].opposite && (M = i.globals.translateYAxisX[t]);
        var N = o.drawText({ x: M, y: i.globals.gridHeight / 2 + i.globals.translateY + i.config.yaxis[t].title.offsetY, text: i.config.yaxis[t].title.text, textAnchor: "end", foreColor: i.config.yaxis[t].title.style.color, fontSize: i.config.yaxis[t].title.style.fontSize, fontWeight: i.config.yaxis[t].title.style.fontWeight, fontFamily: i.config.yaxis[t].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + i.config.yaxis[t].title.style.cssClass });
        b.add(N), S.add(b);
      }
      var X = i.config.yaxis[t].axisBorder, K = 31 + X.offsetX;
      if (i.config.yaxis[t].opposite && (K = -31 - X.offsetX), X.show) {
        var ee = o.drawLine(K, i.globals.translateY + X.offsetY - 2, K, i.globals.gridHeight + i.globals.translateY + X.offsetY + 2, X.color, 0, X.width);
        S.add(ee);
      }
      return i.config.yaxis[t].axisTicks.show && this.axesUtils.drawYAxisTicks(K, E, X, i.config.yaxis[t].axisTicks, t, L, S), S;
    } }, { key: "drawYaxisInversed", value: function(t) {
      var n = this.w, i = new re(this.ctx), o = i.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), d = i.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(n.globals.translateXAxisX, ", ").concat(n.globals.translateXAxisY, ")") });
      o.add(d);
      var f = n.globals.yAxisScale[t].result.length - 1, p = n.globals.gridWidth / f + 0.1, y = p + n.config.xaxis.labels.offsetX, S = n.globals.xLabelFormatter, C = n.globals.yAxisScale[t].result.slice(), E = n.globals.timescaleLabels;
      E.length > 0 && (this.xaxisLabels = E.slice(), f = (C = E.slice()).length), C = this.axesUtils.checkForReversedLabels(t, C);
      var L = E.length;
      if (n.config.xaxis.labels.show)
        for (var O = L ? 0 : f; L ? O < L : O >= 0; L ? O++ : O--) {
          var P = C[O];
          P = S(P, O, n);
          var I = n.globals.gridWidth + n.globals.padHorizontal - (y - p + n.config.xaxis.labels.offsetX);
          if (E.length) {
            var j = this.axesUtils.getLabel(C, E, I, O, this.drawnLabels, this.xaxisFontSize);
            I = j.x, P = j.text, this.drawnLabels.push(j.text), O === 0 && n.globals.skipFirstTimelinelabel && (P = ""), O === C.length - 1 && n.globals.skipLastTimelinelabel && (P = "");
          }
          var V = i.drawText({ x: I, y: this.xAxisoffX + n.config.xaxis.labels.offsetY + 30 - (n.config.xaxis.position === "top" ? n.globals.xAxisHeight + n.config.xaxis.axisTicks.height - 2 : 0), text: P, textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: n.config.xaxis.labels.style.fontWeight, isPlainText: !1, cssClass: "apexcharts-xaxis-label " + n.config.xaxis.labels.style.cssClass });
          d.add(V), V.tspan(P);
          var Z = document.createElementNS(n.globals.SVGNS, "title");
          Z.textContent = P, V.node.appendChild(Z), y += p;
        }
      return this.inversedYAxisTitleText(o), this.inversedYAxisBorder(o), o;
    } }, { key: "inversedYAxisBorder", value: function(t) {
      var n = this.w, i = new re(this.ctx), o = n.config.xaxis.axisBorder;
      if (o.show) {
        var d = 0;
        n.config.chart.type === "bar" && n.globals.isXNumeric && (d -= 15);
        var f = i.drawLine(n.globals.padHorizontal + d + o.offsetX, this.xAxisoffX, n.globals.gridWidth, this.xAxisoffX, o.color, 0, o.height);
        this.elgrid && this.elgrid.elGridBorders && n.config.grid.show ? this.elgrid.elGridBorders.add(f) : t.add(f);
      }
    } }, { key: "inversedYAxisTitleText", value: function(t) {
      var n = this.w, i = new re(this.ctx);
      if (n.config.xaxis.title.text !== void 0) {
        var o = i.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), d = i.drawText({ x: n.globals.gridWidth / 2 + n.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(n.config.xaxis.title.style.fontSize) + n.config.xaxis.title.offsetY + 20, text: n.config.xaxis.title.text, textAnchor: "middle", fontSize: n.config.xaxis.title.style.fontSize, fontFamily: n.config.xaxis.title.style.fontFamily, fontWeight: n.config.xaxis.title.style.fontWeight, foreColor: n.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + n.config.xaxis.title.style.cssClass });
        o.add(d), t.add(o);
      }
    } }, { key: "yAxisTitleRotate", value: function(t, n) {
      var i = this.w, o = new re(this.ctx), d = { width: 0, height: 0 }, f = { width: 0, height: 0 }, p = i.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-texts-g"));
      p !== null && (d = p.getBoundingClientRect());
      var y = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-title text"));
      if (y !== null && (f = y.getBoundingClientRect()), y !== null) {
        var S = this.xPaddingForYAxisTitle(t, d, f, n);
        y.setAttribute("x", S.xPos - (n ? 10 : 0));
      }
      if (y !== null) {
        var C = o.rotateAroundCenter(y);
        y.setAttribute("transform", "rotate(".concat(n ? -1 * i.config.yaxis[t].title.rotate : i.config.yaxis[t].title.rotate, " ").concat(C.x, " ").concat(C.y, ")"));
      }
    } }, { key: "xPaddingForYAxisTitle", value: function(t, n, i, o) {
      var d = this.w, f = 0, p = 0, y = 10;
      return d.config.yaxis[t].title.text === void 0 || t < 0 ? { xPos: p, padd: 0 } : (o ? (p = n.width + d.config.yaxis[t].title.offsetX + i.width / 2 + y / 2, (f += 1) === 0 && (p -= y / 2)) : (p = -1 * n.width + d.config.yaxis[t].title.offsetX + y / 2 + i.width / 2, d.globals.isBarHorizontal && (y = 25, p = -1 * n.width - d.config.yaxis[t].title.offsetX - y)), { xPos: p, padd: y });
    } }, { key: "setYAxisXPosition", value: function(t, n) {
      var i = this.w, o = 0, d = 0, f = 18, p = 1;
      i.config.yaxis.length > 1 && (this.multipleYs = !0), i.config.yaxis.map(function(y, S) {
        var C = i.globals.ignoreYAxisIndexes.indexOf(S) > -1 || !y.show || y.floating || t[S].width === 0, E = t[S].width + n[S].width;
        y.opposite ? i.globals.isBarHorizontal ? (d = i.globals.gridWidth + i.globals.translateX - 1, i.globals.translateYAxisX[S] = d - y.labels.offsetX) : (d = i.globals.gridWidth + i.globals.translateX + p, C || (p = p + E + 20), i.globals.translateYAxisX[S] = d - y.labels.offsetX + 20) : (o = i.globals.translateX - f, C || (f = f + E + 20), i.globals.translateYAxisX[S] = o + y.labels.offsetX);
      });
    } }, { key: "setYAxisTextAlignments", value: function() {
      var t = this.w, n = t.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
      (n = Q.listToArray(n)).forEach(function(i, o) {
        var d = t.config.yaxis[o];
        if (d && !d.floating && d.labels.align !== void 0) {
          var f = t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(o, "'] .apexcharts-yaxis-texts-g")), p = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(o, "'] .apexcharts-yaxis-label"));
          p = Q.listToArray(p);
          var y = f.getBoundingClientRect();
          d.labels.align === "left" ? (p.forEach(function(S, C) {
            S.setAttribute("text-anchor", "start");
          }), d.opposite || f.setAttribute("transform", "translate(-".concat(y.width, ", 0)"))) : d.labels.align === "center" ? (p.forEach(function(S, C) {
            S.setAttribute("text-anchor", "middle");
          }), f.setAttribute("transform", "translate(".concat(y.width / 2 * (d.opposite ? 1 : -1), ", 0)"))) : d.labels.align === "right" && (p.forEach(function(S, C) {
            S.setAttribute("text-anchor", "end");
          }), d.opposite && f.setAttribute("transform", "translate(".concat(y.width, ", 0)")));
        }
      });
    } }]), B;
  }(), rr = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w, this.documentEvent = Q.bind(this.documentEvent, this);
    }
    return F(B, [{ key: "addEventListener", value: function(t, n) {
      var i = this.w;
      i.globals.events.hasOwnProperty(t) ? i.globals.events[t].push(n) : i.globals.events[t] = [n];
    } }, { key: "removeEventListener", value: function(t, n) {
      var i = this.w;
      if (i.globals.events.hasOwnProperty(t)) {
        var o = i.globals.events[t].indexOf(n);
        o !== -1 && i.globals.events[t].splice(o, 1);
      }
    } }, { key: "fireEvent", value: function(t, n) {
      var i = this.w;
      if (i.globals.events.hasOwnProperty(t)) {
        n && n.length || (n = []);
        for (var o = i.globals.events[t], d = o.length, f = 0; f < d; f++)
          o[f].apply(null, n);
      }
    } }, { key: "setupEventHandlers", value: function() {
      var t = this, n = this.w, i = this.ctx, o = n.globals.dom.baseEl.querySelector(n.globals.chartClass);
      this.ctx.eventList.forEach(function(d) {
        o.addEventListener(d, function(f) {
          var p = Object.assign({}, n, { seriesIndex: n.globals.capturedSeriesIndex, dataPointIndex: n.globals.capturedDataPointIndex });
          f.type === "mousemove" || f.type === "touchmove" ? typeof n.config.chart.events.mouseMove == "function" && n.config.chart.events.mouseMove(f, i, p) : f.type === "mouseleave" || f.type === "touchleave" ? typeof n.config.chart.events.mouseLeave == "function" && n.config.chart.events.mouseLeave(f, i, p) : (f.type === "mouseup" && f.which === 1 || f.type === "touchend") && (typeof n.config.chart.events.click == "function" && n.config.chart.events.click(f, i, p), i.ctx.events.fireEvent("click", [f, i, p]));
        }, { capture: !1, passive: !0 });
      }), this.ctx.eventList.forEach(function(d) {
        n.globals.dom.baseEl.addEventListener(d, t.documentEvent, { passive: !0 });
      }), this.ctx.core.setupBrushHandler();
    } }, { key: "documentEvent", value: function(t) {
      var n = this.w, i = t.target.className;
      if (t.type === "click") {
        var o = n.globals.dom.baseEl.querySelector(".apexcharts-menu");
        o && o.classList.contains("apexcharts-menu-open") && i !== "apexcharts-menu-icon" && o.classList.remove("apexcharts-menu-open");
      }
      n.globals.clientX = t.type === "touchmove" ? t.touches[0].clientX : t.clientX, n.globals.clientY = t.type === "touchmove" ? t.touches[0].clientY : t.clientY;
    } }]), B;
  }(), Lr = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "setCurrentLocaleValues", value: function(t) {
      var n = this.w.config.chart.locales;
      window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (n = this.w.config.chart.locales.concat(window.Apex.chart.locales));
      var i = n.filter(function(d) {
        return d.name === t;
      })[0];
      if (!i)
        throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
      var o = Q.extend(ft, i);
      this.w.globals.locale = o.options;
    } }]), B;
  }(), Mr = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "drawAxis", value: function(t, n) {
      var i, o, d = this, f = this.w.globals, p = this.w.config, y = new Bt(this.ctx, n), S = new jn(this.ctx, n);
      f.axisCharts && t !== "radar" && (f.isBarHorizontal ? (o = S.drawYaxisInversed(0), i = y.drawXaxisInversed(0), f.dom.elGraphical.add(i), f.dom.elGraphical.add(o)) : (i = y.drawXaxis(), f.dom.elGraphical.add(i), p.yaxis.map(function(C, E) {
        if (f.ignoreYAxisIndexes.indexOf(E) === -1 && (o = S.drawYaxis(E), f.dom.Paper.add(o), d.w.config.grid.position === "back")) {
          var L = f.dom.Paper.children()[1];
          L.remove(), f.dom.Paper.add(L);
        }
      })));
    } }]), B;
  }(), ei = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "drawXCrosshairs", value: function() {
      var t = this.w, n = new re(this.ctx), i = new Ee(this.ctx), o = t.config.xaxis.crosshairs.fill.gradient, d = t.config.xaxis.crosshairs.dropShadow, f = t.config.xaxis.crosshairs.fill.type, p = o.colorFrom, y = o.colorTo, S = o.opacityFrom, C = o.opacityTo, E = o.stops, L = d.enabled, O = d.left, P = d.top, I = d.blur, j = d.color, V = d.opacity, Z = t.config.xaxis.crosshairs.fill.color;
      if (t.config.xaxis.crosshairs.show) {
        f === "gradient" && (Z = n.drawGradient("vertical", p, y, S, C, null, E, null));
        var b = n.drawRect();
        t.config.xaxis.crosshairs.width === 1 && (b = n.drawLine());
        var M = t.globals.gridHeight;
        (!Q.isNumber(M) || M < 0) && (M = 0);
        var N = t.config.xaxis.crosshairs.width;
        (!Q.isNumber(N) || N < 0) && (N = 0), b.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2: M, width: N, height: M, fill: Z, filter: "none", "fill-opacity": t.config.xaxis.crosshairs.opacity, stroke: t.config.xaxis.crosshairs.stroke.color, "stroke-width": t.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": t.config.xaxis.crosshairs.stroke.dashArray }), L && (b = i.dropShadow(b, { left: O, top: P, blur: I, color: j, opacity: V })), t.globals.dom.elGraphical.add(b);
      }
    } }, { key: "drawYCrosshairs", value: function() {
      var t = this.w, n = new re(this.ctx), i = t.config.yaxis[0].crosshairs, o = t.globals.barPadForNumericAxis;
      if (t.config.yaxis[0].crosshairs.show) {
        var d = n.drawLine(-o, 0, t.globals.gridWidth + o, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width);
        d.attr({ class: "apexcharts-ycrosshairs" }), t.globals.dom.elGraphical.add(d);
      }
      var f = n.drawLine(-o, 0, t.globals.gridWidth + o, 0, i.stroke.color, 0, 0);
      f.attr({ class: "apexcharts-ycrosshairs-hidden" }), t.globals.dom.elGraphical.add(f);
    } }]), B;
  }(), qi = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "checkResponsiveConfig", value: function(t) {
      var n = this, i = this.w, o = i.config;
      if (o.responsive.length !== 0) {
        var d = o.responsive.slice();
        d.sort(function(S, C) {
          return S.breakpoint > C.breakpoint ? 1 : C.breakpoint > S.breakpoint ? -1 : 0;
        }).reverse();
        var f = new pt({}), p = function() {
          var S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, C = d[0].breakpoint, E = window.innerWidth > 0 ? window.innerWidth : screen.width;
          if (E > C) {
            var L = ve.extendArrayProps(f, i.globals.initialConfig, i);
            S = Q.extend(L, S), S = Q.extend(i.config, S), n.overrideResponsiveOptions(S);
          } else
            for (var O = 0; O < d.length; O++)
              E < d[O].breakpoint && (S = ve.extendArrayProps(f, d[O].options, i), S = Q.extend(i.config, S), n.overrideResponsiveOptions(S));
        };
        if (t) {
          var y = ve.extendArrayProps(f, t, i);
          y = Q.extend(i.config, y), p(y = Q.extend(y, t));
        } else
          p({});
      }
    } }, { key: "overrideResponsiveOptions", value: function(t) {
      var n = new pt(t).init({ responsiveOverride: !0 });
      this.w.config = n;
    } }]), B;
  }(), Oa = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.colors = [], this.w = t.w;
      var n = this.w;
      this.isColorFn = !1, this.isHeatmapDistributed = n.config.chart.type === "treemap" && n.config.plotOptions.treemap.distributed || n.config.chart.type === "heatmap" && n.config.plotOptions.heatmap.distributed, this.isBarDistributed = n.config.plotOptions.bar.distributed && (n.config.chart.type === "bar" || n.config.chart.type === "rangeBar");
    }
    return F(B, [{ key: "init", value: function() {
      this.setDefaultColors();
    } }, { key: "setDefaultColors", value: function() {
      var t, n = this, i = this.w, o = new Q();
      if (i.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(i.config.theme.mode)), i.config.colors === void 0 || ((t = i.config.colors) === null || t === void 0 ? void 0 : t.length) === 0 ? i.globals.colors = this.predefined() : (i.globals.colors = i.config.colors, Array.isArray(i.config.colors) && i.config.colors.length > 0 && typeof i.config.colors[0] == "function" && (i.globals.colors = i.config.series.map(function(P, I) {
        var j = i.config.colors[I];
        return j || (j = i.config.colors[0]), typeof j == "function" ? (n.isColorFn = !0, j({ value: i.globals.axisCharts ? i.globals.series[I][0] ? i.globals.series[I][0] : 0 : i.globals.series[I], seriesIndex: I, dataPointIndex: I, w: i })) : j;
      }))), i.globals.seriesColors.map(function(P, I) {
        P && (i.globals.colors[I] = P);
      }), i.config.theme.monochrome.enabled) {
        var d = [], f = i.globals.series.length;
        (this.isBarDistributed || this.isHeatmapDistributed) && (f = i.globals.series[0].length * i.globals.series.length);
        for (var p = i.config.theme.monochrome.color, y = 1 / (f / i.config.theme.monochrome.shadeIntensity), S = i.config.theme.monochrome.shadeTo, C = 0, E = 0; E < f; E++) {
          var L = void 0;
          S === "dark" ? (L = o.shadeColor(-1 * C, p), C += y) : (L = o.shadeColor(C, p), C += y), d.push(L);
        }
        i.globals.colors = d.slice();
      }
      var O = i.globals.colors.slice();
      this.pushExtraColors(i.globals.colors), ["fill", "stroke"].forEach(function(P) {
        i.config[P].colors === void 0 ? i.globals[P].colors = n.isColorFn ? i.config.colors : O : i.globals[P].colors = i.config[P].colors.slice(), n.pushExtraColors(i.globals[P].colors);
      }), i.config.dataLabels.style.colors === void 0 ? i.globals.dataLabels.style.colors = O : i.globals.dataLabels.style.colors = i.config.dataLabels.style.colors.slice(), this.pushExtraColors(i.globals.dataLabels.style.colors, 50), i.config.plotOptions.radar.polygons.fill.colors === void 0 ? i.globals.radarPolygons.fill.colors = [i.config.theme.mode === "dark" ? "#424242" : "none"] : i.globals.radarPolygons.fill.colors = i.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(i.globals.radarPolygons.fill.colors, 20), i.config.markers.colors === void 0 ? i.globals.markers.colors = O : i.globals.markers.colors = i.config.markers.colors.slice(), this.pushExtraColors(i.globals.markers.colors);
    } }, { key: "pushExtraColors", value: function(t, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, o = this.w, d = n || o.globals.series.length;
      if (i === null && (i = this.isBarDistributed || this.isHeatmapDistributed || o.config.chart.type === "heatmap" && o.config.plotOptions.heatmap.colorScale.inverse), i && o.globals.series.length && (d = o.globals.series[o.globals.maxValsInArrayIndex].length * o.globals.series.length), t.length < d)
        for (var f = d - t.length, p = 0; p < f; p++)
          t.push(t[p]);
    } }, { key: "updateThemeOptions", value: function(t) {
      t.chart = t.chart || {}, t.tooltip = t.tooltip || {};
      var n = t.theme.mode || "light", i = t.theme.palette ? t.theme.palette : n === "dark" ? "palette4" : "palette1", o = t.chart.foreColor ? t.chart.foreColor : n === "dark" ? "#f6f7f8" : "#373d3f";
      return t.tooltip.theme = n, t.chart.foreColor = o, t.theme.palette = i, t;
    } }, { key: "predefined", value: function() {
      switch (this.w.config.theme.palette) {
        case "palette1":
        default:
          this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
          break;
        case "palette2":
          this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
          break;
        case "palette3":
          this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
          break;
        case "palette4":
          this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
          break;
        case "palette5":
          this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
          break;
        case "palette6":
          this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
          break;
        case "palette7":
          this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
          break;
        case "palette8":
          this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
          break;
        case "palette9":
          this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
          break;
        case "palette10":
          this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"];
      }
      return this.colors;
    } }]), B;
  }(), ca = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "draw", value: function() {
      this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
    } }, { key: "drawTitleSubtitle", value: function(t) {
      var n = this.w, i = t === "title" ? n.config.title : n.config.subtitle, o = n.globals.svgWidth / 2, d = i.offsetY, f = "middle";
      if (i.align === "left" ? (o = 10, f = "start") : i.align === "right" && (o = n.globals.svgWidth - 10, f = "end"), o += i.offsetX, d = d + parseInt(i.style.fontSize, 10) + i.margin / 2, i.text !== void 0) {
        var p = new re(this.ctx).drawText({ x: o, y: d, text: i.text, textAnchor: f, fontSize: i.style.fontSize, fontFamily: i.style.fontFamily, fontWeight: i.style.fontWeight, foreColor: i.style.color, opacity: 1 });
        p.node.setAttribute("class", "apexcharts-".concat(t, "-text")), n.globals.dom.Paper.add(p);
      }
    } }]), B;
  }(), Zi = function() {
    function B(t) {
      A(this, B), this.w = t.w, this.dCtx = t;
    }
    return F(B, [{ key: "getTitleSubtitleCoords", value: function(t) {
      var n = this.w, i = 0, o = 0, d = t === "title" ? n.config.title.floating : n.config.subtitle.floating, f = n.globals.dom.baseEl.querySelector(".apexcharts-".concat(t, "-text"));
      if (f !== null && !d) {
        var p = f.getBoundingClientRect();
        i = p.width, o = n.globals.axisCharts ? p.height + 5 : p.height;
      }
      return { width: i, height: o };
    } }, { key: "getLegendsRect", value: function() {
      var t = this.w, n = t.globals.dom.elLegendWrap;
      t.config.legend.height || t.config.legend.position !== "top" && t.config.legend.position !== "bottom" || (n.style.maxHeight = t.globals.svgHeight / 2 + "px");
      var i = Object.assign({}, Q.getBoundingClientRect(n));
      return n !== null && !t.config.legend.floating && t.config.legend.show ? this.dCtx.lgRect = { x: i.x, y: i.y, height: i.height, width: i.height === 0 ? 0 : i.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, t.config.legend.position !== "left" && t.config.legend.position !== "right" || 1.5 * this.dCtx.lgRect.width > t.globals.svgWidth && (this.dCtx.lgRect.width = t.globals.svgWidth / 1.5), this.dCtx.lgRect;
    } }, { key: "getLargestStringFromMultiArr", value: function(t, n) {
      var i = t;
      if (this.w.globals.isMultiLineX) {
        var o = n.map(function(f, p) {
          return Array.isArray(f) ? f.length : 1;
        }), d = Math.max.apply(Math, ue(o));
        i = n[o.indexOf(d)];
      }
      return i;
    } }]), B;
  }(), mi = function() {
    function B(t) {
      A(this, B), this.w = t.w, this.dCtx = t;
    }
    return F(B, [{ key: "getxAxisLabelsCoords", value: function() {
      var t, n = this.w, i = n.globals.labels.slice();
      if (n.config.xaxis.convertedCatToNumeric && i.length === 0 && (i = n.globals.categoryLabels), n.globals.timescaleLabels.length > 0) {
        var o = this.getxAxisTimeScaleLabelsCoords();
        t = { width: o.width, height: o.height }, n.globals.rotateXLabels = !1;
      } else {
        this.dCtx.lgWidthForSideLegends = n.config.legend.position !== "left" && n.config.legend.position !== "right" || n.config.legend.floating ? 0 : this.dCtx.lgRect.width;
        var d = n.globals.xLabelFormatter, f = Q.getLargestStringFromArr(i), p = this.dCtx.dimHelpers.getLargestStringFromMultiArr(f, i);
        n.globals.isBarHorizontal && (p = f = n.globals.yAxisScale[0].result.reduce(function(P, I) {
          return P.length > I.length ? P : I;
        }, 0));
        var y = new Ht(this.dCtx.ctx), S = f;
        f = y.xLabelFormat(d, f, S, { i: void 0, dateFormatter: new it(this.dCtx.ctx).formatDate, w: n }), p = y.xLabelFormat(d, p, S, { i: void 0, dateFormatter: new it(this.dCtx.ctx).formatDate, w: n }), (n.config.xaxis.convertedCatToNumeric && f === void 0 || String(f).trim() === "") && (p = f = "1");
        var C = new re(this.dCtx.ctx), E = C.getTextRects(f, n.config.xaxis.labels.style.fontSize), L = E;
        if (f !== p && (L = C.getTextRects(p, n.config.xaxis.labels.style.fontSize)), (t = { width: E.width >= L.width ? E.width : L.width, height: E.height >= L.height ? E.height : L.height }).width * i.length > n.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && n.config.xaxis.labels.rotate !== 0 || n.config.xaxis.labels.rotateAlways) {
          if (!n.globals.isBarHorizontal) {
            n.globals.rotateXLabels = !0;
            var O = function(P) {
              return C.getTextRects(P, n.config.xaxis.labels.style.fontSize, n.config.xaxis.labels.style.fontFamily, "rotate(".concat(n.config.xaxis.labels.rotate, " 0 0)"), !1);
            };
            E = O(f), f !== p && (L = O(p)), t.height = (E.height > L.height ? E.height : L.height) / 1.5, t.width = E.width > L.width ? E.width : L.width;
          }
        } else
          n.globals.rotateXLabels = !1;
      }
      return n.config.xaxis.labels.show || (t = { width: 0, height: 0 }), { width: t.width, height: t.height };
    } }, { key: "getxAxisGroupLabelsCoords", value: function() {
      var t, n = this.w;
      if (!n.globals.hasXaxisGroups)
        return { width: 0, height: 0 };
      var i, o = ((t = n.config.xaxis.group.style) === null || t === void 0 ? void 0 : t.fontSize) || n.config.xaxis.labels.style.fontSize, d = n.globals.groups.map(function(E) {
        return E.title;
      }), f = Q.getLargestStringFromArr(d), p = this.dCtx.dimHelpers.getLargestStringFromMultiArr(f, d), y = new re(this.dCtx.ctx), S = y.getTextRects(f, o), C = S;
      return f !== p && (C = y.getTextRects(p, o)), i = { width: S.width >= C.width ? S.width : C.width, height: S.height >= C.height ? S.height : C.height }, n.config.xaxis.labels.show || (i = { width: 0, height: 0 }), { width: i.width, height: i.height };
    } }, { key: "getxAxisTitleCoords", value: function() {
      var t = this.w, n = 0, i = 0;
      if (t.config.xaxis.title.text !== void 0) {
        var o = new re(this.dCtx.ctx).getTextRects(t.config.xaxis.title.text, t.config.xaxis.title.style.fontSize);
        n = o.width, i = o.height;
      }
      return { width: n, height: i };
    } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
      var t, n = this.w;
      this.dCtx.timescaleLabels = n.globals.timescaleLabels.slice();
      var i = this.dCtx.timescaleLabels.map(function(d) {
        return d.value;
      }), o = i.reduce(function(d, f) {
        return d === void 0 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : d.length > f.length ? d : f;
      }, 0);
      return 1.05 * (t = new re(this.dCtx.ctx).getTextRects(o, n.config.xaxis.labels.style.fontSize)).width * i.length > n.globals.gridWidth && n.config.xaxis.labels.rotate !== 0 && (n.globals.overlappingXLabels = !0), t;
    } }, { key: "additionalPaddingXLabels", value: function(t) {
      var n = this, i = this.w, o = i.globals, d = i.config, f = d.xaxis.type, p = t.width;
      o.skipLastTimelinelabel = !1, o.skipFirstTimelinelabel = !1;
      var y = i.config.yaxis[0].opposite && i.globals.isBarHorizontal, S = function(C, E) {
        d.yaxis.length > 1 && function(L) {
          return o.collapsedSeriesIndices.indexOf(L) !== -1;
        }(E) || function(L) {
          if (n.dCtx.timescaleLabels && n.dCtx.timescaleLabels.length) {
            var O = n.dCtx.timescaleLabels[0], P = n.dCtx.timescaleLabels[n.dCtx.timescaleLabels.length - 1].position + p / 1.75 - n.dCtx.yAxisWidthRight, I = O.position - p / 1.75 + n.dCtx.yAxisWidthLeft, j = i.config.legend.position === "right" && n.dCtx.lgRect.width > 0 ? n.dCtx.lgRect.width : 0;
            P > o.svgWidth - o.translateX - j && (o.skipLastTimelinelabel = !0), I < -(L.show && !L.floating || d.chart.type !== "bar" && d.chart.type !== "candlestick" && d.chart.type !== "rangeBar" && d.chart.type !== "boxPlot" ? 10 : p / 1.75) && (o.skipFirstTimelinelabel = !0);
          } else
            f === "datetime" ? n.dCtx.gridPad.right < p && !o.rotateXLabels && (o.skipLastTimelinelabel = !0) : f !== "datetime" && n.dCtx.gridPad.right < p / 2 - n.dCtx.yAxisWidthRight && !o.rotateXLabels && !i.config.xaxis.labels.trim && (i.config.xaxis.tickPlacement !== "between" || i.globals.isBarHorizontal) && (n.dCtx.xPadRight = p / 2 + 1);
        }(C);
      };
      d.yaxis.forEach(function(C, E) {
        y ? (n.dCtx.gridPad.left < p && (n.dCtx.xPadLeft = p / 2 + 1), n.dCtx.xPadRight = p / 2 + 1) : S(C, E);
      });
    } }]), B;
  }(), da = function() {
    function B(t) {
      A(this, B), this.w = t.w, this.dCtx = t;
    }
    return F(B, [{ key: "getyAxisLabelsCoords", value: function() {
      var t = this, n = this.w, i = [], o = 10, d = new Et(this.dCtx.ctx);
      return n.config.yaxis.map(function(f, p) {
        var y = n.globals.yAxisScale[p], S = 0;
        if (!d.isYAxisHidden(p) && f.labels.show && f.labels.minWidth !== void 0 && (S = f.labels.minWidth), !d.isYAxisHidden(p) && f.labels.show && y.result.length) {
          var C = n.globals.yLabelFormatters[p], E = y.niceMin === Number.MIN_VALUE ? 0 : y.niceMin, L = String(E).length > String(y.niceMax).length ? E : y.niceMax, O = C(L, { seriesIndex: p, dataPointIndex: -1, w: n }), P = O;
          if (O !== void 0 && O.length !== 0 || (O = L), n.globals.isBarHorizontal) {
            o = 0;
            var I = n.globals.labels.slice();
            O = C(O = Q.getLargestStringFromArr(I), { seriesIndex: p, dataPointIndex: -1, w: n }), P = t.dCtx.dimHelpers.getLargestStringFromMultiArr(O, I);
          }
          var j = new re(t.dCtx.ctx), V = "rotate(".concat(f.labels.rotate, " 0 0)"), Z = j.getTextRects(O, f.labels.style.fontSize, f.labels.style.fontFamily, V, !1), b = Z;
          O !== P && (b = j.getTextRects(P, f.labels.style.fontSize, f.labels.style.fontFamily, V, !1)), i.push({ width: (S > b.width || S > Z.width ? S : b.width > Z.width ? b.width : Z.width) + o, height: b.height > Z.height ? b.height : Z.height });
        } else
          i.push({ width: 0, height: 0 });
      }), i;
    } }, { key: "getyAxisTitleCoords", value: function() {
      var t = this, n = this.w, i = [];
      return n.config.yaxis.map(function(o, d) {
        if (o.show && o.title.text !== void 0) {
          var f = new re(t.dCtx.ctx), p = "rotate(".concat(o.title.rotate, " 0 0)"), y = f.getTextRects(o.title.text, o.title.style.fontSize, o.title.style.fontFamily, p, !1);
          i.push({ width: y.width, height: y.height });
        } else
          i.push({ width: 0, height: 0 });
      }), i;
    } }, { key: "getTotalYAxisWidth", value: function() {
      var t = this.w, n = 0, i = 0, o = 0, d = t.globals.yAxisScale.length > 1 ? 10 : 0, f = new Et(this.dCtx.ctx), p = function(y, S) {
        var C = t.config.yaxis[S].floating, E = 0;
        y.width > 0 && !C ? (E = y.width + d, function(L) {
          return t.globals.ignoreYAxisIndexes.indexOf(L) > -1;
        }(S) && (E = E - y.width - d)) : E = C || f.isYAxisHidden(S) ? 0 : 5, t.config.yaxis[S].opposite ? o += E : i += E, n += E;
      };
      return t.globals.yLabelsCoords.map(function(y, S) {
        p(y, S);
      }), t.globals.yTitleCoords.map(function(y, S) {
        p(y, S);
      }), t.globals.isBarHorizontal && !t.config.yaxis[0].floating && (n = t.globals.yLabelsCoords[0].width + t.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i, this.dCtx.yAxisWidthRight = o, n;
    } }]), B;
  }(), yi = function() {
    function B(t) {
      A(this, B), this.w = t.w, this.dCtx = t;
    }
    return F(B, [{ key: "gridPadForColumnsInNumericAxis", value: function(t) {
      var n = this.w;
      if (n.globals.noData || n.globals.allSeriesCollapsed)
        return 0;
      var i = function(C) {
        return C === "bar" || C === "rangeBar" || C === "candlestick" || C === "boxPlot";
      }, o = n.config.chart.type, d = 0, f = i(o) ? n.config.series.length : 1;
      if (n.globals.comboBarCount > 0 && (f = n.globals.comboBarCount), n.globals.collapsedSeries.forEach(function(C) {
        i(C.type) && (f -= 1);
      }), n.config.chart.stacked && (f = 1), (i(o) || n.globals.comboBarCount > 0) && n.globals.isXNumeric && !n.globals.isBarHorizontal && f > 0) {
        var p, y, S = Math.abs(n.globals.initialMaxX - n.globals.initialMinX);
        S <= 3 && (S = n.globals.dataPoints), p = S / t, n.globals.minXDiff && n.globals.minXDiff / p > 0 && (y = n.globals.minXDiff / p), y > t / 2 && (y /= 2), (d = y / f * parseInt(n.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (d = 1), d = d / (f > 1 ? 1 : 1.5) + 5, n.globals.barPadForNumericAxis = d;
      }
      return d;
    } }, { key: "gridPadFortitleSubtitle", value: function() {
      var t = this, n = this.w, i = n.globals, o = this.dCtx.isSparkline || !n.globals.axisCharts ? 0 : 10;
      ["title", "subtitle"].forEach(function(p) {
        n.config[p].text !== void 0 ? o += n.config[p].margin : o += t.dCtx.isSparkline || !n.globals.axisCharts ? 0 : 5;
      }), !n.config.legend.show || n.config.legend.position !== "bottom" || n.config.legend.floating || n.globals.axisCharts || (o += 10);
      var d = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), f = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
      i.gridHeight = i.gridHeight - d.height - f.height - o, i.translateY = i.translateY + d.height + f.height + o;
    } }, { key: "setGridXPosForDualYAxis", value: function(t, n) {
      var i = this.w, o = new Et(this.dCtx.ctx);
      i.config.yaxis.map(function(d, f) {
        i.globals.ignoreYAxisIndexes.indexOf(f) !== -1 || d.floating || o.isYAxisHidden(f) || (d.opposite && (i.globals.translateX = i.globals.translateX - (n[f].width + t[f].width) - parseInt(i.config.yaxis[f].labels.style.fontSize, 10) / 1.2 - 12), i.globals.translateX < 2 && (i.globals.translateX = 2));
      });
    } }]), B;
  }(), ti = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new Zi(this), this.dimYAxis = new da(this), this.dimXAxis = new mi(this), this.dimGrid = new yi(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
    }
    return F(B, [{ key: "plotCoords", value: function() {
      var t = this, n = this.w, i = n.globals;
      this.lgRect = this.dimHelpers.getLegendsRect(), this.isSparkline && (n.config.markers.discrete.length > 0 || n.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(d) {
        var f = ae(d, 2), p = f[0], y = f[1];
        t.gridPad[p] = Math.max(y, t.w.globals.markers.largestSize / 1.5);
      }), i.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i.gridHeight = i.gridHeight - this.gridPad.top - this.gridPad.bottom, i.gridWidth = i.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
      var o = this.dimGrid.gridPadForColumnsInNumericAxis(i.gridWidth);
      i.gridWidth = i.gridWidth - 2 * o, i.translateX = i.translateX + this.gridPad.left + this.xPadLeft + (o > 0 ? o + 4 : 0), i.translateY = i.translateY + this.gridPad.top;
    } }, { key: "setDimensionsForAxisCharts", value: function() {
      var t = this, n = this.w, i = n.globals, o = this.dimYAxis.getyAxisLabelsCoords(), d = this.dimYAxis.getyAxisTitleCoords();
      n.globals.yLabelsCoords = [], n.globals.yTitleCoords = [], n.config.yaxis.map(function(O, P) {
        n.globals.yLabelsCoords.push({ width: o[P].width, index: P }), n.globals.yTitleCoords.push({ width: d[P].width, index: P });
      }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
      var f = this.dimXAxis.getxAxisLabelsCoords(), p = this.dimXAxis.getxAxisGroupLabelsCoords(), y = this.dimXAxis.getxAxisTitleCoords();
      this.conditionalChecksForAxisCoords(f, y, p), i.translateXAxisY = n.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i.translateXAxisX = n.globals.rotateXLabels && n.globals.isXNumeric && n.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, n.globals.isBarHorizontal && (i.rotateXLabels = !1, i.translateXAxisY = parseInt(n.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i.translateXAxisY = i.translateXAxisY + n.config.xaxis.labels.offsetY, i.translateXAxisX = i.translateXAxisX + n.config.xaxis.labels.offsetX;
      var S = this.yAxisWidth, C = this.xAxisHeight;
      i.xAxisLabelsHeight = this.xAxisHeight - y.height, i.xAxisGroupLabelsHeight = i.xAxisLabelsHeight - f.height, i.xAxisLabelsWidth = this.xAxisWidth, i.xAxisHeight = this.xAxisHeight;
      var E = 10;
      (n.config.chart.type === "radar" || this.isSparkline) && (S = 0, C = i.goldenPadding), this.isSparkline && (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || n.config.chart.type === "treemap") && (S = 0, C = 0, E = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(f);
      var L = function() {
        i.translateX = S, i.gridHeight = i.svgHeight - t.lgRect.height - C - (t.isSparkline || n.config.chart.type === "treemap" ? 0 : n.globals.rotateXLabels ? 10 : 15), i.gridWidth = i.svgWidth - S;
      };
      switch (n.config.xaxis.position === "top" && (E = i.xAxisHeight - n.config.xaxis.axisTicks.height - 5), n.config.legend.position) {
        case "bottom":
          i.translateY = E, L();
          break;
        case "top":
          i.translateY = this.lgRect.height + E, L();
          break;
        case "left":
          i.translateY = E, i.translateX = this.lgRect.width + S, i.gridHeight = i.svgHeight - C - 12, i.gridWidth = i.svgWidth - this.lgRect.width - S;
          break;
        case "right":
          i.translateY = E, i.translateX = S, i.gridHeight = i.svgHeight - C - 12, i.gridWidth = i.svgWidth - this.lgRect.width - S - 5;
          break;
        default:
          throw new Error("Legend position not supported");
      }
      this.dimGrid.setGridXPosForDualYAxis(d, o), new jn(this.ctx).setYAxisXPosition(o, d);
    } }, { key: "setDimensionsForNonAxisCharts", value: function() {
      var t = this.w, n = t.globals, i = t.config, o = 0;
      t.config.legend.show && !t.config.legend.floating && (o = 20);
      var d = i.chart.type === "pie" || i.chart.type === "polarArea" || i.chart.type === "donut" ? "pie" : "radialBar", f = i.plotOptions[d].offsetY, p = i.plotOptions[d].offsetX;
      if (!i.legend.show || i.legend.floating)
        return n.gridHeight = n.svgHeight - i.grid.padding.left + i.grid.padding.right, n.gridWidth = n.gridHeight, n.translateY = f, void (n.translateX = p + (n.svgWidth - n.gridWidth) / 2);
      switch (i.legend.position) {
        case "bottom":
          n.gridHeight = n.svgHeight - this.lgRect.height - n.goldenPadding, n.gridWidth = n.svgWidth, n.translateY = f - 10, n.translateX = p + (n.svgWidth - n.gridWidth) / 2;
          break;
        case "top":
          n.gridHeight = n.svgHeight - this.lgRect.height - n.goldenPadding, n.gridWidth = n.svgWidth, n.translateY = this.lgRect.height + f + 10, n.translateX = p + (n.svgWidth - n.gridWidth) / 2;
          break;
        case "left":
          n.gridWidth = n.svgWidth - this.lgRect.width - o, n.gridHeight = i.chart.height !== "auto" ? n.svgHeight : n.gridWidth, n.translateY = f, n.translateX = p + this.lgRect.width + o;
          break;
        case "right":
          n.gridWidth = n.svgWidth - this.lgRect.width - o - 5, n.gridHeight = i.chart.height !== "auto" ? n.svgHeight : n.gridWidth, n.translateY = f, n.translateX = p + 10;
          break;
        default:
          throw new Error("Legend position not supported");
      }
    } }, { key: "conditionalChecksForAxisCoords", value: function(t, n, i) {
      var o = this.w, d = o.globals.hasXaxisGroups ? 2 : 1, f = i.height + t.height + n.height, p = o.globals.isMultiLineX ? 1.2 : o.globals.LINE_HEIGHT_RATIO, y = o.globals.rotateXLabels ? 22 : 10, S = o.globals.rotateXLabels && o.config.legend.position === "bottom" ? 10 : 0;
      this.xAxisHeight = f * p + d * y + S, this.xAxisWidth = t.width, this.xAxisHeight - n.height > o.config.xaxis.labels.maxHeight && (this.xAxisHeight = o.config.xaxis.labels.maxHeight), o.config.xaxis.labels.minHeight && this.xAxisHeight < o.config.xaxis.labels.minHeight && (this.xAxisHeight = o.config.xaxis.labels.minHeight), o.config.xaxis.floating && (this.xAxisHeight = 0);
      var C = 0, E = 0;
      o.config.yaxis.forEach(function(L) {
        C += L.labels.minWidth, E += L.labels.maxWidth;
      }), this.yAxisWidth < C && (this.yAxisWidth = C), this.yAxisWidth > E && (this.yAxisWidth = E);
    } }]), B;
  }(), ir = function() {
    function B(t) {
      A(this, B), this.w = t.w, this.lgCtx = t;
    }
    return F(B, [{ key: "getLegendStyles", value: function() {
      var t = document.createElement("style");
      t.setAttribute("type", "text/css");
      var n = document.createTextNode(`	
    	
      .apexcharts-legend {	
        display: flex;	
        overflow: auto;	
        padding: 0 10px;	
      }	
      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {	
        flex-wrap: wrap	
      }	
      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {	
        flex-direction: column;	
        bottom: 0;	
      }	
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {	
        justify-content: flex-start;	
      }	
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {	
        justify-content: center;  	
      }	
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {	
        justify-content: flex-end;	
      }	
      .apexcharts-legend-series {	
        cursor: pointer;	
        line-height: normal;	
      }	
      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{	
        display: flex;	
        align-items: center;	
      }	
      .apexcharts-legend-text {	
        position: relative;	
        font-size: 14px;	
      }	
      .apexcharts-legend-text *, .apexcharts-legend-marker * {	
        pointer-events: none;	
      }	
      .apexcharts-legend-marker {	
        position: relative;	
        display: inline-block;	
        cursor: pointer;	
        margin-right: 3px;	
        border-style: solid;
      }	
      	
      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{	
        display: inline-block;	
      }	
      .apexcharts-legend-series.apexcharts-no-click {	
        cursor: auto;	
      }	
      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {	
        display: none !important;	
      }	
      .apexcharts-inactive-legend {	
        opacity: 0.45;	
      }`);
      return t.appendChild(n), t;
    } }, { key: "getLegendBBox", value: function() {
      var t = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), n = t.width;
      return { clwh: t.height, clww: n };
    } }, { key: "appendToForeignObject", value: function() {
      this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
    } }, { key: "toggleDataSeries", value: function(t, n) {
      var i = this, o = this.w;
      if (o.globals.axisCharts || o.config.chart.type === "radialBar") {
        o.globals.resized = !0;
        var d = null, f = null;
        o.globals.risingSeries = [], o.globals.axisCharts ? (d = o.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "']")), f = parseInt(d.getAttribute("data:realIndex"), 10)) : (d = o.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t + 1, "']")), f = parseInt(d.getAttribute("rel"), 10) - 1), n ? [{ cs: o.globals.collapsedSeries, csi: o.globals.collapsedSeriesIndices }, { cs: o.globals.ancillaryCollapsedSeries, csi: o.globals.ancillaryCollapsedSeriesIndices }].forEach(function(C) {
          i.riseCollapsedSeries(C.cs, C.csi, f);
        }) : this.hideSeries({ seriesEl: d, realIndex: f });
      } else {
        var p = o.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t + 1, "'] path")), y = o.config.chart.type;
        if (y === "pie" || y === "polarArea" || y === "donut") {
          var S = o.config.plotOptions.pie.donut.labels;
          new re(this.lgCtx.ctx).pathMouseDown(p.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(p.members[0].node, S);
        }
        p.fire("click");
      }
    } }, { key: "hideSeries", value: function(t) {
      var n = t.seriesEl, i = t.realIndex, o = this.w, d = Q.clone(o.config.series);
      if (o.globals.axisCharts) {
        var f = !1;
        if (o.config.yaxis[i] && o.config.yaxis[i].show && o.config.yaxis[i].showAlways && (f = !0, o.globals.ancillaryCollapsedSeriesIndices.indexOf(i) < 0 && (o.globals.ancillaryCollapsedSeries.push({ index: i, data: d[i].data.slice(), type: n.parentNode.className.baseVal.split("-")[1] }), o.globals.ancillaryCollapsedSeriesIndices.push(i))), !f) {
          o.globals.collapsedSeries.push({ index: i, data: d[i].data.slice(), type: n.parentNode.className.baseVal.split("-")[1] }), o.globals.collapsedSeriesIndices.push(i);
          var p = o.globals.risingSeries.indexOf(i);
          o.globals.risingSeries.splice(p, 1);
        }
      } else
        o.globals.collapsedSeries.push({ index: i, data: d[i] }), o.globals.collapsedSeriesIndices.push(i);
      for (var y = n.childNodes, S = 0; S < y.length; S++)
        y[S].classList.contains("apexcharts-series-markers-wrap") && (y[S].classList.contains("apexcharts-hide") ? y[S].classList.remove("apexcharts-hide") : y[S].classList.add("apexcharts-hide"));
      o.globals.allSeriesCollapsed = o.globals.collapsedSeries.length === o.config.series.length, d = this._getSeriesBasedOnCollapsedState(d), this.lgCtx.ctx.updateHelpers._updateSeries(d, o.config.chart.animations.dynamicAnimation.enabled);
    } }, { key: "riseCollapsedSeries", value: function(t, n, i) {
      var o = this.w, d = Q.clone(o.config.series);
      if (t.length > 0) {
        for (var f = 0; f < t.length; f++)
          t[f].index === i && (o.globals.axisCharts ? (d[i].data = t[f].data.slice(), t.splice(f, 1), n.splice(f, 1), o.globals.risingSeries.push(i)) : (d[i] = t[f].data, t.splice(f, 1), n.splice(f, 1), o.globals.risingSeries.push(i)));
        d = this._getSeriesBasedOnCollapsedState(d), this.lgCtx.ctx.updateHelpers._updateSeries(d, o.config.chart.animations.dynamicAnimation.enabled);
      }
    } }, { key: "_getSeriesBasedOnCollapsedState", value: function(t) {
      var n = this.w;
      return n.globals.axisCharts ? t.forEach(function(i, o) {
        n.globals.collapsedSeriesIndices.indexOf(o) > -1 && (t[o].data = []);
      }) : t.forEach(function(i, o) {
        n.globals.collapsedSeriesIndices.indexOf(o) > -1 && (t[o] = 0);
      }), t;
    } }]), B;
  }(), ni = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = this.w.config.chart.type === "bar" && this.w.config.plotOptions.bar.distributed && this.w.config.series.length === 1, this.legendHelpers = new ir(this);
    }
    return F(B, [{ key: "init", value: function() {
      var t = this.w, n = t.globals, i = t.config;
      if ((i.legend.showForSingleSeries && n.series.length === 1 || this.isBarsDistributed || n.series.length > 1 || !n.axisCharts) && i.legend.show) {
        for (; n.dom.elLegendWrap.firstChild; )
          n.dom.elLegendWrap.removeChild(n.dom.elLegendWrap.firstChild);
        this.drawLegends(), Q.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), i.legend.position === "bottom" || i.legend.position === "top" ? this.legendAlignHorizontal() : i.legend.position !== "right" && i.legend.position !== "left" || this.legendAlignVertical();
      }
    } }, { key: "drawLegends", value: function() {
      var t = this, n = this.w, i = n.config.legend.fontFamily, o = n.globals.seriesNames, d = n.globals.colors.slice();
      if (n.config.chart.type === "heatmap") {
        var f = n.config.plotOptions.heatmap.colorScale.ranges;
        o = f.map(function(Me) {
          return Me.name ? Me.name : Me.from + " - " + Me.to;
        }), d = f.map(function(Me) {
          return Me.color;
        });
      } else
        this.isBarsDistributed && (o = n.globals.labels.slice());
      n.config.legend.customLegendItems.length && (o = n.config.legend.customLegendItems);
      for (var p = n.globals.legendFormatter, y = n.config.legend.inverseOrder, S = y ? o.length - 1 : 0; y ? S >= 0 : S <= o.length - 1; y ? S-- : S++) {
        var C, E = p(o[S], { seriesIndex: S, w: n }), L = !1, O = !1;
        if (n.globals.collapsedSeries.length > 0)
          for (var P = 0; P < n.globals.collapsedSeries.length; P++)
            n.globals.collapsedSeries[P].index === S && (L = !0);
        if (n.globals.ancillaryCollapsedSeriesIndices.length > 0)
          for (var I = 0; I < n.globals.ancillaryCollapsedSeriesIndices.length; I++)
            n.globals.ancillaryCollapsedSeriesIndices[I] === S && (O = !0);
        var j = document.createElement("span");
        j.classList.add("apexcharts-legend-marker");
        var V = n.config.legend.markers.offsetX, Z = n.config.legend.markers.offsetY, b = n.config.legend.markers.height, M = n.config.legend.markers.width, N = n.config.legend.markers.strokeWidth, X = n.config.legend.markers.strokeColor, K = n.config.legend.markers.radius, ee = j.style;
        ee.background = d[S], ee.color = d[S], ee.setProperty("background", d[S], "important"), n.config.legend.markers.fillColors && n.config.legend.markers.fillColors[S] && (ee.background = n.config.legend.markers.fillColors[S]), n.globals.seriesColors[S] !== void 0 && (ee.background = n.globals.seriesColors[S], ee.color = n.globals.seriesColors[S]), ee.height = Array.isArray(b) ? parseFloat(b[S]) + "px" : parseFloat(b) + "px", ee.width = Array.isArray(M) ? parseFloat(M[S]) + "px" : parseFloat(M) + "px", ee.left = (Array.isArray(V) ? parseFloat(V[S]) : parseFloat(V)) + "px", ee.top = (Array.isArray(Z) ? parseFloat(Z[S]) : parseFloat(Z)) + "px", ee.borderWidth = Array.isArray(N) ? N[S] : N, ee.borderColor = Array.isArray(X) ? X[S] : X, ee.borderRadius = Array.isArray(K) ? parseFloat(K[S]) + "px" : parseFloat(K) + "px", n.config.legend.markers.customHTML && (Array.isArray(n.config.legend.markers.customHTML) ? n.config.legend.markers.customHTML[S] && (j.innerHTML = n.config.legend.markers.customHTML[S]()) : j.innerHTML = n.config.legend.markers.customHTML()), re.setAttrs(j, { rel: S + 1, "data:collapsed": L || O }), (L || O) && j.classList.add("apexcharts-inactive-legend");
        var oe = document.createElement("div"), de = document.createElement("span");
        de.classList.add("apexcharts-legend-text"), de.innerHTML = Array.isArray(E) ? E.join(" ") : E;
        var ke = n.config.legend.labels.useSeriesColors ? n.globals.colors[S] : Array.isArray(n.config.legend.labels.colors) ? (C = n.config.legend.labels.colors) === null || C === void 0 ? void 0 : C[S] : n.config.legend.labels.colors;
        ke || (ke = n.config.chart.foreColor), de.style.color = ke, de.style.fontSize = parseFloat(n.config.legend.fontSize) + "px", de.style.fontWeight = n.config.legend.fontWeight, de.style.fontFamily = i || n.config.chart.fontFamily, re.setAttrs(de, { rel: S + 1, i: S, "data:default-text": encodeURIComponent(E), "data:collapsed": L || O }), oe.appendChild(j), oe.appendChild(de);
        var _e = new ve(this.ctx);
        n.config.legend.showForZeroSeries || _e.getSeriesTotalByIndex(S) === 0 && _e.seriesHaveSameValues(S) && !_e.isSeriesNull(S) && n.globals.collapsedSeriesIndices.indexOf(S) === -1 && n.globals.ancillaryCollapsedSeriesIndices.indexOf(S) === -1 && oe.classList.add("apexcharts-hidden-zero-series"), n.config.legend.showForNullSeries || _e.isSeriesNull(S) && n.globals.collapsedSeriesIndices.indexOf(S) === -1 && n.globals.ancillaryCollapsedSeriesIndices.indexOf(S) === -1 && oe.classList.add("apexcharts-hidden-null-series"), n.globals.dom.elLegendWrap.appendChild(oe), n.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(n.config.legend.horizontalAlign)), n.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + n.config.legend.position), oe.classList.add("apexcharts-legend-series"), oe.style.margin = "".concat(n.config.legend.itemMargin.vertical, "px ").concat(n.config.legend.itemMargin.horizontal, "px"), n.globals.dom.elLegendWrap.style.width = n.config.legend.width ? n.config.legend.width + "px" : "", n.globals.dom.elLegendWrap.style.height = n.config.legend.height ? n.config.legend.height + "px" : "", re.setAttrs(oe, { rel: S + 1, seriesName: Q.escapeString(o[S]), "data:collapsed": L || O }), (L || O) && oe.classList.add("apexcharts-inactive-legend"), n.config.legend.onItemClick.toggleDataSeries || oe.classList.add("apexcharts-no-click");
      }
      n.globals.dom.elWrap.addEventListener("click", t.onLegendClick, !0), n.config.legend.onItemHover.highlightDataSeries && n.config.legend.customLegendItems.length === 0 && (n.globals.dom.elWrap.addEventListener("mousemove", t.onLegendHovered, !0), n.globals.dom.elWrap.addEventListener("mouseout", t.onLegendHovered, !0));
    } }, { key: "setLegendWrapXY", value: function(t, n) {
      var i = this.w, o = i.globals.dom.elLegendWrap, d = o.getBoundingClientRect(), f = 0, p = 0;
      if (i.config.legend.position === "bottom")
        p += i.globals.svgHeight - d.height / 2;
      else if (i.config.legend.position === "top") {
        var y = new ti(this.ctx), S = y.dimHelpers.getTitleSubtitleCoords("title").height, C = y.dimHelpers.getTitleSubtitleCoords("subtitle").height;
        p = p + (S > 0 ? S - 10 : 0) + (C > 0 ? C - 10 : 0);
      }
      o.style.position = "absolute", f = f + t + i.config.legend.offsetX, p = p + n + i.config.legend.offsetY, o.style.left = f + "px", o.style.top = p + "px", i.config.legend.position === "bottom" ? (o.style.top = "auto", o.style.bottom = 5 - i.config.legend.offsetY + "px") : i.config.legend.position === "right" && (o.style.left = "auto", o.style.right = 25 + i.config.legend.offsetX + "px"), ["width", "height"].forEach(function(E) {
        o.style[E] && (o.style[E] = parseInt(i.config.legend[E], 10) + "px");
      });
    } }, { key: "legendAlignHorizontal", value: function() {
      var t = this.w;
      t.globals.dom.elLegendWrap.style.right = 0;
      var n = this.legendHelpers.getLegendBBox(), i = new ti(this.ctx), o = i.dimHelpers.getTitleSubtitleCoords("title"), d = i.dimHelpers.getTitleSubtitleCoords("subtitle"), f = 0;
      t.config.legend.position === "bottom" ? f = -n.clwh / 1.8 : t.config.legend.position === "top" && (f = o.height + d.height + t.config.title.margin + t.config.subtitle.margin - 10), this.setLegendWrapXY(20, f);
    } }, { key: "legendAlignVertical", value: function() {
      var t = this.w, n = this.legendHelpers.getLegendBBox(), i = 0;
      t.config.legend.position === "left" && (i = 20), t.config.legend.position === "right" && (i = t.globals.svgWidth - n.clww - 10), this.setLegendWrapXY(i, 20);
    } }, { key: "onLegendHovered", value: function(t) {
      var n = this.w, i = t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker");
      if (n.config.chart.type === "heatmap" || this.isBarsDistributed) {
        if (i) {
          var o = parseInt(t.target.getAttribute("rel"), 10) - 1;
          this.ctx.events.fireEvent("legendHover", [this.ctx, o, this.w]), new ot(this.ctx).highlightRangeInSeries(t, t.target);
        }
      } else
        !t.target.classList.contains("apexcharts-inactive-legend") && i && new ot(this.ctx).toggleSeriesOnHover(t, t.target);
    } }, { key: "onLegendClick", value: function(t) {
      var n = this.w;
      if (!n.config.legend.customLegendItems.length && (t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker"))) {
        var i = parseInt(t.target.getAttribute("rel"), 10) - 1, o = t.target.getAttribute("data:collapsed") === "true", d = this.w.config.chart.events.legendClick;
        typeof d == "function" && d(this.ctx, i, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i, this.w]);
        var f = this.w.config.legend.markers.onClick;
        typeof f == "function" && t.target.classList.contains("apexcharts-legend-marker") && (f(this.ctx, i, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i, this.w])), n.config.chart.type !== "treemap" && n.config.chart.type !== "heatmap" && !this.isBarsDistributed && n.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i, o);
      }
    } }]), B;
  }(), _a = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
      var n = this.w;
      this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = n.globals.minX, this.maxX = n.globals.maxX;
    }
    return F(B, [{ key: "createToolbar", value: function() {
      var t = this, n = this.w, i = function() {
        return document.createElement("div");
      }, o = i();
      if (o.setAttribute("class", "apexcharts-toolbar"), o.style.top = n.config.chart.toolbar.offsetY + "px", o.style.right = 3 - n.config.chart.toolbar.offsetX + "px", n.globals.dom.elWrap.appendChild(o), this.elZoom = i(), this.elZoomIn = i(), this.elZoomOut = i(), this.elPan = i(), this.elSelection = i(), this.elZoomReset = i(), this.elMenuIcon = i(), this.elMenu = i(), this.elCustomIcons = [], this.t = n.config.chart.toolbar.tools, Array.isArray(this.t.customIcons))
        for (var d = 0; d < this.t.customIcons.length; d++)
          this.elCustomIcons.push(i());
      var f = [], p = function(E, L, O) {
        var P = E.toLowerCase();
        t.t[P] && n.config.chart.zoom.enabled && f.push({ el: L, icon: typeof t.t[P] == "string" ? t.t[P] : O, title: t.localeValues[E], class: "apexcharts-".concat(P, "-icon") });
      };
      p("zoomIn", this.elZoomIn, `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
</svg>
`), p("zoomOut", this.elZoomOut, `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
</svg>
`);
      var y = function(E) {
        t.t[E] && n.config.chart[E].enabled && f.push({ el: E === "zoom" ? t.elZoom : t.elSelection, icon: typeof t.t[E] == "string" ? t.t[E] : E === "zoom" ? `<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0V0z" fill="none"/>
    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>
</svg>` : `<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>
</svg>`, title: t.localeValues[E === "zoom" ? "selectionZoom" : "selection"], class: n.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(E, "-icon") });
      };
      y("zoom"), y("selection"), this.t.pan && n.config.chart.zoom.enabled && f.push({ el: this.elPan, icon: typeof this.t.pan == "string" ? this.t.pan : `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">
    <defs>
        <path d="M0 0h24v24H0z" id="a"/>
    </defs>
    <clipPath id="b">
        <use overflow="visible" xlink:href="#a"/>
    </clipPath>
    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>
</svg>`, title: this.localeValues.pan, class: n.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon" }), p("reset", this.elZoomReset, `<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`), this.t.download && f.push({ el: this.elMenuIcon, icon: typeof this.t.download == "string" ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: "apexcharts-menu-icon" });
      for (var S = 0; S < this.elCustomIcons.length; S++)
        f.push({ el: this.elCustomIcons[S], icon: this.t.customIcons[S].icon, title: this.t.customIcons[S].title, index: this.t.customIcons[S].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[S].class });
      f.forEach(function(E, L) {
        E.index && Q.moveIndexInArray(f, L, E.index);
      });
      for (var C = 0; C < f.length; C++)
        re.setAttrs(f[C].el, { class: f[C].class, title: f[C].title }), f[C].el.innerHTML = f[C].icon, o.appendChild(f[C].el);
      this._createHamburgerMenu(o), n.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : n.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : n.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
    } }, { key: "_createHamburgerMenu", value: function(t) {
      this.elMenuItems = [], t.appendChild(this.elMenu), re.setAttrs(this.elMenu, { class: "apexcharts-menu" });
      var n = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }, { name: "exportCSV", title: this.localeValues.exportToCSV }];
      this.w.globals.allSeriesHasEqualX || n.splice(2, 1);
      for (var i = 0; i < n.length; i++)
        this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i].innerHTML = n[i].title, re.setAttrs(this.elMenuItems[i], { class: "apexcharts-menu-item ".concat(n[i].name), title: n[i].title }), this.elMenu.appendChild(this.elMenuItems[i]);
    } }, { key: "addToolbarEventListeners", value: function() {
      var t = this;
      this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(i) {
        i.classList.contains("exportSVG") ? i.addEventListener("click", t.handleDownload.bind(t, "svg")) : i.classList.contains("exportPNG") ? i.addEventListener("click", t.handleDownload.bind(t, "png")) : i.classList.contains("exportCSV") && i.addEventListener("click", t.handleDownload.bind(t, "csv"));
      });
      for (var n = 0; n < this.t.customIcons.length; n++)
        this.elCustomIcons[n].addEventListener("click", this.t.customIcons[n].click.bind(this, this.ctx, this.ctx.w));
    } }, { key: "toggleZoomSelection", value: function(t) {
      this.ctx.getSyncedCharts().forEach(function(n) {
        n.ctx.toolbar.toggleOtherControls();
        var i = t === "selection" ? n.ctx.toolbar.elSelection : n.ctx.toolbar.elZoom, o = t === "selection" ? "selectionEnabled" : "zoomEnabled";
        n.w.globals[o] = !n.w.globals[o], i.classList.contains(n.ctx.toolbar.selectedClass) ? i.classList.remove(n.ctx.toolbar.selectedClass) : i.classList.add(n.ctx.toolbar.selectedClass);
      });
    } }, { key: "getToolbarIconsReference", value: function() {
      var t = this.w;
      this.elZoom || (this.elZoom = t.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
    } }, { key: "enableZoomPanFromToolbar", value: function(t) {
      this.toggleOtherControls(), t === "pan" ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
      var n = t === "pan" ? this.elPan : this.elZoom, i = t === "pan" ? this.elZoom : this.elPan;
      n && n.classList.add(this.selectedClass), i && i.classList.remove(this.selectedClass);
    } }, { key: "togglePanning", value: function() {
      this.ctx.getSyncedCharts().forEach(function(t) {
        t.ctx.toolbar.toggleOtherControls(), t.w.globals.panEnabled = !t.w.globals.panEnabled, t.ctx.toolbar.elPan.classList.contains(t.ctx.toolbar.selectedClass) ? t.ctx.toolbar.elPan.classList.remove(t.ctx.toolbar.selectedClass) : t.ctx.toolbar.elPan.classList.add(t.ctx.toolbar.selectedClass);
      });
    } }, { key: "toggleOtherControls", value: function() {
      var t = this, n = this.w;
      n.globals.panEnabled = !1, n.globals.zoomEnabled = !1, n.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(i) {
        i && i.classList.remove(t.selectedClass);
      });
    } }, { key: "handleZoomIn", value: function() {
      var t = this.w;
      t.globals.isRangeBar && (this.minX = t.globals.minY, this.maxX = t.globals.maxY);
      var n = (this.minX + this.maxX) / 2, i = (this.minX + n) / 2, o = (this.maxX + n) / 2, d = this._getNewMinXMaxX(i, o);
      t.globals.disableZoomIn || this.zoomUpdateOptions(d.minX, d.maxX);
    } }, { key: "handleZoomOut", value: function() {
      var t = this.w;
      if (t.globals.isRangeBar && (this.minX = t.globals.minY, this.maxX = t.globals.maxY), !(t.config.xaxis.type === "datetime" && new Date(this.minX).getUTCFullYear() < 1e3)) {
        var n = (this.minX + this.maxX) / 2, i = this.minX - (n - this.minX), o = this.maxX - (n - this.maxX), d = this._getNewMinXMaxX(i, o);
        t.globals.disableZoomOut || this.zoomUpdateOptions(d.minX, d.maxX);
      }
    } }, { key: "_getNewMinXMaxX", value: function(t, n) {
      var i = this.w.config.xaxis.convertedCatToNumeric;
      return { minX: i ? Math.floor(t) : t, maxX: i ? Math.floor(n) : n };
    } }, { key: "zoomUpdateOptions", value: function(t, n) {
      var i = this.w;
      if (t !== void 0 || n !== void 0) {
        if (!(i.config.xaxis.convertedCatToNumeric && (t < 1 && (t = 1, n = i.globals.dataPoints), n - t < 2))) {
          var o = { min: t, max: n }, d = this.getBeforeZoomRange(o);
          d && (o = d.xaxis);
          var f = { xaxis: o }, p = Q.clone(i.globals.initialConfig.yaxis);
          i.config.chart.zoom.autoScaleYaxis && (p = new Ze(this.ctx).autoScaleY(this.ctx, p, { xaxis: o })), i.config.chart.group || (f.yaxis = p), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(f, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(o, p);
        }
      } else
        this.handleZoomReset();
    } }, { key: "zoomCallback", value: function(t, n) {
      typeof this.ev.zoomed == "function" && this.ev.zoomed(this.ctx, { xaxis: t, yaxis: n });
    } }, { key: "getBeforeZoomRange", value: function(t, n) {
      var i = null;
      return typeof this.ev.beforeZoom == "function" && (i = this.ev.beforeZoom(this, { xaxis: t, yaxis: n })), i;
    } }, { key: "toggleMenu", value: function() {
      var t = this;
      window.setTimeout(function() {
        t.elMenu.classList.contains("apexcharts-menu-open") ? t.elMenu.classList.remove("apexcharts-menu-open") : t.elMenu.classList.add("apexcharts-menu-open");
      }, 0);
    } }, { key: "handleDownload", value: function(t) {
      var n = this.w, i = new Ut(this.ctx);
      switch (t) {
        case "svg":
          i.exportToSVG(this.ctx);
          break;
        case "png":
          i.exportToPng(this.ctx);
          break;
        case "csv":
          i.exportToCSV({ series: n.config.series, columnDelimiter: n.config.chart.toolbar.export.csv.columnDelimiter });
      }
    } }, { key: "handleZoomReset", value: function(t) {
      this.ctx.getSyncedCharts().forEach(function(n) {
        var i = n.w;
        if (i.globals.lastXAxis.min = void 0, i.globals.lastXAxis.max = void 0, n.updateHelpers.revertDefaultAxisMinMax(), typeof i.config.chart.events.beforeResetZoom == "function") {
          var o = i.config.chart.events.beforeResetZoom(n, i);
          o && n.updateHelpers.revertDefaultAxisMinMax(o);
        }
        typeof i.config.chart.events.zoomed == "function" && n.ctx.toolbar.zoomCallback({ min: i.config.xaxis.min, max: i.config.xaxis.max }), i.globals.zoomed = !1;
        var d = n.ctx.series.emptyCollapsedSeries(Q.clone(i.globals.initialSeries));
        n.updateHelpers._updateSeries(d, i.config.chart.animations.dynamicAnimation.enabled);
      });
    } }, { key: "destroy", value: function() {
      this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
    } }]), B;
  }(), Qi = function(B) {
    U(n, _a);
    var t = se(n);
    function n(i) {
      var o;
      return A(this, n), (o = t.call(this, i)).ctx = i, o.w = i.w, o.dragged = !1, o.graphics = new re(o.ctx), o.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], o.clientX = 0, o.clientY = 0, o.startX = 0, o.endX = 0, o.dragX = 0, o.startY = 0, o.endY = 0, o.dragY = 0, o.moveDirection = "none", o;
    }
    return F(n, [{ key: "init", value: function(i) {
      var o = this, d = i.xyRatios, f = this.w, p = this;
      this.xyRatios = d, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = f.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), f.globals.dom.elGraphical.add(this.zoomRect), f.globals.dom.elGraphical.add(this.selectionRect), f.config.chart.selection.type === "x" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: f.globals.gridWidth, maxY: f.globals.gridHeight }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : f.config.chart.selection.type === "y" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: f.globals.gridWidth }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = f.globals.dom.baseEl.querySelector("".concat(f.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(y) {
        o.hoverArea.addEventListener(y, p.svgMouseEvents.bind(p, d), { capture: !1, passive: !0 });
      });
    } }, { key: "destroy", value: function() {
      this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
    } }, { key: "svgMouseEvents", value: function(i, o) {
      var d = this.w, f = this, p = this.ctx.toolbar, y = d.globals.zoomEnabled ? d.config.chart.zoom.type : d.config.chart.selection.type, S = d.config.chart.toolbar.autoSelected;
      if (o.shiftKey ? (this.shiftWasPressed = !0, p.enableZoomPanFromToolbar(S === "pan" ? "zoom" : "pan")) : this.shiftWasPressed && (p.enableZoomPanFromToolbar(S), this.shiftWasPressed = !1), o.target) {
        var C, E = o.target.classList;
        if (o.target.parentNode && o.target.parentNode !== null && (C = o.target.parentNode.classList), !(E.contains("apexcharts-selection-rect") || E.contains("apexcharts-legend-marker") || E.contains("apexcharts-legend-text") || C && C.contains("apexcharts-toolbar"))) {
          if (f.clientX = o.type === "touchmove" || o.type === "touchstart" ? o.touches[0].clientX : o.type === "touchend" ? o.changedTouches[0].clientX : o.clientX, f.clientY = o.type === "touchmove" || o.type === "touchstart" ? o.touches[0].clientY : o.type === "touchend" ? o.changedTouches[0].clientY : o.clientY, o.type === "mousedown" && o.which === 1) {
            var L = f.gridRect.getBoundingClientRect();
            f.startX = f.clientX - L.left, f.startY = f.clientY - L.top, f.dragged = !1, f.w.globals.mousedown = !0;
          }
          if ((o.type === "mousemove" && o.which === 1 || o.type === "touchmove") && (f.dragged = !0, d.globals.panEnabled ? (d.globals.selection = null, f.w.globals.mousedown && f.panDragging({ context: f, zoomtype: y, xyRatios: i })) : (f.w.globals.mousedown && d.globals.zoomEnabled || f.w.globals.mousedown && d.globals.selectionEnabled) && (f.selection = f.selectionDrawing({ context: f, zoomtype: y }))), o.type === "mouseup" || o.type === "touchend" || o.type === "mouseleave") {
            var O = f.gridRect.getBoundingClientRect();
            f.w.globals.mousedown && (f.endX = f.clientX - O.left, f.endY = f.clientY - O.top, f.dragX = Math.abs(f.endX - f.startX), f.dragY = Math.abs(f.endY - f.startY), (d.globals.zoomEnabled || d.globals.selectionEnabled) && f.selectionDrawn({ context: f, zoomtype: y }), d.globals.panEnabled && d.config.xaxis.convertedCatToNumeric && f.delayedPanScrolled()), d.globals.zoomEnabled && f.hideSelectionRect(this.selectionRect), f.dragged = !1, f.w.globals.mousedown = !1;
          }
          this.makeSelectionRectDraggable();
        }
      }
    } }, { key: "makeSelectionRectDraggable", value: function() {
      var i = this.w;
      if (this.selectionRect) {
        var o = this.selectionRect.node.getBoundingClientRect();
        o.width > 0 && o.height > 0 && this.slDraggableRect.selectize({ points: "l, r", pointSize: 8, pointType: "rect" }).resize({ constraint: { minX: 0, minY: 0, maxX: i.globals.gridWidth, maxY: i.globals.gridHeight } }).on("resizing", this.selectionDragging.bind(this, "resizing"));
      }
    } }, { key: "preselectedSelection", value: function() {
      var i = this.w, o = this.xyRatios;
      if (!i.globals.zoomEnabled) {
        if (i.globals.selection !== void 0 && i.globals.selection !== null)
          this.drawSelectionRect(i.globals.selection);
        else if (i.config.chart.selection.xaxis.min !== void 0 && i.config.chart.selection.xaxis.max !== void 0) {
          var d = (i.config.chart.selection.xaxis.min - i.globals.minX) / o.xRatio, f = { x: d, y: 0, width: i.globals.gridWidth - (i.globals.maxX - i.config.chart.selection.xaxis.max) / o.xRatio - d, height: i.globals.gridHeight, translateX: 0, translateY: 0, selectionEnabled: !0 };
          this.drawSelectionRect(f), this.makeSelectionRectDraggable(), typeof i.config.chart.events.selection == "function" && i.config.chart.events.selection(this.ctx, { xaxis: { min: i.config.chart.selection.xaxis.min, max: i.config.chart.selection.xaxis.max }, yaxis: {} });
        }
      }
    } }, { key: "drawSelectionRect", value: function(i) {
      var o = i.x, d = i.y, f = i.width, p = i.height, y = i.translateX, S = y === void 0 ? 0 : y, C = i.translateY, E = C === void 0 ? 0 : C, L = this.w, O = this.zoomRect, P = this.selectionRect;
      if (this.dragged || L.globals.selection !== null) {
        var I = { transform: "translate(" + S + ", " + E + ")" };
        L.globals.zoomEnabled && this.dragged && (f < 0 && (f = 1), O.attr({ x: o, y: d, width: f, height: p, fill: L.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": L.config.chart.zoom.zoomedArea.fill.opacity, stroke: L.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": L.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": L.config.chart.zoom.zoomedArea.stroke.opacity }), re.setAttrs(O.node, I)), L.globals.selectionEnabled && (P.attr({ x: o, y: d, width: f > 0 ? f : 0, height: p > 0 ? p : 0, fill: L.config.chart.selection.fill.color, "fill-opacity": L.config.chart.selection.fill.opacity, stroke: L.config.chart.selection.stroke.color, "stroke-width": L.config.chart.selection.stroke.width, "stroke-dasharray": L.config.chart.selection.stroke.dashArray, "stroke-opacity": L.config.chart.selection.stroke.opacity }), re.setAttrs(P.node, I));
      }
    } }, { key: "hideSelectionRect", value: function(i) {
      i && i.attr({ x: 0, y: 0, width: 0, height: 0 });
    } }, { key: "selectionDrawing", value: function(i) {
      var o = i.context, d = i.zoomtype, f = this.w, p = o, y = this.gridRect.getBoundingClientRect(), S = p.startX - 1, C = p.startY, E = !1, L = !1, O = p.clientX - y.left - S, P = p.clientY - y.top - C, I = {};
      return Math.abs(O + S) > f.globals.gridWidth ? O = f.globals.gridWidth - S : p.clientX - y.left < 0 && (O = S), S > p.clientX - y.left && (E = !0, O = Math.abs(O)), C > p.clientY - y.top && (L = !0, P = Math.abs(P)), I = d === "x" ? { x: E ? S - O : S, y: 0, width: O, height: f.globals.gridHeight } : d === "y" ? { x: 0, y: L ? C - P : C, width: f.globals.gridWidth, height: P } : { x: E ? S - O : S, y: L ? C - P : C, width: O, height: P }, p.drawSelectionRect(I), p.selectionDragging("resizing"), I;
    } }, { key: "selectionDragging", value: function(i, o) {
      var d = this, f = this.w, p = this.xyRatios, y = this.selectionRect, S = 0;
      i === "resizing" && (S = 30);
      var C = function(L) {
        return parseFloat(y.node.getAttribute(L));
      }, E = { x: C("x"), y: C("y"), width: C("width"), height: C("height") };
      f.globals.selection = E, typeof f.config.chart.events.selection == "function" && f.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
        var L = d.gridRect.getBoundingClientRect(), O = y.node.getBoundingClientRect(), P = { xaxis: { min: f.globals.xAxisScale.niceMin + (O.left - L.left) * p.xRatio, max: f.globals.xAxisScale.niceMin + (O.right - L.left) * p.xRatio }, yaxis: { min: f.globals.yAxisScale[0].niceMin + (L.bottom - O.bottom) * p.yRatio[0], max: f.globals.yAxisScale[0].niceMax - (O.top - L.top) * p.yRatio[0] } };
        f.config.chart.events.selection(d.ctx, P), f.config.chart.brush.enabled && f.config.chart.events.brushScrolled !== void 0 && f.config.chart.events.brushScrolled(d.ctx, P);
      }, S));
    } }, { key: "selectionDrawn", value: function(i) {
      var o = i.context, d = i.zoomtype, f = this.w, p = o, y = this.xyRatios, S = this.ctx.toolbar;
      if (p.startX > p.endX) {
        var C = p.startX;
        p.startX = p.endX, p.endX = C;
      }
      if (p.startY > p.endY) {
        var E = p.startY;
        p.startY = p.endY, p.endY = E;
      }
      var L = void 0, O = void 0;
      f.globals.isRangeBar ? (L = f.globals.yAxisScale[0].niceMin + p.startX * y.invertedYRatio, O = f.globals.yAxisScale[0].niceMin + p.endX * y.invertedYRatio) : (L = f.globals.xAxisScale.niceMin + p.startX * y.xRatio, O = f.globals.xAxisScale.niceMin + p.endX * y.xRatio);
      var P = [], I = [];
      if (f.config.yaxis.forEach(function(K, ee) {
        P.push(f.globals.yAxisScale[ee].niceMax - y.yRatio[ee] * p.startY), I.push(f.globals.yAxisScale[ee].niceMax - y.yRatio[ee] * p.endY);
      }), p.dragged && (p.dragX > 10 || p.dragY > 10) && L !== O) {
        if (f.globals.zoomEnabled) {
          var j = Q.clone(f.globals.initialConfig.yaxis), V = Q.clone(f.globals.initialConfig.xaxis);
          if (f.globals.zoomed = !0, f.config.xaxis.convertedCatToNumeric && (L = Math.floor(L), O = Math.floor(O), L < 1 && (L = 1, O = f.globals.dataPoints), O - L < 2 && (O = L + 1)), d !== "xy" && d !== "x" || (V = { min: L, max: O }), d !== "xy" && d !== "y" || j.forEach(function(K, ee) {
            j[ee].min = I[ee], j[ee].max = P[ee];
          }), f.config.chart.zoom.autoScaleYaxis) {
            var Z = new Ze(p.ctx);
            j = Z.autoScaleY(p.ctx, j, { xaxis: V });
          }
          if (S) {
            var b = S.getBeforeZoomRange(V, j);
            b && (V = b.xaxis ? b.xaxis : V, j = b.yaxis ? b.yaxis : j);
          }
          var M = { xaxis: V };
          f.config.chart.group || (M.yaxis = j), p.ctx.updateHelpers._updateOptions(M, !1, p.w.config.chart.animations.dynamicAnimation.enabled), typeof f.config.chart.events.zoomed == "function" && S.zoomCallback(V, j);
        } else if (f.globals.selectionEnabled) {
          var N, X = null;
          N = { min: L, max: O }, d !== "xy" && d !== "y" || (X = Q.clone(f.config.yaxis)).forEach(function(K, ee) {
            X[ee].min = I[ee], X[ee].max = P[ee];
          }), f.globals.selection = p.selection, typeof f.config.chart.events.selection == "function" && f.config.chart.events.selection(p.ctx, { xaxis: N, yaxis: X });
        }
      }
    } }, { key: "panDragging", value: function(i) {
      var o = i.context, d = this.w, f = o;
      if (d.globals.lastClientPosition.x !== void 0) {
        var p = d.globals.lastClientPosition.x - f.clientX, y = d.globals.lastClientPosition.y - f.clientY;
        Math.abs(p) > Math.abs(y) && p > 0 ? this.moveDirection = "left" : Math.abs(p) > Math.abs(y) && p < 0 ? this.moveDirection = "right" : Math.abs(y) > Math.abs(p) && y > 0 ? this.moveDirection = "up" : Math.abs(y) > Math.abs(p) && y < 0 && (this.moveDirection = "down");
      }
      d.globals.lastClientPosition = { x: f.clientX, y: f.clientY };
      var S = d.globals.isRangeBar ? d.globals.minY : d.globals.minX, C = d.globals.isRangeBar ? d.globals.maxY : d.globals.maxX;
      d.config.xaxis.convertedCatToNumeric || f.panScrolled(S, C);
    } }, { key: "delayedPanScrolled", value: function() {
      var i = this.w, o = i.globals.minX, d = i.globals.maxX, f = (i.globals.maxX - i.globals.minX) / 2;
      this.moveDirection === "left" ? (o = i.globals.minX + f, d = i.globals.maxX + f) : this.moveDirection === "right" && (o = i.globals.minX - f, d = i.globals.maxX - f), o = Math.floor(o), d = Math.floor(d), this.updateScrolledChart({ xaxis: { min: o, max: d } }, o, d);
    } }, { key: "panScrolled", value: function(i, o) {
      var d = this.w, f = this.xyRatios, p = Q.clone(d.globals.initialConfig.yaxis), y = f.xRatio, S = d.globals.minX, C = d.globals.maxX;
      d.globals.isRangeBar && (y = f.invertedYRatio, S = d.globals.minY, C = d.globals.maxY), this.moveDirection === "left" ? (i = S + d.globals.gridWidth / 15 * y, o = C + d.globals.gridWidth / 15 * y) : this.moveDirection === "right" && (i = S - d.globals.gridWidth / 15 * y, o = C - d.globals.gridWidth / 15 * y), d.globals.isRangeBar || (i < d.globals.initialMinX || o > d.globals.initialMaxX) && (i = S, o = C);
      var E = { min: i, max: o };
      d.config.chart.zoom.autoScaleYaxis && (p = new Ze(this.ctx).autoScaleY(this.ctx, p, { xaxis: E }));
      var L = { xaxis: { min: i, max: o } };
      d.config.chart.group || (L.yaxis = p), this.updateScrolledChart(L, i, o);
    } }, { key: "updateScrolledChart", value: function(i, o, d) {
      var f = this.w;
      this.ctx.updateHelpers._updateOptions(i, !1, !1), typeof f.config.chart.events.scrolled == "function" && f.config.chart.events.scrolled(this.ctx, { xaxis: { min: o, max: d } });
    } }]), n;
  }(), Ke = function() {
    function B(t) {
      A(this, B), this.w = t.w, this.ttCtx = t, this.ctx = t.ctx;
    }
    return F(B, [{ key: "getNearestValues", value: function(t) {
      var n = t.hoverArea, i = t.elGrid, o = t.clientX, d = t.clientY, f = this.w, p = i.getBoundingClientRect(), y = p.width, S = p.height, C = y / (f.globals.dataPoints - 1), E = S / f.globals.dataPoints, L = this.hasBars();
      !f.globals.comboCharts && !L || f.config.xaxis.convertedCatToNumeric || (C = y / f.globals.dataPoints);
      var O = o - p.left - f.globals.barPadForNumericAxis, P = d - p.top;
      O < 0 || P < 0 || O > y || P > S ? (n.classList.remove("hovering-zoom"), n.classList.remove("hovering-pan")) : f.globals.zoomEnabled ? (n.classList.remove("hovering-pan"), n.classList.add("hovering-zoom")) : f.globals.panEnabled && (n.classList.remove("hovering-zoom"), n.classList.add("hovering-pan"));
      var I = Math.round(O / C), j = Math.floor(P / E);
      L && !f.config.xaxis.convertedCatToNumeric && (I = Math.ceil(O / C), I -= 1);
      var V = null, Z = null, b = [], M = [];
      if (f.globals.seriesXvalues.forEach(function(ee) {
        b.push([ee[0] + 1e-6].concat(ee));
      }), f.globals.seriesYvalues.forEach(function(ee) {
        M.push([ee[0] + 1e-6].concat(ee));
      }), b = b.map(function(ee) {
        return ee.filter(function(oe) {
          return Q.isNumber(oe);
        });
      }), M = M.map(function(ee) {
        return ee.filter(function(oe) {
          return Q.isNumber(oe);
        });
      }), f.globals.isXNumeric) {
        var N = this.ttCtx.getElGrid().getBoundingClientRect(), X = O * (N.width / y), K = P * (N.height / S);
        V = (Z = this.closestInMultiArray(X, K, b, M)).index, I = Z.j, V !== null && (b = f.globals.seriesXvalues[V], I = (Z = this.closestInArray(X, b)).index);
      }
      return f.globals.capturedSeriesIndex = V === null ? -1 : V, (!I || I < 1) && (I = 0), f.globals.isBarHorizontal ? f.globals.capturedDataPointIndex = j : f.globals.capturedDataPointIndex = I, { capturedSeries: V, j: f.globals.isBarHorizontal ? j : I, hoverX: O, hoverY: P };
    } }, { key: "closestInMultiArray", value: function(t, n, i, o) {
      var d = this.w, f = 0, p = null, y = -1;
      d.globals.series.length > 1 ? f = this.getFirstActiveXArray(i) : p = 0;
      var S = i[f][0], C = Math.abs(t - S);
      if (i.forEach(function(O) {
        O.forEach(function(P, I) {
          var j = Math.abs(t - P);
          j < C && (C = j, y = I);
        });
      }), y !== -1) {
        var E = o[f][y], L = Math.abs(n - E);
        p = f, o.forEach(function(O, P) {
          var I = Math.abs(n - O[y]);
          I < L && (L = I, p = P);
        });
      }
      return { index: p, j: y };
    } }, { key: "getFirstActiveXArray", value: function(t) {
      for (var n = this.w, i = 0, o = t.map(function(f, p) {
        return f.length > 0 ? p : -1;
      }), d = 0; d < o.length; d++)
        if (o[d] !== -1 && n.globals.collapsedSeriesIndices.indexOf(d) === -1 && n.globals.ancillaryCollapsedSeriesIndices.indexOf(d) === -1) {
          i = o[d];
          break;
        }
      return i;
    } }, { key: "closestInArray", value: function(t, n) {
      for (var i = n[0], o = null, d = Math.abs(t - i), f = 0; f < n.length; f++) {
        var p = Math.abs(t - n[f]);
        p < d && (d = p, o = f);
      }
      return { index: o };
    } }, { key: "isXoverlap", value: function(t) {
      var n = [], i = this.w.globals.seriesX.filter(function(d) {
        return d[0] !== void 0;
      });
      if (i.length > 0)
        for (var o = 0; o < i.length - 1; o++)
          i[o][t] !== void 0 && i[o + 1][t] !== void 0 && i[o][t] !== i[o + 1][t] && n.push("unEqual");
      return n.length === 0;
    } }, { key: "isInitialSeriesSameLen", value: function() {
      for (var t = !0, n = this.w.globals.initialSeries, i = 0; i < n.length - 1; i++)
        if (n[i].data.length !== n[i + 1].data.length) {
          t = !1;
          break;
        }
      return t;
    } }, { key: "getBarsHeight", value: function(t) {
      return ue(t).reduce(function(n, i) {
        return n + i.getBBox().height;
      }, 0);
    } }, { key: "getElMarkers", value: function(t) {
      return typeof t == "number" ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *");
    } }, { key: "getAllMarkers", value: function() {
      var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
      (t = ue(t)).sort(function(i, o) {
        var d = Number(i.getAttribute("data:realIndex")), f = Number(o.getAttribute("data:realIndex"));
        return f < d ? 1 : f > d ? -1 : 0;
      });
      var n = [];
      return t.forEach(function(i) {
        n.push(i.querySelector(".apexcharts-marker"));
      }), n;
    } }, { key: "hasMarkers", value: function(t) {
      return this.getElMarkers(t).length > 0;
    } }, { key: "getElBars", value: function() {
      return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
    } }, { key: "hasBars", value: function() {
      return this.getElBars().length > 0;
    } }, { key: "getHoverMarkerSize", value: function(t) {
      var n = this.w, i = n.config.markers.hover.size;
      return i === void 0 && (i = n.globals.markers.size[t] + n.config.markers.hover.sizeOffset), i;
    } }, { key: "toggleAllTooltipSeriesGroups", value: function(t) {
      var n = this.w, i = this.ttCtx;
      i.allTooltipSeriesGroups.length === 0 && (i.allTooltipSeriesGroups = n.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
      for (var o = i.allTooltipSeriesGroups, d = 0; d < o.length; d++)
        t === "enable" ? (o[d].classList.add("apexcharts-active"), o[d].style.display = n.config.tooltip.items.display) : (o[d].classList.remove("apexcharts-active"), o[d].style.display = "none");
    } }]), B;
  }(), Rt = function() {
    function B(t) {
      A(this, B), this.w = t.w, this.ctx = t.ctx, this.ttCtx = t, this.tooltipUtil = new Ke(t);
    }
    return F(B, [{ key: "drawSeriesTexts", value: function(t) {
      var n = t.shared, i = n === void 0 || n, o = t.ttItems, d = t.i, f = d === void 0 ? 0 : d, p = t.j, y = p === void 0 ? null : p, S = t.y1, C = t.y2, E = t.e, L = this.w;
      L.config.tooltip.custom !== void 0 ? this.handleCustomTooltip({ i: f, j: y, y1: S, y2: C, w: L }) : this.toggleActiveInactiveSeries(i);
      var O = this.getValuesToPrint({ i: f, j: y });
      this.printLabels({ i: f, j: y, values: O, ttItems: o, shared: i, e: E });
      var P = this.ttCtx.getElTooltip();
      this.ttCtx.tooltipRect.ttWidth = P.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = P.getBoundingClientRect().height;
    } }, { key: "printLabels", value: function(t) {
      var n, i = this, o = t.i, d = t.j, f = t.values, p = t.ttItems, y = t.shared, S = t.e, C = this.w, E = [], L = function(N) {
        return C.globals.seriesGoals[N] && C.globals.seriesGoals[N][d] && Array.isArray(C.globals.seriesGoals[N][d]);
      }, O = f.xVal, P = f.zVal, I = f.xAxisTTVal, j = "", V = C.globals.colors[o];
      d !== null && C.config.plotOptions.bar.distributed && (V = C.globals.colors[d]);
      for (var Z = function(N, X) {
        var K = i.getFormatters(o);
        j = i.getSeriesName({ fn: K.yLbTitleFormatter, index: o, seriesIndex: o, j: d }), C.config.chart.type === "treemap" && (j = K.yLbTitleFormatter(String(C.config.series[o].data[d].x), { series: C.globals.series, seriesIndex: o, dataPointIndex: d, w: C }));
        var ee = C.config.tooltip.inverseOrder ? X : N;
        if (C.globals.axisCharts) {
          var oe = function(_e) {
            var Me, Ie, rt, Qt;
            return C.globals.isRangeData ? K.yLbFormatter((Me = C.globals.seriesRangeStart) === null || Me === void 0 || (Ie = Me[_e]) === null || Ie === void 0 ? void 0 : Ie[d], { series: C.globals.seriesRangeStart, seriesIndex: _e, dataPointIndex: d, w: C }) + " - " + K.yLbFormatter((rt = C.globals.seriesRangeEnd) === null || rt === void 0 || (Qt = rt[_e]) === null || Qt === void 0 ? void 0 : Qt[d], { series: C.globals.seriesRangeEnd, seriesIndex: _e, dataPointIndex: d, w: C }) : K.yLbFormatter(C.globals.series[_e][d], { series: C.globals.series, seriesIndex: _e, dataPointIndex: d, w: C });
          };
          if (y)
            K = i.getFormatters(ee), j = i.getSeriesName({ fn: K.yLbTitleFormatter, index: ee, seriesIndex: o, j: d }), V = C.globals.colors[ee], n = oe(ee), L(ee) && (E = C.globals.seriesGoals[ee][d].map(function(_e) {
              return { attrs: _e, val: K.yLbFormatter(_e.value, { seriesIndex: ee, dataPointIndex: d, w: C }) };
            }));
          else {
            var de, ke = S == null || (de = S.target) === null || de === void 0 ? void 0 : de.getAttribute("fill");
            ke && (V = ke.indexOf("url") !== -1 ? document.querySelector(ke.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : ke), n = oe(o), L(o) && Array.isArray(C.globals.seriesGoals[o][d]) && (E = C.globals.seriesGoals[o][d].map(function(_e) {
              return { attrs: _e, val: K.yLbFormatter(_e.value, { seriesIndex: o, dataPointIndex: d, w: C }) };
            }));
          }
        }
        d === null && (n = K.yLbFormatter(C.globals.series[o], v(v({}, C), {}, { seriesIndex: o, dataPointIndex: o }))), i.DOMHandling({ i: o, t: ee, j: d, ttItems: p, values: { val: n, goalVals: E, xVal: O, xAxisTTVal: I, zVal: P }, seriesName: j, shared: y, pColor: V });
      }, b = 0, M = C.globals.series.length - 1; b < C.globals.series.length; b++, M--)
        Z(b, M);
    } }, { key: "getFormatters", value: function(t) {
      var n, i = this.w, o = i.globals.yLabelFormatters[t];
      return i.globals.ttVal !== void 0 ? Array.isArray(i.globals.ttVal) ? (o = i.globals.ttVal[t] && i.globals.ttVal[t].formatter, n = i.globals.ttVal[t] && i.globals.ttVal[t].title && i.globals.ttVal[t].title.formatter) : (o = i.globals.ttVal.formatter, typeof i.globals.ttVal.title.formatter == "function" && (n = i.globals.ttVal.title.formatter)) : n = i.config.tooltip.y.title.formatter, typeof o != "function" && (o = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function(d) {
        return d;
      }), typeof n != "function" && (n = function(d) {
        return d;
      }), { yLbFormatter: o, yLbTitleFormatter: n };
    } }, { key: "getSeriesName", value: function(t) {
      var n = t.fn, i = t.index, o = t.seriesIndex, d = t.j, f = this.w;
      return n(String(f.globals.seriesNames[i]), { series: f.globals.series, seriesIndex: o, dataPointIndex: d, w: f });
    } }, { key: "DOMHandling", value: function(t) {
      t.i;
      var n = t.t, i = t.j, o = t.ttItems, d = t.values, f = t.seriesName, p = t.shared, y = t.pColor, S = this.w, C = this.ttCtx, E = d.val, L = d.goalVals, O = d.xVal, P = d.xAxisTTVal, I = d.zVal, j = null;
      j = o[n].children, S.config.tooltip.fillSeriesColor && (o[n].style.backgroundColor = y, j[0].style.display = "none"), C.showTooltipTitle && (C.tooltipTitle === null && (C.tooltipTitle = S.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), C.tooltipTitle.innerHTML = O), C.isXAxisTooltipEnabled && (C.xaxisTooltipText.innerHTML = P !== "" ? P : O);
      var V = o[n].querySelector(".apexcharts-tooltip-text-y-label");
      V && (V.innerHTML = f || "");
      var Z = o[n].querySelector(".apexcharts-tooltip-text-y-value");
      Z && (Z.innerHTML = E !== void 0 ? E : ""), j[0] && j[0].classList.contains("apexcharts-tooltip-marker") && (S.config.tooltip.marker.fillColors && Array.isArray(S.config.tooltip.marker.fillColors) && (y = S.config.tooltip.marker.fillColors[n]), j[0].style.backgroundColor = y), S.config.tooltip.marker.show || (j[0].style.display = "none");
      var b = o[n].querySelector(".apexcharts-tooltip-text-goals-label"), M = o[n].querySelector(".apexcharts-tooltip-text-goals-value");
      if (L.length && S.globals.seriesGoals[n]) {
        var N = function() {
          var X = "<div >", K = "<div>";
          L.forEach(function(ee, oe) {
            X += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(ee.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(ee.attrs.name, "</div>"), K += "<div>".concat(ee.val, "</div>");
          }), b.innerHTML = X + "</div>", M.innerHTML = K + "</div>";
        };
        p ? S.globals.seriesGoals[n][i] && Array.isArray(S.globals.seriesGoals[n][i]) ? N() : (b.innerHTML = "", M.innerHTML = "") : N();
      } else
        b.innerHTML = "", M.innerHTML = "";
      I !== null && (o[n].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = S.config.tooltip.z.title, o[n].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = I !== void 0 ? I : ""), p && j[0] && (E == null || S.globals.ancillaryCollapsedSeriesIndices.indexOf(n) > -1 || S.globals.collapsedSeriesIndices.indexOf(n) > -1 ? j[0].parentNode.style.display = "none" : j[0].parentNode.style.display = S.config.tooltip.items.display);
    } }, { key: "toggleActiveInactiveSeries", value: function(t) {
      var n = this.w;
      if (t)
        this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
      else {
        this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
        var i = n.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
        i && (i.classList.add("apexcharts-active"), i.style.display = n.config.tooltip.items.display);
      }
    } }, { key: "getValuesToPrint", value: function(t) {
      var n = t.i, i = t.j, o = this.w, d = this.ctx.series.filteredSeriesX(), f = "", p = "", y = null, S = null, C = { series: o.globals.series, seriesIndex: n, dataPointIndex: i, w: o }, E = o.globals.ttZFormatter;
      i === null ? S = o.globals.series[n] : o.globals.isXNumeric && o.config.chart.type !== "treemap" ? (f = d[n][i], d[n].length === 0 && (f = d[this.tooltipUtil.getFirstActiveXArray(d)][i])) : f = o.globals.labels[i] !== void 0 ? o.globals.labels[i] : "";
      var L = f;
      return o.globals.isXNumeric && o.config.xaxis.type === "datetime" ? f = new Ht(this.ctx).xLabelFormat(o.globals.ttKeyFormatter, L, L, { i: void 0, dateFormatter: new it(this.ctx).formatDate, w: this.w }) : f = o.globals.isBarHorizontal ? o.globals.yLabelFormatters[0](L, C) : o.globals.xLabelFormatter(L, C), o.config.tooltip.x.formatter !== void 0 && (f = o.globals.ttKeyFormatter(L, C)), o.globals.seriesZ.length > 0 && o.globals.seriesZ[n].length > 0 && (y = E(o.globals.seriesZ[n][i], o)), p = typeof o.config.xaxis.tooltip.formatter == "function" ? o.globals.xaxisTooltipFormatter(L, C) : f, { val: Array.isArray(S) ? S.join(" ") : S, xVal: Array.isArray(f) ? f.join(" ") : f, xAxisTTVal: Array.isArray(p) ? p.join(" ") : p, zVal: y };
    } }, { key: "handleCustomTooltip", value: function(t) {
      var n = t.i, i = t.j, o = t.y1, d = t.y2, f = t.w, p = this.ttCtx.getElTooltip(), y = f.config.tooltip.custom;
      Array.isArray(y) && y[n] && (y = y[n]), p.innerHTML = y({ ctx: this.ctx, series: f.globals.series, seriesIndex: n, dataPointIndex: i, y1: o, y2: d, w: f });
    } }]), B;
  }(), tn = function() {
    function B(t) {
      A(this, B), this.ttCtx = t, this.ctx = t.ctx, this.w = t.w;
    }
    return F(B, [{ key: "moveXCrosshairs", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = this.ttCtx, o = this.w, d = i.getElXCrosshairs(), f = t - i.xcrosshairsWidth / 2, p = o.globals.labels.slice().length;
      if (n !== null && (f = o.globals.gridWidth / p * n), d === null || o.globals.isBarHorizontal || (d.setAttribute("x", f), d.setAttribute("x1", f), d.setAttribute("x2", f), d.setAttribute("y2", o.globals.gridHeight), d.classList.add("apexcharts-active")), f < 0 && (f = 0), f > o.globals.gridWidth && (f = o.globals.gridWidth), i.isXAxisTooltipEnabled) {
        var y = f;
        o.config.xaxis.crosshairs.width !== "tickWidth" && o.config.xaxis.crosshairs.width !== "barWidth" || (y = f + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(y);
      }
    } }, { key: "moveYCrosshairs", value: function(t) {
      var n = this.ttCtx;
      n.ycrosshairs !== null && re.setAttrs(n.ycrosshairs, { y1: t, y2: t }), n.ycrosshairsHidden !== null && re.setAttrs(n.ycrosshairsHidden, { y1: t, y2: t });
    } }, { key: "moveXAxisTooltip", value: function(t) {
      var n = this.w, i = this.ttCtx;
      if (i.xaxisTooltip !== null && i.xcrosshairsWidth !== 0) {
        i.xaxisTooltip.classList.add("apexcharts-active");
        var o = i.xaxisOffY + n.config.xaxis.tooltip.offsetY + n.globals.translateY + 1 + n.config.xaxis.offsetY;
        if (t -= i.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t)) {
          t += n.globals.translateX;
          var d;
          d = new re(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML), i.xaxisTooltipText.style.minWidth = d.width + "px", i.xaxisTooltip.style.left = t + "px", i.xaxisTooltip.style.top = o + "px";
        }
      }
    } }, { key: "moveYAxisTooltip", value: function(t) {
      var n = this.w, i = this.ttCtx;
      i.yaxisTTEls === null && (i.yaxisTTEls = n.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
      var o = parseInt(i.ycrosshairsHidden.getAttribute("y1"), 10), d = n.globals.translateY + o, f = i.yaxisTTEls[t].getBoundingClientRect().height, p = n.globals.translateYAxisX[t] - 2;
      n.config.yaxis[t].opposite && (p -= 26), d -= f / 2, n.globals.ignoreYAxisIndexes.indexOf(t) === -1 ? (i.yaxisTTEls[t].classList.add("apexcharts-active"), i.yaxisTTEls[t].style.top = d + "px", i.yaxisTTEls[t].style.left = p + n.config.yaxis[t].tooltip.offsetX + "px") : i.yaxisTTEls[t].classList.remove("apexcharts-active");
    } }, { key: "moveTooltip", value: function(t, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, o = this.w, d = this.ttCtx, f = d.getElTooltip(), p = d.tooltipRect, y = i !== null ? parseFloat(i) : 1, S = parseFloat(t) + y + 5, C = parseFloat(n) + y / 2;
      if (S > o.globals.gridWidth / 2 && (S = S - p.ttWidth - y - 10), S > o.globals.gridWidth - p.ttWidth - 10 && (S = o.globals.gridWidth - p.ttWidth), S < -20 && (S = -20), o.config.tooltip.followCursor) {
        var E = d.getElGrid().getBoundingClientRect();
        (S = d.e.clientX - E.left) > o.globals.gridWidth / 2 && (S -= d.tooltipRect.ttWidth), (C = d.e.clientY + o.globals.translateY - E.top) > o.globals.gridHeight / 2 && (C -= d.tooltipRect.ttHeight);
      } else
        o.globals.isBarHorizontal || p.ttHeight / 2 + C > o.globals.gridHeight && (C = o.globals.gridHeight - p.ttHeight + o.globals.translateY);
      isNaN(S) || (S += o.globals.translateX, f.style.left = S + "px", f.style.top = C + "px");
    } }, { key: "moveMarkers", value: function(t, n) {
      var i = this.w, o = this.ttCtx;
      if (i.globals.markers.size[t] > 0)
        for (var d = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-marker")), f = 0; f < d.length; f++)
          parseInt(d[f].getAttribute("rel"), 10) === n && (o.marker.resetPointsSize(), o.marker.enlargeCurrentPoint(n, d[f]));
      else
        o.marker.resetPointsSize(), this.moveDynamicPointOnHover(n, t);
    } }, { key: "moveDynamicPointOnHover", value: function(t, n) {
      var i, o, d = this.w, f = this.ttCtx, p = d.globals.pointsArray, y = f.tooltipUtil.getHoverMarkerSize(n), S = d.config.series[n].type;
      if (!S || S !== "column" && S !== "candlestick" && S !== "boxPlot") {
        i = p[n][t][0], o = p[n][t][1] ? p[n][t][1] : 0;
        var C = d.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(n, "'] .apexcharts-series-markers circle"));
        C && o < d.globals.gridHeight && o > 0 && (C.setAttribute("r", y), C.setAttribute("cx", i), C.setAttribute("cy", o)), this.moveXCrosshairs(i), f.fixedTooltip || this.moveTooltip(i, o, y);
      }
    } }, { key: "moveDynamicPointsOnHover", value: function(t) {
      var n, i = this.ttCtx, o = i.w, d = 0, f = 0, p = o.globals.pointsArray;
      n = new ot(this.ctx).getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
      var y = i.tooltipUtil.getHoverMarkerSize(n);
      p[n] && (d = p[n][t][0], f = p[n][t][1]);
      var S = i.tooltipUtil.getAllMarkers();
      if (S !== null)
        for (var C = 0; C < o.globals.series.length; C++) {
          var E = p[C];
          if (o.globals.comboCharts && E === void 0 && S.splice(C, 0, null), E && E.length) {
            var L = p[C][t][1], O = void 0;
            if (S[C].setAttribute("cx", d), o.config.chart.type === "rangeArea" && !o.globals.comboCharts) {
              var P = t + o.globals.series[C].length;
              O = p[C][P][1], L -= Math.abs(L - O) / 2;
            }
            L !== null && !isNaN(L) && L < o.globals.gridHeight + y && L + y > 0 ? (S[C] && S[C].setAttribute("r", y), S[C] && S[C].setAttribute("cy", L)) : S[C] && S[C].setAttribute("r", 0);
          }
        }
      this.moveXCrosshairs(d), i.fixedTooltip || this.moveTooltip(d, f || o.globals.gridHeight, y);
    } }, { key: "moveStickyTooltipOverBars", value: function(t, n) {
      var i = this.w, o = this.ttCtx, d = i.globals.columnSeries ? i.globals.columnSeries.length : i.globals.series.length, f = d >= 2 && d % 2 == 0 ? Math.floor(d / 2) : Math.floor(d / 2) + 1;
      i.globals.isBarHorizontal && (f = new ot(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
      var p = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(f, "'] path[j='").concat(t, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(f, "'] path[j='").concat(t, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(f, "'] path[j='").concat(t, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(f, "'] path[j='").concat(t, "']"));
      p || typeof n != "number" || (p = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(n, "'] path[j='").concat(t, `'],
        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='`).concat(n, "'] path[j='").concat(t, `'],
        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='`).concat(n, "'] path[j='").concat(t, `'],
        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='`).concat(n, "'] path[j='").concat(t, "']")));
      var y = p ? parseFloat(p.getAttribute("cx")) : 0, S = p ? parseFloat(p.getAttribute("cy")) : 0, C = p ? parseFloat(p.getAttribute("barWidth")) : 0, E = o.getElGrid().getBoundingClientRect(), L = p && (p.classList.contains("apexcharts-candlestick-area") || p.classList.contains("apexcharts-boxPlot-area"));
      i.globals.isXNumeric ? (p && !L && (y -= d % 2 != 0 ? C / 2 : 0), p && L && i.globals.comboCharts && (y -= C / 2)) : i.globals.isBarHorizontal || (y = o.xAxisTicksPositions[t - 1] + o.dataPointsDividedWidth / 2, isNaN(y) && (y = o.xAxisTicksPositions[t] - o.dataPointsDividedWidth / 2)), i.globals.isBarHorizontal ? S -= o.tooltipRect.ttHeight : i.config.tooltip.followCursor ? S = o.e.clientY - E.top - o.tooltipRect.ttHeight / 2 : S + o.tooltipRect.ttHeight + 15 > i.globals.gridHeight && (S = i.globals.gridHeight), i.globals.isBarHorizontal || this.moveXCrosshairs(y), o.fixedTooltip || this.moveTooltip(y, S || i.globals.gridHeight);
    } }]), B;
  }(), bn = function() {
    function B(t) {
      A(this, B), this.w = t.w, this.ttCtx = t, this.ctx = t.ctx, this.tooltipPosition = new tn(t);
    }
    return F(B, [{ key: "drawDynamicPoints", value: function() {
      var t = this.w, n = new re(this.ctx), i = new kt(this.ctx), o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
      o = ue(o), t.config.chart.stacked && o.sort(function(E, L) {
        return parseFloat(E.getAttribute("data:realIndex")) - parseFloat(L.getAttribute("data:realIndex"));
      });
      for (var d = 0; d < o.length; d++) {
        var f = o[d].querySelector(".apexcharts-series-markers-wrap");
        if (f !== null) {
          var p = void 0, y = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
          t.config.chart.type !== "line" && t.config.chart.type !== "area" || t.globals.comboCharts || t.config.tooltip.intersect || (y += " no-pointer-events");
          var S = i.getMarkerConfig({ cssClass: y, seriesIndex: Number(f.getAttribute("data:realIndex")) });
          (p = n.drawMarker(0, 0, S)).node.setAttribute("default-marker-size", 0);
          var C = document.createElementNS(t.globals.SVGNS, "g");
          C.classList.add("apexcharts-series-markers"), C.appendChild(p.node), f.appendChild(C);
        }
      }
    } }, { key: "enlargeCurrentPoint", value: function(t, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, d = this.w;
      d.config.chart.type !== "bubble" && this.newPointSize(t, n);
      var f = n.getAttribute("cx"), p = n.getAttribute("cy");
      if (i !== null && o !== null && (f = i, p = o), this.tooltipPosition.moveXCrosshairs(f), !this.fixedTooltip) {
        if (d.config.chart.type === "radar") {
          var y = this.ttCtx.getElGrid().getBoundingClientRect();
          f = this.ttCtx.e.clientX - y.left;
        }
        this.tooltipPosition.moveTooltip(f, p, d.config.markers.hover.size);
      }
    } }, { key: "enlargePoints", value: function(t) {
      for (var n = this.w, i = this, o = this.ttCtx, d = t, f = n.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), p = n.config.markers.hover.size, y = 0; y < f.length; y++) {
        var S = f[y].getAttribute("rel"), C = f[y].getAttribute("index");
        if (p === void 0 && (p = n.globals.markers.size[C] + n.config.markers.hover.sizeOffset), d === parseInt(S, 10)) {
          i.newPointSize(d, f[y]);
          var E = f[y].getAttribute("cx"), L = f[y].getAttribute("cy");
          i.tooltipPosition.moveXCrosshairs(E), o.fixedTooltip || i.tooltipPosition.moveTooltip(E, L, p);
        } else
          i.oldPointSize(f[y]);
      }
    } }, { key: "newPointSize", value: function(t, n) {
      var i = this.w, o = i.config.markers.hover.size, d = t === 0 ? n.parentNode.firstChild : n.parentNode.lastChild;
      if (d.getAttribute("default-marker-size") !== "0") {
        var f = parseInt(d.getAttribute("index"), 10);
        o === void 0 && (o = i.globals.markers.size[f] + i.config.markers.hover.sizeOffset), o < 0 && (o = 0), d.setAttribute("r", o);
      }
    } }, { key: "oldPointSize", value: function(t) {
      var n = parseFloat(t.getAttribute("default-marker-size"));
      t.setAttribute("r", n);
    } }, { key: "resetPointsSize", value: function() {
      for (var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), n = 0; n < t.length; n++) {
        var i = parseFloat(t[n].getAttribute("default-marker-size"));
        Q.isNumber(i) && i >= 0 ? t[n].setAttribute("r", i) : t[n].setAttribute("r", 0);
      }
    } }]), B;
  }(), Un = function() {
    function B(t) {
      A(this, B), this.w = t.w;
      var n = this.w;
      this.ttCtx = t, this.isVerticalGroupedRangeBar = !n.globals.isBarHorizontal && n.config.chart.type === "rangeBar" && n.config.plotOptions.bar.rangeBarGroupRows;
    }
    return F(B, [{ key: "getAttr", value: function(t, n) {
      return parseFloat(t.target.getAttribute(n));
    } }, { key: "handleHeatTreeTooltip", value: function(t) {
      var n = t.e, i = t.opt, o = t.x, d = t.y, f = t.type, p = this.ttCtx, y = this.w;
      if (n.target.classList.contains("apexcharts-".concat(f, "-rect"))) {
        var S = this.getAttr(n, "i"), C = this.getAttr(n, "j"), E = this.getAttr(n, "cx"), L = this.getAttr(n, "cy"), O = this.getAttr(n, "width"), P = this.getAttr(n, "height");
        if (p.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: S, j: C, shared: !1, e: n }), y.globals.capturedSeriesIndex = S, y.globals.capturedDataPointIndex = C, o = E + p.tooltipRect.ttWidth / 2 + O, d = L + p.tooltipRect.ttHeight / 2 - P / 2, p.tooltipPosition.moveXCrosshairs(E + O / 2), o > y.globals.gridWidth / 2 && (o = E - p.tooltipRect.ttWidth / 2 + O), p.w.config.tooltip.followCursor) {
          var I = y.globals.dom.elWrap.getBoundingClientRect();
          o = y.globals.clientX - I.left - (o > y.globals.gridWidth / 2 ? p.tooltipRect.ttWidth : 0), d = y.globals.clientY - I.top - (d > y.globals.gridHeight / 2 ? p.tooltipRect.ttHeight : 0);
        }
      }
      return { x: o, y: d };
    } }, { key: "handleMarkerTooltip", value: function(t) {
      var n, i, o = t.e, d = t.opt, f = t.x, p = t.y, y = this.w, S = this.ttCtx;
      if (o.target.classList.contains("apexcharts-marker")) {
        var C = parseInt(d.paths.getAttribute("cx"), 10), E = parseInt(d.paths.getAttribute("cy"), 10), L = parseFloat(d.paths.getAttribute("val"));
        if (i = parseInt(d.paths.getAttribute("rel"), 10), n = parseInt(d.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, S.intersect) {
          var O = Q.findAncestor(d.paths, "apexcharts-series");
          O && (n = parseInt(O.getAttribute("data:realIndex"), 10));
        }
        if (S.tooltipLabels.drawSeriesTexts({ ttItems: d.ttItems, i: n, j: i, shared: !S.showOnIntersect && y.config.tooltip.shared, e: o }), o.type === "mouseup" && S.markerClick(o, n, i), y.globals.capturedSeriesIndex = n, y.globals.capturedDataPointIndex = i, f = C, p = E + y.globals.translateY - 1.4 * S.tooltipRect.ttHeight, S.w.config.tooltip.followCursor) {
          var P = S.getElGrid().getBoundingClientRect();
          p = S.e.clientY + y.globals.translateY - P.top;
        }
        L < 0 && (p = E), S.marker.enlargeCurrentPoint(i, d.paths, f, p);
      }
      return { x: f, y: p };
    } }, { key: "handleBarTooltip", value: function(t) {
      var n, i, o = t.e, d = t.opt, f = this.w, p = this.ttCtx, y = p.getElTooltip(), S = 0, C = 0, E = 0, L = this.getBarTooltipXY({ e: o, opt: d });
      n = L.i;
      var O = L.barHeight, P = L.j;
      f.globals.capturedSeriesIndex = n, f.globals.capturedDataPointIndex = P, f.globals.isBarHorizontal && p.tooltipUtil.hasBars() || !f.config.tooltip.shared ? (C = L.x, E = L.y, i = Array.isArray(f.config.stroke.width) ? f.config.stroke.width[n] : f.config.stroke.width, S = C) : f.globals.comboCharts || f.config.tooltip.shared || (S /= 2), isNaN(E) && (E = f.globals.svgHeight - p.tooltipRect.ttHeight);
      var I = parseInt(d.paths.parentNode.getAttribute("data:realIndex"), 10), j = f.globals.isMultipleYAxis ? f.config.yaxis[I] && f.config.yaxis[I].reversed : f.config.yaxis[0].reversed;
      if (C + p.tooltipRect.ttWidth > f.globals.gridWidth && !j ? C -= p.tooltipRect.ttWidth : C < 0 && (C = 0), p.w.config.tooltip.followCursor) {
        var V = p.getElGrid().getBoundingClientRect();
        E = p.e.clientY - V.top;
      }
      p.tooltip === null && (p.tooltip = f.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), f.config.tooltip.shared || (f.globals.comboBarCount > 0 ? p.tooltipPosition.moveXCrosshairs(S + i / 2) : p.tooltipPosition.moveXCrosshairs(S)), !p.fixedTooltip && (!f.config.tooltip.shared || f.globals.isBarHorizontal && p.tooltipUtil.hasBars()) && (j && (C -= p.tooltipRect.ttWidth) < 0 && (C = 0), !j || f.globals.isBarHorizontal && p.tooltipUtil.hasBars() || (E = E + O - 2 * (f.globals.series[n][P] < 0 ? O : 0)), E = E + f.globals.translateY - p.tooltipRect.ttHeight / 2, y.style.left = C + f.globals.translateX + "px", y.style.top = E + "px");
    } }, { key: "getBarTooltipXY", value: function(t) {
      var n = this, i = t.e, o = t.opt, d = this.w, f = null, p = this.ttCtx, y = 0, S = 0, C = 0, E = 0, L = 0, O = i.target.classList;
      if (O.contains("apexcharts-bar-area") || O.contains("apexcharts-candlestick-area") || O.contains("apexcharts-boxPlot-area") || O.contains("apexcharts-rangebar-area")) {
        var P = i.target, I = P.getBoundingClientRect(), j = o.elGrid.getBoundingClientRect(), V = I.height;
        L = I.height;
        var Z = I.width, b = parseInt(P.getAttribute("cx"), 10), M = parseInt(P.getAttribute("cy"), 10);
        E = parseFloat(P.getAttribute("barWidth"));
        var N = i.type === "touchmove" ? i.touches[0].clientX : i.clientX;
        f = parseInt(P.getAttribute("j"), 10), y = parseInt(P.parentNode.getAttribute("rel"), 10) - 1;
        var X = P.getAttribute("data-range-y1"), K = P.getAttribute("data-range-y2");
        d.globals.comboCharts && (y = parseInt(P.parentNode.getAttribute("data:realIndex"), 10));
        var ee = function(de) {
          return d.globals.isXNumeric ? b - Z / 2 : n.isVerticalGroupedRangeBar ? b + Z / 2 : b - p.dataPointsDividedWidth + Z / 2;
        }, oe = function() {
          return M - p.dataPointsDividedHeight + V / 2 - p.tooltipRect.ttHeight / 2;
        };
        p.tooltipLabels.drawSeriesTexts({ ttItems: o.ttItems, i: y, j: f, y1: X ? parseInt(X, 10) : null, y2: K ? parseInt(K, 10) : null, shared: !p.showOnIntersect && d.config.tooltip.shared, e: i }), d.config.tooltip.followCursor ? d.globals.isBarHorizontal ? (S = N - j.left + 15, C = oe()) : (S = ee(), C = i.clientY - j.top - p.tooltipRect.ttHeight / 2 - 15) : d.globals.isBarHorizontal ? ((S = b) < p.xyRatios.baseLineInvertedY && (S = b - p.tooltipRect.ttWidth), C = oe()) : (S = ee(), C = M);
      }
      return { x: S, y: C, barHeight: L, barWidth: E, i: y, j: f };
    } }]), B;
  }(), pr = function() {
    function B(t) {
      A(this, B), this.w = t.w, this.ttCtx = t;
    }
    return F(B, [{ key: "drawXaxisTooltip", value: function() {
      var t = this.w, n = this.ttCtx, i = t.config.xaxis.position === "bottom";
      n.xaxisOffY = i ? t.globals.gridHeight + 1 : -t.globals.xAxisHeight - t.config.xaxis.axisTicks.height + 3;
      var o = i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", d = t.globals.dom.elWrap;
      n.isXAxisTooltipEnabled && t.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") === null && (n.xaxisTooltip = document.createElement("div"), n.xaxisTooltip.setAttribute("class", o + " apexcharts-theme-" + t.config.tooltip.theme), d.appendChild(n.xaxisTooltip), n.xaxisTooltipText = document.createElement("div"), n.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), n.xaxisTooltipText.style.fontFamily = t.config.xaxis.tooltip.style.fontFamily || t.config.chart.fontFamily, n.xaxisTooltipText.style.fontSize = t.config.xaxis.tooltip.style.fontSize, n.xaxisTooltip.appendChild(n.xaxisTooltipText));
    } }, { key: "drawYaxisTooltip", value: function() {
      for (var t = this.w, n = this.ttCtx, i = function(d) {
        var f = t.config.yaxis[d].opposite || t.config.yaxis[d].crosshairs.opposite;
        n.yaxisOffX = f ? t.globals.gridWidth + 1 : 1;
        var p = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(d, f ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
        t.globals.yAxisSameScaleIndices.map(function(S, C) {
          S.map(function(E, L) {
            L === d && (p += t.config.yaxis[L].show ? " " : " apexcharts-yaxistooltip-hidden");
          });
        });
        var y = t.globals.dom.elWrap;
        t.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(d)) === null && (n.yaxisTooltip = document.createElement("div"), n.yaxisTooltip.setAttribute("class", p + " apexcharts-theme-" + t.config.tooltip.theme), y.appendChild(n.yaxisTooltip), d === 0 && (n.yaxisTooltipText = []), n.yaxisTooltipText[d] = document.createElement("div"), n.yaxisTooltipText[d].classList.add("apexcharts-yaxistooltip-text"), n.yaxisTooltip.appendChild(n.yaxisTooltipText[d]));
      }, o = 0; o < t.config.yaxis.length; o++)
        i(o);
    } }, { key: "setXCrosshairWidth", value: function() {
      var t = this.w, n = this.ttCtx, i = n.getElXCrosshairs();
      if (n.xcrosshairsWidth = parseInt(t.config.xaxis.crosshairs.width, 10), t.globals.comboCharts) {
        var o = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
        if (o !== null && t.config.xaxis.crosshairs.width === "barWidth") {
          var d = parseFloat(o.getAttribute("barWidth"));
          n.xcrosshairsWidth = d;
        } else if (t.config.xaxis.crosshairs.width === "tickWidth") {
          var f = t.globals.labels.length;
          n.xcrosshairsWidth = t.globals.gridWidth / f;
        }
      } else if (t.config.xaxis.crosshairs.width === "tickWidth") {
        var p = t.globals.labels.length;
        n.xcrosshairsWidth = t.globals.gridWidth / p;
      } else if (t.config.xaxis.crosshairs.width === "barWidth") {
        var y = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
        if (y !== null) {
          var S = parseFloat(y.getAttribute("barWidth"));
          n.xcrosshairsWidth = S;
        } else
          n.xcrosshairsWidth = 1;
      }
      t.globals.isBarHorizontal && (n.xcrosshairsWidth = 0), i !== null && n.xcrosshairsWidth > 0 && i.setAttribute("width", n.xcrosshairsWidth);
    } }, { key: "handleYCrosshair", value: function() {
      var t = this.w, n = this.ttCtx;
      n.ycrosshairs = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), n.ycrosshairsHidden = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
    } }, { key: "drawYaxisTooltipText", value: function(t, n, i) {
      var o = this.ttCtx, d = this.w, f = d.globals.yLabelFormatters[t];
      if (o.yaxisTooltips[t]) {
        var p = o.getElGrid().getBoundingClientRect(), y = (n - p.top) * i.yRatio[t], S = d.globals.maxYArr[t] - d.globals.minYArr[t], C = d.globals.minYArr[t] + (S - y);
        o.tooltipPosition.moveYCrosshairs(n - p.top), o.yaxisTooltipText[t].innerHTML = f(C), o.tooltipPosition.moveYAxisTooltip(t);
      }
    } }]), B;
  }(), $n = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
      var n = this.w;
      this.tConfig = n.config.tooltip, this.tooltipUtil = new Ke(this), this.tooltipLabels = new Rt(this), this.tooltipPosition = new tn(this), this.marker = new bn(this), this.intersect = new Un(this), this.axesTooltip = new pr(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !n.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
    }
    return F(B, [{ key: "getElTooltip", value: function(t) {
      return t || (t = this), t.w.globals.dom.baseEl ? t.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
    } }, { key: "getElXCrosshairs", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
    } }, { key: "getElGrid", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
    } }, { key: "drawTooltip", value: function(t) {
      var n = this.w;
      this.xyRatios = t, this.isXAxisTooltipEnabled = n.config.xaxis.tooltip.enabled && n.globals.axisCharts, this.yaxisTooltips = n.config.yaxis.map(function(f, p) {
        return !!(f.show && f.tooltip.enabled && n.globals.axisCharts);
      }), this.allTooltipSeriesGroups = [], n.globals.axisCharts || (this.showTooltipTitle = !1);
      var i = document.createElement("div");
      if (i.classList.add("apexcharts-tooltip"), n.config.tooltip.cssClass && i.classList.add(n.config.tooltip.cssClass), i.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), n.globals.dom.elWrap.appendChild(i), n.globals.axisCharts) {
        this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
        var o = new Bt(this.ctx);
        this.xAxisTicksPositions = o.getXAxisTicksPositions();
      }
      if (!n.globals.comboCharts && !this.tConfig.intersect && n.config.chart.type !== "rangeBar" || this.tConfig.shared || (this.showOnIntersect = !0), n.config.markers.size !== 0 && n.globals.markers.largestSize !== 0 || this.marker.drawDynamicPoints(this), n.globals.collapsedSeries.length !== n.globals.series.length) {
        this.dataPointsDividedHeight = n.globals.gridHeight / n.globals.dataPoints, this.dataPointsDividedWidth = n.globals.gridWidth / n.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || n.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i.appendChild(this.tooltipTitle));
        var d = n.globals.series.length;
        (n.globals.xyCharts || n.globals.comboCharts) && this.tConfig.shared && (d = this.showOnIntersect ? 1 : n.globals.series.length), this.legendLabels = n.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(d), this.addSVGEvents();
      }
    } }, { key: "createTTElements", value: function(t) {
      for (var n = this, i = this.w, o = [], d = this.getElTooltip(), f = function(y) {
        var S = document.createElement("div");
        S.classList.add("apexcharts-tooltip-series-group"), S.style.order = i.config.tooltip.inverseOrder ? t - y : y + 1, n.tConfig.shared && n.tConfig.enabledOnSeries && Array.isArray(n.tConfig.enabledOnSeries) && n.tConfig.enabledOnSeries.indexOf(y) < 0 && S.classList.add("apexcharts-tooltip-series-group-hidden");
        var C = document.createElement("span");
        C.classList.add("apexcharts-tooltip-marker"), C.style.backgroundColor = i.globals.colors[y], S.appendChild(C);
        var E = document.createElement("div");
        E.classList.add("apexcharts-tooltip-text"), E.style.fontFamily = n.tConfig.style.fontFamily || i.config.chart.fontFamily, E.style.fontSize = n.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function(L) {
          var O = document.createElement("div");
          O.classList.add("apexcharts-tooltip-".concat(L, "-group"));
          var P = document.createElement("span");
          P.classList.add("apexcharts-tooltip-text-".concat(L, "-label")), O.appendChild(P);
          var I = document.createElement("span");
          I.classList.add("apexcharts-tooltip-text-".concat(L, "-value")), O.appendChild(I), E.appendChild(O);
        }), S.appendChild(E), d.appendChild(S), o.push(S);
      }, p = 0; p < t; p++)
        f(p);
      return o;
    } }, { key: "addSVGEvents", value: function() {
      var t = this.w, n = t.config.chart.type, i = this.getElTooltip(), o = !(n !== "bar" && n !== "candlestick" && n !== "boxPlot" && n !== "rangeBar"), d = n === "area" || n === "line" || n === "scatter" || n === "bubble" || n === "radar", f = t.globals.dom.Paper.node, p = this.getElGrid();
      p && (this.seriesBound = p.getBoundingClientRect());
      var y, S = [], C = [], E = { hoverArea: f, elGrid: p, tooltipEl: i, tooltipY: S, tooltipX: C, ttItems: this.ttItems };
      if (t.globals.axisCharts && (d ? y = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : o ? y = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : n !== "heatmap" && n !== "treemap" || (y = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), y && y.length))
        for (var L = 0; L < y.length; L++)
          S.push(y[L].getAttribute("cy")), C.push(y[L].getAttribute("cx"));
      if (t.globals.xyCharts && !this.showOnIntersect || t.globals.comboCharts && !this.showOnIntersect || o && this.tooltipUtil.hasBars() && this.tConfig.shared)
        this.addPathsEventListeners([f], E);
      else if (o && !t.globals.comboCharts || d && this.showOnIntersect)
        this.addDatapointEventsListeners(E);
      else if (!t.globals.axisCharts || n === "heatmap" || n === "treemap") {
        var O = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
        this.addPathsEventListeners(O, E);
      }
      if (this.showOnIntersect) {
        var P = t.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
        P.length > 0 && this.addPathsEventListeners(P, E), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(E);
      }
    } }, { key: "drawFixedTooltipRect", value: function() {
      var t = this.w, n = this.getElTooltip(), i = n.getBoundingClientRect(), o = i.width + 10, d = i.height + 10, f = this.tConfig.fixed.offsetX, p = this.tConfig.fixed.offsetY, y = this.tConfig.fixed.position.toLowerCase();
      return y.indexOf("right") > -1 && (f = f + t.globals.svgWidth - o + 10), y.indexOf("bottom") > -1 && (p = p + t.globals.svgHeight - d - 10), n.style.left = f + "px", n.style.top = p + "px", { x: f, y: p, ttWidth: o, ttHeight: d };
    } }, { key: "addDatapointEventsListeners", value: function(t) {
      var n = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
      this.addPathsEventListeners(n, t);
    } }, { key: "addPathsEventListeners", value: function(t, n) {
      for (var i = this, o = function(f) {
        var p = { paths: t[f], tooltipEl: n.tooltipEl, tooltipY: n.tooltipY, tooltipX: n.tooltipX, elGrid: n.elGrid, hoverArea: n.hoverArea, ttItems: n.ttItems };
        ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(y) {
          return t[f].addEventListener(y, i.onSeriesHover.bind(i, p), { capture: !1, passive: !0 });
        });
      }, d = 0; d < t.length; d++)
        o(d);
    } }, { key: "onSeriesHover", value: function(t, n) {
      var i = this, o = Date.now() - this.lastHoverTime;
      o >= 100 ? this.seriesHover(t, n) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
        i.seriesHover(t, n);
      }, 100 - o));
    } }, { key: "seriesHover", value: function(t, n) {
      var i = this;
      this.lastHoverTime = Date.now();
      var o = [], d = this.w;
      d.config.chart.group && (o = this.ctx.getGroupedCharts()), d.globals.axisCharts && (d.globals.minX === -1 / 0 && d.globals.maxX === 1 / 0 || d.globals.dataPoints === 0) || (o.length ? o.forEach(function(f) {
        var p = i.getElTooltip(f), y = { paths: t.paths, tooltipEl: p, tooltipY: t.tooltipY, tooltipX: t.tooltipX, elGrid: t.elGrid, hoverArea: t.hoverArea, ttItems: f.w.globals.tooltip.ttItems };
        f.w.globals.minX === i.w.globals.minX && f.w.globals.maxX === i.w.globals.maxX && f.w.globals.tooltip.seriesHoverByContext({ chartCtx: f, ttCtx: f.w.globals.tooltip, opt: y, e: n });
      }) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t, e: n }));
    } }, { key: "seriesHoverByContext", value: function(t) {
      var n = t.chartCtx, i = t.ttCtx, o = t.opt, d = t.e, f = n.w, p = this.getElTooltip();
      p && (i.tooltipRect = { x: 0, y: 0, ttWidth: p.getBoundingClientRect().width, ttHeight: p.getBoundingClientRect().height }, i.e = d, i.tooltipUtil.hasBars() && !f.globals.comboCharts && !i.isBarShared && this.tConfig.onDatasetHover.highlightDataSeries && new ot(n).toggleSeriesOnHover(d, d.target.parentNode), i.fixedTooltip && i.drawFixedTooltipRect(), f.globals.axisCharts ? i.axisChartsTooltips({ e: d, opt: o, tooltipRect: i.tooltipRect }) : i.nonAxisChartsTooltips({ e: d, opt: o, tooltipRect: i.tooltipRect }));
    } }, { key: "axisChartsTooltips", value: function(t) {
      var n, i, o = t.e, d = t.opt, f = this.w, p = d.elGrid.getBoundingClientRect(), y = o.type === "touchmove" ? o.touches[0].clientX : o.clientX, S = o.type === "touchmove" ? o.touches[0].clientY : o.clientY;
      if (this.clientY = S, this.clientX = y, f.globals.capturedSeriesIndex = -1, f.globals.capturedDataPointIndex = -1, S < p.top || S > p.top + p.height)
        this.handleMouseOut(d);
      else {
        if (Array.isArray(this.tConfig.enabledOnSeries) && !f.config.tooltip.shared) {
          var C = parseInt(d.paths.getAttribute("index"), 10);
          if (this.tConfig.enabledOnSeries.indexOf(C) < 0)
            return void this.handleMouseOut(d);
        }
        var E = this.getElTooltip(), L = this.getElXCrosshairs(), O = f.globals.xyCharts || f.config.chart.type === "bar" && !f.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || f.globals.comboCharts && this.tooltipUtil.hasBars();
        if (o.type === "mousemove" || o.type === "touchmove" || o.type === "mouseup") {
          if (f.globals.collapsedSeries.length + f.globals.ancillaryCollapsedSeries.length === f.globals.series.length)
            return;
          L !== null && L.classList.add("apexcharts-active");
          var P = this.yaxisTooltips.filter(function(V) {
            return V === !0;
          });
          if (this.ycrosshairs !== null && P.length && this.ycrosshairs.classList.add("apexcharts-active"), O && !this.showOnIntersect)
            this.handleStickyTooltip(o, y, S, d);
          else if (f.config.chart.type === "heatmap" || f.config.chart.type === "treemap") {
            var I = this.intersect.handleHeatTreeTooltip({ e: o, opt: d, x: n, y: i, type: f.config.chart.type });
            n = I.x, i = I.y, E.style.left = n + "px", E.style.top = i + "px";
          } else
            this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: o, opt: d }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({ e: o, opt: d, x: n, y: i });
          if (this.yaxisTooltips.length)
            for (var j = 0; j < f.config.yaxis.length; j++)
              this.axesTooltip.drawYaxisTooltipText(j, S, this.xyRatios);
          d.tooltipEl.classList.add("apexcharts-active");
        } else
          o.type !== "mouseout" && o.type !== "touchend" || this.handleMouseOut(d);
      }
    } }, { key: "nonAxisChartsTooltips", value: function(t) {
      var n = t.e, i = t.opt, o = t.tooltipRect, d = this.w, f = i.paths.getAttribute("rel"), p = this.getElTooltip(), y = d.globals.dom.elWrap.getBoundingClientRect();
      if (n.type === "mousemove" || n.type === "touchmove") {
        p.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: parseInt(f, 10) - 1, shared: !1 });
        var S = d.globals.clientX - y.left - o.ttWidth / 2, C = d.globals.clientY - y.top - o.ttHeight - 10;
        if (p.style.left = S + "px", p.style.top = C + "px", d.config.legend.tooltipHoverFormatter) {
          var E = f - 1, L = (0, d.config.legend.tooltipHoverFormatter)(this.legendLabels[E].getAttribute("data:default-text"), { seriesIndex: E, dataPointIndex: E, w: d });
          this.legendLabels[E].innerHTML = L;
        }
      } else
        n.type !== "mouseout" && n.type !== "touchend" || (p.classList.remove("apexcharts-active"), d.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(O) {
          var P = O.getAttribute("data:default-text");
          O.innerHTML = decodeURIComponent(P);
        }));
    } }, { key: "handleStickyTooltip", value: function(t, n, i, o) {
      var d = this.w, f = this.tooltipUtil.getNearestValues({ context: this, hoverArea: o.hoverArea, elGrid: o.elGrid, clientX: n, clientY: i }), p = f.j, y = f.capturedSeries;
      d.globals.collapsedSeriesIndices.includes(y) && (y = null);
      var S = o.elGrid.getBoundingClientRect();
      if (f.hoverX < 0 || f.hoverX > S.width)
        this.handleMouseOut(o);
      else if (y !== null)
        this.handleStickyCapturedSeries(t, y, o, p);
      else if (this.tooltipUtil.isXoverlap(p) || d.globals.isBarHorizontal) {
        var C = d.globals.series.findIndex(function(E, L) {
          return !d.globals.collapsedSeriesIndices.includes(L);
        });
        this.create(t, this, C, p, o.ttItems);
      }
    } }, { key: "handleStickyCapturedSeries", value: function(t, n, i, o) {
      var d = this.w;
      if (!this.tConfig.shared && d.globals.series[n][o] === null)
        return void this.handleMouseOut(i);
      if (d.globals.series[n][o] !== void 0)
        this.tConfig.shared && this.tooltipUtil.isXoverlap(o) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t, this, n, o, i.ttItems) : this.create(t, this, n, o, i.ttItems, !1);
      else if (this.tooltipUtil.isXoverlap(o)) {
        var f = d.globals.series.findIndex(function(p, y) {
          return !d.globals.collapsedSeriesIndices.includes(y);
        });
        this.create(t, this, f, o, i.ttItems);
      }
    } }, { key: "deactivateHoverFilter", value: function() {
      for (var t = this.w, n = new re(this.ctx), i = t.globals.dom.Paper.select(".apexcharts-bar-area"), o = 0; o < i.length; o++)
        n.pathMouseLeave(i[o]);
    } }, { key: "handleMouseOut", value: function(t) {
      var n = this.w, i = this.getElXCrosshairs();
      if (t.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), n.config.chart.type !== "bubble" && this.marker.resetPointsSize(), i !== null && i.classList.remove("apexcharts-active"), this.ycrosshairs !== null && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
        this.yaxisTTEls === null && (this.yaxisTTEls = n.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
        for (var o = 0; o < this.yaxisTTEls.length; o++)
          this.yaxisTTEls[o].classList.remove("apexcharts-active");
      }
      n.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(d) {
        var f = d.getAttribute("data:default-text");
        d.innerHTML = decodeURIComponent(f);
      });
    } }, { key: "markerClick", value: function(t, n, i) {
      var o = this.w;
      typeof o.config.chart.events.markerClick == "function" && o.config.chart.events.markerClick(t, this.ctx, { seriesIndex: n, dataPointIndex: i, w: o }), this.ctx.events.fireEvent("markerClick", [t, this.ctx, { seriesIndex: n, dataPointIndex: i, w: o }]);
    } }, { key: "create", value: function(t, n, i, o, d) {
      var f, p, y, S, C, E, L, O, P, I, j, V, Z, b, M, N, X = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, K = this.w, ee = n;
      t.type === "mouseup" && this.markerClick(t, i, o), X === null && (X = this.tConfig.shared);
      var oe = this.tooltipUtil.hasMarkers(i), de = this.tooltipUtil.getElBars();
      if (K.config.legend.tooltipHoverFormatter) {
        var ke = K.config.legend.tooltipHoverFormatter, _e = Array.from(this.legendLabels);
        _e.forEach(function(jr) {
          var Dn = jr.getAttribute("data:default-text");
          jr.innerHTML = decodeURIComponent(Dn);
        });
        for (var Me = 0; Me < _e.length; Me++) {
          var Ie = _e[Me], rt = parseInt(Ie.getAttribute("i"), 10), Qt = decodeURIComponent(Ie.getAttribute("data:default-text")), Kt = ke(Qt, { seriesIndex: X ? rt : i, dataPointIndex: o, w: K });
          if (X)
            Ie.innerHTML = K.globals.collapsedSeriesIndices.indexOf(rt) < 0 ? Kt : Qt;
          else if (Ie.innerHTML = rt === i ? Kt : Qt, i === rt)
            break;
        }
      }
      var mt = v(v({ ttItems: d, i, j: o }, ((f = K.globals.seriesRange) === null || f === void 0 || (p = f[i]) === null || p === void 0 || (y = p[o]) === null || y === void 0 || (S = y.y[0]) === null || S === void 0 ? void 0 : S.y1) !== void 0 && { y1: (C = K.globals.seriesRange) === null || C === void 0 || (E = C[i]) === null || E === void 0 || (L = E[o]) === null || L === void 0 || (O = L.y[0]) === null || O === void 0 ? void 0 : O.y1 }), ((P = K.globals.seriesRange) === null || P === void 0 || (I = P[i]) === null || I === void 0 || (j = I[o]) === null || j === void 0 || (V = j.y[0]) === null || V === void 0 ? void 0 : V.y2) !== void 0 && { y2: (Z = K.globals.seriesRange) === null || Z === void 0 || (b = Z[i]) === null || b === void 0 || (M = b[o]) === null || M === void 0 || (N = M.y[0]) === null || N === void 0 ? void 0 : N.y2 });
      if (X) {
        if (ee.tooltipLabels.drawSeriesTexts(v(v({}, mt), {}, { shared: !this.showOnIntersect && this.tConfig.shared })), oe)
          K.globals.markers.largestSize > 0 ? ee.marker.enlargePoints(o) : ee.tooltipPosition.moveDynamicPointsOnHover(o);
        else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(de), this.barSeriesHeight > 0)) {
          var Mn = new re(this.ctx), zn = K.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(o, "']"));
          this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(o, i);
          for (var gt = 0; gt < zn.length; gt++)
            Mn.pathMouseEnter(zn[gt]);
        }
      } else
        ee.tooltipLabels.drawSeriesTexts(v({ shared: !1 }, mt)), this.tooltipUtil.hasBars() && ee.tooltipPosition.moveStickyTooltipOverBars(o, i), oe && ee.tooltipPosition.moveMarkers(i, o);
    } }]), B;
  }(), ri = function() {
    function B(t) {
      A(this, B), this.w = t.w, this.barCtx = t, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
    }
    return F(B, [{ key: "handleBarDataLabels", value: function(t) {
      var n = t.x, i = t.y, o = t.y1, d = t.y2, f = t.i, p = t.j, y = t.realIndex, S = t.groupIndex, C = t.series, E = t.barHeight, L = t.barWidth, O = t.barXPosition, P = t.barYPosition, I = t.visibleSeries, j = t.renderedPath, V = this.w, Z = new re(this.barCtx.ctx), b = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[y] : this.barCtx.strokeWidth, M = n + parseFloat(L * I), N = i + parseFloat(E * I);
      V.globals.isXNumeric && !V.globals.isBarHorizontal && (M = n + parseFloat(L * (I + 1)), N = i + parseFloat(E * (I + 1)) - b);
      var X, K = null, ee = n, oe = i, de = {}, ke = V.config.dataLabels, _e = this.barCtx.barOptions.dataLabels, Me = this.barCtx.barOptions.dataLabels.total;
      P !== void 0 && this.barCtx.isRangeBar && (N = P, oe = P), O !== void 0 && this.barCtx.isVerticalGroupedRangeBar && (M = O, ee = O);
      var Ie = ke.offsetX, rt = ke.offsetY, Qt = { width: 0, height: 0 };
      if (V.config.dataLabels.enabled) {
        var Kt = this.barCtx.series[f][p];
        Qt = Z.getTextRects(V.globals.yLabelFormatters[0](Kt), parseFloat(ke.style.fontSize));
      }
      var mt = { x: n, y: i, i: f, j: p, realIndex: y, groupIndex: S || -1, renderedPath: j, bcx: M, bcy: N, barHeight: E, barWidth: L, textRects: Qt, strokeWidth: b, dataLabelsX: ee, dataLabelsY: oe, dataLabelsConfig: ke, barDataLabelsConfig: _e, barTotalDataLabelsConfig: Me, offX: Ie, offY: rt };
      return de = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(mt) : this.calculateColumnsDataLabelsPosition(mt), j.attr({ cy: de.bcy, cx: de.bcx, j: p, val: C[f][p], barHeight: E, barWidth: L }), X = this.drawCalculatedDataLabels({ x: de.dataLabelsX, y: de.dataLabelsY, val: this.barCtx.isRangeBar ? [o, d] : C[f][p], i: y, j: p, barWidth: L, barHeight: E, textRects: Qt, dataLabelsConfig: ke }), V.config.chart.stacked && Me.enabled && (K = this.drawTotalDataLabels({ x: de.totalDataLabelsX, y: de.totalDataLabelsY, realIndex: y, textAnchor: de.totalDataLabelsAnchor, val: this.getStackedTotalDataLabel({ realIndex: y, j: p }), dataLabelsConfig: ke, barTotalDataLabelsConfig: Me })), { dataLabels: X, totalDataLabels: K };
    } }, { key: "getStackedTotalDataLabel", value: function(t) {
      var n = t.realIndex, i = t.j, o = this.w, d = this.barCtx.stackedSeriesTotals[i];
      return this.totalFormatter && (d = this.totalFormatter(d, v(v({}, o), {}, { seriesIndex: n, dataPointIndex: i, w: o }))), d;
    } }, { key: "calculateColumnsDataLabelsPosition", value: function(t) {
      var n, i, o = this.w, d = t.i, f = t.j, p = t.realIndex, y = t.groupIndex, S = t.y, C = t.bcx, E = t.barWidth, L = t.barHeight, O = t.textRects, P = t.dataLabelsX, I = t.dataLabelsY, j = t.dataLabelsConfig, V = t.barDataLabelsConfig, Z = t.barTotalDataLabelsConfig, b = t.strokeWidth, M = t.offX, N = t.offY;
      L = Math.abs(L);
      var X = o.config.plotOptions.bar.dataLabels.orientation === "vertical";
      C = C - b / 2 + (y !== -1 ? y * E : 0);
      var K = o.globals.gridWidth / o.globals.dataPoints;
      this.barCtx.isVerticalGroupedRangeBar ? P += E / 2 : P = o.globals.isXNumeric ? C - E / 2 + M : C - K + E / 2 + M, X && (P = P + O.height / 2 - b / 2 - 2);
      var ee = this.barCtx.series[d][f] < 0, oe = S;
      switch (this.barCtx.isReversed && (oe = S - L + (ee ? 2 * L : 0), S -= L), V.position) {
        case "center":
          I = X ? ee ? oe + L / 2 + N : oe + L / 2 - N : ee ? oe - L / 2 + O.height / 2 + N : oe + L / 2 + O.height / 2 - N;
          break;
        case "bottom":
          I = X ? ee ? oe + L + N : oe + L - N : ee ? oe - L + O.height + b + N : oe + L - O.height / 2 + b - N;
          break;
        case "top":
          I = X ? ee ? oe + N : oe - N : ee ? oe - O.height / 2 - N : oe + O.height + N;
      }
      if (this.barCtx.lastActiveBarSerieIndex === p && Z.enabled) {
        var de = new re(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: p, j: f }), j.fontSize);
        n = ee ? oe - de.height / 2 - N - Z.offsetY + 18 : oe + de.height + N + Z.offsetY - 18, i = P + Z.offsetX;
      }
      return o.config.chart.stacked || (I < 0 ? I = 0 + b : I + O.height / 3 > o.globals.gridHeight && (I = o.globals.gridHeight - b)), { bcx: C, bcy: S, dataLabelsX: P, dataLabelsY: I, totalDataLabelsX: i, totalDataLabelsY: n, totalDataLabelsAnchor: "middle" };
    } }, { key: "calculateBarsDataLabelsPosition", value: function(t) {
      var n = this.w, i = t.x, o = t.i, d = t.j, f = t.realIndex, p = t.groupIndex, y = t.bcy, S = t.barHeight, C = t.barWidth, E = t.textRects, L = t.dataLabelsX, O = t.strokeWidth, P = t.dataLabelsConfig, I = t.barDataLabelsConfig, j = t.barTotalDataLabelsConfig, V = t.offX, Z = t.offY, b = n.globals.gridHeight / n.globals.dataPoints;
      C = Math.abs(C);
      var M, N, X = (y += p !== -1 ? p * S : 0) - (this.barCtx.isRangeBar ? 0 : b) + S / 2 + E.height / 2 + Z - 3, K = "start", ee = this.barCtx.series[o][d] < 0, oe = i;
      switch (this.barCtx.isReversed && (oe = i + C - (ee ? 2 * C : 0), i = n.globals.gridWidth - C), I.position) {
        case "center":
          L = ee ? oe + C / 2 - V : Math.max(E.width / 2, oe - C / 2) + V;
          break;
        case "bottom":
          L = ee ? oe + C - O - Math.round(E.width / 2) - V : oe - C + O + Math.round(E.width / 2) + V;
          break;
        case "top":
          L = ee ? oe - O + Math.round(E.width / 2) - V : oe - O - Math.round(E.width / 2) + V;
      }
      if (this.barCtx.lastActiveBarSerieIndex === f && j.enabled) {
        var de = new re(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: f, j: d }), P.fontSize);
        ee ? (M = oe - O + Math.round(de.width / 2) - V - j.offsetX - 15, K = "end") : M = oe - O - Math.round(de.width / 2) + V + j.offsetX + 15, N = X + j.offsetY;
      }
      return n.config.chart.stacked || (L < 0 ? L = L + E.width + O : L + E.width / 2 > n.globals.gridWidth && (L = n.globals.gridWidth - E.width - O)), { bcx: i, bcy: y, dataLabelsX: L, dataLabelsY: X, totalDataLabelsX: M, totalDataLabelsY: N, totalDataLabelsAnchor: K };
    } }, { key: "drawCalculatedDataLabels", value: function(t) {
      var n = t.x, i = t.y, o = t.val, d = t.i, f = t.j, p = t.textRects, y = t.barHeight, S = t.barWidth, C = t.dataLabelsConfig, E = this.w, L = "rotate(0)";
      E.config.plotOptions.bar.dataLabels.orientation === "vertical" && (L = "rotate(-90, ".concat(n, ", ").concat(i, ")"));
      var O = new jt(this.barCtx.ctx), P = new re(this.barCtx.ctx), I = C.formatter, j = null, V = E.globals.collapsedSeriesIndices.indexOf(d) > -1;
      if (C.enabled && !V) {
        j = P.group({ class: "apexcharts-data-labels", transform: L });
        var Z = "";
        o !== void 0 && (Z = I(o, v(v({}, E), {}, { seriesIndex: d, dataPointIndex: f, w: E }))), !o && E.config.plotOptions.bar.hideZeroBarsWhenGrouped && (Z = "");
        var b = E.globals.series[d][f] < 0, M = E.config.plotOptions.bar.dataLabels.position;
        E.config.plotOptions.bar.dataLabels.orientation === "vertical" && (M === "top" && (C.textAnchor = b ? "end" : "start"), M === "center" && (C.textAnchor = "middle"), M === "bottom" && (C.textAnchor = b ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && S < P.getTextRects(Z, parseFloat(C.style.fontSize)).width && (Z = ""), E.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? p.width / 1.6 > Math.abs(S) && (Z = "") : p.height / 1.6 > Math.abs(y) && (Z = ""));
        var N = v({}, C);
        this.barCtx.isHorizontal && o < 0 && (C.textAnchor === "start" ? N.textAnchor = "end" : C.textAnchor === "end" && (N.textAnchor = "start")), O.plotDataLabelsText({ x: n, y: i, text: Z, i: d, j: f, parent: j, dataLabelsConfig: N, alwaysDrawDataLabel: !0, offsetCorrection: !0 });
      }
      return j;
    } }, { key: "drawTotalDataLabels", value: function(t) {
      var n, i = t.x, o = t.y, d = t.val, f = t.realIndex, p = t.textAnchor, y = t.barTotalDataLabelsConfig, S = new re(this.barCtx.ctx);
      return y.enabled && i !== void 0 && o !== void 0 && this.barCtx.lastActiveBarSerieIndex === f && (n = S.drawText({ x: i, y: o, foreColor: y.style.color, text: d, textAnchor: p, fontFamily: y.style.fontFamily, fontSize: y.style.fontSize, fontWeight: y.style.fontWeight })), n;
    } }]), B;
  }(), Ln = function() {
    function B(t) {
      A(this, B), this.w = t.w, this.barCtx = t;
    }
    return F(B, [{ key: "initVariables", value: function(t) {
      var n = this.w;
      this.barCtx.series = t, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
      for (var i = 0; i < t.length; i++)
        if (t[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t[i].length), n.globals.isXNumeric)
          for (var o = 0; o < t[i].length; o++)
            n.globals.seriesX[i][o] > n.globals.minX && n.globals.seriesX[i][o] < n.globals.maxX && this.barCtx.visibleItems++;
        else
          this.barCtx.visibleItems = n.globals.dataPoints;
      this.barCtx.seriesLen === 0 && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], n.globals.comboCharts || this.checkZeroSeries({ series: t });
    } }, { key: "initialPositions", value: function() {
      var t, n, i, o, d, f, p, y, S = this.w, C = S.globals.dataPoints;
      this.barCtx.isRangeBar && (C = S.globals.labels.length);
      var E = this.barCtx.seriesLen;
      if (S.config.plotOptions.bar.rangeBarGroupRows && (E = 1), this.barCtx.isHorizontal)
        d = (i = S.globals.gridHeight / C) / E, S.globals.isXNumeric && (d = (i = S.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), d = d * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, String(this.barCtx.barOptions.barHeight).indexOf("%") === -1 && (d = parseInt(this.barCtx.barOptions.barHeight, 10)), y = this.barCtx.baseLineInvertedY + S.globals.padHorizontal + (this.barCtx.isReversed ? S.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (y = S.globals.gridWidth / 2), n = (i - d * this.barCtx.seriesLen) / 2;
      else {
        if (o = S.globals.gridWidth / this.barCtx.visibleItems, S.config.xaxis.convertedCatToNumeric && (o = S.globals.gridWidth / S.globals.dataPoints), f = o / E * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, S.globals.isXNumeric) {
          var L = this.barCtx.xRatio;
          S.config.xaxis.convertedCatToNumeric && (L = this.barCtx.initialXRatio), S.globals.minXDiff && S.globals.minXDiff !== 0.5 && S.globals.minXDiff / L > 0 && (o = S.globals.minXDiff / L), (f = o / E * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (f = 1);
        }
        String(this.barCtx.barOptions.columnWidth).indexOf("%") === -1 && (f = parseInt(this.barCtx.barOptions.columnWidth, 10)), p = S.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? S.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), t = S.globals.padHorizontal + (o - f * this.barCtx.seriesLen) / 2;
      }
      return { x: t, y: n, yDivision: i, xDivision: o, barHeight: d, barWidth: f, zeroH: p, zeroW: y };
    } }, { key: "initializeStackedPrevVars", value: function(t) {
      var n = t.w;
      n.globals.hasSeriesGroups ? n.globals.seriesGroups.forEach(function(i) {
        t[i] || (t[i] = {}), t[i].prevY = [], t[i].prevX = [], t[i].prevYF = [], t[i].prevXF = [], t[i].prevYVal = [], t[i].prevXVal = [];
      }) : (t.prevY = [], t.prevX = [], t.prevYF = [], t.prevXF = [], t.prevYVal = [], t.prevXVal = []);
    } }, { key: "initializeStackedXYVars", value: function(t) {
      var n = t.w;
      n.globals.hasSeriesGroups ? n.globals.seriesGroups.forEach(function(i) {
        t[i] || (t[i] = {}), t[i].xArrj = [], t[i].xArrjF = [], t[i].xArrjVal = [], t[i].yArrj = [], t[i].yArrjF = [], t[i].yArrjVal = [];
      }) : (t.xArrj = [], t.xArrjF = [], t.xArrjVal = [], t.yArrj = [], t.yArrjF = [], t.yArrjVal = []);
    } }, { key: "getPathFillColor", value: function(t, n, i, o) {
      var d, f, p, y, S = this.w, C = new Je(this.barCtx.ctx), E = null, L = this.barCtx.barOptions.distributed ? i : n;
      return this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(O) {
        t[n][i] >= O.from && t[n][i] <= O.to && (E = O.color);
      }), S.config.series[n].data[i] && S.config.series[n].data[i].fillColor && (E = S.config.series[n].data[i].fillColor), C.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? L : o, dataPointIndex: i, color: E, value: t[n][i], fillConfig: (d = S.config.series[n].data[i]) === null || d === void 0 ? void 0 : d.fill, fillType: (f = S.config.series[n].data[i]) !== null && f !== void 0 && (p = f.fill) !== null && p !== void 0 && p.type ? (y = S.config.series[n].data[i]) === null || y === void 0 ? void 0 : y.fill.type : S.config.fill.type });
    } }, { key: "getStrokeWidth", value: function(t, n, i) {
      var o = 0, d = this.w;
      return this.barCtx.series[t][n] ? this.barCtx.isNullValue = !1 : this.barCtx.isNullValue = !0, d.config.stroke.show && (this.barCtx.isNullValue || (o = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)), o;
    } }, { key: "shouldApplyRadius", value: function(t) {
      var n = this.w, i = !1;
      return n.config.plotOptions.bar.borderRadius > 0 && (n.config.chart.stacked && n.config.plotOptions.bar.borderRadiusWhenStacked === "last" ? this.barCtx.lastActiveBarSerieIndex === t && (i = !0) : i = !0), i;
    } }, { key: "barBackground", value: function(t) {
      var n = t.j, i = t.i, o = t.x1, d = t.x2, f = t.y1, p = t.y2, y = t.elSeries, S = this.w, C = new re(this.barCtx.ctx), E = new ot(this.barCtx.ctx).getActiveConfigSeriesIndex();
      if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && E === i) {
        n >= this.barCtx.barOptions.colors.backgroundBarColors.length && (n %= this.barCtx.barOptions.colors.backgroundBarColors.length);
        var L = this.barCtx.barOptions.colors.backgroundBarColors[n], O = C.drawRect(o !== void 0 ? o : 0, f !== void 0 ? f : 0, d !== void 0 ? d : S.globals.gridWidth, p !== void 0 ? p : S.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, L, this.barCtx.barOptions.colors.backgroundBarOpacity);
        y.add(O), O.node.classList.add("apexcharts-backgroundBar");
      }
    } }, { key: "getColumnPaths", value: function(t) {
      var n, i = t.barWidth, o = t.barXPosition, d = t.y1, f = t.y2, p = t.strokeWidth, y = t.seriesGroup, S = t.realIndex, C = t.i, E = t.j, L = t.w, O = new re(this.barCtx.ctx);
      (p = Array.isArray(p) ? p[S] : p) || (p = 0);
      var P = i, I = o;
      (n = L.config.series[S].data[E]) !== null && n !== void 0 && n.columnWidthOffset && (I = o - L.config.series[S].data[E].columnWidthOffset / 2, P = i + L.config.series[S].data[E].columnWidthOffset);
      var j = I, V = I + P;
      d += 1e-3, f += 1e-3;
      var Z = O.move(j, d), b = O.move(j, d), M = O.line(V - p, d);
      if (L.globals.previousPaths.length > 0 && (b = this.barCtx.getPreviousPath(S, E, !1)), Z = Z + O.line(j, f) + O.line(V - p, f) + O.line(V - p, d) + (L.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), b = b + O.line(j, d) + M + M + M + M + M + O.line(j, d) + (L.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), this.shouldApplyRadius(S) && (Z = O.roundPathCorners(Z, L.config.plotOptions.bar.borderRadius)), L.config.chart.stacked) {
        var N = this.barCtx;
        L.globals.hasSeriesGroups && y && (N = this.barCtx[y]), N.yArrj.push(f), N.yArrjF.push(Math.abs(d - f)), N.yArrjVal.push(this.barCtx.series[C][E]);
      }
      return { pathTo: Z, pathFrom: b };
    } }, { key: "getBarpaths", value: function(t) {
      var n, i = t.barYPosition, o = t.barHeight, d = t.x1, f = t.x2, p = t.strokeWidth, y = t.seriesGroup, S = t.realIndex, C = t.i, E = t.j, L = t.w, O = new re(this.barCtx.ctx);
      (p = Array.isArray(p) ? p[S] : p) || (p = 0);
      var P = i, I = o;
      (n = L.config.series[S].data[E]) !== null && n !== void 0 && n.barHeightOffset && (P = i - L.config.series[S].data[E].barHeightOffset / 2, I = o + L.config.series[S].data[E].barHeightOffset);
      var j = P, V = P + I;
      d += 1e-3, f += 1e-3;
      var Z = O.move(d, j), b = O.move(d, j);
      L.globals.previousPaths.length > 0 && (b = this.barCtx.getPreviousPath(S, E, !1));
      var M = O.line(d, V - p);
      if (Z = Z + O.line(f, j) + O.line(f, V - p) + M + (L.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), b = b + O.line(d, j) + M + M + M + M + M + O.line(d, j) + (L.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), this.shouldApplyRadius(S) && (Z = O.roundPathCorners(Z, L.config.plotOptions.bar.borderRadius)), L.config.chart.stacked) {
        var N = this.barCtx;
        L.globals.hasSeriesGroups && y && (N = this.barCtx[y]), N.xArrj.push(f), N.xArrjF.push(Math.abs(d - f)), N.xArrjVal.push(this.barCtx.series[C][E]);
      }
      return { pathTo: Z, pathFrom: b };
    } }, { key: "checkZeroSeries", value: function(t) {
      for (var n = t.series, i = this.w, o = 0; o < n.length; o++) {
        for (var d = 0, f = 0; f < n[i.globals.maxValsInArrayIndex].length; f++)
          d += n[o][f];
        d === 0 && this.barCtx.zeroSerieses.push(o);
      }
    } }, { key: "getXForValue", value: function(t, n) {
      var i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2] ? n : null;
      return t != null && (i = n + t / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t / this.barCtx.invertedYRatio : 0)), i;
    } }, { key: "getYForValue", value: function(t, n) {
      var i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2] ? n : null;
      return t != null && (i = n - t / this.barCtx.yRatio[this.barCtx.yaxisIndex] + 2 * (this.barCtx.isReversed ? t / this.barCtx.yRatio[this.barCtx.yaxisIndex] : 0)), i;
    } }, { key: "getGoalValues", value: function(t, n, i, o, d) {
      var f = this, p = this.w, y = [], S = function(L, O) {
        var P;
        y.push((H(P = {}, t, t === "x" ? f.getXForValue(L, n, !1) : f.getYForValue(L, i, !1)), H(P, "attrs", O), P));
      };
      if (p.globals.seriesGoals[o] && p.globals.seriesGoals[o][d] && Array.isArray(p.globals.seriesGoals[o][d]) && p.globals.seriesGoals[o][d].forEach(function(L) {
        S(L.value, L);
      }), this.barCtx.barOptions.isDumbbell && p.globals.seriesRange.length) {
        var C = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : p.globals.colors, E = { strokeHeight: t === "x" ? 0 : p.globals.markers.size[o], strokeWidth: t === "x" ? p.globals.markers.size[o] : 0, strokeDashArray: 0, strokeLineCap: "round", strokeColor: Array.isArray(C[o]) ? C[o][0] : C[o] };
        S(p.globals.seriesRangeStart[o][d], E), S(p.globals.seriesRangeEnd[o][d], v(v({}, E), {}, { strokeColor: Array.isArray(C[o]) ? C[o][1] : C[o] }));
      }
      return y;
    } }, { key: "drawGoalLine", value: function(t) {
      var n = t.barXPosition, i = t.barYPosition, o = t.goalX, d = t.goalY, f = t.barWidth, p = t.barHeight, y = new re(this.barCtx.ctx), S = y.group({ className: "apexcharts-bar-goals-groups" });
      S.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({ el: S.node }), S.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
      var C = null;
      return this.barCtx.isHorizontal ? Array.isArray(o) && o.forEach(function(E) {
        var L = E.attrs.strokeHeight !== void 0 ? E.attrs.strokeHeight : p / 2, O = i + L + p / 2;
        C = y.drawLine(E.x, O - 2 * L, E.x, O, E.attrs.strokeColor ? E.attrs.strokeColor : void 0, E.attrs.strokeDashArray, E.attrs.strokeWidth ? E.attrs.strokeWidth : 2, E.attrs.strokeLineCap), S.add(C);
      }) : Array.isArray(d) && d.forEach(function(E) {
        var L = E.attrs.strokeWidth !== void 0 ? E.attrs.strokeWidth : f / 2, O = n + L + f / 2;
        C = y.drawLine(O - 2 * L, E.y, O, E.y, E.attrs.strokeColor ? E.attrs.strokeColor : void 0, E.attrs.strokeDashArray, E.attrs.strokeHeight ? E.attrs.strokeHeight : 2, E.attrs.strokeLineCap), S.add(C);
      }), S;
    } }, { key: "drawBarShadow", value: function(t) {
      var n = t.prevPaths, i = t.currPaths, o = t.color, d = this.w, f = n.x, p = n.x1, y = n.barYPosition, S = i.x, C = i.x1, E = i.barYPosition, L = y + i.barHeight, O = new re(this.barCtx.ctx), P = new Q(), I = O.move(p, L) + O.line(f, L) + O.line(S, E) + O.line(C, E) + O.line(p, L) + (d.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z");
      return O.drawPath({ d: I, fill: P.shadeColor(0.5, Q.rgb2hex(o)), stroke: "none", strokeWidth: 0, fillOpacity: 1, classes: "apexcharts-bar-shadows" });
    } }]), B;
  }(), gr = function() {
    function B(t, n) {
      A(this, B), this.ctx = t, this.w = t.w;
      var i = this.w;
      this.barOptions = i.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = i.config.stroke.width, this.isNullValue = !1, this.isRangeBar = i.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !i.globals.isBarHorizontal && i.globals.seriesRange.length && i.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = n, this.xyRatios !== null && (this.xRatio = n.xRatio, this.initialXRatio = n.initialXRatio, this.yRatio = n.yRatio, this.invertedXRatio = n.invertedXRatio, this.invertedYRatio = n.invertedYRatio, this.baseLineY = n.baseLineY, this.baseLineInvertedY = n.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.pathArr = [];
      var o = new ot(this.ctx);
      this.lastActiveBarSerieIndex = o.getActiveConfigSeriesIndex("desc", ["bar", "column"]);
      var d = o.getBarSeriesIndices(), f = new ve(this.ctx);
      this.stackedSeriesTotals = f.getStackedSeriesTotals(this.w.config.series.map(function(p, y) {
        return d.indexOf(y) === -1 ? y : -1;
      }).filter(function(p) {
        return p !== -1;
      })), this.barHelpers = new Ln(this);
    }
    return F(B, [{ key: "draw", value: function(t, n) {
      var i = this.w, o = new re(this.ctx), d = new ve(this.ctx, i);
      t = d.getLogSeries(t), this.series = t, this.yRatio = d.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t);
      var f = o.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
      i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.");
      for (var p = 0, y = 0; p < t.length; p++, y++) {
        var S, C, E, L, O = void 0, P = void 0, I = [], j = [], V = i.globals.comboCharts ? n[p] : p, Z = o.group({ class: "apexcharts-series", rel: p + 1, seriesName: Q.escapeString(i.globals.seriesNames[V]), "data:realIndex": V });
        this.ctx.series.addCollapsedClassToSeries(Z, V), t[p].length > 0 && (this.visibleI = this.visibleI + 1);
        var b = 0, M = 0;
        this.yRatio.length > 1 && (this.yaxisIndex = V), this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
        var N = this.barHelpers.initialPositions();
        P = N.y, b = N.barHeight, C = N.yDivision, L = N.zeroW, O = N.x, M = N.barWidth, S = N.xDivision, E = N.zeroH, this.horizontal || j.push(O + M / 2);
        var X = o.group({ class: "apexcharts-datalabels", "data:realIndex": V });
        i.globals.delayedElements.push({ el: X.node }), X.node.classList.add("apexcharts-element-hidden");
        var K = o.group({ class: "apexcharts-bar-goals-markers" }), ee = o.group({ class: "apexcharts-bar-shadows" });
        i.globals.delayedElements.push({ el: ee.node }), ee.node.classList.add("apexcharts-element-hidden");
        for (var oe = 0; oe < i.globals.dataPoints; oe++) {
          var de = this.barHelpers.getStrokeWidth(p, oe, V), ke = null, _e = { indexes: { i: p, j: oe, realIndex: V, bc: y }, x: O, y: P, strokeWidth: de, elSeries: Z };
          this.isHorizontal ? (ke = this.drawBarPaths(v(v({}, _e), {}, { barHeight: b, zeroW: L, yDivision: C })), M = this.series[p][oe] / this.invertedYRatio) : (ke = this.drawColumnPaths(v(v({}, _e), {}, { xDivision: S, barWidth: M, zeroH: E })), b = this.series[p][oe] / this.yRatio[this.yaxisIndex]);
          var Me = this.barHelpers.getPathFillColor(t, p, oe, V);
          if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && oe > 0) {
            var Ie = this.barHelpers.drawBarShadow({ color: typeof Me == "string" && (Me == null ? void 0 : Me.indexOf("url")) === -1 ? Me : Q.hexToRgba(i.globals.colors[p]), prevPaths: this.pathArr[this.pathArr.length - 1], currPaths: ke });
            Ie && ee.add(Ie);
          }
          this.pathArr.push(ke);
          var rt = this.barHelpers.drawGoalLine({ barXPosition: ke.barXPosition, barYPosition: ke.barYPosition, goalX: ke.goalX, goalY: ke.goalY, barHeight: b, barWidth: M });
          rt && K.add(rt), P = ke.y, O = ke.x, oe > 0 && j.push(O + M / 2), I.push(P), this.renderSeries({ realIndex: V, pathFill: Me, j: oe, i: p, pathFrom: ke.pathFrom, pathTo: ke.pathTo, strokeWidth: de, elSeries: Z, x: O, y: P, series: t, barHeight: ke.barHeight ? ke.barHeight : b, barWidth: ke.barWidth ? ke.barWidth : M, elDataLabelsWrap: X, elGoalsMarkers: K, elBarShadows: ee, visibleSeries: this.visibleI, type: "bar" });
        }
        i.globals.seriesXvalues[V] = j, i.globals.seriesYvalues[V] = I, f.add(Z);
      }
      return f;
    } }, { key: "renderSeries", value: function(t) {
      var n = t.realIndex, i = t.pathFill, o = t.lineFill, d = t.j, f = t.i, p = t.groupIndex, y = t.pathFrom, S = t.pathTo, C = t.strokeWidth, E = t.elSeries, L = t.x, O = t.y, P = t.y1, I = t.y2, j = t.series, V = t.barHeight, Z = t.barWidth, b = t.barXPosition, M = t.barYPosition, N = t.elDataLabelsWrap, X = t.elGoalsMarkers, K = t.elBarShadows, ee = t.visibleSeries, oe = t.type, de = this.w, ke = new re(this.ctx);
      o || (o = this.barOptions.distributed ? de.globals.stroke.colors[d] : de.globals.stroke.colors[n]), de.config.series[f].data[d] && de.config.series[f].data[d].strokeColor && (o = de.config.series[f].data[d].strokeColor), this.isNullValue && (i = "none");
      var _e = d / de.config.chart.animations.animateGradually.delay * (de.config.chart.animations.speed / de.globals.dataPoints) / 2.4, Me = ke.renderPaths({ i: f, j: d, realIndex: n, pathFrom: y, pathTo: S, stroke: o, strokeWidth: C, strokeLineCap: de.config.stroke.lineCap, fill: i, animationDelay: _e, initialSpeed: de.config.chart.animations.speed, dataChangeSpeed: de.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(oe, "-area") });
      Me.attr("clip-path", "url(#gridRectMask".concat(de.globals.cuid, ")"));
      var Ie = de.config.forecastDataPoints;
      Ie.count > 0 && d >= de.globals.dataPoints - Ie.count && (Me.node.setAttribute("stroke-dasharray", Ie.dashArray), Me.node.setAttribute("stroke-width", Ie.strokeWidth), Me.node.setAttribute("fill-opacity", Ie.fillOpacity)), P !== void 0 && I !== void 0 && (Me.attr("data-range-y1", P), Me.attr("data-range-y2", I)), new Ee(this.ctx).setSelectionFilter(Me, n, d), E.add(Me);
      var rt = new ri(this).handleBarDataLabels({ x: L, y: O, y1: P, y2: I, i: f, j: d, series: j, realIndex: n, groupIndex: p, barHeight: V, barWidth: Z, barXPosition: b, barYPosition: M, renderedPath: Me, visibleSeries: ee });
      return rt.dataLabels !== null && N.add(rt.dataLabels), rt.totalDataLabels && N.add(rt.totalDataLabels), E.add(N), X && E.add(X), K && E.add(K), E;
    } }, { key: "drawBarPaths", value: function(t) {
      var n, i = t.indexes, o = t.barHeight, d = t.strokeWidth, f = t.zeroW, p = t.x, y = t.y, S = t.yDivision, C = t.elSeries, E = this.w, L = i.i, O = i.j;
      if (E.globals.isXNumeric)
        n = (y = (E.globals.seriesX[L][O] - E.globals.minX) / this.invertedXRatio - o) + o * this.visibleI;
      else if (E.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
        var P = 0, I = 0;
        E.globals.seriesPercent.forEach(function(V, Z) {
          V[O] && P++, Z < L && V[O] === 0 && I++;
        }), P > 0 && (o = this.seriesLen * o / P), n = y + o * this.visibleI, n -= o * I;
      } else
        n = y + o * this.visibleI;
      this.isFunnel && (f -= (this.barHelpers.getXForValue(this.series[L][O], f) - f) / 2), p = this.barHelpers.getXForValue(this.series[L][O], f);
      var j = this.barHelpers.getBarpaths({ barYPosition: n, barHeight: o, x1: f, x2: p, strokeWidth: d, series: this.series, realIndex: i.realIndex, i: L, j: O, w: E });
      return E.globals.isXNumeric || (y += S), this.barHelpers.barBackground({ j: O, i: L, y1: n - o * this.visibleI, y2: o * this.seriesLen, elSeries: C }), { pathTo: j.pathTo, pathFrom: j.pathFrom, x1: f, x: p, y, goalX: this.barHelpers.getGoalValues("x", f, null, L, O), barYPosition: n, barHeight: o };
    } }, { key: "drawColumnPaths", value: function(t) {
      var n, i = t.indexes, o = t.x, d = t.y, f = t.xDivision, p = t.barWidth, y = t.zeroH, S = t.strokeWidth, C = t.elSeries, E = this.w, L = i.realIndex, O = i.i, P = i.j, I = i.bc;
      if (E.globals.isXNumeric) {
        var j = L;
        E.globals.seriesX[L].length || (j = E.globals.maxValsInArrayIndex), E.globals.seriesX[j][P] && (o = (E.globals.seriesX[j][P] - E.globals.minX) / this.xRatio - p * this.seriesLen / 2), n = o + p * this.visibleI;
      } else if (E.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
        var V = 0, Z = 0;
        E.globals.seriesPercent.forEach(function(M, N) {
          M[P] && V++, N < O && M[P] === 0 && Z++;
        }), V > 0 && (p = this.seriesLen * p / V), n = o + p * this.visibleI, n -= p * Z;
      } else
        n = o + p * this.visibleI;
      d = this.barHelpers.getYForValue(this.series[O][P], y);
      var b = this.barHelpers.getColumnPaths({ barXPosition: n, barWidth: p, y1: y, y2: d, strokeWidth: S, series: this.series, realIndex: i.realIndex, i: O, j: P, w: E });
      return E.globals.isXNumeric || (o += f), this.barHelpers.barBackground({ bc: I, j: P, i: O, x1: n - S / 2 - p * this.visibleI, x2: p * this.seriesLen + S / 2, elSeries: C }), { pathTo: b.pathTo, pathFrom: b.pathFrom, x: o, y: d, goalY: this.barHelpers.getGoalValues("y", null, y, O, P), barXPosition: n, barWidth: p };
    } }, { key: "getPreviousPath", value: function(t, n) {
      for (var i, o = this.w, d = 0; d < o.globals.previousPaths.length; d++) {
        var f = o.globals.previousPaths[d];
        f.paths && f.paths.length > 0 && parseInt(f.realIndex, 10) === parseInt(t, 10) && o.globals.previousPaths[d].paths[n] !== void 0 && (i = o.globals.previousPaths[d].paths[n].d);
      }
      return i;
    } }]), B;
  }(), kn = function(B) {
    U(n, gr);
    var t = se(n);
    function n() {
      return A(this, n), t.apply(this, arguments);
    }
    return F(n, [{ key: "draw", value: function(i, o) {
      var d = this, f = this.w;
      this.graphics = new re(this.ctx), this.bar = new gr(this.ctx, this.xyRatios);
      var p = new ve(this.ctx, f);
      i = p.getLogSeries(i), this.yRatio = p.getLogYRatios(this.yRatio), this.barHelpers.initVariables(i), f.config.chart.stackType === "100%" && (i = f.globals.seriesPercent.slice()), this.series = i, this.barHelpers.initializeStackedPrevVars(this);
      for (var y = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), S = 0, C = 0, E = function(P, I) {
        var j = void 0, V = void 0, Z = void 0, b = void 0, M = -1;
        d.groupCtx = d, f.globals.seriesGroups.forEach(function(zn, gt) {
          zn.indexOf(f.config.series[P].name) > -1 && (M = gt);
        }), M !== -1 && (d.groupCtx = d[f.globals.seriesGroups[M]]);
        var N = [], X = [], K = f.globals.comboCharts ? o[P] : P;
        d.yRatio.length > 1 && (d.yaxisIndex = K), d.isReversed = f.config.yaxis[d.yaxisIndex] && f.config.yaxis[d.yaxisIndex].reversed;
        var ee = d.graphics.group({ class: "apexcharts-series", seriesName: Q.escapeString(f.globals.seriesNames[K]), rel: P + 1, "data:realIndex": K });
        d.ctx.series.addCollapsedClassToSeries(ee, K);
        var oe = d.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": K }), de = d.graphics.group({ class: "apexcharts-bar-goals-markers" }), ke = 0, _e = 0, Me = d.initialPositions(S, C, j, V, Z, b);
        C = Me.y, ke = Me.barHeight, V = Me.yDivision, b = Me.zeroW, S = Me.x, _e = Me.barWidth, j = Me.xDivision, Z = Me.zeroH, d.barHelpers.initializeStackedXYVars(d), d.groupCtx.prevY.length === 1 && d.groupCtx.prevY[0].every(function(zn) {
          return isNaN(zn);
        }) && (d.groupCtx.prevY[0] = d.groupCtx.prevY[0].map(function(zn) {
          return Z;
        }), d.groupCtx.prevYF[0] = d.groupCtx.prevYF[0].map(function(zn) {
          return 0;
        }));
        for (var Ie = 0; Ie < f.globals.dataPoints; Ie++) {
          var rt = d.barHelpers.getStrokeWidth(P, Ie, K), Qt = { indexes: { i: P, j: Ie, realIndex: K, bc: I }, strokeWidth: rt, x: S, y: C, elSeries: ee, groupIndex: M, seriesGroup: f.globals.seriesGroups[M] }, Kt = null;
          d.isHorizontal ? (Kt = d.drawStackedBarPaths(v(v({}, Qt), {}, { zeroW: b, barHeight: ke, yDivision: V })), _e = d.series[P][Ie] / d.invertedYRatio) : (Kt = d.drawStackedColumnPaths(v(v({}, Qt), {}, { xDivision: j, barWidth: _e, zeroH: Z })), ke = d.series[P][Ie] / d.yRatio[d.yaxisIndex]);
          var mt = d.barHelpers.drawGoalLine({ barXPosition: Kt.barXPosition, barYPosition: Kt.barYPosition, goalX: Kt.goalX, goalY: Kt.goalY, barHeight: ke, barWidth: _e });
          mt && de.add(mt), C = Kt.y, S = Kt.x, N.push(S), X.push(C);
          var Mn = d.barHelpers.getPathFillColor(i, P, Ie, K);
          ee = d.renderSeries({ realIndex: K, pathFill: Mn, j: Ie, i: P, groupIndex: M, pathFrom: Kt.pathFrom, pathTo: Kt.pathTo, strokeWidth: rt, elSeries: ee, x: S, y: C, series: i, barHeight: ke, barWidth: _e, elDataLabelsWrap: oe, elGoalsMarkers: de, type: "bar", visibleSeries: 0 });
        }
        f.globals.seriesXvalues[K] = N, f.globals.seriesYvalues[K] = X, d.groupCtx.prevY.push(d.groupCtx.yArrj), d.groupCtx.prevYF.push(d.groupCtx.yArrjF), d.groupCtx.prevYVal.push(d.groupCtx.yArrjVal), d.groupCtx.prevX.push(d.groupCtx.xArrj), d.groupCtx.prevXF.push(d.groupCtx.xArrjF), d.groupCtx.prevXVal.push(d.groupCtx.xArrjVal), y.add(ee);
      }, L = 0, O = 0; L < i.length; L++, O++)
        E(L, O);
      return y;
    } }, { key: "initialPositions", value: function(i, o, d, f, p, y) {
      var S, C, E, L, O = this.w;
      return this.isHorizontal ? (E = (E = f = O.globals.gridHeight / O.globals.dataPoints) * parseInt(O.config.plotOptions.bar.barHeight, 10) / 100, String(O.config.plotOptions.bar.barHeight).indexOf("%") === -1 && (E = parseInt(O.config.plotOptions.bar.barHeight, 10)), y = this.baseLineInvertedY + O.globals.padHorizontal + (this.isReversed ? O.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), o = (f - E) / 2) : (L = d = O.globals.gridWidth / O.globals.dataPoints, L = O.globals.isXNumeric && O.globals.dataPoints > 1 ? (d = O.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : L * parseInt(O.config.plotOptions.bar.columnWidth, 10) / 100, String(O.config.plotOptions.bar.columnWidth).indexOf("%") === -1 && (L = parseInt(O.config.plotOptions.bar.columnWidth, 10)), p = O.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? O.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), i = O.globals.padHorizontal + (d - L) / 2), { x: i, y: o, yDivision: f, xDivision: d, barHeight: (S = O.globals.seriesGroups) !== null && S !== void 0 && S.length ? E / O.globals.seriesGroups.length : E, barWidth: (C = O.globals.seriesGroups) !== null && C !== void 0 && C.length ? L / O.globals.seriesGroups.length : L, zeroH: p, zeroW: y };
    } }, { key: "drawStackedBarPaths", value: function(i) {
      for (var o, d = i.indexes, f = i.barHeight, p = i.strokeWidth, y = i.zeroW, S = i.x, C = i.y, E = i.groupIndex, L = i.seriesGroup, O = i.yDivision, P = i.elSeries, I = this.w, j = C + (E !== -1 ? E * f : 0), V = d.i, Z = d.j, b = 0, M = 0; M < this.groupCtx.prevXF.length; M++)
        b += this.groupCtx.prevXF[M][Z];
      var N = V;
      if (L && (N = L.indexOf(I.config.series[V].name)), N > 0) {
        var X = y;
        this.groupCtx.prevXVal[N - 1][Z] < 0 ? X = this.series[V][Z] >= 0 ? this.groupCtx.prevX[N - 1][Z] + b - 2 * (this.isReversed ? b : 0) : this.groupCtx.prevX[N - 1][Z] : this.groupCtx.prevXVal[N - 1][Z] >= 0 && (X = this.series[V][Z] >= 0 ? this.groupCtx.prevX[N - 1][Z] : this.groupCtx.prevX[N - 1][Z] - b + 2 * (this.isReversed ? b : 0)), o = X;
      } else
        o = y;
      S = this.series[V][Z] === null ? o : o + this.series[V][Z] / this.invertedYRatio - 2 * (this.isReversed ? this.series[V][Z] / this.invertedYRatio : 0);
      var K = this.barHelpers.getBarpaths({ barYPosition: j, barHeight: f, x1: o, x2: S, strokeWidth: p, series: this.series, realIndex: d.realIndex, seriesGroup: L, i: V, j: Z, w: I });
      return this.barHelpers.barBackground({ j: Z, i: V, y1: j, y2: f, elSeries: P }), C += O, { pathTo: K.pathTo, pathFrom: K.pathFrom, goalX: this.barHelpers.getGoalValues("x", y, null, V, Z), barYPosition: j, x: S, y: C };
    } }, { key: "drawStackedColumnPaths", value: function(i) {
      var o = i.indexes, d = i.x, f = i.y, p = i.xDivision, y = i.barWidth, S = i.zeroH, C = i.groupIndex, E = i.seriesGroup, L = i.elSeries, O = this.w, P = o.i, I = o.j, j = o.bc;
      if (O.globals.isXNumeric) {
        var V = O.globals.seriesX[P][I];
        V || (V = 0), d = (V - O.globals.minX) / this.xRatio - y / 2, O.globals.seriesGroups.length && (d = (V - O.globals.minX) / this.xRatio - y / 2 * O.globals.seriesGroups.length);
      }
      for (var Z, b = d + (C !== -1 ? C * y : 0), M = 0, N = 0; N < this.groupCtx.prevYF.length; N++)
        M += isNaN(this.groupCtx.prevYF[N][I]) ? 0 : this.groupCtx.prevYF[N][I];
      var X = P;
      if (E && (X = E.indexOf(O.config.series[P].name)), X > 0 && !O.globals.isXNumeric || X > 0 && O.globals.isXNumeric && O.globals.seriesX[P - 1][I] === O.globals.seriesX[P][I]) {
        var K, ee, oe, de = Math.min(this.yRatio.length + 1, P + 1);
        if (this.groupCtx.prevY[X - 1] !== void 0 && this.groupCtx.prevY[X - 1].length)
          for (var ke = 1; ke < de; ke++) {
            var _e;
            if (!isNaN((_e = this.groupCtx.prevY[X - ke]) === null || _e === void 0 ? void 0 : _e[I])) {
              oe = this.groupCtx.prevY[X - ke][I];
              break;
            }
          }
        for (var Me = 1; Me < de; Me++) {
          var Ie, rt;
          if (((Ie = this.groupCtx.prevYVal[X - Me]) === null || Ie === void 0 ? void 0 : Ie[I]) < 0) {
            ee = this.series[P][I] >= 0 ? oe - M + 2 * (this.isReversed ? M : 0) : oe;
            break;
          }
          if (((rt = this.groupCtx.prevYVal[X - Me]) === null || rt === void 0 ? void 0 : rt[I]) >= 0) {
            ee = this.series[P][I] >= 0 ? oe : oe + M - 2 * (this.isReversed ? M : 0);
            break;
          }
        }
        ee === void 0 && (ee = O.globals.gridHeight), Z = (K = this.groupCtx.prevYF[0]) !== null && K !== void 0 && K.every(function(Kt) {
          return Kt === 0;
        }) && this.groupCtx.prevYF.slice(1, X).every(function(Kt) {
          return Kt.every(function(mt) {
            return isNaN(mt);
          });
        }) ? S : ee;
      } else
        Z = S;
      f = this.series[P][I] ? Z - this.series[P][I] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[P][I] / this.yRatio[this.yaxisIndex] : 0) : Z;
      var Qt = this.barHelpers.getColumnPaths({ barXPosition: b, barWidth: y, y1: Z, y2: f, yRatio: this.yRatio[this.yaxisIndex], strokeWidth: this.strokeWidth, series: this.series, seriesGroup: E, realIndex: o.realIndex, i: P, j: I, w: O });
      return this.barHelpers.barBackground({ bc: j, j: I, i: P, x1: b, x2: y, elSeries: L }), d += p, { pathTo: Qt.pathTo, pathFrom: Qt.pathFrom, goalY: this.barHelpers.getGoalValues("y", null, S, P, I), barXPosition: b, x: O.globals.isXNumeric ? d - p : d, y: f };
    } }]), n;
  }(), Cn = function(B) {
    U(n, gr);
    var t = se(n);
    function n() {
      return A(this, n), t.apply(this, arguments);
    }
    return F(n, [{ key: "draw", value: function(i, o, d) {
      var f = this, p = this.w, y = new re(this.ctx), S = p.globals.comboCharts ? o : p.config.chart.type, C = new Je(this.ctx);
      this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = p.config.plotOptions.bar.horizontal;
      var E = new ve(this.ctx, p);
      i = E.getLogSeries(i), this.series = i, this.yRatio = E.getLogYRatios(this.yRatio), this.barHelpers.initVariables(i);
      for (var L = y.group({ class: "apexcharts-".concat(S, "-series apexcharts-plot-series") }), O = function(I) {
        f.isBoxPlot = p.config.chart.type === "boxPlot" || p.config.series[I].type === "boxPlot";
        var j, V, Z, b, M = void 0, N = void 0, X = [], K = [], ee = p.globals.comboCharts ? d[I] : I, oe = y.group({ class: "apexcharts-series", seriesName: Q.escapeString(p.globals.seriesNames[ee]), rel: I + 1, "data:realIndex": ee });
        f.ctx.series.addCollapsedClassToSeries(oe, ee), i[I].length > 0 && (f.visibleI = f.visibleI + 1);
        var de, ke;
        f.yRatio.length > 1 && (f.yaxisIndex = ee);
        var _e = f.barHelpers.initialPositions();
        N = _e.y, de = _e.barHeight, V = _e.yDivision, b = _e.zeroW, M = _e.x, ke = _e.barWidth, j = _e.xDivision, Z = _e.zeroH, K.push(M + ke / 2);
        for (var Me = y.group({ class: "apexcharts-datalabels", "data:realIndex": ee }), Ie = function(Qt) {
          var Kt = f.barHelpers.getStrokeWidth(I, Qt, ee), mt = null, Mn = { indexes: { i: I, j: Qt, realIndex: ee }, x: M, y: N, strokeWidth: Kt, elSeries: oe };
          mt = f.isHorizontal ? f.drawHorizontalBoxPaths(v(v({}, Mn), {}, { yDivision: V, barHeight: de, zeroW: b })) : f.drawVerticalBoxPaths(v(v({}, Mn), {}, { xDivision: j, barWidth: ke, zeroH: Z })), N = mt.y, M = mt.x, Qt > 0 && K.push(M + ke / 2), X.push(N), mt.pathTo.forEach(function(zn, gt) {
            var jr = !f.isBoxPlot && f.candlestickOptions.wick.useFillColor ? mt.color[gt] : p.globals.stroke.colors[I], Dn = C.fillPath({ seriesNumber: ee, dataPointIndex: Qt, color: mt.color[gt], value: i[I][Qt] });
            f.renderSeries({ realIndex: ee, pathFill: Dn, lineFill: jr, j: Qt, i: I, pathFrom: mt.pathFrom, pathTo: zn, strokeWidth: Kt, elSeries: oe, x: M, y: N, series: i, barHeight: de, barWidth: ke, elDataLabelsWrap: Me, visibleSeries: f.visibleI, type: p.config.chart.type });
          });
        }, rt = 0; rt < p.globals.dataPoints; rt++)
          Ie(rt);
        p.globals.seriesXvalues[ee] = K, p.globals.seriesYvalues[ee] = X, L.add(oe);
      }, P = 0; P < i.length; P++)
        O(P);
      return L;
    } }, { key: "drawVerticalBoxPaths", value: function(i) {
      var o = i.indexes, d = i.x;
      i.y;
      var f = i.xDivision, p = i.barWidth, y = i.zeroH, S = i.strokeWidth, C = this.w, E = new re(this.ctx), L = o.i, O = o.j, P = !0, I = C.config.plotOptions.candlestick.colors.upward, j = C.config.plotOptions.candlestick.colors.downward, V = "";
      this.isBoxPlot && (V = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
      var Z = this.yRatio[this.yaxisIndex], b = o.realIndex, M = this.getOHLCValue(b, O), N = y, X = y;
      M.o > M.c && (P = !1);
      var K = Math.min(M.o, M.c), ee = Math.max(M.o, M.c), oe = M.m;
      C.globals.isXNumeric && (d = (C.globals.seriesX[b][O] - C.globals.minX) / this.xRatio - p / 2);
      var de = d + p * this.visibleI;
      this.series[L][O] === void 0 || this.series[L][O] === null ? (K = y, ee = y) : (K = y - K / Z, ee = y - ee / Z, N = y - M.h / Z, X = y - M.l / Z, oe = y - M.m / Z);
      var ke = E.move(de, y), _e = E.move(de + p / 2, K);
      return C.globals.previousPaths.length > 0 && (_e = this.getPreviousPath(b, O, !0)), ke = this.isBoxPlot ? [E.move(de, K) + E.line(de + p / 2, K) + E.line(de + p / 2, N) + E.line(de + p / 4, N) + E.line(de + p - p / 4, N) + E.line(de + p / 2, N) + E.line(de + p / 2, K) + E.line(de + p, K) + E.line(de + p, oe) + E.line(de, oe) + E.line(de, K + S / 2), E.move(de, oe) + E.line(de + p, oe) + E.line(de + p, ee) + E.line(de + p / 2, ee) + E.line(de + p / 2, X) + E.line(de + p - p / 4, X) + E.line(de + p / 4, X) + E.line(de + p / 2, X) + E.line(de + p / 2, ee) + E.line(de, ee) + E.line(de, oe) + "z"] : [E.move(de, ee) + E.line(de + p / 2, ee) + E.line(de + p / 2, N) + E.line(de + p / 2, ee) + E.line(de + p, ee) + E.line(de + p, K) + E.line(de + p / 2, K) + E.line(de + p / 2, X) + E.line(de + p / 2, K) + E.line(de, K) + E.line(de, ee - S / 2)], _e += E.move(de, K), C.globals.isXNumeric || (d += f), { pathTo: ke, pathFrom: _e, x: d, y: ee, barXPosition: de, color: this.isBoxPlot ? V : P ? [I] : [j] };
    } }, { key: "drawHorizontalBoxPaths", value: function(i) {
      var o = i.indexes;
      i.x;
      var d = i.y, f = i.yDivision, p = i.barHeight, y = i.zeroW, S = i.strokeWidth, C = this.w, E = new re(this.ctx), L = o.i, O = o.j, P = this.boxOptions.colors.lower;
      this.isBoxPlot && (P = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
      var I = this.invertedYRatio, j = o.realIndex, V = this.getOHLCValue(j, O), Z = y, b = y, M = Math.min(V.o, V.c), N = Math.max(V.o, V.c), X = V.m;
      C.globals.isXNumeric && (d = (C.globals.seriesX[j][O] - C.globals.minX) / this.invertedXRatio - p / 2);
      var K = d + p * this.visibleI;
      this.series[L][O] === void 0 || this.series[L][O] === null ? (M = y, N = y) : (M = y + M / I, N = y + N / I, Z = y + V.h / I, b = y + V.l / I, X = y + V.m / I);
      var ee = E.move(y, K), oe = E.move(M, K + p / 2);
      return C.globals.previousPaths.length > 0 && (oe = this.getPreviousPath(j, O, !0)), ee = [E.move(M, K) + E.line(M, K + p / 2) + E.line(Z, K + p / 2) + E.line(Z, K + p / 2 - p / 4) + E.line(Z, K + p / 2 + p / 4) + E.line(Z, K + p / 2) + E.line(M, K + p / 2) + E.line(M, K + p) + E.line(X, K + p) + E.line(X, K) + E.line(M + S / 2, K), E.move(X, K) + E.line(X, K + p) + E.line(N, K + p) + E.line(N, K + p / 2) + E.line(b, K + p / 2) + E.line(b, K + p - p / 4) + E.line(b, K + p / 4) + E.line(b, K + p / 2) + E.line(N, K + p / 2) + E.line(N, K) + E.line(X, K) + "z"], oe += E.move(M, K), C.globals.isXNumeric || (d += f), { pathTo: ee, pathFrom: oe, x: N, y: d, barYPosition: K, color: P };
    } }, { key: "getOHLCValue", value: function(i, o) {
      var d = this.w;
      return { o: this.isBoxPlot ? d.globals.seriesCandleH[i][o] : d.globals.seriesCandleO[i][o], h: this.isBoxPlot ? d.globals.seriesCandleO[i][o] : d.globals.seriesCandleH[i][o], m: d.globals.seriesCandleM[i][o], l: this.isBoxPlot ? d.globals.seriesCandleC[i][o] : d.globals.seriesCandleL[i][o], c: this.isBoxPlot ? d.globals.seriesCandleL[i][o] : d.globals.seriesCandleC[i][o] };
    } }]), n;
  }(), us = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "checkColorRange", value: function() {
      var t = this.w, n = !1, i = t.config.plotOptions[t.config.chart.type];
      return i.colorScale.ranges.length > 0 && i.colorScale.ranges.map(function(o, d) {
        o.from <= 0 && (n = !0);
      }), n;
    } }, { key: "getShadeColor", value: function(t, n, i, o) {
      var d = this.w, f = 1, p = d.config.plotOptions[t].shadeIntensity, y = this.determineColor(t, n, i);
      d.globals.hasNegs || o ? f = d.config.plotOptions[t].reverseNegativeShade ? y.percent < 0 ? y.percent / 100 * (1.25 * p) : (1 - y.percent / 100) * (1.25 * p) : y.percent <= 0 ? 1 - (1 + y.percent / 100) * p : (1 - y.percent / 100) * p : (f = 1 - y.percent / 100, t === "treemap" && (f = (1 - y.percent / 100) * (1.25 * p)));
      var S = y.color, C = new Q();
      return d.config.plotOptions[t].enableShades && (S = this.w.config.theme.mode === "dark" ? Q.hexToRgba(C.shadeColor(-1 * f, y.color), d.config.fill.opacity) : Q.hexToRgba(C.shadeColor(f, y.color), d.config.fill.opacity)), { color: S, colorProps: y };
    } }, { key: "determineColor", value: function(t, n, i) {
      var o = this.w, d = o.globals.series[n][i], f = o.config.plotOptions[t], p = f.colorScale.inverse ? i : n;
      f.distributed && o.config.chart.type === "treemap" && (p = i);
      var y = o.globals.colors[p], S = null, C = Math.min.apply(Math, ue(o.globals.series[n])), E = Math.max.apply(Math, ue(o.globals.series[n]));
      f.distributed || t !== "heatmap" || (C = o.globals.minY, E = o.globals.maxY), f.colorScale.min !== void 0 && (C = f.colorScale.min < o.globals.minY ? f.colorScale.min : o.globals.minY, E = f.colorScale.max > o.globals.maxY ? f.colorScale.max : o.globals.maxY);
      var L = Math.abs(E) + Math.abs(C), O = 100 * d / (L === 0 ? L - 1e-6 : L);
      return f.colorScale.ranges.length > 0 && f.colorScale.ranges.map(function(P, I) {
        if (d >= P.from && d <= P.to) {
          y = P.color, S = P.foreColor ? P.foreColor : null, C = P.from, E = P.to;
          var j = Math.abs(E) + Math.abs(C);
          O = 100 * d / (j === 0 ? j - 1e-6 : j);
        }
      }), { color: y, foreColor: S, percent: O };
    } }, { key: "calculateDataLabels", value: function(t) {
      var n = t.text, i = t.x, o = t.y, d = t.i, f = t.j, p = t.colorProps, y = t.fontSize, S = this.w.config.dataLabels, C = new re(this.ctx), E = new jt(this.ctx), L = null;
      if (S.enabled) {
        L = C.group({ class: "apexcharts-data-labels" });
        var O = S.offsetX, P = S.offsetY, I = i + O, j = o + parseFloat(S.style.fontSize) / 3 + P;
        E.plotDataLabelsText({ x: I, y: j, text: n, i: d, j: f, color: p.foreColor, parent: L, fontSize: y, dataLabelsConfig: S });
      }
      return L;
    } }, { key: "addListeners", value: function(t) {
      var n = new re(this.ctx);
      t.node.addEventListener("mouseenter", n.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", n.pathMouseLeave.bind(this, t)), t.node.addEventListener("mousedown", n.pathMouseDown.bind(this, t));
    } }]), B;
  }(), cs = function() {
    function B(t, n) {
      A(this, B), this.ctx = t, this.w = t.w, this.xRatio = n.xRatio, this.yRatio = n.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new us(t), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
    }
    return F(B, [{ key: "draw", value: function(t) {
      var n = this.w, i = new re(this.ctx), o = i.group({ class: "apexcharts-heatmap" });
      o.attr("clip-path", "url(#gridRectMask".concat(n.globals.cuid, ")"));
      var d = n.globals.gridWidth / n.globals.dataPoints, f = n.globals.gridHeight / n.globals.series.length, p = 0, y = !1;
      this.negRange = this.helpers.checkColorRange();
      var S = t.slice();
      n.config.yaxis[0].reversed && (y = !0, S.reverse());
      for (var C = y ? 0 : S.length - 1; y ? C < S.length : C >= 0; y ? C++ : C--) {
        var E = i.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: Q.escapeString(n.globals.seriesNames[C]), rel: C + 1, "data:realIndex": C });
        if (this.ctx.series.addCollapsedClassToSeries(E, C), n.config.chart.dropShadow.enabled) {
          var L = n.config.chart.dropShadow;
          new Ee(this.ctx).dropShadow(E, L, C);
        }
        for (var O = 0, P = n.config.plotOptions.heatmap.shadeIntensity, I = 0; I < S[C].length; I++) {
          var j = this.helpers.getShadeColor(n.config.chart.type, C, I, this.negRange), V = j.color, Z = j.colorProps;
          n.config.fill.type === "image" && (V = new Je(this.ctx).fillPath({ seriesNumber: C, dataPointIndex: I, opacity: n.globals.hasNegs ? Z.percent < 0 ? 1 - (1 + Z.percent / 100) : P + Z.percent / 100 : Z.percent / 100, patternID: Q.randomId(), width: n.config.fill.image.width ? n.config.fill.image.width : d, height: n.config.fill.image.height ? n.config.fill.image.height : f }));
          var b = this.rectRadius, M = i.drawRect(O, p, d, f, b);
          if (M.attr({ cx: O, cy: p }), M.node.classList.add("apexcharts-heatmap-rect"), E.add(M), M.attr({ fill: V, i: C, index: C, j: I, val: S[C][I], "stroke-width": this.strokeWidth, stroke: n.config.plotOptions.heatmap.useFillColorAsStroke ? V : n.globals.stroke.colors[0], color: V }), this.helpers.addListeners(M), n.config.chart.animations.enabled && !n.globals.dataChanged) {
            var N = 1;
            n.globals.resized || (N = n.config.chart.animations.speed), this.animateHeatMap(M, O, p, d, f, N);
          }
          if (n.globals.dataChanged) {
            var X = 1;
            if (this.dynamicAnim.enabled && n.globals.shouldAnimate) {
              X = this.dynamicAnim.speed;
              var K = n.globals.previousPaths[C] && n.globals.previousPaths[C][I] && n.globals.previousPaths[C][I].color;
              K || (K = "rgba(255, 255, 255, 0)"), this.animateHeatColor(M, Q.isColorHex(K) ? K : Q.rgb2hex(K), Q.isColorHex(V) ? V : Q.rgb2hex(V), X);
            }
          }
          var ee = (0, n.config.dataLabels.formatter)(n.globals.series[C][I], { value: n.globals.series[C][I], seriesIndex: C, dataPointIndex: I, w: n }), oe = this.helpers.calculateDataLabels({ text: ee, x: O + d / 2, y: p + f / 2, i: C, j: I, colorProps: Z, series: S });
          oe !== null && E.add(oe), O += d;
        }
        p += f, o.add(E);
      }
      var de = n.globals.yAxisScale[0].result.slice();
      n.config.yaxis[0].reversed ? de.unshift("") : de.push(""), n.globals.yAxisScale[0].result = de;
      var ke = n.globals.gridHeight / n.globals.series.length;
      return n.config.yaxis[0].labels.offsetY = -ke / 2, o;
    } }, { key: "animateHeatMap", value: function(t, n, i, o, d, f) {
      var p = new we(this.ctx);
      p.animateRect(t, { x: n + o / 2, y: i + d / 2, width: 0, height: 0 }, { x: n, y: i, width: o, height: d }, f, function() {
        p.animationCompleted(t);
      });
    } }, { key: "animateHeatColor", value: function(t, n, i, o) {
      t.attr({ fill: n }).animate(o).attr({ fill: i });
    } }]), B;
  }(), ds = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "drawYAxisTexts", value: function(t, n, i, o) {
      var d = this.w, f = d.config.yaxis[0], p = d.globals.yLabelFormatters[0];
      return new re(this.ctx).drawText({ x: t + f.labels.offsetX, y: n + f.labels.offsetY, text: p(o, i), textAnchor: "middle", fontSize: f.labels.style.fontSize, fontFamily: f.labels.style.fontFamily, foreColor: Array.isArray(f.labels.style.colors) ? f.labels.style.colors[i] : f.labels.style.colors });
    } }]), B;
  }(), Xs = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
      var n = this.w;
      this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = n.globals.stroke.colors !== void 0 ? n.globals.stroke.colors : n.globals.colors, this.defaultSize = Math.min(n.globals.gridWidth, n.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = n.globals.gridWidth / 2, n.config.chart.type === "radialBar" ? this.fullAngle = 360 : this.fullAngle = Math.abs(n.config.plotOptions.pie.endAngle - n.config.plotOptions.pie.startAngle), this.initialAngle = n.config.plotOptions.pie.startAngle % this.fullAngle, n.globals.radialSize = this.defaultSize / 2.05 - n.config.stroke.width - (n.config.chart.sparkline.enabled ? 0 : n.config.chart.dropShadow.blur), this.donutSize = n.globals.radialSize * parseInt(n.config.plotOptions.pie.donut.size, 10) / 100, this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
    }
    return F(B, [{ key: "draw", value: function(t) {
      var n = this, i = this.w, o = new re(this.ctx);
      if (this.ret = o.group({ class: "apexcharts-pie" }), i.globals.noData)
        return this.ret;
      for (var d = 0, f = 0; f < t.length; f++)
        d += Q.negToZero(t[f]);
      var p = [], y = o.group();
      d === 0 && (d = 1e-5), t.forEach(function(K) {
        n.maxY = Math.max(n.maxY, K);
      }), i.config.yaxis[0].max && (this.maxY = i.config.yaxis[0].max), i.config.grid.position === "back" && this.chartType === "polarArea" && this.drawPolarElements(this.ret);
      for (var S = 0; S < t.length; S++) {
        var C = this.fullAngle * Q.negToZero(t[S]) / d;
        p.push(C), this.chartType === "polarArea" ? (p[S] = this.fullAngle / t.length, this.sliceSizes.push(i.globals.radialSize * t[S] / this.maxY)) : this.sliceSizes.push(i.globals.radialSize);
      }
      if (i.globals.dataChanged) {
        for (var E, L = 0, O = 0; O < i.globals.previousPaths.length; O++)
          L += Q.negToZero(i.globals.previousPaths[O]);
        for (var P = 0; P < i.globals.previousPaths.length; P++)
          E = this.fullAngle * Q.negToZero(i.globals.previousPaths[P]) / L, this.prevSectorAngleArr.push(E);
      }
      this.donutSize < 0 && (this.donutSize = 0);
      var I = i.config.plotOptions.pie.customScale, j = i.globals.gridWidth / 2, V = i.globals.gridHeight / 2, Z = j - i.globals.gridWidth / 2 * I, b = V - i.globals.gridHeight / 2 * I;
      if (this.chartType === "donut") {
        var M = o.drawCircle(this.donutSize);
        M.attr({ cx: this.centerX, cy: this.centerY, fill: i.config.plotOptions.pie.donut.background ? i.config.plotOptions.pie.donut.background : "transparent" }), y.add(M);
      }
      var N = this.drawArcs(p, t);
      if (this.sliceLabels.forEach(function(K) {
        N.add(K);
      }), y.attr({ transform: "translate(".concat(Z, ", ").concat(b, ") scale(").concat(I, ")") }), y.add(N), this.ret.add(y), this.donutDataLabels.show) {
        var X = this.renderInnerDataLabels(this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show, translateX: Z, translateY: b });
        this.ret.add(X);
      }
      return i.config.grid.position === "front" && this.chartType === "polarArea" && this.drawPolarElements(this.ret), this.ret;
    } }, { key: "drawArcs", value: function(t, n) {
      var i = this.w, o = new Ee(this.ctx), d = new re(this.ctx), f = new Je(this.ctx), p = d.group({ class: "apexcharts-slices" }), y = this.initialAngle, S = this.initialAngle, C = this.initialAngle, E = this.initialAngle;
      this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;
      for (var L = 0; L < t.length; L++) {
        var O = d.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: Q.escapeString(i.globals.seriesNames[L]), rel: L + 1, "data:realIndex": L });
        p.add(O), S = E, C = (y = C) + t[L], E = S + this.prevSectorAngleArr[L];
        var P = C < y ? this.fullAngle + C - y : C - y, I = f.fillPath({ seriesNumber: L, size: this.sliceSizes[L], value: n[L] }), j = this.getChangedPath(S, E), V = d.drawPath({ d: j, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[L] : this.lineColorArr, strokeWidth: 0, fill: I, fillOpacity: i.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(L) });
        if (V.attr({ index: 0, j: L }), o.setSelectionFilter(V, 0, L), i.config.chart.dropShadow.enabled) {
          var Z = i.config.chart.dropShadow;
          o.dropShadow(V, Z, L);
        }
        this.addListeners(V, this.donutDataLabels), re.setAttrs(V.node, { "data:angle": P, "data:startAngle": y, "data:strokeWidth": this.strokeWidth, "data:value": n[L] });
        var b = { x: 0, y: 0 };
        this.chartType === "pie" || this.chartType === "polarArea" ? b = Q.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, (y + P / 2) % this.fullAngle) : this.chartType === "donut" && (b = Q.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, (y + P / 2) % this.fullAngle)), O.add(V);
        var M = 0;
        if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : ((M = P / this.fullAngle * i.config.chart.animations.speed) === 0 && (M = 1), this.animDur = M + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i.globals.dataChanged ? this.animatePaths(V, { size: this.sliceSizes[L], endAngle: C, startAngle: y, prevStartAngle: S, prevEndAngle: E, animateStartingPos: !0, i: L, animBeginArr: this.animBeginArr, shouldSetPrevPaths: !0, dur: i.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(V, { size: this.sliceSizes[L], endAngle: C, startAngle: y, i: L, totalItems: t.length - 1, animBeginArr: this.animBeginArr, dur: M }), i.config.plotOptions.pie.expandOnClick && this.chartType !== "polarArea" && V.click(this.pieClicked.bind(this, L)), i.globals.selectedDataPoints[0] !== void 0 && i.globals.selectedDataPoints[0].indexOf(L) > -1 && this.pieClicked(L), i.config.dataLabels.enabled) {
          var N = b.x, X = b.y, K = 100 * P / this.fullAngle + "%";
          if (P !== 0 && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t[L]) {
            var ee = i.config.dataLabels.formatter;
            ee !== void 0 && (K = ee(i.globals.seriesPercent[L][0], { seriesIndex: L, w: i }));
            var oe = i.globals.dataLabels.style.colors[L], de = d.group({ class: "apexcharts-datalabels" }), ke = d.drawText({ x: N, y: X, text: K, textAnchor: "middle", fontSize: i.config.dataLabels.style.fontSize, fontFamily: i.config.dataLabels.style.fontFamily, fontWeight: i.config.dataLabels.style.fontWeight, foreColor: oe });
            if (de.add(ke), i.config.dataLabels.dropShadow.enabled) {
              var _e = i.config.dataLabels.dropShadow;
              o.dropShadow(ke, _e);
            }
            ke.node.classList.add("apexcharts-pie-label"), i.config.chart.animations.animate && i.globals.resized === !1 && (ke.node.classList.add("apexcharts-pie-label-delay"), ke.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(de);
          }
        }
      }
      return p;
    } }, { key: "addListeners", value: function(t, n) {
      var i = new re(this.ctx);
      t.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, t)), t.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t.node, n)), t.node.addEventListener("mousedown", i.pathMouseDown.bind(this, t)), this.donutDataLabels.total.showAlways || (t.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t.node, n)), t.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t.node, n)));
    } }, { key: "animatePaths", value: function(t, n) {
      var i = this.w, o = n.endAngle < n.startAngle ? this.fullAngle + n.endAngle - n.startAngle : n.endAngle - n.startAngle, d = o, f = n.startAngle, p = n.startAngle;
      n.prevStartAngle !== void 0 && n.prevEndAngle !== void 0 && (f = n.prevEndAngle, d = n.prevEndAngle < n.prevStartAngle ? this.fullAngle + n.prevEndAngle - n.prevStartAngle : n.prevEndAngle - n.prevStartAngle), n.i === i.config.series.length - 1 && (o + p > this.fullAngle ? n.endAngle = n.endAngle - (o + p) : o + p < this.fullAngle && (n.endAngle = n.endAngle + (this.fullAngle - (o + p)))), o === this.fullAngle && (o = this.fullAngle - 0.01), this.animateArc(t, f, p, o, d, n);
    } }, { key: "animateArc", value: function(t, n, i, o, d, f) {
      var p, y = this, S = this.w, C = new we(this.ctx), E = f.size;
      (isNaN(n) || isNaN(d)) && (n = i, d = o, f.dur = 0);
      var L = o, O = i, P = n < i ? this.fullAngle + n - i : n - i;
      S.globals.dataChanged && f.shouldSetPrevPaths && f.prevEndAngle && (p = y.getPiePath({ me: y, startAngle: f.prevStartAngle, angle: f.prevEndAngle < f.prevStartAngle ? this.fullAngle + f.prevEndAngle - f.prevStartAngle : f.prevEndAngle - f.prevStartAngle, size: E }), t.attr({ d: p })), f.dur !== 0 ? t.animate(f.dur, S.globals.easing, f.animBeginArr[f.i]).afterAll(function() {
        y.chartType !== "pie" && y.chartType !== "donut" && y.chartType !== "polarArea" || this.animate(S.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": y.strokeWidth }), f.i === S.config.series.length - 1 && C.animationCompleted(t);
      }).during(function(I) {
        L = P + (o - P) * I, f.animateStartingPos && (L = d + (o - d) * I, O = n - d + (i - (n - d)) * I), p = y.getPiePath({ me: y, startAngle: O, angle: L, size: E }), t.node.setAttribute("data:pathOrig", p), t.attr({ d: p });
      }) : (p = y.getPiePath({ me: y, startAngle: O, angle: o, size: E }), f.isTrack || (S.globals.animationEnded = !0), t.node.setAttribute("data:pathOrig", p), t.attr({ d: p, "stroke-width": y.strokeWidth }));
    } }, { key: "pieClicked", value: function(t) {
      var n, i = this.w, o = this, d = o.sliceSizes[t] + (i.config.plotOptions.pie.expandOnClick ? 4 : 0), f = i.globals.dom.Paper.select(".apexcharts-".concat(o.chartType.toLowerCase(), "-slice-").concat(t)).members[0];
      if (f.attr("data:pieClicked") !== "true") {
        var p = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
        Array.prototype.forEach.call(p, function(E) {
          E.setAttribute("data:pieClicked", "false");
          var L = E.getAttribute("data:pathOrig");
          L && E.setAttribute("d", L);
        }), f.attr("data:pieClicked", "true");
        var y = parseInt(f.attr("data:startAngle"), 10), S = parseInt(f.attr("data:angle"), 10);
        n = o.getPiePath({ me: o, startAngle: y, angle: S, size: d }), S !== 360 && f.plot(n);
      } else {
        f.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(f.node, this.donutDataLabels);
        var C = f.attr("data:pathOrig");
        f.attr({ d: C });
      }
    } }, { key: "getChangedPath", value: function(t, n) {
      var i = "";
      return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({ me: this, startAngle: t, angle: n - t, size: this.size })), i;
    } }, { key: "getPiePath", value: function(t) {
      var n = t.me, i = t.startAngle, o = t.angle, d = t.size, f = i, p = Math.PI * (f - 90) / 180, y = o + i;
      Math.ceil(y) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (y = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(y) > this.fullAngle && (y -= this.fullAngle);
      var S = Math.PI * (y - 90) / 180, C = n.centerX + d * Math.cos(p), E = n.centerY + d * Math.sin(p), L = n.centerX + d * Math.cos(S), O = n.centerY + d * Math.sin(S), P = Q.polarToCartesian(n.centerX, n.centerY, n.donutSize, y), I = Q.polarToCartesian(n.centerX, n.centerY, n.donutSize, f), j = o > 180 ? 1 : 0, V = ["M", C, E, "A", d, d, 0, j, 1, L, O];
      return n.chartType === "donut" ? [].concat(V, ["L", P.x, P.y, "A", n.donutSize, n.donutSize, 0, j, 0, I.x, I.y, "L", C, E, "z"]).join(" ") : n.chartType === "pie" || n.chartType === "polarArea" ? [].concat(V, ["L", n.centerX, n.centerY, "L", C, E]).join(" ") : [].concat(V).join(" ");
    } }, { key: "drawPolarElements", value: function(t) {
      var n = this.w, i = new Ze(this.ctx), o = new re(this.ctx), d = new ds(this.ctx), f = o.group(), p = o.group(), y = i.niceScale(0, Math.ceil(this.maxY), n.config.yaxis[0].tickAmount, 0, !0), S = y.result.reverse(), C = y.result.length;
      this.maxY = y.niceMax;
      for (var E = n.globals.radialSize, L = E / (C - 1), O = 0; O < C - 1; O++) {
        var P = o.drawCircle(E);
        if (P.attr({ cx: this.centerX, cy: this.centerY, fill: "none", "stroke-width": n.config.plotOptions.polarArea.rings.strokeWidth, stroke: n.config.plotOptions.polarArea.rings.strokeColor }), n.config.yaxis[0].show) {
          var I = d.drawYAxisTexts(this.centerX, this.centerY - E + parseInt(n.config.yaxis[0].labels.style.fontSize, 10) / 2, O, S[O]);
          p.add(I);
        }
        f.add(P), E -= L;
      }
      this.drawSpokes(t), t.add(f), t.add(p);
    } }, { key: "renderInnerDataLabels", value: function(t, n) {
      var i = this.w, o = new re(this.ctx), d = o.group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(n.translateX ? n.translateX : 0, ", ").concat(n.translateY ? n.translateY : 0, ") scale(").concat(i.config.plotOptions.pie.customScale, ")") }), f = t.total.show;
      d.node.style.opacity = n.opacity;
      var p, y, S = n.centerX, C = n.centerY;
      p = t.name.color === void 0 ? i.globals.colors[0] : t.name.color;
      var E = t.name.fontSize, L = t.name.fontFamily, O = t.name.fontWeight;
      y = t.value.color === void 0 ? i.config.chart.foreColor : t.value.color;
      var P = t.value.formatter, I = "", j = "";
      if (f ? (p = t.total.color, E = t.total.fontSize, L = t.total.fontFamily, O = t.total.fontWeight, j = t.total.label, I = t.total.formatter(i)) : i.globals.series.length === 1 && (I = P(i.globals.series[0], i), j = i.globals.seriesNames[0]), j && (j = t.name.formatter(j, t.total.show, i)), t.name.show) {
        var V = o.drawText({ x: S, y: C + parseFloat(t.name.offsetY), text: j, textAnchor: "middle", foreColor: p, fontSize: E, fontWeight: O, fontFamily: L });
        V.node.classList.add("apexcharts-datalabel-label"), d.add(V);
      }
      if (t.value.show) {
        var Z = t.name.show ? parseFloat(t.value.offsetY) + 16 : t.value.offsetY, b = o.drawText({ x: S, y: C + Z, text: I, textAnchor: "middle", foreColor: y, fontWeight: t.value.fontWeight, fontSize: t.value.fontSize, fontFamily: t.value.fontFamily });
        b.node.classList.add("apexcharts-datalabel-value"), d.add(b);
      }
      return d;
    } }, { key: "printInnerLabels", value: function(t, n, i, o) {
      var d, f = this.w;
      o ? d = t.name.color === void 0 ? f.globals.colors[parseInt(o.parentNode.getAttribute("rel"), 10) - 1] : t.name.color : f.globals.series.length > 1 && t.total.show && (d = t.total.color);
      var p = f.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), y = f.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
      i = (0, t.value.formatter)(i, f), o || typeof t.total.formatter != "function" || (i = t.total.formatter(f));
      var S = n === t.total.label;
      n = t.name.formatter(n, S, f), p !== null && (p.textContent = n), y !== null && (y.textContent = i), p !== null && (p.style.fill = d);
    } }, { key: "printDataLabelsInner", value: function(t, n) {
      var i = this.w, o = t.getAttribute("data:value"), d = i.globals.seriesNames[parseInt(t.parentNode.getAttribute("rel"), 10) - 1];
      i.globals.series.length > 1 && this.printInnerLabels(n, d, o, t);
      var f = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
      f !== null && (f.style.opacity = 1);
    } }, { key: "drawSpokes", value: function(t) {
      var n = this, i = this.w, o = new re(this.ctx), d = i.config.plotOptions.polarArea.spokes;
      if (d.strokeWidth !== 0) {
        for (var f = [], p = 360 / i.globals.series.length, y = 0; y < i.globals.series.length; y++)
          f.push(Q.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize, i.config.plotOptions.pie.startAngle + p * y));
        f.forEach(function(S, C) {
          var E = o.drawLine(S.x, S.y, n.centerX, n.centerY, Array.isArray(d.connectorColors) ? d.connectorColors[C] : d.connectorColors);
          t.add(E);
        });
      }
    } }, { key: "revertDataLabelsInner", value: function(t, n, i) {
      var o = this, d = this.w, f = d.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"), p = !1, y = d.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"), S = function(L) {
        var O = L.makeSliceOut, P = L.printLabel;
        Array.prototype.forEach.call(y, function(I) {
          I.getAttribute("data:pieClicked") === "true" && (O && (p = !0), P && o.printDataLabelsInner(I, n));
        });
      };
      if (S({ makeSliceOut: !0, printLabel: !1 }), n.total.show && d.globals.series.length > 1)
        p && !n.total.showAlways ? S({ makeSliceOut: !1, printLabel: !0 }) : this.printInnerLabels(n, n.total.label, n.total.formatter(d));
      else if (S({ makeSliceOut: !1, printLabel: !0 }), !p)
        if (d.globals.selectedDataPoints.length && d.globals.series.length > 1)
          if (d.globals.selectedDataPoints[0].length > 0) {
            var C = d.globals.selectedDataPoints[0], E = d.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(C));
            this.printDataLabelsInner(E, n);
          } else
            f && d.globals.selectedDataPoints.length && d.globals.selectedDataPoints[0].length === 0 && (f.style.opacity = 0);
        else
          f && d.globals.series.length > 1 && (f.style.opacity = 0);
    } }]), B;
  }(), Ll = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
      var n = this.w;
      this.graphics = new re(this.ctx), this.lineColorArr = n.globals.stroke.colors !== void 0 ? n.globals.stroke.colors : n.globals.colors, this.defaultSize = n.globals.svgHeight < n.globals.svgWidth ? n.globals.gridHeight + 1.5 * n.globals.goldenPadding : n.globals.gridWidth, this.isLog = n.config.yaxis[0].logarithmic, this.coreUtils = new ve(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(n.globals.maxY, 0) : n.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : n.globals.minY, this.polygons = n.config.plotOptions.radar.polygons, this.strokeWidth = n.config.stroke.show ? n.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - n.config.chart.dropShadow.blur, n.config.xaxis.labels.show && (this.size = this.size - n.globals.xAxisLabelsWidth / 1.75), n.config.plotOptions.radar.size !== void 0 && (this.size = n.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
    }
    return F(B, [{ key: "draw", value: function(t) {
      var n = this, i = this.w, o = new Je(this.ctx), d = [], f = new jt(this.ctx);
      t.length && (this.dataPointsLen = t[i.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
      var p = i.globals.gridWidth / 2, y = i.globals.gridHeight / 2, S = p + i.config.plotOptions.radar.offsetX, C = y + i.config.plotOptions.radar.offsetY, E = this.graphics.group({ class: "apexcharts-radar-series apexcharts-plot-series", transform: "translate(".concat(S || 0, ", ").concat(C || 0, ")") }), L = [], O = null, P = null;
      if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), t.forEach(function(j, V) {
        var Z = j.length === i.globals.dataPoints, b = n.graphics.group().attr({ class: "apexcharts-series", "data:longestSeries": Z, seriesName: Q.escapeString(i.globals.seriesNames[V]), rel: V + 1, "data:realIndex": V });
        n.dataRadiusOfPercent[V] = [], n.dataRadius[V] = [], n.angleArr[V] = [], j.forEach(function(Me, Ie) {
          var rt = Math.abs(n.maxValue - n.minValue);
          Me += Math.abs(n.minValue), n.isLog && (Me = n.coreUtils.getLogVal(Me, 0)), n.dataRadiusOfPercent[V][Ie] = Me / rt, n.dataRadius[V][Ie] = n.dataRadiusOfPercent[V][Ie] * n.size, n.angleArr[V][Ie] = Ie * n.disAngle;
        }), L = n.getDataPointsPos(n.dataRadius[V], n.angleArr[V]);
        var M = n.createPaths(L, { x: 0, y: 0 });
        O = n.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), P = n.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": V }), i.globals.delayedElements.push({ el: O.node, index: V });
        var N = { i: V, realIndex: V, animationDelay: V, initialSpeed: i.config.chart.animations.speed, dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: !1, bindEventsOnPaths: !1, stroke: i.globals.stroke.colors[V], strokeLineCap: i.config.stroke.lineCap }, X = null;
        i.globals.previousPaths.length > 0 && (X = n.getPreviousPath(V));
        for (var K = 0; K < M.linePathsTo.length; K++) {
          var ee = n.graphics.renderPaths(v(v({}, N), {}, { pathFrom: X === null ? M.linePathsFrom[K] : X, pathTo: M.linePathsTo[K], strokeWidth: Array.isArray(n.strokeWidth) ? n.strokeWidth[V] : n.strokeWidth, fill: "none", drawShadow: !1 }));
          b.add(ee);
          var oe = o.fillPath({ seriesNumber: V }), de = n.graphics.renderPaths(v(v({}, N), {}, { pathFrom: X === null ? M.areaPathsFrom[K] : X, pathTo: M.areaPathsTo[K], strokeWidth: 0, fill: oe, drawShadow: !1 }));
          if (i.config.chart.dropShadow.enabled) {
            var ke = new Ee(n.ctx), _e = i.config.chart.dropShadow;
            ke.dropShadow(de, Object.assign({}, _e, { noUserSpaceOnUse: !0 }), V);
          }
          b.add(de);
        }
        j.forEach(function(Me, Ie) {
          var rt = new kt(n.ctx).getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: V, dataPointIndex: Ie }), Qt = n.graphics.drawMarker(L[Ie].x, L[Ie].y, rt);
          Qt.attr("rel", Ie), Qt.attr("j", Ie), Qt.attr("index", V), Qt.node.setAttribute("default-marker-size", rt.pSize);
          var Kt = n.graphics.group({ class: "apexcharts-series-markers" });
          Kt && Kt.add(Qt), O.add(Kt), b.add(O);
          var mt = i.config.dataLabels;
          if (mt.enabled) {
            var Mn = mt.formatter(i.globals.series[V][Ie], { seriesIndex: V, dataPointIndex: Ie, w: i });
            f.plotDataLabelsText({ x: L[Ie].x, y: L[Ie].y, text: Mn, textAnchor: "middle", i: V, j: V, parent: P, offsetCorrection: !1, dataLabelsConfig: v({}, mt) });
          }
          b.add(P);
        }), d.push(b);
      }), this.drawPolygons({ parent: E }), i.config.xaxis.labels.show) {
        var I = this.drawXAxisTexts();
        E.add(I);
      }
      return d.forEach(function(j) {
        E.add(j);
      }), E.add(this.yaxisLabels), E;
    } }, { key: "drawPolygons", value: function(t) {
      for (var n = this, i = this.w, o = t.parent, d = new ds(this.ctx), f = i.globals.yAxisScale[0].result.reverse(), p = f.length, y = [], S = this.size / (p - 1), C = 0; C < p; C++)
        y[C] = S * C;
      y.reverse();
      var E = [], L = [];
      y.forEach(function(O, P) {
        var I = Q.getPolygonPos(O, n.dataPointsLen), j = "";
        I.forEach(function(V, Z) {
          if (P === 0) {
            var b = n.graphics.drawLine(V.x, V.y, 0, 0, Array.isArray(n.polygons.connectorColors) ? n.polygons.connectorColors[Z] : n.polygons.connectorColors);
            L.push(b);
          }
          Z === 0 && n.yaxisLabelsTextsPos.push({ x: V.x, y: V.y }), j += V.x + "," + V.y + " ";
        }), E.push(j);
      }), E.forEach(function(O, P) {
        var I = n.polygons.strokeColors, j = n.polygons.strokeWidth, V = n.graphics.drawPolygon(O, Array.isArray(I) ? I[P] : I, Array.isArray(j) ? j[P] : j, i.globals.radarPolygons.fill.colors[P]);
        o.add(V);
      }), L.forEach(function(O) {
        o.add(O);
      }), i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(O, P) {
        var I = d.drawYAxisTexts(O.x, O.y, P, f[P]);
        n.yaxisLabels.add(I);
      });
    } }, { key: "drawXAxisTexts", value: function() {
      var t = this, n = this.w, i = n.config.xaxis.labels, o = this.graphics.group({ class: "apexcharts-xaxis" }), d = Q.getPolygonPos(this.size, this.dataPointsLen);
      return n.globals.labels.forEach(function(f, p) {
        var y = n.config.xaxis.labels.formatter, S = new jt(t.ctx);
        if (d[p]) {
          var C = t.getTextPos(d[p], t.size), E = y(f, { seriesIndex: -1, dataPointIndex: p, w: n });
          S.plotDataLabelsText({ x: C.newX, y: C.newY, text: E, textAnchor: C.textAnchor, i: p, j: p, parent: o, color: Array.isArray(i.style.colors) && i.style.colors[p] ? i.style.colors[p] : "#a8a8a8", dataLabelsConfig: v({ textAnchor: C.textAnchor, dropShadow: { enabled: !1 } }, i), offsetCorrection: !1 });
        }
      }), o;
    } }, { key: "createPaths", value: function(t, n) {
      var i = this, o = [], d = [], f = [], p = [];
      if (t.length) {
        d = [this.graphics.move(n.x, n.y)], p = [this.graphics.move(n.x, n.y)];
        var y = this.graphics.move(t[0].x, t[0].y), S = this.graphics.move(t[0].x, t[0].y);
        t.forEach(function(C, E) {
          y += i.graphics.line(C.x, C.y), S += i.graphics.line(C.x, C.y), E === t.length - 1 && (y += "Z", S += "Z");
        }), o.push(y), f.push(S);
      }
      return { linePathsFrom: d, linePathsTo: o, areaPathsFrom: p, areaPathsTo: f };
    } }, { key: "getTextPos", value: function(t, n) {
      var i = "middle", o = t.x, d = t.y;
      return Math.abs(t.x) >= 10 ? t.x > 0 ? (i = "start", o += 10) : t.x < 0 && (i = "end", o -= 10) : i = "middle", Math.abs(t.y) >= n - 10 && (t.y < 0 ? d -= 10 : t.y > 0 && (d += 10)), { textAnchor: i, newX: o, newY: d };
    } }, { key: "getPreviousPath", value: function(t) {
      for (var n = this.w, i = null, o = 0; o < n.globals.previousPaths.length; o++) {
        var d = n.globals.previousPaths[o];
        d.paths.length > 0 && parseInt(d.realIndex, 10) === parseInt(t, 10) && n.globals.previousPaths[o].paths[0] !== void 0 && (i = n.globals.previousPaths[o].paths[0].d);
      }
      return i;
    } }, { key: "getDataPointsPos", value: function(t, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.dataPointsLen;
      t = t || [], n = n || [];
      for (var o = [], d = 0; d < i; d++) {
        var f = {};
        f.x = t[d] * Math.sin(n[d]), f.y = -t[d] * Math.cos(n[d]), o.push(f);
      }
      return o;
    } }]), B;
  }(), fs = function(B) {
    U(n, Xs);
    var t = se(n);
    function n(i) {
      var o;
      A(this, n), (o = t.call(this, i)).ctx = i, o.w = i.w, o.animBeginArr = [0], o.animDur = 0;
      var d = o.w;
      return o.startAngle = d.config.plotOptions.radialBar.startAngle, o.endAngle = d.config.plotOptions.radialBar.endAngle, o.totalAngle = Math.abs(d.config.plotOptions.radialBar.endAngle - d.config.plotOptions.radialBar.startAngle), o.trackStartAngle = d.config.plotOptions.radialBar.track.startAngle, o.trackEndAngle = d.config.plotOptions.radialBar.track.endAngle, o.donutDataLabels = o.w.config.plotOptions.radialBar.dataLabels, o.radialDataLabels = o.donutDataLabels, o.trackStartAngle || (o.trackStartAngle = o.startAngle), o.trackEndAngle || (o.trackEndAngle = o.endAngle), o.endAngle === 360 && (o.endAngle = 359.99), o.margin = parseInt(d.config.plotOptions.radialBar.track.margin, 10), o;
    }
    return F(n, [{ key: "draw", value: function(i) {
      var o = this.w, d = new re(this.ctx), f = d.group({ class: "apexcharts-radialbar" });
      if (o.globals.noData)
        return f;
      var p = d.group(), y = this.defaultSize / 2, S = o.globals.gridWidth / 2, C = this.defaultSize / 2.05;
      o.config.chart.sparkline.enabled || (C = C - o.config.stroke.width - o.config.chart.dropShadow.blur);
      var E = o.globals.fill.colors;
      if (o.config.plotOptions.radialBar.track.show) {
        var L = this.drawTracks({ size: C, centerX: S, centerY: y, colorArr: E, series: i });
        p.add(L);
      }
      var O = this.drawArcs({ size: C, centerX: S, centerY: y, colorArr: E, series: i }), P = 360;
      o.config.plotOptions.radialBar.startAngle < 0 && (P = this.totalAngle);
      var I = (360 - P) / 360;
      if (o.globals.radialSize = C - C * I, this.radialDataLabels.value.show) {
        var j = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
        o.globals.radialSize += j * I;
      }
      return p.add(O.g), o.config.plotOptions.radialBar.hollow.position === "front" && (O.g.add(O.elHollow), O.dataLabels && O.g.add(O.dataLabels)), f.add(p), f;
    } }, { key: "drawTracks", value: function(i) {
      var o = this.w, d = new re(this.ctx), f = d.group({ class: "apexcharts-tracks" }), p = new Ee(this.ctx), y = new Je(this.ctx), S = this.getStrokeWidth(i);
      i.size = i.size - S / 2;
      for (var C = 0; C < i.series.length; C++) {
        var E = d.group({ class: "apexcharts-radialbar-track apexcharts-track" });
        f.add(E), E.attr({ rel: C + 1 }), i.size = i.size - S - this.margin;
        var L = o.config.plotOptions.radialBar.track, O = y.fillPath({ seriesNumber: 0, size: i.size, fillColors: Array.isArray(L.background) ? L.background[C] : L.background, solid: !0 }), P = this.trackStartAngle, I = this.trackEndAngle;
        Math.abs(I) + Math.abs(P) >= 360 && (I = 360 - Math.abs(this.startAngle) - 0.1);
        var j = d.drawPath({ d: "", stroke: O, strokeWidth: S * parseInt(L.strokeWidth, 10) / 100, fill: "none", strokeOpacity: L.opacity, classes: "apexcharts-radialbar-area" });
        if (L.dropShadow.enabled) {
          var V = L.dropShadow;
          p.dropShadow(j, V);
        }
        E.add(j), j.attr("id", "apexcharts-radialbarTrack-" + C), this.animatePaths(j, { centerX: i.centerX, centerY: i.centerY, endAngle: I, startAngle: P, size: i.size, i: C, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: !0, easing: o.globals.easing });
      }
      return f;
    } }, { key: "drawArcs", value: function(i) {
      var o = this.w, d = new re(this.ctx), f = new Je(this.ctx), p = new Ee(this.ctx), y = d.group(), S = this.getStrokeWidth(i);
      i.size = i.size - S / 2;
      var C = o.config.plotOptions.radialBar.hollow.background, E = i.size - S * i.series.length - this.margin * i.series.length - S * parseInt(o.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, L = E - o.config.plotOptions.radialBar.hollow.margin;
      o.config.plotOptions.radialBar.hollow.image !== void 0 && (C = this.drawHollowImage(i, y, E, C));
      var O = this.drawHollow({ size: L, centerX: i.centerX, centerY: i.centerY, fill: C || "transparent" });
      if (o.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
        var P = o.config.plotOptions.radialBar.hollow.dropShadow;
        p.dropShadow(O, P);
      }
      var I = 1;
      !this.radialDataLabels.total.show && o.globals.series.length > 1 && (I = 0);
      var j = null;
      this.radialDataLabels.show && (j = this.renderInnerDataLabels(this.radialDataLabels, { hollowSize: E, centerX: i.centerX, centerY: i.centerY, opacity: I })), o.config.plotOptions.radialBar.hollow.position === "back" && (y.add(O), j && y.add(j));
      var V = !1;
      o.config.plotOptions.radialBar.inverseOrder && (V = !0);
      for (var Z = V ? i.series.length - 1 : 0; V ? Z >= 0 : Z < i.series.length; V ? Z-- : Z++) {
        var b = d.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: Q.escapeString(o.globals.seriesNames[Z]) });
        y.add(b), b.attr({ rel: Z + 1, "data:realIndex": Z }), this.ctx.series.addCollapsedClassToSeries(b, Z), i.size = i.size - S - this.margin;
        var M = f.fillPath({ seriesNumber: Z, size: i.size, value: i.series[Z] }), N = this.startAngle, X = void 0, K = Q.negToZero(i.series[Z] > 100 ? 100 : i.series[Z]) / 100, ee = Math.round(this.totalAngle * K) + this.startAngle, oe = void 0;
        o.globals.dataChanged && (X = this.startAngle, oe = Math.round(this.totalAngle * Q.negToZero(o.globals.previousPaths[Z]) / 100) + X), Math.abs(ee) + Math.abs(N) >= 360 && (ee -= 0.01), Math.abs(oe) + Math.abs(X) >= 360 && (oe -= 0.01);
        var de = ee - N, ke = Array.isArray(o.config.stroke.dashArray) ? o.config.stroke.dashArray[Z] : o.config.stroke.dashArray, _e = d.drawPath({ d: "", stroke: M, strokeWidth: S, fill: "none", fillOpacity: o.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + Z, strokeDashArray: ke });
        if (re.setAttrs(_e.node, { "data:angle": de, "data:value": i.series[Z] }), o.config.chart.dropShadow.enabled) {
          var Me = o.config.chart.dropShadow;
          p.dropShadow(_e, Me, Z);
        }
        p.setSelectionFilter(_e, 0, Z), this.addListeners(_e, this.radialDataLabels), b.add(_e), _e.attr({ index: 0, j: Z });
        var Ie = 0;
        !this.initialAnim || o.globals.resized || o.globals.dataChanged || (Ie = o.config.chart.animations.speed), o.globals.dataChanged && (Ie = o.config.chart.animations.dynamicAnimation.speed), this.animDur = Ie / (1.2 * i.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(_e, { centerX: i.centerX, centerY: i.centerY, endAngle: ee, startAngle: N, prevEndAngle: oe, prevStartAngle: X, size: i.size, i: Z, totalItems: 2, animBeginArr: this.animBeginArr, dur: Ie, shouldSetPrevPaths: !0, easing: o.globals.easing });
      }
      return { g: y, elHollow: O, dataLabels: j };
    } }, { key: "drawHollow", value: function(i) {
      var o = new re(this.ctx).drawCircle(2 * i.size);
      return o.attr({ class: "apexcharts-radialbar-hollow", cx: i.centerX, cy: i.centerY, r: i.size, fill: i.fill }), o;
    } }, { key: "drawHollowImage", value: function(i, o, d, f) {
      var p = this.w, y = new Je(this.ctx), S = Q.randomId(), C = p.config.plotOptions.radialBar.hollow.image;
      if (p.config.plotOptions.radialBar.hollow.imageClipped)
        y.clippedImgArea({ width: d, height: d, image: C, patternID: "pattern".concat(p.globals.cuid).concat(S) }), f = "url(#pattern".concat(p.globals.cuid).concat(S, ")");
      else {
        var E = p.config.plotOptions.radialBar.hollow.imageWidth, L = p.config.plotOptions.radialBar.hollow.imageHeight;
        if (E === void 0 && L === void 0) {
          var O = p.globals.dom.Paper.image(C).loaded(function(I) {
            this.move(i.centerX - I.width / 2 + p.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - I.height / 2 + p.config.plotOptions.radialBar.hollow.imageOffsetY);
          });
          o.add(O);
        } else {
          var P = p.globals.dom.Paper.image(C).loaded(function(I) {
            this.move(i.centerX - E / 2 + p.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - L / 2 + p.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(E, L);
          });
          o.add(P);
        }
      }
      return f;
    } }, { key: "getStrokeWidth", value: function(i) {
      var o = this.w;
      return i.size * (100 - parseInt(o.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (i.series.length + 1) - this.margin;
    } }]), n;
  }(), Vs = function(B) {
    U(n, gr);
    var t = se(n);
    function n() {
      return A(this, n), t.apply(this, arguments);
    }
    return F(n, [{ key: "draw", value: function(i, o) {
      var d = this.w, f = new re(this.ctx);
      this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = i, this.seriesRangeStart = d.globals.seriesRangeStart, this.seriesRangeEnd = d.globals.seriesRangeEnd, this.barHelpers.initVariables(i);
      for (var p = f.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), y = 0; y < i.length; y++) {
        var S, C, E, L, O = void 0, P = void 0, I = d.globals.comboCharts ? o[y] : y, j = f.group({ class: "apexcharts-series", seriesName: Q.escapeString(d.globals.seriesNames[I]), rel: y + 1, "data:realIndex": I });
        this.ctx.series.addCollapsedClassToSeries(j, I), i[y].length > 0 && (this.visibleI = this.visibleI + 1);
        var V = 0, Z = 0;
        this.yRatio.length > 1 && (this.yaxisIndex = I);
        var b = this.barHelpers.initialPositions();
        P = b.y, L = b.zeroW, O = b.x, Z = b.barWidth, V = b.barHeight, S = b.xDivision, C = b.yDivision, E = b.zeroH;
        for (var M = f.group({ class: "apexcharts-datalabels", "data:realIndex": I }), N = f.group({ class: "apexcharts-rangebar-goals-markers" }), X = 0; X < d.globals.dataPoints; X++) {
          var K, ee = this.barHelpers.getStrokeWidth(y, X, I), oe = this.seriesRangeStart[y][X], de = this.seriesRangeEnd[y][X], ke = null, _e = null, Me = null, Ie = { x: O, y: P, strokeWidth: ee, elSeries: j }, rt = this.seriesLen;
          if (d.config.plotOptions.bar.rangeBarGroupRows && (rt = 1), d.config.series[y].data[X] === void 0)
            break;
          if (this.isHorizontal) {
            Me = P + V * this.visibleI;
            var Qt = (C - V * rt) / 2;
            if (d.config.series[y].data[X].x) {
              var Kt = this.detectOverlappingBars({ i: y, j: X, barYPosition: Me, srty: Qt, barHeight: V, yDivision: C, initPositions: b });
              V = Kt.barHeight, Me = Kt.barYPosition;
            }
            Z = (ke = this.drawRangeBarPaths(v({ indexes: { i: y, j: X, realIndex: I }, barHeight: V, barYPosition: Me, zeroW: L, yDivision: C, y1: oe, y2: de }, Ie))).barWidth;
          } else {
            d.globals.isXNumeric && (O = (d.globals.seriesX[y][X] - d.globals.minX) / this.xRatio - Z / 2), _e = O + Z * this.visibleI;
            var mt = (S - Z * rt) / 2;
            if (d.config.series[y].data[X].x) {
              var Mn = this.detectOverlappingBars({ i: y, j: X, barXPosition: _e, srtx: mt, barWidth: Z, xDivision: S, initPositions: b });
              Z = Mn.barWidth, _e = Mn.barXPosition;
            }
            V = (ke = this.drawRangeColumnPaths(v({ indexes: { i: y, j: X, realIndex: I }, barWidth: Z, barXPosition: _e, zeroH: E, xDivision: S }, Ie))).barHeight;
          }
          var zn = this.barHelpers.drawGoalLine({ barXPosition: ke.barXPosition, barYPosition: Me, goalX: ke.goalX, goalY: ke.goalY, barHeight: V, barWidth: Z });
          zn && N.add(zn), P = ke.y, O = ke.x;
          var gt = this.barHelpers.getPathFillColor(i, y, X, I), jr = d.globals.stroke.colors[I];
          this.renderSeries((H(K = { realIndex: I, pathFill: gt, lineFill: jr, j: X, i: y, x: O, y: P, y1: oe, y2: de, pathFrom: ke.pathFrom, pathTo: ke.pathTo, strokeWidth: ee, elSeries: j, series: i, barHeight: V, barWidth: Z, barXPosition: _e, barYPosition: Me }, "barWidth", Z), H(K, "elDataLabelsWrap", M), H(K, "elGoalsMarkers", N), H(K, "visibleSeries", this.visibleI), H(K, "type", "rangebar"), K));
        }
        p.add(j);
      }
      return p;
    } }, { key: "detectOverlappingBars", value: function(i) {
      var o = i.i, d = i.j, f = i.barYPosition, p = i.barXPosition, y = i.srty, S = i.srtx, C = i.barHeight, E = i.barWidth, L = i.yDivision, O = i.xDivision, P = i.initPositions, I = this.w, j = [], V = I.config.series[o].data[d].rangeName, Z = I.config.series[o].data[d].x, b = Array.isArray(Z) ? Z.join(" ") : Z, M = I.globals.labels.map(function(X) {
        return Array.isArray(X) ? X.join(" ") : X;
      }).indexOf(b), N = I.globals.seriesRange[o].findIndex(function(X) {
        return X.x === b && X.overlaps.length > 0;
      });
      return this.isHorizontal ? (f = I.config.plotOptions.bar.rangeBarGroupRows ? y + L * M : y + C * this.visibleI + L * M, N > -1 && !I.config.plotOptions.bar.rangeBarOverlap && (j = I.globals.seriesRange[o][N].overlaps).indexOf(V) > -1 && (f = (C = P.barHeight / j.length) * this.visibleI + L * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + C * (this.visibleI + j.indexOf(V)) + L * M)) : (M > -1 && (p = I.config.plotOptions.bar.rangeBarGroupRows ? S + O * M : S + E * this.visibleI + O * M), N > -1 && !I.config.plotOptions.bar.rangeBarOverlap && (j = I.globals.seriesRange[o][N].overlaps).indexOf(V) > -1 && (p = (E = P.barWidth / j.length) * this.visibleI + O * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + E * (this.visibleI + j.indexOf(V)) + O * M)), { barYPosition: f, barXPosition: p, barHeight: C, barWidth: E };
    } }, { key: "drawRangeColumnPaths", value: function(i) {
      var o = i.indexes, d = i.x, f = i.xDivision, p = i.barWidth, y = i.barXPosition, S = i.zeroH, C = this.w, E = o.i, L = o.j, O = this.yRatio[this.yaxisIndex], P = o.realIndex, I = this.getRangeValue(P, L), j = Math.min(I.start, I.end), V = Math.max(I.start, I.end);
      this.series[E][L] === void 0 || this.series[E][L] === null ? j = S : (j = S - j / O, V = S - V / O);
      var Z = Math.abs(V - j), b = this.barHelpers.getColumnPaths({ barXPosition: y, barWidth: p, y1: j, y2: V, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: o.realIndex, i: P, j: L, w: C });
      return C.globals.isXNumeric || (d += f), { pathTo: b.pathTo, pathFrom: b.pathFrom, barHeight: Z, x: d, y: V, goalY: this.barHelpers.getGoalValues("y", null, S, E, L), barXPosition: y };
    } }, { key: "drawRangeBarPaths", value: function(i) {
      var o = i.indexes, d = i.y, f = i.y1, p = i.y2, y = i.yDivision, S = i.barHeight, C = i.barYPosition, E = i.zeroW, L = this.w, O = E + f / this.invertedYRatio, P = E + p / this.invertedYRatio, I = Math.abs(P - O), j = this.barHelpers.getBarpaths({ barYPosition: C, barHeight: S, x1: O, x2: P, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: o.realIndex, realIndex: o.realIndex, j: o.j, w: L });
      return L.globals.isXNumeric || (d += y), { pathTo: j.pathTo, pathFrom: j.pathFrom, barWidth: I, x: P, goalX: this.barHelpers.getGoalValues("x", E, null, o.realIndex, o.j), y: d };
    } }, { key: "getRangeValue", value: function(i, o) {
      var d = this.w;
      return { start: d.globals.seriesRangeStart[i][o], end: d.globals.seriesRangeEnd[i][o] };
    } }]), n;
  }(), hs = function() {
    function B(t) {
      A(this, B), this.w = t.w, this.lineCtx = t;
    }
    return F(B, [{ key: "sameValueSeriesFix", value: function(t, n) {
      var i = this.w;
      if ((i.config.fill.type === "gradient" || i.config.fill.type[t] === "gradient") && new ve(this.lineCtx.ctx, i).seriesHaveSameValues(t)) {
        var o = n[t].slice();
        o[o.length - 1] = o[o.length - 1] + 1e-6, n[t] = o;
      }
      return n;
    } }, { key: "calculatePoints", value: function(t) {
      var n = t.series, i = t.realIndex, o = t.x, d = t.y, f = t.i, p = t.j, y = t.prevY, S = this.w, C = [], E = [];
      if (p === 0) {
        var L = this.lineCtx.categoryAxisCorrection + S.config.markers.offsetX;
        S.globals.isXNumeric && (L = (S.globals.seriesX[i][0] - S.globals.minX) / this.lineCtx.xRatio + S.config.markers.offsetX), C.push(L), E.push(Q.isNumber(n[f][0]) ? y + S.config.markers.offsetY : null), C.push(o + S.config.markers.offsetX), E.push(Q.isNumber(n[f][p + 1]) ? d + S.config.markers.offsetY : null);
      } else
        C.push(o + S.config.markers.offsetX), E.push(Q.isNumber(n[f][p + 1]) ? d + S.config.markers.offsetY : null);
      return { x: C, y: E };
    } }, { key: "checkPreviousPaths", value: function(t) {
      for (var n = t.pathFromLine, i = t.pathFromArea, o = t.realIndex, d = this.w, f = 0; f < d.globals.previousPaths.length; f++) {
        var p = d.globals.previousPaths[f];
        (p.type === "line" || p.type === "area") && p.paths.length > 0 && parseInt(p.realIndex, 10) === parseInt(o, 10) && (p.type === "line" ? (this.lineCtx.appendPathFrom = !1, n = d.globals.previousPaths[f].paths[0].d) : p.type === "area" && (this.lineCtx.appendPathFrom = !1, i = d.globals.previousPaths[f].paths[0].d, d.config.stroke.show && d.globals.previousPaths[f].paths[1] && (n = d.globals.previousPaths[f].paths[1].d)));
      }
      return { pathFromLine: n, pathFromArea: i };
    } }, { key: "determineFirstPrevY", value: function(t) {
      var n, i = t.i, o = t.series, d = t.prevY, f = t.lineYPosition, p = this.w;
      if (((n = o[i]) === null || n === void 0 ? void 0 : n[0]) !== void 0)
        d = (f = p.config.chart.stacked && i > 0 ? this.lineCtx.prevSeriesY[i - 1][0] : this.lineCtx.zeroY) - o[i][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? o[i][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);
      else if (p.config.chart.stacked && i > 0 && o[i][0] === void 0) {
        for (var y = i - 1; y >= 0; y--)
          if (o[y][0] !== null && o[y][0] !== void 0) {
            d = f = this.lineCtx.prevSeriesY[y][0];
            break;
          }
      }
      return { prevY: d, lineYPosition: f };
    } }]), B;
  }(), Gs = function(B) {
    for (var t, n, i, o, d = function(C) {
      for (var E = [], L = C[0], O = C[1], P = E[0] = Hr(L, O), I = 1, j = C.length - 1; I < j; I++)
        L = O, O = C[I + 1], E[I] = 0.5 * (P + (P = Hr(L, O)));
      return E[I] = P, E;
    }(B), f = B.length - 1, p = [], y = 0; y < f; y++)
      i = Hr(B[y], B[y + 1]), Math.abs(i) < 1e-6 ? d[y] = d[y + 1] = 0 : (o = (t = d[y] / i) * t + (n = d[y + 1] / i) * n) > 9 && (o = 3 * i / Math.sqrt(o), d[y] = o * t, d[y + 1] = o * n);
    for (var S = 0; S <= f; S++)
      o = (B[Math.min(f, S + 1)][0] - B[Math.max(0, S - 1)][0]) / (6 * (1 + d[S] * d[S])), p.push([o || 0, d[S] * o || 0]);
    return p;
  }, Di = function(B) {
    for (var t = "", n = 0; n < B.length; n++) {
      var i = B[n], o = i.length;
      o > 4 ? (t += "C".concat(i[0], ", ").concat(i[1]), t += ", ".concat(i[2], ", ").concat(i[3]), t += ", ".concat(i[4], ", ").concat(i[5])) : o > 2 && (t += "S".concat(i[0], ", ").concat(i[1]), t += ", ".concat(i[2], ", ").concat(i[3]));
    }
    return t;
  }, Pa = function(B) {
    var t = Gs(B), n = B[1], i = B[0], o = [], d = t[1], f = t[0];
    o.push(i, [i[0] + f[0], i[1] + f[1], n[0] - d[0], n[1] - d[1], n[0], n[1]]);
    for (var p = 2, y = t.length; p < y; p++) {
      var S = B[p], C = t[p];
      o.push([S[0] - C[0], S[1] - C[1], S[0], S[1]]);
    }
    return o;
  };
  function Hr(B, t) {
    return (t[1] - B[1]) / (t[0] - B[0]);
  }
  var xi = function() {
    function B(t, n, i) {
      A(this, B), this.ctx = t, this.w = t.w, this.xyRatios = n, this.pointsChart = !(this.w.config.chart.type !== "bubble" && this.w.config.chart.type !== "scatter") || i, this.scatter = new At(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new hs(this), this.markers = new kt(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
    }
    return F(B, [{ key: "draw", value: function(t, n, i, o) {
      var d = this.w, f = new re(this.ctx), p = d.globals.comboCharts ? n : d.config.chart.type, y = f.group({ class: "apexcharts-".concat(p, "-series apexcharts-plot-series") }), S = new ve(this.ctx, d);
      this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t = S.getLogSeries(t), this.yRatio = S.getLogYRatios(this.yRatio);
      for (var C = [], E = 0; E < t.length; E++) {
        t = this.lineHelpers.sameValueSeriesFix(E, t);
        var L = d.globals.comboCharts ? i[E] : E;
        this._initSerieVariables(t, E, L);
        var O = [], P = [], I = [], j = d.globals.padHorizontal + this.categoryAxisCorrection;
        this.ctx.series.addCollapsedClassToSeries(this.elSeries, L), d.globals.isXNumeric && d.globals.seriesX.length > 0 && (j = (d.globals.seriesX[L][0] - d.globals.minX) / this.xRatio), I.push(j);
        var V, Z = j, b = void 0, M = Z, N = this.zeroY, X = this.zeroY;
        N = this.lineHelpers.determineFirstPrevY({ i: E, series: t, prevY: N, lineYPosition: 0 }).prevY, O.push(N), V = N, p === "rangeArea" && (b = X = this.lineHelpers.determineFirstPrevY({ i: E, series: o, prevY: X, lineYPosition: 0 }).prevY, P.push(X));
        var K = { type: p, series: t, realIndex: L, i: E, x: j, y: 1, pX: Z, pY: V, pathsFrom: this._calculatePathsFrom({ type: p, series: t, i: E, realIndex: L, prevX: M, prevY: N, prevY2: X }), linePaths: [], areaPaths: [], seriesIndex: i, lineYPosition: 0, xArrj: I, yArrj: O, y2Arrj: P, seriesRangeEnd: o }, ee = this._iterateOverDataPoints(v(v({}, K), {}, { iterations: p === "rangeArea" ? t[E].length - 1 : void 0, isRangeStart: !0 }));
        if (p === "rangeArea") {
          var oe = this._calculatePathsFrom({ series: o, i: E, realIndex: L, prevX: M, prevY: X }), de = this._iterateOverDataPoints(v(v({}, K), {}, { series: o, pY: b, pathsFrom: oe, iterations: o[E].length - 1, isRangeStart: !1 }));
          ee.linePaths[0] = de.linePath + ee.linePath, ee.pathFromLine = de.pathFromLine + ee.pathFromLine;
        }
        this._handlePaths({ type: p, realIndex: L, i: E, paths: ee }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), C.push(this.elSeries);
      }
      if (d.config.chart.stacked)
        for (var ke = C.length; ke > 0; ke--)
          y.add(C[ke - 1]);
      else
        for (var _e = 0; _e < C.length; _e++)
          y.add(C[_e]);
      return y;
    } }, { key: "_initSerieVariables", value: function(t, n, i) {
      var o = this.w, d = new re(this.ctx);
      this.xDivision = o.globals.gridWidth / (o.globals.dataPoints - (o.config.xaxis.tickPlacement === "on" ? 1 : 0)), this.strokeWidth = Array.isArray(o.config.stroke.width) ? o.config.stroke.width[i] : o.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = i), this.isReversed = o.config.yaxis[this.yaxisIndex] && o.config.yaxis[this.yaxisIndex].reversed, this.zeroY = o.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? o.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, (this.zeroY > o.globals.gridHeight || o.config.plotOptions.area.fillTo === "end") && (this.areaBottomY = o.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = d.group({ class: "apexcharts-series", seriesName: Q.escapeString(o.globals.seriesNames[i]) }), this.elPointsMain = d.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": i }), this.elDataLabelsWrap = d.group({ class: "apexcharts-datalabels", "data:realIndex": i });
      var f = t[n].length === o.globals.dataPoints;
      this.elSeries.attr({ "data:longestSeries": f, rel: n + 1, "data:realIndex": i }), this.appendPathFrom = !0;
    } }, { key: "_calculatePathsFrom", value: function(t) {
      var n, i, o, d, f = t.type, p = t.series, y = t.i, S = t.realIndex, C = t.prevX, E = t.prevY, L = t.prevY2, O = this.w, P = new re(this.ctx);
      if (p[y][0] === null) {
        for (var I = 0; I < p[y].length; I++)
          if (p[y][I] !== null) {
            C = this.xDivision * I, E = this.zeroY - p[y][I] / this.yRatio[this.yaxisIndex], n = P.move(C, E), i = P.move(C, this.areaBottomY);
            break;
          }
      } else
        n = P.move(C, E), f === "rangeArea" && (n = P.move(C, L) + P.line(C, E)), i = P.move(C, this.areaBottomY) + P.line(C, E);
      if (o = P.move(-1, this.zeroY) + P.line(-1, this.zeroY), d = P.move(-1, this.zeroY) + P.line(-1, this.zeroY), O.globals.previousPaths.length > 0) {
        var j = this.lineHelpers.checkPreviousPaths({ pathFromLine: o, pathFromArea: d, realIndex: S });
        o = j.pathFromLine, d = j.pathFromArea;
      }
      return { prevX: C, prevY: E, linePath: n, areaPath: i, pathFromLine: o, pathFromArea: d };
    } }, { key: "_handlePaths", value: function(t) {
      var n = t.type, i = t.realIndex, o = t.i, d = t.paths, f = this.w, p = new re(this.ctx), y = new Je(this.ctx);
      this.prevSeriesY.push(d.yArrj), f.globals.seriesXvalues[i] = d.xArrj, f.globals.seriesYvalues[i] = d.yArrj;
      var S = f.config.forecastDataPoints;
      if (S.count > 0 && n !== "rangeArea") {
        var C = f.globals.seriesXvalues[i][f.globals.seriesXvalues[i].length - S.count - 1], E = p.drawRect(C, 0, f.globals.gridWidth, f.globals.gridHeight, 0);
        f.globals.dom.elForecastMask.appendChild(E.node);
        var L = p.drawRect(0, 0, C, f.globals.gridHeight, 0);
        f.globals.dom.elNonForecastMask.appendChild(L.node);
      }
      this.pointsChart || f.globals.delayedElements.push({ el: this.elPointsMain.node, index: i });
      var O = { i: o, realIndex: i, animationDelay: o, initialSpeed: f.config.chart.animations.speed, dataChangeSpeed: f.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(n) };
      if (n === "area")
        for (var P = y.fillPath({ seriesNumber: i }), I = 0; I < d.areaPaths.length; I++) {
          var j = p.renderPaths(v(v({}, O), {}, { pathFrom: d.pathFromArea, pathTo: d.areaPaths[I], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: P }));
          this.elSeries.add(j);
        }
      if (f.config.stroke.show && !this.pointsChart) {
        var V = null;
        if (n === "line")
          V = y.fillPath({ seriesNumber: i, i: o });
        else if (f.config.stroke.fill.type === "solid")
          V = f.globals.stroke.colors[i];
        else {
          var Z = f.config.fill;
          f.config.fill = f.config.stroke.fill, V = y.fillPath({ seriesNumber: i, i: o }), f.config.fill = Z;
        }
        for (var b = 0; b < d.linePaths.length; b++) {
          var M = V;
          n === "rangeArea" && (M = y.fillPath({ seriesNumber: i }));
          var N = v(v({}, O), {}, { pathFrom: d.pathFromLine, pathTo: d.linePaths[b], stroke: V, strokeWidth: this.strokeWidth, strokeLineCap: f.config.stroke.lineCap, fill: n === "rangeArea" ? M : "none" }), X = p.renderPaths(N);
          if (this.elSeries.add(X), X.attr("fill-rule", "evenodd"), S.count > 0 && n !== "rangeArea") {
            var K = p.renderPaths(N);
            K.node.setAttribute("stroke-dasharray", S.dashArray), S.strokeWidth && K.node.setAttribute("stroke-width", S.strokeWidth), this.elSeries.add(K), K.attr("clip-path", "url(#forecastMask".concat(f.globals.cuid, ")")), X.attr("clip-path", "url(#nonForecastMask".concat(f.globals.cuid, ")"));
          }
        }
      }
    } }, { key: "_iterateOverDataPoints", value: function(t) {
      var n = t.type, i = t.series, o = t.iterations, d = t.realIndex, f = t.i, p = t.x, y = t.y, S = t.pX, C = t.pY, E = t.pathsFrom, L = t.linePaths, O = t.areaPaths, P = t.seriesIndex, I = t.lineYPosition, j = t.xArrj, V = t.yArrj, Z = t.y2Arrj, b = t.isRangeStart, M = t.seriesRangeEnd, N = this.w, X = new re(this.ctx), K = this.yRatio, ee = E.prevY, oe = E.linePath, de = E.areaPath, ke = E.pathFromLine, _e = E.pathFromArea, Me = Q.isNumber(N.globals.minYArr[d]) ? N.globals.minYArr[d] : N.globals.minY;
      o || (o = N.globals.dataPoints > 1 ? N.globals.dataPoints - 1 : N.globals.dataPoints);
      for (var Ie = y, rt = 0; rt < o; rt++) {
        var Qt = i[f][rt + 1] === void 0 || i[f][rt + 1] === null;
        if (N.globals.isXNumeric) {
          var Kt = N.globals.seriesX[d][rt + 1];
          N.globals.seriesX[d][rt + 1] === void 0 && (Kt = N.globals.seriesX[d][o - 1]), p = (Kt - N.globals.minX) / this.xRatio;
        } else
          p += this.xDivision;
        N.config.chart.stacked ? f > 0 && N.globals.collapsedSeries.length < N.config.series.length - 1 ? I = this.prevSeriesY[function(zn) {
          for (var gt = zn, jr = 0; jr < N.globals.series.length; jr++)
            if (N.globals.collapsedSeriesIndices.indexOf(zn) > -1) {
              gt--;
              break;
            }
          return gt >= 0 ? gt : 0;
        }(f - 1)][rt + 1] : I = this.zeroY : I = this.zeroY, Qt ? y = I - Me / K[this.yaxisIndex] + 2 * (this.isReversed ? Me / K[this.yaxisIndex] : 0) : (y = I - i[f][rt + 1] / K[this.yaxisIndex] + 2 * (this.isReversed ? i[f][rt + 1] / K[this.yaxisIndex] : 0), n === "rangeArea" && (Ie = I - M[f][rt + 1] / K[this.yaxisIndex] + 2 * (this.isReversed ? M[f][rt + 1] / K[this.yaxisIndex] : 0))), j.push(p), V.push(y), Z.push(Ie);
        var mt = this.lineHelpers.calculatePoints({ series: i, x: p, y, realIndex: d, i: f, j: rt, prevY: ee }), Mn = this._createPaths({ type: n, series: i, i: f, realIndex: d, j: rt, x: p, y, y2: Ie, xArrj: j, yArrj: V, y2Arrj: Z, pX: S, pY: C, linePath: oe, areaPath: de, linePaths: L, areaPaths: O, seriesIndex: P, isRangeStart: b });
        O = Mn.areaPaths, L = Mn.linePaths, S = Mn.pX, C = Mn.pY, de = Mn.areaPath, oe = Mn.linePath, !this.appendPathFrom || N.config.stroke.curve === "monotoneCubic" && n === "rangeArea" || (ke += X.line(p, this.zeroY), _e += X.line(p, this.zeroY)), this.handleNullDataPoints(i, mt, f, rt, d), this._handleMarkersAndLabels({ type: n, pointsPos: mt, i: f, j: rt, realIndex: d, isRangeStart: b });
      }
      return { yArrj: V, xArrj: j, pathFromArea: _e, areaPaths: O, pathFromLine: ke, linePaths: L, linePath: oe, areaPath: de };
    } }, { key: "_handleMarkersAndLabels", value: function(t) {
      var n = t.type, i = t.pointsPos, o = t.isRangeStart, d = t.i, f = t.j, p = t.realIndex, y = this.w, S = new jt(this.ctx);
      if (this.pointsChart)
        this.scatter.draw(this.elSeries, f, { realIndex: p, pointsPos: i, zRatio: this.zRatio, elParent: this.elPointsMain });
      else {
        y.globals.series[d].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
        var C = this.markers.plotChartMarkers(i, p, f + 1);
        C !== null && this.elPointsMain.add(C);
      }
      var E = S.drawDataLabel({ type: n, isRangeStart: o, pos: i, i: p, j: f + 1 });
      E !== null && this.elDataLabelsWrap.add(E);
    } }, { key: "_createPaths", value: function(t) {
      var n = t.type, i = t.series, o = t.i, d = t.realIndex, f = t.j, p = t.x, y = t.y, S = t.xArrj, C = t.yArrj, E = t.y2, L = t.y2Arrj, O = t.pX, P = t.pY, I = t.linePath, j = t.areaPath, V = t.linePaths, Z = t.areaPaths, b = t.seriesIndex, M = t.isRangeStart, N = this.w, X = new re(this.ctx), K = N.config.stroke.curve, ee = this.areaBottomY;
      if (Array.isArray(N.config.stroke.curve) && (K = Array.isArray(b) ? N.config.stroke.curve[b[o]] : N.config.stroke.curve[o]), (n === "rangeArea" && (N.globals.hasNullValues || N.config.forecastDataPoints.count > 0) || N.globals.hasNullValues) && K === "monotoneCubic" && (K = "straight"), K === "smooth") {
        var oe = 0.35 * (p - O);
        N.globals.hasNullValues ? (i[o][f] !== null && (i[o][f + 1] !== null ? (I = X.move(O, P) + X.curve(O + oe, P, p - oe, y, p + 1, y), j = X.move(O + 1, P) + X.curve(O + oe, P, p - oe, y, p + 1, y) + X.line(p, ee) + X.line(O, ee) + "z") : (I = X.move(O, P), j = X.move(O, P) + "z")), V.push(I), Z.push(j)) : (I += X.curve(O + oe, P, p - oe, y, p, y), j += X.curve(O + oe, P, p - oe, y, p, y)), O = p, P = y, f === i[o].length - 2 && (j += X.curve(O, P, p, y, p, ee) + X.move(p, y) + "z", n === "rangeArea" && M ? I += X.curve(O, P, p, y, p, E) + X.move(p, E) + "z" : N.globals.hasNullValues || (V.push(I), Z.push(j)));
      } else if (K === "monotoneCubic") {
        if (n === "rangeArea" ? S.length === N.globals.dataPoints : f === i[o].length - 2) {
          var de = S.map(function(Kt, mt) {
            return [S[mt], C[mt]];
          }), ke = Pa(de);
          if (I += Di(ke), j += Di(ke), O = p, P = y, n === "rangeArea" && M) {
            I += X.line(S[S.length - 1], L[L.length - 1]);
            var _e = S.slice().reverse(), Me = L.slice().reverse(), Ie = _e.map(function(Kt, mt) {
              return [_e[mt], Me[mt]];
            }), rt = Pa(Ie);
            j = I += Di(rt);
          } else
            j += X.curve(O, P, p, y, p, ee) + X.move(p, y) + "z";
          V.push(I), Z.push(j);
        }
      } else {
        if (i[o][f + 1] === null) {
          I += X.move(p, y);
          var Qt = N.globals.isXNumeric ? (N.globals.seriesX[d][f] - N.globals.minX) / this.xRatio : p - this.xDivision;
          j = j + X.line(Qt, ee) + X.move(p, y) + "z";
        }
        i[o][f] === null && (I += X.move(p, y), j += X.move(p, ee)), K === "stepline" ? (I = I + X.line(p, null, "H") + X.line(null, y, "V"), j = j + X.line(p, null, "H") + X.line(null, y, "V")) : K === "straight" && (I += X.line(p, y), j += X.line(p, y)), f === i[o].length - 2 && (j = j + X.line(p, ee) + X.move(p, y) + "z", n === "rangeArea" && M ? I = I + X.line(p, E) + X.move(p, E) + "z" : (V.push(I), Z.push(j)));
      }
      return { linePaths: V, areaPaths: Z, pX: O, pY: P, linePath: I, areaPath: j };
    } }, { key: "handleNullDataPoints", value: function(t, n, i, o, d) {
      var f = this.w;
      if (t[i][o] === null && f.config.markers.showNullDataPoints || t[i].length === 1) {
        var p = this.markers.plotChartMarkers(n, d, o + 1, this.strokeWidth - f.config.markers.strokeWidth / 2, !0);
        p !== null && this.elPointsMain.add(p);
      }
    } }]), B;
  }();
  window.TreemapSquared = {}, window.TreemapSquared.generate = function() {
    function B(p, y, S, C) {
      this.xoffset = p, this.yoffset = y, this.height = C, this.width = S, this.shortestEdge = function() {
        return Math.min(this.height, this.width);
      }, this.getCoordinates = function(E) {
        var L, O = [], P = this.xoffset, I = this.yoffset, j = d(E) / this.height, V = d(E) / this.width;
        if (this.width >= this.height)
          for (L = 0; L < E.length; L++)
            O.push([P, I, P + j, I + E[L] / j]), I += E[L] / j;
        else
          for (L = 0; L < E.length; L++)
            O.push([P, I, P + E[L] / V, I + V]), P += E[L] / V;
        return O;
      }, this.cutArea = function(E) {
        var L;
        if (this.width >= this.height) {
          var O = E / this.height, P = this.width - O;
          L = new B(this.xoffset + O, this.yoffset, P, this.height);
        } else {
          var I = E / this.width, j = this.height - I;
          L = new B(this.xoffset, this.yoffset + I, this.width, j);
        }
        return L;
      };
    }
    function t(p, y, S, C, E) {
      C = C === void 0 ? 0 : C, E = E === void 0 ? 0 : E;
      var L = n(function(O, P) {
        var I, j = [], V = P / d(O);
        for (I = 0; I < O.length; I++)
          j[I] = O[I] * V;
        return j;
      }(p, y * S), [], new B(C, E, y, S), []);
      return function(O) {
        var P, I, j = [];
        for (P = 0; P < O.length; P++)
          for (I = 0; I < O[P].length; I++)
            j.push(O[P][I]);
        return j;
      }(L);
    }
    function n(p, y, S, C) {
      var E, L, O;
      if (p.length !== 0)
        return E = S.shortestEdge(), function(P, I, j) {
          var V;
          if (P.length === 0)
            return !0;
          (V = P.slice()).push(I);
          var Z = i(P, j), b = i(V, j);
          return Z >= b;
        }(y, L = p[0], E) ? (y.push(L), n(p.slice(1), y, S, C)) : (O = S.cutArea(d(y), C), C.push(S.getCoordinates(y)), n(p, [], O, C)), C;
      C.push(S.getCoordinates(y));
    }
    function i(p, y) {
      var S = Math.min.apply(Math, p), C = Math.max.apply(Math, p), E = d(p);
      return Math.max(Math.pow(y, 2) * C / Math.pow(E, 2), Math.pow(E, 2) / (Math.pow(y, 2) * S));
    }
    function o(p) {
      return p && p.constructor === Array;
    }
    function d(p) {
      var y, S = 0;
      for (y = 0; y < p.length; y++)
        S += p[y];
      return S;
    }
    function f(p) {
      var y, S = 0;
      if (o(p[0]))
        for (y = 0; y < p.length; y++)
          S += f(p[y]);
      else
        S = d(p);
      return S;
    }
    return function p(y, S, C, E, L) {
      E = E === void 0 ? 0 : E, L = L === void 0 ? 0 : L;
      var O, P, I = [], j = [];
      if (o(y[0])) {
        for (P = 0; P < y.length; P++)
          I[P] = f(y[P]);
        for (O = t(I, S, C, E, L), P = 0; P < y.length; P++)
          j.push(p(y[P], O[P][2] - O[P][0], O[P][3] - O[P][1], O[P][0], O[P][1]));
      } else
        j = t(y, S, C, E, L);
      return j;
    };
  }();
  var ii, le, Ye = function() {
    function B(t, n) {
      A(this, B), this.ctx = t, this.w = t.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new us(t), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
    }
    return F(B, [{ key: "draw", value: function(t) {
      var n = this, i = this.w, o = new re(this.ctx), d = new Je(this.ctx), f = o.group({ class: "apexcharts-treemap" });
      if (i.globals.noData)
        return f;
      var p = [];
      return t.forEach(function(y) {
        var S = y.map(function(C) {
          return Math.abs(C);
        });
        p.push(S);
      }), this.negRange = this.helpers.checkColorRange(), i.config.series.forEach(function(y, S) {
        y.data.forEach(function(C) {
          Array.isArray(n.labels[S]) || (n.labels[S] = []), n.labels[S].push(C.x);
        });
      }), window.TreemapSquared.generate(p, i.globals.gridWidth, i.globals.gridHeight).forEach(function(y, S) {
        var C = o.group({ class: "apexcharts-series apexcharts-treemap-series", seriesName: Q.escapeString(i.globals.seriesNames[S]), rel: S + 1, "data:realIndex": S });
        if (i.config.chart.dropShadow.enabled) {
          var E = i.config.chart.dropShadow;
          new Ee(n.ctx).dropShadow(f, E, S);
        }
        var L = o.group({ class: "apexcharts-data-labels" });
        y.forEach(function(O, P) {
          var I = O[0], j = O[1], V = O[2], Z = O[3], b = o.drawRect(I, j, V - I, Z - j, 0, "#fff", 1, n.strokeWidth, i.config.plotOptions.treemap.useFillColorAsStroke ? N : i.globals.stroke.colors[S]);
          b.attr({ cx: I, cy: j, index: S, i: S, j: P, width: V - I, height: Z - j });
          var M = n.helpers.getShadeColor(i.config.chart.type, S, P, n.negRange), N = M.color;
          i.config.series[S].data[P] !== void 0 && i.config.series[S].data[P].fillColor && (N = i.config.series[S].data[P].fillColor);
          var X = d.fillPath({ color: N, seriesNumber: S, dataPointIndex: P });
          b.node.classList.add("apexcharts-treemap-rect"), b.attr({ fill: X }), n.helpers.addListeners(b);
          var K = { x: I + (V - I) / 2, y: j + (Z - j) / 2, width: 0, height: 0 }, ee = { x: I, y: j, width: V - I, height: Z - j };
          if (i.config.chart.animations.enabled && !i.globals.dataChanged) {
            var oe = 1;
            i.globals.resized || (oe = i.config.chart.animations.speed), n.animateTreemap(b, K, ee, oe);
          }
          if (i.globals.dataChanged) {
            var de = 1;
            n.dynamicAnim.enabled && i.globals.shouldAnimate && (de = n.dynamicAnim.speed, i.globals.previousPaths[S] && i.globals.previousPaths[S][P] && i.globals.previousPaths[S][P].rect && (K = i.globals.previousPaths[S][P].rect), n.animateTreemap(b, K, ee, de));
          }
          var ke = n.getFontSize(O), _e = i.config.dataLabels.formatter(n.labels[S][P], { value: i.globals.series[S][P], seriesIndex: S, dataPointIndex: P, w: i });
          i.config.plotOptions.treemap.dataLabels.format === "truncate" && (ke = parseInt(i.config.dataLabels.style.fontSize, 10), _e = n.truncateLabels(_e, ke, I, j, V, Z));
          var Me = n.helpers.calculateDataLabels({ text: _e, x: (I + V) / 2, y: (j + Z) / 2 + n.strokeWidth / 2 + ke / 3, i: S, j: P, colorProps: M, fontSize: ke, series: t });
          i.config.dataLabels.enabled && Me && n.rotateToFitLabel(Me, ke, _e, I, j, V, Z), C.add(b), Me !== null && C.add(Me);
        }), C.add(L), f.add(C);
      }), f;
    } }, { key: "getFontSize", value: function(t) {
      var n = this.w, i, o, d, f, p = function y(S) {
        var C, E = 0;
        if (Array.isArray(S[0]))
          for (C = 0; C < S.length; C++)
            E += y(S[C]);
        else
          for (C = 0; C < S.length; C++)
            E += S[C].length;
        return E;
      }(this.labels) / function y(S) {
        var C, E = 0;
        if (Array.isArray(S[0]))
          for (C = 0; C < S.length; C++)
            E += y(S[C]);
        else
          for (C = 0; C < S.length; C++)
            E += 1;
        return E;
      }(this.labels);
      return i = t[2] - t[0], o = t[3] - t[1], d = i * o, f = Math.pow(d, 0.5), Math.min(f / p, parseInt(n.config.dataLabels.style.fontSize, 10));
    } }, { key: "rotateToFitLabel", value: function(t, n, i, o, d, f, p) {
      var y = new re(this.ctx), S = y.getTextRects(i, n);
      if (S.width + this.w.config.stroke.width + 5 > f - o && S.width <= p - d) {
        var C = y.rotateAroundCenter(t.node);
        t.node.setAttribute("transform", "rotate(-90 ".concat(C.x, " ").concat(C.y, ") translate(").concat(S.height / 3, ")"));
      }
    } }, { key: "truncateLabels", value: function(t, n, i, o, d, f) {
      var p = new re(this.ctx), y = p.getTextRects(t, n).width + this.w.config.stroke.width + 5 > d - i && f - o > d - i ? f - o : d - i, S = p.getTextBasedOnMaxWidth({ text: t, maxWidth: y, fontSize: n });
      return t.length !== S.length && y / n < 5 ? "" : S;
    } }, { key: "animateTreemap", value: function(t, n, i, o) {
      var d = new we(this.ctx);
      d.animateRect(t, { x: n.x, y: n.y, width: n.width, height: n.height }, { x: i.x, y: i.y, width: i.width, height: i.height }, o, function() {
        d.animationCompleted(t);
      });
    } }]), B;
  }(), et = 86400, Dt = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
    }
    return F(B, [{ key: "calculateTimeScaleTicks", value: function(t, n) {
      var i = this, o = this.w;
      if (o.globals.allSeriesCollapsed)
        return o.globals.labels = [], o.globals.timescaleLabels = [], [];
      var d = new it(this.ctx), f = (n - t) / 864e5;
      this.determineInterval(f), o.globals.disableZoomIn = !1, o.globals.disableZoomOut = !1, f < 11574074074074075e-20 ? o.globals.disableZoomIn = !0 : f > 5e4 && (o.globals.disableZoomOut = !0);
      var p = d.getTimeUnitsfromTimestamp(t, n, this.utc), y = o.globals.gridWidth / f, S = y / 24, C = S / 60, E = C / 60, L = Math.floor(24 * f), O = Math.floor(1440 * f), P = Math.floor(f * et), I = Math.floor(f), j = Math.floor(f / 30), V = Math.floor(f / 365), Z = { minMillisecond: p.minMillisecond, minSecond: p.minSecond, minMinute: p.minMinute, minHour: p.minHour, minDate: p.minDate, minMonth: p.minMonth, minYear: p.minYear }, b = { firstVal: Z, currentMillisecond: Z.minMillisecond, currentSecond: Z.minSecond, currentMinute: Z.minMinute, currentHour: Z.minHour, currentMonthDate: Z.minDate, currentDate: Z.minDate, currentMonth: Z.minMonth, currentYear: Z.minYear, daysWidthOnXAxis: y, hoursWidthOnXAxis: S, minutesWidthOnXAxis: C, secondsWidthOnXAxis: E, numberOfSeconds: P, numberOfMinutes: O, numberOfHours: L, numberOfDays: I, numberOfMonths: j, numberOfYears: V };
      switch (this.tickInterval) {
        case "years":
          this.generateYearScale(b);
          break;
        case "months":
        case "half_year":
          this.generateMonthScale(b);
          break;
        case "months_days":
        case "months_fortnight":
        case "days":
        case "week_days":
          this.generateDayScale(b);
          break;
        case "hours":
          this.generateHourScale(b);
          break;
        case "minutes_fives":
        case "minutes":
          this.generateMinuteScale(b);
          break;
        case "seconds_tens":
        case "seconds_fives":
        case "seconds":
          this.generateSecondScale(b);
      }
      var M = this.timeScaleArray.map(function(N) {
        var X = { position: N.position, unit: N.unit, year: N.year, day: N.day ? N.day : 1, hour: N.hour ? N.hour : 0, month: N.month + 1 };
        return N.unit === "month" ? v(v({}, X), {}, { day: 1, value: N.value + 1 }) : N.unit === "day" || N.unit === "hour" ? v(v({}, X), {}, { value: N.value }) : N.unit === "minute" ? v(v({}, X), {}, { value: N.value, minute: N.value }) : N.unit === "second" ? v(v({}, X), {}, { value: N.value, minute: N.minute, second: N.second }) : N;
      });
      return M.filter(function(N) {
        var X = 1, K = Math.ceil(o.globals.gridWidth / 120), ee = N.value;
        o.config.xaxis.tickAmount !== void 0 && (K = o.config.xaxis.tickAmount), M.length > K && (X = Math.floor(M.length / K));
        var oe = !1, de = !1;
        switch (i.tickInterval) {
          case "years":
            N.unit === "year" && (oe = !0);
            break;
          case "half_year":
            X = 7, N.unit === "year" && (oe = !0);
            break;
          case "months":
            X = 1, N.unit === "year" && (oe = !0);
            break;
          case "months_fortnight":
            X = 15, N.unit !== "year" && N.unit !== "month" || (oe = !0), ee === 30 && (de = !0);
            break;
          case "months_days":
            X = 10, N.unit === "month" && (oe = !0), ee === 30 && (de = !0);
            break;
          case "week_days":
            X = 8, N.unit === "month" && (oe = !0);
            break;
          case "days":
            X = 1, N.unit === "month" && (oe = !0);
            break;
          case "hours":
            N.unit === "day" && (oe = !0);
            break;
          case "minutes_fives":
          case "seconds_fives":
            ee % 5 != 0 && (de = !0);
            break;
          case "seconds_tens":
            ee % 10 != 0 && (de = !0);
        }
        if (i.tickInterval === "hours" || i.tickInterval === "minutes_fives" || i.tickInterval === "seconds_tens" || i.tickInterval === "seconds_fives") {
          if (!de)
            return !0;
        } else if ((ee % X == 0 || oe) && !de)
          return !0;
      });
    } }, { key: "recalcDimensionsBasedOnFormat", value: function(t, n) {
      var i = this.w, o = this.formatDates(t), d = this.removeOverlappingTS(o);
      i.globals.timescaleLabels = d.slice(), new ti(this.ctx).plotCoords();
    } }, { key: "determineInterval", value: function(t) {
      var n = 24 * t, i = 60 * n;
      switch (!0) {
        case t / 365 > 5:
          this.tickInterval = "years";
          break;
        case t > 800:
          this.tickInterval = "half_year";
          break;
        case t > 180:
          this.tickInterval = "months";
          break;
        case t > 90:
          this.tickInterval = "months_fortnight";
          break;
        case t > 60:
          this.tickInterval = "months_days";
          break;
        case t > 30:
          this.tickInterval = "week_days";
          break;
        case t > 2:
          this.tickInterval = "days";
          break;
        case n > 2.4:
          this.tickInterval = "hours";
          break;
        case i > 15:
          this.tickInterval = "minutes_fives";
          break;
        case i > 5:
          this.tickInterval = "minutes";
          break;
        case i > 1:
          this.tickInterval = "seconds_tens";
          break;
        case 60 * i > 20:
          this.tickInterval = "seconds_fives";
          break;
        default:
          this.tickInterval = "seconds";
      }
    } }, { key: "generateYearScale", value: function(t) {
      var n = t.firstVal, i = t.currentMonth, o = t.currentYear, d = t.daysWidthOnXAxis, f = t.numberOfYears, p = n.minYear, y = 0, S = new it(this.ctx), C = "year";
      if (n.minDate > 1 || n.minMonth > 0) {
        var E = S.determineRemainingDaysOfYear(n.minYear, n.minMonth, n.minDate);
        y = (S.determineDaysOfYear(n.minYear) - E + 1) * d, p = n.minYear + 1, this.timeScaleArray.push({ position: y, value: p, unit: C, year: p, month: Q.monthMod(i + 1) });
      } else
        n.minDate === 1 && n.minMonth === 0 && this.timeScaleArray.push({ position: y, value: p, unit: C, year: o, month: Q.monthMod(i + 1) });
      for (var L = p, O = y, P = 0; P < f; P++)
        L++, O = S.determineDaysOfYear(L - 1) * d + O, this.timeScaleArray.push({ position: O, value: L, unit: C, year: L, month: 1 });
    } }, { key: "generateMonthScale", value: function(t) {
      var n = t.firstVal, i = t.currentMonthDate, o = t.currentMonth, d = t.currentYear, f = t.daysWidthOnXAxis, p = t.numberOfMonths, y = o, S = 0, C = new it(this.ctx), E = "month", L = 0;
      if (n.minDate > 1) {
        S = (C.determineDaysOfMonths(o + 1, n.minYear) - i + 1) * f, y = Q.monthMod(o + 1);
        var O = d + L, P = Q.monthMod(y), I = y;
        y === 0 && (E = "year", I = O, P = 1, O += L += 1), this.timeScaleArray.push({ position: S, value: I, unit: E, year: O, month: P });
      } else
        this.timeScaleArray.push({ position: S, value: y, unit: E, year: d, month: Q.monthMod(o) });
      for (var j = y + 1, V = S, Z = 0, b = 1; Z < p; Z++, b++) {
        (j = Q.monthMod(j)) === 0 ? (E = "year", L += 1) : E = "month";
        var M = this._getYear(d, j, L);
        V = C.determineDaysOfMonths(j, M) * f + V;
        var N = j === 0 ? M : j;
        this.timeScaleArray.push({ position: V, value: N, unit: E, year: M, month: j === 0 ? 1 : j }), j++;
      }
    } }, { key: "generateDayScale", value: function(t) {
      var n = t.firstVal, i = t.currentMonth, o = t.currentYear, d = t.hoursWidthOnXAxis, f = t.numberOfDays, p = new it(this.ctx), y = "day", S = n.minDate + 1, C = S, E = function(b, M, N) {
        return b > p.determineDaysOfMonths(M + 1, N) && (C = 1, y = "month", O = M += 1), M;
      }, L = (24 - n.minHour) * d, O = S, P = E(C, i, o);
      n.minHour === 0 && n.minDate === 1 ? (L = 0, O = Q.monthMod(n.minMonth), y = "month", C = n.minDate, f++) : n.minDate !== 1 && n.minHour === 0 && n.minMinute === 0 && (L = 0, S = n.minDate, O = S, P = E(C = S, i, o)), this.timeScaleArray.push({ position: L, value: O, unit: y, year: this._getYear(o, P, 0), month: Q.monthMod(P), day: C });
      for (var I = L, j = 0; j < f; j++) {
        y = "day", P = E(C += 1, P, this._getYear(o, P, 0));
        var V = this._getYear(o, P, 0);
        I = 24 * d + I;
        var Z = C === 1 ? Q.monthMod(P) : C;
        this.timeScaleArray.push({ position: I, value: Z, unit: y, year: V, month: Q.monthMod(P), day: Z });
      }
    } }, { key: "generateHourScale", value: function(t) {
      var n = t.firstVal, i = t.currentDate, o = t.currentMonth, d = t.currentYear, f = t.minutesWidthOnXAxis, p = t.numberOfHours, y = new it(this.ctx), S = "hour", C = function(X, K) {
        return X > y.determineDaysOfMonths(K + 1, d) && (j = 1, K += 1), { month: K, date: j };
      }, E = function(X, K) {
        return X > y.determineDaysOfMonths(K + 1, d) ? K += 1 : K;
      }, L = 60 - (n.minMinute + n.minSecond / 60), O = L * f, P = n.minHour + 1, I = P + 1;
      L === 60 && (O = 0, I = (P = n.minHour) + 1);
      var j = i, V = E(j, o);
      this.timeScaleArray.push({ position: O, value: P, unit: S, day: j, hour: I, year: d, month: Q.monthMod(V) });
      for (var Z = O, b = 0; b < p; b++) {
        S = "hour", I >= 24 && (I = 0, S = "day", V = C(j += 1, V).month, V = E(j, V));
        var M = this._getYear(d, V, 0);
        Z = 60 * f + Z;
        var N = I === 0 ? j : I;
        this.timeScaleArray.push({ position: Z, value: N, unit: S, hour: I, day: j, year: M, month: Q.monthMod(V) }), I++;
      }
    } }, { key: "generateMinuteScale", value: function(t) {
      for (var n = t.currentMillisecond, i = t.currentSecond, o = t.currentMinute, d = t.currentHour, f = t.currentDate, p = t.currentMonth, y = t.currentYear, S = t.minutesWidthOnXAxis, C = t.secondsWidthOnXAxis, E = t.numberOfMinutes, L = o + 1, O = f, P = p, I = y, j = d, V = (60 - i - n / 1e3) * C, Z = 0; Z < E; Z++)
        L >= 60 && (L = 0, (j += 1) === 24 && (j = 0)), this.timeScaleArray.push({ position: V, value: L, unit: "minute", hour: j, minute: L, day: O, year: this._getYear(I, P, 0), month: Q.monthMod(P) }), V += S, L++;
    } }, { key: "generateSecondScale", value: function(t) {
      for (var n = t.currentMillisecond, i = t.currentSecond, o = t.currentMinute, d = t.currentHour, f = t.currentDate, p = t.currentMonth, y = t.currentYear, S = t.secondsWidthOnXAxis, C = t.numberOfSeconds, E = i + 1, L = o, O = f, P = p, I = y, j = d, V = (1e3 - n) / 1e3 * S, Z = 0; Z < C; Z++)
        E >= 60 && (E = 0, ++L >= 60 && (L = 0, ++j === 24 && (j = 0))), this.timeScaleArray.push({ position: V, value: E, unit: "second", hour: j, minute: L, second: E, day: O, year: this._getYear(I, P, 0), month: Q.monthMod(P) }), V += S, E++;
    } }, { key: "createRawDateString", value: function(t, n) {
      var i = t.year;
      return t.month === 0 && (t.month = 1), i += "-" + ("0" + t.month.toString()).slice(-2), t.unit === "day" ? i += t.unit === "day" ? "-" + ("0" + n).slice(-2) : "-01" : i += "-" + ("0" + (t.day ? t.day : "1")).slice(-2), t.unit === "hour" ? i += t.unit === "hour" ? "T" + ("0" + n).slice(-2) : "T00" : i += "T" + ("0" + (t.hour ? t.hour : "0")).slice(-2), t.unit === "minute" ? i += ":" + ("0" + n).slice(-2) : i += ":" + (t.minute ? ("0" + t.minute).slice(-2) : "00"), t.unit === "second" ? i += ":" + ("0" + n).slice(-2) : i += ":00", this.utc && (i += ".000Z"), i;
    } }, { key: "formatDates", value: function(t) {
      var n = this, i = this.w;
      return t.map(function(o) {
        var d = o.value.toString(), f = new it(n.ctx), p = n.createRawDateString(o, d), y = f.getDate(f.parseDate(p));
        if (n.utc || (y = f.getDate(f.parseDateWithTimezone(p))), i.config.xaxis.labels.format === void 0) {
          var S = "dd MMM", C = i.config.xaxis.labels.datetimeFormatter;
          o.unit === "year" && (S = C.year), o.unit === "month" && (S = C.month), o.unit === "day" && (S = C.day), o.unit === "hour" && (S = C.hour), o.unit === "minute" && (S = C.minute), o.unit === "second" && (S = C.second), d = f.formatDate(y, S);
        } else
          d = f.formatDate(y, i.config.xaxis.labels.format);
        return { dateString: p, position: o.position, value: d, unit: o.unit, year: o.year, month: o.month };
      });
    } }, { key: "removeOverlappingTS", value: function(t) {
      var n, i = this, o = new re(this.ctx), d = !1;
      t.length > 0 && t[0].value && t.every(function(y) {
        return y.value.length === t[0].value.length;
      }) && (d = !0, n = o.getTextRects(t[0].value).width);
      var f = 0, p = t.map(function(y, S) {
        if (S > 0 && i.w.config.xaxis.labels.hideOverlappingLabels) {
          var C = d ? n : o.getTextRects(t[f].value).width, E = t[f].position;
          return y.position > E + C + 10 ? (f = S, y) : null;
        }
        return y;
      });
      return p = p.filter(function(y) {
        return y !== null;
      });
    } }, { key: "_getYear", value: function(t, n, i) {
      return t + Math.floor(n / 12) + i;
    } }]), B;
  }(), qt = function() {
    function B(t, n) {
      A(this, B), this.ctx = n, this.w = n.w, this.el = t;
    }
    return F(B, [{ key: "setupElements", value: function() {
      var t = this.w.globals, n = this.w.config, i = n.chart.type;
      t.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(i) > -1, t.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(i) > -1, t.isBarHorizontal = (n.chart.type === "bar" || n.chart.type === "rangeBar" || n.chart.type === "boxPlot") && n.plotOptions.bar.horizontal, t.chartClass = ".apexcharts" + t.chartID, t.dom.baseEl = this.el, t.dom.elWrap = document.createElement("div"), re.setAttrs(t.dom.elWrap, { id: t.chartClass.substring(1), class: "apexcharts-canvas " + t.chartClass.substring(1) }), this.el.appendChild(t.dom.elWrap), t.dom.Paper = new window.SVG.Doc(t.dom.elWrap), t.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(n.chart.offsetX, ", ").concat(n.chart.offsetY, ")") }), t.dom.Paper.node.style.background = n.chart.background, this.setSVGDimensions(), t.dom.elLegendForeign = document.createElementNS(t.SVGNS, "foreignObject"), re.setAttrs(t.dom.elLegendForeign, { x: 0, y: 0, width: t.svgWidth, height: t.svgHeight }), t.dom.elLegendWrap = document.createElement("div"), t.dom.elLegendWrap.classList.add("apexcharts-legend"), t.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), t.dom.elLegendForeign.appendChild(t.dom.elLegendWrap), t.dom.Paper.node.appendChild(t.dom.elLegendForeign), t.dom.elGraphical = t.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), t.dom.elDefs = t.dom.Paper.defs(), t.dom.Paper.add(t.dom.elGraphical), t.dom.elGraphical.add(t.dom.elDefs);
    } }, { key: "plotChartType", value: function(t, n) {
      var i = this.w, o = i.config, d = i.globals, f = { series: [], i: [] }, p = { series: [], i: [] }, y = { series: [], i: [] }, S = { series: [], i: [] }, C = { series: [], i: [] }, E = { series: [], i: [] }, L = { series: [], i: [] }, O = { series: [], i: [] }, P = { series: [], seriesRangeEnd: [], i: [] };
      d.series.map(function(K, ee) {
        var oe = 0;
        t[ee].type !== void 0 ? (t[ee].type === "column" || t[ee].type === "bar" ? (d.series.length > 1 && o.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"), C.series.push(K), C.i.push(ee), oe++, i.globals.columnSeries = C.series) : t[ee].type === "area" ? (p.series.push(K), p.i.push(ee), oe++) : t[ee].type === "line" ? (f.series.push(K), f.i.push(ee), oe++) : t[ee].type === "scatter" ? (y.series.push(K), y.i.push(ee)) : t[ee].type === "bubble" ? (S.series.push(K), S.i.push(ee), oe++) : t[ee].type === "candlestick" ? (E.series.push(K), E.i.push(ee), oe++) : t[ee].type === "boxPlot" ? (L.series.push(K), L.i.push(ee), oe++) : t[ee].type === "rangeBar" ? (O.series.push(K), O.i.push(ee), oe++) : t[ee].type === "rangeArea" ? (P.series.push(d.seriesRangeStart[ee]), P.seriesRangeEnd.push(d.seriesRangeEnd[ee]), P.i.push(ee), oe++) : console.warn("You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble/candlestick/boxPlot/rangeBar/rangeArea"), oe > 1 && (d.comboCharts = !0)) : (f.series.push(K), f.i.push(ee));
      });
      var I = new xi(this.ctx, n), j = new Cn(this.ctx, n);
      this.ctx.pie = new Xs(this.ctx);
      var V = new fs(this.ctx);
      this.ctx.rangeBar = new Vs(this.ctx, n);
      var Z = new Ll(this.ctx), b = [];
      if (d.comboCharts) {
        if (p.series.length > 0 && b.push(I.draw(p.series, "area", p.i)), C.series.length > 0)
          if (i.config.chart.stacked) {
            var M = new kn(this.ctx, n);
            b.push(M.draw(C.series, C.i));
          } else
            this.ctx.bar = new gr(this.ctx, n), b.push(this.ctx.bar.draw(C.series, C.i));
        if (P.series.length > 0 && b.push(I.draw(P.series, "rangeArea", P.i, P.seriesRangeEnd)), f.series.length > 0 && b.push(I.draw(f.series, "line", f.i)), E.series.length > 0 && b.push(j.draw(E.series, "candlestick", E.i)), L.series.length > 0 && b.push(j.draw(L.series, "boxPlot", L.i)), O.series.length > 0 && b.push(this.ctx.rangeBar.draw(O.series, O.i)), y.series.length > 0) {
          var N = new xi(this.ctx, n, !0);
          b.push(N.draw(y.series, "scatter", y.i));
        }
        if (S.series.length > 0) {
          var X = new xi(this.ctx, n, !0);
          b.push(X.draw(S.series, "bubble", S.i));
        }
      } else
        switch (o.chart.type) {
          case "line":
            b = I.draw(d.series, "line");
            break;
          case "area":
            b = I.draw(d.series, "area");
            break;
          case "bar":
            o.chart.stacked ? b = new kn(this.ctx, n).draw(d.series) : (this.ctx.bar = new gr(this.ctx, n), b = this.ctx.bar.draw(d.series));
            break;
          case "candlestick":
            b = new Cn(this.ctx, n).draw(d.series, "candlestick");
            break;
          case "boxPlot":
            b = new Cn(this.ctx, n).draw(d.series, o.chart.type);
            break;
          case "rangeBar":
            b = this.ctx.rangeBar.draw(d.series);
            break;
          case "rangeArea":
            b = I.draw(d.seriesRangeStart, "rangeArea", void 0, d.seriesRangeEnd);
            break;
          case "heatmap":
            b = new cs(this.ctx, n).draw(d.series);
            break;
          case "treemap":
            b = new Ye(this.ctx, n).draw(d.series);
            break;
          case "pie":
          case "donut":
          case "polarArea":
            b = this.ctx.pie.draw(d.series);
            break;
          case "radialBar":
            b = V.draw(d.series);
            break;
          case "radar":
            b = Z.draw(d.series);
            break;
          default:
            b = I.draw(d.series);
        }
      return b;
    } }, { key: "setSVGDimensions", value: function() {
      var t = this.w.globals, n = this.w.config;
      t.svgWidth = n.chart.width, t.svgHeight = n.chart.height;
      var i = Q.getDimensions(this.el), o = n.chart.width.toString().split(/[0-9]+/g).pop();
      o === "%" ? Q.isNumber(i[0]) && (i[0].width === 0 && (i = Q.getDimensions(this.el.parentNode)), t.svgWidth = i[0] * parseInt(n.chart.width, 10) / 100) : o !== "px" && o !== "" || (t.svgWidth = parseInt(n.chart.width, 10));
      var d = n.chart.height.toString().split(/[0-9]+/g).pop();
      if (t.svgHeight !== "auto" && t.svgHeight !== "")
        if (d === "%") {
          var f = Q.getDimensions(this.el.parentNode);
          t.svgHeight = f[1] * parseInt(n.chart.height, 10) / 100;
        } else
          t.svgHeight = parseInt(n.chart.height, 10);
      else
        t.axisCharts ? t.svgHeight = t.svgWidth / 1.61 : t.svgHeight = t.svgWidth / 1.2;
      if (t.svgWidth < 0 && (t.svgWidth = 0), t.svgHeight < 0 && (t.svgHeight = 0), re.setAttrs(t.dom.Paper.node, { width: t.svgWidth, height: t.svgHeight }), d !== "%") {
        var p = n.chart.sparkline.enabled ? 0 : t.axisCharts ? n.chart.parentHeightOffset : 0;
        t.dom.Paper.node.parentNode.parentNode.style.minHeight = t.svgHeight + p + "px";
      }
      t.dom.elWrap.style.width = t.svgWidth + "px", t.dom.elWrap.style.height = t.svgHeight + "px";
    } }, { key: "shiftGraphPosition", value: function() {
      var t = this.w.globals, n = t.translateY, i = { transform: "translate(" + t.translateX + ", " + n + ")" };
      re.setAttrs(t.dom.elGraphical.node, i);
    } }, { key: "resizeNonAxisCharts", value: function() {
      var t = this.w, n = t.globals, i = 0, o = t.config.chart.sparkline.enabled ? 1 : 15;
      o += t.config.grid.padding.bottom, t.config.legend.position !== "top" && t.config.legend.position !== "bottom" || !t.config.legend.show || t.config.legend.floating || (i = new ni(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
      var d = t.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), f = 2.05 * t.globals.radialSize;
      if (d && !t.config.chart.sparkline.enabled && t.config.plotOptions.radialBar.startAngle !== 0) {
        var p = Q.getBoundingClientRect(d);
        f = p.bottom;
        var y = p.bottom - p.top;
        f = Math.max(2.05 * t.globals.radialSize, y);
      }
      var S = f + n.translateY + i + o;
      n.dom.elLegendForeign && n.dom.elLegendForeign.setAttribute("height", S), t.config.chart.height && String(t.config.chart.height).indexOf("%") > 0 || (n.dom.elWrap.style.height = S + "px", re.setAttrs(n.dom.Paper.node, { height: S }), n.dom.Paper.node.parentNode.parentNode.style.minHeight = S + "px");
    } }, { key: "coreCalculations", value: function() {
      new pn(this.ctx).init();
    } }, { key: "resetGlobals", value: function() {
      var t = this, n = function() {
        return t.w.config.series.map(function(d) {
          return [];
        });
      }, i = new ye(), o = this.w.globals;
      i.initGlobalVars(o), o.seriesXvalues = n(), o.seriesYvalues = n();
    } }, { key: "isMultipleY", value: function() {
      if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1)
        return this.w.globals.isMultipleYAxis = !0, !0;
    } }, { key: "xySettings", value: function() {
      var t = null, n = this.w;
      if (n.globals.axisCharts) {
        if (n.config.xaxis.crosshairs.position === "back" && new ei(this.ctx).drawXCrosshairs(), n.config.yaxis[0].crosshairs.position === "back" && new ei(this.ctx).drawYCrosshairs(), n.config.xaxis.type === "datetime" && n.config.xaxis.labels.formatter === void 0) {
          this.ctx.timeScale = new Dt(this.ctx);
          var i = [];
          isFinite(n.globals.minX) && isFinite(n.globals.maxX) && !n.globals.isBarHorizontal ? i = this.ctx.timeScale.calculateTimeScaleTicks(n.globals.minX, n.globals.maxX) : n.globals.isBarHorizontal && (i = this.ctx.timeScale.calculateTimeScaleTicks(n.globals.minY, n.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i);
        }
        t = new ve(this.ctx).getCalculatedRatios();
      }
      return t;
    } }, { key: "updateSourceChart", value: function(t) {
      this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: t.w.globals.minX, max: t.w.globals.maxX } } } }, !1, !1);
    } }, { key: "setupBrushHandler", value: function() {
      var t = this, n = this.w;
      if (n.config.chart.brush.enabled && typeof n.config.chart.events.selection != "function") {
        var i = Array.isArray(n.config.chart.brush.targets) || [n.config.chart.brush.target];
        i.forEach(function(o) {
          var d = ApexCharts.getChartByID(o);
          d.w.globals.brushSource = t.ctx, typeof d.w.config.chart.events.zoomed != "function" && (d.w.config.chart.events.zoomed = function() {
            t.updateSourceChart(d);
          }), typeof d.w.config.chart.events.scrolled != "function" && (d.w.config.chart.events.scrolled = function() {
            t.updateSourceChart(d);
          });
        }), n.config.chart.events.selection = function(o, d) {
          i.forEach(function(f) {
            var p = ApexCharts.getChartByID(f), y = Q.clone(n.config.yaxis);
            if (n.config.chart.brush.autoScaleYaxis && p.w.globals.series.length === 1) {
              var S = new Ze(p);
              y = S.autoScaleY(p, y, d);
            }
            var C = p.w.config.yaxis.reduce(function(E, L, O) {
              return [].concat(ue(E), [v(v({}, p.w.config.yaxis[O]), {}, { min: y[0].min, max: y[0].max })]);
            }, []);
            p.ctx.updateHelpers._updateOptions({ xaxis: { min: d.xaxis.min, max: d.xaxis.max }, yaxis: C }, !1, !1, !1, !1);
          });
        };
      }
    } }]), B;
  }(), cn = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "_updateOptions", value: function(t) {
      var n = this, i = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], o = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], d = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], f = arguments.length > 4 && arguments[4] !== void 0 && arguments[4];
      return new Promise(function(p) {
        var y = [n.ctx];
        d && (y = n.ctx.getSyncedCharts()), n.ctx.w.globals.isExecCalled && (y = [n.ctx], n.ctx.w.globals.isExecCalled = !1), y.forEach(function(S, C) {
          var E = S.w;
          if (E.globals.shouldAnimate = o, i || (E.globals.resized = !0, E.globals.dataChanged = !0, o && S.series.getPreviousPaths()), t && w(t) === "object" && (S.config = new pt(t), t = ve.extendArrayProps(S.config, t, E), S.w.globals.chartID !== n.ctx.w.globals.chartID && delete t.series, E.config = Q.extend(E.config, t), f && (E.globals.lastXAxis = t.xaxis ? Q.clone(t.xaxis) : [], E.globals.lastYAxis = t.yaxis ? Q.clone(t.yaxis) : [], E.globals.initialConfig = Q.extend({}, E.config), E.globals.initialSeries = Q.clone(E.config.series), t.series))) {
            for (var L = 0; L < E.globals.collapsedSeriesIndices.length; L++) {
              var O = E.config.series[E.globals.collapsedSeriesIndices[L]];
              E.globals.collapsedSeries[L].data = E.globals.axisCharts ? O.data.slice() : O;
            }
            for (var P = 0; P < E.globals.ancillaryCollapsedSeriesIndices.length; P++) {
              var I = E.config.series[E.globals.ancillaryCollapsedSeriesIndices[P]];
              E.globals.ancillaryCollapsedSeries[P].data = E.globals.axisCharts ? I.data.slice() : I;
            }
            S.series.emptyCollapsedSeries(E.config.series);
          }
          return S.update(t).then(function() {
            C === y.length - 1 && p(S);
          });
        });
      });
    } }, { key: "_updateSeries", value: function(t, n) {
      var i = this, o = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
      return new Promise(function(d) {
        var f, p = i.w;
        return p.globals.shouldAnimate = n, p.globals.dataChanged = !0, n && i.ctx.series.getPreviousPaths(), p.globals.axisCharts ? ((f = t.map(function(y, S) {
          return i._extendSeries(y, S);
        })).length === 0 && (f = [{ data: [] }]), p.config.series = f) : p.config.series = t.slice(), o && (p.globals.initialConfig.series = Q.clone(p.config.series), p.globals.initialSeries = Q.clone(p.config.series)), i.ctx.update().then(function() {
          d(i.ctx);
        });
      });
    } }, { key: "_extendSeries", value: function(t, n) {
      var i = this.w, o = i.config.series[n];
      return v(v({}, i.config.series[n]), {}, { name: t.name ? t.name : o && o.name, color: t.color ? t.color : o && o.color, type: t.type ? t.type : o && o.type, group: t.group ? t.group : o && o.group, data: t.data ? t.data : o && o.data });
    } }, { key: "toggleDataPointSelection", value: function(t, n) {
      var i = this.w, o = null, d = ".apexcharts-series[data\\:realIndex='".concat(t, "']");
      return i.globals.axisCharts ? o = i.globals.dom.Paper.select("".concat(d, " path[j='").concat(n, "'], ").concat(d, " circle[j='").concat(n, "'], ").concat(d, " rect[j='").concat(n, "']")).members[0] : n === void 0 && (o = i.globals.dom.Paper.select("".concat(d, " path[j='").concat(t, "']")).members[0], i.config.chart.type !== "pie" && i.config.chart.type !== "polarArea" && i.config.chart.type !== "donut" || this.ctx.pie.pieClicked(t)), o ? (new re(this.ctx).pathMouseDown(o, null), o.node ? o.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
    } }, { key: "forceXAxisUpdate", value: function(t) {
      var n = this.w;
      if (["min", "max"].forEach(function(o) {
        t.xaxis[o] !== void 0 && (n.config.xaxis[o] = t.xaxis[o], n.globals.lastXAxis[o] = t.xaxis[o]);
      }), t.xaxis.categories && t.xaxis.categories.length && (n.config.xaxis.categories = t.xaxis.categories), n.config.xaxis.convertedCatToNumeric) {
        var i = new We(t);
        t = i.convertCatToNumericXaxis(t, this.ctx);
      }
      return t;
    } }, { key: "forceYAxisUpdate", value: function(t) {
      return t.chart && t.chart.stacked && t.chart.stackType === "100%" && (Array.isArray(t.yaxis) ? t.yaxis.forEach(function(n, i) {
        t.yaxis[i].min = 0, t.yaxis[i].max = 100;
      }) : (t.yaxis.min = 0, t.yaxis.max = 100)), t;
    } }, { key: "revertDefaultAxisMinMax", value: function(t) {
      var n = this, i = this.w, o = i.globals.lastXAxis, d = i.globals.lastYAxis;
      t && t.xaxis && (o = t.xaxis), t && t.yaxis && (d = t.yaxis), i.config.xaxis.min = o.min, i.config.xaxis.max = o.max;
      var f = function(p) {
        d[p] !== void 0 && (i.config.yaxis[p].min = d[p].min, i.config.yaxis[p].max = d[p].max);
      };
      i.config.yaxis.map(function(p, y) {
        i.globals.zoomed || d[y] !== void 0 ? f(y) : n.ctx.opts.yaxis[y] !== void 0 && (p.min = n.ctx.opts.yaxis[y].min, p.max = n.ctx.opts.yaxis[y].max);
      });
    } }]), B;
  }();
  ii = typeof window < "u" ? window : void 0, le = function(B, t) {
    var n = (this !== void 0 ? this : B).SVG = function(b) {
      if (n.supported)
        return b = new n.Doc(b), n.parser.draw || n.prepare(), b;
    };
    if (n.ns = "http://www.w3.org/2000/svg", n.xmlns = "http://www.w3.org/2000/xmlns/", n.xlink = "http://www.w3.org/1999/xlink", n.svgjs = "http://svgjs.dev", n.supported = !0, !n.supported)
      return !1;
    n.did = 1e3, n.eid = function(b) {
      return "Svgjs" + C(b) + n.did++;
    }, n.create = function(b) {
      var M = t.createElementNS(this.ns, b);
      return M.setAttribute("id", this.eid(b)), M;
    }, n.extend = function() {
      var b, M;
      M = (b = [].slice.call(arguments)).pop();
      for (var N = b.length - 1; N >= 0; N--)
        if (b[N])
          for (var X in M)
            b[N].prototype[X] = M[X];
      n.Set && n.Set.inherit && n.Set.inherit();
    }, n.invent = function(b) {
      var M = typeof b.create == "function" ? b.create : function() {
        this.constructor.call(this, n.create(b.create));
      };
      return b.inherit && (M.prototype = new b.inherit()), b.extend && n.extend(M, b.extend), b.construct && n.extend(b.parent || n.Container, b.construct), M;
    }, n.adopt = function(b) {
      return b ? b.instance ? b.instance : ((M = b.nodeName == "svg" ? b.parentNode instanceof B.SVGElement ? new n.Nested() : new n.Doc() : b.nodeName == "linearGradient" ? new n.Gradient("linear") : b.nodeName == "radialGradient" ? new n.Gradient("radial") : n[C(b.nodeName)] ? new n[C(b.nodeName)]() : new n.Element(b)).type = b.nodeName, M.node = b, b.instance = M, M instanceof n.Doc && M.namespace().defs(), M.setData(JSON.parse(b.getAttribute("svgjs:data")) || {}), M) : null;
      var M;
    }, n.prepare = function() {
      var b = t.getElementsByTagName("body")[0], M = (b ? new n.Doc(b) : n.adopt(t.documentElement).nested()).size(2, 0);
      n.parser = { body: b || t.documentElement, draw: M.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node, poly: M.polyline().node, path: M.path().node, native: n.create("svg") };
    }, n.parser = { native: n.create("svg") }, t.addEventListener("DOMContentLoaded", function() {
      n.parser.draw || n.prepare();
    }, !1), n.regex = { numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, rgb: /rgb\((\d+),(\d+),(\d+)\)/, reference: /#([a-z0-9\-_]+)/i, transforms: /\)\s*,?\s*/, whitespace: /\s/g, isHex: /^#[a-f0-9]{3,6}$/i, isRgb: /^rgb\(/, isCss: /[^:]+:[^;]+;?/, isBlank: /^(\s+)?$/, isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, isPercent: /^-?[\d\.]+%$/, isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, delimiter: /[\s,]+/, hyphen: /([^e])\-/gi, pathLetters: /[MLHVCSQTAZ]/gi, isPathLetter: /[MLHVCSQTAZ]/i, numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi, dots: /\./g }, n.utils = { map: function(b, M) {
      for (var N = b.length, X = [], K = 0; K < N; K++)
        X.push(M(b[K]));
      return X;
    }, filter: function(b, M) {
      for (var N = b.length, X = [], K = 0; K < N; K++)
        M(b[K]) && X.push(b[K]);
      return X;
    }, filterSVGElements: function(b) {
      return this.filter(b, function(M) {
        return M instanceof B.SVGElement;
      });
    } }, n.defaults = { attrs: { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "font-size": 16, "font-family": "Helvetica, Arial, sans-serif", "text-anchor": "start" } }, n.Color = function(b) {
      var M, N;
      this.r = 0, this.g = 0, this.b = 0, b && (typeof b == "string" ? n.regex.isRgb.test(b) ? (M = n.regex.rgb.exec(b.replace(n.regex.whitespace, "")), this.r = parseInt(M[1]), this.g = parseInt(M[2]), this.b = parseInt(M[3])) : n.regex.isHex.test(b) && (M = n.regex.hex.exec((N = b).length == 4 ? ["#", N.substring(1, 2), N.substring(1, 2), N.substring(2, 3), N.substring(2, 3), N.substring(3, 4), N.substring(3, 4)].join("") : N), this.r = parseInt(M[1], 16), this.g = parseInt(M[2], 16), this.b = parseInt(M[3], 16)) : w(b) === "object" && (this.r = b.r, this.g = b.g, this.b = b.b));
    }, n.extend(n.Color, { toString: function() {
      return this.toHex();
    }, toHex: function() {
      return "#" + E(this.r) + E(this.g) + E(this.b);
    }, toRgb: function() {
      return "rgb(" + [this.r, this.g, this.b].join() + ")";
    }, brightness: function() {
      return this.r / 255 * 0.3 + this.g / 255 * 0.59 + this.b / 255 * 0.11;
    }, morph: function(b) {
      return this.destination = new n.Color(b), this;
    }, at: function(b) {
      return this.destination ? (b = b < 0 ? 0 : b > 1 ? 1 : b, new n.Color({ r: ~~(this.r + (this.destination.r - this.r) * b), g: ~~(this.g + (this.destination.g - this.g) * b), b: ~~(this.b + (this.destination.b - this.b) * b) })) : this;
    } }), n.Color.test = function(b) {
      return b += "", n.regex.isHex.test(b) || n.regex.isRgb.test(b);
    }, n.Color.isRgb = function(b) {
      return b && typeof b.r == "number" && typeof b.g == "number" && typeof b.b == "number";
    }, n.Color.isColor = function(b) {
      return n.Color.isRgb(b) || n.Color.test(b);
    }, n.Array = function(b, M) {
      (b = (b || []).valueOf()).length == 0 && M && (b = M.valueOf()), this.value = this.parse(b);
    }, n.extend(n.Array, { toString: function() {
      return this.value.join(" ");
    }, valueOf: function() {
      return this.value;
    }, parse: function(b) {
      return b = b.valueOf(), Array.isArray(b) ? b : this.split(b);
    } }), n.PointArray = function(b, M) {
      n.Array.call(this, b, M || [[0, 0]]);
    }, n.PointArray.prototype = new n.Array(), n.PointArray.prototype.constructor = n.PointArray;
    for (var i = { M: function(b, M, N) {
      return M.x = N.x = b[0], M.y = N.y = b[1], ["M", M.x, M.y];
    }, L: function(b, M) {
      return M.x = b[0], M.y = b[1], ["L", b[0], b[1]];
    }, H: function(b, M) {
      return M.x = b[0], ["H", b[0]];
    }, V: function(b, M) {
      return M.y = b[0], ["V", b[0]];
    }, C: function(b, M) {
      return M.x = b[4], M.y = b[5], ["C", b[0], b[1], b[2], b[3], b[4], b[5]];
    }, Q: function(b, M) {
      return M.x = b[2], M.y = b[3], ["Q", b[0], b[1], b[2], b[3]];
    }, S: function(b, M) {
      return M.x = b[2], M.y = b[3], ["S", b[0], b[1], b[2], b[3]];
    }, Z: function(b, M, N) {
      return M.x = N.x, M.y = N.y, ["Z"];
    } }, o = "mlhvqtcsaz".split(""), d = 0, f = o.length; d < f; ++d)
      i[o[d]] = function(b) {
        return function(M, N, X) {
          if (b == "H")
            M[0] = M[0] + N.x;
          else if (b == "V")
            M[0] = M[0] + N.y;
          else if (b == "A")
            M[5] = M[5] + N.x, M[6] = M[6] + N.y;
          else
            for (var K = 0, ee = M.length; K < ee; ++K)
              M[K] = M[K] + (K % 2 ? N.y : N.x);
          if (i && typeof i[b] == "function")
            return i[b](M, N, X);
        };
      }(o[d].toUpperCase());
    n.PathArray = function(b, M) {
      n.Array.call(this, b, M || [["M", 0, 0]]);
    }, n.PathArray.prototype = new n.Array(), n.PathArray.prototype.constructor = n.PathArray, n.extend(n.PathArray, { toString: function() {
      return function(b) {
        for (var M = 0, N = b.length, X = ""; M < N; M++)
          X += b[M][0], b[M][1] != null && (X += b[M][1], b[M][2] != null && (X += " ", X += b[M][2], b[M][3] != null && (X += " ", X += b[M][3], X += " ", X += b[M][4], b[M][5] != null && (X += " ", X += b[M][5], X += " ", X += b[M][6], b[M][7] != null && (X += " ", X += b[M][7])))));
        return X + " ";
      }(this.value);
    }, move: function(b, M) {
      var N = this.bbox();
      return N.x, N.y, this;
    }, at: function(b) {
      if (!this.destination)
        return this;
      for (var M = this.value, N = this.destination.value, X = [], K = new n.PathArray(), ee = 0, oe = M.length; ee < oe; ee++) {
        X[ee] = [M[ee][0]];
        for (var de = 1, ke = M[ee].length; de < ke; de++)
          X[ee][de] = M[ee][de] + (N[ee][de] - M[ee][de]) * b;
        X[ee][0] === "A" && (X[ee][4] = +(X[ee][4] != 0), X[ee][5] = +(X[ee][5] != 0));
      }
      return K.value = X, K;
    }, parse: function(b) {
      if (b instanceof n.PathArray)
        return b.valueOf();
      var M, N = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };
      b = typeof b == "string" ? b.replace(n.regex.numbersWithDots, y).replace(n.regex.pathLetters, " $& ").replace(n.regex.hyphen, "$1 -").trim().split(n.regex.delimiter) : b.reduce(function(ke, _e) {
        return [].concat.call(ke, _e);
      }, []);
      var X = [], K = new n.Point(), ee = new n.Point(), oe = 0, de = b.length;
      do
        n.regex.isPathLetter.test(b[oe]) ? (M = b[oe], ++oe) : M == "M" ? M = "L" : M == "m" && (M = "l"), X.push(i[M].call(null, b.slice(oe, oe += N[M.toUpperCase()]).map(parseFloat), K, ee));
      while (de > oe);
      return X;
    }, bbox: function() {
      return n.parser.draw || n.prepare(), n.parser.path.setAttribute("d", this.toString()), n.parser.path.getBBox();
    } }), n.Number = n.invent({ create: function(b, M) {
      this.value = 0, this.unit = M || "", typeof b == "number" ? this.value = isNaN(b) ? 0 : isFinite(b) ? b : b < 0 ? -34e37 : 34e37 : typeof b == "string" ? (M = b.match(n.regex.numberAndUnit)) && (this.value = parseFloat(M[1]), M[5] == "%" ? this.value /= 100 : M[5] == "s" && (this.value *= 1e3), this.unit = M[5]) : b instanceof n.Number && (this.value = b.valueOf(), this.unit = b.unit);
    }, extend: { toString: function() {
      return (this.unit == "%" ? ~~(1e8 * this.value) / 1e6 : this.unit == "s" ? this.value / 1e3 : this.value) + this.unit;
    }, toJSON: function() {
      return this.toString();
    }, valueOf: function() {
      return this.value;
    }, plus: function(b) {
      return b = new n.Number(b), new n.Number(this + b, this.unit || b.unit);
    }, minus: function(b) {
      return b = new n.Number(b), new n.Number(this - b, this.unit || b.unit);
    }, times: function(b) {
      return b = new n.Number(b), new n.Number(this * b, this.unit || b.unit);
    }, divide: function(b) {
      return b = new n.Number(b), new n.Number(this / b, this.unit || b.unit);
    }, to: function(b) {
      var M = new n.Number(this);
      return typeof b == "string" && (M.unit = b), M;
    }, morph: function(b) {
      return this.destination = new n.Number(b), b.relative && (this.destination.value += this.value), this;
    }, at: function(b) {
      return this.destination ? new n.Number(this.destination).minus(this).times(b).plus(this) : this;
    } } }), n.Element = n.invent({ create: function(b) {
      this._stroke = n.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = b) && (this.type = b.nodeName, this.node.instance = this, this._stroke = b.getAttribute("stroke") || this._stroke);
    }, extend: { x: function(b) {
      return this.attr("x", b);
    }, y: function(b) {
      return this.attr("y", b);
    }, cx: function(b) {
      return b == null ? this.x() + this.width() / 2 : this.x(b - this.width() / 2);
    }, cy: function(b) {
      return b == null ? this.y() + this.height() / 2 : this.y(b - this.height() / 2);
    }, move: function(b, M) {
      return this.x(b).y(M);
    }, center: function(b, M) {
      return this.cx(b).cy(M);
    }, width: function(b) {
      return this.attr("width", b);
    }, height: function(b) {
      return this.attr("height", b);
    }, size: function(b, M) {
      var N = L(this, b, M);
      return this.width(new n.Number(N.width)).height(new n.Number(N.height));
    }, clone: function(b) {
      this.writeDataToDom();
      var M = I(this.node.cloneNode(!0));
      return b ? b.add(M) : this.after(M), M;
    }, remove: function() {
      return this.parent() && this.parent().removeElement(this), this;
    }, replace: function(b) {
      return this.after(b).remove(), b;
    }, addTo: function(b) {
      return b.put(this);
    }, putIn: function(b) {
      return b.add(this);
    }, id: function(b) {
      return this.attr("id", b);
    }, show: function() {
      return this.style("display", "");
    }, hide: function() {
      return this.style("display", "none");
    }, visible: function() {
      return this.style("display") != "none";
    }, toString: function() {
      return this.attr("id");
    }, classes: function() {
      var b = this.attr("class");
      return b == null ? [] : b.trim().split(n.regex.delimiter);
    }, hasClass: function(b) {
      return this.classes().indexOf(b) != -1;
    }, addClass: function(b) {
      if (!this.hasClass(b)) {
        var M = this.classes();
        M.push(b), this.attr("class", M.join(" "));
      }
      return this;
    }, removeClass: function(b) {
      return this.hasClass(b) && this.attr("class", this.classes().filter(function(M) {
        return M != b;
      }).join(" ")), this;
    }, toggleClass: function(b) {
      return this.hasClass(b) ? this.removeClass(b) : this.addClass(b);
    }, reference: function(b) {
      return n.get(this.attr(b));
    }, parent: function(b) {
      var M = this;
      if (!M.node.parentNode)
        return null;
      if (M = n.adopt(M.node.parentNode), !b)
        return M;
      for (; M && M.node instanceof B.SVGElement; ) {
        if (typeof b == "string" ? M.matches(b) : M instanceof b)
          return M;
        if (!M.node.parentNode || M.node.parentNode.nodeName == "#document")
          return null;
        M = n.adopt(M.node.parentNode);
      }
    }, doc: function() {
      return this instanceof n.Doc ? this : this.parent(n.Doc);
    }, parents: function(b) {
      var M = [], N = this;
      do {
        if (!(N = N.parent(b)) || !N.node)
          break;
        M.push(N);
      } while (N.parent);
      return M;
    }, matches: function(b) {
      return function(M, N) {
        return (M.matches || M.matchesSelector || M.msMatchesSelector || M.mozMatchesSelector || M.webkitMatchesSelector || M.oMatchesSelector).call(M, N);
      }(this.node, b);
    }, native: function() {
      return this.node;
    }, svg: function(b) {
      var M = t.createElement("svg");
      if (!(b && this instanceof n.Parent))
        return M.appendChild(b = t.createElement("svg")), this.writeDataToDom(), b.appendChild(this.node.cloneNode(!0)), M.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
      M.innerHTML = "<svg>" + b.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
      for (var N = 0, X = M.firstChild.childNodes.length; N < X; N++)
        this.node.appendChild(M.firstChild.firstChild);
      return this;
    }, writeDataToDom: function() {
      return (this.each || this.lines) && (this.each ? this : this.lines()).each(function() {
        this.writeDataToDom();
      }), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this;
    }, setData: function(b) {
      return this.dom = b, this;
    }, is: function(b) {
      return function(M, N) {
        return M instanceof N;
      }(this, b);
    } } }), n.easing = { "-": function(b) {
      return b;
    }, "<>": function(b) {
      return -Math.cos(b * Math.PI) / 2 + 0.5;
    }, ">": function(b) {
      return Math.sin(b * Math.PI / 2);
    }, "<": function(b) {
      return 1 - Math.cos(b * Math.PI / 2);
    } }, n.morph = function(b) {
      return function(M, N) {
        return new n.MorphObj(M, N).at(b);
      };
    }, n.Situation = n.invent({ create: function(b) {
      this.init = !1, this.reversed = !1, this.reversing = !1, this.duration = new n.Number(b.duration).valueOf(), this.delay = new n.Number(b.delay).valueOf(), this.start = +/* @__PURE__ */ new Date() + this.delay, this.finish = this.start + this.duration, this.ease = b.ease, this.loop = 0, this.loops = !1, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {};
    } }), n.FX = n.invent({ create: function(b) {
      this._target = b, this.situations = [], this.active = !1, this.situation = null, this.paused = !1, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1;
    }, extend: { animate: function(b, M, N) {
      w(b) === "object" && (M = b.ease, N = b.delay, b = b.duration);
      var X = new n.Situation({ duration: b || 1e3, delay: N || 0, ease: n.easing[M || "-"] || M });
      return this.queue(X), this;
    }, target: function(b) {
      return b && b instanceof n.Element ? (this._target = b, this) : this._target;
    }, timeToAbsPos: function(b) {
      return (b - this.situation.start) / (this.situation.duration / this._speed);
    }, absPosToTime: function(b) {
      return this.situation.duration / this._speed * b + this.situation.start;
    }, startAnimFrame: function() {
      this.stopAnimFrame(), this.animationFrame = B.requestAnimationFrame((function() {
        this.step();
      }).bind(this));
    }, stopAnimFrame: function() {
      B.cancelAnimationFrame(this.animationFrame);
    }, start: function() {
      return !this.active && this.situation && (this.active = !0, this.startCurrent()), this;
    }, startCurrent: function() {
      return this.situation.start = +/* @__PURE__ */ new Date() + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step();
    }, queue: function(b) {
      return (typeof b == "function" || b instanceof n.Situation) && this.situations.push(b), this.situation || (this.situation = this.situations.shift()), this;
    }, dequeue: function() {
      return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof n.Situation ? this.start() : this.situation.call(this)), this;
    }, initAnimations: function() {
      var b, M = this.situation;
      if (M.init)
        return this;
      for (var N in M.animations) {
        b = this.target()[N](), Array.isArray(b) || (b = [b]), Array.isArray(M.animations[N]) || (M.animations[N] = [M.animations[N]]);
        for (var X = b.length; X--; )
          M.animations[N][X] instanceof n.Number && (b[X] = new n.Number(b[X])), M.animations[N][X] = b[X].morph(M.animations[N][X]);
      }
      for (var N in M.attrs)
        M.attrs[N] = new n.MorphObj(this.target().attr(N), M.attrs[N]);
      for (var N in M.styles)
        M.styles[N] = new n.MorphObj(this.target().style(N), M.styles[N]);
      return M.initialTransformation = this.target().matrixify(), M.init = !0, this;
    }, clearQueue: function() {
      return this.situations = [], this;
    }, clearCurrent: function() {
      return this.situation = null, this;
    }, stop: function(b, M) {
      var N = this.active;
      return this.active = !1, M && this.clearQueue(), b && this.situation && (!N && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent();
    }, after: function(b) {
      var M = this.last();
      return this.target().on("finished.fx", function N(X) {
        X.detail.situation == M && (b.call(this, M), this.off("finished.fx", N));
      }), this._callStart();
    }, during: function(b) {
      var M = this.last(), N = function(X) {
        X.detail.situation == M && b.call(this, X.detail.pos, n.morph(X.detail.pos), X.detail.eased, M);
      };
      return this.target().off("during.fx", N).on("during.fx", N), this.after(function() {
        this.off("during.fx", N);
      }), this._callStart();
    }, afterAll: function(b) {
      var M = function N(X) {
        b.call(this), this.off("allfinished.fx", N);
      };
      return this.target().off("allfinished.fx", M).on("allfinished.fx", M), this._callStart();
    }, last: function() {
      return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
    }, add: function(b, M, N) {
      return this.last()[N || "animations"][b] = M, this._callStart();
    }, step: function(b) {
      var M, N, X;
      b || (this.absPos = this.timeToAbsPos(+/* @__PURE__ */ new Date())), this.situation.loops !== !1 ? (M = Math.max(this.absPos, 0), N = Math.floor(M), this.situation.loops === !0 || N < this.situation.loops ? (this.pos = M - N, X = this.situation.loop, this.situation.loop = N) : (this.absPos = this.situation.loops, this.pos = 1, X = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != !!((this.situation.loop - X) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
      var K = this.situation.ease(this.pos);
      for (var ee in this.situation.once)
        ee > this.lastPos && ee <= K && (this.situation.once[ee].call(this.target(), this.pos, K), delete this.situation.once[ee]);
      return this.active && this.target().fire("during", { pos: this.pos, eased: K, fx: this, situation: this.situation }), this.situation ? (this.eachAt(), this.pos == 1 && !this.situation.reversed || this.situation.reversed && this.pos == 0 ? (this.stopAnimFrame(), this.target().fire("finished", { fx: this, situation: this.situation }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = !1)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = K, this) : this;
    }, eachAt: function() {
      var b, M = this, N = this.target(), X = this.situation;
      for (var K in X.animations)
        b = [].concat(X.animations[K]).map(function(de) {
          return typeof de != "string" && de.at ? de.at(X.ease(M.pos), M.pos) : de;
        }), N[K].apply(N, b);
      for (var K in X.attrs)
        b = [K].concat(X.attrs[K]).map(function(ke) {
          return typeof ke != "string" && ke.at ? ke.at(X.ease(M.pos), M.pos) : ke;
        }), N.attr.apply(N, b);
      for (var K in X.styles)
        b = [K].concat(X.styles[K]).map(function(ke) {
          return typeof ke != "string" && ke.at ? ke.at(X.ease(M.pos), M.pos) : ke;
        }), N.style.apply(N, b);
      if (X.transforms.length) {
        b = X.initialTransformation, K = 0;
        for (var ee = X.transforms.length; K < ee; K++) {
          var oe = X.transforms[K];
          oe instanceof n.Matrix ? b = oe.relative ? b.multiply(new n.Matrix().morph(oe).at(X.ease(this.pos))) : b.morph(oe).at(X.ease(this.pos)) : (oe.relative || oe.undo(b.extract()), b = b.multiply(oe.at(X.ease(this.pos))));
        }
        N.matrix(b);
      }
      return this;
    }, once: function(b, M, N) {
      var X = this.last();
      return N || (b = X.ease(b)), X.once[b] = M, this;
    }, _callStart: function() {
      return setTimeout((function() {
        this.start();
      }).bind(this), 0), this;
    } }, parent: n.Element, construct: { animate: function(b, M, N) {
      return (this.fx || (this.fx = new n.FX(this))).animate(b, M, N);
    }, delay: function(b) {
      return (this.fx || (this.fx = new n.FX(this))).delay(b);
    }, stop: function(b, M) {
      return this.fx && this.fx.stop(b, M), this;
    }, finish: function() {
      return this.fx && this.fx.finish(), this;
    } } }), n.MorphObj = n.invent({ create: function(b, M) {
      return n.Color.isColor(M) ? new n.Color(b).morph(M) : n.regex.delimiter.test(b) ? n.regex.pathLetters.test(b) ? new n.PathArray(b).morph(M) : new n.Array(b).morph(M) : n.regex.numberAndUnit.test(M) ? new n.Number(b).morph(M) : (this.value = b, void (this.destination = M));
    }, extend: { at: function(b, M) {
      return M < 1 ? this.value : this.destination;
    }, valueOf: function() {
      return this.value;
    } } }), n.extend(n.FX, { attr: function(b, M, N) {
      if (w(b) === "object")
        for (var X in b)
          this.attr(X, b[X]);
      else
        this.add(b, M, "attrs");
      return this;
    }, plot: function(b, M, N, X) {
      return arguments.length == 4 ? this.plot([b, M, N, X]) : this.add("plot", new (this.target()).morphArray(b));
    } }), n.Box = n.invent({ create: function(b, M, N, X) {
      if (!(w(b) !== "object" || b instanceof n.Element))
        return n.Box.call(this, b.left != null ? b.left : b.x, b.top != null ? b.top : b.y, b.width, b.height);
      var K;
      arguments.length == 4 && (this.x = b, this.y = M, this.width = N, this.height = X), (K = this).x == null && (K.x = 0, K.y = 0, K.width = 0, K.height = 0), K.w = K.width, K.h = K.height, K.x2 = K.x + K.width, K.y2 = K.y + K.height, K.cx = K.x + K.width / 2, K.cy = K.y + K.height / 2;
    } }), n.BBox = n.invent({ create: function(b) {
      if (n.Box.apply(this, [].slice.call(arguments)), b instanceof n.Element) {
        var M;
        try {
          if (!t.documentElement.contains) {
            for (var N = b.node; N.parentNode; )
              N = N.parentNode;
            if (N != t)
              throw new Error("Element not in the dom");
          }
          M = b.node.getBBox();
        } catch {
          if (b instanceof n.Shape) {
            n.parser.draw || n.prepare();
            var X = b.clone(n.parser.draw.instance).show();
            X && X.node && typeof X.node.getBBox == "function" && (M = X.node.getBBox()), X && typeof X.remove == "function" && X.remove();
          } else
            M = { x: b.node.clientLeft, y: b.node.clientTop, width: b.node.clientWidth, height: b.node.clientHeight };
        }
        n.Box.call(this, M);
      }
    }, inherit: n.Box, parent: n.Element, construct: { bbox: function() {
      return new n.BBox(this);
    } } }), n.BBox.prototype.constructor = n.BBox, n.Matrix = n.invent({ create: function(b) {
      var M = P([1, 0, 0, 1, 0, 0]);
      b = b === null ? M : b instanceof n.Element ? b.matrixify() : typeof b == "string" ? P(b.split(n.regex.delimiter).map(parseFloat)) : arguments.length == 6 ? P([].slice.call(arguments)) : Array.isArray(b) ? P(b) : b && w(b) === "object" ? b : M;
      for (var N = V.length - 1; N >= 0; --N)
        this[V[N]] = b[V[N]] != null ? b[V[N]] : M[V[N]];
    }, extend: { extract: function() {
      var b = O(this, 0, 1);
      O(this, 1, 0);
      var M = 180 / Math.PI * Math.atan2(b.y, b.x) - 90;
      return { x: this.e, y: this.f, transformedX: (this.e * Math.cos(M * Math.PI / 180) + this.f * Math.sin(M * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b), transformedY: (this.f * Math.cos(M * Math.PI / 180) + this.e * Math.sin(-M * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d), rotation: M, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f, matrix: new n.Matrix(this) };
    }, clone: function() {
      return new n.Matrix(this);
    }, morph: function(b) {
      return this.destination = new n.Matrix(b), this;
    }, multiply: function(b) {
      return new n.Matrix(this.native().multiply(function(M) {
        return M instanceof n.Matrix || (M = new n.Matrix(M)), M;
      }(b).native()));
    }, inverse: function() {
      return new n.Matrix(this.native().inverse());
    }, translate: function(b, M) {
      return new n.Matrix(this.native().translate(b || 0, M || 0));
    }, native: function() {
      for (var b = n.parser.native.createSVGMatrix(), M = V.length - 1; M >= 0; M--)
        b[V[M]] = this[V[M]];
      return b;
    }, toString: function() {
      return "matrix(" + j(this.a) + "," + j(this.b) + "," + j(this.c) + "," + j(this.d) + "," + j(this.e) + "," + j(this.f) + ")";
    } }, parent: n.Element, construct: { ctm: function() {
      return new n.Matrix(this.node.getCTM());
    }, screenCTM: function() {
      if (this instanceof n.Nested) {
        var b = this.rect(1, 1), M = b.node.getScreenCTM();
        return b.remove(), new n.Matrix(M);
      }
      return new n.Matrix(this.node.getScreenCTM());
    } } }), n.Point = n.invent({ create: function(b, M) {
      var N;
      N = Array.isArray(b) ? { x: b[0], y: b[1] } : w(b) === "object" ? { x: b.x, y: b.y } : b != null ? { x: b, y: M ?? b } : { x: 0, y: 0 }, this.x = N.x, this.y = N.y;
    }, extend: { clone: function() {
      return new n.Point(this);
    }, morph: function(b, M) {
      return this.destination = new n.Point(b, M), this;
    } } }), n.extend(n.Element, { point: function(b, M) {
      return new n.Point(b, M).transform(this.screenCTM().inverse());
    } }), n.extend(n.Element, { attr: function(b, M, N) {
      if (b == null) {
        for (b = {}, N = (M = this.node.attributes).length - 1; N >= 0; N--)
          b[M[N].nodeName] = n.regex.isNumber.test(M[N].nodeValue) ? parseFloat(M[N].nodeValue) : M[N].nodeValue;
        return b;
      }
      if (w(b) === "object")
        for (var X in b)
          this.attr(X, b[X]);
      else if (M === null)
        this.node.removeAttribute(b);
      else {
        if (M == null)
          return (M = this.node.getAttribute(b)) == null ? n.defaults.attrs[b] : n.regex.isNumber.test(M) ? parseFloat(M) : M;
        b == "stroke-width" ? this.attr("stroke", parseFloat(M) > 0 ? this._stroke : null) : b == "stroke" && (this._stroke = M), b != "fill" && b != "stroke" || (n.regex.isImage.test(M) && (M = this.doc().defs().image(M, 0, 0)), M instanceof n.Image && (M = this.doc().defs().pattern(0, 0, function() {
          this.add(M);
        }))), typeof M == "number" ? M = new n.Number(M) : n.Color.isColor(M) ? M = new n.Color(M) : Array.isArray(M) && (M = new n.Array(M)), b == "leading" ? this.leading && this.leading(M) : typeof N == "string" ? this.node.setAttributeNS(N, b, M.toString()) : this.node.setAttribute(b, M.toString()), !this.rebuild || b != "font-size" && b != "x" || this.rebuild(b, M);
      }
      return this;
    } }), n.extend(n.Element, { transform: function(b, M) {
      var N;
      return w(b) !== "object" ? (N = new n.Matrix(this).extract(), typeof b == "string" ? N[b] : N) : (N = new n.Matrix(this), M = !!M || !!b.relative, b.a != null && (N = M ? N.multiply(new n.Matrix(b)) : new n.Matrix(b)), this.attr("transform", N));
    } }), n.extend(n.Element, { untransform: function() {
      return this.attr("transform", null);
    }, matrixify: function() {
      return (this.attr("transform") || "").split(n.regex.transforms).slice(0, -1).map(function(b) {
        var M = b.trim().split("(");
        return [M[0], M[1].split(n.regex.delimiter).map(function(N) {
          return parseFloat(N);
        })];
      }).reduce(function(b, M) {
        return M[0] == "matrix" ? b.multiply(P(M[1])) : b[M[0]].apply(b, M[1]);
      }, new n.Matrix());
    }, toParent: function(b) {
      if (this == b)
        return this;
      var M = this.screenCTM(), N = b.screenCTM().inverse();
      return this.addTo(b).untransform().transform(N.multiply(M)), this;
    }, toDoc: function() {
      return this.toParent(this.doc());
    } }), n.Transformation = n.invent({ create: function(b, M) {
      if (arguments.length > 1 && typeof M != "boolean")
        return this.constructor.call(this, [].slice.call(arguments));
      if (Array.isArray(b))
        for (var N = 0, X = this.arguments.length; N < X; ++N)
          this[this.arguments[N]] = b[N];
      else if (b && w(b) === "object")
        for (N = 0, X = this.arguments.length; N < X; ++N)
          this[this.arguments[N]] = b[this.arguments[N]];
      this.inversed = !1, M === !0 && (this.inversed = !0);
    } }), n.Translate = n.invent({ parent: n.Matrix, inherit: n.Transformation, create: function(b, M) {
      this.constructor.apply(this, [].slice.call(arguments));
    }, extend: { arguments: ["transformedX", "transformedY"], method: "translate" } }), n.extend(n.Element, { style: function(b, M) {
      if (arguments.length == 0)
        return this.node.style.cssText || "";
      if (arguments.length < 2)
        if (w(b) === "object")
          for (var N in b)
            this.style(N, b[N]);
        else {
          if (!n.regex.isCss.test(b))
            return this.node.style[S(b)];
          for (b = b.split(/\s*;\s*/).filter(function(X) {
            return !!X;
          }).map(function(X) {
            return X.split(/\s*:\s*/);
          }); M = b.pop(); )
            this.style(M[0], M[1]);
        }
      else
        this.node.style[S(b)] = M === null || n.regex.isBlank.test(M) ? "" : M;
      return this;
    } }), n.Parent = n.invent({ create: function(b) {
      this.constructor.call(this, b);
    }, inherit: n.Element, extend: { children: function() {
      return n.utils.map(n.utils.filterSVGElements(this.node.childNodes), function(b) {
        return n.adopt(b);
      });
    }, add: function(b, M) {
      return M == null ? this.node.appendChild(b.node) : b.node != this.node.childNodes[M] && this.node.insertBefore(b.node, this.node.childNodes[M]), this;
    }, put: function(b, M) {
      return this.add(b, M), b;
    }, has: function(b) {
      return this.index(b) >= 0;
    }, index: function(b) {
      return [].slice.call(this.node.childNodes).indexOf(b.node);
    }, get: function(b) {
      return n.adopt(this.node.childNodes[b]);
    }, first: function() {
      return this.get(0);
    }, last: function() {
      return this.get(this.node.childNodes.length - 1);
    }, each: function(b, M) {
      for (var N = this.children(), X = 0, K = N.length; X < K; X++)
        N[X] instanceof n.Element && b.apply(N[X], [X, N]), M && N[X] instanceof n.Container && N[X].each(b, M);
      return this;
    }, removeElement: function(b) {
      return this.node.removeChild(b.node), this;
    }, clear: function() {
      for (; this.node.hasChildNodes(); )
        this.node.removeChild(this.node.lastChild);
      return delete this._defs, this;
    }, defs: function() {
      return this.doc().defs();
    } } }), n.extend(n.Parent, { ungroup: function(b, M) {
      return M === 0 || this instanceof n.Defs || this.node == n.parser.draw || (b = b || (this instanceof n.Doc ? this : this.parent(n.Parent)), M = M || 1 / 0, this.each(function() {
        return this instanceof n.Defs ? this : this instanceof n.Parent ? this.ungroup(b, M - 1) : this.toParent(b);
      }), this.node.firstChild || this.remove()), this;
    }, flatten: function(b, M) {
      return this.ungroup(b, M);
    } }), n.Container = n.invent({ create: function(b) {
      this.constructor.call(this, b);
    }, inherit: n.Parent }), n.ViewBox = n.invent({ parent: n.Container, construct: {} }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function(b) {
      n.Element.prototype[b] = function(M) {
        return n.on(this.node, b, M), this;
      };
    }), n.listeners = [], n.handlerMap = [], n.listenerId = 0, n.on = function(b, M, N, X, K) {
      var ee = N.bind(X || b.instance || b), oe = (n.handlerMap.indexOf(b) + 1 || n.handlerMap.push(b)) - 1, de = M.split(".")[0], ke = M.split(".")[1] || "*";
      n.listeners[oe] = n.listeners[oe] || {}, n.listeners[oe][de] = n.listeners[oe][de] || {}, n.listeners[oe][de][ke] = n.listeners[oe][de][ke] || {}, N._svgjsListenerId || (N._svgjsListenerId = ++n.listenerId), n.listeners[oe][de][ke][N._svgjsListenerId] = ee, b.addEventListener(de, ee, K || { passive: !0 });
    }, n.off = function(b, M, N) {
      var X = n.handlerMap.indexOf(b), K = M && M.split(".")[0], ee = M && M.split(".")[1], oe = "";
      if (X != -1)
        if (N) {
          if (typeof N == "function" && (N = N._svgjsListenerId), !N)
            return;
          n.listeners[X][K] && n.listeners[X][K][ee || "*"] && (b.removeEventListener(K, n.listeners[X][K][ee || "*"][N], !1), delete n.listeners[X][K][ee || "*"][N]);
        } else if (ee && K) {
          if (n.listeners[X][K] && n.listeners[X][K][ee]) {
            for (var de in n.listeners[X][K][ee])
              n.off(b, [K, ee].join("."), de);
            delete n.listeners[X][K][ee];
          }
        } else if (ee)
          for (var ke in n.listeners[X])
            for (var oe in n.listeners[X][ke])
              ee === oe && n.off(b, [ke, ee].join("."));
        else if (K) {
          if (n.listeners[X][K]) {
            for (var oe in n.listeners[X][K])
              n.off(b, [K, oe].join("."));
            delete n.listeners[X][K];
          }
        } else {
          for (var ke in n.listeners[X])
            n.off(b, ke);
          delete n.listeners[X], delete n.handlerMap[X];
        }
    }, n.extend(n.Element, { on: function(b, M, N, X) {
      return n.on(this.node, b, M, N, X), this;
    }, off: function(b, M) {
      return n.off(this.node, b, M), this;
    }, fire: function(b, M) {
      return b instanceof B.Event ? this.node.dispatchEvent(b) : this.node.dispatchEvent(b = new n.CustomEvent(b, { detail: M, cancelable: !0 })), this._event = b, this;
    }, event: function() {
      return this._event;
    } }), n.Defs = n.invent({ create: "defs", inherit: n.Container }), n.G = n.invent({ create: "g", inherit: n.Container, extend: { x: function(b) {
      return b == null ? this.transform("x") : this.transform({ x: b - this.x() }, !0);
    } }, construct: { group: function() {
      return this.put(new n.G());
    } } }), n.Doc = n.invent({ create: function(b) {
      b && ((b = typeof b == "string" ? t.getElementById(b) : b).nodeName == "svg" ? this.constructor.call(this, b) : (this.constructor.call(this, n.create("svg")), b.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs());
    }, inherit: n.Container, extend: { namespace: function() {
      return this.attr({ xmlns: n.ns, version: "1.1" }).attr("xmlns:xlink", n.xlink, n.xmlns).attr("xmlns:svgjs", n.svgjs, n.xmlns);
    }, defs: function() {
      var b;
      return this._defs || ((b = this.node.getElementsByTagName("defs")[0]) ? this._defs = n.adopt(b) : this._defs = new n.Defs(), this.node.appendChild(this._defs.node)), this._defs;
    }, parent: function() {
      return this.node.parentNode && this.node.parentNode.nodeName != "#document" ? this.node.parentNode : null;
    }, remove: function() {
      return this.parent() && this.parent().removeChild(this.node), this;
    }, clear: function() {
      for (; this.node.hasChildNodes(); )
        this.node.removeChild(this.node.lastChild);
      return delete this._defs, n.parser.draw && !n.parser.draw.parentNode && this.node.appendChild(n.parser.draw), this;
    }, clone: function(b) {
      this.writeDataToDom();
      var M = this.node, N = I(M.cloneNode(!0));
      return b ? (b.node || b).appendChild(N.node) : M.parentNode.insertBefore(N.node, M.nextSibling), N;
    } } }), n.extend(n.Element, {}), n.Gradient = n.invent({ create: function(b) {
      this.constructor.call(this, n.create(b + "Gradient")), this.type = b;
    }, inherit: n.Container, extend: { at: function(b, M, N) {
      return this.put(new n.Stop()).update(b, M, N);
    }, update: function(b) {
      return this.clear(), typeof b == "function" && b.call(this, this), this;
    }, fill: function() {
      return "url(#" + this.id() + ")";
    }, toString: function() {
      return this.fill();
    }, attr: function(b, M, N) {
      return b == "transform" && (b = "gradientTransform"), n.Container.prototype.attr.call(this, b, M, N);
    } }, construct: { gradient: function(b, M) {
      return this.defs().gradient(b, M);
    } } }), n.extend(n.Gradient, n.FX, { from: function(b, M) {
      return (this._target || this).type == "radial" ? this.attr({ fx: new n.Number(b), fy: new n.Number(M) }) : this.attr({ x1: new n.Number(b), y1: new n.Number(M) });
    }, to: function(b, M) {
      return (this._target || this).type == "radial" ? this.attr({ cx: new n.Number(b), cy: new n.Number(M) }) : this.attr({ x2: new n.Number(b), y2: new n.Number(M) });
    } }), n.extend(n.Defs, { gradient: function(b, M) {
      return this.put(new n.Gradient(b)).update(M);
    } }), n.Stop = n.invent({ create: "stop", inherit: n.Element, extend: { update: function(b) {
      return (typeof b == "number" || b instanceof n.Number) && (b = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), b.opacity != null && this.attr("stop-opacity", b.opacity), b.color != null && this.attr("stop-color", b.color), b.offset != null && this.attr("offset", new n.Number(b.offset)), this;
    } } }), n.Pattern = n.invent({ create: "pattern", inherit: n.Container, extend: { fill: function() {
      return "url(#" + this.id() + ")";
    }, update: function(b) {
      return this.clear(), typeof b == "function" && b.call(this, this), this;
    }, toString: function() {
      return this.fill();
    }, attr: function(b, M, N) {
      return b == "transform" && (b = "patternTransform"), n.Container.prototype.attr.call(this, b, M, N);
    } }, construct: { pattern: function(b, M, N) {
      return this.defs().pattern(b, M, N);
    } } }), n.extend(n.Defs, { pattern: function(b, M, N) {
      return this.put(new n.Pattern()).update(N).attr({ x: 0, y: 0, width: b, height: M, patternUnits: "userSpaceOnUse" });
    } }), n.Shape = n.invent({ create: function(b) {
      this.constructor.call(this, b);
    }, inherit: n.Element }), n.Symbol = n.invent({ create: "symbol", inherit: n.Container, construct: { symbol: function() {
      return this.put(new n.Symbol());
    } } }), n.Use = n.invent({ create: "use", inherit: n.Shape, extend: { element: function(b, M) {
      return this.attr("href", (M || "") + "#" + b, n.xlink);
    } }, construct: { use: function(b, M) {
      return this.put(new n.Use()).element(b, M);
    } } }), n.Rect = n.invent({ create: "rect", inherit: n.Shape, construct: { rect: function(b, M) {
      return this.put(new n.Rect()).size(b, M);
    } } }), n.Circle = n.invent({ create: "circle", inherit: n.Shape, construct: { circle: function(b) {
      return this.put(new n.Circle()).rx(new n.Number(b).divide(2)).move(0, 0);
    } } }), n.extend(n.Circle, n.FX, { rx: function(b) {
      return this.attr("r", b);
    }, ry: function(b) {
      return this.rx(b);
    } }), n.Ellipse = n.invent({ create: "ellipse", inherit: n.Shape, construct: { ellipse: function(b, M) {
      return this.put(new n.Ellipse()).size(b, M).move(0, 0);
    } } }), n.extend(n.Ellipse, n.Rect, n.FX, { rx: function(b) {
      return this.attr("rx", b);
    }, ry: function(b) {
      return this.attr("ry", b);
    } }), n.extend(n.Circle, n.Ellipse, { x: function(b) {
      return b == null ? this.cx() - this.rx() : this.cx(b + this.rx());
    }, y: function(b) {
      return b == null ? this.cy() - this.ry() : this.cy(b + this.ry());
    }, cx: function(b) {
      return b == null ? this.attr("cx") : this.attr("cx", b);
    }, cy: function(b) {
      return b == null ? this.attr("cy") : this.attr("cy", b);
    }, width: function(b) {
      return b == null ? 2 * this.rx() : this.rx(new n.Number(b).divide(2));
    }, height: function(b) {
      return b == null ? 2 * this.ry() : this.ry(new n.Number(b).divide(2));
    }, size: function(b, M) {
      var N = L(this, b, M);
      return this.rx(new n.Number(N.width).divide(2)).ry(new n.Number(N.height).divide(2));
    } }), n.Line = n.invent({ create: "line", inherit: n.Shape, extend: { array: function() {
      return new n.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
    }, plot: function(b, M, N, X) {
      return b == null ? this.array() : (b = M !== void 0 ? { x1: b, y1: M, x2: N, y2: X } : new n.PointArray(b).toLine(), this.attr(b));
    }, move: function(b, M) {
      return this.attr(this.array().move(b, M).toLine());
    }, size: function(b, M) {
      var N = L(this, b, M);
      return this.attr(this.array().size(N.width, N.height).toLine());
    } }, construct: { line: function(b, M, N, X) {
      return n.Line.prototype.plot.apply(this.put(new n.Line()), b != null ? [b, M, N, X] : [0, 0, 0, 0]);
    } } }), n.Polyline = n.invent({ create: "polyline", inherit: n.Shape, construct: { polyline: function(b) {
      return this.put(new n.Polyline()).plot(b || new n.PointArray());
    } } }), n.Polygon = n.invent({ create: "polygon", inherit: n.Shape, construct: { polygon: function(b) {
      return this.put(new n.Polygon()).plot(b || new n.PointArray());
    } } }), n.extend(n.Polyline, n.Polygon, { array: function() {
      return this._array || (this._array = new n.PointArray(this.attr("points")));
    }, plot: function(b) {
      return b == null ? this.array() : this.clear().attr("points", typeof b == "string" ? b : this._array = new n.PointArray(b));
    }, clear: function() {
      return delete this._array, this;
    }, move: function(b, M) {
      return this.attr("points", this.array().move(b, M));
    }, size: function(b, M) {
      var N = L(this, b, M);
      return this.attr("points", this.array().size(N.width, N.height));
    } }), n.extend(n.Line, n.Polyline, n.Polygon, { morphArray: n.PointArray, x: function(b) {
      return b == null ? this.bbox().x : this.move(b, this.bbox().y);
    }, y: function(b) {
      return b == null ? this.bbox().y : this.move(this.bbox().x, b);
    }, width: function(b) {
      var M = this.bbox();
      return b == null ? M.width : this.size(b, M.height);
    }, height: function(b) {
      var M = this.bbox();
      return b == null ? M.height : this.size(M.width, b);
    } }), n.Path = n.invent({ create: "path", inherit: n.Shape, extend: { morphArray: n.PathArray, array: function() {
      return this._array || (this._array = new n.PathArray(this.attr("d")));
    }, plot: function(b) {
      return b == null ? this.array() : this.clear().attr("d", typeof b == "string" ? b : this._array = new n.PathArray(b));
    }, clear: function() {
      return delete this._array, this;
    } }, construct: { path: function(b) {
      return this.put(new n.Path()).plot(b || new n.PathArray());
    } } }), n.Image = n.invent({ create: "image", inherit: n.Shape, extend: { load: function(b) {
      if (!b)
        return this;
      var M = this, N = new B.Image();
      return n.on(N, "load", function() {
        n.off(N);
        var X = M.parent(n.Pattern);
        X !== null && (M.width() == 0 && M.height() == 0 && M.size(N.width, N.height), X && X.width() == 0 && X.height() == 0 && X.size(M.width(), M.height()), typeof M._loaded == "function" && M._loaded.call(M, { width: N.width, height: N.height, ratio: N.width / N.height, url: b }));
      }), n.on(N, "error", function(X) {
        n.off(N), typeof M._error == "function" && M._error.call(M, X);
      }), this.attr("href", N.src = this.src = b, n.xlink);
    }, loaded: function(b) {
      return this._loaded = b, this;
    }, error: function(b) {
      return this._error = b, this;
    } }, construct: { image: function(b, M, N) {
      return this.put(new n.Image()).load(b).size(M || 0, N || M || 0);
    } } }), n.Text = n.invent({ create: function() {
      this.constructor.call(this, n.create("text")), this.dom.leading = new n.Number(1.3), this._rebuild = !0, this._build = !1, this.attr("font-family", n.defaults.attrs["font-family"]);
    }, inherit: n.Shape, extend: { x: function(b) {
      return b == null ? this.attr("x") : this.attr("x", b);
    }, text: function(b) {
      if (b === void 0) {
        b = "";
        for (var M = this.node.childNodes, N = 0, X = M.length; N < X; ++N)
          N != 0 && M[N].nodeType != 3 && n.adopt(M[N]).dom.newLined == 1 && (b += `
`), b += M[N].textContent;
        return b;
      }
      if (this.clear().build(!0), typeof b == "function")
        b.call(this, this);
      else {
        N = 0;
        for (var K = (b = b.split(`
`)).length; N < K; N++)
          this.tspan(b[N]).newLine();
      }
      return this.build(!1).rebuild();
    }, size: function(b) {
      return this.attr("font-size", b).rebuild();
    }, leading: function(b) {
      return b == null ? this.dom.leading : (this.dom.leading = new n.Number(b), this.rebuild());
    }, lines: function() {
      var b = (this.textPath && this.textPath() || this).node, M = n.utils.map(n.utils.filterSVGElements(b.childNodes), function(N) {
        return n.adopt(N);
      });
      return new n.Set(M);
    }, rebuild: function(b) {
      if (typeof b == "boolean" && (this._rebuild = b), this._rebuild) {
        var M = this, N = 0, X = this.dom.leading * new n.Number(this.attr("font-size"));
        this.lines().each(function() {
          this.dom.newLined && (M.textPath() || this.attr("x", M.attr("x")), this.text() == `
` ? N += X : (this.attr("dy", X + N), N = 0));
        }), this.fire("rebuild");
      }
      return this;
    }, build: function(b) {
      return this._build = !!b, this;
    }, setData: function(b) {
      return this.dom = b, this.dom.leading = new n.Number(b.leading || 1.3), this;
    } }, construct: { text: function(b) {
      return this.put(new n.Text()).text(b);
    }, plain: function(b) {
      return this.put(new n.Text()).plain(b);
    } } }), n.Tspan = n.invent({ create: "tspan", inherit: n.Shape, extend: { text: function(b) {
      return b == null ? this.node.textContent + (this.dom.newLined ? `
` : "") : (typeof b == "function" ? b.call(this, this) : this.plain(b), this);
    }, dx: function(b) {
      return this.attr("dx", b);
    }, dy: function(b) {
      return this.attr("dy", b);
    }, newLine: function() {
      var b = this.parent(n.Text);
      return this.dom.newLined = !0, this.dy(b.dom.leading * b.attr("font-size")).attr("x", b.x());
    } } }), n.extend(n.Text, n.Tspan, { plain: function(b) {
      return this._build === !1 && this.clear(), this.node.appendChild(t.createTextNode(b)), this;
    }, tspan: function(b) {
      var M = (this.textPath && this.textPath() || this).node, N = new n.Tspan();
      return this._build === !1 && this.clear(), M.appendChild(N.node), N.text(b);
    }, clear: function() {
      for (var b = (this.textPath && this.textPath() || this).node; b.hasChildNodes(); )
        b.removeChild(b.lastChild);
      return this;
    }, length: function() {
      return this.node.getComputedTextLength();
    } }), n.TextPath = n.invent({ create: "textPath", inherit: n.Parent, parent: n.Text, construct: { morphArray: n.PathArray, array: function() {
      var b = this.track();
      return b ? b.array() : null;
    }, plot: function(b) {
      var M = this.track(), N = null;
      return M && (N = M.plot(b)), b == null ? N : this;
    }, track: function() {
      var b = this.textPath();
      if (b)
        return b.reference("href");
    }, textPath: function() {
      if (this.node.firstChild && this.node.firstChild.nodeName == "textPath")
        return n.adopt(this.node.firstChild);
    } } }), n.Nested = n.invent({ create: function() {
      this.constructor.call(this, n.create("svg")), this.style("overflow", "visible");
    }, inherit: n.Container, construct: { nested: function() {
      return this.put(new n.Nested());
    } } });
    var p = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(b, M) {
      return M == "color" ? b : b + "-" + M;
    } };
    function y(b, M, N, X) {
      return N + X.replace(n.regex.dots, " .");
    }
    function S(b) {
      return b.toLowerCase().replace(/-(.)/g, function(M, N) {
        return N.toUpperCase();
      });
    }
    function C(b) {
      return b.charAt(0).toUpperCase() + b.slice(1);
    }
    function E(b) {
      var M = b.toString(16);
      return M.length == 1 ? "0" + M : M;
    }
    function L(b, M, N) {
      if (M == null || N == null) {
        var X = b.bbox();
        M == null ? M = X.width / X.height * N : N == null && (N = X.height / X.width * M);
      }
      return { width: M, height: N };
    }
    function O(b, M, N) {
      return { x: M * b.a + N * b.c + 0, y: M * b.b + N * b.d + 0 };
    }
    function P(b) {
      return { a: b[0], b: b[1], c: b[2], d: b[3], e: b[4], f: b[5] };
    }
    function I(b) {
      for (var M = b.childNodes.length - 1; M >= 0; M--)
        b.childNodes[M] instanceof B.SVGElement && I(b.childNodes[M]);
      return n.adopt(b).id(n.eid(b.nodeName));
    }
    function j(b) {
      return Math.abs(b) > 1e-37 ? b : 0;
    }
    ["fill", "stroke"].forEach(function(b) {
      var M = {};
      M[b] = function(N) {
        if (N === void 0)
          return this;
        if (typeof N == "string" || n.Color.isRgb(N) || N && typeof N.fill == "function")
          this.attr(b, N);
        else
          for (var X = p[b].length - 1; X >= 0; X--)
            N[p[b][X]] != null && this.attr(p.prefix(b, p[b][X]), N[p[b][X]]);
        return this;
      }, n.extend(n.Element, n.FX, M);
    }), n.extend(n.Element, n.FX, { translate: function(b, M) {
      return this.transform({ x: b, y: M });
    }, matrix: function(b) {
      return this.attr("transform", new n.Matrix(arguments.length == 6 ? [].slice.call(arguments) : b));
    }, opacity: function(b) {
      return this.attr("opacity", b);
    }, dx: function(b) {
      return this.x(new n.Number(b).plus(this instanceof n.FX ? 0 : this.x()), !0);
    }, dy: function(b) {
      return this.y(new n.Number(b).plus(this instanceof n.FX ? 0 : this.y()), !0);
    } }), n.extend(n.Path, { length: function() {
      return this.node.getTotalLength();
    }, pointAt: function(b) {
      return this.node.getPointAtLength(b);
    } }), n.Set = n.invent({ create: function(b) {
      Array.isArray(b) ? this.members = b : this.clear();
    }, extend: { add: function() {
      for (var b = [].slice.call(arguments), M = 0, N = b.length; M < N; M++)
        this.members.push(b[M]);
      return this;
    }, remove: function(b) {
      var M = this.index(b);
      return M > -1 && this.members.splice(M, 1), this;
    }, each: function(b) {
      for (var M = 0, N = this.members.length; M < N; M++)
        b.apply(this.members[M], [M, this.members]);
      return this;
    }, clear: function() {
      return this.members = [], this;
    }, length: function() {
      return this.members.length;
    }, has: function(b) {
      return this.index(b) >= 0;
    }, index: function(b) {
      return this.members.indexOf(b);
    }, get: function(b) {
      return this.members[b];
    }, first: function() {
      return this.get(0);
    }, last: function() {
      return this.get(this.members.length - 1);
    }, valueOf: function() {
      return this.members;
    } }, construct: { set: function(b) {
      return new n.Set(b);
    } } }), n.FX.Set = n.invent({ create: function(b) {
      this.set = b;
    } }), n.Set.inherit = function() {
      var b = [];
      for (var M in n.Shape.prototype)
        typeof n.Shape.prototype[M] == "function" && typeof n.Set.prototype[M] != "function" && b.push(M);
      for (var M in b.forEach(function(X) {
        n.Set.prototype[X] = function() {
          for (var K = 0, ee = this.members.length; K < ee; K++)
            this.members[K] && typeof this.members[K][X] == "function" && this.members[K][X].apply(this.members[K], arguments);
          return X == "animate" ? this.fx || (this.fx = new n.FX.Set(this)) : this;
        };
      }), b = [], n.FX.prototype)
        typeof n.FX.prototype[M] == "function" && typeof n.FX.Set.prototype[M] != "function" && b.push(M);
      b.forEach(function(N) {
        n.FX.Set.prototype[N] = function() {
          for (var X = 0, K = this.set.members.length; X < K; X++)
            this.set.members[X].fx[N].apply(this.set.members[X].fx, arguments);
          return this;
        };
      });
    }, n.extend(n.Element, {}), n.extend(n.Element, { remember: function(b, M) {
      if (w(arguments[0]) === "object")
        for (var N in b)
          this.remember(N, b[N]);
      else {
        if (arguments.length == 1)
          return this.memory()[b];
        this.memory()[b] = M;
      }
      return this;
    }, forget: function() {
      if (arguments.length == 0)
        this._memory = {};
      else
        for (var b = arguments.length - 1; b >= 0; b--)
          delete this.memory()[arguments[b]];
      return this;
    }, memory: function() {
      return this._memory || (this._memory = {});
    } }), n.get = function(b) {
      var M = t.getElementById(function(N) {
        var X = (N || "").toString().match(n.regex.reference);
        if (X)
          return X[1];
      }(b) || b);
      return n.adopt(M);
    }, n.select = function(b, M) {
      return new n.Set(n.utils.map((M || t).querySelectorAll(b), function(N) {
        return n.adopt(N);
      }));
    }, n.extend(n.Parent, { select: function(b) {
      return n.select(b, this.node);
    } });
    var V = "abcdef".split("");
    if (typeof B.CustomEvent != "function") {
      var Z = function(b, M) {
        M = M || { bubbles: !1, cancelable: !1, detail: void 0 };
        var N = t.createEvent("CustomEvent");
        return N.initCustomEvent(b, M.bubbles, M.cancelable, M.detail), N;
      };
      Z.prototype = B.Event.prototype, n.CustomEvent = Z;
    } else
      n.CustomEvent = B.CustomEvent;
    return n;
  }, w(u) === "object" ? s.exports = ii.document ? le(ii, ii.document) : function(B) {
    return le(B, B.document);
  } : ii.SVG = le(ii, ii.document), /*! svg.filter.js - v2.0.2 - 2016-02-24
  * https://github.com/wout/svg.filter.js
  * Copyright (c) 2016 Wout Fierens; Licensed MIT */
  (function() {
    SVG.Filter = SVG.invent({ create: "filter", inherit: SVG.Parent, extend: { source: "SourceGraphic", sourceAlpha: "SourceAlpha", background: "BackgroundImage", backgroundAlpha: "BackgroundAlpha", fill: "FillPaint", stroke: "StrokePaint", autoSetIn: !0, put: function(f, p) {
      return this.add(f, p), !f.attr("in") && this.autoSetIn && f.attr("in", this.source), f.attr("result") || f.attr("result", f), f;
    }, blend: function(f, p, y) {
      return this.put(new SVG.BlendEffect(f, p, y));
    }, colorMatrix: function(f, p) {
      return this.put(new SVG.ColorMatrixEffect(f, p));
    }, convolveMatrix: function(f) {
      return this.put(new SVG.ConvolveMatrixEffect(f));
    }, componentTransfer: function(f) {
      return this.put(new SVG.ComponentTransferEffect(f));
    }, composite: function(f, p, y) {
      return this.put(new SVG.CompositeEffect(f, p, y));
    }, flood: function(f, p) {
      return this.put(new SVG.FloodEffect(f, p));
    }, offset: function(f, p) {
      return this.put(new SVG.OffsetEffect(f, p));
    }, image: function(f) {
      return this.put(new SVG.ImageEffect(f));
    }, merge: function() {
      var f = [void 0];
      for (var p in arguments)
        f.push(arguments[p]);
      return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, f))());
    }, gaussianBlur: function(f, p) {
      return this.put(new SVG.GaussianBlurEffect(f, p));
    }, morphology: function(f, p) {
      return this.put(new SVG.MorphologyEffect(f, p));
    }, diffuseLighting: function(f, p, y) {
      return this.put(new SVG.DiffuseLightingEffect(f, p, y));
    }, displacementMap: function(f, p, y, S, C) {
      return this.put(new SVG.DisplacementMapEffect(f, p, y, S, C));
    }, specularLighting: function(f, p, y, S) {
      return this.put(new SVG.SpecularLightingEffect(f, p, y, S));
    }, tile: function() {
      return this.put(new SVG.TileEffect());
    }, turbulence: function(f, p, y, S, C) {
      return this.put(new SVG.TurbulenceEffect(f, p, y, S, C));
    }, toString: function() {
      return "url(#" + this.attr("id") + ")";
    } } }), SVG.extend(SVG.Defs, { filter: function(f) {
      var p = this.put(new SVG.Filter());
      return typeof f == "function" && f.call(p, p), p;
    } }), SVG.extend(SVG.Container, { filter: function(f) {
      return this.defs().filter(f);
    } }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, { filter: function(f) {
      return this.filterer = f instanceof SVG.Element ? f : this.doc().filter(f), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer;
    }, unfilter: function(f) {
      return this.filterer && f === !0 && this.filterer.remove(), delete this.filterer, this.attr("filter", null);
    } }), SVG.Effect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Element, extend: { in: function(f) {
      return f == null ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", f);
    }, result: function(f) {
      return f == null ? this.attr("result") : this.attr("result", f);
    }, toString: function() {
      return this.result();
    } } }), SVG.ParentEffect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Parent, extend: { in: function(f) {
      return f == null ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", f);
    }, result: function(f) {
      return f == null ? this.attr("result") : this.attr("result", f);
    }, toString: function() {
      return this.result();
    } } });
    var B = { blend: function(f, p) {
      return this.parent() && this.parent().blend(this, f, p);
    }, colorMatrix: function(f, p) {
      return this.parent() && this.parent().colorMatrix(f, p).in(this);
    }, convolveMatrix: function(f) {
      return this.parent() && this.parent().convolveMatrix(f).in(this);
    }, componentTransfer: function(f) {
      return this.parent() && this.parent().componentTransfer(f).in(this);
    }, composite: function(f, p) {
      return this.parent() && this.parent().composite(this, f, p);
    }, flood: function(f, p) {
      return this.parent() && this.parent().flood(f, p);
    }, offset: function(f, p) {
      return this.parent() && this.parent().offset(f, p).in(this);
    }, image: function(f) {
      return this.parent() && this.parent().image(f);
    }, merge: function() {
      return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments));
    }, gaussianBlur: function(f, p) {
      return this.parent() && this.parent().gaussianBlur(f, p).in(this);
    }, morphology: function(f, p) {
      return this.parent() && this.parent().morphology(f, p).in(this);
    }, diffuseLighting: function(f, p, y) {
      return this.parent() && this.parent().diffuseLighting(f, p, y).in(this);
    }, displacementMap: function(f, p, y, S) {
      return this.parent() && this.parent().displacementMap(this, f, p, y, S);
    }, specularLighting: function(f, p, y, S) {
      return this.parent() && this.parent().specularLighting(f, p, y, S).in(this);
    }, tile: function() {
      return this.parent() && this.parent().tile().in(this);
    }, turbulence: function(f, p, y, S, C) {
      return this.parent() && this.parent().turbulence(f, p, y, S, C).in(this);
    } };
    SVG.extend(SVG.Effect, B), SVG.extend(SVG.ParentEffect, B), SVG.ChildEffect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Element, extend: { in: function(f) {
      this.attr("in", f);
    } } });
    var t = { blend: function(f, p, y) {
      this.attr({ in: f, in2: p, mode: y || "normal" });
    }, colorMatrix: function(f, p) {
      f == "matrix" && (p = o(p)), this.attr({ type: f, values: p === void 0 ? null : p });
    }, convolveMatrix: function(f) {
      f = o(f), this.attr({ order: Math.sqrt(f.split(" ").length), kernelMatrix: f });
    }, composite: function(f, p, y) {
      this.attr({ in: f, in2: p, operator: y });
    }, flood: function(f, p) {
      this.attr("flood-color", f), p != null && this.attr("flood-opacity", p);
    }, offset: function(f, p) {
      this.attr({ dx: f, dy: p });
    }, image: function(f) {
      this.attr("href", f, SVG.xlink);
    }, displacementMap: function(f, p, y, S, C) {
      this.attr({ in: f, in2: p, scale: y, xChannelSelector: S, yChannelSelector: C });
    }, gaussianBlur: function(f, p) {
      f != null || p != null ? this.attr("stdDeviation", function(y) {
        if (!Array.isArray(y))
          return y;
        for (var S = 0, C = y.length, E = []; S < C; S++)
          E.push(y[S]);
        return E.join(" ");
      }(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0");
    }, morphology: function(f, p) {
      this.attr({ operator: f, radius: p });
    }, tile: function() {
    }, turbulence: function(f, p, y, S, C) {
      this.attr({ numOctaves: p, seed: y, stitchTiles: S, baseFrequency: f, type: C });
    } }, n = { merge: function() {
      var f;
      if (arguments[0] instanceof SVG.Set) {
        var p = this;
        arguments[0].each(function(S) {
          this instanceof SVG.MergeNode ? p.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && p.put(new SVG.MergeNode(this));
        });
      } else {
        f = Array.isArray(arguments[0]) ? arguments[0] : arguments;
        for (var y = 0; y < f.length; y++)
          f[y] instanceof SVG.MergeNode ? this.put(f[y]) : this.put(new SVG.MergeNode(f[y]));
      }
    }, componentTransfer: function(f) {
      if (this.rgb = new SVG.Set(), ["r", "g", "b", "a"].forEach((function(y) {
        this[y] = new SVG["Func" + y.toUpperCase()]("identity"), this.rgb.add(this[y]), this.node.appendChild(this[y].node);
      }).bind(this)), f)
        for (var p in f.rgb && (["r", "g", "b"].forEach((function(y) {
          this[y].attr(f.rgb);
        }).bind(this)), delete f.rgb), f)
          this[p].attr(f[p]);
    }, diffuseLighting: function(f, p, y) {
      this.attr({ surfaceScale: f, diffuseConstant: p, kernelUnitLength: y });
    }, specularLighting: function(f, p, y, S) {
      this.attr({ surfaceScale: f, diffuseConstant: p, specularExponent: y, kernelUnitLength: S });
    } }, i = { distantLight: function(f, p) {
      this.attr({ azimuth: f, elevation: p });
    }, pointLight: function(f, p, y) {
      this.attr({ x: f, y: p, z: y });
    }, spotLight: function(f, p, y, S, C, E) {
      this.attr({ x: f, y: p, z: y, pointsAtX: S, pointsAtY: C, pointsAtZ: E });
    }, mergeNode: function(f) {
      this.attr("in", f);
    } };
    function o(f) {
      return Array.isArray(f) && (f = new SVG.Array(f)), f.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
    }
    function d() {
      var f = function() {
      };
      for (var p in typeof arguments[arguments.length - 1] == "function" && (f = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments)
        for (var y in arguments[p])
          f(arguments[p][y], y, arguments[p]);
    }
    ["r", "g", "b", "a"].forEach(function(f) {
      i["Func" + f.toUpperCase()] = function(p) {
        switch (this.attr("type", p), p) {
          case "table":
            this.attr("tableValues", arguments[1]);
            break;
          case "linear":
            this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
            break;
          case "gamma":
            this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2]);
        }
      };
    }), d(t, function(f, p) {
      var y = p.charAt(0).toUpperCase() + p.slice(1);
      SVG[y + "Effect"] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + y)), f.apply(this, arguments), this.result(this.attr("id") + "Out");
      }, inherit: SVG.Effect, extend: {} });
    }), d(n, function(f, p) {
      var y = p.charAt(0).toUpperCase() + p.slice(1);
      SVG[y + "Effect"] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + y)), f.apply(this, arguments), this.result(this.attr("id") + "Out");
      }, inherit: SVG.ParentEffect, extend: {} });
    }), d(i, function(f, p) {
      var y = p.charAt(0).toUpperCase() + p.slice(1);
      SVG[y] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + y)), f.apply(this, arguments);
      }, inherit: SVG.ChildEffect, extend: {} });
    }), SVG.extend(SVG.MergeEffect, { in: function(f) {
      return f instanceof SVG.MergeNode ? this.add(f, 0) : this.add(new SVG.MergeNode(f), 0), this;
    } }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, { in2: function(f) {
      return f == null ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", f);
    } }), SVG.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
  }).call(void 0), function() {
    function B(d, f, p, y, S, C, E) {
      for (var L = d.slice(f, p || E), O = y.slice(S, C || E), P = 0, I = { pos: [0, 0], start: [0, 0] }, j = { pos: [0, 0], start: [0, 0] }; L[P] = t.call(I, L[P]), O[P] = t.call(j, O[P]), L[P][0] != O[P][0] || L[P][0] == "M" || L[P][0] == "A" && (L[P][4] != O[P][4] || L[P][5] != O[P][5]) ? (Array.prototype.splice.apply(L, [P, 1].concat(i.call(I, L[P]))), Array.prototype.splice.apply(O, [P, 1].concat(i.call(j, O[P])))) : (L[P] = n.call(I, L[P]), O[P] = n.call(j, O[P])), !(++P == L.length && P == O.length); )
        P == L.length && L.push(["C", I.pos[0], I.pos[1], I.pos[0], I.pos[1], I.pos[0], I.pos[1]]), P == O.length && O.push(["C", j.pos[0], j.pos[1], j.pos[0], j.pos[1], j.pos[0], j.pos[1]]);
      return { start: L, dest: O };
    }
    function t(d) {
      switch (d[0]) {
        case "z":
        case "Z":
          d[0] = "L", d[1] = this.start[0], d[2] = this.start[1];
          break;
        case "H":
          d[0] = "L", d[2] = this.pos[1];
          break;
        case "V":
          d[0] = "L", d[2] = d[1], d[1] = this.pos[0];
          break;
        case "T":
          d[0] = "Q", d[3] = d[1], d[4] = d[2], d[1] = this.reflection[1], d[2] = this.reflection[0];
          break;
        case "S":
          d[0] = "C", d[6] = d[4], d[5] = d[3], d[4] = d[2], d[3] = d[1], d[2] = this.reflection[1], d[1] = this.reflection[0];
      }
      return d;
    }
    function n(d) {
      var f = d.length;
      return this.pos = [d[f - 2], d[f - 1]], "SCQT".indexOf(d[0]) != -1 && (this.reflection = [2 * this.pos[0] - d[f - 4], 2 * this.pos[1] - d[f - 3]]), d;
    }
    function i(d) {
      var f = [d];
      switch (d[0]) {
        case "M":
          return this.pos = this.start = [d[1], d[2]], f;
        case "L":
          d[5] = d[3] = d[1], d[6] = d[4] = d[2], d[1] = this.pos[0], d[2] = this.pos[1];
          break;
        case "Q":
          d[6] = d[4], d[5] = d[3], d[4] = 1 * d[4] / 3 + 2 * d[2] / 3, d[3] = 1 * d[3] / 3 + 2 * d[1] / 3, d[2] = 1 * this.pos[1] / 3 + 2 * d[2] / 3, d[1] = 1 * this.pos[0] / 3 + 2 * d[1] / 3;
          break;
        case "A":
          f = function(p, y) {
            var S, C, E, L, O, P, I, j, V, Z, b, M, N, X, K, ee, oe, de, ke, _e, Me, Ie, rt, Qt, Kt, mt, Mn = Math.abs(y[1]), zn = Math.abs(y[2]), gt = y[3] % 360, jr = y[4], Dn = y[5], ai = y[6], si = y[7], vr = new SVG.Point(p), ln = new SVG.Point(ai, si), wn = [];
            if (Mn === 0 || zn === 0 || vr.x === ln.x && vr.y === ln.y)
              return [["C", vr.x, vr.y, ln.x, ln.y, ln.x, ln.y]];
            for (S = new SVG.Point((vr.x - ln.x) / 2, (vr.y - ln.y) / 2).transform(new SVG.Matrix().rotate(gt)), (C = S.x * S.x / (Mn * Mn) + S.y * S.y / (zn * zn)) > 1 && (Mn *= C = Math.sqrt(C), zn *= C), E = new SVG.Matrix().rotate(gt).scale(1 / Mn, 1 / zn).rotate(-gt), vr = vr.transform(E), ln = ln.transform(E), L = [ln.x - vr.x, ln.y - vr.y], P = L[0] * L[0] + L[1] * L[1], O = Math.sqrt(P), L[0] /= O, L[1] /= O, I = P < 4 ? Math.sqrt(1 - P / 4) : 0, jr === Dn && (I *= -1), j = new SVG.Point((ln.x + vr.x) / 2 + I * -L[1], (ln.y + vr.y) / 2 + I * L[0]), V = new SVG.Point(vr.x - j.x, vr.y - j.y), Z = new SVG.Point(ln.x - j.x, ln.y - j.y), b = Math.acos(V.x / Math.sqrt(V.x * V.x + V.y * V.y)), V.y < 0 && (b *= -1), M = Math.acos(Z.x / Math.sqrt(Z.x * Z.x + Z.y * Z.y)), Z.y < 0 && (M *= -1), Dn && b > M && (M += 2 * Math.PI), !Dn && b < M && (M -= 2 * Math.PI), X = Math.ceil(2 * Math.abs(b - M) / Math.PI), ee = [], oe = b, N = (M - b) / X, K = 4 * Math.tan(N / 4) / 3, Me = 0; Me <= X; Me++)
              ke = Math.cos(oe), de = Math.sin(oe), _e = new SVG.Point(j.x + ke, j.y + de), ee[Me] = [new SVG.Point(_e.x + K * de, _e.y - K * ke), _e, new SVG.Point(_e.x - K * de, _e.y + K * ke)], oe += N;
            for (ee[0][0] = ee[0][1].clone(), ee[ee.length - 1][2] = ee[ee.length - 1][1].clone(), E = new SVG.Matrix().rotate(gt).scale(Mn, zn).rotate(-gt), Me = 0, Ie = ee.length; Me < Ie; Me++)
              ee[Me][0] = ee[Me][0].transform(E), ee[Me][1] = ee[Me][1].transform(E), ee[Me][2] = ee[Me][2].transform(E);
            for (Me = 1, Ie = ee.length; Me < Ie; Me++)
              rt = (_e = ee[Me - 1][2]).x, Qt = _e.y, Kt = (_e = ee[Me][0]).x, mt = _e.y, ai = (_e = ee[Me][1]).x, si = _e.y, wn.push(["C", rt, Qt, Kt, mt, ai, si]);
            return wn;
          }(this.pos, d), d = f[0];
      }
      return d[0] = "C", this.pos = [d[5], d[6]], this.reflection = [2 * d[5] - d[3], 2 * d[6] - d[4]], f;
    }
    function o(d, f) {
      if (f === !1)
        return !1;
      for (var p = f, y = d.length; p < y; ++p)
        if (d[p][0] == "M")
          return p;
      return !1;
    }
    SVG.extend(SVG.PathArray, { morph: function(d) {
      for (var f = this.value, p = this.parse(d), y = 0, S = 0, C = !1, E = !1; y !== !1 || S !== !1; ) {
        var L;
        C = o(f, y !== !1 && y + 1), E = o(p, S !== !1 && S + 1), y === !1 && (y = (L = new SVG.PathArray(O.start).bbox()).height == 0 || L.width == 0 ? f.push(f[0]) - 1 : f.push(["M", L.x + L.width / 2, L.y + L.height / 2]) - 1), S === !1 && (S = (L = new SVG.PathArray(O.dest).bbox()).height == 0 || L.width == 0 ? p.push(p[0]) - 1 : p.push(["M", L.x + L.width / 2, L.y + L.height / 2]) - 1);
        var O = B(f, y, C, p, S, E);
        f = f.slice(0, y).concat(O.start, C === !1 ? [] : f.slice(C)), p = p.slice(0, S).concat(O.dest, E === !1 ? [] : p.slice(E)), y = C !== !1 && y + O.start.length, S = E !== !1 && S + O.dest.length;
      }
      return this.value = f, this.destination = new SVG.PathArray(), this.destination.value = p, this;
    } });
  }(), /*! svg.draggable.js - v2.2.2 - 2019-01-08
  * https://github.com/svgdotjs/svg.draggable.js
  * Copyright (c) 2019 Wout Fierens; Licensed MIT */
  (function() {
    function B(t) {
      t.remember("_draggable", this), this.el = t;
    }
    B.prototype.init = function(t, n) {
      var i = this;
      this.constraint = t, this.value = n, this.el.on("mousedown.drag", function(o) {
        i.start(o);
      }), this.el.on("touchstart.drag", function(o) {
        i.start(o);
      });
    }, B.prototype.transformPoint = function(t, n) {
      var i = (t = t || window.event).changedTouches && t.changedTouches[0] || t;
      return this.p.x = i.clientX - (n || 0), this.p.y = i.clientY, this.p.matrixTransform(this.m);
    }, B.prototype.getBBox = function() {
      var t = this.el.bbox();
      return this.el instanceof SVG.Nested && (t = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t.x = this.el.x(), t.y = this.el.y()), t;
    }, B.prototype.start = function(t) {
      if (t.type != "click" && t.type != "mousedown" && t.type != "mousemove" || (t.which || t.buttons) == 1) {
        var n = this;
        if (this.el.fire("beforedrag", { event: t, handler: this }), !this.el.event().defaultPrevented) {
          t.preventDefault(), t.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
          var i, o = this.getBBox();
          if (this.el instanceof SVG.Text)
            switch (i = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
              case "middle":
                i /= 2;
                break;
              case "start":
                i = 0;
            }
          this.startPoints = { point: this.transformPoint(t, i), box: o, transform: this.el.transform() }, SVG.on(window, "mousemove.drag", function(d) {
            n.drag(d);
          }), SVG.on(window, "touchmove.drag", function(d) {
            n.drag(d);
          }), SVG.on(window, "mouseup.drag", function(d) {
            n.end(d);
          }), SVG.on(window, "touchend.drag", function(d) {
            n.end(d);
          }), this.el.fire("dragstart", { event: t, p: this.startPoints.point, m: this.m, handler: this });
        }
      }
    }, B.prototype.drag = function(t) {
      var n = this.getBBox(), i = this.transformPoint(t), o = this.startPoints.box.x + i.x - this.startPoints.point.x, d = this.startPoints.box.y + i.y - this.startPoints.point.y, f = this.constraint, p = i.x - this.startPoints.point.x, y = i.y - this.startPoints.point.y;
      if (this.el.fire("dragmove", { event: t, p: i, m: this.m, handler: this }), this.el.event().defaultPrevented)
        return i;
      if (typeof f == "function") {
        var S = f.call(this.el, o, d, this.m);
        typeof S == "boolean" && (S = { x: S, y: S }), S.x === !0 ? this.el.x(o) : S.x !== !1 && this.el.x(S.x), S.y === !0 ? this.el.y(d) : S.y !== !1 && this.el.y(S.y);
      } else
        typeof f == "object" && (f.minX != null && o < f.minX ? p = (o = f.minX) - this.startPoints.box.x : f.maxX != null && o > f.maxX - n.width && (p = (o = f.maxX - n.width) - this.startPoints.box.x), f.minY != null && d < f.minY ? y = (d = f.minY) - this.startPoints.box.y : f.maxY != null && d > f.maxY - n.height && (y = (d = f.maxY - n.height) - this.startPoints.box.y), f.snapToGrid != null && (o -= o % f.snapToGrid, d -= d % f.snapToGrid, p -= p % f.snapToGrid, y -= y % f.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({ x: p, y }, !0) : this.el.move(o, d));
      return i;
    }, B.prototype.end = function(t) {
      var n = this.drag(t);
      this.el.fire("dragend", { event: t, p: n, m: this.m, handler: this }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag");
    }, SVG.extend(SVG.Element, { draggable: function(t, n) {
      typeof t != "function" && typeof t != "object" || (n = t, t = !0);
      var i = this.remember("_draggable") || new B(this);
      return (t = t === void 0 || t) ? i.init(n || {}, t) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this;
    } });
  }).call(void 0), function() {
    function B(t) {
      this.el = t, t.remember("_selectHandler", this), this.pointSelection = { isSelected: !1 }, this.rectSelection = { isSelected: !1 }, this.pointsList = { lt: [0, 0], rt: ["width", 0], rb: ["width", "height"], lb: [0, "height"], t: ["width", 0], r: ["width", "height"], b: ["width", "height"], l: [0, "height"] }, this.pointCoord = function(n, i, o) {
        var d = typeof n != "string" ? n : i[n];
        return o ? d / 2 : d;
      }, this.pointCoords = function(n, i) {
        var o = this.pointsList[n];
        return { x: this.pointCoord(o[0], i, n === "t" || n === "b"), y: this.pointCoord(o[1], i, n === "r" || n === "l") };
      };
    }
    B.prototype.init = function(t, n) {
      var i = this.el.bbox();
      this.options = {};
      var o = this.el.selectize.defaults.points;
      for (var d in this.el.selectize.defaults)
        this.options[d] = this.el.selectize.defaults[d], n[d] !== void 0 && (this.options[d] = n[d]);
      var f = ["points", "pointsExclude"];
      for (var d in f) {
        var p = this.options[f[d]];
        typeof p == "string" ? p = p.length > 0 ? p.split(/\s*,\s*/i) : [] : typeof p == "boolean" && f[d] === "points" && (p = p ? o : []), this.options[f[d]] = p;
      }
      this.options.points = [o, this.options.points].reduce(function(y, S) {
        return y.filter(function(C) {
          return S.indexOf(C) > -1;
        });
      }), this.options.points = [this.options.points, this.options.pointsExclude].reduce(function(y, S) {
        return y.filter(function(C) {
          return S.indexOf(C) < 0;
        });
      }), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i.x, i.y)), this.options.deepSelect && ["line", "polyline", "polygon"].indexOf(this.el.type) !== -1 ? this.selectPoints(t) : this.selectRect(t), this.observe(), this.cleanup();
    }, B.prototype.selectPoints = function(t) {
      return this.pointSelection.isSelected = t, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this;
    }, B.prototype.getPointArray = function() {
      var t = this.el.bbox();
      return this.el.array().valueOf().map(function(n) {
        return [n[0] - t.x, n[1] - t.y];
      });
    }, B.prototype.drawPoints = function() {
      for (var t = this, n = this.getPointArray(), i = 0, o = n.length; i < o; ++i) {
        var d = function(p) {
          return function(y) {
            (y = y || window.event).preventDefault ? y.preventDefault() : y.returnValue = !1, y.stopPropagation();
            var S = y.pageX || y.touches[0].pageX, C = y.pageY || y.touches[0].pageY;
            t.el.fire("point", { x: S, y: C, i: p, event: y });
          };
        }(i), f = this.drawPoint(n[i][0], n[i][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", d).on("mousedown", d);
        this.pointSelection.set.add(f);
      }
    }, B.prototype.drawPoint = function(t, n) {
      var i = this.options.pointType;
      switch (i) {
        case "circle":
          return this.drawCircle(t, n);
        case "rect":
          return this.drawRect(t, n);
        default:
          if (typeof i == "function")
            return i.call(this, t, n);
          throw new Error("Unknown " + i + " point type!");
      }
    }, B.prototype.drawCircle = function(t, n) {
      return this.nested.circle(this.options.pointSize).center(t, n);
    }, B.prototype.drawRect = function(t, n) {
      return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t, n);
    }, B.prototype.updatePointSelection = function() {
      var t = this.getPointArray();
      this.pointSelection.set.each(function(n) {
        this.cx() === t[n][0] && this.cy() === t[n][1] || this.center(t[n][0], t[n][1]);
      });
    }, B.prototype.updateRectSelection = function() {
      var t = this, n = this.el.bbox();
      if (this.rectSelection.set.get(0).attr({ width: n.width, height: n.height }), this.options.points.length && this.options.points.map(function(o, d) {
        var f = t.pointCoords(o, n);
        t.rectSelection.set.get(d + 1).center(f.x, f.y);
      }), this.options.rotationPoint) {
        var i = this.rectSelection.set.length();
        this.rectSelection.set.get(i - 1).center(n.width / 2, 20);
      }
    }, B.prototype.selectRect = function(t) {
      var n = this, i = this.el.bbox();
      function o(p) {
        return function(y) {
          (y = y || window.event).preventDefault ? y.preventDefault() : y.returnValue = !1, y.stopPropagation();
          var S = y.pageX || y.touches[0].pageX, C = y.pageY || y.touches[0].pageY;
          n.el.fire(p, { x: S, y: C, event: y });
        };
      }
      if (this.rectSelection.isSelected = t, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i.width, i.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2 && (this.options.points.map(function(p, y) {
        var S = n.pointCoords(p, i), C = n.drawPoint(S.x, S.y).attr("class", n.options.classPoints + "_" + p).on("mousedown", o(p)).on("touchstart", o(p));
        n.rectSelection.set.add(C);
      }), this.rectSelection.set.each(function() {
        this.addClass(n.options.classPoints);
      })), this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
        var d = function(p) {
          (p = p || window.event).preventDefault ? p.preventDefault() : p.returnValue = !1, p.stopPropagation();
          var y = p.pageX || p.touches[0].pageX, S = p.pageY || p.touches[0].pageY;
          n.el.fire("rot", { x: y, y: S, event: p });
        }, f = this.drawPoint(i.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", d).on("mousedown", d);
        this.rectSelection.set.add(f);
      }
    }, B.prototype.handler = function() {
      var t = this.el.bbox();
      this.nested.matrix(new SVG.Matrix(this.el).translate(t.x, t.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection();
    }, B.prototype.observe = function() {
      var t = this;
      if (MutationObserver)
        if (this.rectSelection.isSelected || this.pointSelection.isSelected)
          this.observerInst = this.observerInst || new MutationObserver(function() {
            t.handler();
          }), this.observerInst.observe(this.el.node, { attributes: !0 });
        else
          try {
            this.observerInst.disconnect(), delete this.observerInst;
          } catch {
          }
      else
        this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function() {
          t.handler();
        });
    }, B.prototype.cleanup = function() {
      !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function() {
        this.remove();
      }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function() {
        this.remove();
      }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested);
    }, SVG.extend(SVG.Element, { selectize: function(t, n) {
      return typeof t == "object" && (n = t, t = !0), (this.remember("_selectHandler") || new B(this)).init(t === void 0 || t, n || {}), this;
    } }), SVG.Element.prototype.selectize.defaults = { points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"], pointsExclude: [], classRect: "svg_select_boundingRect", classPoints: "svg_select_points", pointSize: 7, rotationPoint: !0, deepSelect: !1, pointType: "circle" };
  }(), function() {
    (function() {
      function B(t) {
        t.remember("_resizeHandler", this), this.el = t, this.parameters = {}, this.lastUpdateCall = null, this.p = t.doc().node.createSVGPoint();
      }
      B.prototype.transformPoint = function(t, n, i) {
        return this.p.x = t - (this.offset.x - window.pageXOffset), this.p.y = n - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i || this.m);
      }, B.prototype._extractPosition = function(t) {
        return { x: t.clientX != null ? t.clientX : t.touches[0].clientX, y: t.clientY != null ? t.clientY : t.touches[0].clientY };
      }, B.prototype.init = function(t) {
        var n = this;
        if (this.stop(), t !== "stop") {
          for (var i in this.options = {}, this.el.resize.defaults)
            this.options[i] = this.el.resize.defaults[i], t[i] !== void 0 && (this.options[i] = t[i]);
          this.el.on("lt.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("rt.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("rb.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("lb.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("t.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("r.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("b.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("l.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("rot.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("point.resize", function(o) {
            n.resize(o || window.event);
          }), this.update();
        }
      }, B.prototype.stop = function() {
        return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this;
      }, B.prototype.resize = function(t) {
        var n = this;
        this.m = this.el.node.getScreenCTM().inverse(), this.offset = { x: window.pageXOffset, y: window.pageYOffset };
        var i = this._extractPosition(t.detail.event);
        if (this.parameters = { type: this.el.type, p: this.transformPoint(i.x, i.y), x: t.detail.x, y: t.detail.y, box: this.el.bbox(), rotation: this.el.transform().rotation }, this.el.type === "text" && (this.parameters.fontSize = this.el.attr()["font-size"]), t.detail.i !== void 0) {
          var o = this.el.array().valueOf();
          this.parameters.i = t.detail.i, this.parameters.pointCoords = [o[t.detail.i][0], o[t.detail.i][1]];
        }
        switch (t.type) {
          case "lt":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f);
              if (this.parameters.box.width - p[0] > 0 && this.parameters.box.height - p[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x + p[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - p[0]);
                p = this.checkAspectRatio(p), this.el.move(this.parameters.box.x + p[0], this.parameters.box.y + p[1]).size(this.parameters.box.width - p[0], this.parameters.box.height - p[1]);
              }
            };
            break;
          case "rt":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 2);
              if (this.parameters.box.width + p[0] > 0 && this.parameters.box.height - p[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x - p[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + p[0]);
                p = this.checkAspectRatio(p, !0), this.el.move(this.parameters.box.x, this.parameters.box.y + p[1]).size(this.parameters.box.width + p[0], this.parameters.box.height - p[1]);
              }
            };
            break;
          case "rb":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 0);
              if (this.parameters.box.width + p[0] > 0 && this.parameters.box.height + p[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x - p[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + p[0]);
                p = this.checkAspectRatio(p), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + p[0], this.parameters.box.height + p[1]);
              }
            };
            break;
          case "lb":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 1);
              if (this.parameters.box.width - p[0] > 0 && this.parameters.box.height + p[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x + p[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - p[0]);
                p = this.checkAspectRatio(p, !0), this.el.move(this.parameters.box.x + p[0], this.parameters.box.y).size(this.parameters.box.width - p[0], this.parameters.box.height + p[1]);
              }
            };
            break;
          case "t":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 2);
              if (this.parameters.box.height - p[1] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y + p[1]).height(this.parameters.box.height - p[1]);
              }
            };
            break;
          case "r":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 0);
              if (this.parameters.box.width + p[0] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + p[0]);
              }
            };
            break;
          case "b":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 0);
              if (this.parameters.box.height + p[1] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + p[1]);
              }
            };
            break;
          case "l":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 1);
              if (this.parameters.box.width - p[0] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x + p[0], this.parameters.box.y).width(this.parameters.box.width - p[0]);
              }
            };
            break;
          case "rot":
            this.calc = function(d, f) {
              var p = d + this.parameters.p.x, y = f + this.parameters.p.y, S = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2), C = Math.atan2(y - this.parameters.box.y - this.parameters.box.height / 2, p - this.parameters.box.x - this.parameters.box.width / 2), E = this.parameters.rotation + 180 * (C - S) / Math.PI + this.options.snapToAngle / 2;
              this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(E - E % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);
            };
            break;
          case "point":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, this.parameters.pointCoords[0], this.parameters.pointCoords[1]), y = this.el.array().valueOf();
              y[this.parameters.i][0] = this.parameters.pointCoords[0] + p[0], y[this.parameters.i][1] = this.parameters.pointCoords[1] + p[1], this.el.plot(y);
            };
        }
        this.el.fire("resizestart", { dx: this.parameters.x, dy: this.parameters.y, event: t }), SVG.on(window, "touchmove.resize", function(d) {
          n.update(d || window.event);
        }), SVG.on(window, "touchend.resize", function() {
          n.done();
        }), SVG.on(window, "mousemove.resize", function(d) {
          n.update(d || window.event);
        }), SVG.on(window, "mouseup.resize", function() {
          n.done();
        });
      }, B.prototype.update = function(t) {
        if (t) {
          var n = this._extractPosition(t), i = this.transformPoint(n.x, n.y), o = i.x - this.parameters.p.x, d = i.y - this.parameters.p.y;
          this.lastUpdateCall = [o, d], this.calc(o, d), this.el.fire("resizing", { dx: o, dy: d, event: t });
        } else
          this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
      }, B.prototype.done = function() {
        this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone");
      }, B.prototype.snapToGrid = function(t, n, i, o) {
        var d;
        return o !== void 0 ? d = [(i + t) % this.options.snapToGrid, (o + n) % this.options.snapToGrid] : (i = i ?? 3, d = [(this.parameters.box.x + t + (1 & i ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + n + (2 & i ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), t < 0 && (d[0] -= this.options.snapToGrid), n < 0 && (d[1] -= this.options.snapToGrid), t -= Math.abs(d[0]) < this.options.snapToGrid / 2 ? d[0] : d[0] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid), n -= Math.abs(d[1]) < this.options.snapToGrid / 2 ? d[1] : d[1] - (n < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t, n, i, o);
      }, B.prototype.constraintToBox = function(t, n, i, o) {
        var d, f, p = this.options.constraint || {};
        return o !== void 0 ? (d = i, f = o) : (d = this.parameters.box.x + (1 & i ? 0 : this.parameters.box.width), f = this.parameters.box.y + (2 & i ? 0 : this.parameters.box.height)), p.minX !== void 0 && d + t < p.minX && (t = p.minX - d), p.maxX !== void 0 && d + t > p.maxX && (t = p.maxX - d), p.minY !== void 0 && f + n < p.minY && (n = p.minY - f), p.maxY !== void 0 && f + n > p.maxY && (n = p.maxY - f), [t, n];
      }, B.prototype.checkAspectRatio = function(t, n) {
        if (!this.options.saveAspectRatio)
          return t;
        var i = t.slice(), o = this.parameters.box.width / this.parameters.box.height, d = this.parameters.box.width + t[0], f = this.parameters.box.height - t[1], p = d / f;
        return p < o ? (i[1] = d / o - this.parameters.box.height, n && (i[1] = -i[1])) : p > o && (i[0] = this.parameters.box.width - f * o, n && (i[0] = -i[0])), i;
      }, SVG.extend(SVG.Element, { resize: function(t) {
        return (this.remember("_resizeHandler") || new B(this)).init(t || {}), this;
      } }), SVG.Element.prototype.resize.defaults = { snapToAngle: 0.1, snapToGrid: 1, constraint: {}, saveAspectRatio: !1 };
    }).call(this);
  }(), window.Apex === void 0 && (window.Apex = {});
  var Zt = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "initModules", value: function() {
      this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new we(this.ctx), this.ctx.axes = new Mr(this.ctx), this.ctx.core = new qt(this.ctx.el, this.ctx), this.ctx.config = new pt({}), this.ctx.data = new It(this.ctx), this.ctx.grid = new vn(this.ctx), this.ctx.graphics = new re(this.ctx), this.ctx.coreUtils = new ve(this.ctx), this.ctx.crosshairs = new ei(this.ctx), this.ctx.events = new rr(this.ctx), this.ctx.exports = new Ut(this.ctx), this.ctx.localization = new Lr(this.ctx), this.ctx.options = new wt(), this.ctx.responsive = new qi(this.ctx), this.ctx.series = new ot(this.ctx), this.ctx.theme = new Oa(this.ctx), this.ctx.formatters = new Ht(this.ctx), this.ctx.titleSubtitle = new ca(this.ctx), this.ctx.legend = new ni(this.ctx), this.ctx.toolbar = new _a(this.ctx), this.ctx.tooltip = new $n(this.ctx), this.ctx.dimensions = new ti(this.ctx), this.ctx.updateHelpers = new cn(this.ctx), this.ctx.zoomPanSelection = new Qi(this.ctx), this.ctx.w.globals.tooltip = new $n(this.ctx);
    } }]), B;
  }(), Ot = function() {
    function B(t) {
      A(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "clear", value: function(t) {
      var n = t.isUpdating;
      this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: n });
    } }, { key: "killSVG", value: function(t) {
      t.each(function(n, i) {
        this.removeClass("*"), this.off(), this.stop();
      }, !0), t.ungroup(), t.clear();
    } }, { key: "clearDomElements", value: function(t) {
      var n = this, i = t.isUpdating, o = this.w.globals.dom.Paper.node;
      o.parentNode && o.parentNode.parentNode && !i && (o.parentNode.parentNode.style.minHeight = "unset");
      var d = this.w.globals.dom.baseEl;
      d && this.ctx.eventList.forEach(function(p) {
        d.removeEventListener(p, n.ctx.events.documentEvent);
      });
      var f = this.w.globals.dom;
      if (this.ctx.el !== null)
        for (; this.ctx.el.firstChild; )
          this.ctx.el.removeChild(this.ctx.el.firstChild);
      this.killSVG(f.Paper), f.Paper.remove(), f.elWrap = null, f.elGraphical = null, f.elLegendWrap = null, f.elLegendForeign = null, f.baseEl = null, f.elGridRect = null, f.elGridRectMask = null, f.elGridRectMarkerMask = null, f.elForecastMask = null, f.elNonForecastMask = null, f.elDefs = null;
    } }]), B;
  }(), ar = /* @__PURE__ */ new WeakMap(), Yn = function() {
    function B(t, n) {
      A(this, B), this.opts = n, this.ctx = this, this.w = new je(n).init(), this.el = t, this.w.globals.cuid = Q.randomId(), this.w.globals.chartID = this.w.config.chart.id ? Q.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new Zt(this).initModules(), this.create = Q.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
    }
    return F(B, [{ key: "render", value: function() {
      var t = this;
      return new Promise(function(n, i) {
        if (t.el !== null) {
          Apex._chartInstances === void 0 && (Apex._chartInstances = []), t.w.config.chart.id && Apex._chartInstances.push({ id: t.w.globals.chartID, group: t.w.config.chart.group, chart: t }), t.setLocale(t.w.config.chart.defaultLocale);
          var o = t.w.config.chart.events.beforeMount;
          if (typeof o == "function" && o(t, t.w), t.events.fireEvent("beforeMount", [t, t.w]), window.addEventListener("resize", t.windowResizeHandler), function(C, E) {
            var L = !1;
            if (C.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
              var O = C.getBoundingClientRect();
              C.style.display !== "none" && O.width !== 0 || (L = !0);
            }
            var P = new ResizeObserver(function(I) {
              L && E.call(C, I), L = !0;
            });
            C.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(C.children).forEach(function(I) {
              return P.observe(I);
            }) : P.observe(C), ar.set(E, P);
          }(t.el.parentNode, t.parentResizeHandler), !t.css) {
            var d = t.el.getRootNode && t.el.getRootNode(), f = Q.is("ShadowRoot", d), p = t.el.ownerDocument, y = p.getElementById("apexcharts-css");
            !f && y || (t.css = document.createElement("style"), t.css.id = "apexcharts-css", t.css.textContent = `@keyframes opaque {
  0% {
      opacity: 0
  }

  to {
      opacity: 1
  }
}

@keyframes resizeanim {
  0%,to {
      opacity: 0
  }
}

.apexcharts-canvas {
  position: relative;
  user-select: none
}

.apexcharts-canvas ::-webkit-scrollbar {
  -webkit-appearance: none;
  width: 6px
}

.apexcharts-canvas ::-webkit-scrollbar-thumb {
  border-radius: 4px;
  background-color: rgba(0,0,0,.5);
  box-shadow: 0 0 1px rgba(255,255,255,.5);
  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5)
}

.apexcharts-inner {
  position: relative
}

.apexcharts-text tspan {
  font-family: inherit
}

.legend-mouseover-inactive {
  transition: .15s ease all;
  opacity: .2
}

.apexcharts-legend-text {
  padding-left: 15px;
  margin-left: -15px;
}

.apexcharts-series-collapsed {
  opacity: 0
}

.apexcharts-tooltip {
  border-radius: 5px;
  box-shadow: 2px 2px 6px -4px #999;
  cursor: default;
  font-size: 14px;
  left: 62px;
  opacity: 0;
  pointer-events: none;
  position: absolute;
  top: 20px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  white-space: nowrap;
  z-index: 12;
  transition: .15s ease all
}

.apexcharts-tooltip.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-tooltip.apexcharts-theme-light {
  border: 1px solid #e3e3e3;
  background: rgba(255,255,255,.96)
}

.apexcharts-tooltip.apexcharts-theme-dark {
  color: #fff;
  background: rgba(30,30,30,.8)
}

.apexcharts-tooltip * {
  font-family: inherit
}

.apexcharts-tooltip-title {
  padding: 6px;
  font-size: 15px;
  margin-bottom: 4px
}

.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {
  background: #eceff1;
  border-bottom: 1px solid #ddd
}

.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {
  background: rgba(0,0,0,.7);
  border-bottom: 1px solid #333
}

.apexcharts-tooltip-text-goals-value,.apexcharts-tooltip-text-y-value,.apexcharts-tooltip-text-z-value {
  display: inline-block;
  margin-left: 5px;
  font-weight: 600
}

.apexcharts-tooltip-text-goals-label:empty,.apexcharts-tooltip-text-goals-value:empty,.apexcharts-tooltip-text-y-label:empty,.apexcharts-tooltip-text-y-value:empty,.apexcharts-tooltip-text-z-value:empty,.apexcharts-tooltip-title:empty {
  display: none
}

.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {
  padding: 6px 0 5px
}

.apexcharts-tooltip-goals-group,.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {
  display: flex
}

.apexcharts-tooltip-text-goals-label:not(:empty),.apexcharts-tooltip-text-goals-value:not(:empty) {
  margin-top: -6px
}

.apexcharts-tooltip-marker {
  width: 12px;
  height: 12px;
  position: relative;
  top: 0;
  margin-right: 10px;
  border-radius: 50%
}

.apexcharts-tooltip-series-group {
  padding: 0 10px;
  display: none;
  text-align: left;
  justify-content: left;
  align-items: center
}

.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {
  opacity: 1
}

.apexcharts-tooltip-series-group.apexcharts-active,.apexcharts-tooltip-series-group:last-child {
  padding-bottom: 4px
}

.apexcharts-tooltip-series-group-hidden {
  opacity: 0;
  height: 0;
  line-height: 0;
  padding: 0!important
}

.apexcharts-tooltip-y-group {
  padding: 6px 0 5px
}

.apexcharts-custom-tooltip,.apexcharts-tooltip-box {
  padding: 4px 8px
}

.apexcharts-tooltip-boxPlot {
  display: flex;
  flex-direction: column-reverse
}

.apexcharts-tooltip-box>div {
  margin: 4px 0
}

.apexcharts-tooltip-box span.value {
  font-weight: 700
}

.apexcharts-tooltip-rangebar {
  padding: 5px 8px
}

.apexcharts-tooltip-rangebar .category {
  font-weight: 600;
  color: #777
}

.apexcharts-tooltip-rangebar .series-name {
  font-weight: 700;
  display: block;
  margin-bottom: 5px
}

.apexcharts-xaxistooltip,.apexcharts-yaxistooltip {
  opacity: 0;
  pointer-events: none;
  color: #373d3f;
  font-size: 13px;
  text-align: center;
  border-radius: 2px;
  position: absolute;
  z-index: 10;
  background: #eceff1;
  border: 1px solid #90a4ae
}

.apexcharts-xaxistooltip {
  padding: 9px 10px;
  transition: .15s ease all
}

.apexcharts-xaxistooltip.apexcharts-theme-dark {
  background: rgba(0,0,0,.7);
  border: 1px solid rgba(0,0,0,.5);
  color: #fff
}

.apexcharts-xaxistooltip:after,.apexcharts-xaxistooltip:before {
  left: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none
}

.apexcharts-xaxistooltip:after {
  border-color: transparent;
  border-width: 6px;
  margin-left: -6px
}

.apexcharts-xaxistooltip:before {
  border-color: transparent;
  border-width: 7px;
  margin-left: -7px
}

.apexcharts-xaxistooltip-bottom:after,.apexcharts-xaxistooltip-bottom:before {
  bottom: 100%
}

.apexcharts-xaxistooltip-top:after,.apexcharts-xaxistooltip-top:before {
  top: 100%
}

.apexcharts-xaxistooltip-bottom:after {
  border-bottom-color: #eceff1
}

.apexcharts-xaxistooltip-bottom:before {
  border-bottom-color: #90a4ae
}

.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {
  border-bottom-color: rgba(0,0,0,.5)
}

.apexcharts-xaxistooltip-top:after {
  border-top-color: #eceff1
}

.apexcharts-xaxistooltip-top:before {
  border-top-color: #90a4ae
}

.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {
  border-top-color: rgba(0,0,0,.5)
}

.apexcharts-xaxistooltip.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-yaxistooltip {
  padding: 4px 10px
}

.apexcharts-yaxistooltip.apexcharts-theme-dark {
  background: rgba(0,0,0,.7);
  border: 1px solid rgba(0,0,0,.5);
  color: #fff
}

.apexcharts-yaxistooltip:after,.apexcharts-yaxistooltip:before {
  top: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none
}

.apexcharts-yaxistooltip:after {
  border-color: transparent;
  border-width: 6px;
  margin-top: -6px
}

.apexcharts-yaxistooltip:before {
  border-color: transparent;
  border-width: 7px;
  margin-top: -7px
}

.apexcharts-yaxistooltip-left:after,.apexcharts-yaxistooltip-left:before {
  left: 100%
}

.apexcharts-yaxistooltip-right:after,.apexcharts-yaxistooltip-right:before {
  right: 100%
}

.apexcharts-yaxistooltip-left:after {
  border-left-color: #eceff1
}

.apexcharts-yaxistooltip-left:before {
  border-left-color: #90a4ae
}

.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {
  border-left-color: rgba(0,0,0,.5)
}

.apexcharts-yaxistooltip-right:after {
  border-right-color: #eceff1
}

.apexcharts-yaxistooltip-right:before {
  border-right-color: #90a4ae
}

.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {
  border-right-color: rgba(0,0,0,.5)
}

.apexcharts-yaxistooltip.apexcharts-active {
  opacity: 1
}

.apexcharts-yaxistooltip-hidden {
  display: none
}

.apexcharts-xcrosshairs,.apexcharts-ycrosshairs {
  pointer-events: none;
  opacity: 0;
  transition: .15s ease all
}

.apexcharts-xcrosshairs.apexcharts-active,.apexcharts-ycrosshairs.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-ycrosshairs-hidden {
  opacity: 0
}

.apexcharts-selection-rect {
  cursor: move
}

.svg_select_boundingRect,.svg_select_points_rot {
  pointer-events: none;
  opacity: 0;
  visibility: hidden
}

.apexcharts-selection-rect+g .svg_select_boundingRect,.apexcharts-selection-rect+g .svg_select_points_rot {
  opacity: 0;
  visibility: hidden
}

.apexcharts-selection-rect+g .svg_select_points_l,.apexcharts-selection-rect+g .svg_select_points_r {
  cursor: ew-resize;
  opacity: 1;
  visibility: visible
}

.svg_select_points {
  fill: #efefef;
  stroke: #333;
  rx: 2
}

.apexcharts-svg.apexcharts-zoomable.hovering-zoom {
  cursor: crosshair
}

.apexcharts-svg.apexcharts-zoomable.hovering-pan {
  cursor: move
}

.apexcharts-menu-icon,.apexcharts-pan-icon,.apexcharts-reset-icon,.apexcharts-selection-icon,.apexcharts-toolbar-custom-icon,.apexcharts-zoom-icon,.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {
  cursor: pointer;
  width: 20px;
  height: 20px;
  line-height: 24px;
  color: #6e8192;
  text-align: center
}

.apexcharts-menu-icon svg,.apexcharts-reset-icon svg,.apexcharts-zoom-icon svg,.apexcharts-zoomin-icon svg,.apexcharts-zoomout-icon svg {
  fill: #6e8192
}

.apexcharts-selection-icon svg {
  fill: #444;
  transform: scale(.76)
}

.apexcharts-theme-dark .apexcharts-menu-icon svg,.apexcharts-theme-dark .apexcharts-pan-icon svg,.apexcharts-theme-dark .apexcharts-reset-icon svg,.apexcharts-theme-dark .apexcharts-selection-icon svg,.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,.apexcharts-theme-dark .apexcharts-zoom-icon svg,.apexcharts-theme-dark .apexcharts-zoomin-icon svg,.apexcharts-theme-dark .apexcharts-zoomout-icon svg {
  fill: #f3f4f5
}

.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {
  fill: #008ffb
}

.apexcharts-theme-light .apexcharts-menu-icon:hover svg,.apexcharts-theme-light .apexcharts-reset-icon:hover svg,.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {
  fill: #333
}

.apexcharts-menu-icon,.apexcharts-selection-icon {
  position: relative
}

.apexcharts-reset-icon {
  margin-left: 5px
}

.apexcharts-menu-icon,.apexcharts-reset-icon,.apexcharts-zoom-icon {
  transform: scale(.85)
}

.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {
  transform: scale(.7)
}

.apexcharts-zoomout-icon {
  margin-right: 3px
}

.apexcharts-pan-icon {
  transform: scale(.62);
  position: relative;
  left: 1px;
  top: 0
}

.apexcharts-pan-icon svg {
  fill: #fff;
  stroke: #6e8192;
  stroke-width: 2
}

.apexcharts-pan-icon.apexcharts-selected svg {
  stroke: #008ffb
}

.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {
  stroke: #333
}

.apexcharts-toolbar {
  position: absolute;
  z-index: 11;
  max-width: 176px;
  text-align: right;
  border-radius: 3px;
  padding: 0 6px 2px;
  display: flex;
  justify-content: space-between;
  align-items: center
}

.apexcharts-menu {
  background: #fff;
  position: absolute;
  top: 100%;
  border: 1px solid #ddd;
  border-radius: 3px;
  padding: 3px;
  right: 10px;
  opacity: 0;
  min-width: 110px;
  transition: .15s ease all;
  pointer-events: none
}

.apexcharts-menu.apexcharts-menu-open {
  opacity: 1;
  pointer-events: all;
  transition: .15s ease all
}

.apexcharts-menu-item {
  padding: 6px 7px;
  font-size: 12px;
  cursor: pointer
}

.apexcharts-theme-light .apexcharts-menu-item:hover {
  background: #eee
}

.apexcharts-theme-dark .apexcharts-menu {
  background: rgba(0,0,0,.7);
  color: #fff
}

@media screen and (min-width:768px) {
  .apexcharts-canvas:hover .apexcharts-toolbar {
      opacity: 1
  }
}

.apexcharts-canvas .apexcharts-element-hidden,.apexcharts-datalabel.apexcharts-element-hidden,.apexcharts-hide .apexcharts-series-points {
  opacity: 0
}

.apexcharts-hidden-element-shown {
  opacity: 1;
  transition: 0.25s ease all;
}
.apexcharts-datalabel,.apexcharts-datalabel-label,.apexcharts-datalabel-value,.apexcharts-datalabels,.apexcharts-pie-label {
  cursor: default;
  pointer-events: none
}

.apexcharts-pie-label-delay {
  opacity: 0;
  animation-name: opaque;
  animation-duration: .3s;
  animation-fill-mode: forwards;
  animation-timing-function: ease
}

.apexcharts-annotation-rect,.apexcharts-area-series .apexcharts-area,.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-gridline,.apexcharts-line,.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-point-annotation-label,.apexcharts-radar-series path,.apexcharts-radar-series polygon,.apexcharts-toolbar svg,.apexcharts-tooltip .apexcharts-marker,.apexcharts-xaxis-annotation-label,.apexcharts-yaxis-annotation-label,.apexcharts-zoom-rect {
  pointer-events: none
}

.apexcharts-marker {
  transition: .15s ease all
}

.resize-triggers {
  animation: 1ms resizeanim;
  visibility: hidden;
  opacity: 0;
  height: 100%;
  width: 100%;
  overflow: hidden
}

.contract-trigger:before,.resize-triggers,.resize-triggers>div {
  content: " ";
  display: block;
  position: absolute;
  top: 0;
  left: 0
}

.resize-triggers>div {
  height: 100%;
  width: 100%;
  background: #eee;
  overflow: auto
}

.contract-trigger:before {
  overflow: hidden;
  width: 200%;
  height: 200%
}

.apexcharts-bar-goals-markers{
  pointer-events: none
}

.apexcharts-bar-shadows{
  pointer-events: none
}

.apexcharts-rangebar-goals-markers{
  pointer-events: none
}`, f ? d.prepend(t.css) : p.head.appendChild(t.css));
          }
          var S = t.create(t.w.config.series, {});
          if (!S)
            return n(t);
          t.mount(S).then(function() {
            typeof t.w.config.chart.events.mounted == "function" && t.w.config.chart.events.mounted(t, t.w), t.events.fireEvent("mounted", [t, t.w]), n(S);
          }).catch(function(C) {
            i(C);
          });
        } else
          i(new Error("Element not found"));
      });
    } }, { key: "create", value: function(t, n) {
      var i = this.w;
      new Zt(this).initModules();
      var o = this.w.globals;
      if (o.noData = !1, o.animationEnded = !1, this.responsive.checkResponsiveConfig(n), i.config.xaxis.convertedCatToNumeric && new We(i.config).convertCatToNumericXaxis(i.config, this.ctx), this.el === null || (this.core.setupElements(), i.config.chart.type === "treemap" && (i.config.grid.show = !1, i.config.yaxis[0].show = !1), o.svgWidth === 0))
        return o.animationEnded = !0, null;
      var d = ve.checkComboSeries(t);
      o.comboCharts = d.comboCharts, o.comboBarCount = d.comboBarCount;
      var f = t.every(function(C) {
        return C.data && C.data.length === 0;
      });
      (t.length === 0 || f) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t), this.theme.init(), new kt(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), o.noData && o.collapsedSeries.length !== o.series.length && !i.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), o.axisCharts && (this.core.coreCalculations(), i.config.xaxis.type !== "category" && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = i.globals.minX, this.ctx.toolbar.maxX = i.globals.maxX), this.formatters.heatmapLabelFormatters(), new ve(this).getLargestMarkerSize(), this.dimensions.plotCoords();
      var p = this.core.xySettings();
      this.grid.createGridMask();
      var y = this.core.plotChartType(t, p), S = new jt(this);
      return S.bringForward(), i.config.dataLabels.background.enabled && S.dataLabelsBackground(), this.core.shiftGraphPosition(), { elGraph: y, xyRatios: p, dimensions: { plot: { left: i.globals.translateX, top: i.globals.translateY, width: i.globals.gridWidth, height: i.globals.gridHeight } } };
    } }, { key: "mount", value: function() {
      var t = this, n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, i = this, o = i.w;
      return new Promise(function(d, f) {
        if (i.el === null)
          return f(new Error("Not enough data to display or target element not found"));
        (n === null || o.globals.allSeriesCollapsed) && i.series.handleNoData(), i.grid = new vn(i);
        var p, y, S = i.grid.drawGrid();
        if (i.annotations = new st(i), i.annotations.drawImageAnnos(), i.annotations.drawTextAnnos(), o.config.grid.position === "back" && (S && o.globals.dom.elGraphical.add(S.el), S != null && (p = S.elGridBorders) !== null && p !== void 0 && p.node && o.globals.dom.elGraphical.add(S.elGridBorders)), Array.isArray(n.elGraph))
          for (var C = 0; C < n.elGraph.length; C++)
            o.globals.dom.elGraphical.add(n.elGraph[C]);
        else
          o.globals.dom.elGraphical.add(n.elGraph);
        o.config.grid.position === "front" && (S && o.globals.dom.elGraphical.add(S.el), S != null && (y = S.elGridBorders) !== null && y !== void 0 && y.node && o.globals.dom.elGraphical.add(S.elGridBorders)), o.config.xaxis.crosshairs.position === "front" && i.crosshairs.drawXCrosshairs(), o.config.yaxis[0].crosshairs.position === "front" && i.crosshairs.drawYCrosshairs(), o.config.chart.type !== "treemap" && i.axes.drawAxis(o.config.chart.type, S);
        var E = new Bt(t.ctx, S), L = new jn(t.ctx, S);
        if (S !== null && (E.xAxisLabelCorrections(S.xAxisTickWidth), L.setYAxisTextAlignments(), o.config.yaxis.map(function(P, I) {
          o.globals.ignoreYAxisIndexes.indexOf(I) === -1 && L.yAxisTitleRotate(I, P.opposite);
        })), i.annotations.drawAxesAnnotations(), !o.globals.noData) {
          if (o.config.tooltip.enabled && !o.globals.noData && i.w.globals.tooltip.drawTooltip(n.xyRatios), o.globals.axisCharts && (o.globals.isXNumeric || o.config.xaxis.convertedCatToNumeric || o.globals.isRangeBar))
            (o.config.chart.zoom.enabled || o.config.chart.selection && o.config.chart.selection.enabled || o.config.chart.pan && o.config.chart.pan.enabled) && i.zoomPanSelection.init({ xyRatios: n.xyRatios });
          else {
            var O = o.config.chart.toolbar.tools;
            ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(P) {
              O[P] = !1;
            });
          }
          o.config.chart.toolbar.show && !o.globals.allSeriesCollapsed && i.toolbar.createToolbar();
        }
        o.globals.memory.methodsToExec.length > 0 && o.globals.memory.methodsToExec.forEach(function(P) {
          P.method(P.params, !1, P.context);
        }), o.globals.axisCharts || o.globals.noData || i.core.resizeNonAxisCharts(), d(i);
      });
    } }, { key: "destroy", value: function() {
      var t, n;
      window.removeEventListener("resize", this.windowResizeHandler), this.el.parentNode, t = this.parentResizeHandler, (n = ar.get(t)) && (n.disconnect(), ar.delete(t));
      var i = this.w.config.chart.id;
      i && Apex._chartInstances.forEach(function(o, d) {
        o.id === Q.escapeString(i) && Apex._chartInstances.splice(d, 1);
      }), new Ot(this.ctx).clear({ isUpdating: !1 });
    } }, { key: "updateOptions", value: function(t) {
      var n = this, i = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], o = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], d = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], f = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], p = this.w;
      return p.globals.selection = void 0, t.series && (this.series.resetSeries(!1, !0, !1), t.series.length && t.series[0].data && (t.series = t.series.map(function(y, S) {
        return n.updateHelpers._extendSeries(y, S);
      })), this.updateHelpers.revertDefaultAxisMinMax()), t.xaxis && (t = this.updateHelpers.forceXAxisUpdate(t)), t.yaxis && (t = this.updateHelpers.forceYAxisUpdate(t)), p.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t.theme && (t = this.theme.updateThemeOptions(t)), this.updateHelpers._updateOptions(t, i, o, d, f);
    } }, { key: "updateSeries", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
      return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t, n, i);
    } }, { key: "appendSeries", value: function(t) {
      var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], o = this.w.config.series.slice();
      return o.push(t), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(o, n, i);
    } }, { key: "appendData", value: function(t) {
      var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = this;
      i.w.globals.dataChanged = !0, i.series.getPreviousPaths();
      for (var o = i.w.config.series.slice(), d = 0; d < o.length; d++)
        if (t[d] !== null && t[d] !== void 0)
          for (var f = 0; f < t[d].data.length; f++)
            o[d].data.push(t[d].data[f]);
      return i.w.config.series = o, n && (i.w.globals.initialSeries = Q.clone(i.w.config.series)), this.update();
    } }, { key: "update", value: function(t) {
      var n = this;
      return new Promise(function(i, o) {
        new Ot(n.ctx).clear({ isUpdating: !0 });
        var d = n.create(n.w.config.series, t);
        if (!d)
          return i(n);
        n.mount(d).then(function() {
          typeof n.w.config.chart.events.updated == "function" && n.w.config.chart.events.updated(n, n.w), n.events.fireEvent("updated", [n, n.w]), n.w.globals.isDirty = !0, i(n);
        }).catch(function(f) {
          o(f);
        });
      });
    } }, { key: "getSyncedCharts", value: function() {
      var t = this.getGroupedCharts(), n = [this];
      return t.length && (n = [], t.forEach(function(i) {
        n.push(i);
      })), n;
    } }, { key: "getGroupedCharts", value: function() {
      var t = this;
      return Apex._chartInstances.filter(function(n) {
        if (n.group)
          return !0;
      }).map(function(n) {
        return t.w.config.chart.group === n.group ? n.chart : t;
      });
    } }, { key: "toggleSeries", value: function(t) {
      return this.series.toggleSeries(t);
    } }, { key: "highlightSeriesOnLegendHover", value: function(t, n) {
      return this.series.toggleSeriesOnHover(t, n);
    } }, { key: "showSeries", value: function(t) {
      this.series.showSeries(t);
    } }, { key: "hideSeries", value: function(t) {
      this.series.hideSeries(t);
    } }, { key: "resetSeries", value: function() {
      var t = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
      this.series.resetSeries(t, n);
    } }, { key: "addEventListener", value: function(t, n) {
      this.events.addEventListener(t, n);
    } }, { key: "removeEventListener", value: function(t, n) {
      this.events.removeEventListener(t, n);
    } }, { key: "addXaxisAnnotation", value: function(t) {
      var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, o = this;
      i && (o = i), o.annotations.addXaxisAnnotationExternal(t, n, o);
    } }, { key: "addYaxisAnnotation", value: function(t) {
      var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, o = this;
      i && (o = i), o.annotations.addYaxisAnnotationExternal(t, n, o);
    } }, { key: "addPointAnnotation", value: function(t) {
      var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, o = this;
      i && (o = i), o.annotations.addPointAnnotationExternal(t, n, o);
    } }, { key: "clearAnnotations", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0, n = this;
      t && (n = t), n.annotations.clearAnnotations(n);
    } }, { key: "removeAnnotation", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0, i = this;
      n && (i = n), i.annotations.removeAnnotation(i, t);
    } }, { key: "getChartArea", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
    } }, { key: "getSeriesTotalXRange", value: function(t, n) {
      return this.coreUtils.getSeriesTotalsXRange(t, n);
    } }, { key: "getHighestValueInSeries", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return new pn(this.ctx).getMinYMaxY(t).highestY;
    } }, { key: "getLowestValueInSeries", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return new pn(this.ctx).getMinYMaxY(t).lowestY;
    } }, { key: "getSeriesTotal", value: function() {
      return this.w.globals.seriesTotals;
    } }, { key: "toggleDataPointSelection", value: function(t, n) {
      return this.updateHelpers.toggleDataPointSelection(t, n);
    } }, { key: "zoomX", value: function(t, n) {
      this.ctx.toolbar.zoomUpdateOptions(t, n);
    } }, { key: "setLocale", value: function(t) {
      this.localization.setCurrentLocaleValues(t);
    } }, { key: "dataURI", value: function(t) {
      return new Ut(this.ctx).dataURI(t);
    } }, { key: "exportToCSV", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return new Ut(this.ctx).exportToCSV(t);
    } }, { key: "paper", value: function() {
      return this.w.globals.dom.Paper;
    } }, { key: "_parentResizeCallback", value: function() {
      this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
    } }, { key: "_windowResize", value: function() {
      var t = this;
      clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
        t.w.globals.resized = !0, t.w.globals.dataChanged = !1, t.ctx.update();
      }, 150);
    } }, { key: "_windowResizeHandler", value: function() {
      var t = this.w.config.chart.redrawOnWindowResize;
      typeof t == "function" && (t = t()), t && this._windowResize();
    } }], [{ key: "getChartByID", value: function(t) {
      var n = Q.escapeString(t), i = Apex._chartInstances.filter(function(o) {
        return o.id === n;
      })[0];
      return i && i.chart;
    } }, { key: "initOnLoad", value: function() {
      for (var t = document.querySelectorAll("[data-apexcharts]"), n = 0; n < t.length; n++)
        new B(t[n], JSON.parse(t[n].getAttribute("data-options"))).render();
    } }, { key: "exec", value: function(t, n) {
      var i = this.getChartByID(t);
      if (i) {
        i.w.globals.isExecCalled = !0;
        var o = null;
        if (i.publicMethods.indexOf(n) !== -1) {
          for (var d = arguments.length, f = new Array(d > 2 ? d - 2 : 0), p = 2; p < d; p++)
            f[p - 2] = arguments[p];
          o = i[n].apply(i, f);
        }
        return o;
      }
    } }, { key: "merge", value: function(t, n) {
      return Q.extend(t, n);
    } }]), B;
  }();
  s.exports = Yn;
})(R1, R1.exports);
var uj = R1.exports, L1 = { exports: {} }, Cy = { exports: {} }, Pn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ZT;
function cj() {
  if (ZT)
    return Pn;
  ZT = 1;
  var s = typeof Symbol == "function" && Symbol.for, u = s ? Symbol.for("react.element") : 60103, h = s ? Symbol.for("react.portal") : 60106, v = s ? Symbol.for("react.fragment") : 60107, w = s ? Symbol.for("react.strict_mode") : 60108, A = s ? Symbol.for("react.profiler") : 60114, T = s ? Symbol.for("react.provider") : 60109, F = s ? Symbol.for("react.context") : 60110, H = s ? Symbol.for("react.async_mode") : 60111, U = s ? Symbol.for("react.concurrent_mode") : 60111, $ = s ? Symbol.for("react.forward_ref") : 60112, q = s ? Symbol.for("react.suspense") : 60113, te = s ? Symbol.for("react.suspense_list") : 60120, se = s ? Symbol.for("react.memo") : 60115, ae = s ? Symbol.for("react.lazy") : 60116, ue = s ? Symbol.for("react.block") : 60121, Re = s ? Symbol.for("react.fundamental") : 60117, Ne = s ? Symbol.for("react.responder") : 60118, Q = s ? Symbol.for("react.scope") : 60119;
  function we(re) {
    if (typeof re == "object" && re !== null) {
      var ve = re.$$typeof;
      switch (ve) {
        case u:
          switch (re = re.type, re) {
            case H:
            case U:
            case v:
            case A:
            case w:
            case q:
              return re;
            default:
              switch (re = re && re.$$typeof, re) {
                case F:
                case $:
                case ae:
                case se:
                case T:
                  return re;
                default:
                  return ve;
              }
          }
        case h:
          return ve;
      }
    }
  }
  function Ee(re) {
    return we(re) === U;
  }
  return Pn.AsyncMode = H, Pn.ConcurrentMode = U, Pn.ContextConsumer = F, Pn.ContextProvider = T, Pn.Element = u, Pn.ForwardRef = $, Pn.Fragment = v, Pn.Lazy = ae, Pn.Memo = se, Pn.Portal = h, Pn.Profiler = A, Pn.StrictMode = w, Pn.Suspense = q, Pn.isAsyncMode = function(re) {
    return Ee(re) || we(re) === H;
  }, Pn.isConcurrentMode = Ee, Pn.isContextConsumer = function(re) {
    return we(re) === F;
  }, Pn.isContextProvider = function(re) {
    return we(re) === T;
  }, Pn.isElement = function(re) {
    return typeof re == "object" && re !== null && re.$$typeof === u;
  }, Pn.isForwardRef = function(re) {
    return we(re) === $;
  }, Pn.isFragment = function(re) {
    return we(re) === v;
  }, Pn.isLazy = function(re) {
    return we(re) === ae;
  }, Pn.isMemo = function(re) {
    return we(re) === se;
  }, Pn.isPortal = function(re) {
    return we(re) === h;
  }, Pn.isProfiler = function(re) {
    return we(re) === A;
  }, Pn.isStrictMode = function(re) {
    return we(re) === w;
  }, Pn.isSuspense = function(re) {
    return we(re) === q;
  }, Pn.isValidElementType = function(re) {
    return typeof re == "string" || typeof re == "function" || re === v || re === U || re === A || re === w || re === q || re === te || typeof re == "object" && re !== null && (re.$$typeof === ae || re.$$typeof === se || re.$$typeof === T || re.$$typeof === F || re.$$typeof === $ || re.$$typeof === Re || re.$$typeof === Ne || re.$$typeof === Q || re.$$typeof === ue);
  }, Pn.typeOf = we, Pn;
}
var Nn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var QT;
function dj() {
  return QT || (QT = 1, process.env.NODE_ENV !== "production" && function() {
    var s = typeof Symbol == "function" && Symbol.for, u = s ? Symbol.for("react.element") : 60103, h = s ? Symbol.for("react.portal") : 60106, v = s ? Symbol.for("react.fragment") : 60107, w = s ? Symbol.for("react.strict_mode") : 60108, A = s ? Symbol.for("react.profiler") : 60114, T = s ? Symbol.for("react.provider") : 60109, F = s ? Symbol.for("react.context") : 60110, H = s ? Symbol.for("react.async_mode") : 60111, U = s ? Symbol.for("react.concurrent_mode") : 60111, $ = s ? Symbol.for("react.forward_ref") : 60112, q = s ? Symbol.for("react.suspense") : 60113, te = s ? Symbol.for("react.suspense_list") : 60120, se = s ? Symbol.for("react.memo") : 60115, ae = s ? Symbol.for("react.lazy") : 60116, ue = s ? Symbol.for("react.block") : 60121, Re = s ? Symbol.for("react.fundamental") : 60117, Ne = s ? Symbol.for("react.responder") : 60118, Q = s ? Symbol.for("react.scope") : 60119;
    function we(Ze) {
      return typeof Ze == "string" || typeof Ze == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      Ze === v || Ze === U || Ze === A || Ze === w || Ze === q || Ze === te || typeof Ze == "object" && Ze !== null && (Ze.$$typeof === ae || Ze.$$typeof === se || Ze.$$typeof === T || Ze.$$typeof === F || Ze.$$typeof === $ || Ze.$$typeof === Re || Ze.$$typeof === Ne || Ze.$$typeof === Q || Ze.$$typeof === ue);
    }
    function Ee(Ze) {
      if (typeof Ze == "object" && Ze !== null) {
        var pn = Ze.$$typeof;
        switch (pn) {
          case u:
            var jn = Ze.type;
            switch (jn) {
              case H:
              case U:
              case v:
              case A:
              case w:
              case q:
                return jn;
              default:
                var rr = jn && jn.$$typeof;
                switch (rr) {
                  case F:
                  case $:
                  case ae:
                  case se:
                  case T:
                    return rr;
                  default:
                    return pn;
                }
            }
          case h:
            return pn;
        }
      }
    }
    var re = H, ve = U, Le = F, Qe = T, Be = u, Ge = $, ft = v, wt = ae, st = se, it = h, Ht = A, Mt = w, an = q, We = !1;
    function pt(Ze) {
      return We || (We = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), ye(Ze) || Ee(Ze) === H;
    }
    function ye(Ze) {
      return Ee(Ze) === U;
    }
    function je(Ze) {
      return Ee(Ze) === F;
    }
    function Je(Ze) {
      return Ee(Ze) === T;
    }
    function kt(Ze) {
      return typeof Ze == "object" && Ze !== null && Ze.$$typeof === u;
    }
    function At(Ze) {
      return Ee(Ze) === $;
    }
    function jt(Ze) {
      return Ee(Ze) === v;
    }
    function ot(Ze) {
      return Ee(Ze) === ae;
    }
    function It(Ze) {
      return Ee(Ze) === se;
    }
    function Et(Ze) {
      return Ee(Ze) === h;
    }
    function Ut(Ze) {
      return Ee(Ze) === A;
    }
    function Bt(Ze) {
      return Ee(Ze) === w;
    }
    function vn(Ze) {
      return Ee(Ze) === q;
    }
    Nn.AsyncMode = re, Nn.ConcurrentMode = ve, Nn.ContextConsumer = Le, Nn.ContextProvider = Qe, Nn.Element = Be, Nn.ForwardRef = Ge, Nn.Fragment = ft, Nn.Lazy = wt, Nn.Memo = st, Nn.Portal = it, Nn.Profiler = Ht, Nn.StrictMode = Mt, Nn.Suspense = an, Nn.isAsyncMode = pt, Nn.isConcurrentMode = ye, Nn.isContextConsumer = je, Nn.isContextProvider = Je, Nn.isElement = kt, Nn.isForwardRef = At, Nn.isFragment = jt, Nn.isLazy = ot, Nn.isMemo = It, Nn.isPortal = Et, Nn.isProfiler = Ut, Nn.isStrictMode = Bt, Nn.isSuspense = vn, Nn.isValidElementType = we, Nn.typeOf = Ee;
  }()), Nn;
}
var KT;
function UR() {
  return KT || (KT = 1, process.env.NODE_ENV === "production" ? Cy.exports = cj() : Cy.exports = dj()), Cy.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Kw, JT;
function fj() {
  if (JT)
    return Kw;
  JT = 1;
  var s = Object.getOwnPropertySymbols, u = Object.prototype.hasOwnProperty, h = Object.prototype.propertyIsEnumerable;
  function v(A) {
    if (A == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(A);
  }
  function w() {
    try {
      if (!Object.assign)
        return !1;
      var A = new String("abc");
      if (A[5] = "de", Object.getOwnPropertyNames(A)[0] === "5")
        return !1;
      for (var T = {}, F = 0; F < 10; F++)
        T["_" + String.fromCharCode(F)] = F;
      var H = Object.getOwnPropertyNames(T).map(function($) {
        return T[$];
      });
      if (H.join("") !== "0123456789")
        return !1;
      var U = {};
      return "abcdefghijklmnopqrst".split("").forEach(function($) {
        U[$] = $;
      }), Object.keys(Object.assign({}, U)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Kw = w() ? Object.assign : function(A, T) {
    for (var F, H = v(A), U, $ = 1; $ < arguments.length; $++) {
      F = Object(arguments[$]);
      for (var q in F)
        u.call(F, q) && (H[q] = F[q]);
      if (s) {
        U = s(F);
        for (var te = 0; te < U.length; te++)
          h.call(F, U[te]) && (H[U[te]] = F[U[te]]);
      }
    }
    return H;
  }, Kw;
}
var Jw, eE;
function hS() {
  if (eE)
    return Jw;
  eE = 1;
  var s = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Jw = s, Jw;
}
var e1, tE;
function BR() {
  return tE || (tE = 1, e1 = Function.call.bind(Object.prototype.hasOwnProperty)), e1;
}
var t1, nE;
function hj() {
  if (nE)
    return t1;
  nE = 1;
  var s = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var u = hS(), h = {}, v = BR();
    s = function(A) {
      var T = "Warning: " + A;
      typeof console < "u" && console.error(T);
      try {
        throw new Error(T);
      } catch {
      }
    };
  }
  function w(A, T, F, H, U) {
    if (process.env.NODE_ENV !== "production") {
      for (var $ in A)
        if (v(A, $)) {
          var q;
          try {
            if (typeof A[$] != "function") {
              var te = Error(
                (H || "React class") + ": " + F + " type `" + $ + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof A[$] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw te.name = "Invariant Violation", te;
            }
            q = A[$](T, $, H, F, null, u);
          } catch (ae) {
            q = ae;
          }
          if (q && !(q instanceof Error) && s(
            (H || "React class") + ": type specification of " + F + " `" + $ + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof q + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), q instanceof Error && !(q.message in h)) {
            h[q.message] = !0;
            var se = U ? U() : "";
            s(
              "Failed " + F + " type: " + q.message + (se ?? "")
            );
          }
        }
    }
  }
  return w.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (h = {});
  }, t1 = w, t1;
}
var n1, rE;
function pj() {
  if (rE)
    return n1;
  rE = 1;
  var s = UR(), u = fj(), h = hS(), v = BR(), w = hj(), A = function() {
  };
  process.env.NODE_ENV !== "production" && (A = function(F) {
    var H = "Warning: " + F;
    typeof console < "u" && console.error(H);
    try {
      throw new Error(H);
    } catch {
    }
  });
  function T() {
    return null;
  }
  return n1 = function(F, H) {
    var U = typeof Symbol == "function" && Symbol.iterator, $ = "@@iterator";
    function q(ye) {
      var je = ye && (U && ye[U] || ye[$]);
      if (typeof je == "function")
        return je;
    }
    var te = "<<anonymous>>", se = {
      array: Ne("array"),
      bigint: Ne("bigint"),
      bool: Ne("boolean"),
      func: Ne("function"),
      number: Ne("number"),
      object: Ne("object"),
      string: Ne("string"),
      symbol: Ne("symbol"),
      any: Q(),
      arrayOf: we,
      element: Ee(),
      elementType: re(),
      instanceOf: ve,
      node: Ge(),
      objectOf: Qe,
      oneOf: Le,
      oneOfType: Be,
      shape: wt,
      exact: st
    };
    function ae(ye, je) {
      return ye === je ? ye !== 0 || 1 / ye === 1 / je : ye !== ye && je !== je;
    }
    function ue(ye, je) {
      this.message = ye, this.data = je && typeof je == "object" ? je : {}, this.stack = "";
    }
    ue.prototype = Error.prototype;
    function Re(ye) {
      if (process.env.NODE_ENV !== "production")
        var je = {}, Je = 0;
      function kt(jt, ot, It, Et, Ut, Bt, vn) {
        if (Et = Et || te, Bt = Bt || It, vn !== h) {
          if (H) {
            var Ze = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw Ze.name = "Invariant Violation", Ze;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var pn = Et + ":" + It;
            !je[pn] && // Avoid spamming the console because they are often not actionable except for lib authors
            Je < 3 && (A(
              "You are manually calling a React.PropTypes validation function for the `" + Bt + "` prop on `" + Et + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), je[pn] = !0, Je++);
          }
        }
        return ot[It] == null ? jt ? ot[It] === null ? new ue("The " + Ut + " `" + Bt + "` is marked as required " + ("in `" + Et + "`, but its value is `null`.")) : new ue("The " + Ut + " `" + Bt + "` is marked as required in " + ("`" + Et + "`, but its value is `undefined`.")) : null : ye(ot, It, Et, Ut, Bt);
      }
      var At = kt.bind(null, !1);
      return At.isRequired = kt.bind(null, !0), At;
    }
    function Ne(ye) {
      function je(Je, kt, At, jt, ot, It) {
        var Et = Je[kt], Ut = Mt(Et);
        if (Ut !== ye) {
          var Bt = an(Et);
          return new ue(
            "Invalid " + jt + " `" + ot + "` of type " + ("`" + Bt + "` supplied to `" + At + "`, expected ") + ("`" + ye + "`."),
            { expectedType: ye }
          );
        }
        return null;
      }
      return Re(je);
    }
    function Q() {
      return Re(T);
    }
    function we(ye) {
      function je(Je, kt, At, jt, ot) {
        if (typeof ye != "function")
          return new ue("Property `" + ot + "` of component `" + At + "` has invalid PropType notation inside arrayOf.");
        var It = Je[kt];
        if (!Array.isArray(It)) {
          var Et = Mt(It);
          return new ue("Invalid " + jt + " `" + ot + "` of type " + ("`" + Et + "` supplied to `" + At + "`, expected an array."));
        }
        for (var Ut = 0; Ut < It.length; Ut++) {
          var Bt = ye(It, Ut, At, jt, ot + "[" + Ut + "]", h);
          if (Bt instanceof Error)
            return Bt;
        }
        return null;
      }
      return Re(je);
    }
    function Ee() {
      function ye(je, Je, kt, At, jt) {
        var ot = je[Je];
        if (!F(ot)) {
          var It = Mt(ot);
          return new ue("Invalid " + At + " `" + jt + "` of type " + ("`" + It + "` supplied to `" + kt + "`, expected a single ReactElement."));
        }
        return null;
      }
      return Re(ye);
    }
    function re() {
      function ye(je, Je, kt, At, jt) {
        var ot = je[Je];
        if (!s.isValidElementType(ot)) {
          var It = Mt(ot);
          return new ue("Invalid " + At + " `" + jt + "` of type " + ("`" + It + "` supplied to `" + kt + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return Re(ye);
    }
    function ve(ye) {
      function je(Je, kt, At, jt, ot) {
        if (!(Je[kt] instanceof ye)) {
          var It = ye.name || te, Et = pt(Je[kt]);
          return new ue("Invalid " + jt + " `" + ot + "` of type " + ("`" + Et + "` supplied to `" + At + "`, expected ") + ("instance of `" + It + "`."));
        }
        return null;
      }
      return Re(je);
    }
    function Le(ye) {
      if (!Array.isArray(ye))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? A(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : A("Invalid argument supplied to oneOf, expected an array.")), T;
      function je(Je, kt, At, jt, ot) {
        for (var It = Je[kt], Et = 0; Et < ye.length; Et++)
          if (ae(It, ye[Et]))
            return null;
        var Ut = JSON.stringify(ye, function(vn, Ze) {
          var pn = an(Ze);
          return pn === "symbol" ? String(Ze) : Ze;
        });
        return new ue("Invalid " + jt + " `" + ot + "` of value `" + String(It) + "` " + ("supplied to `" + At + "`, expected one of " + Ut + "."));
      }
      return Re(je);
    }
    function Qe(ye) {
      function je(Je, kt, At, jt, ot) {
        if (typeof ye != "function")
          return new ue("Property `" + ot + "` of component `" + At + "` has invalid PropType notation inside objectOf.");
        var It = Je[kt], Et = Mt(It);
        if (Et !== "object")
          return new ue("Invalid " + jt + " `" + ot + "` of type " + ("`" + Et + "` supplied to `" + At + "`, expected an object."));
        for (var Ut in It)
          if (v(It, Ut)) {
            var Bt = ye(It, Ut, At, jt, ot + "." + Ut, h);
            if (Bt instanceof Error)
              return Bt;
          }
        return null;
      }
      return Re(je);
    }
    function Be(ye) {
      if (!Array.isArray(ye))
        return process.env.NODE_ENV !== "production" && A("Invalid argument supplied to oneOfType, expected an instance of array."), T;
      for (var je = 0; je < ye.length; je++) {
        var Je = ye[je];
        if (typeof Je != "function")
          return A(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + We(Je) + " at index " + je + "."
          ), T;
      }
      function kt(At, jt, ot, It, Et) {
        for (var Ut = [], Bt = 0; Bt < ye.length; Bt++) {
          var vn = ye[Bt], Ze = vn(At, jt, ot, It, Et, h);
          if (Ze == null)
            return null;
          Ze.data && v(Ze.data, "expectedType") && Ut.push(Ze.data.expectedType);
        }
        var pn = Ut.length > 0 ? ", expected one of type [" + Ut.join(", ") + "]" : "";
        return new ue("Invalid " + It + " `" + Et + "` supplied to " + ("`" + ot + "`" + pn + "."));
      }
      return Re(kt);
    }
    function Ge() {
      function ye(je, Je, kt, At, jt) {
        return it(je[Je]) ? null : new ue("Invalid " + At + " `" + jt + "` supplied to " + ("`" + kt + "`, expected a ReactNode."));
      }
      return Re(ye);
    }
    function ft(ye, je, Je, kt, At) {
      return new ue(
        (ye || "React class") + ": " + je + " type `" + Je + "." + kt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + At + "`."
      );
    }
    function wt(ye) {
      function je(Je, kt, At, jt, ot) {
        var It = Je[kt], Et = Mt(It);
        if (Et !== "object")
          return new ue("Invalid " + jt + " `" + ot + "` of type `" + Et + "` " + ("supplied to `" + At + "`, expected `object`."));
        for (var Ut in ye) {
          var Bt = ye[Ut];
          if (typeof Bt != "function")
            return ft(At, jt, ot, Ut, an(Bt));
          var vn = Bt(It, Ut, At, jt, ot + "." + Ut, h);
          if (vn)
            return vn;
        }
        return null;
      }
      return Re(je);
    }
    function st(ye) {
      function je(Je, kt, At, jt, ot) {
        var It = Je[kt], Et = Mt(It);
        if (Et !== "object")
          return new ue("Invalid " + jt + " `" + ot + "` of type `" + Et + "` " + ("supplied to `" + At + "`, expected `object`."));
        var Ut = u({}, Je[kt], ye);
        for (var Bt in Ut) {
          var vn = ye[Bt];
          if (v(ye, Bt) && typeof vn != "function")
            return ft(At, jt, ot, Bt, an(vn));
          if (!vn)
            return new ue(
              "Invalid " + jt + " `" + ot + "` key `" + Bt + "` supplied to `" + At + "`.\nBad object: " + JSON.stringify(Je[kt], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(ye), null, "  ")
            );
          var Ze = vn(It, Bt, At, jt, ot + "." + Bt, h);
          if (Ze)
            return Ze;
        }
        return null;
      }
      return Re(je);
    }
    function it(ye) {
      switch (typeof ye) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !ye;
        case "object":
          if (Array.isArray(ye))
            return ye.every(it);
          if (ye === null || F(ye))
            return !0;
          var je = q(ye);
          if (je) {
            var Je = je.call(ye), kt;
            if (je !== ye.entries) {
              for (; !(kt = Je.next()).done; )
                if (!it(kt.value))
                  return !1;
            } else
              for (; !(kt = Je.next()).done; ) {
                var At = kt.value;
                if (At && !it(At[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Ht(ye, je) {
      return ye === "symbol" ? !0 : je ? je["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && je instanceof Symbol : !1;
    }
    function Mt(ye) {
      var je = typeof ye;
      return Array.isArray(ye) ? "array" : ye instanceof RegExp ? "object" : Ht(je, ye) ? "symbol" : je;
    }
    function an(ye) {
      if (typeof ye > "u" || ye === null)
        return "" + ye;
      var je = Mt(ye);
      if (je === "object") {
        if (ye instanceof Date)
          return "date";
        if (ye instanceof RegExp)
          return "regexp";
      }
      return je;
    }
    function We(ye) {
      var je = an(ye);
      switch (je) {
        case "array":
        case "object":
          return "an " + je;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + je;
        default:
          return je;
      }
    }
    function pt(ye) {
      return !ye.constructor || !ye.constructor.name ? te : ye.constructor.name;
    }
    return se.checkPropTypes = w, se.resetWarningCache = w.resetWarningCache, se.PropTypes = se, se;
  }, n1;
}
var r1, iE;
function gj() {
  if (iE)
    return r1;
  iE = 1;
  var s = hS();
  function u() {
  }
  function h() {
  }
  return h.resetWarningCache = u, r1 = function() {
    function v(T, F, H, U, $, q) {
      if (q !== s) {
        var te = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw te.name = "Invariant Violation", te;
      }
    }
    v.isRequired = v;
    function w() {
      return v;
    }
    var A = {
      array: v,
      bigint: v,
      bool: v,
      func: v,
      number: v,
      object: v,
      string: v,
      symbol: v,
      any: v,
      arrayOf: w,
      element: v,
      elementType: v,
      instanceOf: w,
      node: v,
      objectOf: w,
      oneOf: w,
      oneOfType: w,
      shape: w,
      exact: w,
      checkPropTypes: h,
      resetWarningCache: u
    };
    return A.PropTypes = A, A;
  }, r1;
}
if (process.env.NODE_ENV !== "production") {
  var vj = UR(), mj = !0;
  L1.exports = pj()(vj.isElement, mj);
} else
  L1.exports = gj()();
var yj = L1.exports, WR;
Object.defineProperty(jR, "__esModule", { value: !0 });
var xj = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(s) {
  return typeof s;
} : function(s) {
  return s && typeof Symbol == "function" && s.constructor === Symbol && s !== Symbol.prototype ? "symbol" : typeof s;
}, bj = Object.assign || function(s) {
  for (var u = 1; u < arguments.length; u++) {
    var h, v = arguments[u];
    for (h in v)
      Object.prototype.hasOwnProperty.call(v, h) && (s[h] = v[h]);
  }
  return s;
}, wj = function() {
  function s(u, h) {
    for (var v = 0; v < h.length; v++) {
      var w = h[v];
      w.enumerable = w.enumerable || !1, w.configurable = !0, "value" in w && (w.writable = !0), Object.defineProperty(u, w.key, w);
    }
  }
  return function(u, h, v) {
    return h && s(u.prototype, h), v && s(u, v), u;
  };
}(), Sj = uj, XR = pS(Sj), VR = vi, ag = pS(VR), kj = yj, wl = pS(kj);
function pS(s) {
  return s && s.__esModule ? s : { default: s };
}
function Cj(s, u, h) {
  return u in s ? Object.defineProperty(s, u, { value: h, enumerable: !0, configurable: !0, writable: !0 }) : s[u] = h, s;
}
function Aj(s, u) {
  var h, v = {};
  for (h in s)
    0 <= u.indexOf(h) || Object.prototype.hasOwnProperty.call(s, h) && (v[h] = s[h]);
  return v;
}
function Tj(s, u) {
  if (!(s instanceof u))
    throw new TypeError("Cannot call a class as a function");
}
function Ej(s, u) {
  if (s)
    return !u || typeof u != "object" && typeof u != "function" ? s : u;
  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
}
function Rj(s, u) {
  if (typeof u != "function" && u !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof u);
  s.prototype = Object.create(u && u.prototype, { constructor: { value: s, enumerable: !1, writable: !0, configurable: !0 } }), u && (Object.setPrototypeOf ? Object.setPrototypeOf(s, u) : s.__proto__ = u);
}
window.ApexCharts = XR.default;
var aE = function() {
  function s(u) {
    Tj(this, s);
    var h = Ej(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, u));
    return ag.default.createRef ? h.chartRef = ag.default.createRef() : h.setRef = function(v) {
      return h.chartRef = v;
    }, h.chart = null, h;
  }
  return Rj(s, VR.Component), wj(s, [{ key: "render", value: function() {
    var u = Aj(this.props, []);
    return ag.default.createElement("div", bj({ ref: ag.default.createRef ? this.chartRef : this.setRef }, u));
  } }, { key: "componentDidMount", value: function() {
    var u = ag.default.createRef ? this.chartRef.current : this.chartRef;
    this.chart = new XR.default(u, this.getConfig()), this.chart.render();
  } }, { key: "getConfig", value: function() {
    var A = this.props, u = A.type, h = A.height, v = A.width, w = A.series, A = A.options;
    return this.extend(A, { chart: { type: u, height: h, width: v }, series: w });
  } }, { key: "isObject", value: function(u) {
    return u && (u === void 0 ? "undefined" : xj(u)) === "object" && !Array.isArray(u) && u != null;
  } }, { key: "extend", value: function(u, h) {
    var v = this, w = (typeof Object.assign != "function" && (Object.assign = function(A) {
      if (A == null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var T = Object(A), F = 1; F < arguments.length; F++) {
        var H = arguments[F];
        if (H != null)
          for (var U in H)
            H.hasOwnProperty(U) && (T[U] = H[U]);
      }
      return T;
    }), Object.assign({}, u));
    return this.isObject(u) && this.isObject(h) && Object.keys(h).forEach(function(A) {
      v.isObject(h[A]) && A in u ? w[A] = v.extend(u[A], h[A]) : Object.assign(w, Cj({}, A, h[A]));
    }), w;
  } }, { key: "componentDidUpdate", value: function(u) {
    if (!this.chart)
      return null;
    var w = this.props, F = w.options, h = w.series, v = w.height, w = w.width, A = JSON.stringify(u.options), T = JSON.stringify(u.series), F = JSON.stringify(F), H = JSON.stringify(h);
    A === F && T === H && v === u.height && w === u.width || (T !== H && A === F && v === u.height && w === u.width ? this.chart.updateSeries(h) : this.chart.updateOptions(this.getConfig()));
  } }, { key: "componentWillUnmount", value: function() {
    this.chart && typeof this.chart.destroy == "function" && this.chart.destroy();
  } }]), s;
}();
(WR = jR.default = aE).propTypes = { type: wl.default.string.isRequired, width: wl.default.oneOfType([wl.default.string, wl.default.number]), height: wl.default.oneOfType([wl.default.string, wl.default.number]), series: wl.default.array.isRequired, options: wl.default.object.isRequired }, aE.defaultProps = { type: "line", width: "100%", height: "auto" };
const Lj = ({
  data: s,
  groupBy: u,
  labels: h,
  groupByFormatter: v = (A) => A,
  hidden: w = []
}) => {
  if ((s == null ? void 0 : s.length) === 0)
    return { series: [], labels: [] };
  const A = [], T = {};
  let F = 0;
  const H = [];
  return Object.keys(s[0]).forEach((U) => {
    w.includes(U) || u === U || (A.push({ name: U, data: [] }), T[U] = F, F++);
  }), s.forEach((U) => {
    Object.entries(U).forEach(([$, q]) => {
      var se, ae;
      if (u === $ && H.push(
        v(q) ?? ""
      ), w.includes($))
        return;
      let te = 0;
      typeof q == "number" && (te = q), (ae = (se = A[T[$]]) == null ? void 0 : se.data) == null || ae.push(te);
    });
  }), console.log({ series: A, labels: H }), { series: A, labels: H ?? h };
}, Mj = ({
  type: s = "bar",
  foreColor: u = "var(--neutral-content)",
  id: h = "any",
  labelFormatter: v = (F) => F,
  dataLabelFormatter: w = (F) => F,
  series: A = [],
  labels: T = []
}) => ({
  options: {
    chart: {
      id: h,
      type: s,
      foreColor: u,
      toolbar: {
        show: !0
      }
    },
    plotOptions: {
      bar: {
        borderRadius: 4,
        borderRadiusApplication: "around"
      }
    },
    colors: ["var(--info)", "var(--info-hover)"],
    grid: {
      show: !1
    },
    legend: {
      position: "top",
      formatter: w
    },
    xaxis: {
      categories: T,
      labels: {
        formatter: v,
        style: {
          colors: ["var(--text-neutral-content)"]
        }
      }
    },
    dataLabels: {
      enabled: !0
      // formatter: dataLabelFormatter,
    },
    tooltip: {
      x: {},
      y: {
        title: {
          formatter: w
        }
      }
    },
    yaxis: {
      show: !1
    }
  },
  series: A ?? []
}), Gj = ({
  data: s,
  labelFormatter: u,
  groupBy: h,
  translation: v = "common",
  type: w = "bar",
  hidden: A = [],
  color: T = "neutral-content"
}) => (uE({ language: "pt-BR" }), /* @__PURE__ */ fe.jsx(
  WR,
  {
    type: w,
    ...Mj({
      type: w,
      labelFormatter: u,
      dataLabelFormatter: (F) => Yr(`${v}.${F}`),
      foreColor: `var(--${T})`,
      id: "any",
      ...Lj({
        data: s,
        groupBy: h,
        hidden: A
      })
    })
  }
));
export {
  Nj as Chart,
  Fj as DateRangePicker,
  Hj as DetailedWorkDay,
  Gj as GenericChart,
  jj as Header,
  KH as Modal,
  Yj as MultiSelect,
  iS as Select,
  Ij as ShowPassword,
  Uj as Sidebar,
  Bj as Table,
  bY as Textfield,
  Vj as changeDesignLanguage,
  aS as debounce,
  Xj as initDesignTranslator,
  HR as useModal,
  tj as useScroll,
  Wj as useToast
};
