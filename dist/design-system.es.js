import mi, { Fragment as uE, useRef as gr, useState as dr, useCallback as Du, useEffect as Hf, useDebugValue as z_ } from "react";
import tr from "moment";
function I_(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var s1 = { exports: {} }, Jp = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ZA;
function F_() {
  if (ZA)
    return Jp;
  ZA = 1;
  var s = mi, u = Symbol.for("react.element"), h = Symbol.for("react.fragment"), v = Object.prototype.hasOwnProperty, w = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, C = { key: !0, ref: !0, __self: !0, __source: !0 };
  function T(F, Y, U) {
    var G, q = {}, te = null, se = null;
    U !== void 0 && (te = "" + U), Y.key !== void 0 && (te = "" + Y.key), Y.ref !== void 0 && (se = Y.ref);
    for (G in Y)
      v.call(Y, G) && !C.hasOwnProperty(G) && (q[G] = Y[G]);
    if (F && F.defaultProps)
      for (G in Y = F.defaultProps, Y)
        q[G] === void 0 && (q[G] = Y[G]);
    return { $$typeof: u, type: F, key: te, ref: se, props: q, _owner: w.current };
  }
  return Jp.Fragment = h, Jp.jsx = T, Jp.jsxs = T, Jp;
}
var eg = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var QA;
function Y_() {
  return QA || (QA = 1, process.env.NODE_ENV !== "production" && function() {
    var s = mi, u = Symbol.for("react.element"), h = Symbol.for("react.portal"), v = Symbol.for("react.fragment"), w = Symbol.for("react.strict_mode"), C = Symbol.for("react.profiler"), T = Symbol.for("react.provider"), F = Symbol.for("react.context"), Y = Symbol.for("react.forward_ref"), U = Symbol.for("react.suspense"), G = Symbol.for("react.suspense_list"), q = Symbol.for("react.memo"), te = Symbol.for("react.lazy"), se = Symbol.for("react.offscreen"), ae = Symbol.iterator, ue = "@@iterator";
    function Ce(le) {
      if (le === null || typeof le != "object")
        return null;
      var Ye = ae && le[ae] || le[ue];
      return typeof Ye == "function" ? Ye : null;
    }
    var Ne = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function K(le) {
      {
        for (var Ye = arguments.length, tt = new Array(Ye > 1 ? Ye - 1 : 0), Dt = 1; Dt < Ye; Dt++)
          tt[Dt - 1] = arguments[Dt];
        we("error", le, tt);
      }
    }
    function we(le, Ye, tt) {
      {
        var Dt = Ne.ReactDebugCurrentFrame, qt = Dt.getStackAddendum();
        qt !== "" && (Ye += "%s", tt = tt.concat([qt]));
        var cn = tt.map(function(Zt) {
          return String(Zt);
        });
        cn.unshift("Warning: " + Ye), Function.prototype.apply.call(console[le], console, cn);
      }
    }
    var Re = !1, re = !1, ve = !1, Me = !1, et = !1, je;
    je = Symbol.for("react.module.reference");
    function Ve(le) {
      return !!(typeof le == "string" || typeof le == "function" || le === v || le === C || et || le === w || le === U || le === G || Me || le === se || Re || re || ve || typeof le == "object" && le !== null && (le.$$typeof === te || le.$$typeof === q || le.$$typeof === T || le.$$typeof === F || le.$$typeof === Y || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      le.$$typeof === je || le.getModuleId !== void 0));
    }
    function it(le, Ye, tt) {
      var Dt = le.displayName;
      if (Dt)
        return Dt;
      var qt = Ye.displayName || Ye.name || "";
      return qt !== "" ? tt + "(" + qt + ")" : tt;
    }
    function dt(le) {
      return le.displayName || "Context";
    }
    function Ke(le) {
      if (le == null)
        return null;
      if (typeof le.tag == "number" && K("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof le == "function")
        return le.displayName || le.name || null;
      if (typeof le == "string")
        return le;
      switch (le) {
        case v:
          return "Fragment";
        case h:
          return "Portal";
        case C:
          return "Profiler";
        case w:
          return "StrictMode";
        case U:
          return "Suspense";
        case G:
          return "SuspenseList";
      }
      if (typeof le == "object")
        switch (le.$$typeof) {
          case F:
            var Ye = le;
            return dt(Ye) + ".Consumer";
          case T:
            var tt = le;
            return dt(tt._context) + ".Provider";
          case Y:
            return it(le, le.render, "ForwardRef");
          case q:
            var Dt = le.displayName || null;
            return Dt !== null ? Dt : Ke(le.type) || "Memo";
          case te: {
            var qt = le, cn = qt._payload, Zt = qt._init;
            try {
              return Ke(Zt(cn));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Ze = Object.assign, Vt = 0, Et, an, We, ft, ye, Ue, Qe;
    function St() {
    }
    St.__reactDisabledLog = !0;
    function kt() {
      {
        if (Vt === 0) {
          Et = console.log, an = console.info, We = console.warn, ft = console.error, ye = console.group, Ue = console.groupCollapsed, Qe = console.groupEnd;
          var le = {
            configurable: !0,
            enumerable: !0,
            value: St,
            writable: !0
          };
          Object.defineProperties(console, {
            info: le,
            log: le,
            warn: le,
            error: le,
            group: le,
            groupCollapsed: le,
            groupEnd: le
          });
        }
        Vt++;
      }
    }
    function Ht() {
      {
        if (Vt--, Vt === 0) {
          var le = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Ze({}, le, {
              value: Et
            }),
            info: Ze({}, le, {
              value: an
            }),
            warn: Ze({}, le, {
              value: We
            }),
            error: Ze({}, le, {
              value: ft
            }),
            group: Ze({}, le, {
              value: ye
            }),
            groupCollapsed: Ze({}, le, {
              value: Ue
            }),
            groupEnd: Ze({}, le, {
              value: Qe
            })
          });
        }
        Vt < 0 && K("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ot = Ne.ReactCurrentDispatcher, It;
    function Rt(le, Ye, tt) {
      {
        if (It === void 0)
          try {
            throw Error();
          } catch (qt) {
            var Dt = qt.stack.trim().match(/\n( *(at )?)/);
            It = Dt && Dt[1] || "";
          }
        return `
` + It + le;
      }
    }
    var jt = !1, Ut;
    {
      var vn = typeof WeakMap == "function" ? WeakMap : Map;
      Ut = new vn();
    }
    function qe(le, Ye) {
      if (!le || jt)
        return "";
      {
        var tt = Ut.get(le);
        if (tt !== void 0)
          return tt;
      }
      var Dt;
      jt = !0;
      var qt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var cn;
      cn = ot.current, ot.current = null, kt();
      try {
        if (Ye) {
          var Zt = function() {
            throw Error();
          };
          if (Object.defineProperty(Zt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Zt, []);
            } catch (o) {
              Dt = o;
            }
            Reflect.construct(le, [], Zt);
          } else {
            try {
              Zt.call();
            } catch (o) {
              Dt = o;
            }
            le.call(Zt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (o) {
            Dt = o;
          }
          le();
        }
      } catch (o) {
        if (o && Dt && typeof o.stack == "string") {
          for (var Ot = o.stack.split(`
`), sr = Dt.stack.split(`
`), Yn = Ot.length - 1, B = sr.length - 1; Yn >= 1 && B >= 0 && Ot[Yn] !== sr[B]; )
            B--;
          for (; Yn >= 1 && B >= 0; Yn--, B--)
            if (Ot[Yn] !== sr[B]) {
              if (Yn !== 1 || B !== 1)
                do
                  if (Yn--, B--, B < 0 || Ot[Yn] !== sr[B]) {
                    var t = `
` + Ot[Yn].replace(" at new ", " at ");
                    return le.displayName && t.includes("<anonymous>") && (t = t.replace("<anonymous>", le.displayName)), typeof le == "function" && Ut.set(le, t), t;
                  }
                while (Yn >= 1 && B >= 0);
              break;
            }
        }
      } finally {
        jt = !1, ot.current = cn, Ht(), Error.prepareStackTrace = qt;
      }
      var n = le ? le.displayName || le.name : "", i = n ? Rt(n) : "";
      return typeof le == "function" && Ut.set(le, i), i;
    }
    function pn(le, Ye, tt) {
      return qe(le, !1);
    }
    function jn(le) {
      var Ye = le.prototype;
      return !!(Ye && Ye.isReactComponent);
    }
    function ir(le, Ye, tt) {
      if (le == null)
        return "";
      if (typeof le == "function")
        return qe(le, jn(le));
      if (typeof le == "string")
        return Rt(le);
      switch (le) {
        case U:
          return Rt("Suspense");
        case G:
          return Rt("SuspenseList");
      }
      if (typeof le == "object")
        switch (le.$$typeof) {
          case Y:
            return pn(le.render);
          case q:
            return ir(le.type, Ye, tt);
          case te: {
            var Dt = le, qt = Dt._payload, cn = Dt._init;
            try {
              return ir(cn(qt), Ye, tt);
            } catch {
            }
          }
        }
      return "";
    }
    var Dr = Object.prototype.hasOwnProperty, Or = {}, ti = Ne.ReactDebugCurrentFrame;
    function Zi(le) {
      if (le) {
        var Ye = le._owner, tt = ir(le.type, le._source, Ye ? Ye.type : null);
        ti.setExtraStackFrame(tt);
      } else
        ti.setExtraStackFrame(null);
    }
    function _a(le, Ye, tt, Dt, qt) {
      {
        var cn = Function.call.bind(Dr);
        for (var Zt in le)
          if (cn(le, Zt)) {
            var Ot = void 0;
            try {
              if (typeof le[Zt] != "function") {
                var sr = Error((Dt || "React class") + ": " + tt + " type `" + Zt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof le[Zt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw sr.name = "Invariant Violation", sr;
              }
              Ot = le[Zt](Ye, Zt, Dt, tt, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Yn) {
              Ot = Yn;
            }
            Ot && !(Ot instanceof Error) && (Zi(qt), K("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Dt || "React class", tt, Zt, typeof Ot), Zi(null)), Ot instanceof Error && !(Ot.message in Or) && (Or[Ot.message] = !0, Zi(qt), K("Failed %s type: %s", tt, Ot.message), Zi(null));
          }
      }
    }
    var da = Array.isArray;
    function Qi(le) {
      return da(le);
    }
    function yi(le) {
      {
        var Ye = typeof Symbol == "function" && Symbol.toStringTag, tt = Ye && le[Symbol.toStringTag] || le.constructor.name || "Object";
        return tt;
      }
    }
    function fa(le) {
      try {
        return xi(le), !1;
      } catch {
        return !0;
      }
    }
    function xi(le) {
      return "" + le;
    }
    function ni(le) {
      if (fa(le))
        return K("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", yi(le)), xi(le);
    }
    var ar = Ne.ReactCurrentOwner, ri = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Pa, Ki, Je;
    Je = {};
    function Lt(le) {
      if (Dr.call(le, "ref")) {
        var Ye = Object.getOwnPropertyDescriptor(le, "ref").get;
        if (Ye && Ye.isReactWarning)
          return !1;
      }
      return le.ref !== void 0;
    }
    function tn(le) {
      if (Dr.call(le, "key")) {
        var Ye = Object.getOwnPropertyDescriptor(le, "key").get;
        if (Ye && Ye.isReactWarning)
          return !1;
      }
      return le.key !== void 0;
    }
    function bn(le, Ye) {
      if (typeof le.ref == "string" && ar.current && Ye && ar.current.stateNode !== Ye) {
        var tt = Ke(ar.current.type);
        Je[tt] || (K('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Ke(ar.current.type), le.ref), Je[tt] = !0);
      }
    }
    function Un(le, Ye) {
      {
        var tt = function() {
          Pa || (Pa = !0, K("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ye));
        };
        tt.isReactWarning = !0, Object.defineProperty(le, "key", {
          get: tt,
          configurable: !0
        });
      }
    }
    function vr(le, Ye) {
      {
        var tt = function() {
          Ki || (Ki = !0, K("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ye));
        };
        tt.isReactWarning = !0, Object.defineProperty(le, "ref", {
          get: tt,
          configurable: !0
        });
      }
    }
    var $n = function(le, Ye, tt, Dt, qt, cn, Zt) {
      var Ot = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: u,
        // Built-in properties that belong on the element
        type: le,
        key: Ye,
        ref: tt,
        props: Zt,
        // Record the component responsible for creating this element.
        _owner: cn
      };
      return Ot._store = {}, Object.defineProperty(Ot._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ot, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Dt
      }), Object.defineProperty(Ot, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: qt
      }), Object.freeze && (Object.freeze(Ot.props), Object.freeze(Ot)), Ot;
    };
    function ii(le, Ye, tt, Dt, qt) {
      {
        var cn, Zt = {}, Ot = null, sr = null;
        tt !== void 0 && (ni(tt), Ot = "" + tt), tn(Ye) && (ni(Ye.key), Ot = "" + Ye.key), Lt(Ye) && (sr = Ye.ref, bn(Ye, qt));
        for (cn in Ye)
          Dr.call(Ye, cn) && !ri.hasOwnProperty(cn) && (Zt[cn] = Ye[cn]);
        if (le && le.defaultProps) {
          var Yn = le.defaultProps;
          for (cn in Yn)
            Zt[cn] === void 0 && (Zt[cn] = Yn[cn]);
        }
        if (Ot || sr) {
          var B = typeof le == "function" ? le.displayName || le.name || "Unknown" : le;
          Ot && Un(Zt, B), sr && vr(Zt, B);
        }
        return $n(le, Ot, sr, qt, Dt, ar.current, Zt);
      }
    }
    var Ln = Ne.ReactCurrentOwner, mr = Ne.ReactDebugCurrentFrame;
    function kn(le) {
      if (le) {
        var Ye = le._owner, tt = ir(le.type, le._source, Ye ? Ye.type : null);
        mr.setExtraStackFrame(tt);
      } else
        mr.setExtraStackFrame(null);
    }
    var Cn;
    Cn = !1;
    function cs(le) {
      return typeof le == "object" && le !== null && le.$$typeof === u;
    }
    function ds() {
      {
        if (Ln.current) {
          var le = Ke(Ln.current.type);
          if (le)
            return `

Check the render method of \`` + le + "`.";
        }
        return "";
      }
    }
    function fs(le) {
      {
        if (le !== void 0) {
          var Ye = le.fileName.replace(/^.*[\\\/]/, ""), tt = le.lineNumber;
          return `

Check your code at ` + Ye + ":" + tt + ".";
        }
        return "";
      }
    }
    var Vs = {};
    function Ml(le) {
      {
        var Ye = ds();
        if (!Ye) {
          var tt = typeof le == "string" ? le : le.displayName || le.name;
          tt && (Ye = `

Check the top-level render call using <` + tt + ">.");
        }
        return Ye;
      }
    }
    function hs(le, Ye) {
      {
        if (!le._store || le._store.validated || le.key != null)
          return;
        le._store.validated = !0;
        var tt = Ml(Ye);
        if (Vs[tt])
          return;
        Vs[tt] = !0;
        var Dt = "";
        le && le._owner && le._owner !== Ln.current && (Dt = " It was passed a child from " + Ke(le._owner.type) + "."), kn(le), K('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', tt, Dt), kn(null);
      }
    }
    function Gs(le, Ye) {
      {
        if (typeof le != "object")
          return;
        if (Qi(le))
          for (var tt = 0; tt < le.length; tt++) {
            var Dt = le[tt];
            cs(Dt) && hs(Dt, Ye);
          }
        else if (cs(le))
          le._store && (le._store.validated = !0);
        else if (le) {
          var qt = Ce(le);
          if (typeof qt == "function" && qt !== le.entries)
            for (var cn = qt.call(le), Zt; !(Zt = cn.next()).done; )
              cs(Zt.value) && hs(Zt.value, Ye);
        }
      }
    }
    function ps(le) {
      {
        var Ye = le.type;
        if (Ye == null || typeof Ye == "string")
          return;
        var tt;
        if (typeof Ye == "function")
          tt = Ye.propTypes;
        else if (typeof Ye == "object" && (Ye.$$typeof === Y || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Ye.$$typeof === q))
          tt = Ye.propTypes;
        else
          return;
        if (tt) {
          var Dt = Ke(Ye);
          _a(tt, le.props, "prop", Dt, le);
        } else if (Ye.PropTypes !== void 0 && !Cn) {
          Cn = !0;
          var qt = Ke(Ye);
          K("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", qt || "Unknown");
        }
        typeof Ye.getDefaultProps == "function" && !Ye.getDefaultProps.isReactClassApproved && K("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function $s(le) {
      {
        for (var Ye = Object.keys(le.props), tt = 0; tt < Ye.length; tt++) {
          var Dt = Ye[tt];
          if (Dt !== "children" && Dt !== "key") {
            kn(le), K("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Dt), kn(null);
            break;
          }
        }
        le.ref !== null && (kn(le), K("Invalid attribute `ref` supplied to `React.Fragment`."), kn(null));
      }
    }
    function Oi(le, Ye, tt, Dt, qt, cn) {
      {
        var Zt = Ve(le);
        if (!Zt) {
          var Ot = "";
          (le === void 0 || typeof le == "object" && le !== null && Object.keys(le).length === 0) && (Ot += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var sr = fs(qt);
          sr ? Ot += sr : Ot += ds();
          var Yn;
          le === null ? Yn = "null" : Qi(le) ? Yn = "array" : le !== void 0 && le.$$typeof === u ? (Yn = "<" + (Ke(le.type) || "Unknown") + " />", Ot = " Did you accidentally export a JSX literal instead of a component?") : Yn = typeof le, K("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Yn, Ot);
        }
        var B = ii(le, Ye, tt, qt, cn);
        if (B == null)
          return B;
        if (Zt) {
          var t = Ye.children;
          if (t !== void 0)
            if (Dt)
              if (Qi(t)) {
                for (var n = 0; n < t.length; n++)
                  Gs(t[n], le);
                Object.freeze && Object.freeze(t);
              } else
                K("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Gs(t, le);
        }
        return le === v ? $s(B) : ps(B), B;
      }
    }
    function Na(le, Ye, tt) {
      return Oi(le, Ye, tt, !0);
    }
    function jr(le, Ye, tt) {
      return Oi(le, Ye, tt, !1);
    }
    var bi = jr, ai = Na;
    eg.Fragment = v, eg.jsx = bi, eg.jsxs = ai;
  }()), eg;
}
process.env.NODE_ENV === "production" ? s1.exports = F_() : s1.exports = Y_();
var de = s1.exports;
const H_ = {
  type: "logger",
  log(s) {
    this.output("log", s);
  },
  warn(s) {
    this.output("warn", s);
  },
  error(s) {
    this.output("error", s);
  },
  output(s, u) {
    console && console[s] && console[s].apply(console, u);
  }
};
class _y {
  constructor(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(u, h);
  }
  init(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = h.prefix || "i18next:", this.logger = u || H_, this.options = h, this.debug = h.debug;
  }
  log() {
    for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
      h[v] = arguments[v];
    return this.forward(h, "log", "", !0);
  }
  warn() {
    for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
      h[v] = arguments[v];
    return this.forward(h, "warn", "", !0);
  }
  error() {
    for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
      h[v] = arguments[v];
    return this.forward(h, "error", "");
  }
  deprecate() {
    for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
      h[v] = arguments[v];
    return this.forward(h, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(u, h, v, w) {
    return w && !this.debug ? null : (typeof u[0] == "string" && (u[0] = `${v}${this.prefix} ${u[0]}`), this.logger[h](u));
  }
  create(u) {
    return new _y(this.logger, {
      prefix: `${this.prefix}:${u}:`,
      ...this.options
    });
  }
  clone(u) {
    return u = u || this.options, u.prefix = u.prefix || this.prefix, new _y(this.logger, u);
  }
}
var Mo = new _y();
class Gy {
  constructor() {
    this.observers = {};
  }
  on(u, h) {
    return u.split(" ").forEach((v) => {
      this.observers[v] = this.observers[v] || [], this.observers[v].push(h);
    }), this;
  }
  off(u, h) {
    if (this.observers[u]) {
      if (!h) {
        delete this.observers[u];
        return;
      }
      this.observers[u] = this.observers[u].filter((v) => v !== h);
    }
  }
  emit(u) {
    for (var h = arguments.length, v = new Array(h > 1 ? h - 1 : 0), w = 1; w < h; w++)
      v[w - 1] = arguments[w];
    this.observers[u] && [].concat(this.observers[u]).forEach((C) => {
      C(...v);
    }), this.observers["*"] && [].concat(this.observers["*"]).forEach((C) => {
      C.apply(C, [u, ...v]);
    });
  }
}
function tg() {
  let s, u;
  const h = new Promise((v, w) => {
    s = v, u = w;
  });
  return h.resolve = s, h.reject = u, h;
}
function KA(s) {
  return s == null ? "" : "" + s;
}
function j_(s, u, h) {
  s.forEach((v) => {
    u[v] && (h[v] = u[v]);
  });
}
function O1(s, u, h) {
  function v(T) {
    return T && T.indexOf("###") > -1 ? T.replace(/###/g, ".") : T;
  }
  function w() {
    return !s || typeof s == "string";
  }
  const C = typeof u != "string" ? [].concat(u) : u.split(".");
  for (; C.length > 1; ) {
    if (w())
      return {};
    const T = v(C.shift());
    !s[T] && h && (s[T] = new h()), Object.prototype.hasOwnProperty.call(s, T) ? s = s[T] : s = {};
  }
  return w() ? {} : {
    obj: s,
    k: v(C.shift())
  };
}
function JA(s, u, h) {
  const {
    obj: v,
    k: w
  } = O1(s, u, Object);
  v[w] = h;
}
function U_(s, u, h, v) {
  const {
    obj: w,
    k: C
  } = O1(s, u, Object);
  w[C] = w[C] || [], v && (w[C] = w[C].concat(h)), v || w[C].push(h);
}
function Py(s, u) {
  const {
    obj: h,
    k: v
  } = O1(s, u);
  if (h)
    return h[v];
}
function B_(s, u, h) {
  const v = Py(s, h);
  return v !== void 0 ? v : Py(u, h);
}
function cE(s, u, h) {
  for (const v in u)
    v !== "__proto__" && v !== "constructor" && (v in s ? typeof s[v] == "string" || s[v] instanceof String || typeof u[v] == "string" || u[v] instanceof String ? h && (s[v] = u[v]) : cE(s[v], u[v], h) : s[v] = u[v]);
  return s;
}
function Of(s) {
  return s.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var W_ = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function X_(s) {
  return typeof s == "string" ? s.replace(/[&<>"'\/]/g, (u) => W_[u]) : s;
}
const V_ = [" ", ",", "?", "!", ";"];
function G_(s, u, h) {
  u = u || "", h = h || "";
  const v = V_.filter((T) => u.indexOf(T) < 0 && h.indexOf(T) < 0);
  if (v.length === 0)
    return !0;
  const w = new RegExp(`(${v.map((T) => T === "?" ? "\\?" : T).join("|")})`);
  let C = !w.test(s);
  if (!C) {
    const T = s.indexOf(h);
    T > 0 && !w.test(s.substring(0, T)) && (C = !0);
  }
  return C;
}
function Ny(s, u) {
  let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!s)
    return;
  if (s[u])
    return s[u];
  const v = u.split(h);
  let w = s;
  for (let C = 0; C < v.length; ++C) {
    if (!w || typeof w[v[C]] == "string" && C + 1 < v.length)
      return;
    if (w[v[C]] === void 0) {
      let T = 2, F = v.slice(C, C + T).join(h), Y = w[F];
      for (; Y === void 0 && v.length > C + T; )
        T++, F = v.slice(C, C + T).join(h), Y = w[F];
      if (Y === void 0)
        return;
      if (Y === null)
        return null;
      if (u.endsWith(F)) {
        if (typeof Y == "string")
          return Y;
        if (F && typeof Y[F] == "string")
          return Y[F];
      }
      const U = v.slice(C + T).join(h);
      return U ? Ny(Y, U, h) : void 0;
    }
    w = w[v[C]];
  }
  return w;
}
function zy(s) {
  return s && s.indexOf("_") > 0 ? s.replace("_", "-") : s;
}
class eT extends Gy {
  constructor(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = u || {}, this.options = h, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(u) {
    this.options.ns.indexOf(u) < 0 && this.options.ns.push(u);
  }
  removeNamespaces(u) {
    const h = this.options.ns.indexOf(u);
    h > -1 && this.options.ns.splice(h, 1);
  }
  getResource(u, h, v) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const C = w.keySeparator !== void 0 ? w.keySeparator : this.options.keySeparator, T = w.ignoreJSONStructure !== void 0 ? w.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let F = [u, h];
    v && typeof v != "string" && (F = F.concat(v)), v && typeof v == "string" && (F = F.concat(C ? v.split(C) : v)), u.indexOf(".") > -1 && (F = u.split("."));
    const Y = Py(this.data, F);
    return Y || !T || typeof v != "string" ? Y : Ny(this.data && this.data[u] && this.data[u][h], v, C);
  }
  addResource(u, h, v, w) {
    let C = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const T = C.keySeparator !== void 0 ? C.keySeparator : this.options.keySeparator;
    let F = [u, h];
    v && (F = F.concat(T ? v.split(T) : v)), u.indexOf(".") > -1 && (F = u.split("."), w = h, h = F[1]), this.addNamespaces(h), JA(this.data, F, w), C.silent || this.emit("added", u, h, v, w);
  }
  addResources(u, h, v) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const C in v)
      (typeof v[C] == "string" || Object.prototype.toString.apply(v[C]) === "[object Array]") && this.addResource(u, h, C, v[C], {
        silent: !0
      });
    w.silent || this.emit("added", u, h, v);
  }
  addResourceBundle(u, h, v, w, C) {
    let T = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: !1
    }, F = [u, h];
    u.indexOf(".") > -1 && (F = u.split("."), w = v, v = h, h = F[1]), this.addNamespaces(h);
    let Y = Py(this.data, F) || {};
    w ? cE(Y, v, C) : Y = {
      ...Y,
      ...v
    }, JA(this.data, F, Y), T.silent || this.emit("added", u, h, v);
  }
  removeResourceBundle(u, h) {
    this.hasResourceBundle(u, h) && delete this.data[u][h], this.removeNamespaces(h), this.emit("removed", u, h);
  }
  hasResourceBundle(u, h) {
    return this.getResource(u, h) !== void 0;
  }
  getResourceBundle(u, h) {
    return h || (h = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? {
      ...this.getResource(u, h)
    } : this.getResource(u, h);
  }
  getDataByLanguage(u) {
    return this.data[u];
  }
  hasLanguageSomeTranslations(u) {
    const h = this.getDataByLanguage(u);
    return !!(h && Object.keys(h) || []).find((v) => h[v] && Object.keys(h[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var dE = {
  processors: {},
  addPostProcessor(s) {
    this.processors[s.name] = s;
  },
  handle(s, u, h, v, w) {
    return s.forEach((C) => {
      this.processors[C] && (u = this.processors[C].process(u, h, v, w));
    }), u;
  }
};
const tT = {};
class Iy extends Gy {
  constructor(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), j_(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], u, this), this.options = h, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = Mo.create("translator");
  }
  changeLanguage(u) {
    u && (this.language = u);
  }
  exists(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (u == null)
      return !1;
    const v = this.resolve(u, h);
    return v && v.res !== void 0;
  }
  extractFromKey(u, h) {
    let v = h.nsSeparator !== void 0 ? h.nsSeparator : this.options.nsSeparator;
    v === void 0 && (v = ":");
    const w = h.keySeparator !== void 0 ? h.keySeparator : this.options.keySeparator;
    let C = h.ns || this.options.defaultNS || [];
    const T = v && u.indexOf(v) > -1, F = !this.options.userDefinedKeySeparator && !h.keySeparator && !this.options.userDefinedNsSeparator && !h.nsSeparator && !G_(u, v, w);
    if (T && !F) {
      const Y = u.match(this.interpolator.nestingRegexp);
      if (Y && Y.length > 0)
        return {
          key: u,
          namespaces: C
        };
      const U = u.split(v);
      (v !== w || v === w && this.options.ns.indexOf(U[0]) > -1) && (C = U.shift()), u = U.join(w);
    }
    return typeof C == "string" && (C = [C]), {
      key: u,
      namespaces: C
    };
  }
  translate(u, h, v) {
    if (typeof h != "object" && this.options.overloadTranslationOptionHandler && (h = this.options.overloadTranslationOptionHandler(arguments)), typeof h == "object" && (h = {
      ...h
    }), h || (h = {}), u == null)
      return "";
    Array.isArray(u) || (u = [String(u)]);
    const w = h.returnDetails !== void 0 ? h.returnDetails : this.options.returnDetails, C = h.keySeparator !== void 0 ? h.keySeparator : this.options.keySeparator, {
      key: T,
      namespaces: F
    } = this.extractFromKey(u[u.length - 1], h), Y = F[F.length - 1], U = h.lng || this.language, G = h.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (U && U.toLowerCase() === "cimode") {
      if (G) {
        const we = h.nsSeparator || this.options.nsSeparator;
        return w ? {
          res: `${Y}${we}${T}`,
          usedKey: T,
          exactUsedKey: T,
          usedLng: U,
          usedNS: Y
        } : `${Y}${we}${T}`;
      }
      return w ? {
        res: T,
        usedKey: T,
        exactUsedKey: T,
        usedLng: U,
        usedNS: Y
      } : T;
    }
    const q = this.resolve(u, h);
    let te = q && q.res;
    const se = q && q.usedKey || T, ae = q && q.exactUsedKey || T, ue = Object.prototype.toString.apply(te), Ce = ["[object Number]", "[object Function]", "[object RegExp]"], Ne = h.joinArrays !== void 0 ? h.joinArrays : this.options.joinArrays, K = !this.i18nFormat || this.i18nFormat.handleAsObject;
    if (K && te && typeof te != "string" && typeof te != "boolean" && typeof te != "number" && Ce.indexOf(ue) < 0 && !(typeof Ne == "string" && ue === "[object Array]")) {
      if (!h.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const we = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(se, te, {
          ...h,
          ns: F
        }) : `key '${T} (${this.language})' returned an object instead of string.`;
        return w ? (q.res = we, q) : we;
      }
      if (C) {
        const we = ue === "[object Array]", Re = we ? [] : {}, re = we ? ae : se;
        for (const ve in te)
          if (Object.prototype.hasOwnProperty.call(te, ve)) {
            const Me = `${re}${C}${ve}`;
            Re[ve] = this.translate(Me, {
              ...h,
              joinArrays: !1,
              ns: F
            }), Re[ve] === Me && (Re[ve] = te[ve]);
          }
        te = Re;
      }
    } else if (K && typeof Ne == "string" && ue === "[object Array]")
      te = te.join(Ne), te && (te = this.extendTranslation(te, u, h, v));
    else {
      let we = !1, Re = !1;
      const re = h.count !== void 0 && typeof h.count != "string", ve = Iy.hasDefaultValue(h), Me = re ? this.pluralResolver.getSuffix(U, h.count, h) : "", et = h.ordinal && re ? this.pluralResolver.getSuffix(U, h.count, {
        ordinal: !1
      }) : "", je = h[`defaultValue${Me}`] || h[`defaultValue${et}`] || h.defaultValue;
      !this.isValidLookup(te) && ve && (we = !0, te = je), this.isValidLookup(te) || (Re = !0, te = T);
      const Ve = (h.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && Re ? void 0 : te, it = ve && je !== te && this.options.updateMissing;
      if (Re || we || it) {
        if (this.logger.log(it ? "updateKey" : "missingKey", U, Y, T, it ? je : te), C) {
          const Vt = this.resolve(T, {
            ...h,
            keySeparator: !1
          });
          Vt && Vt.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let dt = [];
        const Ke = this.languageUtils.getFallbackCodes(this.options.fallbackLng, h.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && Ke && Ke[0])
          for (let Vt = 0; Vt < Ke.length; Vt++)
            dt.push(Ke[Vt]);
        else
          this.options.saveMissingTo === "all" ? dt = this.languageUtils.toResolveHierarchy(h.lng || this.language) : dt.push(h.lng || this.language);
        const Ze = (Vt, Et, an) => {
          const We = ve && an !== te ? an : Ve;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(Vt, Y, Et, We, it, h) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(Vt, Y, Et, We, it, h), this.emit("missingKey", Vt, Y, Et, te);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && re ? dt.forEach((Vt) => {
          this.pluralResolver.getSuffixes(Vt, h).forEach((Et) => {
            Ze([Vt], T + Et, h[`defaultValue${Et}`] || je);
          });
        }) : Ze(dt, T, je));
      }
      te = this.extendTranslation(te, u, h, q, v), Re && te === T && this.options.appendNamespaceToMissingKey && (te = `${Y}:${T}`), (Re || we) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? te = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${Y}:${T}` : T, we ? te : void 0) : te = this.options.parseMissingKeyHandler(te));
    }
    return w ? (q.res = te, q) : te;
  }
  extendTranslation(u, h, v, w, C) {
    var T = this;
    if (this.i18nFormat && this.i18nFormat.parse)
      u = this.i18nFormat.parse(u, {
        ...this.options.interpolation.defaultVariables,
        ...v
      }, v.lng || this.language || w.usedLng, w.usedNS, w.usedKey, {
        resolved: w
      });
    else if (!v.skipInterpolation) {
      v.interpolation && this.interpolator.init({
        ...v,
        interpolation: {
          ...this.options.interpolation,
          ...v.interpolation
        }
      });
      const U = typeof u == "string" && (v && v.interpolation && v.interpolation.skipOnVariables !== void 0 ? v.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let G;
      if (U) {
        const te = u.match(this.interpolator.nestingRegexp);
        G = te && te.length;
      }
      let q = v.replace && typeof v.replace != "string" ? v.replace : v;
      if (this.options.interpolation.defaultVariables && (q = {
        ...this.options.interpolation.defaultVariables,
        ...q
      }), u = this.interpolator.interpolate(u, q, v.lng || this.language, v), U) {
        const te = u.match(this.interpolator.nestingRegexp), se = te && te.length;
        G < se && (v.nest = !1);
      }
      !v.lng && this.options.compatibilityAPI !== "v1" && w && w.res && (v.lng = w.usedLng), v.nest !== !1 && (u = this.interpolator.nest(u, function() {
        for (var te = arguments.length, se = new Array(te), ae = 0; ae < te; ae++)
          se[ae] = arguments[ae];
        return C && C[0] === se[0] && !v.context ? (T.logger.warn(`It seems you are nesting recursively key: ${se[0]} in key: ${h[0]}`), null) : T.translate(...se, h);
      }, v)), v.interpolation && this.interpolator.reset();
    }
    const F = v.postProcess || this.options.postProcess, Y = typeof F == "string" ? [F] : F;
    return u != null && Y && Y.length && v.applyPostProcessor !== !1 && (u = dE.handle(Y, u, h, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: w,
      ...v
    } : v, this)), u;
  }
  resolve(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, v, w, C, T, F;
    return typeof u == "string" && (u = [u]), u.forEach((Y) => {
      if (this.isValidLookup(v))
        return;
      const U = this.extractFromKey(Y, h), G = U.key;
      w = G;
      let q = U.namespaces;
      this.options.fallbackNS && (q = q.concat(this.options.fallbackNS));
      const te = h.count !== void 0 && typeof h.count != "string", se = te && !h.ordinal && h.count === 0 && this.pluralResolver.shouldUseIntlApi(), ae = h.context !== void 0 && (typeof h.context == "string" || typeof h.context == "number") && h.context !== "", ue = h.lngs ? h.lngs : this.languageUtils.toResolveHierarchy(h.lng || this.language, h.fallbackLng);
      q.forEach((Ce) => {
        this.isValidLookup(v) || (F = Ce, !tT[`${ue[0]}-${Ce}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(F) && (tT[`${ue[0]}-${Ce}`] = !0, this.logger.warn(`key "${w}" for languages "${ue.join(", ")}" won't get resolved as namespace "${F}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), ue.forEach((Ne) => {
          if (this.isValidLookup(v))
            return;
          T = Ne;
          const K = [G];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys)
            this.i18nFormat.addLookupKeys(K, G, Ne, Ce, h);
          else {
            let Re;
            te && (Re = this.pluralResolver.getSuffix(Ne, h.count, h));
            const re = `${this.options.pluralSeparator}zero`, ve = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (te && (K.push(G + Re), h.ordinal && Re.indexOf(ve) === 0 && K.push(G + Re.replace(ve, this.options.pluralSeparator)), se && K.push(G + re)), ae) {
              const Me = `${G}${this.options.contextSeparator}${h.context}`;
              K.push(Me), te && (K.push(Me + Re), h.ordinal && Re.indexOf(ve) === 0 && K.push(Me + Re.replace(ve, this.options.pluralSeparator)), se && K.push(Me + re));
            }
          }
          let we;
          for (; we = K.pop(); )
            this.isValidLookup(v) || (C = we, v = this.getResource(Ne, Ce, we, h));
        }));
      });
    }), {
      res: v,
      usedKey: w,
      exactUsedKey: C,
      usedLng: T,
      usedNS: F
    };
  }
  isValidLookup(u) {
    return u !== void 0 && !(!this.options.returnNull && u === null) && !(!this.options.returnEmptyString && u === "");
  }
  getResource(u, h, v) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(u, h, v, w) : this.resourceStore.getResource(u, h, v, w);
  }
  static hasDefaultValue(u) {
    const h = "defaultValue";
    for (const v in u)
      if (Object.prototype.hasOwnProperty.call(u, v) && h === v.substring(0, h.length) && u[v] !== void 0)
        return !0;
    return !1;
  }
}
function Fw(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
class nT {
  constructor(u) {
    this.options = u, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Mo.create("languageUtils");
  }
  getScriptPartFromCode(u) {
    if (u = zy(u), !u || u.indexOf("-") < 0)
      return null;
    const h = u.split("-");
    return h.length === 2 || (h.pop(), h[h.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(h.join("-"));
  }
  getLanguagePartFromCode(u) {
    if (u = zy(u), !u || u.indexOf("-") < 0)
      return u;
    const h = u.split("-");
    return this.formatLanguageCode(h[0]);
  }
  formatLanguageCode(u) {
    if (typeof u == "string" && u.indexOf("-") > -1) {
      const h = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let v = u.split("-");
      return this.options.lowerCaseLng ? v = v.map((w) => w.toLowerCase()) : v.length === 2 ? (v[0] = v[0].toLowerCase(), v[1] = v[1].toUpperCase(), h.indexOf(v[1].toLowerCase()) > -1 && (v[1] = Fw(v[1].toLowerCase()))) : v.length === 3 && (v[0] = v[0].toLowerCase(), v[1].length === 2 && (v[1] = v[1].toUpperCase()), v[0] !== "sgn" && v[2].length === 2 && (v[2] = v[2].toUpperCase()), h.indexOf(v[1].toLowerCase()) > -1 && (v[1] = Fw(v[1].toLowerCase())), h.indexOf(v[2].toLowerCase()) > -1 && (v[2] = Fw(v[2].toLowerCase()))), v.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? u.toLowerCase() : u;
  }
  isSupportedCode(u) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (u = this.getLanguagePartFromCode(u)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(u) > -1;
  }
  getBestMatchFromCodes(u) {
    if (!u)
      return null;
    let h;
    return u.forEach((v) => {
      if (h)
        return;
      const w = this.formatLanguageCode(v);
      (!this.options.supportedLngs || this.isSupportedCode(w)) && (h = w);
    }), !h && this.options.supportedLngs && u.forEach((v) => {
      if (h)
        return;
      const w = this.getLanguagePartFromCode(v);
      if (this.isSupportedCode(w))
        return h = w;
      h = this.options.supportedLngs.find((C) => {
        if (C === w || !(C.indexOf("-") < 0 && w.indexOf("-") < 0) && C.indexOf(w) === 0)
          return C;
      });
    }), h || (h = this.getFallbackCodes(this.options.fallbackLng)[0]), h;
  }
  getFallbackCodes(u, h) {
    if (!u)
      return [];
    if (typeof u == "function" && (u = u(h)), typeof u == "string" && (u = [u]), Object.prototype.toString.apply(u) === "[object Array]")
      return u;
    if (!h)
      return u.default || [];
    let v = u[h];
    return v || (v = u[this.getScriptPartFromCode(h)]), v || (v = u[this.formatLanguageCode(h)]), v || (v = u[this.getLanguagePartFromCode(h)]), v || (v = u.default), v || [];
  }
  toResolveHierarchy(u, h) {
    const v = this.getFallbackCodes(h || this.options.fallbackLng || [], u), w = [], C = (T) => {
      T && (this.isSupportedCode(T) ? w.push(T) : this.logger.warn(`rejecting language code not found in supportedLngs: ${T}`));
    };
    return typeof u == "string" && (u.indexOf("-") > -1 || u.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && C(this.formatLanguageCode(u)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && C(this.getScriptPartFromCode(u)), this.options.load !== "currentOnly" && C(this.getLanguagePartFromCode(u))) : typeof u == "string" && C(this.formatLanguageCode(u)), v.forEach((T) => {
      w.indexOf(T) < 0 && C(this.formatLanguageCode(T));
    }), w;
  }
}
let $_ = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], q_ = {
  1: function(s) {
    return +(s > 1);
  },
  2: function(s) {
    return +(s != 1);
  },
  3: function(s) {
    return 0;
  },
  4: function(s) {
    return s % 10 == 1 && s % 100 != 11 ? 0 : s % 10 >= 2 && s % 10 <= 4 && (s % 100 < 10 || s % 100 >= 20) ? 1 : 2;
  },
  5: function(s) {
    return s == 0 ? 0 : s == 1 ? 1 : s == 2 ? 2 : s % 100 >= 3 && s % 100 <= 10 ? 3 : s % 100 >= 11 ? 4 : 5;
  },
  6: function(s) {
    return s == 1 ? 0 : s >= 2 && s <= 4 ? 1 : 2;
  },
  7: function(s) {
    return s == 1 ? 0 : s % 10 >= 2 && s % 10 <= 4 && (s % 100 < 10 || s % 100 >= 20) ? 1 : 2;
  },
  8: function(s) {
    return s == 1 ? 0 : s == 2 ? 1 : s != 8 && s != 11 ? 2 : 3;
  },
  9: function(s) {
    return +(s >= 2);
  },
  10: function(s) {
    return s == 1 ? 0 : s == 2 ? 1 : s < 7 ? 2 : s < 11 ? 3 : 4;
  },
  11: function(s) {
    return s == 1 || s == 11 ? 0 : s == 2 || s == 12 ? 1 : s > 2 && s < 20 ? 2 : 3;
  },
  12: function(s) {
    return +(s % 10 != 1 || s % 100 == 11);
  },
  13: function(s) {
    return +(s !== 0);
  },
  14: function(s) {
    return s == 1 ? 0 : s == 2 ? 1 : s == 3 ? 2 : 3;
  },
  15: function(s) {
    return s % 10 == 1 && s % 100 != 11 ? 0 : s % 10 >= 2 && (s % 100 < 10 || s % 100 >= 20) ? 1 : 2;
  },
  16: function(s) {
    return s % 10 == 1 && s % 100 != 11 ? 0 : s !== 0 ? 1 : 2;
  },
  17: function(s) {
    return s == 1 || s % 10 == 1 && s % 100 != 11 ? 0 : 1;
  },
  18: function(s) {
    return s == 0 ? 0 : s == 1 ? 1 : 2;
  },
  19: function(s) {
    return s == 1 ? 0 : s == 0 || s % 100 > 1 && s % 100 < 11 ? 1 : s % 100 > 10 && s % 100 < 20 ? 2 : 3;
  },
  20: function(s) {
    return s == 1 ? 0 : s == 0 || s % 100 > 0 && s % 100 < 20 ? 1 : 2;
  },
  21: function(s) {
    return s % 100 == 1 ? 1 : s % 100 == 2 ? 2 : s % 100 == 3 || s % 100 == 4 ? 3 : 0;
  },
  22: function(s) {
    return s == 1 ? 0 : s == 2 ? 1 : (s < 0 || s > 10) && s % 10 == 0 ? 2 : 3;
  }
};
const Z_ = ["v1", "v2", "v3"], Q_ = ["v4"], rT = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function K_() {
  const s = {};
  return $_.forEach((u) => {
    u.lngs.forEach((h) => {
      s[h] = {
        numbers: u.nr,
        plurals: q_[u.fc]
      };
    });
  }), s;
}
class J_ {
  constructor(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = u, this.options = h, this.logger = Mo.create("pluralResolver"), (!this.options.compatibilityJSON || Q_.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = K_();
  }
  addRule(u, h) {
    this.rules[u] = h;
  }
  getRule(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi())
      try {
        return new Intl.PluralRules(zy(u), {
          type: h.ordinal ? "ordinal" : "cardinal"
        });
      } catch {
        return;
      }
    return this.rules[u] || this.rules[this.languageUtils.getLanguagePartFromCode(u)];
  }
  needsPlural(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const v = this.getRule(u, h);
    return this.shouldUseIntlApi() ? v && v.resolvedOptions().pluralCategories.length > 1 : v && v.numbers.length > 1;
  }
  getPluralFormsOfKey(u, h) {
    let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(u, v).map((w) => `${h}${w}`);
  }
  getSuffixes(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const v = this.getRule(u, h);
    return v ? this.shouldUseIntlApi() ? v.resolvedOptions().pluralCategories.sort((w, C) => rT[w] - rT[C]).map((w) => `${this.options.prepend}${h.ordinal ? `ordinal${this.options.prepend}` : ""}${w}`) : v.numbers.map((w) => this.getSuffix(u, w, h)) : [];
  }
  getSuffix(u, h) {
    let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const w = this.getRule(u, v);
    return w ? this.shouldUseIntlApi() ? `${this.options.prepend}${v.ordinal ? `ordinal${this.options.prepend}` : ""}${w.select(h)}` : this.getSuffixRetroCompatible(w, h) : (this.logger.warn(`no plural rule found for: ${u}`), "");
  }
  getSuffixRetroCompatible(u, h) {
    const v = u.noAbs ? u.plurals(h) : u.plurals(Math.abs(h));
    let w = u.numbers[v];
    this.options.simplifyPluralSuffix && u.numbers.length === 2 && u.numbers[0] === 1 && (w === 2 ? w = "plural" : w === 1 && (w = ""));
    const C = () => this.options.prepend && w.toString() ? this.options.prepend + w.toString() : w.toString();
    return this.options.compatibilityJSON === "v1" ? w === 1 ? "" : typeof w == "number" ? `_plural_${w.toString()}` : C() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && u.numbers.length === 2 && u.numbers[0] === 1 ? C() : this.options.prepend && v.toString() ? this.options.prepend + v.toString() : v.toString();
  }
  shouldUseIntlApi() {
    return !Z_.includes(this.options.compatibilityJSON);
  }
}
function iT(s, u, h) {
  let v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", w = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, C = B_(s, u, h);
  return !C && w && typeof h == "string" && (C = Ny(s, h, v), C === void 0 && (C = Ny(u, h, v))), C;
}
class eP {
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Mo.create("interpolator"), this.options = u, this.format = u.interpolation && u.interpolation.format || ((h) => h), this.init(u);
  }
  init() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    u.interpolation || (u.interpolation = {
      escapeValue: !0
    });
    const h = u.interpolation;
    this.escape = h.escape !== void 0 ? h.escape : X_, this.escapeValue = h.escapeValue !== void 0 ? h.escapeValue : !0, this.useRawValueToEscape = h.useRawValueToEscape !== void 0 ? h.useRawValueToEscape : !1, this.prefix = h.prefix ? Of(h.prefix) : h.prefixEscaped || "{{", this.suffix = h.suffix ? Of(h.suffix) : h.suffixEscaped || "}}", this.formatSeparator = h.formatSeparator ? h.formatSeparator : h.formatSeparator || ",", this.unescapePrefix = h.unescapeSuffix ? "" : h.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : h.unescapeSuffix || "", this.nestingPrefix = h.nestingPrefix ? Of(h.nestingPrefix) : h.nestingPrefixEscaped || Of("$t("), this.nestingSuffix = h.nestingSuffix ? Of(h.nestingSuffix) : h.nestingSuffixEscaped || Of(")"), this.nestingOptionsSeparator = h.nestingOptionsSeparator ? h.nestingOptionsSeparator : h.nestingOptionsSeparator || ",", this.maxReplaces = h.maxReplaces ? h.maxReplaces : 1e3, this.alwaysFormat = h.alwaysFormat !== void 0 ? h.alwaysFormat : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const u = `${this.prefix}(.+?)${this.suffix}`;
    this.regexp = new RegExp(u, "g");
    const h = `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`;
    this.regexpUnescape = new RegExp(h, "g");
    const v = `${this.nestingPrefix}(.+?)${this.nestingSuffix}`;
    this.nestingRegexp = new RegExp(v, "g");
  }
  interpolate(u, h, v, w) {
    let C, T, F;
    const Y = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    function U(se) {
      return se.replace(/\$/g, "$$$$");
    }
    const G = (se) => {
      if (se.indexOf(this.formatSeparator) < 0) {
        const Ne = iT(h, Y, se, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(Ne, void 0, v, {
          ...w,
          ...h,
          interpolationkey: se
        }) : Ne;
      }
      const ae = se.split(this.formatSeparator), ue = ae.shift().trim(), Ce = ae.join(this.formatSeparator).trim();
      return this.format(iT(h, Y, ue, this.options.keySeparator, this.options.ignoreJSONStructure), Ce, v, {
        ...w,
        ...h,
        interpolationkey: ue
      });
    };
    this.resetRegExp();
    const q = w && w.missingInterpolationHandler || this.options.missingInterpolationHandler, te = w && w.interpolation && w.interpolation.skipOnVariables !== void 0 ? w.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (se) => U(se)
    }, {
      regex: this.regexp,
      safeValue: (se) => this.escapeValue ? U(this.escape(se)) : U(se)
    }].forEach((se) => {
      for (F = 0; C = se.regex.exec(u); ) {
        const ae = C[1].trim();
        if (T = G(ae), T === void 0)
          if (typeof q == "function") {
            const Ce = q(u, C, w);
            T = typeof Ce == "string" ? Ce : "";
          } else if (w && Object.prototype.hasOwnProperty.call(w, ae))
            T = "";
          else if (te) {
            T = C[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${ae} for interpolating ${u}`), T = "";
        else
          typeof T != "string" && !this.useRawValueToEscape && (T = KA(T));
        const ue = se.safeValue(T);
        if (u = u.replace(C[0], ue), te ? (se.regex.lastIndex += T.length, se.regex.lastIndex -= C[0].length) : se.regex.lastIndex = 0, F++, F >= this.maxReplaces)
          break;
      }
    }), u;
  }
  nest(u, h) {
    let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, w, C, T;
    function F(Y, U) {
      const G = this.nestingOptionsSeparator;
      if (Y.indexOf(G) < 0)
        return Y;
      const q = Y.split(new RegExp(`${G}[ ]*{`));
      let te = `{${q[1]}`;
      Y = q[0], te = this.interpolate(te, T);
      const se = te.match(/'/g), ae = te.match(/"/g);
      (se && se.length % 2 === 0 && !ae || ae.length % 2 !== 0) && (te = te.replace(/'/g, '"'));
      try {
        T = JSON.parse(te), U && (T = {
          ...U,
          ...T
        });
      } catch (ue) {
        return this.logger.warn(`failed parsing options string in nesting for key ${Y}`, ue), `${Y}${G}${te}`;
      }
      return delete T.defaultValue, Y;
    }
    for (; w = this.nestingRegexp.exec(u); ) {
      let Y = [];
      T = {
        ...v
      }, T = T.replace && typeof T.replace != "string" ? T.replace : T, T.applyPostProcessor = !1, delete T.defaultValue;
      let U = !1;
      if (w[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(w[1])) {
        const G = w[1].split(this.formatSeparator).map((q) => q.trim());
        w[1] = G.shift(), Y = G, U = !0;
      }
      if (C = h(F.call(this, w[1].trim(), T), T), C && w[0] === u && typeof C != "string")
        return C;
      typeof C != "string" && (C = KA(C)), C || (this.logger.warn(`missed to resolve ${w[1]} for nesting ${u}`), C = ""), U && (C = Y.reduce((G, q) => this.format(G, q, v.lng, {
        ...v,
        interpolationkey: w[1].trim()
      }), C.trim())), u = u.replace(w[0], C), this.regexp.lastIndex = 0;
    }
    return u;
  }
}
function tP(s) {
  let u = s.toLowerCase().trim();
  const h = {};
  if (s.indexOf("(") > -1) {
    const v = s.split("(");
    u = v[0].toLowerCase().trim();
    const w = v[1].substring(0, v[1].length - 1);
    u === "currency" && w.indexOf(":") < 0 ? h.currency || (h.currency = w.trim()) : u === "relativetime" && w.indexOf(":") < 0 ? h.range || (h.range = w.trim()) : w.split(";").forEach((C) => {
      if (!C)
        return;
      const [T, ...F] = C.split(":"), Y = F.join(":").trim().replace(/^'+|'+$/g, "");
      h[T.trim()] || (h[T.trim()] = Y), Y === "false" && (h[T.trim()] = !1), Y === "true" && (h[T.trim()] = !0), isNaN(Y) || (h[T.trim()] = parseInt(Y, 10));
    });
  }
  return {
    formatName: u,
    formatOptions: h
  };
}
function _f(s) {
  const u = {};
  return function(h, v, w) {
    const C = v + JSON.stringify(w);
    let T = u[C];
    return T || (T = s(zy(v), w), u[C] = T), T(h);
  };
}
class nP {
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Mo.create("formatter"), this.options = u, this.formats = {
      number: _f((h, v) => {
        const w = new Intl.NumberFormat(h, {
          ...v
        });
        return (C) => w.format(C);
      }),
      currency: _f((h, v) => {
        const w = new Intl.NumberFormat(h, {
          ...v,
          style: "currency"
        });
        return (C) => w.format(C);
      }),
      datetime: _f((h, v) => {
        const w = new Intl.DateTimeFormat(h, {
          ...v
        });
        return (C) => w.format(C);
      }),
      relativetime: _f((h, v) => {
        const w = new Intl.RelativeTimeFormat(h, {
          ...v
        });
        return (C) => w.format(C, v.range || "day");
      }),
      list: _f((h, v) => {
        const w = new Intl.ListFormat(h, {
          ...v
        });
        return (C) => w.format(C);
      })
    }, this.init(u);
  }
  init(u) {
    const h = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    }).interpolation;
    this.formatSeparator = h.formatSeparator ? h.formatSeparator : h.formatSeparator || ",";
  }
  add(u, h) {
    this.formats[u.toLowerCase().trim()] = h;
  }
  addCached(u, h) {
    this.formats[u.toLowerCase().trim()] = _f(h);
  }
  format(u, h, v) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return h.split(this.formatSeparator).reduce((C, T) => {
      const {
        formatName: F,
        formatOptions: Y
      } = tP(T);
      if (this.formats[F]) {
        let U = C;
        try {
          const G = w && w.formatParams && w.formatParams[w.interpolationkey] || {}, q = G.locale || G.lng || w.locale || w.lng || v;
          U = this.formats[F](C, q, {
            ...Y,
            ...w,
            ...G
          });
        } catch (G) {
          this.logger.warn(G);
        }
        return U;
      } else
        this.logger.warn(`there was no format function for ${F}`);
      return C;
    }, u);
  }
}
function rP(s, u) {
  s.pending[u] !== void 0 && (delete s.pending[u], s.pendingCount--);
}
class iP extends Gy {
  constructor(u, h, v) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = u, this.store = h, this.services = v, this.languageUtils = v.languageUtils, this.options = w, this.logger = Mo.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = w.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = w.maxRetries >= 0 ? w.maxRetries : 5, this.retryTimeout = w.retryTimeout >= 1 ? w.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(v, w.backend, w);
  }
  queueLoad(u, h, v, w) {
    const C = {}, T = {}, F = {}, Y = {};
    return u.forEach((U) => {
      let G = !0;
      h.forEach((q) => {
        const te = `${U}|${q}`;
        !v.reload && this.store.hasResourceBundle(U, q) ? this.state[te] = 2 : this.state[te] < 0 || (this.state[te] === 1 ? T[te] === void 0 && (T[te] = !0) : (this.state[te] = 1, G = !1, T[te] === void 0 && (T[te] = !0), C[te] === void 0 && (C[te] = !0), Y[q] === void 0 && (Y[q] = !0)));
      }), G || (F[U] = !0);
    }), (Object.keys(C).length || Object.keys(T).length) && this.queue.push({
      pending: T,
      pendingCount: Object.keys(T).length,
      loaded: {},
      errors: [],
      callback: w
    }), {
      toLoad: Object.keys(C),
      pending: Object.keys(T),
      toLoadLanguages: Object.keys(F),
      toLoadNamespaces: Object.keys(Y)
    };
  }
  loaded(u, h, v) {
    const w = u.split("|"), C = w[0], T = w[1];
    h && this.emit("failedLoading", C, T, h), v && this.store.addResourceBundle(C, T, v), this.state[u] = h ? -1 : 2;
    const F = {};
    this.queue.forEach((Y) => {
      U_(Y.loaded, [C], T), rP(Y, u), h && Y.errors.push(h), Y.pendingCount === 0 && !Y.done && (Object.keys(Y.loaded).forEach((U) => {
        F[U] || (F[U] = {});
        const G = Y.loaded[U];
        G.length && G.forEach((q) => {
          F[U][q] === void 0 && (F[U][q] = !0);
        });
      }), Y.done = !0, Y.errors.length ? Y.callback(Y.errors) : Y.callback());
    }), this.emit("loaded", F), this.queue = this.queue.filter((Y) => !Y.done);
  }
  read(u, h, v) {
    let w = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, C = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, T = arguments.length > 5 ? arguments[5] : void 0;
    if (!u.length)
      return T(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: u,
        ns: h,
        fcName: v,
        tried: w,
        wait: C,
        callback: T
      });
      return;
    }
    this.readingCalls++;
    const F = (U, G) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const q = this.waitingReads.shift();
        this.read(q.lng, q.ns, q.fcName, q.tried, q.wait, q.callback);
      }
      if (U && G && w < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, u, h, v, w + 1, C * 2, T);
        }, C);
        return;
      }
      T(U, G);
    }, Y = this.backend[v].bind(this.backend);
    if (Y.length === 2) {
      try {
        const U = Y(u, h);
        U && typeof U.then == "function" ? U.then((G) => F(null, G)).catch(F) : F(null, U);
      } catch (U) {
        F(U);
      }
      return;
    }
    return Y(u, h, F);
  }
  prepareLoading(u, h) {
    let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, w = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), w && w();
    typeof u == "string" && (u = this.languageUtils.toResolveHierarchy(u)), typeof h == "string" && (h = [h]);
    const C = this.queueLoad(u, h, v, w);
    if (!C.toLoad.length)
      return C.pending.length || w(), null;
    C.toLoad.forEach((T) => {
      this.loadOne(T);
    });
  }
  load(u, h, v) {
    this.prepareLoading(u, h, {}, v);
  }
  reload(u, h, v) {
    this.prepareLoading(u, h, {
      reload: !0
    }, v);
  }
  loadOne(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const v = u.split("|"), w = v[0], C = v[1];
    this.read(w, C, "read", void 0, void 0, (T, F) => {
      T && this.logger.warn(`${h}loading namespace ${C} for language ${w} failed`, T), !T && F && this.logger.log(`${h}loaded namespace ${C} for language ${w}`, F), this.loaded(u, T, F);
    });
  }
  saveMissing(u, h, v, w, C) {
    let T = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, F = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(h)) {
      this.logger.warn(`did not save key "${v}" as the namespace "${h}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(v == null || v === "")) {
      if (this.backend && this.backend.create) {
        const Y = {
          ...T,
          isUpdate: C
        }, U = this.backend.create.bind(this.backend);
        if (U.length < 6)
          try {
            let G;
            U.length === 5 ? G = U(u, h, v, w, Y) : G = U(u, h, v, w), G && typeof G.then == "function" ? G.then((q) => F(null, q)).catch(F) : F(null, G);
          } catch (G) {
            F(G);
          }
        else
          U(u, h, v, w, F, Y);
      }
      !u || !u[0] || this.store.addResource(u[0], h, v, w);
    }
  }
}
function aT() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !1,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(s) {
      let u = {};
      if (typeof s[1] == "object" && (u = s[1]), typeof s[1] == "string" && (u.defaultValue = s[1]), typeof s[2] == "string" && (u.tDescription = s[2]), typeof s[2] == "object" || typeof s[3] == "object") {
        const h = s[3] || s[2];
        Object.keys(h).forEach((v) => {
          u[v] = h[v];
        });
      }
      return u;
    },
    interpolation: {
      escapeValue: !0,
      format: (s, u, h, v) => s,
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
function sT(s) {
  return typeof s.ns == "string" && (s.ns = [s.ns]), typeof s.fallbackLng == "string" && (s.fallbackLng = [s.fallbackLng]), typeof s.fallbackNS == "string" && (s.fallbackNS = [s.fallbackNS]), s.supportedLngs && s.supportedLngs.indexOf("cimode") < 0 && (s.supportedLngs = s.supportedLngs.concat(["cimode"])), s;
}
function yy() {
}
function aP(s) {
  Object.getOwnPropertyNames(Object.getPrototypeOf(s)).forEach((u) => {
    typeof s[u] == "function" && (s[u] = s[u].bind(s));
  });
}
class hg extends Gy {
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = sT(u), this.services = {}, this.logger = Mo, this.modules = {
      external: []
    }, aP(this), h && !this.isInitialized && !u.isClone) {
      if (!this.options.initImmediate)
        return this.init(u, h), this;
      setTimeout(() => {
        this.init(u, h);
      }, 0);
    }
  }
  init() {
    var u = this;
    let h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, v = arguments.length > 1 ? arguments[1] : void 0;
    typeof h == "function" && (v = h, h = {}), !h.defaultNS && h.defaultNS !== !1 && h.ns && (typeof h.ns == "string" ? h.defaultNS = h.ns : h.ns.indexOf("translation") < 0 && (h.defaultNS = h.ns[0]));
    const w = aT();
    this.options = {
      ...w,
      ...this.options,
      ...sT(h)
    }, this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
      ...w.interpolation,
      ...this.options.interpolation
    }), h.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = h.keySeparator), h.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = h.nsSeparator);
    function C(Y) {
      return Y ? typeof Y == "function" ? new Y() : Y : null;
    }
    if (!this.options.isClone) {
      this.modules.logger ? Mo.init(C(this.modules.logger), this.options) : Mo.init(null, this.options);
      let Y;
      this.modules.formatter ? Y = this.modules.formatter : typeof Intl < "u" && (Y = nP);
      const U = new nT(this.options);
      this.store = new eT(this.options.resources, this.options);
      const G = this.services;
      G.logger = Mo, G.resourceStore = this.store, G.languageUtils = U, G.pluralResolver = new J_(U, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), Y && (!this.options.interpolation.format || this.options.interpolation.format === w.interpolation.format) && (G.formatter = C(Y), G.formatter.init(G, this.options), this.options.interpolation.format = G.formatter.format.bind(G.formatter)), G.interpolator = new eP(this.options), G.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, G.backendConnector = new iP(C(this.modules.backend), G.resourceStore, G, this.options), G.backendConnector.on("*", function(q) {
        for (var te = arguments.length, se = new Array(te > 1 ? te - 1 : 0), ae = 1; ae < te; ae++)
          se[ae - 1] = arguments[ae];
        u.emit(q, ...se);
      }), this.modules.languageDetector && (G.languageDetector = C(this.modules.languageDetector), G.languageDetector.init && G.languageDetector.init(G, this.options.detection, this.options)), this.modules.i18nFormat && (G.i18nFormat = C(this.modules.i18nFormat), G.i18nFormat.init && G.i18nFormat.init(this)), this.translator = new Iy(this.services, this.options), this.translator.on("*", function(q) {
        for (var te = arguments.length, se = new Array(te > 1 ? te - 1 : 0), ae = 1; ae < te; ae++)
          se[ae - 1] = arguments[ae];
        u.emit(q, ...se);
      }), this.modules.external.forEach((q) => {
        q.init && q.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, v || (v = yy), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const Y = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      Y.length > 0 && Y[0] !== "dev" && (this.options.lng = Y[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((Y) => {
      this[Y] = function() {
        return u.store[Y](...arguments);
      };
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((Y) => {
      this[Y] = function() {
        return u.store[Y](...arguments), u;
      };
    });
    const T = tg(), F = () => {
      const Y = (U, G) => {
        this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), T.resolve(G), v(U, G);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized)
        return Y(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, Y);
    };
    return this.options.resources || !this.options.initImmediate ? F() : setTimeout(F, 0), T;
  }
  loadResources(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : yy;
    const v = typeof u == "string" ? u : this.language;
    if (typeof u == "function" && (h = u), !this.options.resources || this.options.partialBundledLanguages) {
      if (v && v.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0))
        return h();
      const w = [], C = (T) => {
        !T || T === "cimode" || this.services.languageUtils.toResolveHierarchy(T).forEach((F) => {
          F !== "cimode" && w.indexOf(F) < 0 && w.push(F);
        });
      };
      v ? C(v) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((T) => C(T)), this.options.preload && this.options.preload.forEach((T) => C(T)), this.services.backendConnector.load(w, this.options.ns, (T) => {
        !T && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), h(T);
      });
    } else
      h(null);
  }
  reloadResources(u, h, v) {
    const w = tg();
    return u || (u = this.languages), h || (h = this.options.ns), v || (v = yy), this.services.backendConnector.reload(u, h, (C) => {
      w.resolve(), v(C);
    }), w;
  }
  use(u) {
    if (!u)
      throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!u.type)
      throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return u.type === "backend" && (this.modules.backend = u), (u.type === "logger" || u.log && u.warn && u.error) && (this.modules.logger = u), u.type === "languageDetector" && (this.modules.languageDetector = u), u.type === "i18nFormat" && (this.modules.i18nFormat = u), u.type === "postProcessor" && dE.addPostProcessor(u), u.type === "formatter" && (this.modules.formatter = u), u.type === "3rdParty" && this.modules.external.push(u), this;
  }
  setResolvedLanguage(u) {
    if (!(!u || !this.languages) && !(["cimode", "dev"].indexOf(u) > -1))
      for (let h = 0; h < this.languages.length; h++) {
        const v = this.languages[h];
        if (!(["cimode", "dev"].indexOf(v) > -1) && this.store.hasLanguageSomeTranslations(v)) {
          this.resolvedLanguage = v;
          break;
        }
      }
  }
  changeLanguage(u, h) {
    var v = this;
    this.isLanguageChangingTo = u;
    const w = tg();
    this.emit("languageChanging", u);
    const C = (Y) => {
      this.language = Y, this.languages = this.services.languageUtils.toResolveHierarchy(Y), this.resolvedLanguage = void 0, this.setResolvedLanguage(Y);
    }, T = (Y, U) => {
      U ? (C(U), this.translator.changeLanguage(U), this.isLanguageChangingTo = void 0, this.emit("languageChanged", U), this.logger.log("languageChanged", U)) : this.isLanguageChangingTo = void 0, w.resolve(function() {
        return v.t(...arguments);
      }), h && h(Y, function() {
        return v.t(...arguments);
      });
    }, F = (Y) => {
      !u && !Y && this.services.languageDetector && (Y = []);
      const U = typeof Y == "string" ? Y : this.services.languageUtils.getBestMatchFromCodes(Y);
      U && (this.language || C(U), this.translator.language || this.translator.changeLanguage(U), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(U)), this.loadResources(U, (G) => {
        T(G, U);
      });
    };
    return !u && this.services.languageDetector && !this.services.languageDetector.async ? F(this.services.languageDetector.detect()) : !u && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(F) : this.services.languageDetector.detect(F) : F(u), w;
  }
  getFixedT(u, h, v) {
    var w = this;
    const C = function(T, F) {
      let Y;
      if (typeof F != "object") {
        for (var U = arguments.length, G = new Array(U > 2 ? U - 2 : 0), q = 2; q < U; q++)
          G[q - 2] = arguments[q];
        Y = w.options.overloadTranslationOptionHandler([T, F].concat(G));
      } else
        Y = {
          ...F
        };
      Y.lng = Y.lng || C.lng, Y.lngs = Y.lngs || C.lngs, Y.ns = Y.ns || C.ns, Y.keyPrefix = Y.keyPrefix || v || C.keyPrefix;
      const te = w.options.keySeparator || ".";
      let se;
      return Y.keyPrefix && Array.isArray(T) ? se = T.map((ae) => `${Y.keyPrefix}${te}${ae}`) : se = Y.keyPrefix ? `${Y.keyPrefix}${te}${T}` : T, w.t(se, Y);
    };
    return typeof u == "string" ? C.lng = u : C.lngs = u, C.ns = h, C.keyPrefix = v, C;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(u) {
    this.options.defaultNS = u;
  }
  hasLoadedNamespace(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const v = h.lng || this.resolvedLanguage || this.languages[0], w = this.options ? this.options.fallbackLng : !1, C = this.languages[this.languages.length - 1];
    if (v.toLowerCase() === "cimode")
      return !0;
    const T = (F, Y) => {
      const U = this.services.backendConnector.state[`${F}|${Y}`];
      return U === -1 || U === 2;
    };
    if (h.precheck) {
      const F = h.precheck(this, T);
      if (F !== void 0)
        return F;
    }
    return !!(this.hasResourceBundle(v, u) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || T(v, u) && (!w || T(C, u)));
  }
  loadNamespaces(u, h) {
    const v = tg();
    return this.options.ns ? (typeof u == "string" && (u = [u]), u.forEach((w) => {
      this.options.ns.indexOf(w) < 0 && this.options.ns.push(w);
    }), this.loadResources((w) => {
      v.resolve(), h && h(w);
    }), v) : (h && h(), Promise.resolve());
  }
  loadLanguages(u, h) {
    const v = tg();
    typeof u == "string" && (u = [u]);
    const w = this.options.preload || [], C = u.filter((T) => w.indexOf(T) < 0);
    return C.length ? (this.options.preload = w.concat(C), this.loadResources((T) => {
      v.resolve(), h && h(T);
    }), v) : (h && h(), Promise.resolve());
  }
  dir(u) {
    if (u || (u = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !u)
      return "rtl";
    const h = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], v = this.services && this.services.languageUtils || new nT(aT());
    return h.indexOf(v.getLanguagePartFromCode(u)) > -1 || u.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = arguments.length > 1 ? arguments[1] : void 0;
    return new hg(u, h);
  }
  cloneInstance() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : yy;
    const v = u.forkResourceStore;
    v && delete u.forkResourceStore;
    const w = {
      ...this.options,
      ...u,
      isClone: !0
    }, C = new hg(w);
    return (u.debug !== void 0 || u.prefix !== void 0) && (C.logger = C.logger.clone(u)), ["store", "services", "language"].forEach((T) => {
      C[T] = this[T];
    }), C.services = {
      ...this.services
    }, C.services.utils = {
      hasLoadedNamespace: C.hasLoadedNamespace.bind(C)
    }, v && (C.store = new eT(this.store.data, w), C.services.resourceStore = C.store), C.translator = new Iy(C.services, w), C.translator.on("*", function(T) {
      for (var F = arguments.length, Y = new Array(F > 1 ? F - 1 : 0), U = 1; U < F; U++)
        Y[U - 1] = arguments[U];
      C.emit(T, ...Y);
    }), C.init(w, h), C.translator.options = w, C.translator.backendConnector.services.utils = {
      hasLoadedNamespace: C.hasLoadedNamespace.bind(C)
    }, C;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const Di = hg.createInstance();
Di.createInstance = hg.createInstance;
Di.createInstance;
Di.dir;
Di.init;
Di.loadResources;
Di.reloadResources;
Di.use;
const sP = Di.changeLanguage;
Di.getFixedT;
Di.t;
Di.exists;
Di.setDefaultNamespace;
Di.hasLoadedNamespace;
Di.loadNamespaces;
Di.loadLanguages;
const kr = (s, u) => Di.t(s, u), oP = {
  common: {
    ok: "Okay",
    workgroup: "Workgroup",
    "not-found": "Not Found",
    settings: "Settings",
    home: "Home",
    user: "User",
    tenant: "Tenant",
    admin: "Administrator",
    calls: "Calls",
    viewer: "Viewer",
    role: "Role",
    roles: "Roles",
    attempt: "Attempt",
    add: "Add",
    adherence: "Adherence",
    "file-type": "File Type",
    file: "File",
    "contact-right-person": "Contact Right Person",
    error: "Error",
    cancel: "Cancel",
    "real-time": "Real Time",
    back: "Back",
    name: "Name",
    email: "Email",
    group: "Group",
    password: "Password",
    services: "Services",
    visualization: "Visualization",
    table: "Table",
    chart: "Chart",
    continue: "Continue",
    close: "Close",
    save: "Save",
    open: "Open",
    break: "Break",
    breaks: "Breaks",
    edit: "Edit",
    logout: "Log Out",
    new: "New",
    agents: "Agents",
    agent: "Agent",
    users: "Users",
    applications: "Applications",
    general: "General",
    workgroups: "Work Groups",
    scalesgroups: "Scales Group",
    scales: "Scales",
    remove: "Remove",
    company: "Company",
    companies: "Companies",
    database: "Databases",
    theme: "Theme",
    language: "Language",
    search: "Search",
    done: "Done",
    next: "Next",
    previous: "Previous",
    loading: "Loading",
    journey: "Journey",
    action: "Action",
    start: "Start",
    entry: "Entry",
    end: "End",
    finish: "Finish",
    weekdays: "Weekdays",
    weekdaysNames: {
      sunday: "Sunday",
      monday: "Monday",
      tuesday: "Tuesday",
      wednesday: "Wednesday",
      thursday: "Thursday",
      friday: "Friday",
      saturday: "Saturday"
    },
    charts: {
      types: "Chart Types",
      bar: "Bar",
      line: "Line",
      time: "Time"
    }
  },
  complement: {
    add: "Add {{complement}}",
    select: "Select {{complement}}",
    remove: "Remove {{complement}}",
    name: "{{complement}}`s name",
    new: "New {{complement}}",
    edit: "Edit {{complement}}",
    open: "Open {{complement}}",
    close: "Close {{complement}}"
  },
  settings: {
    "application-title": "Select a company and database",
    tabs: {
      personal: "Personal",
      application: "Application"
    },
    themes: {
      coffe: "Coffee",
      light: "Light",
      dark: "Dark",
      forest: "Forest"
    },
    langs: {
      english: "English",
      portuguese: "Portuguese",
      spanish: "Spanish"
    }
  },
  messages: {
    "not-found": "No {{item}} was found",
    typing: "Type your {{item}}...",
    success: "{{item}} {{action}} successfully",
    failed: "{{item}} {{action}} failed"
  },
  table: {
    page: "Page",
    of: "of",
    "per-page": "Per page",
    items: "Items"
  },
  picker: {
    date: {
      days: {
        su: "Su",
        mo: "Mo",
        tu: "Tu",
        we: "We",
        th: "Th",
        fr: "Fr",
        sa: "Sa"
      }
    }
  },
  select: {
    "select-one": "Select one of the options"
  },
  sidebar: {
    general: "General",
    agents: "Agents",
    users: "Users",
    services: "Services",
    calls: "Calls",
    "contact-right-person": "Contact Right Person",
    dashboard: "Dashboard",
    adherence: "Adherence",
    "real-time": "Real Time",
    workgroups: "Workgroups",
    staffing: "Staffing",
    home: "Home",
    scales: "Scales",
    scalesgroups: "Scales Groups",
    forecast: "Forecast"
  },
  actions: {
    create: "create",
    created: "created",
    download: "download",
    downloaded: "downloaded",
    update: "update",
    updated: "updated",
    remove: "remove",
    removed: "removed"
  },
  data: {
    users: {
      firstName: "First Name",
      lastName: "Last Name",
      email: "Email",
      role: "Role",
      active: "Active"
    },
    workgroups: {
      name: "Name",
      agents: "Agents",
      workGroups: "Work Groups",
      timeScale: "Time Scale",
      supervisor: "Supervisor"
    },
    scales: {
      firstName: "First Name",
      lastName: "Last Name",
      baseUserId: "Base User ID"
    },
    scalesgroups: {
      name: "Name",
      timeScale: "Time Scale",
      workGroups: "Work Groups",
      breaks: "Breaks"
    },
    services: {
      attempts: "Attempts",
      hour: "Hour",
      answereds: "Answereds",
      contact_right_person: "Contact Right Person",
      loggeds_agents: "Loggeds Agents",
      average_service_time: "Average Service Time",
      occupancyRate: "Occupancy Rate",
      productivityRate: "Productivity Rate",
      availabilityFee: "Availability Fee",
      averageTimeLoggedIn: "Average Time Logged In",
      averageTimeSpoken: "Average Time Spoken",
      averageIdleTime: "Average Idle Time",
      averageOperatingTime: "Average Operating Time",
      hitRate: "Hit Rate"
    },
    charts: {
      absenteeism: "Absenteeism",
      topAdherenceOffenders: "Top Adherence Offenders",
      mediumWorkGroupsAdherence: "Medium WorkGroups Adherence",
      totalWorkGroupsExtraHours: "Total Work Groups Extra Hours",
      mediumWorkGroupsBreaksTimes: "Medium Work Groups Breaks Times",
      mediumWorkGroupsLoggedTimes: "Medium Work Groups Logged Times"
    },
    "real-time": {
      serviceName: "Service Name",
      serviceId: "Service Id",
      allAgentsLoggeds: "Agents Logged In",
      allAgentsInCall: "Agents in Call",
      allAgentIdle: "Agents Idle",
      allAgentNotReady: "Agents Not Ready",
      allAgentOthers: "Others",
      occupancyRate: "Occupancy Rate",
      inHold: "In Hold",
      inWrap: "In Wrap",
      date: "Date",
      totalCalls: "Total Calls",
      answered: "Answered",
      answeredPercentage: "Answered Percentage",
      notAnswered: "Not Answered",
      notAnsweredPercentage: "Not Answered Percentage",
      busy: "Busy",
      busyPercentage: "Busy Percentage",
      notAttend: "Not Attended",
      notAttendPercentage: "Not Attended Percentage",
      message: "Message",
      messagePercentage: "Message Percentage",
      cpc: "Contact Right Person"
    }
  }
}, lP = {
  common: {
    ok: "Aceptar",
    workgroup: "Grupo de Trabajo",
    "not-found": "No Encontrado",
    settings: "Configuraciones",
    home: "Inicio",
    user: "Usuario",
    tenant: "Inquilino",
    admin: "Administrador",
    calls: "Llamadas",
    viewer: "Visualizador",
    role: "Rol",
    roles: "Roles",
    attempt: "Intento",
    add: "Agregar",
    adherence: "Adhesión",
    "file-type": "Tipo de Archivo",
    file: "Archivo",
    "contact-right-person": "Contactar a la Persona Correcta",
    error: "Error",
    cancel: "Cancelar",
    "real-time": "Tiempo Real",
    back: "Volver",
    name: "Nombre",
    email: "Correo Electrónico",
    group: "Grupo",
    password: "Contraseña",
    services: "Servicios",
    visualization: "Visualización",
    table: "Tabla",
    chart: "Gráfico",
    continue: "Continuar",
    close: "Cerrar",
    save: "Guardar",
    open: "Abrir",
    break: "Descanso",
    breaks: "Descansos",
    edit: "Editar",
    logout: "Cerrar Sesión",
    new: "Nuevo",
    agents: "Agentes",
    agent: "Agente",
    users: "Usuarios",
    applications: "Aplicaciones",
    general: "General",
    workgroups: "Grupos de Trabajo",
    scalesgroups: "Grupo de Escalas",
    scales: "Escalas",
    remove: "Eliminar",
    company: "Empresa",
    companies: "Empresas",
    database: "Bases de Datos",
    theme: "Tema",
    language: "Idioma",
    search: "Buscar",
    done: "Hecho",
    next: "Siguiente",
    previous: "Anterior",
    loading: "Cargando",
    journey: "Trayecto",
    action: "Acción",
    start: "Comenzar",
    entry: "Entrada",
    end: "Fin",
    finish: "Finalizar",
    weekdays: "Días de la Semana",
    weekdaysNames: {
      sunday: "Domingo",
      monday: "Lunes",
      tuesday: "Martes",
      wednesday: "Miércoles",
      thursday: "Jueves",
      friday: "Viernes",
      saturday: "Sábado"
    },
    charts: {
      types: "Tipos de Gráficos",
      bar: "Barra",
      line: "Línea",
      time: "Tiempo"
    }
  },
  complement: {
    add: "Agregar {{complement}}",
    select: "Seleccionar {{complement}}",
    remove: "Eliminar {{complement}}",
    name: "Nombre de {{complement}}",
    new: "Nuevo {{complement}}",
    edit: "Editar {{complement}}",
    open: "Abrir {{complement}}",
    close: "Cerrar {{complement}}"
  },
  settings: {
    "application-title": "Seleccione una empresa y una base de datos",
    tabs: {
      personal: "Personal",
      application: "Aplicación"
    },
    themes: {
      coffe: "Café",
      light: "Claro",
      dark: "Oscuro",
      forest: "Bosque"
    },
    langs: {
      english: "Inglés",
      portuguese: "Portugués",
      spanish: "Español"
    }
  },
  messages: {
    "not-found": "No se encontró {{item}}",
    typing: "Escribe tu {{item}}...",
    success: "{{item}} {{action}} exitosamente",
    failed: "{{item}} {{action}} falló"
  },
  table: {
    page: "Página",
    of: "de",
    "per-page": "Por página",
    items: "Elementos"
  },
  picker: {
    date: {
      days: {
        su: "Do",
        mo: "Lu",
        tu: "Ma",
        we: "Mi",
        th: "Ju",
        fr: "Vi",
        sa: "Sá"
      }
    }
  },
  select: {
    "select-one": "Selecciona una de las opciones"
  },
  sidebar: {
    general: "General",
    agents: "Agentes",
    users: "Usuarios",
    services: "Servicios",
    calls: "Llamadas",
    "contact-right-person": "Contactar a la Persona Correcta",
    dashboard: "Tablero",
    adherence: "Adhesión",
    "real-time": "Tiempo Real",
    workgroups: "Grupos de Trabajo",
    staffing: "Personal",
    home: "Inicio",
    scales: "Escalas",
    scalesgroups: "Grupos de Escalas",
    forecast: "Pronóstico"
  },
  actions: {
    create: "crear",
    created: "creado",
    download: "descargar",
    downloaded: "descargado",
    update: "actualizar",
    updated: "actualizado",
    remove: "eliminar",
    removed: "eliminado"
  },
  data: {
    users: {
      firstName: "Nombre",
      lastName: "Apellido",
      email: "Correo Electrónico",
      role: "Rol",
      active: "Activo"
    },
    workgroups: {
      name: "Nombre",
      agents: "Agentes",
      workGroups: "Grupos de Trabajo",
      timeScale: "Escala de Tiempo",
      supervisor: "Supervisor"
    },
    scales: {
      firstName: "Nombre",
      lastName: "Apellido",
      baseUserId: "ID del Usuario Base"
    },
    scalesgroups: {
      name: "Nombre",
      timeScale: "Escala de Tiempo",
      workGroups: "Grupos de Trabajo",
      breaks: "Descansos"
    },
    services: {
      attempts: "Intentos",
      hour: "Hora",
      answereds: "Atendidas",
      contact_right_person: "Contactar a la Persona Correcta",
      loggeds_agents: "Agentes Registrados",
      average_service_time: "Tiempo Promedio de Servicio",
      occupancyRate: "Tasa de Ocupación",
      productivityRate: "Tasa de Productividad",
      availabilityFee: "Tarifa de Disponibilidad",
      averageTimeLoggedIn: "Tiempo Promedio Conectado",
      averageTimeSpoken: "Tiempo Promedio Hablado",
      averageIdleTime: "Tiempo Promedio de Inactividad",
      averageOperatingTime: "Tiempo Promedio de Operación",
      hitRate: "Tasa de Éxito"
    },
    charts: {
      absenteeism: "Absentismo",
      topAdherenceOffenders: "Principales Infractores de Adhesión",
      mediumWorkGroupsAdherence: "Adhesión Media de Grupos de Trabajo",
      totalWorkGroupsExtraHours: "Total de Horas Extra de Grupos de Trabajo",
      mediumWorkGroupsBreaksTimes: "Tiempos Medios de Descansos de Grupos de Trabajo",
      mediumWorkGroupsLoggedTimes: "Tiempos Medios de Registro de Grupos de Trabajo"
    },
    "real-time": {
      serviceName: "Nombre del Servicio",
      serviceId: "ID del Servicio",
      allAgentsLoggeds: "Agentes Conectados",
      allAgentsInCall: "Agentes en Llamada",
      allAgentIdle: "Agentes Inactivos",
      allAgentNotReady: "Agentes No Listos",
      allAgentOthers: "Otros",
      occupancyRate: "Tasa de Ocupación",
      inHold: "En Espera",
      inWrap: "En Finalización",
      date: "Fecha",
      totalCalls: "Total de Llamadas",
      answered: "Atendidas",
      answeredPercentage: "Porcentaje Atendidas",
      notAnswered: "No Atendidas",
      notAnsweredPercentage: "Porcentaje No Atendidas",
      busy: "Ocupadas",
      busyPercentage: "Porcentaje Ocupadas",
      notAttend: "No Atendidas",
      notAttendPercentage: "Porcentaje No Atendidas",
      message: "Mensaje",
      messagePercentage: "Porcentaje de Mensajes",
      cpc: "Contactar a la Persona Correcta"
    }
  }
}, uP = {
  common: {
    ok: "Ok",
    workgroup: "Grupo de Trabalho",
    "not-found": "Não Encontrado",
    settings: "Configurações",
    home: "Início",
    user: "Usuário",
    tenant: "Inquilino",
    admin: "Administrador",
    calls: "Chamadas",
    viewer: "Visualizador",
    role: "Cargo",
    roles: "Cargos",
    attempt: "Tentativa",
    add: "Adicionar",
    adherence: "Adesão",
    "file-type": "Tipo de Arquivo",
    file: "Arquivo",
    "contact-right-person": "Contatar a Pessoa Certa",
    error: "Erro",
    cancel: "Cancelar",
    "real-time": "Tempo Real",
    back: "Voltar",
    name: "Nome",
    email: "E-mail",
    group: "Grupo",
    password: "Senha",
    services: "Serviços",
    visualization: "Visualização",
    table: "Tabela",
    chart: "Gráfico",
    continue: "Continuar",
    close: "Fechar",
    save: "Salvar",
    open: "Abrir",
    break: "Pausa",
    breaks: "Pausas",
    edit: "Editar",
    logout: "Sair",
    new: "Novo",
    agents: "Agentes",
    agent: "Agente",
    users: "Usuários",
    applications: "Aplicações",
    general: "Geral",
    workgroups: "Grupos de Trabalho",
    scalesgroups: "Grupo de Escalas",
    scales: "Escalas",
    remove: "Remover",
    company: "Empresa",
    companies: "Empresas",
    database: "Banco de Dados",
    theme: "Tema",
    language: "Idioma",
    search: "Pesquisar",
    done: "Concluído",
    next: "Próximo",
    previous: "Anterior",
    loading: "Carregando",
    journey: "Jornada",
    action: "Ação",
    start: "Início",
    entry: "Entrada",
    end: "Fim",
    finish: "Terminar",
    weekdays: "Dias da Semana",
    weekdaysNames: {
      sunday: "Domingo",
      monday: "Segunda-feira",
      tuesday: "Terça-feira",
      wednesday: "Quarta-feira",
      thursday: "Quinta-feira",
      friday: "Sexta-feira",
      saturday: "Sábado"
    },
    charts: {
      types: "Tipos de Gráfico",
      bar: "Barra",
      line: "Linha",
      time: "Tempo"
    }
  },
  complement: {
    add: "Adicionar {{complement}}",
    select: "Selecionar {{complement}}",
    remove: "Remover {{complement}}",
    name: "Nome de {{complement}}",
    new: "Novo {{complement}}",
    edit: "Editar {{complement}}",
    open: "Abrir {{complement}}",
    close: "Fechar {{complement}}"
  },
  settings: {
    "application-title": "Selecione uma empresa e banco de dados",
    tabs: {
      personal: "Pessoal",
      application: "Aplicação"
    },
    themes: {
      coffe: "Café",
      light: "Claro",
      dark: "Escuro",
      forest: "Floresta"
    },
    langs: {
      english: "Inglês",
      portuguese: "Português",
      spanish: "Espanhol"
    }
  },
  messages: {
    "not-found": "Nenhum {{item}} foi encontrado",
    typing: "Digite o seu {{item}}...",
    success: "{{item}} {{action}} realizado com sucesso",
    failed: "{{item}} {{action}} falhou"
  },
  table: {
    page: "Página",
    of: "de",
    "per-page": "Por página",
    items: "Itens"
  },
  picker: {
    date: {
      days: {
        su: "Dom",
        mo: "Seg",
        tu: "Ter",
        we: "Qua",
        th: "Qui",
        fr: "Sex",
        sa: "Sáb"
      }
    }
  },
  select: {
    "select-one": "Selecione uma das opções"
  },
  sidebar: {
    general: "Geral",
    agents: "Agentes",
    users: "Usuários",
    services: "Serviços",
    calls: "Chamadas",
    "contact-right-person": "Contatar a Pessoa Certa",
    dashboard: "Painel",
    adherence: "Adesão",
    "real-time": "Tempo Real",
    workgroups: "Grupos de Trabalho",
    staffing: "Alocação de Pessoal",
    home: "Início",
    scales: "Escalas",
    scalesgroups: "Grupos de Escalas",
    forecast: "Previsão"
  },
  actions: {
    create: "criar",
    created: "criado",
    download: "baixar",
    downloaded: "baixado",
    update: "atualizar",
    updated: "atualizado",
    remove: "remover",
    removed: "removido"
  },
  data: {
    users: {
      firstName: "Primeiro Nome",
      lastName: "Sobrenome",
      email: "E-mail",
      role: "Cargo",
      active: "Ativo"
    },
    workgroups: {
      name: "Nome",
      agents: "Agentes",
      workGroups: "Grupos de Trabalho",
      timeScale: "Escala de Tempo",
      supervisor: "Supervisor"
    },
    scales: {
      firstName: "Primeiro Nome",
      lastName: "Sobrenome",
      baseUserId: "ID do Usuário Base"
    },
    scalesgroups: {
      name: "Nome",
      timeScale: "Escala de Tempo",
      workGroups: "Grupos de Trabalho",
      breaks: "Pausas"
    },
    services: {
      attempts: "Tentativas",
      hour: "Hora",
      answereds: "Atendidas",
      contact_right_person: "Contatar a Pessoa Certa",
      loggeds_agents: "Agentes Registrados",
      average_service_time: "Tempo Médio de Atendimento",
      occupancyRate: "Taxa de Ocupação",
      productivityRate: "Taxa de Produtividade",
      availabilityFee: "Taxa de Disponibilidade",
      averageTimeLoggedIn: "Tempo Médio Logado",
      averageTimeSpoken: "Tempo Médio Falado",
      averageIdleTime: "Tempo Médio de Inatividade",
      averageOperatingTime: "Tempo Médio de Operação",
      hitRate: "Taxa de Acerto"
    },
    charts: {
      absenteeism: "Absenteísmo",
      topAdherenceOffenders: "Principais Infratores de Adesão",
      mediumWorkGroupsAdherence: "Adesão Média dos Grupos de Trabalho",
      totalWorkGroupsExtraHours: "Total de Horas Extras dos Grupos de Trabalho",
      mediumWorkGroupsBreaksTimes: "Tempo Médio de Pausas dos Grupos de Trabalho",
      mediumWorkGroupsLoggedTimes: "Tempo Médio Logado dos Grupos de Trabalho"
    },
    "real-time": {
      serviceName: "Nome do Serviço",
      serviceId: "ID do Serviço",
      allAgentsLoggeds: "Agentes Logados",
      allAgentsInCall: "Agentes em Chamada",
      allAgentIdle: "Agentes Inativos",
      allAgentNotReady: "Agentes Não Prontos",
      allAgentOthers: "Outros",
      occupancyRate: "Taxa de Ocupação",
      inHold: "Em Espera",
      inWrap: "Em Finalização",
      date: "Data",
      totalCalls: "Total de Chamadas",
      answered: "Atendidas",
      answeredPercentage: "Percentual Atendido",
      notAnswered: "Não Atendidas",
      notAnsweredPercentage: "Percentual Não Atendido",
      busy: "Ocupadas",
      busyPercentage: "Percentual Ocupado",
      notAttend: "Não Atendidas",
      notAttendPercentage: "Percentual Não Atendido",
      message: "Mensagem",
      messagePercentage: "Percentual de Mensagens",
      cpc: "Contatar a Pessoa Certa"
    }
  }
}, fE = ({ language: s = "en" }) => {
  Di.init({
    lng: s,
    fallbackLng: "en",
    resources: {
      en: { translation: oP },
      "pt-BR": { translation: uP },
      es: { translation: lP }
    }
  });
}, cP = (s) => {
  sP(s);
}, dP = (s, u, h, v, w, C) => {
  u = u - 16;
  const T = u / v, F = [];
  return Object.values(s).forEach((Y) => {
    let U = "";
    Y.forEach((G, q) => {
      q === 0 && (C ? U += `M-4,${u + 50}L-4,${u - G * T}` : U += `M0,${u - G * T}`), q > 0 && (U += `L${w * q},${u - G * T}`), q === Y.length - 1 && (U += `L${h + 4},${u + 50}`);
    }), F.push(U);
  }), F;
}, fP = ({
  data: s,
  width: u,
  height: h,
  filled: v = !1,
  tooltipRef: w,
  translation: C,
  maxItemValue: T,
  lineRef: F
}) => {
  if (u === 0 || h === 0 || s.length === 0)
    return null;
  const Y = Object.keys(s[0]).length, U = u / (s.length - 1) + 1, G = s.reduce(
    (te, se) => (Object.entries(se).forEach(
      ([ae, ue]) => {
        te != null && te[ae] ? te[ae].push(ue) : te[ae] = [ue];
      }
    ), te),
    {}
  ), q = dP(
    G,
    h,
    u,
    T,
    U,
    v
  );
  return /* @__PURE__ */ de.jsx(de.Fragment, { children: q == null ? void 0 : q.map((te, se) => /* @__PURE__ */ de.jsxs("g", { children: [
    /* @__PURE__ */ de.jsx(
      "path",
      {
        className: v ? "filled" : "",
        d: te,
        strokeWidth: "3",
        fill: v ? "currentColor" : "none",
        strokeLinejoin: "round",
        strokeLinecap: "round",
        onMouseMove: (ae) => {
          const ue = ae.clientX;
          if (F.current) {
            const Ce = F.current.parentNode.getBoundingClientRect().left, K = Array.from({ length: Y }).map(
              (Re, re) => U * re
            ).map(
              (Re) => Math.abs(ue - Ce - Re)
            ), we = K.indexOf(
              Math.min(...K)
            );
            if (w.current) {
              const Re = Object.entries(
                s[we] ?? []
              ).reduce((re, ve) => (re += `<span>${kr(
                `data.${C}.${ve[0]}`
              )}: ${ve[1]}</span>`, re), "");
              w.current.innerHTML = `
                       ${Re}
                    `;
            }
          }
        }
      }
    ),
    v && /* @__PURE__ */ de.jsxs("linearGradient", { id: `lgrad-${se}`, gradientTransform: "rotate(90)", children: [
      /* @__PURE__ */ de.jsx("stop", { offset: "0%", stopColor: "#4169e1" }),
      /* @__PURE__ */ de.jsx("stop", { offset: "75%", stopColor: "#c44764" })
    ] })
  ] }, se)) });
}, hP = ({
  label: s,
  onMouseEnter: u,
  x: h,
  y: v,
  height: w,
  width: C,
  ...T
}) => {
  if (T.value === 0)
    return null;
  const F = String(T.value).length * 4, Y = C / 2 - F;
  return /* @__PURE__ */ de.jsxs(
    "g",
    {
      onMouseEnter: () => u == null ? void 0 : u({
        label: s,
        value: Number(T.value)
      }),
      onMouseMove: (U) => {
        var G;
        return (G = T.onMouseMove) == null ? void 0 : G.call(T, { x: U.clientX, y: U.clientY });
      },
      children: [
        /* @__PURE__ */ de.jsx("text", { x: h + Y, y: v - 5, children: T.value }),
        /* @__PURE__ */ de.jsx("rect", { x: h, y: v, height: w, width: C, rx: 4 })
      ]
    }
  );
}, pP = ({
  width: s,
  height: u,
  data: h,
  showOnly: v,
  tooltipRef: w,
  groupBy: C,
  translation: T,
  maxItemValue: F
}) => {
  if (console.log(h), s === 0 || u === 0 || h.length === 0)
    return null;
  v && (h = h.map((q) => ({
    [C]: q[C],
    [v]: q[v]
  })));
  const Y = Object.keys(h[0]).length;
  let U = 24, G = (s - U * (h.length - 1)) / h.length;
  return v ? U = 24 : (U = 0, G = (s - U * (h.length - 1) * (Y - 1)) / h.length / Y), console.log(h, G, Y), /* @__PURE__ */ de.jsx(de.Fragment, { children: h.map((q, te) => {
    const se = (u - 40) / F, ae = { ...q };
    delete ae[C];
    let ue = 1, Ne = te * ue * Y * ((G + U) / (Y - 1)), K = te > 0 ? Ne / 2 : Ne;
    K += String(q[C]).length * 6;
    const we = (G + U) * Y;
    let Re = 0;
    if (!v) {
      const re = (s - U * (h.length - 1)) / h.length;
      K = re * te + re / 2 - String(q[C]).length * 8;
    }
    return console.log(kr("data.workgroups.name")), /* @__PURE__ */ de.jsxs("g", { children: [
      Object.entries(ae).map(([re, ve]) => {
        const Me = Re;
        if (ve === 0)
          return null;
        Ne = Me * Y * ((G + U * (Y - 1)) / (Y - 1)), Ne = Ne + te * we, v && (Ne /= 2);
        const je = Number(ve) * se;
        return ue += 1, Re += 1, /* @__PURE__ */ de.jsx(
          hP,
          {
            x: Ne + 16,
            value: Number(ve),
            y: u - 20 - je,
            onMouseEnter: ({ label: Ve, value: it }) => {
              w.current && (w.current.innerHTML = `
                         <span>${Ve}: ${it}</span>
                    `);
            },
            itemIndex: te,
            width: G,
            height: je,
            label: kr(
              `data.${T}.${re}`
            )
          },
          `${re}-${te}`
        );
      }),
      /* @__PURE__ */ de.jsx(
        "text",
        {
          y: u - 4,
          x: K + (G - U - G * (Y - 3) - String(q[C]).length * 8) / 2 + 16,
          children: q[C]
        }
      )
    ] }, te);
  }) });
}, gP = ({
  tooltipRef: s,
  width: u,
  maxDate: h,
  minDate: v,
  labels: w,
  spacing: C,
  iteration: T,
  rectHeight: F,
  proportion: Y,
  theme: U,
  items: G,
  translation: q
}) => {
  const te = gr(null);
  return /* @__PURE__ */ de.jsxs(
    "g",
    {
      onMouseMove: (se) => {
        if (se.target === te.current && s.current) {
          const ue = se.nativeEvent.offsetX / u * h.diff(v), Ce = v.clone().add(ue, "milliseconds"), K = h.diff(v) / 3600 / 1e3 > 24 ? "YYYY-MM-DD HH:mm:ss" : "HH:mm:ss";
          s.current.innerHTML = `
              ${Ce.format(K)}
          `;
        }
      },
      children: [
        (w == null ? void 0 : w.length) && (w == null ? void 0 : w.length) > 0 && /* @__PURE__ */ de.jsx(
          "text",
          {
            x: C / 2 - w[T].length * 4,
            y: F / 2 + F * T + 4 + 20,
            children: w[T]
          }
        ),
        /* @__PURE__ */ de.jsx(
          "rect",
          {
            rx: 4,
            x: C,
            y: F * T + 20,
            ref: te,
            width: h.diff(v) * Y,
            height: F,
            className: U == null ? void 0 : U.period
          }
        ),
        Object.values(G).map(
          (se, ae) => se.map((ue, Ce) => {
            if (Object.keys(G)[ae] === "period")
              return null;
            const Ne = ue.start.diff(v) * Y, K = ue.finish.diff(ue.start), we = K * Y, Re = Object.keys(G)[ae];
            let re = K / 3600 / 1e3 < 1 ? tr.utc(K).format("mm[m]") : tr.utc(K).format("HH[h]mm");
            re = re.substring(re.length - 2, re.length) === "00" ? re.substring(0, re.length - 2) : re;
            const ve = (re.length + 0.5) * 4;
            return /* @__PURE__ */ de.jsxs(
              "g",
              {
                y: 20,
                onMouseMove: (Me) => {
                  const je = Me.nativeEvent.offsetX / u * h.diff(v), Ve = v.clone().add(je, "milliseconds"), dt = h.diff(v) / 3600 / 1e3 > 24 ? "YYYY-MM-DD HH:mm:ss" : "HH:mm:ss";
                  s.current && (s.current.innerHTML = `
                  <span>${q(Re)}</span>
                  <span>
                  ${Ve.format(dt)} |
                    ${tr.utc(ue.start).format("HH[h]mm")} -
                    ${tr.utc(ue.finish).format("HH[h]mm")}
                  </span>
                  <span>
                    Escalado: ${tr.utc(ue == null ? void 0 : ue.scaled).format("HH[h]mm")}
                  </span>
                  <span>
                    Duração: ${re}
                 </span>
              `);
                },
                children: [
                  /* @__PURE__ */ de.jsx(
                    "rect",
                    {
                      className: (U == null ? void 0 : U[Object.keys(G)[ae]]) ?? "fill-text-disabled",
                      width: we,
                      rx: 4,
                      x: Ne + C,
                      height: F,
                      y: F * T + 20,
                      fill: "currentColor"
                    }
                  ),
                  ve < we / 2 && /* @__PURE__ */ de.jsx(
                    "text",
                    {
                      x: Ne + we / 2 - ve + C,
                      y: F * T + F / 2 + 26,
                      children: re
                    }
                  )
                ]
              },
              Ce
            );
          })
        )
      ]
    }
  );
}, vP = ({
  data: s,
  width: u,
  height: h,
  labels: v,
  tooltipRef: w,
  translation: C,
  theme: T
}) => {
  if (u === 0 || h === 0 || s.length === 0)
    return null;
  const F = v != null && v.length && (v == null ? void 0 : v.length) > 0 ? 80 : 0;
  u = u - F, h = h - 20;
  const Y = h / s.length;
  let U = tr(), G = tr();
  s.forEach((ue) => {
    Object.values(ue).forEach((Ce) => {
      Ce.forEach((Ne) => {
        U = tr.min(U, Ne.start), G = tr.max(G, Ne.finish);
      });
    });
  });
  const q = G.diff(U), te = u / q, se = tr.duration(q, "milliseconds").hours(), ae = u / se / 4;
  return /* @__PURE__ */ de.jsxs(de.Fragment, { children: [
    s.map((ue, Ce) => /* @__PURE__ */ de.jsx(uE, { children: /* @__PURE__ */ de.jsx(
      gP,
      {
        width: u + F,
        labels: v,
        items: ue,
        maxDate: G,
        minDate: U,
        spacing: F,
        iteration: Ce,
        proportion: te,
        rectHeight: Y,
        translation: C,
        tooltipRef: w,
        theme: T
      }
    ) }, Ce)),
    Array.from({ length: se * 4 }).map((ue, Ce) => /* @__PURE__ */ de.jsx("g", { className: "interval", children: /* @__PURE__ */ de.jsx(
      "line",
      {
        x1: ae * Ce + 80,
        x2: ae * Ce + 80,
        y1: 20,
        y2: h + 20
      }
    ) }, Ce)),
    Array.from({ length: se + 1 }).map((ue, Ce) => {
      const Ne = tr.utc(U).hours() + Ce;
      return /* @__PURE__ */ de.jsxs(
        "text",
        {
          x: ae * 4 * Ce + F - String(Ne).length * 8,
          y: 12,
          fill: "#fff",
          children: [
            Ne,
            "h"
          ]
        },
        Ce
      );
    })
  ] });
};
function mP(s, u = 300) {
  let h;
  return function(...v) {
    clearTimeout(h), h = setTimeout(() => {
      s.apply(this, v);
    }, u);
  };
}
const Yw = (s, u, h, v = !1) => {
  var T, F, Y, U;
  const w = s.clientWidth, C = s.clientHeight;
  if ((T = u.current) == null || T.setAttribute("viewBox", `0 0 ${w} ${C}`), (F = u.current) == null || F.setAttribute("width", String(w)), !v) {
    (Y = u.current) == null || Y.setAttribute("height", String(C)), h({
      height: C,
      width: w
    });
    return;
  }
  (U = u.current) == null || U.setAttribute("height", String(C)), h((G) => ({
    ...G,
    width: w
  }));
}, yP = ({
  type: s,
  width: u,
  height: h,
  hide: v,
  data: w,
  children: C,
  translation: T = "workgroups",
  snap: F = !1
}) => {
  const Y = gr(null), [U, G] = dr({
    width: u !== void 0 ? u - 32 : 0,
    height: h ?? 0
  }), q = gr(null), te = gr(null), se = Du(() => v ? [...w].filter((ue) => (v.forEach((Ce) => delete ue[Ce]), ue)) : w, [v, w]);
  console.log(U), Hf(() => {
    var Ce;
    const ue = (Ce = Y == null ? void 0 : Y.current) == null ? void 0 : Ce.parentNode;
    return window == null || window.addEventListener(
      "resize",
      mP(
        () => Yw(ue, Y, G, h !== void 0)
      )
    ), (!u || !h) && Yw(ue, Y, G, h !== void 0), () => ue == null ? void 0 : ue.removeEventListener(
      "resize",
      () => Yw(ue, Y, () => {
      }, h !== void 0)
    );
  }, [G, u, h]);
  const ae = Math.max(
    ...se().map((ue) => {
      const Ce = Object.values(ue).filter(
        (Ne) => typeof Ne == "number"
      );
      return Math.max(...Ce);
    })
  );
  return /* @__PURE__ */ de.jsxs(de.Fragment, { children: [
    /* @__PURE__ */ de.jsx(
      "div",
      {
        ref: q,
        className: "chart-tooltip container rounded-box bg-neutral shadow-md gap-sm"
      }
    ),
    /* @__PURE__ */ de.jsxs(
      "svg",
      {
        ref: Y,
        className: `chart ${s}`,
        viewBox: `0 0 ${u ?? 0} ${h ?? 0}`,
        width: U.width,
        height: U.height,
        onMouseMove: (ue) => {
          if (te.current && Y.current && q.current) {
            const Ce = te.current.style, Ne = ue.clientX, K = Y.current.getBoundingClientRect().left, we = Y.current.getBoundingClientRect().top;
            if (Ce.opacity = "1", F) {
              const et = U.width / (w.length * 4), je = Array.from({
                length: w.length
              }).map((dt, Ke) => Math.abs(
                Ne - K - et * Ke - U.width / w.length * Ke
              )), Ve = je.indexOf(
                Math.min(...je)
              ), it = U.width / w.length * Ve + et * Ve;
              Ce.transform = `translate(${it}px, 0px)`;
            } else
              Ce.transform = `translate(${ue.clientX - K}px, 0px)`, Ce.transition = "none";
            if (q.current.innerHTML === "") {
              q.current.style.opacity = "0";
              return;
            }
            const Re = ue.clientX - K, re = q.current.clientWidth;
            q.current.style.opacity = "1";
            let ve = Re + 20;
            const Me = ue.clientY - we + 20;
            q.current.offsetLeft + Re + re + 20 > window.innerWidth && (ve = Re - re - 20), q.current.style.transform = `translate(${ve}px, ${Me}px)`;
          }
        },
        onMouseLeave: () => {
          q.current && te.current && (q.current.innerHTML = "", q.current.style.opacity = "0", te.current.style.opacity = "0");
        },
        children: [
          C({
            currentSize: U,
            tooltipRef: q,
            data: se(),
            maxItemValue: ae,
            lineRef: te,
            translation: T
          }),
          /* @__PURE__ */ de.jsx(
            "line",
            {
              ref: te,
              x1: "0",
              y1: "0",
              x2: "0",
              y2: h,
              strokeDasharray: 8,
              style: { stroke: "#ded", strokeWidth: "2px" }
            }
          )
        ]
      }
    )
  ] });
}, jj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bar: pP,
  Line: fP,
  Time: vP,
  default: yP
}, Symbol.toStringTag, { value: "Module" }));
var Ou = mi;
const og = /^[a-z0-9]+(-[a-z0-9]+)*$/, $y = (s, u, h, v = "") => {
  const w = s.split(":");
  if (s.slice(0, 1) === "@") {
    if (w.length < 2 || w.length > 3)
      return null;
    v = w.shift().slice(1);
  }
  if (w.length > 3 || !w.length)
    return null;
  if (w.length > 1) {
    const F = w.pop(), Y = w.pop(), U = {
      // Allow provider without '@': "provider:prefix:name"
      provider: w.length > 0 ? w[0] : v,
      prefix: Y,
      name: F
    };
    return u && !Ty(U) ? null : U;
  }
  const C = w[0], T = C.split("-");
  if (T.length > 1) {
    const F = {
      provider: v,
      prefix: T.shift(),
      name: T.join("-")
    };
    return u && !Ty(F) ? null : F;
  }
  if (h && v === "") {
    const F = {
      provider: v,
      prefix: "",
      name: C
    };
    return u && !Ty(F, h) ? null : F;
  }
  return null;
}, Ty = (s, u) => s ? !!((s.provider === "" || s.provider.match(og)) && (u && s.prefix === "" || s.prefix.match(og)) && s.name.match(og)) : !1, hE = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), Fy = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), _1 = Object.freeze({
  ...hE,
  ...Fy
}), o1 = Object.freeze({
  ..._1,
  body: "",
  hidden: !1
});
function xP(s, u) {
  const h = {};
  !s.hFlip != !u.hFlip && (h.hFlip = !0), !s.vFlip != !u.vFlip && (h.vFlip = !0);
  const v = ((s.rotate || 0) + (u.rotate || 0)) % 4;
  return v && (h.rotate = v), h;
}
function oT(s, u) {
  const h = xP(s, u);
  for (const v in o1)
    v in Fy ? v in s && !(v in h) && (h[v] = Fy[v]) : v in u ? h[v] = u[v] : v in s && (h[v] = s[v]);
  return h;
}
function bP(s, u) {
  const h = s.icons, v = s.aliases || /* @__PURE__ */ Object.create(null), w = /* @__PURE__ */ Object.create(null);
  function C(T) {
    if (h[T])
      return w[T] = [];
    if (!(T in w)) {
      w[T] = null;
      const F = v[T] && v[T].parent, Y = F && C(F);
      Y && (w[T] = [F].concat(Y));
    }
    return w[T];
  }
  return (u || Object.keys(h).concat(Object.keys(v))).forEach(C), w;
}
function wP(s, u, h) {
  const v = s.icons, w = s.aliases || /* @__PURE__ */ Object.create(null);
  let C = {};
  function T(F) {
    C = oT(
      v[F] || w[F],
      C
    );
  }
  return T(u), h.forEach(T), oT(s, C);
}
function pE(s, u) {
  const h = [];
  if (typeof s != "object" || typeof s.icons != "object")
    return h;
  s.not_found instanceof Array && s.not_found.forEach((w) => {
    u(w, null), h.push(w);
  });
  const v = bP(s);
  for (const w in v) {
    const C = v[w];
    C && (u(w, wP(s, w, C)), h.push(w));
  }
  return h;
}
const SP = {
  provider: "",
  aliases: {},
  not_found: {},
  ...hE
};
function Hw(s, u) {
  for (const h in u)
    if (h in s && typeof s[h] != typeof u[h])
      return !1;
  return !0;
}
function gE(s) {
  if (typeof s != "object" || s === null)
    return null;
  const u = s;
  if (typeof u.prefix != "string" || !s.icons || typeof s.icons != "object" || !Hw(s, SP))
    return null;
  const h = u.icons;
  for (const w in h) {
    const C = h[w];
    if (!w.match(og) || typeof C.body != "string" || !Hw(
      C,
      o1
    ))
      return null;
  }
  const v = u.aliases || /* @__PURE__ */ Object.create(null);
  for (const w in v) {
    const C = v[w], T = C.parent;
    if (!w.match(og) || typeof T != "string" || !h[T] && !v[T] || !Hw(
      C,
      o1
    ))
      return null;
  }
  return u;
}
const lT = /* @__PURE__ */ Object.create(null);
function kP(s, u) {
  return {
    provider: s,
    prefix: u,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function Hc(s, u) {
  const h = lT[s] || (lT[s] = /* @__PURE__ */ Object.create(null));
  return h[u] || (h[u] = kP(s, u));
}
function P1(s, u) {
  return gE(u) ? pE(u, (h, v) => {
    v ? s.icons[h] = v : s.missing.add(h);
  }) : [];
}
function CP(s, u, h) {
  try {
    if (typeof h.body == "string")
      return s.icons[u] = { ...h }, !0;
  } catch {
  }
  return !1;
}
let pg = !1;
function vE(s) {
  return typeof s == "boolean" && (pg = s), pg;
}
function AP(s) {
  const u = typeof s == "string" ? $y(s, !0, pg) : s;
  if (u) {
    const h = Hc(u.provider, u.prefix), v = u.name;
    return h.icons[v] || (h.missing.has(v) ? null : void 0);
  }
}
function TP(s, u) {
  const h = $y(s, !0, pg);
  if (!h)
    return !1;
  const v = Hc(h.provider, h.prefix);
  return CP(v, h.name, u);
}
function EP(s, u) {
  if (typeof s != "object")
    return !1;
  if (typeof u != "string" && (u = s.provider || ""), pg && !u && !s.prefix) {
    let w = !1;
    return gE(s) && (s.prefix = "", pE(s, (C, T) => {
      T && TP(C, T) && (w = !0);
    })), w;
  }
  const h = s.prefix;
  if (!Ty({
    provider: u,
    prefix: h,
    name: "a"
  }))
    return !1;
  const v = Hc(u, h);
  return !!P1(v, s);
}
const mE = Object.freeze({
  width: null,
  height: null
}), yE = Object.freeze({
  // Dimensions
  ...mE,
  // Transformations
  ...Fy
}), RP = /(-?[0-9.]*[0-9]+[0-9.]*)/g, LP = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function uT(s, u, h) {
  if (u === 1)
    return s;
  if (h = h || 100, typeof s == "number")
    return Math.ceil(s * u * h) / h;
  if (typeof s != "string")
    return s;
  const v = s.split(RP);
  if (v === null || !v.length)
    return s;
  const w = [];
  let C = v.shift(), T = LP.test(C);
  for (; ; ) {
    if (T) {
      const F = parseFloat(C);
      isNaN(F) ? w.push(C) : w.push(Math.ceil(F * u * h) / h);
    } else
      w.push(C);
    if (C = v.shift(), C === void 0)
      return w.join("");
    T = !T;
  }
}
const MP = (s) => s === "unset" || s === "undefined" || s === "none";
function DP(s, u) {
  const h = {
    ..._1,
    ...s
  }, v = {
    ...yE,
    ...u
  }, w = {
    left: h.left,
    top: h.top,
    width: h.width,
    height: h.height
  };
  let C = h.body;
  [h, v].forEach((ae) => {
    const ue = [], Ce = ae.hFlip, Ne = ae.vFlip;
    let K = ae.rotate;
    Ce ? Ne ? K += 2 : (ue.push(
      "translate(" + (w.width + w.left).toString() + " " + (0 - w.top).toString() + ")"
    ), ue.push("scale(-1 1)"), w.top = w.left = 0) : Ne && (ue.push(
      "translate(" + (0 - w.left).toString() + " " + (w.height + w.top).toString() + ")"
    ), ue.push("scale(1 -1)"), w.top = w.left = 0);
    let we;
    switch (K < 0 && (K -= Math.floor(K / 4) * 4), K = K % 4, K) {
      case 1:
        we = w.height / 2 + w.top, ue.unshift(
          "rotate(90 " + we.toString() + " " + we.toString() + ")"
        );
        break;
      case 2:
        ue.unshift(
          "rotate(180 " + (w.width / 2 + w.left).toString() + " " + (w.height / 2 + w.top).toString() + ")"
        );
        break;
      case 3:
        we = w.width / 2 + w.left, ue.unshift(
          "rotate(-90 " + we.toString() + " " + we.toString() + ")"
        );
        break;
    }
    K % 2 === 1 && (w.left !== w.top && (we = w.left, w.left = w.top, w.top = we), w.width !== w.height && (we = w.width, w.width = w.height, w.height = we)), ue.length && (C = '<g transform="' + ue.join(" ") + '">' + C + "</g>");
  });
  const T = v.width, F = v.height, Y = w.width, U = w.height;
  let G, q;
  T === null ? (q = F === null ? "1em" : F === "auto" ? U : F, G = uT(q, Y / U)) : (G = T === "auto" ? Y : T, q = F === null ? uT(G, U / Y) : F === "auto" ? U : F);
  const te = {}, se = (ae, ue) => {
    MP(ue) || (te[ae] = ue.toString());
  };
  return se("width", G), se("height", q), te.viewBox = w.left.toString() + " " + w.top.toString() + " " + Y.toString() + " " + U.toString(), {
    attributes: te,
    body: C
  };
}
const OP = /\sid="(\S+)"/g, _P = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let PP = 0;
function NP(s, u = _P) {
  const h = [];
  let v;
  for (; v = OP.exec(s); )
    h.push(v[1]);
  if (!h.length)
    return s;
  const w = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return h.forEach((C) => {
    const T = typeof u == "function" ? u(C) : u + (PP++).toString(), F = C.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    s = s.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + F + ')([")]|\\.[a-z])', "g"),
      "$1" + T + w + "$3"
    );
  }), s = s.replace(new RegExp(w, "g"), ""), s;
}
const l1 = /* @__PURE__ */ Object.create(null);
function zP(s, u) {
  l1[s] = u;
}
function u1(s) {
  return l1[s] || l1[""];
}
function N1(s) {
  let u;
  if (typeof s.resources == "string")
    u = [s.resources];
  else if (u = s.resources, !(u instanceof Array) || !u.length)
    return null;
  return {
    // API hosts
    resources: u,
    // Root path
    path: s.path || "/",
    // URL length limit
    maxURL: s.maxURL || 500,
    // Timeout before next host is used.
    rotate: s.rotate || 750,
    // Timeout before failing query.
    timeout: s.timeout || 5e3,
    // Randomise default API end point.
    random: s.random === !0,
    // Start index
    index: s.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: s.dataAfterTimeout !== !1
  };
}
const z1 = /* @__PURE__ */ Object.create(null), ng = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], Ey = [];
for (; ng.length > 0; )
  ng.length === 1 || Math.random() > 0.5 ? Ey.push(ng.shift()) : Ey.push(ng.pop());
z1[""] = N1({
  resources: ["https://api.iconify.design"].concat(Ey)
});
function IP(s, u) {
  const h = N1(u);
  return h === null ? !1 : (z1[s] = h, !0);
}
function I1(s) {
  return z1[s];
}
const FP = () => {
  let s;
  try {
    if (s = fetch, typeof s == "function")
      return s;
  } catch {
  }
};
let cT = FP();
function YP(s, u) {
  const h = I1(s);
  if (!h)
    return 0;
  let v;
  if (!h.maxURL)
    v = 0;
  else {
    let w = 0;
    h.resources.forEach((T) => {
      w = Math.max(w, T.length);
    });
    const C = u + ".json?icons=";
    v = h.maxURL - w - h.path.length - C.length;
  }
  return v;
}
function HP(s) {
  return s === 404;
}
const jP = (s, u, h) => {
  const v = [], w = YP(s, u), C = "icons";
  let T = {
    type: C,
    provider: s,
    prefix: u,
    icons: []
  }, F = 0;
  return h.forEach((Y, U) => {
    F += Y.length + 1, F >= w && U > 0 && (v.push(T), T = {
      type: C,
      provider: s,
      prefix: u,
      icons: []
    }, F = Y.length), T.icons.push(Y);
  }), v.push(T), v;
};
function UP(s) {
  if (typeof s == "string") {
    const u = I1(s);
    if (u)
      return u.path;
  }
  return "/";
}
const BP = (s, u, h) => {
  if (!cT) {
    h("abort", 424);
    return;
  }
  let v = UP(u.provider);
  switch (u.type) {
    case "icons": {
      const C = u.prefix, F = u.icons.join(","), Y = new URLSearchParams({
        icons: F
      });
      v += C + ".json?" + Y.toString();
      break;
    }
    case "custom": {
      const C = u.uri;
      v += C.slice(0, 1) === "/" ? C.slice(1) : C;
      break;
    }
    default:
      h("abort", 400);
      return;
  }
  let w = 503;
  cT(s + v).then((C) => {
    const T = C.status;
    if (T !== 200) {
      setTimeout(() => {
        h(HP(T) ? "abort" : "next", T);
      });
      return;
    }
    return w = 501, C.json();
  }).then((C) => {
    if (typeof C != "object" || C === null) {
      setTimeout(() => {
        C === 404 ? h("abort", C) : h("next", w);
      });
      return;
    }
    setTimeout(() => {
      h("success", C);
    });
  }).catch(() => {
    h("next", w);
  });
}, WP = {
  prepare: jP,
  send: BP
};
function XP(s) {
  const u = {
    loaded: [],
    missing: [],
    pending: []
  }, h = /* @__PURE__ */ Object.create(null);
  s.sort((w, C) => w.provider !== C.provider ? w.provider.localeCompare(C.provider) : w.prefix !== C.prefix ? w.prefix.localeCompare(C.prefix) : w.name.localeCompare(C.name));
  let v = {
    provider: "",
    prefix: "",
    name: ""
  };
  return s.forEach((w) => {
    if (v.name === w.name && v.prefix === w.prefix && v.provider === w.provider)
      return;
    v = w;
    const C = w.provider, T = w.prefix, F = w.name, Y = h[C] || (h[C] = /* @__PURE__ */ Object.create(null)), U = Y[T] || (Y[T] = Hc(C, T));
    let G;
    F in U.icons ? G = u.loaded : T === "" || U.missing.has(F) ? G = u.missing : G = u.pending;
    const q = {
      provider: C,
      prefix: T,
      name: F
    };
    G.push(q);
  }), u;
}
function xE(s, u) {
  s.forEach((h) => {
    const v = h.loaderCallbacks;
    v && (h.loaderCallbacks = v.filter((w) => w.id !== u));
  });
}
function VP(s) {
  s.pendingCallbacksFlag || (s.pendingCallbacksFlag = !0, setTimeout(() => {
    s.pendingCallbacksFlag = !1;
    const u = s.loaderCallbacks ? s.loaderCallbacks.slice(0) : [];
    if (!u.length)
      return;
    let h = !1;
    const v = s.provider, w = s.prefix;
    u.forEach((C) => {
      const T = C.icons, F = T.pending.length;
      T.pending = T.pending.filter((Y) => {
        if (Y.prefix !== w)
          return !0;
        const U = Y.name;
        if (s.icons[U])
          T.loaded.push({
            provider: v,
            prefix: w,
            name: U
          });
        else if (s.missing.has(U))
          T.missing.push({
            provider: v,
            prefix: w,
            name: U
          });
        else
          return h = !0, !0;
        return !1;
      }), T.pending.length !== F && (h || xE([s], C.id), C.callback(
        T.loaded.slice(0),
        T.missing.slice(0),
        T.pending.slice(0),
        C.abort
      ));
    });
  }));
}
let GP = 0;
function $P(s, u, h) {
  const v = GP++, w = xE.bind(null, h, v);
  if (!u.pending.length)
    return w;
  const C = {
    id: v,
    icons: u,
    callback: s,
    abort: w
  };
  return h.forEach((T) => {
    (T.loaderCallbacks || (T.loaderCallbacks = [])).push(C);
  }), w;
}
function qP(s, u = !0, h = !1) {
  const v = [];
  return s.forEach((w) => {
    const C = typeof w == "string" ? $y(w, u, h) : w;
    C && v.push(C);
  }), v;
}
var ZP = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function QP(s, u, h, v) {
  const w = s.resources.length, C = s.random ? Math.floor(Math.random() * w) : s.index;
  let T;
  if (s.random) {
    let ve = s.resources.slice(0);
    for (T = []; ve.length > 1; ) {
      const Me = Math.floor(Math.random() * ve.length);
      T.push(ve[Me]), ve = ve.slice(0, Me).concat(ve.slice(Me + 1));
    }
    T = T.concat(ve);
  } else
    T = s.resources.slice(C).concat(s.resources.slice(0, C));
  const F = Date.now();
  let Y = "pending", U = 0, G, q = null, te = [], se = [];
  typeof v == "function" && se.push(v);
  function ae() {
    q && (clearTimeout(q), q = null);
  }
  function ue() {
    Y === "pending" && (Y = "aborted"), ae(), te.forEach((ve) => {
      ve.status === "pending" && (ve.status = "aborted");
    }), te = [];
  }
  function Ce(ve, Me) {
    Me && (se = []), typeof ve == "function" && se.push(ve);
  }
  function Ne() {
    return {
      startTime: F,
      payload: u,
      status: Y,
      queriesSent: U,
      queriesPending: te.length,
      subscribe: Ce,
      abort: ue
    };
  }
  function K() {
    Y = "failed", se.forEach((ve) => {
      ve(void 0, G);
    });
  }
  function we() {
    te.forEach((ve) => {
      ve.status === "pending" && (ve.status = "aborted");
    }), te = [];
  }
  function Re(ve, Me, et) {
    const je = Me !== "success";
    switch (te = te.filter((Ve) => Ve !== ve), Y) {
      case "pending":
        break;
      case "failed":
        if (je || !s.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (Me === "abort") {
      G = et, K();
      return;
    }
    if (je) {
      G = et, te.length || (T.length ? re() : K());
      return;
    }
    if (ae(), we(), !s.random) {
      const Ve = s.resources.indexOf(ve.resource);
      Ve !== -1 && Ve !== s.index && (s.index = Ve);
    }
    Y = "completed", se.forEach((Ve) => {
      Ve(et);
    });
  }
  function re() {
    if (Y !== "pending")
      return;
    ae();
    const ve = T.shift();
    if (ve === void 0) {
      if (te.length) {
        q = setTimeout(() => {
          ae(), Y === "pending" && (we(), K());
        }, s.timeout);
        return;
      }
      K();
      return;
    }
    const Me = {
      status: "pending",
      resource: ve,
      callback: (et, je) => {
        Re(Me, et, je);
      }
    };
    te.push(Me), U++, q = setTimeout(re, s.rotate), h(ve, u, Me.callback);
  }
  return setTimeout(re), Ne;
}
function bE(s) {
  const u = {
    ...ZP,
    ...s
  };
  let h = [];
  function v() {
    h = h.filter((F) => F().status === "pending");
  }
  function w(F, Y, U) {
    const G = QP(
      u,
      F,
      Y,
      (q, te) => {
        v(), U && U(q, te);
      }
    );
    return h.push(G), G;
  }
  function C(F) {
    return h.find((Y) => F(Y)) || null;
  }
  return {
    query: w,
    find: C,
    setIndex: (F) => {
      u.index = F;
    },
    getIndex: () => u.index,
    cleanup: v
  };
}
function dT() {
}
const jw = /* @__PURE__ */ Object.create(null);
function KP(s) {
  if (!jw[s]) {
    const u = I1(s);
    if (!u)
      return;
    const h = bE(u), v = {
      config: u,
      redundancy: h
    };
    jw[s] = v;
  }
  return jw[s];
}
function JP(s, u, h) {
  let v, w;
  if (typeof s == "string") {
    const C = u1(s);
    if (!C)
      return h(void 0, 424), dT;
    w = C.send;
    const T = KP(s);
    T && (v = T.redundancy);
  } else {
    const C = N1(s);
    if (C) {
      v = bE(C);
      const T = s.resources ? s.resources[0] : "", F = u1(T);
      F && (w = F.send);
    }
  }
  return !v || !w ? (h(void 0, 424), dT) : v.query(u, w, h)().abort;
}
const fT = "iconify2", gg = "iconify", wE = gg + "-count", hT = gg + "-version", SE = 36e5, eN = 168;
function c1(s, u) {
  try {
    return s.getItem(u);
  } catch {
  }
}
function F1(s, u, h) {
  try {
    return s.setItem(u, h), !0;
  } catch {
  }
}
function pT(s, u) {
  try {
    s.removeItem(u);
  } catch {
  }
}
function d1(s, u) {
  return F1(s, wE, u.toString());
}
function f1(s) {
  return parseInt(c1(s, wE)) || 0;
}
const qy = {
  local: !0,
  session: !0
}, kE = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let Y1 = !1;
function tN(s) {
  Y1 = s;
}
let xy = typeof window > "u" ? {} : window;
function CE(s) {
  const u = s + "Storage";
  try {
    if (xy && xy[u] && typeof xy[u].length == "number")
      return xy[u];
  } catch {
  }
  qy[s] = !1;
}
function AE(s, u) {
  const h = CE(s);
  if (!h)
    return;
  const v = c1(h, hT);
  if (v !== fT) {
    if (v) {
      const F = f1(h);
      for (let Y = 0; Y < F; Y++)
        pT(h, gg + Y.toString());
    }
    F1(h, hT, fT), d1(h, 0);
    return;
  }
  const w = Math.floor(Date.now() / SE) - eN, C = (F) => {
    const Y = gg + F.toString(), U = c1(h, Y);
    if (typeof U == "string") {
      try {
        const G = JSON.parse(U);
        if (typeof G == "object" && typeof G.cached == "number" && G.cached > w && typeof G.provider == "string" && typeof G.data == "object" && typeof G.data.prefix == "string" && // Valid item: run callback
        u(G, F))
          return !0;
      } catch {
      }
      pT(h, Y);
    }
  };
  let T = f1(h);
  for (let F = T - 1; F >= 0; F--)
    C(F) || (F === T - 1 ? (T--, d1(h, T)) : kE[s].add(F));
}
function TE() {
  if (!Y1) {
    tN(!0);
    for (const s in qy)
      AE(s, (u) => {
        const h = u.data, v = u.provider, w = h.prefix, C = Hc(
          v,
          w
        );
        if (!P1(C, h).length)
          return !1;
        const T = h.lastModified || -1;
        return C.lastModifiedCached = C.lastModifiedCached ? Math.min(C.lastModifiedCached, T) : T, !0;
      });
  }
}
function nN(s, u) {
  const h = s.lastModifiedCached;
  if (
    // Matches or newer
    h && h >= u
  )
    return h === u;
  if (s.lastModifiedCached = u, h)
    for (const v in qy)
      AE(v, (w) => {
        const C = w.data;
        return w.provider !== s.provider || C.prefix !== s.prefix || C.lastModified === u;
      });
  return !0;
}
function rN(s, u) {
  Y1 || TE();
  function h(v) {
    let w;
    if (!qy[v] || !(w = CE(v)))
      return;
    const C = kE[v];
    let T;
    if (C.size)
      C.delete(T = Array.from(C).shift());
    else if (T = f1(w), !d1(w, T + 1))
      return;
    const F = {
      cached: Math.floor(Date.now() / SE),
      provider: s.provider,
      data: u
    };
    return F1(
      w,
      gg + T.toString(),
      JSON.stringify(F)
    );
  }
  u.lastModified && !nN(s, u.lastModified) || Object.keys(u.icons).length && (u.not_found && (u = Object.assign({}, u), delete u.not_found), h("local") || h("session"));
}
function gT() {
}
function iN(s) {
  s.iconsLoaderFlag || (s.iconsLoaderFlag = !0, setTimeout(() => {
    s.iconsLoaderFlag = !1, VP(s);
  }));
}
function aN(s, u) {
  s.iconsToLoad ? s.iconsToLoad = s.iconsToLoad.concat(u).sort() : s.iconsToLoad = u, s.iconsQueueFlag || (s.iconsQueueFlag = !0, setTimeout(() => {
    s.iconsQueueFlag = !1;
    const { provider: h, prefix: v } = s, w = s.iconsToLoad;
    delete s.iconsToLoad;
    let C;
    if (!w || !(C = u1(h)))
      return;
    C.prepare(h, v, w).forEach((F) => {
      JP(h, F, (Y) => {
        if (typeof Y != "object")
          F.icons.forEach((U) => {
            s.missing.add(U);
          });
        else
          try {
            const U = P1(
              s,
              Y
            );
            if (!U.length)
              return;
            const G = s.pendingIcons;
            G && U.forEach((q) => {
              G.delete(q);
            }), rN(s, Y);
          } catch (U) {
            console.error(U);
          }
        iN(s);
      });
    });
  }));
}
const sN = (s, u) => {
  const h = qP(s, !0, vE()), v = XP(h);
  if (!v.pending.length) {
    let Y = !0;
    return u && setTimeout(() => {
      Y && u(
        v.loaded,
        v.missing,
        v.pending,
        gT
      );
    }), () => {
      Y = !1;
    };
  }
  const w = /* @__PURE__ */ Object.create(null), C = [];
  let T, F;
  return v.pending.forEach((Y) => {
    const { provider: U, prefix: G } = Y;
    if (G === F && U === T)
      return;
    T = U, F = G, C.push(Hc(U, G));
    const q = w[U] || (w[U] = /* @__PURE__ */ Object.create(null));
    q[G] || (q[G] = []);
  }), v.pending.forEach((Y) => {
    const { provider: U, prefix: G, name: q } = Y, te = Hc(U, G), se = te.pendingIcons || (te.pendingIcons = /* @__PURE__ */ new Set());
    se.has(q) || (se.add(q), w[U][G].push(q));
  }), C.forEach((Y) => {
    const { provider: U, prefix: G } = Y;
    w[U][G].length && aN(Y, w[U][G]);
  }), u ? $P(u, v, C) : gT;
};
function oN(s, u) {
  const h = {
    ...s
  };
  for (const v in u) {
    const w = u[v], C = typeof w;
    v in mE ? (w === null || w && (C === "string" || C === "number")) && (h[v] = w) : C === typeof h[v] && (h[v] = v === "rotate" ? w % 4 : w);
  }
  return h;
}
const lN = /[\s,]+/;
function uN(s, u) {
  u.split(lN).forEach((h) => {
    switch (h.trim()) {
      case "horizontal":
        s.hFlip = !0;
        break;
      case "vertical":
        s.vFlip = !0;
        break;
    }
  });
}
function cN(s, u = 0) {
  const h = s.replace(/^-?[0-9.]*/, "");
  function v(w) {
    for (; w < 0; )
      w += 4;
    return w % 4;
  }
  if (h === "") {
    const w = parseInt(s);
    return isNaN(w) ? 0 : v(w);
  } else if (h !== s) {
    let w = 0;
    switch (h) {
      case "%":
        w = 25;
        break;
      case "deg":
        w = 90;
    }
    if (w) {
      let C = parseFloat(s.slice(0, s.length - h.length));
      return isNaN(C) ? 0 : (C = C / w, C % 1 === 0 ? v(C) : 0);
    }
  }
  return u;
}
function dN(s, u) {
  let h = s.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const v in u)
    h += " " + v + '="' + u[v] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + h + ">" + s + "</svg>";
}
function fN(s) {
  return s.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function hN(s) {
  return "data:image/svg+xml," + fN(s);
}
function pN(s) {
  return 'url("' + hN(s) + '")';
}
let lg;
function gN() {
  try {
    lg = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (s) => s
    });
  } catch {
    lg = null;
  }
}
function vN(s) {
  return lg === void 0 && gN(), lg ? lg.createHTML(s) : s;
}
const EE = {
  ...yE,
  inline: !1
}, mN = {
  xmlns: "http://www.w3.org/2000/svg",
  xmlnsXlink: "http://www.w3.org/1999/xlink",
  "aria-hidden": !0,
  role: "img"
}, yN = {
  display: "inline-block"
}, h1 = {
  backgroundColor: "currentColor"
}, RE = {
  backgroundColor: "transparent"
}, vT = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
}, mT = {
  WebkitMask: h1,
  mask: h1,
  background: RE
};
for (const s in mT) {
  const u = mT[s];
  for (const h in vT)
    u[s + h] = vT[h];
}
const xN = {
  ...EE,
  inline: !0
};
function yT(s) {
  return s + (s.match(/^[-0-9.]+$/) ? "px" : "");
}
const bN = (s, u, h, v) => {
  const w = h ? xN : EE, C = oN(w, u), T = u.mode || "svg", F = {}, Y = u.style || {}, U = {
    ...T === "svg" ? mN : {},
    ref: v
  };
  for (let Ne in u) {
    const K = u[Ne];
    if (K !== void 0)
      switch (Ne) {
        case "icon":
        case "style":
        case "children":
        case "onLoad":
        case "mode":
        case "_ref":
        case "_inline":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          C[Ne] = K === !0 || K === "true" || K === 1;
          break;
        case "flip":
          typeof K == "string" && uN(C, K);
          break;
        case "color":
          F.color = K;
          break;
        case "rotate":
          typeof K == "string" ? C[Ne] = cN(K) : typeof K == "number" && (C[Ne] = K);
          break;
        case "ariaHidden":
        case "aria-hidden":
          K !== !0 && K !== "true" && delete U["aria-hidden"];
          break;
        default:
          w[Ne] === void 0 && (U[Ne] = K);
      }
  }
  const G = DP(s, C), q = G.attributes;
  if (C.inline && (F.verticalAlign = "-0.125em"), T === "svg") {
    U.style = {
      ...F,
      ...Y
    }, Object.assign(U, q);
    let Ne = 0, K = u.id;
    return typeof K == "string" && (K = K.replace(/-/g, "_")), U.dangerouslySetInnerHTML = {
      __html: vN(NP(G.body, K ? () => K + "ID" + Ne++ : "iconifyReact"))
    }, Ou.createElement("svg", U);
  }
  const { body: te, width: se, height: ae } = s, ue = T === "mask" || (T === "bg" ? !1 : te.indexOf("currentColor") !== -1), Ce = dN(te, {
    ...q,
    width: se + "",
    height: ae + ""
  });
  return U.style = {
    ...F,
    "--svg": pN(Ce),
    width: yT(q.width),
    height: yT(q.height),
    ...yN,
    ...ue ? h1 : RE,
    ...Y
  }, Ou.createElement("span", U);
};
vE(!0);
zP("", WP);
if (typeof document < "u" && typeof window < "u") {
  TE();
  const s = window;
  if (s.IconifyPreload !== void 0) {
    const u = s.IconifyPreload, h = "Invalid IconifyPreload syntax.";
    typeof u == "object" && u !== null && (u instanceof Array ? u : [u]).forEach((v) => {
      try {
        // Check if item is an object and not null/array
        (typeof v != "object" || v === null || v instanceof Array || // Check for 'icons' and 'prefix'
        typeof v.icons != "object" || typeof v.prefix != "string" || // Add icon set
        !EP(v)) && console.error(h);
      } catch {
        console.error(h);
      }
    });
  }
  if (s.IconifyProviders !== void 0) {
    const u = s.IconifyProviders;
    if (typeof u == "object" && u !== null)
      for (let h in u) {
        const v = "IconifyProviders[" + h + "] is invalid.";
        try {
          const w = u[h];
          if (typeof w != "object" || !w || w.resources === void 0)
            continue;
          IP(h, w) || console.error(v);
        } catch {
          console.error(v);
        }
      }
  }
}
let LE = class extends Ou.Component {
  constructor(u) {
    super(u), this.state = {
      // Render placeholder before component is mounted
      icon: null
    };
  }
  /**
   * Abort loading icon
   */
  _abortLoading() {
    this._loading && (this._loading.abort(), this._loading = null);
  }
  /**
   * Update state
   */
  _setData(u) {
    this.state.icon !== u && this.setState({
      icon: u
    });
  }
  /**
   * Check if icon should be loaded
   */
  _checkIcon(u) {
    const h = this.state, v = this.props.icon;
    if (typeof v == "object" && v !== null && typeof v.body == "string") {
      this._icon = "", this._abortLoading(), (u || h.icon === null) && this._setData({
        data: v
      });
      return;
    }
    let w;
    if (typeof v != "string" || (w = $y(v, !1, !0)) === null) {
      this._abortLoading(), this._setData(null);
      return;
    }
    const C = AP(w);
    if (!C) {
      (!this._loading || this._loading.name !== v) && (this._abortLoading(), this._icon = "", this._setData(null), C !== null && (this._loading = {
        name: v,
        abort: sN([w], this._checkIcon.bind(this, !1))
      }));
      return;
    }
    if (this._icon !== v || h.icon === null) {
      this._abortLoading(), this._icon = v;
      const T = ["iconify"];
      w.prefix !== "" && T.push("iconify--" + w.prefix), w.provider !== "" && T.push("iconify--" + w.provider), this._setData({
        data: C,
        classes: T
      }), this.props.onLoad && this.props.onLoad(v);
    }
  }
  /**
   * Component mounted
   */
  componentDidMount() {
    this._checkIcon(!1);
  }
  /**
   * Component updated
   */
  componentDidUpdate(u) {
    u.icon !== this.props.icon && this._checkIcon(!0);
  }
  /**
   * Abort loading
   */
  componentWillUnmount() {
    this._abortLoading();
  }
  /**
   * Render
   */
  render() {
    const u = this.props, h = this.state.icon;
    if (h === null)
      return u.children ? u.children : Ou.createElement("span", {});
    let v = u;
    return h.classes && (v = {
      ...u,
      className: (typeof u.className == "string" ? u.className + " " : "") + h.classes.join(" ")
    }), bN({
      ..._1,
      ...h.data
    }, v, u._inline, u._ref);
  }
};
const wN = Ou.forwardRef(function(u, h) {
  const v = {
    ...u,
    _ref: h,
    _inline: !1
  };
  return Ou.createElement(LE, v);
});
Ou.forwardRef(function(u, h) {
  const v = {
    ...u,
    _ref: h,
    _inline: !0
  };
  return Ou.createElement(LE, v);
});
var vi = wN;
const SN = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (s) => {
  const u = Math.random() * 16 | 0;
  return (s === "x" ? u : u & 3 | 8).toString(16);
}), kN = ({
  onChange: s,
  defaultValue: u,
  children: h,
  name: v,
  invalidText: w,
  placeholder: C,
  variant: T,
  icon: F,
  required: Y = !0,
  className: U = "",
  type: G = "text",
  id: q = SN(),
  ...te
}) => /* @__PURE__ */ de.jsxs("div", { className: `textfield ${T ? "bg-" + T : ""} ${U}`, children: [
  /* @__PURE__ */ de.jsx("label", { htmlFor: q, children: C ?? v ?? q }),
  /* @__PURE__ */ de.jsx(
    "input",
    {
      id: q,
      type: G,
      className: "input",
      name: v ?? q,
      onChange: s,
      defaultValue: u,
      placeholder: C ?? v ?? q ?? "",
      required: Y,
      ...te
    }
  ),
  F && /* @__PURE__ */ de.jsx(vi, { icon: F }),
  Y && /* @__PURE__ */ de.jsx("span", { className: "required", children: w ?? v ? `${v ?? q} should not be empty!` : "Should not be empty!" }),
  h && h
] }), Bj = ({
  defaultShow: s = !1,
  ...u
}) => {
  const [h, v] = dr(s);
  return /* @__PURE__ */ de.jsx(de.Fragment, { children: /* @__PURE__ */ de.jsx(
    kN,
    {
      ...u,
      className: `textfield-password ${(u == null ? void 0 : u.className) ?? ""}`,
      type: h ? "text" : "password",
      autoComplete: "new-password",
      children: /* @__PURE__ */ de.jsx(
        "button",
        {
          type: "button",
          title: "Show or hide the password",
          className: "btn btn-circle btn-sm ring-info",
          onClick: () => v((w) => !w),
          children: /* @__PURE__ */ de.jsx(vi, { icon: h ? "ph:eye-slash" : "ph:eye-light" })
        }
      )
    }
  ) });
}, CN = (s) => {
  console.log(s);
}, AN = (s) => {
  console.log(s);
}, TN = ["Su", "Mo", "Tu", "We", "Th", "Fri", "Sa"], EN = ({
  defaultSelected: s,
  startDateRef: u,
  endDateRef: h,
  onClose: v
}) => {
  const [w, C] = dr(
    (s == null ? void 0 : s.end) === void 0 ? tr() : s.end
  ), [T, F] = dr(
    s === void 0 ? {
      start: null,
      end: null
    } : s
  ), Y = w, U = Y.clone().startOf("month"), G = Y.clone().endOf("month"), q = [], te = U.day(), se = G.day();
  for (let ae = te - 1; ae >= 0; ae--)
    q.push(U.clone().subtract(ae, "days"));
  for (let ae = U.clone().add(1, "day"); ae.isSameOrBefore(G); ae.add(1, "day"))
    q.push(ae.clone());
  for (let ae = 1; ae <= 6 - se + 1; ae++)
    q.push(G.clone().add(ae, "days"));
  return /* @__PURE__ */ de.jsx("div", { className: "dropdown", children: /* @__PURE__ */ de.jsxs("div", { className: "container rounded-box shadow-md bg-base-200", children: [
    /* @__PURE__ */ de.jsxs("header", { className: "date-header", children: [
      /* @__PURE__ */ de.jsxs("div", { className: "date-header--actions", children: [
        /* @__PURE__ */ de.jsx(
          "button",
          {
            type: "button",
            className: "btn btn-icon btn-sm btn-square btn-neutral",
            onClick: () => {
              C(
                (ae) => ae.clone().subtract(1, "month")
              );
            },
            children: /* @__PURE__ */ de.jsx(vi, { icon: "ep:arrow-left-bold" })
          }
        ),
        /* @__PURE__ */ de.jsx("button", { type: "button", className: "btn", children: Y.format("MMM, YYYY") }),
        /* @__PURE__ */ de.jsx(
          "button",
          {
            type: "button",
            className: "btn btn-icon btn-sm btn-square btn-neutral",
            onClick: () => {
              C(
                (ae) => ae.clone().add(1, "month")
              );
            },
            disabled: w.clone().add(1, "month").isSameOrAfter(tr()),
            children: /* @__PURE__ */ de.jsx(vi, { icon: "ep:arrow-left-bold", hFlip: !0 })
          }
        )
      ] }),
      /* @__PURE__ */ de.jsx("ul", { className: "date-weekdays", children: TN.map((ae) => /* @__PURE__ */ de.jsx("li", { children: /* @__PURE__ */ de.jsx("span", { children: ae }) }, ae)) })
    ] }),
    /* @__PURE__ */ de.jsx("ul", { className: "days-container", children: q.map((ae, ue) => {
      var Re, re, ve;
      let Ce = "";
      const Ne = (Re = T.start) != null && Re.startOf("day").isSame(ae) ? "selected start" : (ve = (re = T.end) == null ? void 0 : re.startOf("day")) != null && ve.isSame(ae) ? "selected end" : "", K = ae.format("MM") !== Y.format("MM") ? "not-current" : "", we = ae.isBetween(
        T.start,
        T.end
      ) ? "between" : "";
      return Ce += K + Ne + we, /* @__PURE__ */ de.jsx("li", { children: /* @__PURE__ */ de.jsx(
        "button",
        {
          type: "button",
          onClick: () => {
            var Me;
            if (!(u.current === null || h.current === null)) {
              if (((Me = T.start) == null ? void 0 : Me.date()) === ae.date()) {
                F({
                  start: null,
                  end: null
                }), u.current.value = "", h.current.value = "";
                return;
              }
              if (T.start === null)
                F((et) => ({
                  ...et,
                  start: ae
                })), u.current.value = ae.format("YYYY-MM-DD");
              else if (T.start !== null) {
                if (ae.isBefore(T.start)) {
                  F((et) => ({
                    start: ae,
                    end: et.start
                  })), u.current.value = ae.format("YYYY-MM-DD"), h.current.value = T.start.format("YYYY-MM-DD");
                  return;
                }
                F((et) => ({
                  ...et,
                  end: ae
                })), h.current.value = ae.format("YYYY-MM-DD");
              }
            }
          },
          className: Ce,
          disabled: ae.isAfter(tr()),
          children: ae.format("DD")
        }
      ) }, ue);
    }) }),
    /* @__PURE__ */ de.jsx(
      "button",
      {
        type: "button",
        onClick: v,
        className: "btn btn-sm btn-primary",
        style: { alignSelf: "end" },
        children: "Done"
      }
    )
  ] }) });
}, Wj = ({
  defaultSelected: s,
  onSearch: u,
  children: h
}) => {
  const [v, w] = dr(!1), C = gr(null), T = gr(null), F = {
    ref: C,
    type: "date",
    name: "start",
    onFocus: CN,
    onClick: () => {
      w((U) => !U);
    },
    autoComplete: "off",
    defaultValue: s ? s.start.format("YYYY-MM-DD") : ""
  }, Y = {
    ref: T,
    type: "date",
    name: "end",
    onFocus: AN,
    onClick: () => {
      w((U) => !U);
    },
    autoComplete: "off",
    defaultValue: s != null && s.end ? s.end.format("YYYY-MM-DD") : ""
  };
  return /* @__PURE__ */ de.jsx(de.Fragment, { children: /* @__PURE__ */ de.jsxs(
    "form",
    {
      className: "date-range-picker",
      onSubmit: (U) => {
        U.preventDefault();
        const G = new FormData(U.target), q = Object.fromEntries(G.entries()), te = {
          start: tr(q.start, "YYYY-MM-DD"),
          end: tr(q.end, "YYYY-MM-DD")
        };
        u == null || u(te);
      },
      children: [
        /* @__PURE__ */ de.jsxs("div", { className: "group rounded-box", children: [
          h({ startDateProps: F, endDateProps: Y }),
          /* @__PURE__ */ de.jsx("button", { className: "btn btn-primary ring-info", children: "Search" })
        ] }),
        v && /* @__PURE__ */ de.jsx(
          EN,
          {
            defaultSelected: s,
            startDateRef: C,
            endDateRef: T,
            onClose: () => w(!1)
          }
        )
      ]
    }
  ) });
}, RN = (s, u, h, v, w, C) => {
  let T = 0, F = !1;
  switch (s.key) {
    case "ArrowUp": {
      if (u === 0)
        return;
      T = u - 1, w.current[T].focus(), h(T), v.current = "";
      break;
    }
    case "ArrowDown": {
      if (u === C - 1)
        return;
      T = u + 1, w.current[T].focus(), v.current = "", h(T);
      break;
    }
    case "Backspace": {
      v.current = v.current.slice(0, -1), v.current.length > 0 && (F = !0);
      break;
    }
    default:
      s.key.length === 1 && isNaN(Number(s.key)) && (v.current += s.key, F = !0);
  }
  if (F) {
    const Y = w.current.findIndex(
      (U) => U.innerText.toLowerCase().includes(v.current.toLowerCase())
    );
    if (Y === -1)
      return;
    w.current[Y].focus(), h(Y);
  }
}, LN = (s) => typeof s == "object" ? /* @__PURE__ */ de.jsx("span", { children: Object.values(s)[0] }) : /* @__PURE__ */ de.jsx("span", { children: s }), Yy = ({
  items: s,
  selected: u,
  currentSelected: h,
  selector: v,
  onChange: w,
  labelExtractor: C,
  disabled: T = !1,
  required: F = !0,
  showQty: Y = 4,
  style: U = {},
  name: G = "",
  position: q = "top",
  variant: te = "neutral",
  keyExtractor: se = LN
}) => {
  const [ae, ue] = dr(!1), [Ce, Ne] = dr(
    u !== void 0 ? u : s.findIndex(
      (Me) => v ? Me[v] === (h == null ? void 0 : h[v]) : Me === h
    )
  );
  Hf(() => {
    u && u !== Ce && Ne(u);
  }, [u, Ce]);
  const [K, we] = dr(Ce), Re = gr(null), re = gr(""), ve = gr([]);
  return /* @__PURE__ */ de.jsxs(
    "div",
    {
      className: `select ${ae ? "shadow-md" : ""} ${q}`,
      onBlur: () => {
      },
      style: U,
      children: [
        /* @__PURE__ */ de.jsxs(
          "button",
          {
            type: "button",
            disabled: T,
            className: `btn btn-${te} btn-select ${ae ? "active" : ""}`,
            onClick: () => {
              ue((et) => !et);
              const Me = h === void 0 ? 0 : Ce;
              we(Me), setTimeout(() => {
                ae || ve.current[Me].focus();
              }, 10);
            },
            children: [
              /* @__PURE__ */ de.jsx("span", { className: Ce === -1 ? "not-selected" : "", children: Ce === -1 ? kr("select.select-one") : (C == null ? void 0 : C(s[Ce], -1)) ?? se(s[Ce], -1) }),
              /* @__PURE__ */ de.jsx(vi, { icon: "eva:arrow-down-fill", vFlip: ae })
            ]
          }
        ),
        /* @__PURE__ */ de.jsx(
          "input",
          {
            style: {
              display: "block",
              position: "absolute",
              top: "100%",
              opacity: 0,
              height: 1,
              pointerEvents: "none"
            },
            defaultValue: typeof h == "object" && v ? h == null ? void 0 : h[v] : typeof h == "string" ? h : "",
            autoComplete: "new-password",
            name: G,
            ref: Re,
            required: F
          }
        ),
        ae && /* @__PURE__ */ de.jsx(
          "ul",
          {
            className: `select-items${s.length > 4 ? " custom-scroll " : " "}bg-${te} shadow-md`,
            style: { "--select-items": Y },
            children: s.map((Me, et) => /* @__PURE__ */ de.jsx("li", { className: "item", children: /* @__PURE__ */ de.jsx(
              "button",
              {
                type: "button",
                className: `${et === Ce ? "active" : ""}`,
                ref: (je) => ve.current[et] = je,
                tabIndex: 0,
                onClick: () => {
                  Ne(et), w !== void 0 && w(et, s[et]), Re.current && v && (Re.current.value = String(s[et][v])), ue(!1);
                },
                onMouseEnter: (je) => {
                  we(et), je.target.focus();
                },
                onMouseLeave: () => {
                  we(Ce);
                },
                onKeyDown: (je) => RN(
                  je,
                  K,
                  we,
                  re,
                  ve,
                  s.length
                ),
                children: se(Me, et)
              }
            ) }, et))
          }
        )
      ]
    }
  );
}, xT = (s, u, h, v, w, C) => {
  let T = 0, F = !1;
  switch (s.key) {
    case "ArrowUp": {
      if (u === 0)
        return;
      T = u - 1, w.current[T].focus(), h(T), v.current = "";
      break;
    }
    case "ArrowDown": {
      if (u === C - 1)
        return;
      T = u + 1, w.current[T].focus(), v.current = "", h(T);
      break;
    }
    case "Backspace": {
      v.current = v.current.slice(0, -1), v.current.length > 0 && (F = !0);
      break;
    }
    default:
      s.key.length === 1 && isNaN(Number(s.key)) && (v.current += s.key, F = !0);
  }
  if (F) {
    const Y = w.current.findIndex(
      (U) => U.innerText.toLowerCase().includes(v.current.toLowerCase())
    );
    if (Y === -1)
      return;
    w.current[Y].focus(), h(Y);
  }
}, H1 = (s, u, h) => {
  let v;
  return (...w) => {
    const T = () => {
      v = null, h || s.apply(void 0, w);
    }, F = h && !v;
    clearTimeout(v), v = setTimeout(T, u), F && s.apply(void 0, w);
  };
}, MN = [
  {
    mode: "all",
    label: "Todos"
  },
  {
    mode: "selected",
    label: "Selecionados"
  },
  {
    mode: "not-selected",
    label: "Não selecionados"
  }
], DN = (s) => typeof s == "object" ? /* @__PURE__ */ de.jsx("span", { children: Object.values(s)[0] }) : /* @__PURE__ */ de.jsx("span", { children: s }), Xj = ({
  items: s,
  selected: u,
  selector: h,
  onChange: v,
  labelExtractor: w,
  onAllChange: C = () => {
  },
  showQty: T = 10,
  style: F = {},
  position: Y = "top",
  variant: U = "neutral",
  keyExtractor: G = DN
}) => {
  const [q, te] = dr(!1), [se, ae] = dr(u ?? []), [ue, Ce] = dr(
    "all"
  ), [Ne, K] = dr("");
  Hf(() => {
    u && u !== se && ae(u ?? []);
  }, [u, se]);
  const we = Du(() => {
    var Ve;
    const je = [];
    for (let it = 0; it < s.length; it++) {
      if (!String(h ? (Ve = s[it]) == null ? void 0 : Ve[h] : s[it]).toLowerCase().includes(Ne))
        continue;
      if (ue === "all") {
        je.push(it);
        continue;
      }
      const Ze = se.includes(it);
      Ze && ue === "selected" && je.push(it), !Ze && ue === "not-selected" && je.push(it);
    }
    return je;
  }, [s, Ne, h, ue, se]), [Re, re] = dr(0), ve = gr(null), Me = gr(""), et = gr([]);
  return /* @__PURE__ */ de.jsxs(
    "div",
    {
      className: `select multiselect ${q ? "shadow-md" : ""} ${Y}`,
      onBlur: () => {
      },
      style: F,
      children: [
        /* @__PURE__ */ de.jsxs(
          "button",
          {
            type: "button",
            className: `btn btn-${U} btn-select ${q ? "active" : ""}`,
            onClick: () => {
              te((je) => !je), re(0);
            },
            children: [
              /* @__PURE__ */ de.jsx("span", { className: se.length === 0 ? "not-selected" : "", children: se.length === 0 ? "Clique para selecionar" : (w == null ? void 0 : w(se)) ?? `${se.length} selecionados` }),
              /* @__PURE__ */ de.jsx(vi, { icon: "eva:arrow-down-fill", vFlip: q })
            ]
          }
        ),
        q && /* @__PURE__ */ de.jsxs(
          "ul",
          {
            className: `select-items${s.length > 4 ? " custom-scroll " : " "}bg-${U} shadow-md`,
            style: { "--select-items": T },
            children: [
              /* @__PURE__ */ de.jsx(
                "li",
                {
                  className: "group rounded-box",
                  style: { width: "fit-content", padding: "var(--spacing-xs)" },
                  children: MN.map((je) => /* @__PURE__ */ de.jsx(
                    "button",
                    {
                      className: `btn no-bounce btn-${je.mode === ue ? "primary" : "neutral"} btn-sm`,
                      onClick: () => Ce(je.mode),
                      children: je.label
                    },
                    je.mode
                  ))
                }
              ),
              /* @__PURE__ */ de.jsx("li", { className: "search-bar", children: /* @__PURE__ */ de.jsx(
                "input",
                {
                  className: "input",
                  type: "input",
                  placeholder: "Buscar...",
                  onChange: H1((je) => {
                    K(je.target.value.toLowerCase());
                  }, 300)
                }
              ) }),
              /* @__PURE__ */ de.jsx("li", { className: "item", children: /* @__PURE__ */ de.jsxs(
                "button",
                {
                  type: "button",
                  ref: (je) => et.current[0] = je,
                  className: `${se.length === s.length ? "active" : ""}`,
                  onMouseEnter: (je) => {
                    re(0), je.target.focus();
                  },
                  onClick: () => {
                    C(se.length !== s.length), se.length === s.length ? ae([]) : ae(s.map((je, Ve) => Ve));
                  },
                  onKeyDown: (je) => xT(
                    je,
                    Re,
                    re,
                    Me,
                    et,
                    s.length
                  ),
                  tabIndex: 0,
                  children: [
                    /* @__PURE__ */ de.jsx(
                      "input",
                      {
                        type: "checkbox",
                        className: "checkbox checkbox-secondary",
                        onChange: () => {
                          C(se.length !== s.length), se.length === s.length ? ae([]) : ae(s.map((je, Ve) => Ve));
                        },
                        checked: se.length === s.length
                      }
                    ),
                    /* @__PURE__ */ de.jsx("span", { children: "Selecionar Tudo" })
                  ]
                }
              ) }),
              s.length === 0 || we().length === 0 && /* @__PURE__ */ de.jsx("li", { className: "item", style: { padding: "var(--spacing-xs)" }, children: /* @__PURE__ */ de.jsx("span", { children: "Nenhum item foi encontrado" }) }),
              s.map((je, Ve) => {
                if (!we().includes(Ve))
                  return null;
                const it = se.includes(Ve);
                return /* @__PURE__ */ de.jsx("li", { className: "item", children: /* @__PURE__ */ de.jsxs(
                  "button",
                  {
                    type: "button",
                    className: `${it ? "active" : ""}`,
                    ref: (dt) => et.current[Ve + 1] = dt,
                    tabIndex: 0,
                    onClick: () => {
                      const dt = it ? se.filter((Ke) => Ke !== Ve) : [...se, Ve];
                      ae(dt), v !== void 0 && v(Ve, s[Ve], dt), ve.current && h && (ve.current.value = String(s[Ve][h]));
                    },
                    onMouseEnter: (dt) => {
                      re(Ve), dt.target.focus();
                    },
                    onMouseLeave: () => {
                      re(0);
                    },
                    onKeyDown: (dt) => xT(
                      dt,
                      Re,
                      re,
                      Me,
                      et,
                      we().length + 1
                    ),
                    children: [
                      /* @__PURE__ */ de.jsx(
                        "input",
                        {
                          type: "checkbox",
                          className: "checkbox checkbox-secondary",
                          checked: it ?? !1,
                          onChange: () => {
                            ae((dt) => it ? dt.filter(
                              (Ke) => Ke !== Ve
                            ) : [...dt, Ve]), v !== void 0 && v(Ve, s[Ve]), ve.current && h && (ve.current.value = String(s[Ve][h]));
                          }
                        }
                      ),
                      G(je)
                    ]
                  }
                ) }, Ve);
              })
            ]
          }
        )
      ]
    }
  );
};
//! moment.js
//! version : 2.29.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var ME;
function ct() {
  return ME.apply(null, arguments);
}
function ON(s) {
  ME = s;
}
function Bs(s) {
  return s instanceof Array || Object.prototype.toString.call(s) === "[object Array]";
}
function Yc(s) {
  return s != null && Object.prototype.toString.call(s) === "[object Object]";
}
function En(s, u) {
  return Object.prototype.hasOwnProperty.call(s, u);
}
function j1(s) {
  if (Object.getOwnPropertyNames)
    return Object.getOwnPropertyNames(s).length === 0;
  var u;
  for (u in s)
    if (En(s, u))
      return !1;
  return !0;
}
function Oa(s) {
  return s === void 0;
}
function El(s) {
  return typeof s == "number" || Object.prototype.toString.call(s) === "[object Number]";
}
function wg(s) {
  return s instanceof Date || Object.prototype.toString.call(s) === "[object Date]";
}
function DE(s, u) {
  var h = [], v, w = s.length;
  for (v = 0; v < w; ++v)
    h.push(u(s[v], v));
  return h;
}
function Ru(s, u) {
  for (var h in u)
    En(u, h) && (s[h] = u[h]);
  return En(u, "toString") && (s.toString = u.toString), En(u, "valueOf") && (s.valueOf = u.valueOf), s;
}
function Oo(s, u, h, v) {
  return tR(s, u, h, v, !0).utc();
}
function _N() {
  return {
    empty: !1,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: !1,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: !1,
    userInvalidated: !1,
    iso: !1,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: !1,
    weekdayMismatch: !1
  };
}
function rn(s) {
  return s._pf == null && (s._pf = _N()), s._pf;
}
var p1;
Array.prototype.some ? p1 = Array.prototype.some : p1 = function(s) {
  var u = Object(this), h = u.length >>> 0, v;
  for (v = 0; v < h; v++)
    if (v in u && s.call(this, u[v], v, u))
      return !0;
  return !1;
};
function U1(s) {
  if (s._isValid == null) {
    var u = rn(s), h = p1.call(u.parsedDateParts, function(w) {
      return w != null;
    }), v = !isNaN(s._d.getTime()) && u.overflow < 0 && !u.empty && !u.invalidEra && !u.invalidMonth && !u.invalidWeekday && !u.weekdayMismatch && !u.nullInput && !u.invalidFormat && !u.userInvalidated && (!u.meridiem || u.meridiem && h);
    if (s._strict && (v = v && u.charsLeftOver === 0 && u.unusedTokens.length === 0 && u.bigHour === void 0), Object.isFrozen == null || !Object.isFrozen(s))
      s._isValid = v;
    else
      return v;
  }
  return s._isValid;
}
function Zy(s) {
  var u = Oo(NaN);
  return s != null ? Ru(rn(u), s) : rn(u).userInvalidated = !0, u;
}
var bT = ct.momentProperties = [], Uw = !1;
function B1(s, u) {
  var h, v, w, C = bT.length;
  if (Oa(u._isAMomentObject) || (s._isAMomentObject = u._isAMomentObject), Oa(u._i) || (s._i = u._i), Oa(u._f) || (s._f = u._f), Oa(u._l) || (s._l = u._l), Oa(u._strict) || (s._strict = u._strict), Oa(u._tzm) || (s._tzm = u._tzm), Oa(u._isUTC) || (s._isUTC = u._isUTC), Oa(u._offset) || (s._offset = u._offset), Oa(u._pf) || (s._pf = rn(u)), Oa(u._locale) || (s._locale = u._locale), C > 0)
    for (h = 0; h < C; h++)
      v = bT[h], w = u[v], Oa(w) || (s[v] = w);
  return s;
}
function Sg(s) {
  B1(this, s), this._d = new Date(s._d != null ? s._d.getTime() : NaN), this.isValid() || (this._d = /* @__PURE__ */ new Date(NaN)), Uw === !1 && (Uw = !0, ct.updateOffset(this), Uw = !1);
}
function Ws(s) {
  return s instanceof Sg || s != null && s._isAMomentObject != null;
}
function OE(s) {
  ct.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn("Deprecation warning: " + s);
}
function ls(s, u) {
  var h = !0;
  return Ru(function() {
    if (ct.deprecationHandler != null && ct.deprecationHandler(null, s), h) {
      var v = [], w, C, T, F = arguments.length;
      for (C = 0; C < F; C++) {
        if (w = "", typeof arguments[C] == "object") {
          w += `
[` + C + "] ";
          for (T in arguments[0])
            En(arguments[0], T) && (w += T + ": " + arguments[0][T] + ", ");
          w = w.slice(0, -2);
        } else
          w = arguments[C];
        v.push(w);
      }
      OE(
        s + `
Arguments: ` + Array.prototype.slice.call(v).join("") + `
` + new Error().stack
      ), h = !1;
    }
    return u.apply(this, arguments);
  }, u);
}
var wT = {};
function _E(s, u) {
  ct.deprecationHandler != null && ct.deprecationHandler(s, u), wT[s] || (OE(u), wT[s] = !0);
}
ct.suppressDeprecationWarnings = !1;
ct.deprecationHandler = null;
function _o(s) {
  return typeof Function < "u" && s instanceof Function || Object.prototype.toString.call(s) === "[object Function]";
}
function PN(s) {
  var u, h;
  for (h in s)
    En(s, h) && (u = s[h], _o(u) ? this[h] = u : this["_" + h] = u);
  this._config = s, this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function g1(s, u) {
  var h = Ru({}, s), v;
  for (v in u)
    En(u, v) && (Yc(s[v]) && Yc(u[v]) ? (h[v] = {}, Ru(h[v], s[v]), Ru(h[v], u[v])) : u[v] != null ? h[v] = u[v] : delete h[v]);
  for (v in s)
    En(s, v) && !En(u, v) && Yc(s[v]) && (h[v] = Ru({}, h[v]));
  return h;
}
function W1(s) {
  s != null && this.set(s);
}
var v1;
Object.keys ? v1 = Object.keys : v1 = function(s) {
  var u, h = [];
  for (u in s)
    En(s, u) && h.push(u);
  return h;
};
var NN = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function zN(s, u, h) {
  var v = this._calendar[s] || this._calendar.sameElse;
  return _o(v) ? v.call(u, h) : v;
}
function Do(s, u, h) {
  var v = "" + Math.abs(s), w = u - v.length, C = s >= 0;
  return (C ? h ? "+" : "" : "-") + Math.pow(10, Math.max(0, w)).toString().substr(1) + v;
}
var X1 = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, by = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, Bw = {}, If = {};
function zt(s, u, h, v) {
  var w = v;
  typeof v == "string" && (w = function() {
    return this[v]();
  }), s && (If[s] = w), u && (If[u[0]] = function() {
    return Do(w.apply(this, arguments), u[1], u[2]);
  }), h && (If[h] = function() {
    return this.localeData().ordinal(
      w.apply(this, arguments),
      s
    );
  });
}
function IN(s) {
  return s.match(/\[[\s\S]/) ? s.replace(/^\[|\]$/g, "") : s.replace(/\\/g, "");
}
function FN(s) {
  var u = s.match(X1), h, v;
  for (h = 0, v = u.length; h < v; h++)
    If[u[h]] ? u[h] = If[u[h]] : u[h] = IN(u[h]);
  return function(w) {
    var C = "", T;
    for (T = 0; T < v; T++)
      C += _o(u[T]) ? u[T].call(w, s) : u[T];
    return C;
  };
}
function Ry(s, u) {
  return s.isValid() ? (u = PE(u, s.localeData()), Bw[u] = Bw[u] || FN(u), Bw[u](s)) : s.localeData().invalidDate();
}
function PE(s, u) {
  var h = 5;
  function v(w) {
    return u.longDateFormat(w) || w;
  }
  for (by.lastIndex = 0; h >= 0 && by.test(s); )
    s = s.replace(
      by,
      v
    ), by.lastIndex = 0, h -= 1;
  return s;
}
var YN = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function HN(s) {
  var u = this._longDateFormat[s], h = this._longDateFormat[s.toUpperCase()];
  return u || !h ? u : (this._longDateFormat[s] = h.match(X1).map(function(v) {
    return v === "MMMM" || v === "MM" || v === "DD" || v === "dddd" ? v.slice(1) : v;
  }).join(""), this._longDateFormat[s]);
}
var jN = "Invalid date";
function UN() {
  return this._invalidDate;
}
var BN = "%d", WN = /\d{1,2}/;
function XN(s) {
  return this._ordinal.replace("%d", s);
}
var VN = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function GN(s, u, h, v) {
  var w = this._relativeTime[h];
  return _o(w) ? w(s, u, h, v) : w.replace(/%d/i, s);
}
function $N(s, u) {
  var h = this._relativeTime[s > 0 ? "future" : "past"];
  return _o(h) ? h(u) : h.replace(/%s/i, u);
}
var ug = {};
function $i(s, u) {
  var h = s.toLowerCase();
  ug[h] = ug[h + "s"] = ug[u] = s;
}
function us(s) {
  return typeof s == "string" ? ug[s] || ug[s.toLowerCase()] : void 0;
}
function V1(s) {
  var u = {}, h, v;
  for (v in s)
    En(s, v) && (h = us(v), h && (u[h] = s[v]));
  return u;
}
var NE = {};
function qi(s, u) {
  NE[s] = u;
}
function qN(s) {
  var u = [], h;
  for (h in s)
    En(s, h) && u.push({ unit: h, priority: NE[h] });
  return u.sort(function(v, w) {
    return v.priority - w.priority;
  }), u;
}
function Qy(s) {
  return s % 4 === 0 && s % 100 !== 0 || s % 400 === 0;
}
function os(s) {
  return s < 0 ? Math.ceil(s) || 0 : Math.floor(s);
}
function un(s) {
  var u = +s, h = 0;
  return u !== 0 && isFinite(u) && (h = os(u)), h;
}
function jf(s, u) {
  return function(h) {
    return h != null ? (zE(this, s, h), ct.updateOffset(this, u), this) : Hy(this, s);
  };
}
function Hy(s, u) {
  return s.isValid() ? s._d["get" + (s._isUTC ? "UTC" : "") + u]() : NaN;
}
function zE(s, u, h) {
  s.isValid() && !isNaN(h) && (u === "FullYear" && Qy(s.year()) && s.month() === 1 && s.date() === 29 ? (h = un(h), s._d["set" + (s._isUTC ? "UTC" : "") + u](
    h,
    s.month(),
    rx(h, s.month())
  )) : s._d["set" + (s._isUTC ? "UTC" : "") + u](h));
}
function ZN(s) {
  return s = us(s), _o(this[s]) ? this[s]() : this;
}
function QN(s, u) {
  if (typeof s == "object") {
    s = V1(s);
    var h = qN(s), v, w = h.length;
    for (v = 0; v < w; v++)
      this[h[v].unit](s[h[v].unit]);
  } else if (s = us(s), _o(this[s]))
    return this[s](u);
  return this;
}
var IE = /\d/, Va = /\d\d/, FE = /\d{3}/, G1 = /\d{4}/, Ky = /[+-]?\d{6}/, rr = /\d\d?/, YE = /\d\d\d\d?/, HE = /\d\d\d\d\d\d?/, Jy = /\d{1,3}/, $1 = /\d{1,4}/, ex = /[+-]?\d{1,6}/, Uf = /\d+/, tx = /[+-]?\d+/, KN = /Z|[+-]\d\d:?\d\d/gi, nx = /Z|[+-]\d\d(?::?\d\d)?/gi, JN = /[+-]?\d+(\.\d{1,3})?/, kg = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, jy;
jy = {};
function mt(s, u, h) {
  jy[s] = _o(u) ? u : function(v, w) {
    return v && h ? h : u;
  };
}
function ez(s, u) {
  return En(jy, s) ? jy[s](u._strict, u._locale) : new RegExp(tz(s));
}
function tz(s) {
  return Xa(
    s.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(u, h, v, w, C) {
        return h || v || w || C;
      }
    )
  );
}
function Xa(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var m1 = {};
function Hn(s, u) {
  var h, v = u, w;
  for (typeof s == "string" && (s = [s]), El(u) && (v = function(C, T) {
    T[u] = un(C);
  }), w = s.length, h = 0; h < w; h++)
    m1[s[h]] = v;
}
function Cg(s, u) {
  Hn(s, function(h, v, w, C) {
    w._w = w._w || {}, u(h, w._w, w, C);
  });
}
function nz(s, u, h) {
  u != null && En(m1, s) && m1[s](u, h._a, h, s);
}
var Gi = 0, Cl = 1, Lo = 2, ei = 3, Us = 4, Al = 5, Fc = 6, rz = 7, iz = 8;
function az(s, u) {
  return (s % u + u) % u;
}
var Mr;
Array.prototype.indexOf ? Mr = Array.prototype.indexOf : Mr = function(s) {
  var u;
  for (u = 0; u < this.length; ++u)
    if (this[u] === s)
      return u;
  return -1;
};
function rx(s, u) {
  if (isNaN(s) || isNaN(u))
    return NaN;
  var h = az(u, 12);
  return s += (u - h) / 12, h === 1 ? Qy(s) ? 29 : 28 : 31 - h % 7 % 2;
}
zt("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
zt("MMM", 0, 0, function(s) {
  return this.localeData().monthsShort(this, s);
});
zt("MMMM", 0, 0, function(s) {
  return this.localeData().months(this, s);
});
$i("month", "M");
qi("month", 8);
mt("M", rr);
mt("MM", rr, Va);
mt("MMM", function(s, u) {
  return u.monthsShortRegex(s);
});
mt("MMMM", function(s, u) {
  return u.monthsRegex(s);
});
Hn(["M", "MM"], function(s, u) {
  u[Cl] = un(s) - 1;
});
Hn(["MMM", "MMMM"], function(s, u, h, v) {
  var w = h._locale.monthsParse(s, v, h._strict);
  w != null ? u[Cl] = w : rn(h).invalidMonth = s;
});
var sz = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), jE = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), UE = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, oz = kg, lz = kg;
function uz(s, u) {
  return s ? Bs(this._months) ? this._months[s.month()] : this._months[(this._months.isFormat || UE).test(u) ? "format" : "standalone"][s.month()] : Bs(this._months) ? this._months : this._months.standalone;
}
function cz(s, u) {
  return s ? Bs(this._monthsShort) ? this._monthsShort[s.month()] : this._monthsShort[UE.test(u) ? "format" : "standalone"][s.month()] : Bs(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
}
function dz(s, u, h) {
  var v, w, C, T = s.toLocaleLowerCase();
  if (!this._monthsParse)
    for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], v = 0; v < 12; ++v)
      C = Oo([2e3, v]), this._shortMonthsParse[v] = this.monthsShort(
        C,
        ""
      ).toLocaleLowerCase(), this._longMonthsParse[v] = this.months(C, "").toLocaleLowerCase();
  return h ? u === "MMM" ? (w = Mr.call(this._shortMonthsParse, T), w !== -1 ? w : null) : (w = Mr.call(this._longMonthsParse, T), w !== -1 ? w : null) : u === "MMM" ? (w = Mr.call(this._shortMonthsParse, T), w !== -1 ? w : (w = Mr.call(this._longMonthsParse, T), w !== -1 ? w : null)) : (w = Mr.call(this._longMonthsParse, T), w !== -1 ? w : (w = Mr.call(this._shortMonthsParse, T), w !== -1 ? w : null));
}
function fz(s, u, h) {
  var v, w, C;
  if (this._monthsParseExact)
    return dz.call(this, s, u, h);
  for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), v = 0; v < 12; v++) {
    if (w = Oo([2e3, v]), h && !this._longMonthsParse[v] && (this._longMonthsParse[v] = new RegExp(
      "^" + this.months(w, "").replace(".", "") + "$",
      "i"
    ), this._shortMonthsParse[v] = new RegExp(
      "^" + this.monthsShort(w, "").replace(".", "") + "$",
      "i"
    )), !h && !this._monthsParse[v] && (C = "^" + this.months(w, "") + "|^" + this.monthsShort(w, ""), this._monthsParse[v] = new RegExp(C.replace(".", ""), "i")), h && u === "MMMM" && this._longMonthsParse[v].test(s))
      return v;
    if (h && u === "MMM" && this._shortMonthsParse[v].test(s))
      return v;
    if (!h && this._monthsParse[v].test(s))
      return v;
  }
}
function BE(s, u) {
  var h;
  if (!s.isValid())
    return s;
  if (typeof u == "string") {
    if (/^\d+$/.test(u))
      u = un(u);
    else if (u = s.localeData().monthsParse(u), !El(u))
      return s;
  }
  return h = Math.min(s.date(), rx(s.year(), u)), s._d["set" + (s._isUTC ? "UTC" : "") + "Month"](u, h), s;
}
function WE(s) {
  return s != null ? (BE(this, s), ct.updateOffset(this, !0), this) : Hy(this, "Month");
}
function hz() {
  return rx(this.year(), this.month());
}
function pz(s) {
  return this._monthsParseExact ? (En(this, "_monthsRegex") || XE.call(this), s ? this._monthsShortStrictRegex : this._monthsShortRegex) : (En(this, "_monthsShortRegex") || (this._monthsShortRegex = oz), this._monthsShortStrictRegex && s ? this._monthsShortStrictRegex : this._monthsShortRegex);
}
function gz(s) {
  return this._monthsParseExact ? (En(this, "_monthsRegex") || XE.call(this), s ? this._monthsStrictRegex : this._monthsRegex) : (En(this, "_monthsRegex") || (this._monthsRegex = lz), this._monthsStrictRegex && s ? this._monthsStrictRegex : this._monthsRegex);
}
function XE() {
  function s(T, F) {
    return F.length - T.length;
  }
  var u = [], h = [], v = [], w, C;
  for (w = 0; w < 12; w++)
    C = Oo([2e3, w]), u.push(this.monthsShort(C, "")), h.push(this.months(C, "")), v.push(this.months(C, "")), v.push(this.monthsShort(C, ""));
  for (u.sort(s), h.sort(s), v.sort(s), w = 0; w < 12; w++)
    u[w] = Xa(u[w]), h[w] = Xa(h[w]);
  for (w = 0; w < 24; w++)
    v[w] = Xa(v[w]);
  this._monthsRegex = new RegExp("^(" + v.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp(
    "^(" + h.join("|") + ")",
    "i"
  ), this._monthsShortStrictRegex = new RegExp(
    "^(" + u.join("|") + ")",
    "i"
  );
}
zt("Y", 0, 0, function() {
  var s = this.year();
  return s <= 9999 ? Do(s, 4) : "+" + s;
});
zt(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
zt(0, ["YYYY", 4], 0, "year");
zt(0, ["YYYYY", 5], 0, "year");
zt(0, ["YYYYYY", 6, !0], 0, "year");
$i("year", "y");
qi("year", 1);
mt("Y", tx);
mt("YY", rr, Va);
mt("YYYY", $1, G1);
mt("YYYYY", ex, Ky);
mt("YYYYYY", ex, Ky);
Hn(["YYYYY", "YYYYYY"], Gi);
Hn("YYYY", function(s, u) {
  u[Gi] = s.length === 2 ? ct.parseTwoDigitYear(s) : un(s);
});
Hn("YY", function(s, u) {
  u[Gi] = ct.parseTwoDigitYear(s);
});
Hn("Y", function(s, u) {
  u[Gi] = parseInt(s, 10);
});
function cg(s) {
  return Qy(s) ? 366 : 365;
}
ct.parseTwoDigitYear = function(s) {
  return un(s) + (un(s) > 68 ? 1900 : 2e3);
};
var VE = jf("FullYear", !0);
function vz() {
  return Qy(this.year());
}
function mz(s, u, h, v, w, C, T) {
  var F;
  return s < 100 && s >= 0 ? (F = new Date(s + 400, u, h, v, w, C, T), isFinite(F.getFullYear()) && F.setFullYear(s)) : F = new Date(s, u, h, v, w, C, T), F;
}
function vg(s) {
  var u, h;
  return s < 100 && s >= 0 ? (h = Array.prototype.slice.call(arguments), h[0] = s + 400, u = new Date(Date.UTC.apply(null, h)), isFinite(u.getUTCFullYear()) && u.setUTCFullYear(s)) : u = new Date(Date.UTC.apply(null, arguments)), u;
}
function Uy(s, u, h) {
  var v = 7 + u - h, w = (7 + vg(s, 0, v).getUTCDay() - u) % 7;
  return -w + v - 1;
}
function GE(s, u, h, v, w) {
  var C = (7 + h - v) % 7, T = Uy(s, v, w), F = 1 + 7 * (u - 1) + C + T, Y, U;
  return F <= 0 ? (Y = s - 1, U = cg(Y) + F) : F > cg(s) ? (Y = s + 1, U = F - cg(s)) : (Y = s, U = F), {
    year: Y,
    dayOfYear: U
  };
}
function mg(s, u, h) {
  var v = Uy(s.year(), u, h), w = Math.floor((s.dayOfYear() - v - 1) / 7) + 1, C, T;
  return w < 1 ? (T = s.year() - 1, C = w + Tl(T, u, h)) : w > Tl(s.year(), u, h) ? (C = w - Tl(s.year(), u, h), T = s.year() + 1) : (T = s.year(), C = w), {
    week: C,
    year: T
  };
}
function Tl(s, u, h) {
  var v = Uy(s, u, h), w = Uy(s + 1, u, h);
  return (cg(s) - v + w) / 7;
}
zt("w", ["ww", 2], "wo", "week");
zt("W", ["WW", 2], "Wo", "isoWeek");
$i("week", "w");
$i("isoWeek", "W");
qi("week", 5);
qi("isoWeek", 5);
mt("w", rr);
mt("ww", rr, Va);
mt("W", rr);
mt("WW", rr, Va);
Cg(
  ["w", "ww", "W", "WW"],
  function(s, u, h, v) {
    u[v.substr(0, 1)] = un(s);
  }
);
function yz(s) {
  return mg(s, this._week.dow, this._week.doy).week;
}
var xz = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function bz() {
  return this._week.dow;
}
function wz() {
  return this._week.doy;
}
function Sz(s) {
  var u = this.localeData().week(this);
  return s == null ? u : this.add((s - u) * 7, "d");
}
function kz(s) {
  var u = mg(this, 1, 4).week;
  return s == null ? u : this.add((s - u) * 7, "d");
}
zt("d", 0, "do", "day");
zt("dd", 0, 0, function(s) {
  return this.localeData().weekdaysMin(this, s);
});
zt("ddd", 0, 0, function(s) {
  return this.localeData().weekdaysShort(this, s);
});
zt("dddd", 0, 0, function(s) {
  return this.localeData().weekdays(this, s);
});
zt("e", 0, 0, "weekday");
zt("E", 0, 0, "isoWeekday");
$i("day", "d");
$i("weekday", "e");
$i("isoWeekday", "E");
qi("day", 11);
qi("weekday", 11);
qi("isoWeekday", 11);
mt("d", rr);
mt("e", rr);
mt("E", rr);
mt("dd", function(s, u) {
  return u.weekdaysMinRegex(s);
});
mt("ddd", function(s, u) {
  return u.weekdaysShortRegex(s);
});
mt("dddd", function(s, u) {
  return u.weekdaysRegex(s);
});
Cg(["dd", "ddd", "dddd"], function(s, u, h, v) {
  var w = h._locale.weekdaysParse(s, v, h._strict);
  w != null ? u.d = w : rn(h).invalidWeekday = s;
});
Cg(["d", "e", "E"], function(s, u, h, v) {
  u[v] = un(s);
});
function Cz(s, u) {
  return typeof s != "string" ? s : isNaN(s) ? (s = u.weekdaysParse(s), typeof s == "number" ? s : null) : parseInt(s, 10);
}
function Az(s, u) {
  return typeof s == "string" ? u.weekdaysParse(s) % 7 || 7 : isNaN(s) ? null : s;
}
function q1(s, u) {
  return s.slice(u, 7).concat(s.slice(0, u));
}
var Tz = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), $E = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), Ez = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), Rz = kg, Lz = kg, Mz = kg;
function Dz(s, u) {
  var h = Bs(this._weekdays) ? this._weekdays : this._weekdays[s && s !== !0 && this._weekdays.isFormat.test(u) ? "format" : "standalone"];
  return s === !0 ? q1(h, this._week.dow) : s ? h[s.day()] : h;
}
function Oz(s) {
  return s === !0 ? q1(this._weekdaysShort, this._week.dow) : s ? this._weekdaysShort[s.day()] : this._weekdaysShort;
}
function _z(s) {
  return s === !0 ? q1(this._weekdaysMin, this._week.dow) : s ? this._weekdaysMin[s.day()] : this._weekdaysMin;
}
function Pz(s, u, h) {
  var v, w, C, T = s.toLocaleLowerCase();
  if (!this._weekdaysParse)
    for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], v = 0; v < 7; ++v)
      C = Oo([2e3, 1]).day(v), this._minWeekdaysParse[v] = this.weekdaysMin(
        C,
        ""
      ).toLocaleLowerCase(), this._shortWeekdaysParse[v] = this.weekdaysShort(
        C,
        ""
      ).toLocaleLowerCase(), this._weekdaysParse[v] = this.weekdays(C, "").toLocaleLowerCase();
  return h ? u === "dddd" ? (w = Mr.call(this._weekdaysParse, T), w !== -1 ? w : null) : u === "ddd" ? (w = Mr.call(this._shortWeekdaysParse, T), w !== -1 ? w : null) : (w = Mr.call(this._minWeekdaysParse, T), w !== -1 ? w : null) : u === "dddd" ? (w = Mr.call(this._weekdaysParse, T), w !== -1 || (w = Mr.call(this._shortWeekdaysParse, T), w !== -1) ? w : (w = Mr.call(this._minWeekdaysParse, T), w !== -1 ? w : null)) : u === "ddd" ? (w = Mr.call(this._shortWeekdaysParse, T), w !== -1 || (w = Mr.call(this._weekdaysParse, T), w !== -1) ? w : (w = Mr.call(this._minWeekdaysParse, T), w !== -1 ? w : null)) : (w = Mr.call(this._minWeekdaysParse, T), w !== -1 || (w = Mr.call(this._weekdaysParse, T), w !== -1) ? w : (w = Mr.call(this._shortWeekdaysParse, T), w !== -1 ? w : null));
}
function Nz(s, u, h) {
  var v, w, C;
  if (this._weekdaysParseExact)
    return Pz.call(this, s, u, h);
  for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), v = 0; v < 7; v++) {
    if (w = Oo([2e3, 1]).day(v), h && !this._fullWeekdaysParse[v] && (this._fullWeekdaysParse[v] = new RegExp(
      "^" + this.weekdays(w, "").replace(".", "\\.?") + "$",
      "i"
    ), this._shortWeekdaysParse[v] = new RegExp(
      "^" + this.weekdaysShort(w, "").replace(".", "\\.?") + "$",
      "i"
    ), this._minWeekdaysParse[v] = new RegExp(
      "^" + this.weekdaysMin(w, "").replace(".", "\\.?") + "$",
      "i"
    )), this._weekdaysParse[v] || (C = "^" + this.weekdays(w, "") + "|^" + this.weekdaysShort(w, "") + "|^" + this.weekdaysMin(w, ""), this._weekdaysParse[v] = new RegExp(C.replace(".", ""), "i")), h && u === "dddd" && this._fullWeekdaysParse[v].test(s))
      return v;
    if (h && u === "ddd" && this._shortWeekdaysParse[v].test(s))
      return v;
    if (h && u === "dd" && this._minWeekdaysParse[v].test(s))
      return v;
    if (!h && this._weekdaysParse[v].test(s))
      return v;
  }
}
function zz(s) {
  if (!this.isValid())
    return s != null ? this : NaN;
  var u = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  return s != null ? (s = Cz(s, this.localeData()), this.add(s - u, "d")) : u;
}
function Iz(s) {
  if (!this.isValid())
    return s != null ? this : NaN;
  var u = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return s == null ? u : this.add(s - u, "d");
}
function Fz(s) {
  if (!this.isValid())
    return s != null ? this : NaN;
  if (s != null) {
    var u = Az(s, this.localeData());
    return this.day(this.day() % 7 ? u : u - 7);
  } else
    return this.day() || 7;
}
function Yz(s) {
  return this._weekdaysParseExact ? (En(this, "_weekdaysRegex") || Z1.call(this), s ? this._weekdaysStrictRegex : this._weekdaysRegex) : (En(this, "_weekdaysRegex") || (this._weekdaysRegex = Rz), this._weekdaysStrictRegex && s ? this._weekdaysStrictRegex : this._weekdaysRegex);
}
function Hz(s) {
  return this._weekdaysParseExact ? (En(this, "_weekdaysRegex") || Z1.call(this), s ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (En(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = Lz), this._weekdaysShortStrictRegex && s ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
}
function jz(s) {
  return this._weekdaysParseExact ? (En(this, "_weekdaysRegex") || Z1.call(this), s ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (En(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = Mz), this._weekdaysMinStrictRegex && s ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
}
function Z1() {
  function s(G, q) {
    return q.length - G.length;
  }
  var u = [], h = [], v = [], w = [], C, T, F, Y, U;
  for (C = 0; C < 7; C++)
    T = Oo([2e3, 1]).day(C), F = Xa(this.weekdaysMin(T, "")), Y = Xa(this.weekdaysShort(T, "")), U = Xa(this.weekdays(T, "")), u.push(F), h.push(Y), v.push(U), w.push(F), w.push(Y), w.push(U);
  u.sort(s), h.sort(s), v.sort(s), w.sort(s), this._weekdaysRegex = new RegExp("^(" + w.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp(
    "^(" + v.join("|") + ")",
    "i"
  ), this._weekdaysShortStrictRegex = new RegExp(
    "^(" + h.join("|") + ")",
    "i"
  ), this._weekdaysMinStrictRegex = new RegExp(
    "^(" + u.join("|") + ")",
    "i"
  );
}
function Q1() {
  return this.hours() % 12 || 12;
}
function Uz() {
  return this.hours() || 24;
}
zt("H", ["HH", 2], 0, "hour");
zt("h", ["hh", 2], 0, Q1);
zt("k", ["kk", 2], 0, Uz);
zt("hmm", 0, 0, function() {
  return "" + Q1.apply(this) + Do(this.minutes(), 2);
});
zt("hmmss", 0, 0, function() {
  return "" + Q1.apply(this) + Do(this.minutes(), 2) + Do(this.seconds(), 2);
});
zt("Hmm", 0, 0, function() {
  return "" + this.hours() + Do(this.minutes(), 2);
});
zt("Hmmss", 0, 0, function() {
  return "" + this.hours() + Do(this.minutes(), 2) + Do(this.seconds(), 2);
});
function qE(s, u) {
  zt(s, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      u
    );
  });
}
qE("a", !0);
qE("A", !1);
$i("hour", "h");
qi("hour", 13);
function ZE(s, u) {
  return u._meridiemParse;
}
mt("a", ZE);
mt("A", ZE);
mt("H", rr);
mt("h", rr);
mt("k", rr);
mt("HH", rr, Va);
mt("hh", rr, Va);
mt("kk", rr, Va);
mt("hmm", YE);
mt("hmmss", HE);
mt("Hmm", YE);
mt("Hmmss", HE);
Hn(["H", "HH"], ei);
Hn(["k", "kk"], function(s, u, h) {
  var v = un(s);
  u[ei] = v === 24 ? 0 : v;
});
Hn(["a", "A"], function(s, u, h) {
  h._isPm = h._locale.isPM(s), h._meridiem = s;
});
Hn(["h", "hh"], function(s, u, h) {
  u[ei] = un(s), rn(h).bigHour = !0;
});
Hn("hmm", function(s, u, h) {
  var v = s.length - 2;
  u[ei] = un(s.substr(0, v)), u[Us] = un(s.substr(v)), rn(h).bigHour = !0;
});
Hn("hmmss", function(s, u, h) {
  var v = s.length - 4, w = s.length - 2;
  u[ei] = un(s.substr(0, v)), u[Us] = un(s.substr(v, 2)), u[Al] = un(s.substr(w)), rn(h).bigHour = !0;
});
Hn("Hmm", function(s, u, h) {
  var v = s.length - 2;
  u[ei] = un(s.substr(0, v)), u[Us] = un(s.substr(v));
});
Hn("Hmmss", function(s, u, h) {
  var v = s.length - 4, w = s.length - 2;
  u[ei] = un(s.substr(0, v)), u[Us] = un(s.substr(v, 2)), u[Al] = un(s.substr(w));
});
function Bz(s) {
  return (s + "").toLowerCase().charAt(0) === "p";
}
var Wz = /[ap]\.?m?\.?/i, Xz = jf("Hours", !0);
function Vz(s, u, h) {
  return s > 11 ? h ? "pm" : "PM" : h ? "am" : "AM";
}
var QE = {
  calendar: NN,
  longDateFormat: YN,
  invalidDate: jN,
  ordinal: BN,
  dayOfMonthOrdinalParse: WN,
  relativeTime: VN,
  months: sz,
  monthsShort: jE,
  week: xz,
  weekdays: Tz,
  weekdaysMin: Ez,
  weekdaysShort: $E,
  meridiemParse: Wz
}, cr = {}, rg = {}, yg;
function Gz(s, u) {
  var h, v = Math.min(s.length, u.length);
  for (h = 0; h < v; h += 1)
    if (s[h] !== u[h])
      return h;
  return v;
}
function ST(s) {
  return s && s.toLowerCase().replace("_", "-");
}
function $z(s) {
  for (var u = 0, h, v, w, C; u < s.length; ) {
    for (C = ST(s[u]).split("-"), h = C.length, v = ST(s[u + 1]), v = v ? v.split("-") : null; h > 0; ) {
      if (w = ix(C.slice(0, h).join("-")), w)
        return w;
      if (v && v.length >= h && Gz(C, v) >= h - 1)
        break;
      h--;
    }
    u++;
  }
  return yg;
}
function qz(s) {
  return s.match("^[^/\\\\]*$") != null;
}
function ix(s) {
  var u = null, h;
  if (cr[s] === void 0 && typeof module < "u" && module && module.exports && qz(s))
    try {
      u = yg._abbr, h = require, h("./locale/" + s), Mu(u);
    } catch {
      cr[s] = null;
    }
  return cr[s];
}
function Mu(s, u) {
  var h;
  return s && (Oa(u) ? h = Rl(s) : h = K1(s, u), h ? yg = h : typeof console < "u" && console.warn && console.warn(
    "Locale " + s + " not found. Did you forget to load it?"
  )), yg._abbr;
}
function K1(s, u) {
  if (u !== null) {
    var h, v = QE;
    if (u.abbr = s, cr[s] != null)
      _E(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      ), v = cr[s]._config;
    else if (u.parentLocale != null)
      if (cr[u.parentLocale] != null)
        v = cr[u.parentLocale]._config;
      else if (h = ix(u.parentLocale), h != null)
        v = h._config;
      else
        return rg[u.parentLocale] || (rg[u.parentLocale] = []), rg[u.parentLocale].push({
          name: s,
          config: u
        }), null;
    return cr[s] = new W1(g1(v, u)), rg[s] && rg[s].forEach(function(w) {
      K1(w.name, w.config);
    }), Mu(s), cr[s];
  } else
    return delete cr[s], null;
}
function Zz(s, u) {
  if (u != null) {
    var h, v, w = QE;
    cr[s] != null && cr[s].parentLocale != null ? cr[s].set(g1(cr[s]._config, u)) : (v = ix(s), v != null && (w = v._config), u = g1(w, u), v == null && (u.abbr = s), h = new W1(u), h.parentLocale = cr[s], cr[s] = h), Mu(s);
  } else
    cr[s] != null && (cr[s].parentLocale != null ? (cr[s] = cr[s].parentLocale, s === Mu() && Mu(s)) : cr[s] != null && delete cr[s]);
  return cr[s];
}
function Rl(s) {
  var u;
  if (s && s._locale && s._locale._abbr && (s = s._locale._abbr), !s)
    return yg;
  if (!Bs(s)) {
    if (u = ix(s), u)
      return u;
    s = [s];
  }
  return $z(s);
}
function Qz() {
  return v1(cr);
}
function J1(s) {
  var u, h = s._a;
  return h && rn(s).overflow === -2 && (u = h[Cl] < 0 || h[Cl] > 11 ? Cl : h[Lo] < 1 || h[Lo] > rx(h[Gi], h[Cl]) ? Lo : h[ei] < 0 || h[ei] > 24 || h[ei] === 24 && (h[Us] !== 0 || h[Al] !== 0 || h[Fc] !== 0) ? ei : h[Us] < 0 || h[Us] > 59 ? Us : h[Al] < 0 || h[Al] > 59 ? Al : h[Fc] < 0 || h[Fc] > 999 ? Fc : -1, rn(s)._overflowDayOfYear && (u < Gi || u > Lo) && (u = Lo), rn(s)._overflowWeeks && u === -1 && (u = rz), rn(s)._overflowWeekday && u === -1 && (u = iz), rn(s).overflow = u), s;
}
var Kz = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, Jz = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, eI = /Z|[+-]\d\d(?::?\d\d)?/, wy = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, !1],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, !1],
  ["YYYY", /\d{4}/, !1]
], Ww = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], tI = /^\/?Date\((-?\d+)/i, nI = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, rI = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function KE(s) {
  var u, h, v = s._i, w = Kz.exec(v) || Jz.exec(v), C, T, F, Y, U = wy.length, G = Ww.length;
  if (w) {
    for (rn(s).iso = !0, u = 0, h = U; u < h; u++)
      if (wy[u][1].exec(w[1])) {
        T = wy[u][0], C = wy[u][2] !== !1;
        break;
      }
    if (T == null) {
      s._isValid = !1;
      return;
    }
    if (w[3]) {
      for (u = 0, h = G; u < h; u++)
        if (Ww[u][1].exec(w[3])) {
          F = (w[2] || " ") + Ww[u][0];
          break;
        }
      if (F == null) {
        s._isValid = !1;
        return;
      }
    }
    if (!C && F != null) {
      s._isValid = !1;
      return;
    }
    if (w[4])
      if (eI.exec(w[4]))
        Y = "Z";
      else {
        s._isValid = !1;
        return;
      }
    s._f = T + (F || "") + (Y || ""), tS(s);
  } else
    s._isValid = !1;
}
function iI(s, u, h, v, w, C) {
  var T = [
    aI(s),
    jE.indexOf(u),
    parseInt(h, 10),
    parseInt(v, 10),
    parseInt(w, 10)
  ];
  return C && T.push(parseInt(C, 10)), T;
}
function aI(s) {
  var u = parseInt(s, 10);
  return u <= 49 ? 2e3 + u : u <= 999 ? 1900 + u : u;
}
function sI(s) {
  return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function oI(s, u, h) {
  if (s) {
    var v = $E.indexOf(s), w = new Date(
      u[0],
      u[1],
      u[2]
    ).getDay();
    if (v !== w)
      return rn(h).weekdayMismatch = !0, h._isValid = !1, !1;
  }
  return !0;
}
function lI(s, u, h) {
  if (s)
    return rI[s];
  if (u)
    return 0;
  var v = parseInt(h, 10), w = v % 100, C = (v - w) / 100;
  return C * 60 + w;
}
function JE(s) {
  var u = nI.exec(sI(s._i)), h;
  if (u) {
    if (h = iI(
      u[4],
      u[3],
      u[2],
      u[5],
      u[6],
      u[7]
    ), !oI(u[1], h, s))
      return;
    s._a = h, s._tzm = lI(u[8], u[9], u[10]), s._d = vg.apply(null, s._a), s._d.setUTCMinutes(s._d.getUTCMinutes() - s._tzm), rn(s).rfc2822 = !0;
  } else
    s._isValid = !1;
}
function uI(s) {
  var u = tI.exec(s._i);
  if (u !== null) {
    s._d = /* @__PURE__ */ new Date(+u[1]);
    return;
  }
  if (KE(s), s._isValid === !1)
    delete s._isValid;
  else
    return;
  if (JE(s), s._isValid === !1)
    delete s._isValid;
  else
    return;
  s._strict ? s._isValid = !1 : ct.createFromInputFallback(s);
}
ct.createFromInputFallback = ls(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(s) {
    s._d = /* @__PURE__ */ new Date(s._i + (s._useUTC ? " UTC" : ""));
  }
);
function Nf(s, u, h) {
  return s ?? u ?? h;
}
function cI(s) {
  var u = new Date(ct.now());
  return s._useUTC ? [
    u.getUTCFullYear(),
    u.getUTCMonth(),
    u.getUTCDate()
  ] : [u.getFullYear(), u.getMonth(), u.getDate()];
}
function eS(s) {
  var u, h, v = [], w, C, T;
  if (!s._d) {
    for (w = cI(s), s._w && s._a[Lo] == null && s._a[Cl] == null && dI(s), s._dayOfYear != null && (T = Nf(s._a[Gi], w[Gi]), (s._dayOfYear > cg(T) || s._dayOfYear === 0) && (rn(s)._overflowDayOfYear = !0), h = vg(T, 0, s._dayOfYear), s._a[Cl] = h.getUTCMonth(), s._a[Lo] = h.getUTCDate()), u = 0; u < 3 && s._a[u] == null; ++u)
      s._a[u] = v[u] = w[u];
    for (; u < 7; u++)
      s._a[u] = v[u] = s._a[u] == null ? u === 2 ? 1 : 0 : s._a[u];
    s._a[ei] === 24 && s._a[Us] === 0 && s._a[Al] === 0 && s._a[Fc] === 0 && (s._nextDay = !0, s._a[ei] = 0), s._d = (s._useUTC ? vg : mz).apply(
      null,
      v
    ), C = s._useUTC ? s._d.getUTCDay() : s._d.getDay(), s._tzm != null && s._d.setUTCMinutes(s._d.getUTCMinutes() - s._tzm), s._nextDay && (s._a[ei] = 24), s._w && typeof s._w.d < "u" && s._w.d !== C && (rn(s).weekdayMismatch = !0);
  }
}
function dI(s) {
  var u, h, v, w, C, T, F, Y, U;
  u = s._w, u.GG != null || u.W != null || u.E != null ? (C = 1, T = 4, h = Nf(
    u.GG,
    s._a[Gi],
    mg(nr(), 1, 4).year
  ), v = Nf(u.W, 1), w = Nf(u.E, 1), (w < 1 || w > 7) && (Y = !0)) : (C = s._locale._week.dow, T = s._locale._week.doy, U = mg(nr(), C, T), h = Nf(u.gg, s._a[Gi], U.year), v = Nf(u.w, U.week), u.d != null ? (w = u.d, (w < 0 || w > 6) && (Y = !0)) : u.e != null ? (w = u.e + C, (u.e < 0 || u.e > 6) && (Y = !0)) : w = C), v < 1 || v > Tl(h, C, T) ? rn(s)._overflowWeeks = !0 : Y != null ? rn(s)._overflowWeekday = !0 : (F = GE(h, v, w, C, T), s._a[Gi] = F.year, s._dayOfYear = F.dayOfYear);
}
ct.ISO_8601 = function() {
};
ct.RFC_2822 = function() {
};
function tS(s) {
  if (s._f === ct.ISO_8601) {
    KE(s);
    return;
  }
  if (s._f === ct.RFC_2822) {
    JE(s);
    return;
  }
  s._a = [], rn(s).empty = !0;
  var u = "" + s._i, h, v, w, C, T, F = u.length, Y = 0, U, G;
  for (w = PE(s._f, s._locale).match(X1) || [], G = w.length, h = 0; h < G; h++)
    C = w[h], v = (u.match(ez(C, s)) || [])[0], v && (T = u.substr(0, u.indexOf(v)), T.length > 0 && rn(s).unusedInput.push(T), u = u.slice(
      u.indexOf(v) + v.length
    ), Y += v.length), If[C] ? (v ? rn(s).empty = !1 : rn(s).unusedTokens.push(C), nz(C, v, s)) : s._strict && !v && rn(s).unusedTokens.push(C);
  rn(s).charsLeftOver = F - Y, u.length > 0 && rn(s).unusedInput.push(u), s._a[ei] <= 12 && rn(s).bigHour === !0 && s._a[ei] > 0 && (rn(s).bigHour = void 0), rn(s).parsedDateParts = s._a.slice(0), rn(s).meridiem = s._meridiem, s._a[ei] = fI(
    s._locale,
    s._a[ei],
    s._meridiem
  ), U = rn(s).era, U !== null && (s._a[Gi] = s._locale.erasConvertYear(U, s._a[Gi])), eS(s), J1(s);
}
function fI(s, u, h) {
  var v;
  return h == null ? u : s.meridiemHour != null ? s.meridiemHour(u, h) : (s.isPM != null && (v = s.isPM(h), v && u < 12 && (u += 12), !v && u === 12 && (u = 0)), u);
}
function hI(s) {
  var u, h, v, w, C, T, F = !1, Y = s._f.length;
  if (Y === 0) {
    rn(s).invalidFormat = !0, s._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (w = 0; w < Y; w++)
    C = 0, T = !1, u = B1({}, s), s._useUTC != null && (u._useUTC = s._useUTC), u._f = s._f[w], tS(u), U1(u) && (T = !0), C += rn(u).charsLeftOver, C += rn(u).unusedTokens.length * 10, rn(u).score = C, F ? C < v && (v = C, h = u) : (v == null || C < v || T) && (v = C, h = u, T && (F = !0));
  Ru(s, h || u);
}
function pI(s) {
  if (!s._d) {
    var u = V1(s._i), h = u.day === void 0 ? u.date : u.day;
    s._a = DE(
      [u.year, u.month, h, u.hour, u.minute, u.second, u.millisecond],
      function(v) {
        return v && parseInt(v, 10);
      }
    ), eS(s);
  }
}
function gI(s) {
  var u = new Sg(J1(eR(s)));
  return u._nextDay && (u.add(1, "d"), u._nextDay = void 0), u;
}
function eR(s) {
  var u = s._i, h = s._f;
  return s._locale = s._locale || Rl(s._l), u === null || h === void 0 && u === "" ? Zy({ nullInput: !0 }) : (typeof u == "string" && (s._i = u = s._locale.preparse(u)), Ws(u) ? new Sg(J1(u)) : (wg(u) ? s._d = u : Bs(h) ? hI(s) : h ? tS(s) : vI(s), U1(s) || (s._d = null), s));
}
function vI(s) {
  var u = s._i;
  Oa(u) ? s._d = new Date(ct.now()) : wg(u) ? s._d = new Date(u.valueOf()) : typeof u == "string" ? uI(s) : Bs(u) ? (s._a = DE(u.slice(0), function(h) {
    return parseInt(h, 10);
  }), eS(s)) : Yc(u) ? pI(s) : El(u) ? s._d = new Date(u) : ct.createFromInputFallback(s);
}
function tR(s, u, h, v, w) {
  var C = {};
  return (u === !0 || u === !1) && (v = u, u = void 0), (h === !0 || h === !1) && (v = h, h = void 0), (Yc(s) && j1(s) || Bs(s) && s.length === 0) && (s = void 0), C._isAMomentObject = !0, C._useUTC = C._isUTC = w, C._l = h, C._i = s, C._f = u, C._strict = v, gI(C);
}
function nr(s, u, h, v) {
  return tR(s, u, h, v, !1);
}
var mI = ls(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var s = nr.apply(null, arguments);
    return this.isValid() && s.isValid() ? s < this ? this : s : Zy();
  }
), yI = ls(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var s = nr.apply(null, arguments);
    return this.isValid() && s.isValid() ? s > this ? this : s : Zy();
  }
);
function nR(s, u) {
  var h, v;
  if (u.length === 1 && Bs(u[0]) && (u = u[0]), !u.length)
    return nr();
  for (h = u[0], v = 1; v < u.length; ++v)
    (!u[v].isValid() || u[v][s](h)) && (h = u[v]);
  return h;
}
function xI() {
  var s = [].slice.call(arguments, 0);
  return nR("isBefore", s);
}
function bI() {
  var s = [].slice.call(arguments, 0);
  return nR("isAfter", s);
}
var wI = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
}, ig = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function SI(s) {
  var u, h = !1, v, w = ig.length;
  for (u in s)
    if (En(s, u) && !(Mr.call(ig, u) !== -1 && (s[u] == null || !isNaN(s[u]))))
      return !1;
  for (v = 0; v < w; ++v)
    if (s[ig[v]]) {
      if (h)
        return !1;
      parseFloat(s[ig[v]]) !== un(s[ig[v]]) && (h = !0);
    }
  return !0;
}
function kI() {
  return this._isValid;
}
function CI() {
  return Xs(NaN);
}
function ax(s) {
  var u = V1(s), h = u.year || 0, v = u.quarter || 0, w = u.month || 0, C = u.week || u.isoWeek || 0, T = u.day || 0, F = u.hour || 0, Y = u.minute || 0, U = u.second || 0, G = u.millisecond || 0;
  this._isValid = SI(u), this._milliseconds = +G + U * 1e3 + // 1000
  Y * 6e4 + // 1000 * 60
  F * 1e3 * 60 * 60, this._days = +T + C * 7, this._months = +w + v * 3 + h * 12, this._data = {}, this._locale = Rl(), this._bubble();
}
function Ly(s) {
  return s instanceof ax;
}
function y1(s) {
  return s < 0 ? Math.round(-1 * s) * -1 : Math.round(s);
}
function AI(s, u, h) {
  var v = Math.min(s.length, u.length), w = Math.abs(s.length - u.length), C = 0, T;
  for (T = 0; T < v; T++)
    (h && s[T] !== u[T] || !h && un(s[T]) !== un(u[T])) && C++;
  return C + w;
}
function rR(s, u) {
  zt(s, 0, 0, function() {
    var h = this.utcOffset(), v = "+";
    return h < 0 && (h = -h, v = "-"), v + Do(~~(h / 60), 2) + u + Do(~~h % 60, 2);
  });
}
rR("Z", ":");
rR("ZZ", "");
mt("Z", nx);
mt("ZZ", nx);
Hn(["Z", "ZZ"], function(s, u, h) {
  h._useUTC = !0, h._tzm = nS(nx, s);
});
var TI = /([\+\-]|\d\d)/gi;
function nS(s, u) {
  var h = (u || "").match(s), v, w, C;
  return h === null ? null : (v = h[h.length - 1] || [], w = (v + "").match(TI) || ["-", 0, 0], C = +(w[1] * 60) + un(w[2]), C === 0 ? 0 : w[0] === "+" ? C : -C);
}
function rS(s, u) {
  var h, v;
  return u._isUTC ? (h = u.clone(), v = (Ws(s) || wg(s) ? s.valueOf() : nr(s).valueOf()) - h.valueOf(), h._d.setTime(h._d.valueOf() + v), ct.updateOffset(h, !1), h) : nr(s).local();
}
function x1(s) {
  return -Math.round(s._d.getTimezoneOffset());
}
ct.updateOffset = function() {
};
function EI(s, u, h) {
  var v = this._offset || 0, w;
  if (!this.isValid())
    return s != null ? this : NaN;
  if (s != null) {
    if (typeof s == "string") {
      if (s = nS(nx, s), s === null)
        return this;
    } else
      Math.abs(s) < 16 && !h && (s = s * 60);
    return !this._isUTC && u && (w = x1(this)), this._offset = s, this._isUTC = !0, w != null && this.add(w, "m"), v !== s && (!u || this._changeInProgress ? sR(
      this,
      Xs(s - v, "m"),
      1,
      !1
    ) : this._changeInProgress || (this._changeInProgress = !0, ct.updateOffset(this, !0), this._changeInProgress = null)), this;
  } else
    return this._isUTC ? v : x1(this);
}
function RI(s, u) {
  return s != null ? (typeof s != "string" && (s = -s), this.utcOffset(s, u), this) : -this.utcOffset();
}
function LI(s) {
  return this.utcOffset(0, s);
}
function MI(s) {
  return this._isUTC && (this.utcOffset(0, s), this._isUTC = !1, s && this.subtract(x1(this), "m")), this;
}
function DI() {
  if (this._tzm != null)
    this.utcOffset(this._tzm, !1, !0);
  else if (typeof this._i == "string") {
    var s = nS(KN, this._i);
    s != null ? this.utcOffset(s) : this.utcOffset(0, !0);
  }
  return this;
}
function OI(s) {
  return this.isValid() ? (s = s ? nr(s).utcOffset() : 0, (this.utcOffset() - s) % 60 === 0) : !1;
}
function _I() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function PI() {
  if (!Oa(this._isDSTShifted))
    return this._isDSTShifted;
  var s = {}, u;
  return B1(s, this), s = eR(s), s._a ? (u = s._isUTC ? Oo(s._a) : nr(s._a), this._isDSTShifted = this.isValid() && AI(s._a, u.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted;
}
function NI() {
  return this.isValid() ? !this._isUTC : !1;
}
function zI() {
  return this.isValid() ? this._isUTC : !1;
}
function iR() {
  return this.isValid() ? this._isUTC && this._offset === 0 : !1;
}
var II = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, FI = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function Xs(s, u) {
  var h = s, v = null, w, C, T;
  return Ly(s) ? h = {
    ms: s._milliseconds,
    d: s._days,
    M: s._months
  } : El(s) || !isNaN(+s) ? (h = {}, u ? h[u] = +s : h.milliseconds = +s) : (v = II.exec(s)) ? (w = v[1] === "-" ? -1 : 1, h = {
    y: 0,
    d: un(v[Lo]) * w,
    h: un(v[ei]) * w,
    m: un(v[Us]) * w,
    s: un(v[Al]) * w,
    ms: un(y1(v[Fc] * 1e3)) * w
    // the millisecond decimal point is included in the match
  }) : (v = FI.exec(s)) ? (w = v[1] === "-" ? -1 : 1, h = {
    y: Ic(v[2], w),
    M: Ic(v[3], w),
    w: Ic(v[4], w),
    d: Ic(v[5], w),
    h: Ic(v[6], w),
    m: Ic(v[7], w),
    s: Ic(v[8], w)
  }) : h == null ? h = {} : typeof h == "object" && ("from" in h || "to" in h) && (T = YI(
    nr(h.from),
    nr(h.to)
  ), h = {}, h.ms = T.milliseconds, h.M = T.months), C = new ax(h), Ly(s) && En(s, "_locale") && (C._locale = s._locale), Ly(s) && En(s, "_isValid") && (C._isValid = s._isValid), C;
}
Xs.fn = ax.prototype;
Xs.invalid = CI;
function Ic(s, u) {
  var h = s && parseFloat(s.replace(",", "."));
  return (isNaN(h) ? 0 : h) * u;
}
function kT(s, u) {
  var h = {};
  return h.months = u.month() - s.month() + (u.year() - s.year()) * 12, s.clone().add(h.months, "M").isAfter(u) && --h.months, h.milliseconds = +u - +s.clone().add(h.months, "M"), h;
}
function YI(s, u) {
  var h;
  return s.isValid() && u.isValid() ? (u = rS(u, s), s.isBefore(u) ? h = kT(s, u) : (h = kT(u, s), h.milliseconds = -h.milliseconds, h.months = -h.months), h) : { milliseconds: 0, months: 0 };
}
function aR(s, u) {
  return function(h, v) {
    var w, C;
    return v !== null && !isNaN(+v) && (_E(
      u,
      "moment()." + u + "(period, number) is deprecated. Please use moment()." + u + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
    ), C = h, h = v, v = C), w = Xs(h, v), sR(this, w, s), this;
  };
}
function sR(s, u, h, v) {
  var w = u._milliseconds, C = y1(u._days), T = y1(u._months);
  s.isValid() && (v = v ?? !0, T && BE(s, Hy(s, "Month") + T * h), C && zE(s, "Date", Hy(s, "Date") + C * h), w && s._d.setTime(s._d.valueOf() + w * h), v && ct.updateOffset(s, C || T));
}
var HI = aR(1, "add"), jI = aR(-1, "subtract");
function oR(s) {
  return typeof s == "string" || s instanceof String;
}
function UI(s) {
  return Ws(s) || wg(s) || oR(s) || El(s) || WI(s) || BI(s) || s === null || s === void 0;
}
function BI(s) {
  var u = Yc(s) && !j1(s), h = !1, v = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], w, C, T = v.length;
  for (w = 0; w < T; w += 1)
    C = v[w], h = h || En(s, C);
  return u && h;
}
function WI(s) {
  var u = Bs(s), h = !1;
  return u && (h = s.filter(function(v) {
    return !El(v) && oR(s);
  }).length === 0), u && h;
}
function XI(s) {
  var u = Yc(s) && !j1(s), h = !1, v = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], w, C;
  for (w = 0; w < v.length; w += 1)
    C = v[w], h = h || En(s, C);
  return u && h;
}
function VI(s, u) {
  var h = s.diff(u, "days", !0);
  return h < -6 ? "sameElse" : h < -1 ? "lastWeek" : h < 0 ? "lastDay" : h < 1 ? "sameDay" : h < 2 ? "nextDay" : h < 7 ? "nextWeek" : "sameElse";
}
function GI(s, u) {
  arguments.length === 1 && (arguments[0] ? UI(arguments[0]) ? (s = arguments[0], u = void 0) : XI(arguments[0]) && (u = arguments[0], s = void 0) : (s = void 0, u = void 0));
  var h = s || nr(), v = rS(h, this).startOf("day"), w = ct.calendarFormat(this, v) || "sameElse", C = u && (_o(u[w]) ? u[w].call(this, h) : u[w]);
  return this.format(
    C || this.localeData().calendar(w, this, nr(h))
  );
}
function $I() {
  return new Sg(this);
}
function qI(s, u) {
  var h = Ws(s) ? s : nr(s);
  return this.isValid() && h.isValid() ? (u = us(u) || "millisecond", u === "millisecond" ? this.valueOf() > h.valueOf() : h.valueOf() < this.clone().startOf(u).valueOf()) : !1;
}
function ZI(s, u) {
  var h = Ws(s) ? s : nr(s);
  return this.isValid() && h.isValid() ? (u = us(u) || "millisecond", u === "millisecond" ? this.valueOf() < h.valueOf() : this.clone().endOf(u).valueOf() < h.valueOf()) : !1;
}
function QI(s, u, h, v) {
  var w = Ws(s) ? s : nr(s), C = Ws(u) ? u : nr(u);
  return this.isValid() && w.isValid() && C.isValid() ? (v = v || "()", (v[0] === "(" ? this.isAfter(w, h) : !this.isBefore(w, h)) && (v[1] === ")" ? this.isBefore(C, h) : !this.isAfter(C, h))) : !1;
}
function KI(s, u) {
  var h = Ws(s) ? s : nr(s), v;
  return this.isValid() && h.isValid() ? (u = us(u) || "millisecond", u === "millisecond" ? this.valueOf() === h.valueOf() : (v = h.valueOf(), this.clone().startOf(u).valueOf() <= v && v <= this.clone().endOf(u).valueOf())) : !1;
}
function JI(s, u) {
  return this.isSame(s, u) || this.isAfter(s, u);
}
function eF(s, u) {
  return this.isSame(s, u) || this.isBefore(s, u);
}
function tF(s, u, h) {
  var v, w, C;
  if (!this.isValid())
    return NaN;
  if (v = rS(s, this), !v.isValid())
    return NaN;
  switch (w = (v.utcOffset() - this.utcOffset()) * 6e4, u = us(u), u) {
    case "year":
      C = My(this, v) / 12;
      break;
    case "month":
      C = My(this, v);
      break;
    case "quarter":
      C = My(this, v) / 3;
      break;
    case "second":
      C = (this - v) / 1e3;
      break;
    case "minute":
      C = (this - v) / 6e4;
      break;
    case "hour":
      C = (this - v) / 36e5;
      break;
    case "day":
      C = (this - v - w) / 864e5;
      break;
    case "week":
      C = (this - v - w) / 6048e5;
      break;
    default:
      C = this - v;
  }
  return h ? C : os(C);
}
function My(s, u) {
  if (s.date() < u.date())
    return -My(u, s);
  var h = (u.year() - s.year()) * 12 + (u.month() - s.month()), v = s.clone().add(h, "months"), w, C;
  return u - v < 0 ? (w = s.clone().add(h - 1, "months"), C = (u - v) / (v - w)) : (w = s.clone().add(h + 1, "months"), C = (u - v) / (w - v)), -(h + C) || 0;
}
ct.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
ct.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function nF() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function rF(s) {
  if (!this.isValid())
    return null;
  var u = s !== !0, h = u ? this.clone().utc() : this;
  return h.year() < 0 || h.year() > 9999 ? Ry(
    h,
    u ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
  ) : _o(Date.prototype.toISOString) ? u ? this.toDate().toISOString() : new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", Ry(h, "Z")) : Ry(
    h,
    u ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function iF() {
  if (!this.isValid())
    return "moment.invalid(/* " + this._i + " */)";
  var s = "moment", u = "", h, v, w, C;
  return this.isLocal() || (s = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", u = "Z"), h = "[" + s + '("]', v = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", w = "-MM-DD[T]HH:mm:ss.SSS", C = u + '[")]', this.format(h + v + w + C);
}
function aF(s) {
  s || (s = this.isUtc() ? ct.defaultFormatUtc : ct.defaultFormat);
  var u = Ry(this, s);
  return this.localeData().postformat(u);
}
function sF(s, u) {
  return this.isValid() && (Ws(s) && s.isValid() || nr(s).isValid()) ? Xs({ to: this, from: s }).locale(this.locale()).humanize(!u) : this.localeData().invalidDate();
}
function oF(s) {
  return this.from(nr(), s);
}
function lF(s, u) {
  return this.isValid() && (Ws(s) && s.isValid() || nr(s).isValid()) ? Xs({ from: this, to: s }).locale(this.locale()).humanize(!u) : this.localeData().invalidDate();
}
function uF(s) {
  return this.to(nr(), s);
}
function lR(s) {
  var u;
  return s === void 0 ? this._locale._abbr : (u = Rl(s), u != null && (this._locale = u), this);
}
var uR = ls(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(s) {
    return s === void 0 ? this.localeData() : this.locale(s);
  }
);
function cR() {
  return this._locale;
}
var By = 1e3, Ff = 60 * By, Wy = 60 * Ff, dR = (365 * 400 + 97) * 24 * Wy;
function Yf(s, u) {
  return (s % u + u) % u;
}
function fR(s, u, h) {
  return s < 100 && s >= 0 ? new Date(s + 400, u, h) - dR : new Date(s, u, h).valueOf();
}
function hR(s, u, h) {
  return s < 100 && s >= 0 ? Date.UTC(s + 400, u, h) - dR : Date.UTC(s, u, h);
}
function cF(s) {
  var u, h;
  if (s = us(s), s === void 0 || s === "millisecond" || !this.isValid())
    return this;
  switch (h = this._isUTC ? hR : fR, s) {
    case "year":
      u = h(this.year(), 0, 1);
      break;
    case "quarter":
      u = h(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      u = h(this.year(), this.month(), 1);
      break;
    case "week":
      u = h(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      u = h(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      u = h(this.year(), this.month(), this.date());
      break;
    case "hour":
      u = this._d.valueOf(), u -= Yf(
        u + (this._isUTC ? 0 : this.utcOffset() * Ff),
        Wy
      );
      break;
    case "minute":
      u = this._d.valueOf(), u -= Yf(u, Ff);
      break;
    case "second":
      u = this._d.valueOf(), u -= Yf(u, By);
      break;
  }
  return this._d.setTime(u), ct.updateOffset(this, !0), this;
}
function dF(s) {
  var u, h;
  if (s = us(s), s === void 0 || s === "millisecond" || !this.isValid())
    return this;
  switch (h = this._isUTC ? hR : fR, s) {
    case "year":
      u = h(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      u = h(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      u = h(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      u = h(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      u = h(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      u = h(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      u = this._d.valueOf(), u += Wy - Yf(
        u + (this._isUTC ? 0 : this.utcOffset() * Ff),
        Wy
      ) - 1;
      break;
    case "minute":
      u = this._d.valueOf(), u += Ff - Yf(u, Ff) - 1;
      break;
    case "second":
      u = this._d.valueOf(), u += By - Yf(u, By) - 1;
      break;
  }
  return this._d.setTime(u), ct.updateOffset(this, !0), this;
}
function fF() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function hF() {
  return Math.floor(this.valueOf() / 1e3);
}
function pF() {
  return new Date(this.valueOf());
}
function gF() {
  var s = this;
  return [
    s.year(),
    s.month(),
    s.date(),
    s.hour(),
    s.minute(),
    s.second(),
    s.millisecond()
  ];
}
function vF() {
  var s = this;
  return {
    years: s.year(),
    months: s.month(),
    date: s.date(),
    hours: s.hours(),
    minutes: s.minutes(),
    seconds: s.seconds(),
    milliseconds: s.milliseconds()
  };
}
function mF() {
  return this.isValid() ? this.toISOString() : null;
}
function yF() {
  return U1(this);
}
function xF() {
  return Ru({}, rn(this));
}
function bF() {
  return rn(this).overflow;
}
function wF() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
zt("N", 0, 0, "eraAbbr");
zt("NN", 0, 0, "eraAbbr");
zt("NNN", 0, 0, "eraAbbr");
zt("NNNN", 0, 0, "eraName");
zt("NNNNN", 0, 0, "eraNarrow");
zt("y", ["y", 1], "yo", "eraYear");
zt("y", ["yy", 2], 0, "eraYear");
zt("y", ["yyy", 3], 0, "eraYear");
zt("y", ["yyyy", 4], 0, "eraYear");
mt("N", iS);
mt("NN", iS);
mt("NNN", iS);
mt("NNNN", OF);
mt("NNNNN", _F);
Hn(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(s, u, h, v) {
    var w = h._locale.erasParse(s, v, h._strict);
    w ? rn(h).era = w : rn(h).invalidEra = s;
  }
);
mt("y", Uf);
mt("yy", Uf);
mt("yyy", Uf);
mt("yyyy", Uf);
mt("yo", PF);
Hn(["y", "yy", "yyy", "yyyy"], Gi);
Hn(["yo"], function(s, u, h, v) {
  var w;
  h._locale._eraYearOrdinalRegex && (w = s.match(h._locale._eraYearOrdinalRegex)), h._locale.eraYearOrdinalParse ? u[Gi] = h._locale.eraYearOrdinalParse(s, w) : u[Gi] = parseInt(s, 10);
});
function SF(s, u) {
  var h, v, w, C = this._eras || Rl("en")._eras;
  for (h = 0, v = C.length; h < v; ++h) {
    switch (typeof C[h].since) {
      case "string":
        w = ct(C[h].since).startOf("day"), C[h].since = w.valueOf();
        break;
    }
    switch (typeof C[h].until) {
      case "undefined":
        C[h].until = 1 / 0;
        break;
      case "string":
        w = ct(C[h].until).startOf("day").valueOf(), C[h].until = w.valueOf();
        break;
    }
  }
  return C;
}
function kF(s, u, h) {
  var v, w, C = this.eras(), T, F, Y;
  for (s = s.toUpperCase(), v = 0, w = C.length; v < w; ++v)
    if (T = C[v].name.toUpperCase(), F = C[v].abbr.toUpperCase(), Y = C[v].narrow.toUpperCase(), h)
      switch (u) {
        case "N":
        case "NN":
        case "NNN":
          if (F === s)
            return C[v];
          break;
        case "NNNN":
          if (T === s)
            return C[v];
          break;
        case "NNNNN":
          if (Y === s)
            return C[v];
          break;
      }
    else if ([T, F, Y].indexOf(s) >= 0)
      return C[v];
}
function CF(s, u) {
  var h = s.since <= s.until ? 1 : -1;
  return u === void 0 ? ct(s.since).year() : ct(s.since).year() + (u - s.offset) * h;
}
function AF() {
  var s, u, h, v = this.localeData().eras();
  for (s = 0, u = v.length; s < u; ++s)
    if (h = this.clone().startOf("day").valueOf(), v[s].since <= h && h <= v[s].until || v[s].until <= h && h <= v[s].since)
      return v[s].name;
  return "";
}
function TF() {
  var s, u, h, v = this.localeData().eras();
  for (s = 0, u = v.length; s < u; ++s)
    if (h = this.clone().startOf("day").valueOf(), v[s].since <= h && h <= v[s].until || v[s].until <= h && h <= v[s].since)
      return v[s].narrow;
  return "";
}
function EF() {
  var s, u, h, v = this.localeData().eras();
  for (s = 0, u = v.length; s < u; ++s)
    if (h = this.clone().startOf("day").valueOf(), v[s].since <= h && h <= v[s].until || v[s].until <= h && h <= v[s].since)
      return v[s].abbr;
  return "";
}
function RF() {
  var s, u, h, v, w = this.localeData().eras();
  for (s = 0, u = w.length; s < u; ++s)
    if (h = w[s].since <= w[s].until ? 1 : -1, v = this.clone().startOf("day").valueOf(), w[s].since <= v && v <= w[s].until || w[s].until <= v && v <= w[s].since)
      return (this.year() - ct(w[s].since).year()) * h + w[s].offset;
  return this.year();
}
function LF(s) {
  return En(this, "_erasNameRegex") || aS.call(this), s ? this._erasNameRegex : this._erasRegex;
}
function MF(s) {
  return En(this, "_erasAbbrRegex") || aS.call(this), s ? this._erasAbbrRegex : this._erasRegex;
}
function DF(s) {
  return En(this, "_erasNarrowRegex") || aS.call(this), s ? this._erasNarrowRegex : this._erasRegex;
}
function iS(s, u) {
  return u.erasAbbrRegex(s);
}
function OF(s, u) {
  return u.erasNameRegex(s);
}
function _F(s, u) {
  return u.erasNarrowRegex(s);
}
function PF(s, u) {
  return u._eraYearOrdinalRegex || Uf;
}
function aS() {
  var s = [], u = [], h = [], v = [], w, C, T = this.eras();
  for (w = 0, C = T.length; w < C; ++w)
    u.push(Xa(T[w].name)), s.push(Xa(T[w].abbr)), h.push(Xa(T[w].narrow)), v.push(Xa(T[w].name)), v.push(Xa(T[w].abbr)), v.push(Xa(T[w].narrow));
  this._erasRegex = new RegExp("^(" + v.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + u.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp(
    "^(" + h.join("|") + ")",
    "i"
  );
}
zt(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
zt(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function sx(s, u) {
  zt(0, [s, s.length], 0, u);
}
sx("gggg", "weekYear");
sx("ggggg", "weekYear");
sx("GGGG", "isoWeekYear");
sx("GGGGG", "isoWeekYear");
$i("weekYear", "gg");
$i("isoWeekYear", "GG");
qi("weekYear", 1);
qi("isoWeekYear", 1);
mt("G", tx);
mt("g", tx);
mt("GG", rr, Va);
mt("gg", rr, Va);
mt("GGGG", $1, G1);
mt("gggg", $1, G1);
mt("GGGGG", ex, Ky);
mt("ggggg", ex, Ky);
Cg(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(s, u, h, v) {
    u[v.substr(0, 2)] = un(s);
  }
);
Cg(["gg", "GG"], function(s, u, h, v) {
  u[v] = ct.parseTwoDigitYear(s);
});
function NF(s) {
  return pR.call(
    this,
    s,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function zF(s) {
  return pR.call(
    this,
    s,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function IF() {
  return Tl(this.year(), 1, 4);
}
function FF() {
  return Tl(this.isoWeekYear(), 1, 4);
}
function YF() {
  var s = this.localeData()._week;
  return Tl(this.year(), s.dow, s.doy);
}
function HF() {
  var s = this.localeData()._week;
  return Tl(this.weekYear(), s.dow, s.doy);
}
function pR(s, u, h, v, w) {
  var C;
  return s == null ? mg(this, v, w).year : (C = Tl(s, v, w), u > C && (u = C), jF.call(this, s, u, h, v, w));
}
function jF(s, u, h, v, w) {
  var C = GE(s, u, h, v, w), T = vg(C.year, 0, C.dayOfYear);
  return this.year(T.getUTCFullYear()), this.month(T.getUTCMonth()), this.date(T.getUTCDate()), this;
}
zt("Q", 0, "Qo", "quarter");
$i("quarter", "Q");
qi("quarter", 7);
mt("Q", IE);
Hn("Q", function(s, u) {
  u[Cl] = (un(s) - 1) * 3;
});
function UF(s) {
  return s == null ? Math.ceil((this.month() + 1) / 3) : this.month((s - 1) * 3 + this.month() % 3);
}
zt("D", ["DD", 2], "Do", "date");
$i("date", "D");
qi("date", 9);
mt("D", rr);
mt("DD", rr, Va);
mt("Do", function(s, u) {
  return s ? u._dayOfMonthOrdinalParse || u._ordinalParse : u._dayOfMonthOrdinalParseLenient;
});
Hn(["D", "DD"], Lo);
Hn("Do", function(s, u) {
  u[Lo] = un(s.match(rr)[0]);
});
var gR = jf("Date", !0);
zt("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
$i("dayOfYear", "DDD");
qi("dayOfYear", 4);
mt("DDD", Jy);
mt("DDDD", FE);
Hn(["DDD", "DDDD"], function(s, u, h) {
  h._dayOfYear = un(s);
});
function BF(s) {
  var u = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return s == null ? u : this.add(s - u, "d");
}
zt("m", ["mm", 2], 0, "minute");
$i("minute", "m");
qi("minute", 14);
mt("m", rr);
mt("mm", rr, Va);
Hn(["m", "mm"], Us);
var WF = jf("Minutes", !1);
zt("s", ["ss", 2], 0, "second");
$i("second", "s");
qi("second", 15);
mt("s", rr);
mt("ss", rr, Va);
Hn(["s", "ss"], Al);
var XF = jf("Seconds", !1);
zt("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
zt(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
zt(0, ["SSS", 3], 0, "millisecond");
zt(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
zt(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
zt(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
zt(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
zt(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
zt(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
$i("millisecond", "ms");
qi("millisecond", 16);
mt("S", Jy, IE);
mt("SS", Jy, Va);
mt("SSS", Jy, FE);
var Lu, vR;
for (Lu = "SSSS"; Lu.length <= 9; Lu += "S")
  mt(Lu, Uf);
function VF(s, u) {
  u[Fc] = un(("0." + s) * 1e3);
}
for (Lu = "S"; Lu.length <= 9; Lu += "S")
  Hn(Lu, VF);
vR = jf("Milliseconds", !1);
zt("z", 0, 0, "zoneAbbr");
zt("zz", 0, 0, "zoneName");
function GF() {
  return this._isUTC ? "UTC" : "";
}
function $F() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var Ge = Sg.prototype;
Ge.add = HI;
Ge.calendar = GI;
Ge.clone = $I;
Ge.diff = tF;
Ge.endOf = dF;
Ge.format = aF;
Ge.from = sF;
Ge.fromNow = oF;
Ge.to = lF;
Ge.toNow = uF;
Ge.get = ZN;
Ge.invalidAt = bF;
Ge.isAfter = qI;
Ge.isBefore = ZI;
Ge.isBetween = QI;
Ge.isSame = KI;
Ge.isSameOrAfter = JI;
Ge.isSameOrBefore = eF;
Ge.isValid = yF;
Ge.lang = uR;
Ge.locale = lR;
Ge.localeData = cR;
Ge.max = yI;
Ge.min = mI;
Ge.parsingFlags = xF;
Ge.set = QN;
Ge.startOf = cF;
Ge.subtract = jI;
Ge.toArray = gF;
Ge.toObject = vF;
Ge.toDate = pF;
Ge.toISOString = rF;
Ge.inspect = iF;
typeof Symbol < "u" && Symbol.for != null && (Ge[Symbol.for("nodejs.util.inspect.custom")] = function() {
  return "Moment<" + this.format() + ">";
});
Ge.toJSON = mF;
Ge.toString = nF;
Ge.unix = hF;
Ge.valueOf = fF;
Ge.creationData = wF;
Ge.eraName = AF;
Ge.eraNarrow = TF;
Ge.eraAbbr = EF;
Ge.eraYear = RF;
Ge.year = VE;
Ge.isLeapYear = vz;
Ge.weekYear = NF;
Ge.isoWeekYear = zF;
Ge.quarter = Ge.quarters = UF;
Ge.month = WE;
Ge.daysInMonth = hz;
Ge.week = Ge.weeks = Sz;
Ge.isoWeek = Ge.isoWeeks = kz;
Ge.weeksInYear = YF;
Ge.weeksInWeekYear = HF;
Ge.isoWeeksInYear = IF;
Ge.isoWeeksInISOWeekYear = FF;
Ge.date = gR;
Ge.day = Ge.days = zz;
Ge.weekday = Iz;
Ge.isoWeekday = Fz;
Ge.dayOfYear = BF;
Ge.hour = Ge.hours = Xz;
Ge.minute = Ge.minutes = WF;
Ge.second = Ge.seconds = XF;
Ge.millisecond = Ge.milliseconds = vR;
Ge.utcOffset = EI;
Ge.utc = LI;
Ge.local = MI;
Ge.parseZone = DI;
Ge.hasAlignedHourOffset = OI;
Ge.isDST = _I;
Ge.isLocal = NI;
Ge.isUtcOffset = zI;
Ge.isUtc = iR;
Ge.isUTC = iR;
Ge.zoneAbbr = GF;
Ge.zoneName = $F;
Ge.dates = ls(
  "dates accessor is deprecated. Use date instead.",
  gR
);
Ge.months = ls(
  "months accessor is deprecated. Use month instead",
  WE
);
Ge.years = ls(
  "years accessor is deprecated. Use year instead",
  VE
);
Ge.zone = ls(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  RI
);
Ge.isDSTShifted = ls(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  PI
);
function qF(s) {
  return nr(s * 1e3);
}
function ZF() {
  return nr.apply(null, arguments).parseZone();
}
function mR(s) {
  return s;
}
var Rn = W1.prototype;
Rn.calendar = zN;
Rn.longDateFormat = HN;
Rn.invalidDate = UN;
Rn.ordinal = XN;
Rn.preparse = mR;
Rn.postformat = mR;
Rn.relativeTime = GN;
Rn.pastFuture = $N;
Rn.set = PN;
Rn.eras = SF;
Rn.erasParse = kF;
Rn.erasConvertYear = CF;
Rn.erasAbbrRegex = MF;
Rn.erasNameRegex = LF;
Rn.erasNarrowRegex = DF;
Rn.months = uz;
Rn.monthsShort = cz;
Rn.monthsParse = fz;
Rn.monthsRegex = gz;
Rn.monthsShortRegex = pz;
Rn.week = yz;
Rn.firstDayOfYear = wz;
Rn.firstDayOfWeek = bz;
Rn.weekdays = Dz;
Rn.weekdaysMin = _z;
Rn.weekdaysShort = Oz;
Rn.weekdaysParse = Nz;
Rn.weekdaysRegex = Yz;
Rn.weekdaysShortRegex = Hz;
Rn.weekdaysMinRegex = jz;
Rn.isPM = Bz;
Rn.meridiem = Vz;
function Xy(s, u, h, v) {
  var w = Rl(), C = Oo().set(v, u);
  return w[h](C, s);
}
function yR(s, u, h) {
  if (El(s) && (u = s, s = void 0), s = s || "", u != null)
    return Xy(s, u, h, "month");
  var v, w = [];
  for (v = 0; v < 12; v++)
    w[v] = Xy(s, v, h, "month");
  return w;
}
function sS(s, u, h, v) {
  typeof s == "boolean" ? (El(u) && (h = u, u = void 0), u = u || "") : (u = s, h = u, s = !1, El(u) && (h = u, u = void 0), u = u || "");
  var w = Rl(), C = s ? w._week.dow : 0, T, F = [];
  if (h != null)
    return Xy(u, (h + C) % 7, v, "day");
  for (T = 0; T < 7; T++)
    F[T] = Xy(u, (T + C) % 7, v, "day");
  return F;
}
function QF(s, u) {
  return yR(s, u, "months");
}
function KF(s, u) {
  return yR(s, u, "monthsShort");
}
function JF(s, u, h) {
  return sS(s, u, h, "weekdays");
}
function eY(s, u, h) {
  return sS(s, u, h, "weekdaysShort");
}
function tY(s, u, h) {
  return sS(s, u, h, "weekdaysMin");
}
Mu("en", {
  eras: [
    {
      since: "0001-01-01",
      until: 1 / 0,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -1 / 0,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(s) {
    var u = s % 10, h = un(s % 100 / 10) === 1 ? "th" : u === 1 ? "st" : u === 2 ? "nd" : u === 3 ? "rd" : "th";
    return s + h;
  }
});
ct.lang = ls(
  "moment.lang is deprecated. Use moment.locale instead.",
  Mu
);
ct.langData = ls(
  "moment.langData is deprecated. Use moment.localeData instead.",
  Rl
);
var wl = Math.abs;
function nY() {
  var s = this._data;
  return this._milliseconds = wl(this._milliseconds), this._days = wl(this._days), this._months = wl(this._months), s.milliseconds = wl(s.milliseconds), s.seconds = wl(s.seconds), s.minutes = wl(s.minutes), s.hours = wl(s.hours), s.months = wl(s.months), s.years = wl(s.years), this;
}
function xR(s, u, h, v) {
  var w = Xs(u, h);
  return s._milliseconds += v * w._milliseconds, s._days += v * w._days, s._months += v * w._months, s._bubble();
}
function rY(s, u) {
  return xR(this, s, u, 1);
}
function iY(s, u) {
  return xR(this, s, u, -1);
}
function CT(s) {
  return s < 0 ? Math.floor(s) : Math.ceil(s);
}
function aY() {
  var s = this._milliseconds, u = this._days, h = this._months, v = this._data, w, C, T, F, Y;
  return s >= 0 && u >= 0 && h >= 0 || s <= 0 && u <= 0 && h <= 0 || (s += CT(b1(h) + u) * 864e5, u = 0, h = 0), v.milliseconds = s % 1e3, w = os(s / 1e3), v.seconds = w % 60, C = os(w / 60), v.minutes = C % 60, T = os(C / 60), v.hours = T % 24, u += os(T / 24), Y = os(bR(u)), h += Y, u -= CT(b1(Y)), F = os(h / 12), h %= 12, v.days = u, v.months = h, v.years = F, this;
}
function bR(s) {
  return s * 4800 / 146097;
}
function b1(s) {
  return s * 146097 / 4800;
}
function sY(s) {
  if (!this.isValid())
    return NaN;
  var u, h, v = this._milliseconds;
  if (s = us(s), s === "month" || s === "quarter" || s === "year")
    switch (u = this._days + v / 864e5, h = this._months + bR(u), s) {
      case "month":
        return h;
      case "quarter":
        return h / 3;
      case "year":
        return h / 12;
    }
  else
    switch (u = this._days + Math.round(b1(this._months)), s) {
      case "week":
        return u / 7 + v / 6048e5;
      case "day":
        return u + v / 864e5;
      case "hour":
        return u * 24 + v / 36e5;
      case "minute":
        return u * 1440 + v / 6e4;
      case "second":
        return u * 86400 + v / 1e3;
      case "millisecond":
        return Math.floor(u * 864e5) + v;
      default:
        throw new Error("Unknown unit " + s);
    }
}
function oY() {
  return this.isValid() ? this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + un(this._months / 12) * 31536e6 : NaN;
}
function Ll(s) {
  return function() {
    return this.as(s);
  };
}
var lY = Ll("ms"), uY = Ll("s"), cY = Ll("m"), dY = Ll("h"), fY = Ll("d"), hY = Ll("w"), pY = Ll("M"), gY = Ll("Q"), vY = Ll("y");
function mY() {
  return Xs(this);
}
function yY(s) {
  return s = us(s), this.isValid() ? this[s + "s"]() : NaN;
}
function Uc(s) {
  return function() {
    return this.isValid() ? this._data[s] : NaN;
  };
}
var xY = Uc("milliseconds"), bY = Uc("seconds"), wY = Uc("minutes"), SY = Uc("hours"), kY = Uc("days"), CY = Uc("months"), AY = Uc("years");
function TY() {
  return os(this.days() / 7);
}
var kl = Math.round, zf = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function EY(s, u, h, v, w) {
  return w.relativeTime(u || 1, !!h, s, v);
}
function RY(s, u, h, v) {
  var w = Xs(s).abs(), C = kl(w.as("s")), T = kl(w.as("m")), F = kl(w.as("h")), Y = kl(w.as("d")), U = kl(w.as("M")), G = kl(w.as("w")), q = kl(w.as("y")), te = C <= h.ss && ["s", C] || C < h.s && ["ss", C] || T <= 1 && ["m"] || T < h.m && ["mm", T] || F <= 1 && ["h"] || F < h.h && ["hh", F] || Y <= 1 && ["d"] || Y < h.d && ["dd", Y];
  return h.w != null && (te = te || G <= 1 && ["w"] || G < h.w && ["ww", G]), te = te || U <= 1 && ["M"] || U < h.M && ["MM", U] || q <= 1 && ["y"] || ["yy", q], te[2] = u, te[3] = +s > 0, te[4] = v, EY.apply(null, te);
}
function LY(s) {
  return s === void 0 ? kl : typeof s == "function" ? (kl = s, !0) : !1;
}
function MY(s, u) {
  return zf[s] === void 0 ? !1 : u === void 0 ? zf[s] : (zf[s] = u, s === "s" && (zf.ss = u - 1), !0);
}
function DY(s, u) {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var h = !1, v = zf, w, C;
  return typeof s == "object" && (u = s, s = !1), typeof s == "boolean" && (h = s), typeof u == "object" && (v = Object.assign({}, zf, u), u.s != null && u.ss == null && (v.ss = u.s - 1)), w = this.localeData(), C = RY(this, !h, v, w), h && (C = w.pastFuture(+this, C)), w.postformat(C);
}
var Xw = Math.abs;
function Pf(s) {
  return (s > 0) - (s < 0) || +s;
}
function ox() {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var s = Xw(this._milliseconds) / 1e3, u = Xw(this._days), h = Xw(this._months), v, w, C, T, F = this.asSeconds(), Y, U, G, q;
  return F ? (v = os(s / 60), w = os(v / 60), s %= 60, v %= 60, C = os(h / 12), h %= 12, T = s ? s.toFixed(3).replace(/\.?0+$/, "") : "", Y = F < 0 ? "-" : "", U = Pf(this._months) !== Pf(F) ? "-" : "", G = Pf(this._days) !== Pf(F) ? "-" : "", q = Pf(this._milliseconds) !== Pf(F) ? "-" : "", Y + "P" + (C ? U + C + "Y" : "") + (h ? U + h + "M" : "") + (u ? G + u + "D" : "") + (w || v || s ? "T" : "") + (w ? q + w + "H" : "") + (v ? q + v + "M" : "") + (s ? q + T + "S" : "")) : "P0D";
}
var xn = ax.prototype;
xn.isValid = kI;
xn.abs = nY;
xn.add = rY;
xn.subtract = iY;
xn.as = sY;
xn.asMilliseconds = lY;
xn.asSeconds = uY;
xn.asMinutes = cY;
xn.asHours = dY;
xn.asDays = fY;
xn.asWeeks = hY;
xn.asMonths = pY;
xn.asQuarters = gY;
xn.asYears = vY;
xn.valueOf = oY;
xn._bubble = aY;
xn.clone = mY;
xn.get = yY;
xn.milliseconds = xY;
xn.seconds = bY;
xn.minutes = wY;
xn.hours = SY;
xn.days = kY;
xn.weeks = TY;
xn.months = CY;
xn.years = AY;
xn.humanize = DY;
xn.toISOString = ox;
xn.toString = ox;
xn.toJSON = ox;
xn.locale = lR;
xn.localeData = cR;
xn.toIsoString = ls(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  ox
);
xn.lang = uR;
zt("X", 0, 0, "unix");
zt("x", 0, 0, "valueOf");
mt("x", tx);
mt("X", JN);
Hn("X", function(s, u, h) {
  h._d = new Date(parseFloat(s) * 1e3);
});
Hn("x", function(s, u, h) {
  h._d = new Date(un(s));
});
//! moment.js
ct.version = "2.29.4";
ON(nr);
ct.fn = Ge;
ct.min = xI;
ct.max = bI;
ct.now = wI;
ct.utc = Oo;
ct.unix = qF;
ct.months = QF;
ct.isDate = wg;
ct.locale = Mu;
ct.invalid = Zy;
ct.duration = Xs;
ct.isMoment = Ws;
ct.weekdays = JF;
ct.parseZone = ZF;
ct.localeData = Rl;
ct.isDuration = Ly;
ct.monthsShort = KF;
ct.weekdaysMin = tY;
ct.defineLocale = K1;
ct.updateLocale = Zz;
ct.locales = Qz;
ct.weekdaysShort = eY;
ct.normalizeUnits = us;
ct.relativeTimeRounding = LY;
ct.relativeTimeThreshold = MY;
ct.calendarFormat = VI;
ct.prototype = Ge;
ct.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
//! moment.js locale configuration
//! locale : Portuguese (Brazil) [pt-br]
//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira
ct.defineLocale("pt-br", {
  months: "janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split(
    "_"
  ),
  monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
  weekdays: "domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado".split(
    "_"
  ),
  weekdaysShort: "dom_seg_ter_qua_qui_sex_sáb".split("_"),
  weekdaysMin: "do_2ª_3ª_4ª_5ª_6ª_sá".split("_"),
  weekdaysParseExact: !0,
  longDateFormat: {
    LT: "HH:mm",
    LTS: "HH:mm:ss",
    L: "DD/MM/YYYY",
    LL: "D [de] MMMM [de] YYYY",
    LLL: "D [de] MMMM [de] YYYY [às] HH:mm",
    LLLL: "dddd, D [de] MMMM [de] YYYY [às] HH:mm"
  },
  calendar: {
    sameDay: "[Hoje às] LT",
    nextDay: "[Amanhã às] LT",
    nextWeek: "dddd [às] LT",
    lastDay: "[Ontem às] LT",
    lastWeek: function() {
      return this.day() === 0 || this.day() === 6 ? "[Último] dddd [às] LT" : "[Última] dddd [às] LT";
    },
    sameElse: "L"
  },
  relativeTime: {
    future: "em %s",
    past: "há %s",
    s: "poucos segundos",
    ss: "%d segundos",
    m: "um minuto",
    mm: "%d minutos",
    h: "uma hora",
    hh: "%d horas",
    d: "um dia",
    dd: "%d dias",
    M: "um mês",
    MM: "%d meses",
    y: "um ano",
    yy: "%d anos"
  },
  dayOfMonthOrdinalParse: /\d{1,2}º/,
  ordinal: "%dº",
  invalidDate: "Data inválida"
});
const OY = [
  {
    agent: {
      firstName: "Ricardo",
      lastName: "Dutra",
      baseUserId: "ricardo.dutra"
    },
    period: [
      {
        date: "2023-08-08T03:00:00.002Z",
        start: "2023-08-08T06:24:32.532Z",
        finish: "2023-08-08T15:24:32.532Z",
        description: "Saída mais cedo",
        breaks: [
          {
            start: "2023-08-08T06:24:32.532Z",
            finish: "2023-08-08T06:24:32.532Z",
            type: 205
          }
        ]
      },
      {
        date: "2023-08-11T03:00:00.002Z",
        start: "2023-08-11T06:24:32.532Z",
        finish: "2023-08-11T14:58:32.532Z",
        description: "Saída mais cedo",
        breaks: [
          {
            start: "2023-08-11T09:24:32.532Z",
            finish: "2023-08-11T09:54:32.532Z",
            type: 206
          },
          {
            start: "2023-08-11T11:15:02.532Z",
            finish: "2023-08-11T11:29:32.532Z",
            type: 205
          }
        ]
      }
    ]
  },
  {
    agent: {
      firstName: "José",
      lastName: "Aultra",
      baseUserId: "jose.aultra"
    },
    period: [
      {
        date: "2023-08-09T03:00:00.002Z",
        start: "2023-08-09T06:24:32.532Z",
        finish: "2023-08-09T14:58:32.532Z",
        description: "Saída mais cedo",
        breaks: [
          {
            start: "2023-09-08T09:24:32.532Z",
            finish: "2023-09-08T09:54:32.532Z",
            type: 206
          },
          {
            start: "2023-09-08T11:15:02.532Z",
            finish: "2023-09-08T11:29:32.532Z",
            type: 205
          }
        ]
      }
    ]
  },
  {
    agent: {
      firstName: "Rinaldo",
      lastName: "Guilherme",
      baseUserId: "rinaldo.guilherme"
    },
    period: [
      {
        date: "2023-08-10T03:00:00.002Z",
        start: "2023-08-10T06:24:32.532Z",
        finish: "2023-08-10T14:58:32.532Z",
        description: "Saída mais cedo",
        breaks: [
          {
            start: "2023-09-08T09:24:32.532Z",
            finish: "2023-09-08T09:54:32.532Z",
            type: 206
          },
          {
            start: "2023-09-08T11:15:02.532Z",
            finish: "2023-09-08T11:29:32.532Z",
            type: 205
          }
        ]
      },
      {
        date: "2023-08-14T03:00:00.002Z",
        start: "2023-08-14T06:24:32.532Z",
        finish: "2023-08-14T14:58:32.532Z",
        description: "Saída mais cedo",
        breaks: [
          {
            start: "2023-09-08T09:24:32.532Z",
            finish: "2023-09-08T09:54:32.532Z",
            type: 206
          },
          {
            start: "2023-09-08T11:15:02.532Z",
            finish: "2023-09-08T11:29:32.532Z",
            type: 205
          }
        ]
      }
    ]
  }
];
tr.locale("pt-br");
const _Y = {
  206: "Almoço",
  205: "Banheiro"
}, PY = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
], NY = ({
  data: s,
  lastSevenDays: u
}) => /* @__PURE__ */ de.jsx("div", { className: "detailed-workday--period", children: u.map((h, v) => {
  const w = tr(h).format("DD [de] MMMM"), C = s.find(
    ({ date: Y }) => tr(Y).format("YYYY/MM/DD") === h.format("YYYY/MM/DD")
  );
  if (C === void 0)
    return /* @__PURE__ */ de.jsx("div", { className: "day", children: /* @__PURE__ */ de.jsx("span", { children: w }) }, v);
  const T = tr.utc(C.start).format("HH[h]mm"), F = tr.utc(C.finish).format("HH[h]mm");
  return /* @__PURE__ */ de.jsxs("div", { className: "day", children: [
    /* @__PURE__ */ de.jsx("span", { children: w }),
    /* @__PURE__ */ de.jsx("span", { className: "service", children: "Serviço" }),
    /* @__PURE__ */ de.jsxs("span", { className: "service-time", children: [
      T,
      " - ",
      F
    ] }),
    /* @__PURE__ */ de.jsxs("span", { className: "description", children: [
      C.description,
      "*"
    ] }),
    /* @__PURE__ */ de.jsx("div", { className: "breaks", children: C.breaks.map((Y, U) => {
      const G = tr.utc(Y.start).format("HH[h]mm"), q = tr.utc(Y.finish).format("HH[h]mm");
      return /* @__PURE__ */ de.jsxs("div", { className: "break-item", children: [
        /* @__PURE__ */ de.jsx("span", { className: "break-item--label", children: _Y[String(Y.type)] }),
        /* @__PURE__ */ de.jsxs("span", { className: "break-item--content", children: [
          G,
          " - ",
          q
        ] })
      ] }, U);
    }) })
  ] }, v);
}) }), Vj = () => {
  const s = Array.from({ length: 7 }).map(
    (u, h) => tr().clone().subtract(7 - h, "days")
  );
  return /* @__PURE__ */ de.jsxs("div", { className: "detailed-workday container", children: [
    /* @__PURE__ */ de.jsxs("header", { className: "detailed-workday--header container row spacing", children: [
      /* @__PURE__ */ de.jsxs("div", { className: "group rounded-box", children: [
        /* @__PURE__ */ de.jsx("label", { className: "bg-primary", children: "Filtro" }),
        /* @__PURE__ */ de.jsx(Yy, { items: ["Semana", "Mês", "Ano"] })
      ] }),
      /* @__PURE__ */ de.jsx("span", { children: "Intervalo de data: 08/08/2023 - 14/08/2023" })
    ] }),
    /* @__PURE__ */ de.jsxs("div", { className: "detailed-workday--container", children: [
      /* @__PURE__ */ de.jsxs("div", { className: "detailed-workday--item", children: [
        /* @__PURE__ */ de.jsx("span", { className: "", style: { width: "10rem" } }),
        /* @__PURE__ */ de.jsx("div", { className: "weekdays", children: s.map((u) => {
          const h = tr(u).day();
          return /* @__PURE__ */ de.jsx("span", { className: "", children: PY[h] });
        }) })
      ] }),
      OY.map((u, h) => /* @__PURE__ */ de.jsxs("div", { className: "detailed-workday--item", children: [
        /* @__PURE__ */ de.jsx("span", { children: u.agent.firstName }),
        /* @__PURE__ */ de.jsx(
          NY,
          {
            data: u.period,
            lastSevenDays: s
          },
          h
        )
      ] }, h))
    ] })
  ] });
}, Gj = ({ logo: s, items: u }) => /* @__PURE__ */ de.jsxs("header", { className: "header", children: [
  s,
  u
] }), zY = (s, u) => {
  var w, C, T, F;
  const v = s.currentTarget.childNodes[1].childNodes;
  switch (s.key) {
    case "ArrowDown": {
      if (u.current === v.length - 1)
        return;
      u.current += 1;
      const Y = (C = (w = v[u.current]) == null ? void 0 : w.firstChild) == null ? void 0 : C.firstChild;
      Y !== null && Y.focus();
      break;
    }
    case "ArrowUp": {
      if (u.current === 2)
        return;
      u.current -= 1;
      const Y = (F = (T = v[u.current]) == null ? void 0 : T.firstChild) == null ? void 0 : F.firstChild;
      Y !== null && Y.focus();
      break;
    }
    case " ": {
      const Y = s.target;
      Y instanceof HTMLAnchorElement && Y.click();
    }
  }
}, AT = (s, u, h, v, w, C = 0, T, F) => {
  s.current === null || u.current === null || (v.route === h && s.current.classList.add("active"), s.current.classList.contains("active") && v.route !== h && s.current.classList.remove("active"), T || (u.current.innerHTML = `
      <div className="sidebar-tooltip-container">
        <span>${F(`sidebar.${v.label}`)}</span>
      </div>
    `, u.current.style.opacity = "1", u.current.style.top = `calc(48px * ${w + C})`), s.current.style.top = `calc(48px * ${w + C})`);
}, IY = (s, u, h, v, w, C, T) => {
  var F;
  {
    if (u.current === null || h.current === null)
      return;
    let Y = -1;
    w || (h.current.innerHTML = "", h.current.style.opacity = "0"), C.forEach((U, G) => {
      s + U.route === v && (Y = G, T !== null && G >= T && (Y += C[T].submenus.length)), Object.hasOwnProperty.call(U, "submenus") && U.submenus.forEach((q, te) => {
        `${s}${U.route}${q.route}` === v && (T === G ? Y = G + te + 1 : Y = G);
      });
    }), (F = document.activeElement) == null || F.blur(), Y > -1 && (u.current.style.top = `calc(48px * ${Y})`, u.current.classList.add("active"));
  }
}, $j = ({
  data: s,
  itemLink: u,
  onSettings: h,
  onLogout: v,
  prefix: w = "",
  pathname: C = ""
}) => {
  const T = gr(null), F = gr(null), Y = gr(null), U = gr(3), [G, q] = dr(!1), [te, se] = dr(null);
  return /* @__PURE__ */ de.jsxs(
    "aside",
    {
      className: "sidebar closed",
      ref: T,
      onKeyDown: (ae) => zY(ae, U),
      children: [
        /* @__PURE__ */ de.jsx(
          "button",
          {
            type: "button",
            className: "btn btn-square btn-ghost ring-info",
            onClick: () => {
              T.current !== null && (q((ae) => !ae), T.current.classList.toggle("closed"));
            },
            children: /* @__PURE__ */ de.jsx(vi, { icon: "jam:menu", height: 32 })
          }
        ),
        /* @__PURE__ */ de.jsxs(
          "ul",
          {
            className: "sidebar-container",
            onMouseLeave: () => IY(
              w,
              F,
              Y,
              C,
              G,
              s,
              te
            ),
            children: [
              /* @__PURE__ */ de.jsx("span", { ref: F, className: "sidebar-selector" }),
              /* @__PURE__ */ de.jsx("div", { ref: Y, className: "sidebar-tooltip" }),
              s.map((ae, ue) => /* @__PURE__ */ de.jsxs(uE, { children: [
                /* @__PURE__ */ de.jsxs(
                  "li",
                  {
                    className: "sidebar-item",
                    onMouseEnter: () => AT(
                      F,
                      Y,
                      C,
                      ae,
                      te !== null && ue > te ? ue + s[te].submenus.length : ue,
                      0,
                      G,
                      kr
                    ),
                    onClick: () => {
                      ae != null && ae.submenus && se(
                        (Ce) => Ce === ue ? null : ue
                      );
                    },
                    children: [
                      /* @__PURE__ */ de.jsx("div", { className: "sidebar-item--icon", children: u({
                        icon: ae.icon,
                        label: kr(`sidebar.${ae.label}`),
                        route: ae.route,
                        isOpen: G,
                        props: {
                          className: ae != null && ae.submenus ? "group" : "",
                          onClick: () => {
                            U.current = ue + 2, F.current && F.current.classList.toggle("active");
                          }
                        }
                      }) }),
                      (ae == null ? void 0 : ae.submenus) && /* @__PURE__ */ de.jsxs("div", { className: "sidebar-item--submenu-handler", children: [
                        G && /* @__PURE__ */ de.jsx("span", { className: "sidebar-item--indicator", children: ae.submenus.length }),
                        /* @__PURE__ */ de.jsx(
                          vi,
                          {
                            icon: "ic:round-arrow-right",
                            height: 24,
                            rotate: ue === te ? 45 : 0
                          }
                        )
                      ] })
                    ]
                  }
                ),
                (ae == null ? void 0 : ae.submenus) && ue === te && /* @__PURE__ */ de.jsx("div", { className: "sidebar-submenu", children: ae.submenus.map((Ce, Ne) => /* @__PURE__ */ de.jsx(
                  "div",
                  {
                    className: "sidebar-submenu-item",
                    onMouseEnter: () => AT(
                      F,
                      Y,
                      C,
                      Ce,
                      ue,
                      Ne + 1,
                      G,
                      kr
                    ),
                    children: u({
                      icon: Ce.icon,
                      label: kr(
                        `sidebar.${Ce.label}`
                      ),
                      route: `${ae.route}${Ce.route}`,
                      isOpen: G,
                      props: { className: "" }
                    })
                  },
                  Ce.route
                )) })
              ] }, ue))
            ]
          }
        ),
        h && /* @__PURE__ */ de.jsxs(
          "button",
          {
            type: "button",
            className: "sidebar-settings-action ring-info",
            onClick: h,
            children: [
              /* @__PURE__ */ de.jsx(vi, { icon: "ph:gear-six-fill", height: 16 }),
              G && /* @__PURE__ */ de.jsx("span", { children: kr("common.settings") })
            ]
          }
        ),
        v && /* @__PURE__ */ de.jsxs(
          "button",
          {
            type: "button",
            className: "sidebar-exit-action ring-warning",
            onClick: v,
            children: [
              /* @__PURE__ */ de.jsx(vi, { icon: "mingcute:exit-fill", height: 16 }),
              G && /* @__PURE__ */ de.jsx("span", { children: kr("common.logout") })
            ]
          }
        )
      ]
    }
  );
};
var w1 = { exports: {} }, Ma = {}, Sy = { exports: {} }, Vw = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var TT;
function FY() {
  return TT || (TT = 1, function(s) {
    function u(We, ft) {
      var ye = We.length;
      We.push(ft);
      e:
        for (; 0 < ye; ) {
          var Ue = ye - 1 >>> 1, Qe = We[Ue];
          if (0 < w(Qe, ft))
            We[Ue] = ft, We[ye] = Qe, ye = Ue;
          else
            break e;
        }
    }
    function h(We) {
      return We.length === 0 ? null : We[0];
    }
    function v(We) {
      if (We.length === 0)
        return null;
      var ft = We[0], ye = We.pop();
      if (ye !== ft) {
        We[0] = ye;
        e:
          for (var Ue = 0, Qe = We.length, St = Qe >>> 1; Ue < St; ) {
            var kt = 2 * (Ue + 1) - 1, Ht = We[kt], ot = kt + 1, It = We[ot];
            if (0 > w(Ht, ye))
              ot < Qe && 0 > w(It, Ht) ? (We[Ue] = It, We[ot] = ye, Ue = ot) : (We[Ue] = Ht, We[kt] = ye, Ue = kt);
            else if (ot < Qe && 0 > w(It, ye))
              We[Ue] = It, We[ot] = ye, Ue = ot;
            else
              break e;
          }
      }
      return ft;
    }
    function w(We, ft) {
      var ye = We.sortIndex - ft.sortIndex;
      return ye !== 0 ? ye : We.id - ft.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var C = performance;
      s.unstable_now = function() {
        return C.now();
      };
    } else {
      var T = Date, F = T.now();
      s.unstable_now = function() {
        return T.now() - F;
      };
    }
    var Y = [], U = [], G = 1, q = null, te = 3, se = !1, ae = !1, ue = !1, Ce = typeof setTimeout == "function" ? setTimeout : null, Ne = typeof clearTimeout == "function" ? clearTimeout : null, K = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function we(We) {
      for (var ft = h(U); ft !== null; ) {
        if (ft.callback === null)
          v(U);
        else if (ft.startTime <= We)
          v(U), ft.sortIndex = ft.expirationTime, u(Y, ft);
        else
          break;
        ft = h(U);
      }
    }
    function Re(We) {
      if (ue = !1, we(We), !ae)
        if (h(Y) !== null)
          ae = !0, Et(re);
        else {
          var ft = h(U);
          ft !== null && an(Re, ft.startTime - We);
        }
    }
    function re(We, ft) {
      ae = !1, ue && (ue = !1, Ne(et), et = -1), se = !0;
      var ye = te;
      try {
        for (we(ft), q = h(Y); q !== null && (!(q.expirationTime > ft) || We && !it()); ) {
          var Ue = q.callback;
          if (typeof Ue == "function") {
            q.callback = null, te = q.priorityLevel;
            var Qe = Ue(q.expirationTime <= ft);
            ft = s.unstable_now(), typeof Qe == "function" ? q.callback = Qe : q === h(Y) && v(Y), we(ft);
          } else
            v(Y);
          q = h(Y);
        }
        if (q !== null)
          var St = !0;
        else {
          var kt = h(U);
          kt !== null && an(Re, kt.startTime - ft), St = !1;
        }
        return St;
      } finally {
        q = null, te = ye, se = !1;
      }
    }
    var ve = !1, Me = null, et = -1, je = 5, Ve = -1;
    function it() {
      return !(s.unstable_now() - Ve < je);
    }
    function dt() {
      if (Me !== null) {
        var We = s.unstable_now();
        Ve = We;
        var ft = !0;
        try {
          ft = Me(!0, We);
        } finally {
          ft ? Ke() : (ve = !1, Me = null);
        }
      } else
        ve = !1;
    }
    var Ke;
    if (typeof K == "function")
      Ke = function() {
        K(dt);
      };
    else if (typeof MessageChannel < "u") {
      var Ze = new MessageChannel(), Vt = Ze.port2;
      Ze.port1.onmessage = dt, Ke = function() {
        Vt.postMessage(null);
      };
    } else
      Ke = function() {
        Ce(dt, 0);
      };
    function Et(We) {
      Me = We, ve || (ve = !0, Ke());
    }
    function an(We, ft) {
      et = Ce(function() {
        We(s.unstable_now());
      }, ft);
    }
    s.unstable_IdlePriority = 5, s.unstable_ImmediatePriority = 1, s.unstable_LowPriority = 4, s.unstable_NormalPriority = 3, s.unstable_Profiling = null, s.unstable_UserBlockingPriority = 2, s.unstable_cancelCallback = function(We) {
      We.callback = null;
    }, s.unstable_continueExecution = function() {
      ae || se || (ae = !0, Et(re));
    }, s.unstable_forceFrameRate = function(We) {
      0 > We || 125 < We ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : je = 0 < We ? Math.floor(1e3 / We) : 5;
    }, s.unstable_getCurrentPriorityLevel = function() {
      return te;
    }, s.unstable_getFirstCallbackNode = function() {
      return h(Y);
    }, s.unstable_next = function(We) {
      switch (te) {
        case 1:
        case 2:
        case 3:
          var ft = 3;
          break;
        default:
          ft = te;
      }
      var ye = te;
      te = ft;
      try {
        return We();
      } finally {
        te = ye;
      }
    }, s.unstable_pauseExecution = function() {
    }, s.unstable_requestPaint = function() {
    }, s.unstable_runWithPriority = function(We, ft) {
      switch (We) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          We = 3;
      }
      var ye = te;
      te = We;
      try {
        return ft();
      } finally {
        te = ye;
      }
    }, s.unstable_scheduleCallback = function(We, ft, ye) {
      var Ue = s.unstable_now();
      switch (typeof ye == "object" && ye !== null ? (ye = ye.delay, ye = typeof ye == "number" && 0 < ye ? Ue + ye : Ue) : ye = Ue, We) {
        case 1:
          var Qe = -1;
          break;
        case 2:
          Qe = 250;
          break;
        case 5:
          Qe = 1073741823;
          break;
        case 4:
          Qe = 1e4;
          break;
        default:
          Qe = 5e3;
      }
      return Qe = ye + Qe, We = { id: G++, callback: ft, priorityLevel: We, startTime: ye, expirationTime: Qe, sortIndex: -1 }, ye > Ue ? (We.sortIndex = ye, u(U, We), h(Y) === null && We === h(U) && (ue ? (Ne(et), et = -1) : ue = !0, an(Re, ye - Ue))) : (We.sortIndex = Qe, u(Y, We), ae || se || (ae = !0, Et(re))), We;
    }, s.unstable_shouldYield = it, s.unstable_wrapCallback = function(We) {
      var ft = te;
      return function() {
        var ye = te;
        te = ft;
        try {
          return We.apply(this, arguments);
        } finally {
          te = ye;
        }
      };
    };
  }(Vw)), Vw;
}
var Gw = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ET;
function YY() {
  return ET || (ET = 1, function(s) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var u = !1, h = !1, v = 5;
      function w(Je, Lt) {
        var tn = Je.length;
        Je.push(Lt), F(Je, Lt, tn);
      }
      function C(Je) {
        return Je.length === 0 ? null : Je[0];
      }
      function T(Je) {
        if (Je.length === 0)
          return null;
        var Lt = Je[0], tn = Je.pop();
        return tn !== Lt && (Je[0] = tn, Y(Je, tn, 0)), Lt;
      }
      function F(Je, Lt, tn) {
        for (var bn = tn; bn > 0; ) {
          var Un = bn - 1 >>> 1, vr = Je[Un];
          if (U(vr, Lt) > 0)
            Je[Un] = Lt, Je[bn] = vr, bn = Un;
          else
            return;
        }
      }
      function Y(Je, Lt, tn) {
        for (var bn = tn, Un = Je.length, vr = Un >>> 1; bn < vr; ) {
          var $n = (bn + 1) * 2 - 1, ii = Je[$n], Ln = $n + 1, mr = Je[Ln];
          if (U(ii, Lt) < 0)
            Ln < Un && U(mr, ii) < 0 ? (Je[bn] = mr, Je[Ln] = Lt, bn = Ln) : (Je[bn] = ii, Je[$n] = Lt, bn = $n);
          else if (Ln < Un && U(mr, Lt) < 0)
            Je[bn] = mr, Je[Ln] = Lt, bn = Ln;
          else
            return;
        }
      }
      function U(Je, Lt) {
        var tn = Je.sortIndex - Lt.sortIndex;
        return tn !== 0 ? tn : Je.id - Lt.id;
      }
      var G = 1, q = 2, te = 3, se = 4, ae = 5;
      function ue(Je, Lt) {
      }
      var Ce = typeof performance == "object" && typeof performance.now == "function";
      if (Ce) {
        var Ne = performance;
        s.unstable_now = function() {
          return Ne.now();
        };
      } else {
        var K = Date, we = K.now();
        s.unstable_now = function() {
          return K.now() - we;
        };
      }
      var Re = 1073741823, re = -1, ve = 250, Me = 5e3, et = 1e4, je = Re, Ve = [], it = [], dt = 1, Ke = null, Ze = te, Vt = !1, Et = !1, an = !1, We = typeof setTimeout == "function" ? setTimeout : null, ft = typeof clearTimeout == "function" ? clearTimeout : null, ye = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function Ue(Je) {
        for (var Lt = C(it); Lt !== null; ) {
          if (Lt.callback === null)
            T(it);
          else if (Lt.startTime <= Je)
            T(it), Lt.sortIndex = Lt.expirationTime, w(Ve, Lt);
          else
            return;
          Lt = C(it);
        }
      }
      function Qe(Je) {
        if (an = !1, Ue(Je), !Et)
          if (C(Ve) !== null)
            Et = !0, ni(St);
          else {
            var Lt = C(it);
            Lt !== null && ar(Qe, Lt.startTime - Je);
          }
      }
      function St(Je, Lt) {
        Et = !1, an && (an = !1, ri()), Vt = !0;
        var tn = Ze;
        try {
          var bn;
          if (!h)
            return kt(Je, Lt);
        } finally {
          Ke = null, Ze = tn, Vt = !1;
        }
      }
      function kt(Je, Lt) {
        var tn = Lt;
        for (Ue(tn), Ke = C(Ve); Ke !== null && !u && !(Ke.expirationTime > tn && (!Je || Zi())); ) {
          var bn = Ke.callback;
          if (typeof bn == "function") {
            Ke.callback = null, Ze = Ke.priorityLevel;
            var Un = Ke.expirationTime <= tn, vr = bn(Un);
            tn = s.unstable_now(), typeof vr == "function" ? Ke.callback = vr : Ke === C(Ve) && T(Ve), Ue(tn);
          } else
            T(Ve);
          Ke = C(Ve);
        }
        if (Ke !== null)
          return !0;
        var $n = C(it);
        return $n !== null && ar(Qe, $n.startTime - tn), !1;
      }
      function Ht(Je, Lt) {
        switch (Je) {
          case G:
          case q:
          case te:
          case se:
          case ae:
            break;
          default:
            Je = te;
        }
        var tn = Ze;
        Ze = Je;
        try {
          return Lt();
        } finally {
          Ze = tn;
        }
      }
      function ot(Je) {
        var Lt;
        switch (Ze) {
          case G:
          case q:
          case te:
            Lt = te;
            break;
          default:
            Lt = Ze;
            break;
        }
        var tn = Ze;
        Ze = Lt;
        try {
          return Je();
        } finally {
          Ze = tn;
        }
      }
      function It(Je) {
        var Lt = Ze;
        return function() {
          var tn = Ze;
          Ze = Lt;
          try {
            return Je.apply(this, arguments);
          } finally {
            Ze = tn;
          }
        };
      }
      function Rt(Je, Lt, tn) {
        var bn = s.unstable_now(), Un;
        if (typeof tn == "object" && tn !== null) {
          var vr = tn.delay;
          typeof vr == "number" && vr > 0 ? Un = bn + vr : Un = bn;
        } else
          Un = bn;
        var $n;
        switch (Je) {
          case G:
            $n = re;
            break;
          case q:
            $n = ve;
            break;
          case ae:
            $n = je;
            break;
          case se:
            $n = et;
            break;
          case te:
          default:
            $n = Me;
            break;
        }
        var ii = Un + $n, Ln = {
          id: dt++,
          callback: Lt,
          priorityLevel: Je,
          startTime: Un,
          expirationTime: ii,
          sortIndex: -1
        };
        return Un > bn ? (Ln.sortIndex = Un, w(it, Ln), C(Ve) === null && Ln === C(it) && (an ? ri() : an = !0, ar(Qe, Un - bn))) : (Ln.sortIndex = ii, w(Ve, Ln), !Et && !Vt && (Et = !0, ni(St))), Ln;
      }
      function jt() {
      }
      function Ut() {
        !Et && !Vt && (Et = !0, ni(St));
      }
      function vn() {
        return C(Ve);
      }
      function qe(Je) {
        Je.callback = null;
      }
      function pn() {
        return Ze;
      }
      var jn = !1, ir = null, Dr = -1, Or = v, ti = -1;
      function Zi() {
        var Je = s.unstable_now() - ti;
        return !(Je < Or);
      }
      function _a() {
      }
      function da(Je) {
        if (Je < 0 || Je > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Je > 0 ? Or = Math.floor(1e3 / Je) : Or = v;
      }
      var Qi = function() {
        if (ir !== null) {
          var Je = s.unstable_now();
          ti = Je;
          var Lt = !0, tn = !0;
          try {
            tn = ir(Lt, Je);
          } finally {
            tn ? yi() : (jn = !1, ir = null);
          }
        } else
          jn = !1;
      }, yi;
      if (typeof ye == "function")
        yi = function() {
          ye(Qi);
        };
      else if (typeof MessageChannel < "u") {
        var fa = new MessageChannel(), xi = fa.port2;
        fa.port1.onmessage = Qi, yi = function() {
          xi.postMessage(null);
        };
      } else
        yi = function() {
          We(Qi, 0);
        };
      function ni(Je) {
        ir = Je, jn || (jn = !0, yi());
      }
      function ar(Je, Lt) {
        Dr = We(function() {
          Je(s.unstable_now());
        }, Lt);
      }
      function ri() {
        ft(Dr), Dr = -1;
      }
      var Pa = _a, Ki = null;
      s.unstable_IdlePriority = ae, s.unstable_ImmediatePriority = G, s.unstable_LowPriority = se, s.unstable_NormalPriority = te, s.unstable_Profiling = Ki, s.unstable_UserBlockingPriority = q, s.unstable_cancelCallback = qe, s.unstable_continueExecution = Ut, s.unstable_forceFrameRate = da, s.unstable_getCurrentPriorityLevel = pn, s.unstable_getFirstCallbackNode = vn, s.unstable_next = ot, s.unstable_pauseExecution = jt, s.unstable_requestPaint = Pa, s.unstable_runWithPriority = Ht, s.unstable_scheduleCallback = Rt, s.unstable_shouldYield = Zi, s.unstable_wrapCallback = It, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(Gw)), Gw;
}
var RT;
function wR() {
  return RT || (RT = 1, process.env.NODE_ENV === "production" ? Sy.exports = FY() : Sy.exports = YY()), Sy.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var LT;
function HY() {
  if (LT)
    return Ma;
  LT = 1;
  var s = mi, u = wR();
  function h(a) {
    for (var l = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, m = 1; m < arguments.length; m++)
      l += "&args[]=" + encodeURIComponent(arguments[m]);
    return "Minified React error #" + a + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var v = /* @__PURE__ */ new Set(), w = {};
  function C(a, l) {
    T(a, l), T(a + "Capture", l);
  }
  function T(a, l) {
    for (w[a] = l, a = 0; a < l.length; a++)
      v.add(l[a]);
  }
  var F = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Y = Object.prototype.hasOwnProperty, U = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, G = {}, q = {};
  function te(a) {
    return Y.call(q, a) ? !0 : Y.call(G, a) ? !1 : U.test(a) ? q[a] = !0 : (G[a] = !0, !1);
  }
  function se(a, l, m, k) {
    if (m !== null && m.type === 0)
      return !1;
    switch (typeof l) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return k ? !1 : m !== null ? !m.acceptsBooleans : (a = a.toLowerCase().slice(0, 5), a !== "data-" && a !== "aria-");
      default:
        return !1;
    }
  }
  function ae(a, l, m, k) {
    if (l === null || typeof l > "u" || se(a, l, m, k))
      return !0;
    if (k)
      return !1;
    if (m !== null)
      switch (m.type) {
        case 3:
          return !l;
        case 4:
          return l === !1;
        case 5:
          return isNaN(l);
        case 6:
          return isNaN(l) || 1 > l;
      }
    return !1;
  }
  function ue(a, l, m, k, D, z, $) {
    this.acceptsBooleans = l === 2 || l === 3 || l === 4, this.attributeName = k, this.attributeNamespace = D, this.mustUseProperty = m, this.propertyName = a, this.type = l, this.sanitizeURL = z, this.removeEmptyString = $;
  }
  var Ce = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    Ce[a] = new ue(a, 0, !1, a, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
    var l = a[0];
    Ce[l] = new ue(l, 1, !1, a[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
    Ce[a] = new ue(a, 2, !1, a.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
    Ce[a] = new ue(a, 2, !1, a, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    Ce[a] = new ue(a, 3, !1, a.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(a) {
    Ce[a] = new ue(a, 3, !0, a, null, !1, !1);
  }), ["capture", "download"].forEach(function(a) {
    Ce[a] = new ue(a, 4, !1, a, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(a) {
    Ce[a] = new ue(a, 6, !1, a, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(a) {
    Ce[a] = new ue(a, 5, !1, a.toLowerCase(), null, !1, !1);
  });
  var Ne = /[\-:]([a-z])/g;
  function K(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var l = a.replace(
      Ne,
      K
    );
    Ce[l] = new ue(l, 1, !1, a, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var l = a.replace(Ne, K);
    Ce[l] = new ue(l, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
    var l = a.replace(Ne, K);
    Ce[l] = new ue(l, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(a) {
    Ce[a] = new ue(a, 1, !1, a.toLowerCase(), null, !1, !1);
  }), Ce.xlinkHref = new ue("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(a) {
    Ce[a] = new ue(a, 1, !1, a.toLowerCase(), null, !0, !0);
  });
  function we(a, l, m, k) {
    var D = Ce.hasOwnProperty(l) ? Ce[l] : null;
    (D !== null ? D.type !== 0 : k || !(2 < l.length) || l[0] !== "o" && l[0] !== "O" || l[1] !== "n" && l[1] !== "N") && (ae(l, m, D, k) && (m = null), k || D === null ? te(l) && (m === null ? a.removeAttribute(l) : a.setAttribute(l, "" + m)) : D.mustUseProperty ? a[D.propertyName] = m === null ? D.type === 3 ? !1 : "" : m : (l = D.attributeName, k = D.attributeNamespace, m === null ? a.removeAttribute(l) : (D = D.type, m = D === 3 || D === 4 && m === !0 ? "" : "" + m, k ? a.setAttributeNS(k, l, m) : a.setAttribute(l, m))));
  }
  var Re = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, re = Symbol.for("react.element"), ve = Symbol.for("react.portal"), Me = Symbol.for("react.fragment"), et = Symbol.for("react.strict_mode"), je = Symbol.for("react.profiler"), Ve = Symbol.for("react.provider"), it = Symbol.for("react.context"), dt = Symbol.for("react.forward_ref"), Ke = Symbol.for("react.suspense"), Ze = Symbol.for("react.suspense_list"), Vt = Symbol.for("react.memo"), Et = Symbol.for("react.lazy"), an = Symbol.for("react.offscreen"), We = Symbol.iterator;
  function ft(a) {
    return a === null || typeof a != "object" ? null : (a = We && a[We] || a["@@iterator"], typeof a == "function" ? a : null);
  }
  var ye = Object.assign, Ue;
  function Qe(a) {
    if (Ue === void 0)
      try {
        throw Error();
      } catch (m) {
        var l = m.stack.trim().match(/\n( *(at )?)/);
        Ue = l && l[1] || "";
      }
    return `
` + Ue + a;
  }
  var St = !1;
  function kt(a, l) {
    if (!a || St)
      return "";
    St = !0;
    var m = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (l)
        if (l = function() {
          throw Error();
        }, Object.defineProperty(l.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(l, []);
          } catch (Ee) {
            var k = Ee;
          }
          Reflect.construct(a, [], l);
        } else {
          try {
            l.call();
          } catch (Ee) {
            k = Ee;
          }
          a.call(l.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Ee) {
          k = Ee;
        }
        a();
      }
    } catch (Ee) {
      if (Ee && k && typeof Ee.stack == "string") {
        for (var D = Ee.stack.split(`
`), z = k.stack.split(`
`), $ = D.length - 1, ie = z.length - 1; 1 <= $ && 0 <= ie && D[$] !== z[ie]; )
          ie--;
        for (; 1 <= $ && 0 <= ie; $--, ie--)
          if (D[$] !== z[ie]) {
            if ($ !== 1 || ie !== 1)
              do
                if ($--, ie--, 0 > ie || D[$] !== z[ie]) {
                  var ce = `
` + D[$].replace(" at new ", " at ");
                  return a.displayName && ce.includes("<anonymous>") && (ce = ce.replace("<anonymous>", a.displayName)), ce;
                }
              while (1 <= $ && 0 <= ie);
            break;
          }
      }
    } finally {
      St = !1, Error.prepareStackTrace = m;
    }
    return (a = a ? a.displayName || a.name : "") ? Qe(a) : "";
  }
  function Ht(a) {
    switch (a.tag) {
      case 5:
        return Qe(a.type);
      case 16:
        return Qe("Lazy");
      case 13:
        return Qe("Suspense");
      case 19:
        return Qe("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a = kt(a.type, !1), a;
      case 11:
        return a = kt(a.type.render, !1), a;
      case 1:
        return a = kt(a.type, !0), a;
      default:
        return "";
    }
  }
  function ot(a) {
    if (a == null)
      return null;
    if (typeof a == "function")
      return a.displayName || a.name || null;
    if (typeof a == "string")
      return a;
    switch (a) {
      case Me:
        return "Fragment";
      case ve:
        return "Portal";
      case je:
        return "Profiler";
      case et:
        return "StrictMode";
      case Ke:
        return "Suspense";
      case Ze:
        return "SuspenseList";
    }
    if (typeof a == "object")
      switch (a.$$typeof) {
        case it:
          return (a.displayName || "Context") + ".Consumer";
        case Ve:
          return (a._context.displayName || "Context") + ".Provider";
        case dt:
          var l = a.render;
          return a = a.displayName, a || (a = l.displayName || l.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
        case Vt:
          return l = a.displayName || null, l !== null ? l : ot(a.type) || "Memo";
        case Et:
          l = a._payload, a = a._init;
          try {
            return ot(a(l));
          } catch {
          }
      }
    return null;
  }
  function It(a) {
    var l = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (l.displayName || "Context") + ".Consumer";
      case 10:
        return (l._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a = l.render, a = a.displayName || a.name || "", l.displayName || (a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return l;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return ot(l);
      case 8:
        return l === et ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof l == "function")
          return l.displayName || l.name || null;
        if (typeof l == "string")
          return l;
    }
    return null;
  }
  function Rt(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function jt(a) {
    var l = a.type;
    return (a = a.nodeName) && a.toLowerCase() === "input" && (l === "checkbox" || l === "radio");
  }
  function Ut(a) {
    var l = jt(a) ? "checked" : "value", m = Object.getOwnPropertyDescriptor(a.constructor.prototype, l), k = "" + a[l];
    if (!a.hasOwnProperty(l) && typeof m < "u" && typeof m.get == "function" && typeof m.set == "function") {
      var D = m.get, z = m.set;
      return Object.defineProperty(a, l, { configurable: !0, get: function() {
        return D.call(this);
      }, set: function($) {
        k = "" + $, z.call(this, $);
      } }), Object.defineProperty(a, l, { enumerable: m.enumerable }), { getValue: function() {
        return k;
      }, setValue: function($) {
        k = "" + $;
      }, stopTracking: function() {
        a._valueTracker = null, delete a[l];
      } };
    }
  }
  function vn(a) {
    a._valueTracker || (a._valueTracker = Ut(a));
  }
  function qe(a) {
    if (!a)
      return !1;
    var l = a._valueTracker;
    if (!l)
      return !0;
    var m = l.getValue(), k = "";
    return a && (k = jt(a) ? a.checked ? "true" : "false" : a.value), a = k, a !== m ? (l.setValue(a), !0) : !1;
  }
  function pn(a) {
    if (a = a || (typeof document < "u" ? document : void 0), typeof a > "u")
      return null;
    try {
      return a.activeElement || a.body;
    } catch {
      return a.body;
    }
  }
  function jn(a, l) {
    var m = l.checked;
    return ye({}, l, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: m ?? a._wrapperState.initialChecked });
  }
  function ir(a, l) {
    var m = l.defaultValue == null ? "" : l.defaultValue, k = l.checked != null ? l.checked : l.defaultChecked;
    m = Rt(l.value != null ? l.value : m), a._wrapperState = { initialChecked: k, initialValue: m, controlled: l.type === "checkbox" || l.type === "radio" ? l.checked != null : l.value != null };
  }
  function Dr(a, l) {
    l = l.checked, l != null && we(a, "checked", l, !1);
  }
  function Or(a, l) {
    Dr(a, l);
    var m = Rt(l.value), k = l.type;
    if (m != null)
      k === "number" ? (m === 0 && a.value === "" || a.value != m) && (a.value = "" + m) : a.value !== "" + m && (a.value = "" + m);
    else if (k === "submit" || k === "reset") {
      a.removeAttribute("value");
      return;
    }
    l.hasOwnProperty("value") ? Zi(a, l.type, m) : l.hasOwnProperty("defaultValue") && Zi(a, l.type, Rt(l.defaultValue)), l.checked == null && l.defaultChecked != null && (a.defaultChecked = !!l.defaultChecked);
  }
  function ti(a, l, m) {
    if (l.hasOwnProperty("value") || l.hasOwnProperty("defaultValue")) {
      var k = l.type;
      if (!(k !== "submit" && k !== "reset" || l.value !== void 0 && l.value !== null))
        return;
      l = "" + a._wrapperState.initialValue, m || l === a.value || (a.value = l), a.defaultValue = l;
    }
    m = a.name, m !== "" && (a.name = ""), a.defaultChecked = !!a._wrapperState.initialChecked, m !== "" && (a.name = m);
  }
  function Zi(a, l, m) {
    (l !== "number" || pn(a.ownerDocument) !== a) && (m == null ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + m && (a.defaultValue = "" + m));
  }
  var _a = Array.isArray;
  function da(a, l, m, k) {
    if (a = a.options, l) {
      l = {};
      for (var D = 0; D < m.length; D++)
        l["$" + m[D]] = !0;
      for (m = 0; m < a.length; m++)
        D = l.hasOwnProperty("$" + a[m].value), a[m].selected !== D && (a[m].selected = D), D && k && (a[m].defaultSelected = !0);
    } else {
      for (m = "" + Rt(m), l = null, D = 0; D < a.length; D++) {
        if (a[D].value === m) {
          a[D].selected = !0, k && (a[D].defaultSelected = !0);
          return;
        }
        l !== null || a[D].disabled || (l = a[D]);
      }
      l !== null && (l.selected = !0);
    }
  }
  function Qi(a, l) {
    if (l.dangerouslySetInnerHTML != null)
      throw Error(h(91));
    return ye({}, l, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
  }
  function yi(a, l) {
    var m = l.value;
    if (m == null) {
      if (m = l.children, l = l.defaultValue, m != null) {
        if (l != null)
          throw Error(h(92));
        if (_a(m)) {
          if (1 < m.length)
            throw Error(h(93));
          m = m[0];
        }
        l = m;
      }
      l == null && (l = ""), m = l;
    }
    a._wrapperState = { initialValue: Rt(m) };
  }
  function fa(a, l) {
    var m = Rt(l.value), k = Rt(l.defaultValue);
    m != null && (m = "" + m, m !== a.value && (a.value = m), l.defaultValue == null && a.defaultValue !== m && (a.defaultValue = m)), k != null && (a.defaultValue = "" + k);
  }
  function xi(a) {
    var l = a.textContent;
    l === a._wrapperState.initialValue && l !== "" && l !== null && (a.value = l);
  }
  function ni(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function ar(a, l) {
    return a == null || a === "http://www.w3.org/1999/xhtml" ? ni(l) : a === "http://www.w3.org/2000/svg" && l === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a;
  }
  var ri, Pa = function(a) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(l, m, k, D) {
      MSApp.execUnsafeLocalFunction(function() {
        return a(l, m, k, D);
      });
    } : a;
  }(function(a, l) {
    if (a.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in a)
      a.innerHTML = l;
    else {
      for (ri = ri || document.createElement("div"), ri.innerHTML = "<svg>" + l.valueOf().toString() + "</svg>", l = ri.firstChild; a.firstChild; )
        a.removeChild(a.firstChild);
      for (; l.firstChild; )
        a.appendChild(l.firstChild);
    }
  });
  function Ki(a, l) {
    if (l) {
      var m = a.firstChild;
      if (m && m === a.lastChild && m.nodeType === 3) {
        m.nodeValue = l;
        return;
      }
    }
    a.textContent = l;
  }
  var Je = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Lt = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Je).forEach(function(a) {
    Lt.forEach(function(l) {
      l = l + a.charAt(0).toUpperCase() + a.substring(1), Je[l] = Je[a];
    });
  });
  function tn(a, l, m) {
    return l == null || typeof l == "boolean" || l === "" ? "" : m || typeof l != "number" || l === 0 || Je.hasOwnProperty(a) && Je[a] ? ("" + l).trim() : l + "px";
  }
  function bn(a, l) {
    a = a.style;
    for (var m in l)
      if (l.hasOwnProperty(m)) {
        var k = m.indexOf("--") === 0, D = tn(m, l[m], k);
        m === "float" && (m = "cssFloat"), k ? a.setProperty(m, D) : a[m] = D;
      }
  }
  var Un = ye({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function vr(a, l) {
    if (l) {
      if (Un[a] && (l.children != null || l.dangerouslySetInnerHTML != null))
        throw Error(h(137, a));
      if (l.dangerouslySetInnerHTML != null) {
        if (l.children != null)
          throw Error(h(60));
        if (typeof l.dangerouslySetInnerHTML != "object" || !("__html" in l.dangerouslySetInnerHTML))
          throw Error(h(61));
      }
      if (l.style != null && typeof l.style != "object")
        throw Error(h(62));
    }
  }
  function $n(a, l) {
    if (a.indexOf("-") === -1)
      return typeof l.is == "string";
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var ii = null;
  function Ln(a) {
    return a = a.target || a.srcElement || window, a.correspondingUseElement && (a = a.correspondingUseElement), a.nodeType === 3 ? a.parentNode : a;
  }
  var mr = null, kn = null, Cn = null;
  function cs(a) {
    if (a = Zu(a)) {
      if (typeof mr != "function")
        throw Error(h(280));
      var l = a.stateNode;
      l && (l = _t(l), mr(a.stateNode, a.type, l));
    }
  }
  function ds(a) {
    kn ? Cn ? Cn.push(a) : Cn = [a] : kn = a;
  }
  function fs() {
    if (kn) {
      var a = kn, l = Cn;
      if (Cn = kn = null, cs(a), l)
        for (a = 0; a < l.length; a++)
          cs(l[a]);
    }
  }
  function Vs(a, l) {
    return a(l);
  }
  function Ml() {
  }
  var hs = !1;
  function Gs(a, l, m) {
    if (hs)
      return a(l, m);
    hs = !0;
    try {
      return Vs(a, l, m);
    } finally {
      hs = !1, (kn !== null || Cn !== null) && (Ml(), fs());
    }
  }
  function ps(a, l) {
    var m = a.stateNode;
    if (m === null)
      return null;
    var k = _t(m);
    if (k === null)
      return null;
    m = k[l];
    e:
      switch (l) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (k = !k.disabled) || (a = a.type, k = !(a === "button" || a === "input" || a === "select" || a === "textarea")), a = !k;
          break e;
        default:
          a = !1;
      }
    if (a)
      return null;
    if (m && typeof m != "function")
      throw Error(h(231, l, typeof m));
    return m;
  }
  var $s = !1;
  if (F)
    try {
      var Oi = {};
      Object.defineProperty(Oi, "passive", { get: function() {
        $s = !0;
      } }), window.addEventListener("test", Oi, Oi), window.removeEventListener("test", Oi, Oi);
    } catch {
      $s = !1;
    }
  function Na(a, l, m, k, D, z, $, ie, ce) {
    var Ee = Array.prototype.slice.call(arguments, 3);
    try {
      l.apply(m, Ee);
    } catch (He) {
      this.onError(He);
    }
  }
  var jr = !1, bi = null, ai = !1, le = null, Ye = { onError: function(a) {
    jr = !0, bi = a;
  } };
  function tt(a, l, m, k, D, z, $, ie, ce) {
    jr = !1, bi = null, Na.apply(Ye, arguments);
  }
  function Dt(a, l, m, k, D, z, $, ie, ce) {
    if (tt.apply(this, arguments), jr) {
      if (jr) {
        var Ee = bi;
        jr = !1, bi = null;
      } else
        throw Error(h(198));
      ai || (ai = !0, le = Ee);
    }
  }
  function qt(a) {
    var l = a, m = a;
    if (a.alternate)
      for (; l.return; )
        l = l.return;
    else {
      a = l;
      do
        l = a, l.flags & 4098 && (m = l.return), a = l.return;
      while (a);
    }
    return l.tag === 3 ? m : null;
  }
  function cn(a) {
    if (a.tag === 13) {
      var l = a.memoizedState;
      if (l === null && (a = a.alternate, a !== null && (l = a.memoizedState)), l !== null)
        return l.dehydrated;
    }
    return null;
  }
  function Zt(a) {
    if (qt(a) !== a)
      throw Error(h(188));
  }
  function Ot(a) {
    var l = a.alternate;
    if (!l) {
      if (l = qt(a), l === null)
        throw Error(h(188));
      return l !== a ? null : a;
    }
    for (var m = a, k = l; ; ) {
      var D = m.return;
      if (D === null)
        break;
      var z = D.alternate;
      if (z === null) {
        if (k = D.return, k !== null) {
          m = k;
          continue;
        }
        break;
      }
      if (D.child === z.child) {
        for (z = D.child; z; ) {
          if (z === m)
            return Zt(D), a;
          if (z === k)
            return Zt(D), l;
          z = z.sibling;
        }
        throw Error(h(188));
      }
      if (m.return !== k.return)
        m = D, k = z;
      else {
        for (var $ = !1, ie = D.child; ie; ) {
          if (ie === m) {
            $ = !0, m = D, k = z;
            break;
          }
          if (ie === k) {
            $ = !0, k = D, m = z;
            break;
          }
          ie = ie.sibling;
        }
        if (!$) {
          for (ie = z.child; ie; ) {
            if (ie === m) {
              $ = !0, m = z, k = D;
              break;
            }
            if (ie === k) {
              $ = !0, k = z, m = D;
              break;
            }
            ie = ie.sibling;
          }
          if (!$)
            throw Error(h(189));
        }
      }
      if (m.alternate !== k)
        throw Error(h(190));
    }
    if (m.tag !== 3)
      throw Error(h(188));
    return m.stateNode.current === m ? a : l;
  }
  function sr(a) {
    return a = Ot(a), a !== null ? Yn(a) : null;
  }
  function Yn(a) {
    if (a.tag === 5 || a.tag === 6)
      return a;
    for (a = a.child; a !== null; ) {
      var l = Yn(a);
      if (l !== null)
        return l;
      a = a.sibling;
    }
    return null;
  }
  var B = u.unstable_scheduleCallback, t = u.unstable_cancelCallback, n = u.unstable_shouldYield, i = u.unstable_requestPaint, o = u.unstable_now, d = u.unstable_getCurrentPriorityLevel, f = u.unstable_ImmediatePriority, p = u.unstable_UserBlockingPriority, y = u.unstable_NormalPriority, S = u.unstable_LowPriority, A = u.unstable_IdlePriority, E = null, L = null;
  function O(a) {
    if (L && typeof L.onCommitFiberRoot == "function")
      try {
        L.onCommitFiberRoot(E, a, void 0, (a.current.flags & 128) === 128);
      } catch {
      }
  }
  var P = Math.clz32 ? Math.clz32 : V, I = Math.log, j = Math.LN2;
  function V(a) {
    return a >>>= 0, a === 0 ? 32 : 31 - (I(a) / j | 0) | 0;
  }
  var Z = 64, b = 4194304;
  function M(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function N(a, l) {
    var m = a.pendingLanes;
    if (m === 0)
      return 0;
    var k = 0, D = a.suspendedLanes, z = a.pingedLanes, $ = m & 268435455;
    if ($ !== 0) {
      var ie = $ & ~D;
      ie !== 0 ? k = M(ie) : (z &= $, z !== 0 && (k = M(z)));
    } else
      $ = m & ~D, $ !== 0 ? k = M($) : z !== 0 && (k = M(z));
    if (k === 0)
      return 0;
    if (l !== 0 && l !== k && !(l & D) && (D = k & -k, z = l & -l, D >= z || D === 16 && (z & 4194240) !== 0))
      return l;
    if (k & 4 && (k |= m & 16), l = a.entangledLanes, l !== 0)
      for (a = a.entanglements, l &= k; 0 < l; )
        m = 31 - P(l), D = 1 << m, k |= a[m], l &= ~D;
    return k;
  }
  function X(a, l) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return l + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Q(a, l) {
    for (var m = a.suspendedLanes, k = a.pingedLanes, D = a.expirationTimes, z = a.pendingLanes; 0 < z; ) {
      var $ = 31 - P(z), ie = 1 << $, ce = D[$];
      ce === -1 ? (!(ie & m) || ie & k) && (D[$] = X(ie, l)) : ce <= l && (a.expiredLanes |= ie), z &= ~ie;
    }
  }
  function ee(a) {
    return a = a.pendingLanes & -1073741825, a !== 0 ? a : a & 1073741824 ? 1073741824 : 0;
  }
  function oe() {
    var a = Z;
    return Z <<= 1, !(Z & 4194240) && (Z = 64), a;
  }
  function fe(a) {
    for (var l = [], m = 0; 31 > m; m++)
      l.push(a);
    return l;
  }
  function ke(a, l, m) {
    a.pendingLanes |= l, l !== 536870912 && (a.suspendedLanes = 0, a.pingedLanes = 0), a = a.eventTimes, l = 31 - P(l), a[l] = m;
  }
  function _e(a, l) {
    var m = a.pendingLanes & ~l;
    a.pendingLanes = l, a.suspendedLanes = 0, a.pingedLanes = 0, a.expiredLanes &= l, a.mutableReadLanes &= l, a.entangledLanes &= l, l = a.entanglements;
    var k = a.eventTimes;
    for (a = a.expirationTimes; 0 < m; ) {
      var D = 31 - P(m), z = 1 << D;
      l[D] = 0, k[D] = -1, a[D] = -1, m &= ~z;
    }
  }
  function Le(a, l) {
    var m = a.entangledLanes |= l;
    for (a = a.entanglements; m; ) {
      var k = 31 - P(m), D = 1 << k;
      D & l | a[k] & l && (a[k] |= l), m &= ~D;
    }
  }
  var Ie = 0;
  function at(a) {
    return a &= -a, 1 < a ? 4 < a ? a & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var Qt, Kt, yt, Mn, zn, vt = !1, Ur = [], Dn = null, si = null, oi = null, yr = /* @__PURE__ */ new Map(), ln = /* @__PURE__ */ new Map(), wn = [], cx = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function za(a, l) {
    switch (a) {
      case "focusin":
      case "focusout":
        Dn = null;
        break;
      case "dragenter":
      case "dragleave":
        si = null;
        break;
      case "mouseover":
      case "mouseout":
        oi = null;
        break;
      case "pointerover":
      case "pointerout":
        yr.delete(l.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        ln.delete(l.pointerId);
    }
  }
  function li(a, l, m, k, D, z) {
    return a === null || a.nativeEvent !== z ? (a = { blockedOn: l, domEventName: m, eventSystemFlags: k, nativeEvent: z, targetContainers: [D] }, l !== null && (l = Zu(l), l !== null && Kt(l)), a) : (a.eventSystemFlags |= k, l = a.targetContainers, D !== null && l.indexOf(D) === -1 && l.push(D), a);
  }
  function qs(a, l, m, k, D) {
    switch (l) {
      case "focusin":
        return Dn = li(Dn, a, l, m, k, D), !0;
      case "dragenter":
        return si = li(si, a, l, m, k, D), !0;
      case "mouseover":
        return oi = li(oi, a, l, m, k, D), !0;
      case "pointerover":
        var z = D.pointerId;
        return yr.set(z, li(yr.get(z) || null, a, l, m, k, D)), !0;
      case "gotpointercapture":
        return z = D.pointerId, ln.set(z, li(ln.get(z) || null, a, l, m, k, D)), !0;
    }
    return !1;
  }
  function Ag(a) {
    var l = pa(a.target);
    if (l !== null) {
      var m = qt(l);
      if (m !== null) {
        if (l = m.tag, l === 13) {
          if (l = cn(m), l !== null) {
            a.blockedOn = l, zn(a.priority, function() {
              yt(m);
            });
            return;
          }
        } else if (l === 3 && m.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = m.tag === 3 ? m.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function Dl(a) {
    if (a.blockedOn !== null)
      return !1;
    for (var l = a.targetContainers; 0 < l.length; ) {
      var m = Xc(a.domEventName, a.eventSystemFlags, l[0], a.nativeEvent);
      if (m === null) {
        m = a.nativeEvent;
        var k = new m.constructor(m.type, m);
        ii = k, m.target.dispatchEvent(k), ii = null;
      } else
        return l = Zu(m), l !== null && Kt(l), a.blockedOn = m, !1;
      l.shift();
    }
    return !0;
  }
  function Bf(a, l, m) {
    Dl(a) && m.delete(l);
  }
  function Tg() {
    vt = !1, Dn !== null && Dl(Dn) && (Dn = null), si !== null && Dl(si) && (si = null), oi !== null && Dl(oi) && (oi = null), yr.forEach(Bf), ln.forEach(Bf);
  }
  function _u(a, l) {
    a.blockedOn === l && (a.blockedOn = null, vt || (vt = !0, u.unstable_scheduleCallback(u.unstable_NormalPriority, Tg)));
  }
  function Pu(a) {
    function l(D) {
      return _u(D, a);
    }
    if (0 < Ur.length) {
      _u(Ur[0], a);
      for (var m = 1; m < Ur.length; m++) {
        var k = Ur[m];
        k.blockedOn === a && (k.blockedOn = null);
      }
    }
    for (Dn !== null && _u(Dn, a), si !== null && _u(si, a), oi !== null && _u(oi, a), yr.forEach(l), ln.forEach(l), m = 0; m < wn.length; m++)
      k = wn[m], k.blockedOn === a && (k.blockedOn = null);
    for (; 0 < wn.length && (m = wn[0], m.blockedOn === null); )
      Ag(m), m.blockedOn === null && wn.shift();
  }
  var Ol = Re.ReactCurrentBatchConfig, Po = !0;
  function Eg(a, l, m, k) {
    var D = Ie, z = Ol.transition;
    Ol.transition = null;
    try {
      Ie = 1, Wc(a, l, m, k);
    } finally {
      Ie = D, Ol.transition = z;
    }
  }
  function Bc(a, l, m, k) {
    var D = Ie, z = Ol.transition;
    Ol.transition = null;
    try {
      Ie = 4, Wc(a, l, m, k);
    } finally {
      Ie = D, Ol.transition = z;
    }
  }
  function Wc(a, l, m, k) {
    if (Po) {
      var D = Xc(a, l, m, k);
      if (D === null)
        rd(a, l, k, Nu, m), za(a, k);
      else if (qs(D, a, l, m, k))
        k.stopPropagation();
      else if (za(a, k), l & 4 && -1 < cx.indexOf(a)) {
        for (; D !== null; ) {
          var z = Zu(D);
          if (z !== null && Qt(z), z = Xc(a, l, m, k), z === null && rd(a, l, k, Nu, m), z === D)
            break;
          D = z;
        }
        D !== null && k.stopPropagation();
      } else
        rd(a, l, k, null, m);
    }
  }
  var Nu = null;
  function Xc(a, l, m, k) {
    if (Nu = null, a = Ln(k), a = pa(a), a !== null)
      if (l = qt(a), l === null)
        a = null;
      else if (m = l.tag, m === 13) {
        if (a = cn(l), a !== null)
          return a;
        a = null;
      } else if (m === 3) {
        if (l.stateNode.current.memoizedState.isDehydrated)
          return l.tag === 3 ? l.stateNode.containerInfo : null;
        a = null;
      } else
        l !== a && (a = null);
    return Nu = a, null;
  }
  function Wf(a) {
    switch (a) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (d()) {
          case f:
            return 1;
          case p:
            return 4;
          case y:
          case S:
            return 16;
          case A:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var gs = null, zu = null, Iu = null;
  function Xf() {
    if (Iu)
      return Iu;
    var a, l = zu, m = l.length, k, D = "value" in gs ? gs.value : gs.textContent, z = D.length;
    for (a = 0; a < m && l[a] === D[a]; a++)
      ;
    var $ = m - a;
    for (k = 1; k <= $ && l[m - k] === D[z - k]; k++)
      ;
    return Iu = D.slice(a, 1 < k ? 1 - k : void 0);
  }
  function _l(a) {
    var l = a.keyCode;
    return "charCode" in a ? (a = a.charCode, a === 0 && l === 13 && (a = 13)) : a = l, a === 10 && (a = 13), 32 <= a || a === 13 ? a : 0;
  }
  function Fu() {
    return !0;
  }
  function Rg() {
    return !1;
  }
  function Ji(a) {
    function l(m, k, D, z, $) {
      this._reactName = m, this._targetInst = D, this.type = k, this.nativeEvent = z, this.target = $, this.currentTarget = null;
      for (var ie in a)
        a.hasOwnProperty(ie) && (m = a[ie], this[ie] = m ? m(z) : z[ie]);
      return this.isDefaultPrevented = (z.defaultPrevented != null ? z.defaultPrevented : z.returnValue === !1) ? Fu : Rg, this.isPropagationStopped = Rg, this;
    }
    return ye(l.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var m = this.nativeEvent;
      m && (m.preventDefault ? m.preventDefault() : typeof m.returnValue != "unknown" && (m.returnValue = !1), this.isDefaultPrevented = Fu);
    }, stopPropagation: function() {
      var m = this.nativeEvent;
      m && (m.stopPropagation ? m.stopPropagation() : typeof m.cancelBubble != "unknown" && (m.cancelBubble = !0), this.isPropagationStopped = Fu);
    }, persist: function() {
    }, isPersistent: Fu }), l;
  }
  var Zs = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Vc = Ji(Zs), Pl = ye({}, Zs, { view: 0, detail: 0 }), Lg = Ji(Pl), Gc, Vf, Yu, _r = ye({}, Pl, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Zf, button: 0, buttons: 0, relatedTarget: function(a) {
    return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  }, movementX: function(a) {
    return "movementX" in a ? a.movementX : (a !== Yu && (Yu && a.type === "mousemove" ? (Gc = a.screenX - Yu.screenX, Vf = a.screenY - Yu.screenY) : Vf = Gc = 0, Yu = a), Gc);
  }, movementY: function(a) {
    return "movementY" in a ? a.movementY : Vf;
  } }), $c = Ji(_r), Mg = ye({}, _r, { dataTransfer: 0 }), Dg = Ji(Mg), dx = ye({}, Pl, { relatedTarget: 0 }), Qs = Ji(dx), Gf = ye({}, Zs, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Og = Ji(Gf), fx = ye({}, Zs, { clipboardData: function(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } }), hx = Ji(fx), px = ye({}, Zs, { data: 0 }), $f = Ji(px), qf = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, _g = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Pg = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Ng(a) {
    var l = this.nativeEvent;
    return l.getModifierState ? l.getModifierState(a) : (a = Pg[a]) ? !!l[a] : !1;
  }
  function Zf() {
    return Ng;
  }
  var vs = ye({}, Pl, { key: function(a) {
    if (a.key) {
      var l = qf[a.key] || a.key;
      if (l !== "Unidentified")
        return l;
    }
    return a.type === "keypress" ? (a = _l(a), a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? _g[a.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Zf, charCode: function(a) {
    return a.type === "keypress" ? _l(a) : 0;
  }, keyCode: function(a) {
    return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
  }, which: function(a) {
    return a.type === "keypress" ? _l(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
  } }), gx = Ji(vs), Qf = ye({}, _r, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), qc = Ji(Qf), Kf = ye({}, Pl, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Zf }), vx = Ji(Kf), Zc = ye({}, Zs, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), zg = Ji(Zc), _i = ye({}, _r, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), ms = Ji(_i), xr = [9, 13, 27, 32], Ia = F && "CompositionEvent" in window, No = null;
  F && "documentMode" in document && (No = document.documentMode);
  var Qc = F && "TextEvent" in window && !No, Ig = F && (!Ia || No && 8 < No && 11 >= No), Nl = String.fromCharCode(32), Fg = !1;
  function Yg(a, l) {
    switch (a) {
      case "keyup":
        return xr.indexOf(l.keyCode) !== -1;
      case "keydown":
        return l.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Kc(a) {
    return a = a.detail, typeof a == "object" && "data" in a ? a.data : null;
  }
  var zl = !1;
  function mx(a, l) {
    switch (a) {
      case "compositionend":
        return Kc(l);
      case "keypress":
        return l.which !== 32 ? null : (Fg = !0, Nl);
      case "textInput":
        return a = l.data, a === Nl && Fg ? null : a;
      default:
        return null;
    }
  }
  function yx(a, l) {
    if (zl)
      return a === "compositionend" || !Ia && Yg(a, l) ? (a = Xf(), Iu = zu = gs = null, zl = !1, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) {
          if (l.char && 1 < l.char.length)
            return l.char;
          if (l.which)
            return String.fromCharCode(l.which);
        }
        return null;
      case "compositionend":
        return Ig && l.locale !== "ko" ? null : l.data;
      default:
        return null;
    }
  }
  var Hg = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function jg(a) {
    var l = a && a.nodeName && a.nodeName.toLowerCase();
    return l === "input" ? !!Hg[a.type] : l === "textarea";
  }
  function Ug(a, l, m, k) {
    ds(k), l = Gu(l, "onChange"), 0 < l.length && (m = new Vc("onChange", "change", null, m, k), a.push({ event: m, listeners: l }));
  }
  var Hu = null, Il = null;
  function Fl(a) {
    nd(a, 0);
  }
  function Yl(a) {
    var l = jl(a);
    if (qe(l))
      return a;
  }
  function Bg(a, l) {
    if (a === "change")
      return l;
  }
  var Jf = !1;
  if (F) {
    var eh;
    if (F) {
      var th = "oninput" in document;
      if (!th) {
        var Wg = document.createElement("div");
        Wg.setAttribute("oninput", "return;"), th = typeof Wg.oninput == "function";
      }
      eh = th;
    } else
      eh = !1;
    Jf = eh && (!document.documentMode || 9 < document.documentMode);
  }
  function Xg() {
    Hu && (Hu.detachEvent("onpropertychange", Vg), Il = Hu = null);
  }
  function Vg(a) {
    if (a.propertyName === "value" && Yl(Il)) {
      var l = [];
      Ug(l, Il, a, Ln(a)), Gs(Fl, l);
    }
  }
  function xx(a, l, m) {
    a === "focusin" ? (Xg(), Hu = l, Il = m, Hu.attachEvent("onpropertychange", Vg)) : a === "focusout" && Xg();
  }
  function bx(a) {
    if (a === "selectionchange" || a === "keyup" || a === "keydown")
      return Yl(Il);
  }
  function wx(a, l) {
    if (a === "click")
      return Yl(l);
  }
  function Gg(a, l) {
    if (a === "input" || a === "change")
      return Yl(l);
  }
  function Sx(a, l) {
    return a === l && (a !== 0 || 1 / a === 1 / l) || a !== a && l !== l;
  }
  var ha = typeof Object.is == "function" ? Object.is : Sx;
  function ju(a, l) {
    if (ha(a, l))
      return !0;
    if (typeof a != "object" || a === null || typeof l != "object" || l === null)
      return !1;
    var m = Object.keys(a), k = Object.keys(l);
    if (m.length !== k.length)
      return !1;
    for (k = 0; k < m.length; k++) {
      var D = m[k];
      if (!Y.call(l, D) || !ha(a[D], l[D]))
        return !1;
    }
    return !0;
  }
  function $g(a) {
    for (; a && a.firstChild; )
      a = a.firstChild;
    return a;
  }
  function qg(a, l) {
    var m = $g(a);
    a = 0;
    for (var k; m; ) {
      if (m.nodeType === 3) {
        if (k = a + m.textContent.length, a <= l && k >= l)
          return { node: m, offset: l - a };
        a = k;
      }
      e: {
        for (; m; ) {
          if (m.nextSibling) {
            m = m.nextSibling;
            break e;
          }
          m = m.parentNode;
        }
        m = void 0;
      }
      m = $g(m);
    }
  }
  function Zg(a, l) {
    return a && l ? a === l ? !0 : a && a.nodeType === 3 ? !1 : l && l.nodeType === 3 ? Zg(a, l.parentNode) : "contains" in a ? a.contains(l) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(l) & 16) : !1 : !1;
  }
  function Jc() {
    for (var a = window, l = pn(); l instanceof a.HTMLIFrameElement; ) {
      try {
        var m = typeof l.contentWindow.location.href == "string";
      } catch {
        m = !1;
      }
      if (m)
        a = l.contentWindow;
      else
        break;
      l = pn(a.document);
    }
    return l;
  }
  function ys(a) {
    var l = a && a.nodeName && a.nodeName.toLowerCase();
    return l && (l === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || l === "textarea" || a.contentEditable === "true");
  }
  function ed(a) {
    var l = Jc(), m = a.focusedElem, k = a.selectionRange;
    if (l !== m && m && m.ownerDocument && Zg(m.ownerDocument.documentElement, m)) {
      if (k !== null && ys(m)) {
        if (l = k.start, a = k.end, a === void 0 && (a = l), "selectionStart" in m)
          m.selectionStart = l, m.selectionEnd = Math.min(a, m.value.length);
        else if (a = (l = m.ownerDocument || document) && l.defaultView || window, a.getSelection) {
          a = a.getSelection();
          var D = m.textContent.length, z = Math.min(k.start, D);
          k = k.end === void 0 ? z : Math.min(k.end, D), !a.extend && z > k && (D = k, k = z, z = D), D = qg(m, z);
          var $ = qg(
            m,
            k
          );
          D && $ && (a.rangeCount !== 1 || a.anchorNode !== D.node || a.anchorOffset !== D.offset || a.focusNode !== $.node || a.focusOffset !== $.offset) && (l = l.createRange(), l.setStart(D.node, D.offset), a.removeAllRanges(), z > k ? (a.addRange(l), a.extend($.node, $.offset)) : (l.setEnd($.node, $.offset), a.addRange(l)));
        }
      }
      for (l = [], a = m; a = a.parentNode; )
        a.nodeType === 1 && l.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      for (typeof m.focus == "function" && m.focus(), m = 0; m < l.length; m++)
        a = l[m], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
    }
  }
  var Qg = F && "documentMode" in document && 11 >= document.documentMode, Fa = null, nh = null, Uu = null, rh = !1;
  function Kg(a, l, m) {
    var k = m.window === m ? m.document : m.nodeType === 9 ? m : m.ownerDocument;
    rh || Fa == null || Fa !== pn(k) || (k = Fa, "selectionStart" in k && ys(k) ? k = { start: k.selectionStart, end: k.selectionEnd } : (k = (k.ownerDocument && k.ownerDocument.defaultView || window).getSelection(), k = { anchorNode: k.anchorNode, anchorOffset: k.anchorOffset, focusNode: k.focusNode, focusOffset: k.focusOffset }), Uu && ju(Uu, k) || (Uu = k, k = Gu(nh, "onSelect"), 0 < k.length && (l = new Vc("onSelect", "select", null, l, m), a.push({ event: l, listeners: k }), l.target = Fa)));
  }
  function td(a, l) {
    var m = {};
    return m[a.toLowerCase()] = l.toLowerCase(), m["Webkit" + a] = "webkit" + l, m["Moz" + a] = "moz" + l, m;
  }
  var zo = { animationend: td("Animation", "AnimationEnd"), animationiteration: td("Animation", "AnimationIteration"), animationstart: td("Animation", "AnimationStart"), transitionend: td("Transition", "TransitionEnd") }, ih = {}, ah = {};
  F && (ah = document.createElement("div").style, "AnimationEvent" in window || (delete zo.animationend.animation, delete zo.animationiteration.animation, delete zo.animationstart.animation), "TransitionEvent" in window || delete zo.transitionend.transition);
  function Pr(a) {
    if (ih[a])
      return ih[a];
    if (!zo[a])
      return a;
    var l = zo[a], m;
    for (m in l)
      if (l.hasOwnProperty(m) && m in ah)
        return ih[a] = l[m];
    return a;
  }
  var sh = Pr("animationend"), Jg = Pr("animationiteration"), ev = Pr("animationstart"), tv = Pr("transitionend"), nv = /* @__PURE__ */ new Map(), rv = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function xs(a, l) {
    nv.set(a, l), C(l, [a]);
  }
  for (var Bu = 0; Bu < rv.length; Bu++) {
    var Io = rv[Bu], kx = Io.toLowerCase(), Wu = Io[0].toUpperCase() + Io.slice(1);
    xs(kx, "on" + Wu);
  }
  xs(sh, "onAnimationEnd"), xs(Jg, "onAnimationIteration"), xs(ev, "onAnimationStart"), xs("dblclick", "onDoubleClick"), xs("focusin", "onFocus"), xs("focusout", "onBlur"), xs(tv, "onTransitionEnd"), T("onMouseEnter", ["mouseout", "mouseover"]), T("onMouseLeave", ["mouseout", "mouseover"]), T("onPointerEnter", ["pointerout", "pointerover"]), T("onPointerLeave", ["pointerout", "pointerover"]), C("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), C("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), C("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), C("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), C("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), C("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Xu = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Cx = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xu));
  function iv(a, l, m) {
    var k = a.type || "unknown-event";
    a.currentTarget = m, Dt(k, l, void 0, a), a.currentTarget = null;
  }
  function nd(a, l) {
    l = (l & 4) !== 0;
    for (var m = 0; m < a.length; m++) {
      var k = a[m], D = k.event;
      k = k.listeners;
      e: {
        var z = void 0;
        if (l)
          for (var $ = k.length - 1; 0 <= $; $--) {
            var ie = k[$], ce = ie.instance, Ee = ie.currentTarget;
            if (ie = ie.listener, ce !== z && D.isPropagationStopped())
              break e;
            iv(D, ie, Ee), z = ce;
          }
        else
          for ($ = 0; $ < k.length; $++) {
            if (ie = k[$], ce = ie.instance, Ee = ie.currentTarget, ie = ie.listener, ce !== z && D.isPropagationStopped())
              break e;
            iv(D, ie, Ee), z = ce;
          }
      }
    }
    if (ai)
      throw a = le, ai = !1, le = null, a;
  }
  function In(a, l) {
    var m = l[hh];
    m === void 0 && (m = l[hh] = /* @__PURE__ */ new Set());
    var k = a + "__bubble";
    m.has(k) || (av(l, a, 2, !1), m.add(k));
  }
  function Ks(a, l, m) {
    var k = 0;
    l && (k |= 4), av(m, a, k, l);
  }
  var bs = "_reactListening" + Math.random().toString(36).slice(2);
  function Hl(a) {
    if (!a[bs]) {
      a[bs] = !0, v.forEach(function(m) {
        m !== "selectionchange" && (Cx.has(m) || Ks(m, !1, a), Ks(m, !0, a));
      });
      var l = a.nodeType === 9 ? a : a.ownerDocument;
      l === null || l[bs] || (l[bs] = !0, Ks("selectionchange", !1, l));
    }
  }
  function av(a, l, m, k) {
    switch (Wf(l)) {
      case 1:
        var D = Eg;
        break;
      case 4:
        D = Bc;
        break;
      default:
        D = Wc;
    }
    m = D.bind(null, l, m, a), D = void 0, !$s || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (D = !0), k ? D !== void 0 ? a.addEventListener(l, m, { capture: !0, passive: D }) : a.addEventListener(l, m, !0) : D !== void 0 ? a.addEventListener(l, m, { passive: D }) : a.addEventListener(l, m, !1);
  }
  function rd(a, l, m, k, D) {
    var z = k;
    if (!(l & 1) && !(l & 2) && k !== null)
      e:
        for (; ; ) {
          if (k === null)
            return;
          var $ = k.tag;
          if ($ === 3 || $ === 4) {
            var ie = k.stateNode.containerInfo;
            if (ie === D || ie.nodeType === 8 && ie.parentNode === D)
              break;
            if ($ === 4)
              for ($ = k.return; $ !== null; ) {
                var ce = $.tag;
                if ((ce === 3 || ce === 4) && (ce = $.stateNode.containerInfo, ce === D || ce.nodeType === 8 && ce.parentNode === D))
                  return;
                $ = $.return;
              }
            for (; ie !== null; ) {
              if ($ = pa(ie), $ === null)
                return;
              if (ce = $.tag, ce === 5 || ce === 6) {
                k = z = $;
                continue e;
              }
              ie = ie.parentNode;
            }
          }
          k = k.return;
        }
    Gs(function() {
      var Ee = z, He = Ln(m), Be = [];
      e: {
        var Fe = nv.get(a);
        if (Fe !== void 0) {
          var lt = Vc, xt = a;
          switch (a) {
            case "keypress":
              if (_l(m) === 0)
                break e;
            case "keydown":
            case "keyup":
              lt = gx;
              break;
            case "focusin":
              xt = "focus", lt = Qs;
              break;
            case "focusout":
              xt = "blur", lt = Qs;
              break;
            case "beforeblur":
            case "afterblur":
              lt = Qs;
              break;
            case "click":
              if (m.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              lt = $c;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              lt = Dg;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              lt = vx;
              break;
            case sh:
            case Jg:
            case ev:
              lt = Og;
              break;
            case tv:
              lt = zg;
              break;
            case "scroll":
              lt = Lg;
              break;
            case "wheel":
              lt = ms;
              break;
            case "copy":
            case "cut":
            case "paste":
              lt = hx;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              lt = qc;
          }
          var Ct = (l & 4) !== 0, hr = !Ct && a === "scroll", me = Ct ? Fe !== null ? Fe + "Capture" : null : Fe;
          Ct = [];
          for (var pe = Ee, Se; pe !== null; ) {
            Se = pe;
            var $e = Se.stateNode;
            if (Se.tag === 5 && $e !== null && (Se = $e, me !== null && ($e = ps(pe, me), $e != null && Ct.push(Vu(pe, $e, Se)))), hr)
              break;
            pe = pe.return;
          }
          0 < Ct.length && (Fe = new lt(Fe, xt, null, m, He), Be.push({ event: Fe, listeners: Ct }));
        }
      }
      if (!(l & 7)) {
        e: {
          if (Fe = a === "mouseover" || a === "pointerover", lt = a === "mouseout" || a === "pointerout", Fe && m !== ii && (xt = m.relatedTarget || m.fromElement) && (pa(xt) || xt[ws]))
            break e;
          if ((lt || Fe) && (Fe = He.window === He ? He : (Fe = He.ownerDocument) ? Fe.defaultView || Fe.parentWindow : window, lt ? (xt = m.relatedTarget || m.toElement, lt = Ee, xt = xt ? pa(xt) : null, xt !== null && (hr = qt(xt), xt !== hr || xt.tag !== 5 && xt.tag !== 6) && (xt = null)) : (lt = null, xt = Ee), lt !== xt)) {
            if (Ct = $c, $e = "onMouseLeave", me = "onMouseEnter", pe = "mouse", (a === "pointerout" || a === "pointerover") && (Ct = qc, $e = "onPointerLeave", me = "onPointerEnter", pe = "pointer"), hr = lt == null ? Fe : jl(lt), Se = xt == null ? Fe : jl(xt), Fe = new Ct($e, pe + "leave", lt, m, He), Fe.target = hr, Fe.relatedTarget = Se, $e = null, pa(He) === Ee && (Ct = new Ct(me, pe + "enter", xt, m, He), Ct.target = Se, Ct.relatedTarget = hr, $e = Ct), hr = $e, lt && xt)
              t: {
                for (Ct = lt, me = xt, pe = 0, Se = Ct; Se; Se = Fo(Se))
                  pe++;
                for (Se = 0, $e = me; $e; $e = Fo($e))
                  Se++;
                for (; 0 < pe - Se; )
                  Ct = Fo(Ct), pe--;
                for (; 0 < Se - pe; )
                  me = Fo(me), Se--;
                for (; pe--; ) {
                  if (Ct === me || me !== null && Ct === me.alternate)
                    break t;
                  Ct = Fo(Ct), me = Fo(me);
                }
                Ct = null;
              }
            else
              Ct = null;
            lt !== null && oh(Be, Fe, lt, Ct, !1), xt !== null && hr !== null && oh(Be, hr, xt, Ct, !0);
          }
        }
        e: {
          if (Fe = Ee ? jl(Ee) : window, lt = Fe.nodeName && Fe.nodeName.toLowerCase(), lt === "select" || lt === "input" && Fe.type === "file")
            var At = Bg;
          else if (jg(Fe))
            if (Jf)
              At = Gg;
            else {
              At = bx;
              var bt = xx;
            }
          else
            (lt = Fe.nodeName) && lt.toLowerCase() === "input" && (Fe.type === "checkbox" || Fe.type === "radio") && (At = wx);
          if (At && (At = At(a, Ee))) {
            Ug(Be, At, m, He);
            break e;
          }
          bt && bt(a, Fe, Ee), a === "focusout" && (bt = Fe._wrapperState) && bt.controlled && Fe.type === "number" && Zi(Fe, "number", Fe.value);
        }
        switch (bt = Ee ? jl(Ee) : window, a) {
          case "focusin":
            (jg(bt) || bt.contentEditable === "true") && (Fa = bt, nh = Ee, Uu = null);
            break;
          case "focusout":
            Uu = nh = Fa = null;
            break;
          case "mousedown":
            rh = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            rh = !1, Kg(Be, m, He);
            break;
          case "selectionchange":
            if (Qg)
              break;
          case "keydown":
          case "keyup":
            Kg(Be, m, He);
        }
        var Mt;
        if (Ia)
          e: {
            switch (a) {
              case "compositionstart":
                var Xt = "onCompositionStart";
                break e;
              case "compositionend":
                Xt = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Xt = "onCompositionUpdate";
                break e;
            }
            Xt = void 0;
          }
        else
          zl ? Yg(a, m) && (Xt = "onCompositionEnd") : a === "keydown" && m.keyCode === 229 && (Xt = "onCompositionStart");
        Xt && (Ig && m.locale !== "ko" && (zl || Xt !== "onCompositionStart" ? Xt === "onCompositionEnd" && zl && (Mt = Xf()) : (gs = He, zu = "value" in gs ? gs.value : gs.textContent, zl = !0)), bt = Gu(Ee, Xt), 0 < bt.length && (Xt = new $f(Xt, a, null, m, He), Be.push({ event: Xt, listeners: bt }), Mt ? Xt.data = Mt : (Mt = Kc(m), Mt !== null && (Xt.data = Mt)))), (Mt = Qc ? mx(a, m) : yx(a, m)) && (Ee = Gu(Ee, "onBeforeInput"), 0 < Ee.length && (He = new $f("onBeforeInput", "beforeinput", null, m, He), Be.push({ event: He, listeners: Ee }), He.data = Mt));
      }
      nd(Be, l);
    });
  }
  function Vu(a, l, m) {
    return { instance: a, listener: l, currentTarget: m };
  }
  function Gu(a, l) {
    for (var m = l + "Capture", k = []; a !== null; ) {
      var D = a, z = D.stateNode;
      D.tag === 5 && z !== null && (D = z, z = ps(a, m), z != null && k.unshift(Vu(a, z, D)), z = ps(a, l), z != null && k.push(Vu(a, z, D))), a = a.return;
    }
    return k;
  }
  function Fo(a) {
    if (a === null)
      return null;
    do
      a = a.return;
    while (a && a.tag !== 5);
    return a || null;
  }
  function oh(a, l, m, k, D) {
    for (var z = l._reactName, $ = []; m !== null && m !== k; ) {
      var ie = m, ce = ie.alternate, Ee = ie.stateNode;
      if (ce !== null && ce === k)
        break;
      ie.tag === 5 && Ee !== null && (ie = Ee, D ? (ce = ps(m, z), ce != null && $.unshift(Vu(m, ce, ie))) : D || (ce = ps(m, z), ce != null && $.push(Vu(m, ce, ie)))), m = m.return;
    }
    $.length !== 0 && a.push({ event: l, listeners: $ });
  }
  var lh = /\r\n?/g, Ax = /\u0000|\uFFFD/g;
  function uh(a) {
    return (typeof a == "string" ? a : "" + a).replace(lh, `
`).replace(Ax, "");
  }
  function id(a, l, m) {
    if (l = uh(l), uh(a) !== l && m)
      throw Error(h(425));
  }
  function ad() {
  }
  var ch = null, Yo = null;
  function $u(a, l) {
    return a === "textarea" || a === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null;
  }
  var Ho = typeof setTimeout == "function" ? setTimeout : void 0, sv = typeof clearTimeout == "function" ? clearTimeout : void 0, dh = typeof Promise == "function" ? Promise : void 0, fh = typeof queueMicrotask == "function" ? queueMicrotask : typeof dh < "u" ? function(a) {
    return dh.resolve(null).then(a).catch(Tx);
  } : Ho;
  function Tx(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function Js(a, l) {
    var m = l, k = 0;
    do {
      var D = m.nextSibling;
      if (a.removeChild(m), D && D.nodeType === 8)
        if (m = D.data, m === "/$") {
          if (k === 0) {
            a.removeChild(D), Pu(l);
            return;
          }
          k--;
        } else
          m !== "$" && m !== "$?" && m !== "$!" || k++;
      m = D;
    } while (m);
    Pu(l);
  }
  function Ya(a) {
    for (; a != null; a = a.nextSibling) {
      var l = a.nodeType;
      if (l === 1 || l === 3)
        break;
      if (l === 8) {
        if (l = a.data, l === "$" || l === "$!" || l === "$?")
          break;
        if (l === "/$")
          return null;
      }
    }
    return a;
  }
  function qu(a) {
    a = a.previousSibling;
    for (var l = 0; a; ) {
      if (a.nodeType === 8) {
        var m = a.data;
        if (m === "$" || m === "$!" || m === "$?") {
          if (l === 0)
            return a;
          l--;
        } else
          m === "/$" && l++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var eo = Math.random().toString(36).slice(2), Ga = "__reactFiber$" + eo, jo = "__reactProps$" + eo, ws = "__reactContainer$" + eo, hh = "__reactEvents$" + eo, Ex = "__reactListeners$" + eo, ph = "__reactHandles$" + eo;
  function pa(a) {
    var l = a[Ga];
    if (l)
      return l;
    for (var m = a.parentNode; m; ) {
      if (l = m[ws] || m[Ga]) {
        if (m = l.alternate, l.child !== null || m !== null && m.child !== null)
          for (a = qu(a); a !== null; ) {
            if (m = a[Ga])
              return m;
            a = qu(a);
          }
        return l;
      }
      a = m, m = a.parentNode;
    }
    return null;
  }
  function Zu(a) {
    return a = a[Ga] || a[ws], !a || a.tag !== 5 && a.tag !== 6 && a.tag !== 13 && a.tag !== 3 ? null : a;
  }
  function jl(a) {
    if (a.tag === 5 || a.tag === 6)
      return a.stateNode;
    throw Error(h(33));
  }
  function _t(a) {
    return a[jo] || null;
  }
  var to = [], Bn = -1;
  function Jt(a) {
    return { current: a };
  }
  function Sn(a) {
    0 > Bn || (a.current = to[Bn], to[Bn] = null, Bn--);
  }
  function An(a, l) {
    Bn++, to[Bn] = a.current, a.current = l;
  }
  var $a = {}, Wt = Jt($a), or = Jt(!1), Pi = $a;
  function ga(a, l) {
    var m = a.type.contextTypes;
    if (!m)
      return $a;
    var k = a.stateNode;
    if (k && k.__reactInternalMemoizedUnmaskedChildContext === l)
      return k.__reactInternalMemoizedMaskedChildContext;
    var D = {}, z;
    for (z in m)
      D[z] = l[z];
    return k && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = l, a.__reactInternalMemoizedMaskedChildContext = D), D;
  }
  function qn(a) {
    return a = a.childContextTypes, a != null;
  }
  function va() {
    Sn(or), Sn(Wt);
  }
  function no(a, l, m) {
    if (Wt.current !== $a)
      throw Error(h(168));
    An(Wt, l), An(or, m);
  }
  function Qu(a, l, m) {
    var k = a.stateNode;
    if (l = l.childContextTypes, typeof k.getChildContext != "function")
      return m;
    k = k.getChildContext();
    for (var D in k)
      if (!(D in l))
        throw Error(h(108, It(a) || "Unknown", D));
    return ye({}, m, k);
  }
  function sd(a) {
    return a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || $a, Pi = Wt.current, An(Wt, a), An(or, or.current), !0;
  }
  function ov(a, l, m) {
    var k = a.stateNode;
    if (!k)
      throw Error(h(169));
    m ? (a = Qu(a, l, Pi), k.__reactInternalMemoizedMergedChildContext = a, Sn(or), Sn(Wt), An(Wt, a)) : Sn(or), An(or, m);
  }
  var ea = null, Nr = !1, Ku = !1;
  function gh(a) {
    ea === null ? ea = [a] : ea.push(a);
  }
  function vh(a) {
    Nr = !0, gh(a);
  }
  function Ni() {
    if (!Ku && ea !== null) {
      Ku = !0;
      var a = 0, l = Ie;
      try {
        var m = ea;
        for (Ie = 1; a < m.length; a++) {
          var k = m[a];
          do
            k = k(!0);
          while (k !== null);
        }
        ea = null, Nr = !1;
      } catch (D) {
        throw ea !== null && (ea = ea.slice(a + 1)), B(f, Ni), D;
      } finally {
        Ie = l, Ku = !1;
      }
    }
    return null;
  }
  var ro = [], zi = 0, Uo = null, Ul = 0, Ii = [], ui = 0, ma = null, Br = 1, Ss = "";
  function ta(a, l) {
    ro[zi++] = Ul, ro[zi++] = Uo, Uo = a, Ul = l;
  }
  function mh(a, l, m) {
    Ii[ui++] = Br, Ii[ui++] = Ss, Ii[ui++] = ma, ma = a;
    var k = Br;
    a = Ss;
    var D = 32 - P(k) - 1;
    k &= ~(1 << D), m += 1;
    var z = 32 - P(l) + D;
    if (30 < z) {
      var $ = D - D % 5;
      z = (k & (1 << $) - 1).toString(32), k >>= $, D -= $, Br = 1 << 32 - P(l) + D | m << D | k, Ss = z + a;
    } else
      Br = 1 << z | m << D | k, Ss = a;
  }
  function od(a) {
    a.return !== null && (ta(a, 1), mh(a, 1, 0));
  }
  function yh(a) {
    for (; a === Uo; )
      Uo = ro[--zi], ro[zi] = null, Ul = ro[--zi], ro[zi] = null;
    for (; a === ma; )
      ma = Ii[--ui], Ii[ui] = null, Ss = Ii[--ui], Ii[ui] = null, Br = Ii[--ui], Ii[ui] = null;
  }
  var na = null, Fi = null, Wn = !1, ya = null;
  function xh(a, l) {
    var m = Ca(5, null, null, 0);
    m.elementType = "DELETED", m.stateNode = l, m.return = a, l = a.deletions, l === null ? (a.deletions = [m], a.flags |= 16) : l.push(m);
  }
  function lv(a, l) {
    switch (a.tag) {
      case 5:
        var m = a.type;
        return l = l.nodeType !== 1 || m.toLowerCase() !== l.nodeName.toLowerCase() ? null : l, l !== null ? (a.stateNode = l, na = a, Fi = Ya(l.firstChild), !0) : !1;
      case 6:
        return l = a.pendingProps === "" || l.nodeType !== 3 ? null : l, l !== null ? (a.stateNode = l, na = a, Fi = null, !0) : !1;
      case 13:
        return l = l.nodeType !== 8 ? null : l, l !== null ? (m = ma !== null ? { id: Br, overflow: Ss } : null, a.memoizedState = { dehydrated: l, treeContext: m, retryLane: 1073741824 }, m = Ca(18, null, null, 0), m.stateNode = l, m.return = a, a.child = m, na = a, Fi = null, !0) : !1;
      default:
        return !1;
    }
  }
  function ld(a) {
    return (a.mode & 1) !== 0 && (a.flags & 128) === 0;
  }
  function ud(a) {
    if (Wn) {
      var l = Fi;
      if (l) {
        var m = l;
        if (!lv(a, l)) {
          if (ld(a))
            throw Error(h(418));
          l = Ya(m.nextSibling);
          var k = na;
          l && lv(a, l) ? xh(k, m) : (a.flags = a.flags & -4097 | 2, Wn = !1, na = a);
        }
      } else {
        if (ld(a))
          throw Error(h(418));
        a.flags = a.flags & -4097 | 2, Wn = !1, na = a;
      }
    }
  }
  function uv(a) {
    for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; )
      a = a.return;
    na = a;
  }
  function cd(a) {
    if (a !== na)
      return !1;
    if (!Wn)
      return uv(a), Wn = !0, !1;
    var l;
    if ((l = a.tag !== 3) && !(l = a.tag !== 5) && (l = a.type, l = l !== "head" && l !== "body" && !$u(a.type, a.memoizedProps)), l && (l = Fi)) {
      if (ld(a))
        throw cv(), Error(h(418));
      for (; l; )
        xh(a, l), l = Ya(l.nextSibling);
    }
    if (uv(a), a.tag === 13) {
      if (a = a.memoizedState, a = a !== null ? a.dehydrated : null, !a)
        throw Error(h(317));
      e: {
        for (a = a.nextSibling, l = 0; a; ) {
          if (a.nodeType === 8) {
            var m = a.data;
            if (m === "/$") {
              if (l === 0) {
                Fi = Ya(a.nextSibling);
                break e;
              }
              l--;
            } else
              m !== "$" && m !== "$!" && m !== "$?" || l++;
          }
          a = a.nextSibling;
        }
        Fi = null;
      }
    } else
      Fi = na ? Ya(a.stateNode.nextSibling) : null;
    return !0;
  }
  function cv() {
    for (var a = Fi; a; )
      a = Ya(a.nextSibling);
  }
  function Qn() {
    Fi = na = null, Wn = !1;
  }
  function bh(a) {
    ya === null ? ya = [a] : ya.push(a);
  }
  var dd = Re.ReactCurrentBatchConfig;
  function ra(a, l) {
    if (a && a.defaultProps) {
      l = ye({}, l), a = a.defaultProps;
      for (var m in a)
        l[m] === void 0 && (l[m] = a[m]);
      return l;
    }
    return l;
  }
  var qa = Jt(null), fd = null, io = null, wh = null;
  function Sh() {
    wh = io = fd = null;
  }
  function ao(a) {
    var l = qa.current;
    Sn(qa), a._currentValue = l;
  }
  function zr(a, l, m) {
    for (; a !== null; ) {
      var k = a.alternate;
      if ((a.childLanes & l) !== l ? (a.childLanes |= l, k !== null && (k.childLanes |= l)) : k !== null && (k.childLanes & l) !== l && (k.childLanes |= l), a === m)
        break;
      a = a.return;
    }
  }
  function nt(a, l) {
    fd = a, wh = io = null, a = a.dependencies, a !== null && a.firstContext !== null && (a.lanes & l && (br = !0), a.firstContext = null);
  }
  function fr(a) {
    var l = a._currentValue;
    if (wh !== a)
      if (a = { context: a, memoizedValue: l, next: null }, io === null) {
        if (fd === null)
          throw Error(h(308));
        io = a, fd.dependencies = { lanes: 0, firstContext: a };
      } else
        io = io.next = a;
    return l;
  }
  var Wr = null;
  function kh(a) {
    Wr === null ? Wr = [a] : Wr.push(a);
  }
  function dv(a, l, m, k) {
    var D = l.interleaved;
    return D === null ? (m.next = m, kh(l)) : (m.next = D.next, D.next = m), l.interleaved = m, ks(a, k);
  }
  function ks(a, l) {
    a.lanes |= l;
    var m = a.alternate;
    for (m !== null && (m.lanes |= l), m = a, a = a.return; a !== null; )
      a.childLanes |= l, m = a.alternate, m !== null && (m.childLanes |= l), m = a, a = a.return;
    return m.tag === 3 ? m.stateNode : null;
  }
  var so = !1;
  function Ch(a) {
    a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Cr(a, l) {
    a = a.updateQueue, l.updateQueue === a && (l.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
  }
  function Cs(a, l) {
    return { eventTime: a, lane: l, tag: 0, payload: null, callback: null, next: null };
  }
  function oo(a, l, m) {
    var k = a.updateQueue;
    if (k === null)
      return null;
    if (k = k.shared, sn & 2) {
      var D = k.pending;
      return D === null ? l.next = l : (l.next = D.next, D.next = l), k.pending = l, ks(a, m);
    }
    return D = k.interleaved, D === null ? (l.next = l, kh(k)) : (l.next = D.next, D.next = l), k.interleaved = l, ks(a, m);
  }
  function hd(a, l, m) {
    if (l = l.updateQueue, l !== null && (l = l.shared, (m & 4194240) !== 0)) {
      var k = l.lanes;
      k &= a.pendingLanes, m |= k, l.lanes = m, Le(a, m);
    }
  }
  function Ah(a, l) {
    var m = a.updateQueue, k = a.alternate;
    if (k !== null && (k = k.updateQueue, m === k)) {
      var D = null, z = null;
      if (m = m.firstBaseUpdate, m !== null) {
        do {
          var $ = { eventTime: m.eventTime, lane: m.lane, tag: m.tag, payload: m.payload, callback: m.callback, next: null };
          z === null ? D = z = $ : z = z.next = $, m = m.next;
        } while (m !== null);
        z === null ? D = z = l : z = z.next = l;
      } else
        D = z = l;
      m = { baseState: k.baseState, firstBaseUpdate: D, lastBaseUpdate: z, shared: k.shared, effects: k.effects }, a.updateQueue = m;
      return;
    }
    a = m.lastBaseUpdate, a === null ? m.firstBaseUpdate = l : a.next = l, m.lastBaseUpdate = l;
  }
  function lo(a, l, m, k) {
    var D = a.updateQueue;
    so = !1;
    var z = D.firstBaseUpdate, $ = D.lastBaseUpdate, ie = D.shared.pending;
    if (ie !== null) {
      D.shared.pending = null;
      var ce = ie, Ee = ce.next;
      ce.next = null, $ === null ? z = Ee : $.next = Ee, $ = ce;
      var He = a.alternate;
      He !== null && (He = He.updateQueue, ie = He.lastBaseUpdate, ie !== $ && (ie === null ? He.firstBaseUpdate = Ee : ie.next = Ee, He.lastBaseUpdate = ce));
    }
    if (z !== null) {
      var Be = D.baseState;
      $ = 0, He = Ee = ce = null, ie = z;
      do {
        var Fe = ie.lane, lt = ie.eventTime;
        if ((k & Fe) === Fe) {
          He !== null && (He = He.next = {
            eventTime: lt,
            lane: 0,
            tag: ie.tag,
            payload: ie.payload,
            callback: ie.callback,
            next: null
          });
          e: {
            var xt = a, Ct = ie;
            switch (Fe = l, lt = m, Ct.tag) {
              case 1:
                if (xt = Ct.payload, typeof xt == "function") {
                  Be = xt.call(lt, Be, Fe);
                  break e;
                }
                Be = xt;
                break e;
              case 3:
                xt.flags = xt.flags & -65537 | 128;
              case 0:
                if (xt = Ct.payload, Fe = typeof xt == "function" ? xt.call(lt, Be, Fe) : xt, Fe == null)
                  break e;
                Be = ye({}, Be, Fe);
                break e;
              case 2:
                so = !0;
            }
          }
          ie.callback !== null && ie.lane !== 0 && (a.flags |= 64, Fe = D.effects, Fe === null ? D.effects = [ie] : Fe.push(ie));
        } else
          lt = { eventTime: lt, lane: Fe, tag: ie.tag, payload: ie.payload, callback: ie.callback, next: null }, He === null ? (Ee = He = lt, ce = Be) : He = He.next = lt, $ |= Fe;
        if (ie = ie.next, ie === null) {
          if (ie = D.shared.pending, ie === null)
            break;
          Fe = ie, ie = Fe.next, Fe.next = null, D.lastBaseUpdate = Fe, D.shared.pending = null;
        }
      } while (1);
      if (He === null && (ce = Be), D.baseState = ce, D.firstBaseUpdate = Ee, D.lastBaseUpdate = He, l = D.shared.interleaved, l !== null) {
        D = l;
        do
          $ |= D.lane, D = D.next;
        while (D !== l);
      } else
        z === null && (D.shared.lanes = 0);
      Rs |= $, a.lanes = $, a.memoizedState = Be;
    }
  }
  function Bo(a, l, m) {
    if (a = l.effects, l.effects = null, a !== null)
      for (l = 0; l < a.length; l++) {
        var k = a[l], D = k.callback;
        if (D !== null) {
          if (k.callback = null, k = m, typeof D != "function")
            throw Error(h(191, D));
          D.call(k);
        }
      }
  }
  var fv = new s.Component().refs;
  function Th(a, l, m, k) {
    l = a.memoizedState, m = m(k, l), m = m == null ? l : ye({}, l, m), a.memoizedState = m, a.lanes === 0 && (a.updateQueue.baseState = m);
  }
  var pd = { isMounted: function(a) {
    return (a = a._reactInternals) ? qt(a) === a : !1;
  }, enqueueSetState: function(a, l, m) {
    a = a._reactInternals;
    var k = hi(), D = wr(a), z = Cs(k, D);
    z.payload = l, m != null && (z.callback = m), l = oo(a, z, D), l !== null && (pi(l, a, D, k), hd(l, a, D));
  }, enqueueReplaceState: function(a, l, m) {
    a = a._reactInternals;
    var k = hi(), D = wr(a), z = Cs(k, D);
    z.tag = 1, z.payload = l, m != null && (z.callback = m), l = oo(a, z, D), l !== null && (pi(l, a, D, k), hd(l, a, D));
  }, enqueueForceUpdate: function(a, l) {
    a = a._reactInternals;
    var m = hi(), k = wr(a), D = Cs(m, k);
    D.tag = 2, l != null && (D.callback = l), l = oo(a, D, k), l !== null && (pi(l, a, k, m), hd(l, a, k));
  } };
  function hv(a, l, m, k, D, z, $) {
    return a = a.stateNode, typeof a.shouldComponentUpdate == "function" ? a.shouldComponentUpdate(k, z, $) : l.prototype && l.prototype.isPureReactComponent ? !ju(m, k) || !ju(D, z) : !0;
  }
  function pv(a, l, m) {
    var k = !1, D = $a, z = l.contextType;
    return typeof z == "object" && z !== null ? z = fr(z) : (D = qn(l) ? Pi : Wt.current, k = l.contextTypes, z = (k = k != null) ? ga(a, D) : $a), l = new l(m, z), a.memoizedState = l.state !== null && l.state !== void 0 ? l.state : null, l.updater = pd, a.stateNode = l, l._reactInternals = a, k && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = D, a.__reactInternalMemoizedMaskedChildContext = z), l;
  }
  function gv(a, l, m, k) {
    a = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(m, k), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(m, k), l.state !== a && pd.enqueueReplaceState(l, l.state, null);
  }
  function gd(a, l, m, k) {
    var D = a.stateNode;
    D.props = m, D.state = a.memoizedState, D.refs = fv, Ch(a);
    var z = l.contextType;
    typeof z == "object" && z !== null ? D.context = fr(z) : (z = qn(l) ? Pi : Wt.current, D.context = ga(a, z)), D.state = a.memoizedState, z = l.getDerivedStateFromProps, typeof z == "function" && (Th(a, l, z, m), D.state = a.memoizedState), typeof l.getDerivedStateFromProps == "function" || typeof D.getSnapshotBeforeUpdate == "function" || typeof D.UNSAFE_componentWillMount != "function" && typeof D.componentWillMount != "function" || (l = D.state, typeof D.componentWillMount == "function" && D.componentWillMount(), typeof D.UNSAFE_componentWillMount == "function" && D.UNSAFE_componentWillMount(), l !== D.state && pd.enqueueReplaceState(D, D.state, null), lo(a, m, D, k), D.state = a.memoizedState), typeof D.componentDidMount == "function" && (a.flags |= 4194308);
  }
  function Bl(a, l, m) {
    if (a = m.ref, a !== null && typeof a != "function" && typeof a != "object") {
      if (m._owner) {
        if (m = m._owner, m) {
          if (m.tag !== 1)
            throw Error(h(309));
          var k = m.stateNode;
        }
        if (!k)
          throw Error(h(147, a));
        var D = k, z = "" + a;
        return l !== null && l.ref !== null && typeof l.ref == "function" && l.ref._stringRef === z ? l.ref : (l = function($) {
          var ie = D.refs;
          ie === fv && (ie = D.refs = {}), $ === null ? delete ie[z] : ie[z] = $;
        }, l._stringRef = z, l);
      }
      if (typeof a != "string")
        throw Error(h(284));
      if (!m._owner)
        throw Error(h(290, a));
    }
    return a;
  }
  function vd(a, l) {
    throw a = Object.prototype.toString.call(l), Error(h(31, a === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : a));
  }
  function vv(a) {
    var l = a._init;
    return l(a._payload);
  }
  function mv(a) {
    function l(me, pe) {
      if (a) {
        var Se = me.deletions;
        Se === null ? (me.deletions = [pe], me.flags |= 16) : Se.push(pe);
      }
    }
    function m(me, pe) {
      if (!a)
        return null;
      for (; pe !== null; )
        l(me, pe), pe = pe.sibling;
      return null;
    }
    function k(me, pe) {
      for (me = /* @__PURE__ */ new Map(); pe !== null; )
        pe.key !== null ? me.set(pe.key, pe) : me.set(pe.index, pe), pe = pe.sibling;
      return me;
    }
    function D(me, pe) {
      return me = mo(me, pe), me.index = 0, me.sibling = null, me;
    }
    function z(me, pe, Se) {
      return me.index = Se, a ? (Se = me.alternate, Se !== null ? (Se = Se.index, Se < pe ? (me.flags |= 2, pe) : Se) : (me.flags |= 2, pe)) : (me.flags |= 1048576, pe);
    }
    function $(me) {
      return a && me.alternate === null && (me.flags |= 2), me;
    }
    function ie(me, pe, Se, $e) {
      return pe === null || pe.tag !== 6 ? (pe = mc(Se, me.mode, $e), pe.return = me, pe) : (pe = D(pe, Se), pe.return = me, pe);
    }
    function ce(me, pe, Se, $e) {
      var At = Se.type;
      return At === Me ? He(me, pe, Se.props.children, $e, Se.key) : pe !== null && (pe.elementType === At || typeof At == "object" && At !== null && At.$$typeof === Et && vv(At) === pe.type) ? ($e = D(pe, Se.props), $e.ref = Bl(me, pe, Se), $e.return = me, $e) : ($e = $d(Se.type, Se.key, Se.props, null, me.mode, $e), $e.ref = Bl(me, pe, Se), $e.return = me, $e);
    }
    function Ee(me, pe, Se, $e) {
      return pe === null || pe.tag !== 4 || pe.stateNode.containerInfo !== Se.containerInfo || pe.stateNode.implementation !== Se.implementation ? (pe = ll(Se, me.mode, $e), pe.return = me, pe) : (pe = D(pe, Se.children || []), pe.return = me, pe);
    }
    function He(me, pe, Se, $e, At) {
      return pe === null || pe.tag !== 7 ? (pe = ol(Se, me.mode, $e, At), pe.return = me, pe) : (pe = D(pe, Se), pe.return = me, pe);
    }
    function Be(me, pe, Se) {
      if (typeof pe == "string" && pe !== "" || typeof pe == "number")
        return pe = mc("" + pe, me.mode, Se), pe.return = me, pe;
      if (typeof pe == "object" && pe !== null) {
        switch (pe.$$typeof) {
          case re:
            return Se = $d(pe.type, pe.key, pe.props, null, me.mode, Se), Se.ref = Bl(me, null, pe), Se.return = me, Se;
          case ve:
            return pe = ll(pe, me.mode, Se), pe.return = me, pe;
          case Et:
            var $e = pe._init;
            return Be(me, $e(pe._payload), Se);
        }
        if (_a(pe) || ft(pe))
          return pe = ol(pe, me.mode, Se, null), pe.return = me, pe;
        vd(me, pe);
      }
      return null;
    }
    function Fe(me, pe, Se, $e) {
      var At = pe !== null ? pe.key : null;
      if (typeof Se == "string" && Se !== "" || typeof Se == "number")
        return At !== null ? null : ie(me, pe, "" + Se, $e);
      if (typeof Se == "object" && Se !== null) {
        switch (Se.$$typeof) {
          case re:
            return Se.key === At ? ce(me, pe, Se, $e) : null;
          case ve:
            return Se.key === At ? Ee(me, pe, Se, $e) : null;
          case Et:
            return At = Se._init, Fe(
              me,
              pe,
              At(Se._payload),
              $e
            );
        }
        if (_a(Se) || ft(Se))
          return At !== null ? null : He(me, pe, Se, $e, null);
        vd(me, Se);
      }
      return null;
    }
    function lt(me, pe, Se, $e, At) {
      if (typeof $e == "string" && $e !== "" || typeof $e == "number")
        return me = me.get(Se) || null, ie(pe, me, "" + $e, At);
      if (typeof $e == "object" && $e !== null) {
        switch ($e.$$typeof) {
          case re:
            return me = me.get($e.key === null ? Se : $e.key) || null, ce(pe, me, $e, At);
          case ve:
            return me = me.get($e.key === null ? Se : $e.key) || null, Ee(pe, me, $e, At);
          case Et:
            var bt = $e._init;
            return lt(me, pe, Se, bt($e._payload), At);
        }
        if (_a($e) || ft($e))
          return me = me.get(Se) || null, He(pe, me, $e, At, null);
        vd(pe, $e);
      }
      return null;
    }
    function xt(me, pe, Se, $e) {
      for (var At = null, bt = null, Mt = pe, Xt = pe = 0, Yr = null; Mt !== null && Xt < Se.length; Xt++) {
        Mt.index > Xt ? (Yr = Mt, Mt = null) : Yr = Mt.sibling;
        var gn = Fe(me, Mt, Se[Xt], $e);
        if (gn === null) {
          Mt === null && (Mt = Yr);
          break;
        }
        a && Mt && gn.alternate === null && l(me, Mt), pe = z(gn, pe, Xt), bt === null ? At = gn : bt.sibling = gn, bt = gn, Mt = Yr;
      }
      if (Xt === Se.length)
        return m(me, Mt), Wn && ta(me, Xt), At;
      if (Mt === null) {
        for (; Xt < Se.length; Xt++)
          Mt = Be(me, Se[Xt], $e), Mt !== null && (pe = z(Mt, pe, Xt), bt === null ? At = Mt : bt.sibling = Mt, bt = Mt);
        return Wn && ta(me, Xt), At;
      }
      for (Mt = k(me, Mt); Xt < Se.length; Xt++)
        Yr = lt(Mt, me, Xt, Se[Xt], $e), Yr !== null && (a && Yr.alternate !== null && Mt.delete(Yr.key === null ? Xt : Yr.key), pe = z(Yr, pe, Xt), bt === null ? At = Yr : bt.sibling = Yr, bt = Yr);
      return a && Mt.forEach(function(yo) {
        return l(me, yo);
      }), Wn && ta(me, Xt), At;
    }
    function Ct(me, pe, Se, $e) {
      var At = ft(Se);
      if (typeof At != "function")
        throw Error(h(150));
      if (Se = At.call(Se), Se == null)
        throw Error(h(151));
      for (var bt = At = null, Mt = pe, Xt = pe = 0, Yr = null, gn = Se.next(); Mt !== null && !gn.done; Xt++, gn = Se.next()) {
        Mt.index > Xt ? (Yr = Mt, Mt = null) : Yr = Mt.sibling;
        var yo = Fe(me, Mt, gn.value, $e);
        if (yo === null) {
          Mt === null && (Mt = Yr);
          break;
        }
        a && Mt && yo.alternate === null && l(me, Mt), pe = z(yo, pe, Xt), bt === null ? At = yo : bt.sibling = yo, bt = yo, Mt = Yr;
      }
      if (gn.done)
        return m(
          me,
          Mt
        ), Wn && ta(me, Xt), At;
      if (Mt === null) {
        for (; !gn.done; Xt++, gn = Se.next())
          gn = Be(me, gn.value, $e), gn !== null && (pe = z(gn, pe, Xt), bt === null ? At = gn : bt.sibling = gn, bt = gn);
        return Wn && ta(me, Xt), At;
      }
      for (Mt = k(me, Mt); !gn.done; Xt++, gn = Se.next())
        gn = lt(Mt, me, Xt, gn.value, $e), gn !== null && (a && gn.alternate !== null && Mt.delete(gn.key === null ? Xt : gn.key), pe = z(gn, pe, Xt), bt === null ? At = gn : bt.sibling = gn, bt = gn);
      return a && Mt.forEach(function(Gx) {
        return l(me, Gx);
      }), Wn && ta(me, Xt), At;
    }
    function hr(me, pe, Se, $e) {
      if (typeof Se == "object" && Se !== null && Se.type === Me && Se.key === null && (Se = Se.props.children), typeof Se == "object" && Se !== null) {
        switch (Se.$$typeof) {
          case re:
            e: {
              for (var At = Se.key, bt = pe; bt !== null; ) {
                if (bt.key === At) {
                  if (At = Se.type, At === Me) {
                    if (bt.tag === 7) {
                      m(me, bt.sibling), pe = D(bt, Se.props.children), pe.return = me, me = pe;
                      break e;
                    }
                  } else if (bt.elementType === At || typeof At == "object" && At !== null && At.$$typeof === Et && vv(At) === bt.type) {
                    m(me, bt.sibling), pe = D(bt, Se.props), pe.ref = Bl(me, bt, Se), pe.return = me, me = pe;
                    break e;
                  }
                  m(me, bt);
                  break;
                } else
                  l(me, bt);
                bt = bt.sibling;
              }
              Se.type === Me ? (pe = ol(Se.props.children, me.mode, $e, Se.key), pe.return = me, me = pe) : ($e = $d(Se.type, Se.key, Se.props, null, me.mode, $e), $e.ref = Bl(me, pe, Se), $e.return = me, me = $e);
            }
            return $(me);
          case ve:
            e: {
              for (bt = Se.key; pe !== null; ) {
                if (pe.key === bt)
                  if (pe.tag === 4 && pe.stateNode.containerInfo === Se.containerInfo && pe.stateNode.implementation === Se.implementation) {
                    m(me, pe.sibling), pe = D(pe, Se.children || []), pe.return = me, me = pe;
                    break e;
                  } else {
                    m(me, pe);
                    break;
                  }
                else
                  l(me, pe);
                pe = pe.sibling;
              }
              pe = ll(Se, me.mode, $e), pe.return = me, me = pe;
            }
            return $(me);
          case Et:
            return bt = Se._init, hr(me, pe, bt(Se._payload), $e);
        }
        if (_a(Se))
          return xt(me, pe, Se, $e);
        if (ft(Se))
          return Ct(me, pe, Se, $e);
        vd(me, Se);
      }
      return typeof Se == "string" && Se !== "" || typeof Se == "number" ? (Se = "" + Se, pe !== null && pe.tag === 6 ? (m(me, pe.sibling), pe = D(pe, Se), pe.return = me, me = pe) : (m(me, pe), pe = mc(Se, me.mode, $e), pe.return = me, me = pe), $(me)) : m(me, pe);
    }
    return hr;
  }
  var Wl = mv(!0), yv = mv(!1), Ju = {}, Ha = Jt(Ju), ec = Jt(Ju), Xl = Jt(Ju);
  function Wo(a) {
    if (a === Ju)
      throw Error(h(174));
    return a;
  }
  function Eh(a, l) {
    switch (An(Xl, l), An(ec, a), An(Ha, Ju), a = l.nodeType, a) {
      case 9:
      case 11:
        l = (l = l.documentElement) ? l.namespaceURI : ar(null, "");
        break;
      default:
        a = a === 8 ? l.parentNode : l, l = a.namespaceURI || null, a = a.tagName, l = ar(l, a);
    }
    Sn(Ha), An(Ha, l);
  }
  function uo() {
    Sn(Ha), Sn(ec), Sn(Xl);
  }
  function Nt(a) {
    Wo(Xl.current);
    var l = Wo(Ha.current), m = ar(l, a.type);
    l !== m && (An(ec, a), An(Ha, m));
  }
  function nn(a) {
    ec.current === a && (Sn(Ha), Sn(ec));
  }
  var Ft = Jt(0);
  function Kn(a) {
    for (var l = a; l !== null; ) {
      if (l.tag === 13) {
        var m = l.memoizedState;
        if (m !== null && (m = m.dehydrated, m === null || m.data === "$?" || m.data === "$!"))
          return l;
      } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
        if (l.flags & 128)
          return l;
      } else if (l.child !== null) {
        l.child.return = l, l = l.child;
        continue;
      }
      if (l === a)
        break;
      for (; l.sibling === null; ) {
        if (l.return === null || l.return === a)
          return null;
        l = l.return;
      }
      l.sibling.return = l.return, l = l.sibling;
    }
    return null;
  }
  var xa = [];
  function md() {
    for (var a = 0; a < xa.length; a++)
      xa[a]._workInProgressVersionPrimary = null;
    xa.length = 0;
  }
  var yd = Re.ReactCurrentDispatcher, Rh = Re.ReactCurrentBatchConfig, Xo = 0, Xn = null, Pe = null, dn = null, Yt = !1, Za = !1, ia = 0, Vo = 0;
  function Vn() {
    throw Error(h(321));
  }
  function Go(a, l) {
    if (l === null)
      return !1;
    for (var m = 0; m < l.length && m < a.length; m++)
      if (!ha(a[m], l[m]))
        return !1;
    return !0;
  }
  function co(a, l, m, k, D, z) {
    if (Xo = z, Xn = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, yd.current = a === null || a.memoizedState === null ? Lx : Mx, a = m(k, D), Za) {
      z = 0;
      do {
        if (Za = !1, ia = 0, 25 <= z)
          throw Error(h(301));
        z += 1, dn = Pe = null, l.updateQueue = null, yd.current = Mh, a = m(k, D);
      } while (Za);
    }
    if (yd.current = Pd, l = Pe !== null && Pe.next !== null, Xo = 0, dn = Pe = Xn = null, Yt = !1, l)
      throw Error(h(300));
    return a;
  }
  function $o() {
    var a = ia !== 0;
    return ia = 0, a;
  }
  function ba() {
    var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return dn === null ? Xn.memoizedState = dn = a : dn = dn.next = a, dn;
  }
  function Yi() {
    if (Pe === null) {
      var a = Xn.alternate;
      a = a !== null ? a.memoizedState : null;
    } else
      a = Pe.next;
    var l = dn === null ? Xn.memoizedState : dn.next;
    if (l !== null)
      dn = l, Pe = a;
    else {
      if (a === null)
        throw Error(h(310));
      Pe = a, a = { memoizedState: Pe.memoizedState, baseState: Pe.baseState, baseQueue: Pe.baseQueue, queue: Pe.queue, next: null }, dn === null ? Xn.memoizedState = dn = a : dn = dn.next = a;
    }
    return dn;
  }
  function qo(a, l) {
    return typeof l == "function" ? l(a) : l;
  }
  function tc(a) {
    var l = Yi(), m = l.queue;
    if (m === null)
      throw Error(h(311));
    m.lastRenderedReducer = a;
    var k = Pe, D = k.baseQueue, z = m.pending;
    if (z !== null) {
      if (D !== null) {
        var $ = D.next;
        D.next = z.next, z.next = $;
      }
      k.baseQueue = D = z, m.pending = null;
    }
    if (D !== null) {
      z = D.next, k = k.baseState;
      var ie = $ = null, ce = null, Ee = z;
      do {
        var He = Ee.lane;
        if ((Xo & He) === He)
          ce !== null && (ce = ce.next = { lane: 0, action: Ee.action, hasEagerState: Ee.hasEagerState, eagerState: Ee.eagerState, next: null }), k = Ee.hasEagerState ? Ee.eagerState : a(k, Ee.action);
        else {
          var Be = {
            lane: He,
            action: Ee.action,
            hasEagerState: Ee.hasEagerState,
            eagerState: Ee.eagerState,
            next: null
          };
          ce === null ? (ie = ce = Be, $ = k) : ce = ce.next = Be, Xn.lanes |= He, Rs |= He;
        }
        Ee = Ee.next;
      } while (Ee !== null && Ee !== z);
      ce === null ? $ = k : ce.next = ie, ha(k, l.memoizedState) || (br = !0), l.memoizedState = k, l.baseState = $, l.baseQueue = ce, m.lastRenderedState = k;
    }
    if (a = m.interleaved, a !== null) {
      D = a;
      do
        z = D.lane, Xn.lanes |= z, Rs |= z, D = D.next;
      while (D !== a);
    } else
      D === null && (m.lanes = 0);
    return [l.memoizedState, m.dispatch];
  }
  function nc(a) {
    var l = Yi(), m = l.queue;
    if (m === null)
      throw Error(h(311));
    m.lastRenderedReducer = a;
    var k = m.dispatch, D = m.pending, z = l.memoizedState;
    if (D !== null) {
      m.pending = null;
      var $ = D = D.next;
      do
        z = a(z, $.action), $ = $.next;
      while ($ !== D);
      ha(z, l.memoizedState) || (br = !0), l.memoizedState = z, l.baseQueue === null && (l.baseState = z), m.lastRenderedState = z;
    }
    return [z, k];
  }
  function xd() {
  }
  function bd(a, l) {
    var m = Xn, k = Yi(), D = l(), z = !ha(k.memoizedState, D);
    if (z && (k.memoizedState = D, br = !0), k = k.queue, rc(kd.bind(null, m, k, a), [a]), k.getSnapshot !== l || z || dn !== null && dn.memoizedState.tag & 1) {
      if (m.flags |= 2048, Zo(9, Sd.bind(null, m, k, D, l), void 0, null), Jn === null)
        throw Error(h(349));
      Xo & 30 || wd(m, l, D);
    }
    return D;
  }
  function wd(a, l, m) {
    a.flags |= 16384, a = { getSnapshot: l, value: m }, l = Xn.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, Xn.updateQueue = l, l.stores = [a]) : (m = l.stores, m === null ? l.stores = [a] : m.push(a));
  }
  function Sd(a, l, m, k) {
    l.value = m, l.getSnapshot = k, Cd(l) && Ad(a);
  }
  function kd(a, l, m) {
    return m(function() {
      Cd(l) && Ad(a);
    });
  }
  function Cd(a) {
    var l = a.getSnapshot;
    a = a.value;
    try {
      var m = l();
      return !ha(a, m);
    } catch {
      return !0;
    }
  }
  function Ad(a) {
    var l = ks(a, 1);
    l !== null && pi(l, a, 1, -1);
  }
  function Td(a) {
    var l = ba();
    return typeof a == "function" && (a = a()), l.memoizedState = l.baseState = a, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: qo, lastRenderedState: a }, l.queue = a, a = a.dispatch = _d.bind(null, Xn, a), [l.memoizedState, a];
  }
  function Zo(a, l, m, k) {
    return a = { tag: a, create: l, destroy: m, deps: k, next: null }, l = Xn.updateQueue, l === null ? (l = { lastEffect: null, stores: null }, Xn.updateQueue = l, l.lastEffect = a.next = a) : (m = l.lastEffect, m === null ? l.lastEffect = a.next = a : (k = m.next, m.next = a, a.next = k, l.lastEffect = a)), a;
  }
  function Ed() {
    return Yi().memoizedState;
  }
  function Qo(a, l, m, k) {
    var D = ba();
    Xn.flags |= a, D.memoizedState = Zo(1 | l, m, void 0, k === void 0 ? null : k);
  }
  function As(a, l, m, k) {
    var D = Yi();
    k = k === void 0 ? null : k;
    var z = void 0;
    if (Pe !== null) {
      var $ = Pe.memoizedState;
      if (z = $.destroy, k !== null && Go(k, $.deps)) {
        D.memoizedState = Zo(l, m, z, k);
        return;
      }
    }
    Xn.flags |= a, D.memoizedState = Zo(1 | l, m, z, k);
  }
  function Rd(a, l) {
    return Qo(8390656, 8, a, l);
  }
  function rc(a, l) {
    return As(2048, 8, a, l);
  }
  function Ld(a, l) {
    return As(4, 2, a, l);
  }
  function Md(a, l) {
    return As(4, 4, a, l);
  }
  function Lh(a, l) {
    if (typeof l == "function")
      return a = a(), l(a), function() {
        l(null);
      };
    if (l != null)
      return a = a(), l.current = a, function() {
        l.current = null;
      };
  }
  function Vl(a, l, m) {
    return m = m != null ? m.concat([a]) : null, As(4, 4, Lh.bind(null, l, a), m);
  }
  function Dd() {
  }
  function Gl(a, l) {
    var m = Yi();
    l = l === void 0 ? null : l;
    var k = m.memoizedState;
    return k !== null && l !== null && Go(l, k[1]) ? k[0] : (m.memoizedState = [a, l], a);
  }
  function fo(a, l) {
    var m = Yi();
    l = l === void 0 ? null : l;
    var k = m.memoizedState;
    return k !== null && l !== null && Go(l, k[1]) ? k[0] : (a = a(), m.memoizedState = [a, l], a);
  }
  function Hi(a, l, m) {
    return Xo & 21 ? (ha(m, l) || (m = oe(), Xn.lanes |= m, Rs |= m, a.baseState = !0), l) : (a.baseState && (a.baseState = !1, br = !0), a.memoizedState = m);
  }
  function Rx(a, l) {
    var m = Ie;
    Ie = m !== 0 && 4 > m ? m : 4, a(!0);
    var k = Rh.transition;
    Rh.transition = {};
    try {
      a(!1), l();
    } finally {
      Ie = m, Rh.transition = k;
    }
  }
  function Fn() {
    return Yi().memoizedState;
  }
  function Od(a, l, m) {
    var k = wr(a);
    if (m = { lane: k, action: m, hasEagerState: !1, eagerState: null, next: null }, $l(a))
      ic(l, m);
    else if (m = dv(a, l, m, k), m !== null) {
      var D = hi();
      pi(m, a, k, D), xv(m, l, k);
    }
  }
  function _d(a, l, m) {
    var k = wr(a), D = { lane: k, action: m, hasEagerState: !1, eagerState: null, next: null };
    if ($l(a))
      ic(l, D);
    else {
      var z = a.alternate;
      if (a.lanes === 0 && (z === null || z.lanes === 0) && (z = l.lastRenderedReducer, z !== null))
        try {
          var $ = l.lastRenderedState, ie = z($, m);
          if (D.hasEagerState = !0, D.eagerState = ie, ha(ie, $)) {
            var ce = l.interleaved;
            ce === null ? (D.next = D, kh(l)) : (D.next = ce.next, ce.next = D), l.interleaved = D;
            return;
          }
        } catch {
        } finally {
        }
      m = dv(a, l, D, k), m !== null && (D = hi(), pi(m, a, k, D), xv(m, l, k));
    }
  }
  function $l(a) {
    var l = a.alternate;
    return a === Xn || l !== null && l === Xn;
  }
  function ic(a, l) {
    Za = Yt = !0;
    var m = a.pending;
    m === null ? l.next = l : (l.next = m.next, m.next = l), a.pending = l;
  }
  function xv(a, l, m) {
    if (m & 4194240) {
      var k = l.lanes;
      k &= a.pendingLanes, m |= k, l.lanes = m, Le(a, m);
    }
  }
  var Pd = { readContext: fr, useCallback: Vn, useContext: Vn, useEffect: Vn, useImperativeHandle: Vn, useInsertionEffect: Vn, useLayoutEffect: Vn, useMemo: Vn, useReducer: Vn, useRef: Vn, useState: Vn, useDebugValue: Vn, useDeferredValue: Vn, useTransition: Vn, useMutableSource: Vn, useSyncExternalStore: Vn, useId: Vn, unstable_isNewReconciler: !1 }, Lx = { readContext: fr, useCallback: function(a, l) {
    return ba().memoizedState = [a, l === void 0 ? null : l], a;
  }, useContext: fr, useEffect: Rd, useImperativeHandle: function(a, l, m) {
    return m = m != null ? m.concat([a]) : null, Qo(
      4194308,
      4,
      Lh.bind(null, l, a),
      m
    );
  }, useLayoutEffect: function(a, l) {
    return Qo(4194308, 4, a, l);
  }, useInsertionEffect: function(a, l) {
    return Qo(4, 2, a, l);
  }, useMemo: function(a, l) {
    var m = ba();
    return l = l === void 0 ? null : l, a = a(), m.memoizedState = [a, l], a;
  }, useReducer: function(a, l, m) {
    var k = ba();
    return l = m !== void 0 ? m(l) : l, k.memoizedState = k.baseState = l, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: l }, k.queue = a, a = a.dispatch = Od.bind(null, Xn, a), [k.memoizedState, a];
  }, useRef: function(a) {
    var l = ba();
    return a = { current: a }, l.memoizedState = a;
  }, useState: Td, useDebugValue: Dd, useDeferredValue: function(a) {
    return ba().memoizedState = a;
  }, useTransition: function() {
    var a = Td(!1), l = a[0];
    return a = Rx.bind(null, a[1]), ba().memoizedState = a, [l, a];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a, l, m) {
    var k = Xn, D = ba();
    if (Wn) {
      if (m === void 0)
        throw Error(h(407));
      m = m();
    } else {
      if (m = l(), Jn === null)
        throw Error(h(349));
      Xo & 30 || wd(k, l, m);
    }
    D.memoizedState = m;
    var z = { value: m, getSnapshot: l };
    return D.queue = z, Rd(kd.bind(
      null,
      k,
      z,
      a
    ), [a]), k.flags |= 2048, Zo(9, Sd.bind(null, k, z, m, l), void 0, null), m;
  }, useId: function() {
    var a = ba(), l = Jn.identifierPrefix;
    if (Wn) {
      var m = Ss, k = Br;
      m = (k & ~(1 << 32 - P(k) - 1)).toString(32) + m, l = ":" + l + "R" + m, m = ia++, 0 < m && (l += "H" + m.toString(32)), l += ":";
    } else
      m = Vo++, l = ":" + l + "r" + m.toString(32) + ":";
    return a.memoizedState = l;
  }, unstable_isNewReconciler: !1 }, Mx = {
    readContext: fr,
    useCallback: Gl,
    useContext: fr,
    useEffect: rc,
    useImperativeHandle: Vl,
    useInsertionEffect: Ld,
    useLayoutEffect: Md,
    useMemo: fo,
    useReducer: tc,
    useRef: Ed,
    useState: function() {
      return tc(qo);
    },
    useDebugValue: Dd,
    useDeferredValue: function(a) {
      var l = Yi();
      return Hi(l, Pe.memoizedState, a);
    },
    useTransition: function() {
      var a = tc(qo)[0], l = Yi().memoizedState;
      return [a, l];
    },
    useMutableSource: xd,
    useSyncExternalStore: bd,
    useId: Fn,
    unstable_isNewReconciler: !1
  }, Mh = { readContext: fr, useCallback: Gl, useContext: fr, useEffect: rc, useImperativeHandle: Vl, useInsertionEffect: Ld, useLayoutEffect: Md, useMemo: fo, useReducer: nc, useRef: Ed, useState: function() {
    return nc(qo);
  }, useDebugValue: Dd, useDeferredValue: function(a) {
    var l = Yi();
    return Pe === null ? l.memoizedState = a : Hi(l, Pe.memoizedState, a);
  }, useTransition: function() {
    var a = nc(qo)[0], l = Yi().memoizedState;
    return [a, l];
  }, useMutableSource: xd, useSyncExternalStore: bd, useId: Fn, unstable_isNewReconciler: !1 };
  function ql(a, l) {
    try {
      var m = "", k = l;
      do
        m += Ht(k), k = k.return;
      while (k);
      var D = m;
    } catch (z) {
      D = `
Error generating stack: ` + z.message + `
` + z.stack;
    }
    return { value: a, source: l, stack: D, digest: null };
  }
  function ac(a, l, m) {
    return { value: a, source: null, stack: m ?? null, digest: l ?? null };
  }
  function Nd(a, l) {
    try {
      console.error(l.value);
    } catch (m) {
      setTimeout(function() {
        throw m;
      });
    }
  }
  var Dx = typeof WeakMap == "function" ? WeakMap : Map;
  function bv(a, l, m) {
    m = Cs(-1, m), m.tag = 3, m.payload = { element: null };
    var k = l.value;
    return m.callback = function() {
      Ud || (Ud = !0, nl = k), Nd(a, l);
    }, m;
  }
  function sc(a, l, m) {
    m = Cs(-1, m), m.tag = 3;
    var k = a.type.getDerivedStateFromError;
    if (typeof k == "function") {
      var D = l.value;
      m.payload = function() {
        return k(D);
      }, m.callback = function() {
        Nd(a, l);
      };
    }
    var z = a.stateNode;
    return z !== null && typeof z.componentDidCatch == "function" && (m.callback = function() {
      Nd(a, l), typeof k != "function" && (Ja === null ? Ja = /* @__PURE__ */ new Set([this]) : Ja.add(this));
      var $ = l.stack;
      this.componentDidCatch(l.value, { componentStack: $ !== null ? $ : "" });
    }), m;
  }
  function wv(a, l, m) {
    var k = a.pingCache;
    if (k === null) {
      k = a.pingCache = new Dx();
      var D = /* @__PURE__ */ new Set();
      k.set(l, D);
    } else
      D = k.get(l), D === void 0 && (D = /* @__PURE__ */ new Set(), k.set(l, D));
    D.has(m) || (D.add(m), a = Fx.bind(null, a, l, m), l.then(a, a));
  }
  function Dh(a) {
    do {
      var l;
      if ((l = a.tag === 13) && (l = a.memoizedState, l = l !== null ? l.dehydrated !== null : !0), l)
        return a;
      a = a.return;
    } while (a !== null);
    return null;
  }
  function Oh(a, l, m, k, D) {
    return a.mode & 1 ? (a.flags |= 65536, a.lanes = D, a) : (a === l ? a.flags |= 65536 : (a.flags |= 128, m.flags |= 131072, m.flags &= -52805, m.tag === 1 && (m.alternate === null ? m.tag = 17 : (l = Cs(-1, 1), l.tag = 2, oo(m, l, 1))), m.lanes |= 1), a);
  }
  var Ox = Re.ReactCurrentOwner, br = !1;
  function Ar(a, l, m, k) {
    l.child = a === null ? yv(l, null, m, k) : Wl(l, a.child, m, k);
  }
  function ho(a, l, m, k, D) {
    m = m.render;
    var z = l.ref;
    return nt(l, D), k = co(a, l, m, k, z, D), m = $o(), a !== null && !br ? (l.updateQueue = a.updateQueue, l.flags &= -2053, a.lanes &= ~D, Xr(a, l, D)) : (Wn && m && od(l), l.flags |= 1, Ar(a, l, k, D), l.child);
  }
  function zd(a, l, m, k, D) {
    if (a === null) {
      var z = m.type;
      return typeof z == "function" && !Qh(z) && z.defaultProps === void 0 && m.compare === null && m.defaultProps === void 0 ? (l.tag = 15, l.type = z, ji(a, l, z, k, D)) : (a = $d(m.type, null, k, l, l.mode, D), a.ref = l.ref, a.return = l, l.child = a);
    }
    if (z = a.child, !(a.lanes & D)) {
      var $ = z.memoizedProps;
      if (m = m.compare, m = m !== null ? m : ju, m($, k) && a.ref === l.ref)
        return Xr(a, l, D);
    }
    return l.flags |= 1, a = mo(z, k), a.ref = l.ref, a.return = l, l.child = a;
  }
  function ji(a, l, m, k, D) {
    if (a !== null) {
      var z = a.memoizedProps;
      if (ju(z, k) && a.ref === l.ref)
        if (br = !1, l.pendingProps = k = z, (a.lanes & D) !== 0)
          a.flags & 131072 && (br = !0);
        else
          return l.lanes = a.lanes, Xr(a, l, D);
    }
    return Zl(a, l, m, k, D);
  }
  function Ko(a, l, m) {
    var k = l.pendingProps, D = k.children, z = a !== null ? a.memoizedState : null;
    if (k.mode === "hidden")
      if (!(l.mode & 1))
        l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, An(nu, aa), aa |= m;
      else {
        if (!(m & 1073741824))
          return a = z !== null ? z.baseLanes | m : m, l.lanes = l.childLanes = 1073741824, l.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, l.updateQueue = null, An(nu, aa), aa |= a, null;
        l.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, k = z !== null ? z.baseLanes : m, An(nu, aa), aa |= k;
      }
    else
      z !== null ? (k = z.baseLanes | m, l.memoizedState = null) : k = m, An(nu, aa), aa |= k;
    return Ar(a, l, D, m), l.child;
  }
  function en(a, l) {
    var m = l.ref;
    (a === null && m !== null || a !== null && a.ref !== m) && (l.flags |= 512, l.flags |= 2097152);
  }
  function Zl(a, l, m, k, D) {
    var z = qn(m) ? Pi : Wt.current;
    return z = ga(l, z), nt(l, D), m = co(a, l, m, k, z, D), k = $o(), a !== null && !br ? (l.updateQueue = a.updateQueue, l.flags &= -2053, a.lanes &= ~D, Xr(a, l, D)) : (Wn && k && od(l), l.flags |= 1, Ar(a, l, m, D), l.child);
  }
  function _h(a, l, m, k, D) {
    if (qn(m)) {
      var z = !0;
      sd(l);
    } else
      z = !1;
    if (nt(l, D), l.stateNode === null)
      ci(a, l), pv(l, m, k), gd(l, m, k, D), k = !0;
    else if (a === null) {
      var $ = l.stateNode, ie = l.memoizedProps;
      $.props = ie;
      var ce = $.context, Ee = m.contextType;
      typeof Ee == "object" && Ee !== null ? Ee = fr(Ee) : (Ee = qn(m) ? Pi : Wt.current, Ee = ga(l, Ee));
      var He = m.getDerivedStateFromProps, Be = typeof He == "function" || typeof $.getSnapshotBeforeUpdate == "function";
      Be || typeof $.UNSAFE_componentWillReceiveProps != "function" && typeof $.componentWillReceiveProps != "function" || (ie !== k || ce !== Ee) && gv(l, $, k, Ee), so = !1;
      var Fe = l.memoizedState;
      $.state = Fe, lo(l, k, $, D), ce = l.memoizedState, ie !== k || Fe !== ce || or.current || so ? (typeof He == "function" && (Th(l, m, He, k), ce = l.memoizedState), (ie = so || hv(l, m, ie, k, Fe, ce, Ee)) ? (Be || typeof $.UNSAFE_componentWillMount != "function" && typeof $.componentWillMount != "function" || (typeof $.componentWillMount == "function" && $.componentWillMount(), typeof $.UNSAFE_componentWillMount == "function" && $.UNSAFE_componentWillMount()), typeof $.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof $.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = k, l.memoizedState = ce), $.props = k, $.state = ce, $.context = Ee, k = ie) : (typeof $.componentDidMount == "function" && (l.flags |= 4194308), k = !1);
    } else {
      $ = l.stateNode, Cr(a, l), ie = l.memoizedProps, Ee = l.type === l.elementType ? ie : ra(l.type, ie), $.props = Ee, Be = l.pendingProps, Fe = $.context, ce = m.contextType, typeof ce == "object" && ce !== null ? ce = fr(ce) : (ce = qn(m) ? Pi : Wt.current, ce = ga(l, ce));
      var lt = m.getDerivedStateFromProps;
      (He = typeof lt == "function" || typeof $.getSnapshotBeforeUpdate == "function") || typeof $.UNSAFE_componentWillReceiveProps != "function" && typeof $.componentWillReceiveProps != "function" || (ie !== Be || Fe !== ce) && gv(l, $, k, ce), so = !1, Fe = l.memoizedState, $.state = Fe, lo(l, k, $, D);
      var xt = l.memoizedState;
      ie !== Be || Fe !== xt || or.current || so ? (typeof lt == "function" && (Th(l, m, lt, k), xt = l.memoizedState), (Ee = so || hv(l, m, Ee, k, Fe, xt, ce) || !1) ? (He || typeof $.UNSAFE_componentWillUpdate != "function" && typeof $.componentWillUpdate != "function" || (typeof $.componentWillUpdate == "function" && $.componentWillUpdate(k, xt, ce), typeof $.UNSAFE_componentWillUpdate == "function" && $.UNSAFE_componentWillUpdate(k, xt, ce)), typeof $.componentDidUpdate == "function" && (l.flags |= 4), typeof $.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof $.componentDidUpdate != "function" || ie === a.memoizedProps && Fe === a.memoizedState || (l.flags |= 4), typeof $.getSnapshotBeforeUpdate != "function" || ie === a.memoizedProps && Fe === a.memoizedState || (l.flags |= 1024), l.memoizedProps = k, l.memoizedState = xt), $.props = k, $.state = xt, $.context = ce, k = Ee) : (typeof $.componentDidUpdate != "function" || ie === a.memoizedProps && Fe === a.memoizedState || (l.flags |= 4), typeof $.getSnapshotBeforeUpdate != "function" || ie === a.memoizedProps && Fe === a.memoizedState || (l.flags |= 1024), k = !1);
    }
    return Sv(a, l, m, k, z, D);
  }
  function Sv(a, l, m, k, D, z) {
    en(a, l);
    var $ = (l.flags & 128) !== 0;
    if (!k && !$)
      return D && ov(l, m, !1), Xr(a, l, z);
    k = l.stateNode, Ox.current = l;
    var ie = $ && typeof m.getDerivedStateFromError != "function" ? null : k.render();
    return l.flags |= 1, a !== null && $ ? (l.child = Wl(l, a.child, null, z), l.child = Wl(l, null, ie, z)) : Ar(a, l, ie, z), l.memoizedState = k.state, D && ov(l, m, !0), l.child;
  }
  function kv(a) {
    var l = a.stateNode;
    l.pendingContext ? no(a, l.pendingContext, l.pendingContext !== l.context) : l.context && no(a, l.context, !1), Eh(a, l.containerInfo);
  }
  function Id(a, l, m, k, D) {
    return Qn(), bh(D), l.flags |= 256, Ar(a, l, m, k), l.child;
  }
  var Jo = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Ph(a) {
    return { baseLanes: a, cachePool: null, transitions: null };
  }
  function Nh(a, l, m) {
    var k = l.pendingProps, D = Ft.current, z = !1, $ = (l.flags & 128) !== 0, ie;
    if ((ie = $) || (ie = a !== null && a.memoizedState === null ? !1 : (D & 2) !== 0), ie ? (z = !0, l.flags &= -129) : (a === null || a.memoizedState !== null) && (D |= 1), An(Ft, D & 1), a === null)
      return ud(l), a = l.memoizedState, a !== null && (a = a.dehydrated, a !== null) ? (l.mode & 1 ? a.data === "$!" ? l.lanes = 8 : l.lanes = 1073741824 : l.lanes = 1, null) : ($ = k.children, a = k.fallback, z ? (k = l.mode, z = l.child, $ = { mode: "hidden", children: $ }, !(k & 1) && z !== null ? (z.childLanes = 0, z.pendingProps = $) : z = vc($, k, 0, null), a = ol(a, k, m, null), z.return = l, a.return = l, z.sibling = a, l.child = z, l.child.memoizedState = Ph(m), l.memoizedState = Jo, a) : zh(l, $));
    if (D = a.memoizedState, D !== null && (ie = D.dehydrated, ie !== null))
      return _x(a, l, $, k, ie, D, m);
    if (z) {
      z = k.fallback, $ = l.mode, D = a.child, ie = D.sibling;
      var ce = { mode: "hidden", children: k.children };
      return !($ & 1) && l.child !== D ? (k = l.child, k.childLanes = 0, k.pendingProps = ce, l.deletions = null) : (k = mo(D, ce), k.subtreeFlags = D.subtreeFlags & 14680064), ie !== null ? z = mo(ie, z) : (z = ol(z, $, m, null), z.flags |= 2), z.return = l, k.return = l, k.sibling = z, l.child = k, k = z, z = l.child, $ = a.child.memoizedState, $ = $ === null ? Ph(m) : { baseLanes: $.baseLanes | m, cachePool: null, transitions: $.transitions }, z.memoizedState = $, z.childLanes = a.childLanes & ~m, l.memoizedState = Jo, k;
    }
    return z = a.child, a = z.sibling, k = mo(z, { mode: "visible", children: k.children }), !(l.mode & 1) && (k.lanes = m), k.return = l, k.sibling = null, a !== null && (m = l.deletions, m === null ? (l.deletions = [a], l.flags |= 16) : m.push(a)), l.child = k, l.memoizedState = null, k;
  }
  function zh(a, l) {
    return l = vc({ mode: "visible", children: l }, a.mode, 0, null), l.return = a, a.child = l;
  }
  function Ql(a, l, m, k) {
    return k !== null && bh(k), Wl(l, a.child, null, m), a = zh(l, l.pendingProps.children), a.flags |= 2, l.memoizedState = null, a;
  }
  function _x(a, l, m, k, D, z, $) {
    if (m)
      return l.flags & 256 ? (l.flags &= -257, k = ac(Error(h(422))), Ql(a, l, $, k)) : l.memoizedState !== null ? (l.child = a.child, l.flags |= 128, null) : (z = k.fallback, D = l.mode, k = vc({ mode: "visible", children: k.children }, D, 0, null), z = ol(z, D, $, null), z.flags |= 2, k.return = l, z.return = l, k.sibling = z, l.child = k, l.mode & 1 && Wl(l, a.child, null, $), l.child.memoizedState = Ph($), l.memoizedState = Jo, z);
    if (!(l.mode & 1))
      return Ql(a, l, $, null);
    if (D.data === "$!") {
      if (k = D.nextSibling && D.nextSibling.dataset, k)
        var ie = k.dgst;
      return k = ie, z = Error(h(419)), k = ac(z, k, void 0), Ql(a, l, $, k);
    }
    if (ie = ($ & a.childLanes) !== 0, br || ie) {
      if (k = Jn, k !== null) {
        switch ($ & -$) {
          case 4:
            D = 2;
            break;
          case 16:
            D = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            D = 32;
            break;
          case 536870912:
            D = 268435456;
            break;
          default:
            D = 0;
        }
        D = D & (k.suspendedLanes | $) ? 0 : D, D !== 0 && D !== z.retryLane && (z.retryLane = D, ks(a, D), pi(k, a, D, -1));
      }
      return $h(), k = ac(Error(h(421))), Ql(a, l, $, k);
    }
    return D.data === "$?" ? (l.flags |= 128, l.child = a.child, l = Yx.bind(null, a), D._reactRetry = l, null) : (a = z.treeContext, Fi = Ya(D.nextSibling), na = l, Wn = !0, ya = null, a !== null && (Ii[ui++] = Br, Ii[ui++] = Ss, Ii[ui++] = ma, Br = a.id, Ss = a.overflow, ma = l), l = zh(l, k.children), l.flags |= 4096, l);
  }
  function Ih(a, l, m) {
    a.lanes |= l;
    var k = a.alternate;
    k !== null && (k.lanes |= l), zr(a.return, l, m);
  }
  function Fd(a, l, m, k, D) {
    var z = a.memoizedState;
    z === null ? a.memoizedState = { isBackwards: l, rendering: null, renderingStartTime: 0, last: k, tail: m, tailMode: D } : (z.isBackwards = l, z.rendering = null, z.renderingStartTime = 0, z.last = k, z.tail = m, z.tailMode = D);
  }
  function Fh(a, l, m) {
    var k = l.pendingProps, D = k.revealOrder, z = k.tail;
    if (Ar(a, l, k.children, m), k = Ft.current, k & 2)
      k = k & 1 | 2, l.flags |= 128;
    else {
      if (a !== null && a.flags & 128)
        e:
          for (a = l.child; a !== null; ) {
            if (a.tag === 13)
              a.memoizedState !== null && Ih(a, m, l);
            else if (a.tag === 19)
              Ih(a, m, l);
            else if (a.child !== null) {
              a.child.return = a, a = a.child;
              continue;
            }
            if (a === l)
              break e;
            for (; a.sibling === null; ) {
              if (a.return === null || a.return === l)
                break e;
              a = a.return;
            }
            a.sibling.return = a.return, a = a.sibling;
          }
      k &= 1;
    }
    if (An(Ft, k), !(l.mode & 1))
      l.memoizedState = null;
    else
      switch (D) {
        case "forwards":
          for (m = l.child, D = null; m !== null; )
            a = m.alternate, a !== null && Kn(a) === null && (D = m), m = m.sibling;
          m = D, m === null ? (D = l.child, l.child = null) : (D = m.sibling, m.sibling = null), Fd(l, !1, D, m, z);
          break;
        case "backwards":
          for (m = null, D = l.child, l.child = null; D !== null; ) {
            if (a = D.alternate, a !== null && Kn(a) === null) {
              l.child = D;
              break;
            }
            a = D.sibling, D.sibling = m, m = D, D = a;
          }
          Fd(l, !0, m, null, z);
          break;
        case "together":
          Fd(l, !1, null, null, void 0);
          break;
        default:
          l.memoizedState = null;
      }
    return l.child;
  }
  function ci(a, l) {
    !(l.mode & 1) && a !== null && (a.alternate = null, l.alternate = null, l.flags |= 2);
  }
  function Xr(a, l, m) {
    if (a !== null && (l.dependencies = a.dependencies), Rs |= l.lanes, !(m & l.childLanes))
      return null;
    if (a !== null && l.child !== a.child)
      throw Error(h(153));
    if (l.child !== null) {
      for (a = l.child, m = mo(a, a.pendingProps), l.child = m, m.return = l; a.sibling !== null; )
        a = a.sibling, m = m.sibling = mo(a, a.pendingProps), m.return = l;
      m.sibling = null;
    }
    return l.child;
  }
  function Ts(a, l, m) {
    switch (l.tag) {
      case 3:
        kv(l), Qn();
        break;
      case 5:
        Nt(l);
        break;
      case 1:
        qn(l.type) && sd(l);
        break;
      case 4:
        Eh(l, l.stateNode.containerInfo);
        break;
      case 10:
        var k = l.type._context, D = l.memoizedProps.value;
        An(qa, k._currentValue), k._currentValue = D;
        break;
      case 13:
        if (k = l.memoizedState, k !== null)
          return k.dehydrated !== null ? (An(Ft, Ft.current & 1), l.flags |= 128, null) : m & l.child.childLanes ? Nh(a, l, m) : (An(Ft, Ft.current & 1), a = Xr(a, l, m), a !== null ? a.sibling : null);
        An(Ft, Ft.current & 1);
        break;
      case 19:
        if (k = (m & l.childLanes) !== 0, a.flags & 128) {
          if (k)
            return Fh(a, l, m);
          l.flags |= 128;
        }
        if (D = l.memoizedState, D !== null && (D.rendering = null, D.tail = null, D.lastEffect = null), An(Ft, Ft.current), k)
          break;
        return null;
      case 22:
      case 23:
        return l.lanes = 0, Ko(a, l, m);
    }
    return Xr(a, l, m);
  }
  var oc, el, wa, Tr;
  oc = function(a, l) {
    for (var m = l.child; m !== null; ) {
      if (m.tag === 5 || m.tag === 6)
        a.appendChild(m.stateNode);
      else if (m.tag !== 4 && m.child !== null) {
        m.child.return = m, m = m.child;
        continue;
      }
      if (m === l)
        break;
      for (; m.sibling === null; ) {
        if (m.return === null || m.return === l)
          return;
        m = m.return;
      }
      m.sibling.return = m.return, m = m.sibling;
    }
  }, el = function() {
  }, wa = function(a, l, m, k) {
    var D = a.memoizedProps;
    if (D !== k) {
      a = l.stateNode, Wo(Ha.current);
      var z = null;
      switch (m) {
        case "input":
          D = jn(a, D), k = jn(a, k), z = [];
          break;
        case "select":
          D = ye({}, D, { value: void 0 }), k = ye({}, k, { value: void 0 }), z = [];
          break;
        case "textarea":
          D = Qi(a, D), k = Qi(a, k), z = [];
          break;
        default:
          typeof D.onClick != "function" && typeof k.onClick == "function" && (a.onclick = ad);
      }
      vr(m, k);
      var $;
      m = null;
      for (Ee in D)
        if (!k.hasOwnProperty(Ee) && D.hasOwnProperty(Ee) && D[Ee] != null)
          if (Ee === "style") {
            var ie = D[Ee];
            for ($ in ie)
              ie.hasOwnProperty($) && (m || (m = {}), m[$] = "");
          } else
            Ee !== "dangerouslySetInnerHTML" && Ee !== "children" && Ee !== "suppressContentEditableWarning" && Ee !== "suppressHydrationWarning" && Ee !== "autoFocus" && (w.hasOwnProperty(Ee) ? z || (z = []) : (z = z || []).push(Ee, null));
      for (Ee in k) {
        var ce = k[Ee];
        if (ie = D != null ? D[Ee] : void 0, k.hasOwnProperty(Ee) && ce !== ie && (ce != null || ie != null))
          if (Ee === "style")
            if (ie) {
              for ($ in ie)
                !ie.hasOwnProperty($) || ce && ce.hasOwnProperty($) || (m || (m = {}), m[$] = "");
              for ($ in ce)
                ce.hasOwnProperty($) && ie[$] !== ce[$] && (m || (m = {}), m[$] = ce[$]);
            } else
              m || (z || (z = []), z.push(
                Ee,
                m
              )), m = ce;
          else
            Ee === "dangerouslySetInnerHTML" ? (ce = ce ? ce.__html : void 0, ie = ie ? ie.__html : void 0, ce != null && ie !== ce && (z = z || []).push(Ee, ce)) : Ee === "children" ? typeof ce != "string" && typeof ce != "number" || (z = z || []).push(Ee, "" + ce) : Ee !== "suppressContentEditableWarning" && Ee !== "suppressHydrationWarning" && (w.hasOwnProperty(Ee) ? (ce != null && Ee === "onScroll" && In("scroll", a), z || ie === ce || (z = [])) : (z = z || []).push(Ee, ce));
      }
      m && (z = z || []).push("style", m);
      var Ee = z;
      (l.updateQueue = Ee) && (l.flags |= 4);
    }
  }, Tr = function(a, l, m, k) {
    m !== k && (l.flags |= 4);
  };
  function lc(a, l) {
    if (!Wn)
      switch (a.tailMode) {
        case "hidden":
          l = a.tail;
          for (var m = null; l !== null; )
            l.alternate !== null && (m = l), l = l.sibling;
          m === null ? a.tail = null : m.sibling = null;
          break;
        case "collapsed":
          m = a.tail;
          for (var k = null; m !== null; )
            m.alternate !== null && (k = m), m = m.sibling;
          k === null ? l || a.tail === null ? a.tail = null : a.tail.sibling = null : k.sibling = null;
      }
  }
  function di(a) {
    var l = a.alternate !== null && a.alternate.child === a.child, m = 0, k = 0;
    if (l)
      for (var D = a.child; D !== null; )
        m |= D.lanes | D.childLanes, k |= D.subtreeFlags & 14680064, k |= D.flags & 14680064, D.return = a, D = D.sibling;
    else
      for (D = a.child; D !== null; )
        m |= D.lanes | D.childLanes, k |= D.subtreeFlags, k |= D.flags, D.return = a, D = D.sibling;
    return a.subtreeFlags |= k, a.childLanes = m, l;
  }
  function Px(a, l, m) {
    var k = l.pendingProps;
    switch (yh(l), l.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return di(l), null;
      case 1:
        return qn(l.type) && va(), di(l), null;
      case 3:
        return k = l.stateNode, uo(), Sn(or), Sn(Wt), md(), k.pendingContext && (k.context = k.pendingContext, k.pendingContext = null), (a === null || a.child === null) && (cd(l) ? l.flags |= 4 : a === null || a.memoizedState.isDehydrated && !(l.flags & 256) || (l.flags |= 1024, ya !== null && (gc(ya), ya = null))), el(a, l), di(l), null;
      case 5:
        nn(l);
        var D = Wo(Xl.current);
        if (m = l.type, a !== null && l.stateNode != null)
          wa(a, l, m, k, D), a.ref !== l.ref && (l.flags |= 512, l.flags |= 2097152);
        else {
          if (!k) {
            if (l.stateNode === null)
              throw Error(h(166));
            return di(l), null;
          }
          if (a = Wo(Ha.current), cd(l)) {
            k = l.stateNode, m = l.type;
            var z = l.memoizedProps;
            switch (k[Ga] = l, k[jo] = z, a = (l.mode & 1) !== 0, m) {
              case "dialog":
                In("cancel", k), In("close", k);
                break;
              case "iframe":
              case "object":
              case "embed":
                In("load", k);
                break;
              case "video":
              case "audio":
                for (D = 0; D < Xu.length; D++)
                  In(Xu[D], k);
                break;
              case "source":
                In("error", k);
                break;
              case "img":
              case "image":
              case "link":
                In(
                  "error",
                  k
                ), In("load", k);
                break;
              case "details":
                In("toggle", k);
                break;
              case "input":
                ir(k, z), In("invalid", k);
                break;
              case "select":
                k._wrapperState = { wasMultiple: !!z.multiple }, In("invalid", k);
                break;
              case "textarea":
                yi(k, z), In("invalid", k);
            }
            vr(m, z), D = null;
            for (var $ in z)
              if (z.hasOwnProperty($)) {
                var ie = z[$];
                $ === "children" ? typeof ie == "string" ? k.textContent !== ie && (z.suppressHydrationWarning !== !0 && id(k.textContent, ie, a), D = ["children", ie]) : typeof ie == "number" && k.textContent !== "" + ie && (z.suppressHydrationWarning !== !0 && id(
                  k.textContent,
                  ie,
                  a
                ), D = ["children", "" + ie]) : w.hasOwnProperty($) && ie != null && $ === "onScroll" && In("scroll", k);
              }
            switch (m) {
              case "input":
                vn(k), ti(k, z, !0);
                break;
              case "textarea":
                vn(k), xi(k);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof z.onClick == "function" && (k.onclick = ad);
            }
            k = D, l.updateQueue = k, k !== null && (l.flags |= 4);
          } else {
            $ = D.nodeType === 9 ? D : D.ownerDocument, a === "http://www.w3.org/1999/xhtml" && (a = ni(m)), a === "http://www.w3.org/1999/xhtml" ? m === "script" ? (a = $.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : typeof k.is == "string" ? a = $.createElement(m, { is: k.is }) : (a = $.createElement(m), m === "select" && ($ = a, k.multiple ? $.multiple = !0 : k.size && ($.size = k.size))) : a = $.createElementNS(a, m), a[Ga] = l, a[jo] = k, oc(a, l, !1, !1), l.stateNode = a;
            e: {
              switch ($ = $n(m, k), m) {
                case "dialog":
                  In("cancel", a), In("close", a), D = k;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  In("load", a), D = k;
                  break;
                case "video":
                case "audio":
                  for (D = 0; D < Xu.length; D++)
                    In(Xu[D], a);
                  D = k;
                  break;
                case "source":
                  In("error", a), D = k;
                  break;
                case "img":
                case "image":
                case "link":
                  In(
                    "error",
                    a
                  ), In("load", a), D = k;
                  break;
                case "details":
                  In("toggle", a), D = k;
                  break;
                case "input":
                  ir(a, k), D = jn(a, k), In("invalid", a);
                  break;
                case "option":
                  D = k;
                  break;
                case "select":
                  a._wrapperState = { wasMultiple: !!k.multiple }, D = ye({}, k, { value: void 0 }), In("invalid", a);
                  break;
                case "textarea":
                  yi(a, k), D = Qi(a, k), In("invalid", a);
                  break;
                default:
                  D = k;
              }
              vr(m, D), ie = D;
              for (z in ie)
                if (ie.hasOwnProperty(z)) {
                  var ce = ie[z];
                  z === "style" ? bn(a, ce) : z === "dangerouslySetInnerHTML" ? (ce = ce ? ce.__html : void 0, ce != null && Pa(a, ce)) : z === "children" ? typeof ce == "string" ? (m !== "textarea" || ce !== "") && Ki(a, ce) : typeof ce == "number" && Ki(a, "" + ce) : z !== "suppressContentEditableWarning" && z !== "suppressHydrationWarning" && z !== "autoFocus" && (w.hasOwnProperty(z) ? ce != null && z === "onScroll" && In("scroll", a) : ce != null && we(a, z, ce, $));
                }
              switch (m) {
                case "input":
                  vn(a), ti(a, k, !1);
                  break;
                case "textarea":
                  vn(a), xi(a);
                  break;
                case "option":
                  k.value != null && a.setAttribute("value", "" + Rt(k.value));
                  break;
                case "select":
                  a.multiple = !!k.multiple, z = k.value, z != null ? da(a, !!k.multiple, z, !1) : k.defaultValue != null && da(
                    a,
                    !!k.multiple,
                    k.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof D.onClick == "function" && (a.onclick = ad);
              }
              switch (m) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k = !!k.autoFocus;
                  break e;
                case "img":
                  k = !0;
                  break e;
                default:
                  k = !1;
              }
            }
            k && (l.flags |= 4);
          }
          l.ref !== null && (l.flags |= 512, l.flags |= 2097152);
        }
        return di(l), null;
      case 6:
        if (a && l.stateNode != null)
          Tr(a, l, a.memoizedProps, k);
        else {
          if (typeof k != "string" && l.stateNode === null)
            throw Error(h(166));
          if (m = Wo(Xl.current), Wo(Ha.current), cd(l)) {
            if (k = l.stateNode, m = l.memoizedProps, k[Ga] = l, (z = k.nodeValue !== m) && (a = na, a !== null))
              switch (a.tag) {
                case 3:
                  id(k.nodeValue, m, (a.mode & 1) !== 0);
                  break;
                case 5:
                  a.memoizedProps.suppressHydrationWarning !== !0 && id(k.nodeValue, m, (a.mode & 1) !== 0);
              }
            z && (l.flags |= 4);
          } else
            k = (m.nodeType === 9 ? m : m.ownerDocument).createTextNode(k), k[Ga] = l, l.stateNode = k;
        }
        return di(l), null;
      case 13:
        if (Sn(Ft), k = l.memoizedState, a === null || a.memoizedState !== null && a.memoizedState.dehydrated !== null) {
          if (Wn && Fi !== null && l.mode & 1 && !(l.flags & 128))
            cv(), Qn(), l.flags |= 98560, z = !1;
          else if (z = cd(l), k !== null && k.dehydrated !== null) {
            if (a === null) {
              if (!z)
                throw Error(h(318));
              if (z = l.memoizedState, z = z !== null ? z.dehydrated : null, !z)
                throw Error(h(317));
              z[Ga] = l;
            } else
              Qn(), !(l.flags & 128) && (l.memoizedState = null), l.flags |= 4;
            di(l), z = !1;
          } else
            ya !== null && (gc(ya), ya = null), z = !0;
          if (!z)
            return l.flags & 65536 ? l : null;
        }
        return l.flags & 128 ? (l.lanes = m, l) : (k = k !== null, k !== (a !== null && a.memoizedState !== null) && k && (l.child.flags |= 8192, l.mode & 1 && (a === null || Ft.current & 1 ? Rr === 0 && (Rr = 3) : $h())), l.updateQueue !== null && (l.flags |= 4), di(l), null);
      case 4:
        return uo(), el(a, l), a === null && Hl(l.stateNode.containerInfo), di(l), null;
      case 10:
        return ao(l.type._context), di(l), null;
      case 17:
        return qn(l.type) && va(), di(l), null;
      case 19:
        if (Sn(Ft), z = l.memoizedState, z === null)
          return di(l), null;
        if (k = (l.flags & 128) !== 0, $ = z.rendering, $ === null)
          if (k)
            lc(z, !1);
          else {
            if (Rr !== 0 || a !== null && a.flags & 128)
              for (a = l.child; a !== null; ) {
                if ($ = Kn(a), $ !== null) {
                  for (l.flags |= 128, lc(z, !1), k = $.updateQueue, k !== null && (l.updateQueue = k, l.flags |= 4), l.subtreeFlags = 0, k = m, m = l.child; m !== null; )
                    z = m, a = k, z.flags &= 14680066, $ = z.alternate, $ === null ? (z.childLanes = 0, z.lanes = a, z.child = null, z.subtreeFlags = 0, z.memoizedProps = null, z.memoizedState = null, z.updateQueue = null, z.dependencies = null, z.stateNode = null) : (z.childLanes = $.childLanes, z.lanes = $.lanes, z.child = $.child, z.subtreeFlags = 0, z.deletions = null, z.memoizedProps = $.memoizedProps, z.memoizedState = $.memoizedState, z.updateQueue = $.updateQueue, z.type = $.type, a = $.dependencies, z.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }), m = m.sibling;
                  return An(Ft, Ft.current & 1 | 2), l.child;
                }
                a = a.sibling;
              }
            z.tail !== null && o() > iu && (l.flags |= 128, k = !0, lc(z, !1), l.lanes = 4194304);
          }
        else {
          if (!k)
            if (a = Kn($), a !== null) {
              if (l.flags |= 128, k = !0, m = a.updateQueue, m !== null && (l.updateQueue = m, l.flags |= 4), lc(z, !0), z.tail === null && z.tailMode === "hidden" && !$.alternate && !Wn)
                return di(l), null;
            } else
              2 * o() - z.renderingStartTime > iu && m !== 1073741824 && (l.flags |= 128, k = !0, lc(z, !1), l.lanes = 4194304);
          z.isBackwards ? ($.sibling = l.child, l.child = $) : (m = z.last, m !== null ? m.sibling = $ : l.child = $, z.last = $);
        }
        return z.tail !== null ? (l = z.tail, z.rendering = l, z.tail = l.sibling, z.renderingStartTime = o(), l.sibling = null, m = Ft.current, An(Ft, k ? m & 1 | 2 : m & 1), l) : (di(l), null);
      case 22:
      case 23:
        return Gh(), k = l.memoizedState !== null, a !== null && a.memoizedState !== null !== k && (l.flags |= 8192), k && l.mode & 1 ? aa & 1073741824 && (di(l), l.subtreeFlags & 6 && (l.flags |= 8192)) : di(l), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(h(156, l.tag));
  }
  function Yh(a, l) {
    switch (yh(l), l.tag) {
      case 1:
        return qn(l.type) && va(), a = l.flags, a & 65536 ? (l.flags = a & -65537 | 128, l) : null;
      case 3:
        return uo(), Sn(or), Sn(Wt), md(), a = l.flags, a & 65536 && !(a & 128) ? (l.flags = a & -65537 | 128, l) : null;
      case 5:
        return nn(l), null;
      case 13:
        if (Sn(Ft), a = l.memoizedState, a !== null && a.dehydrated !== null) {
          if (l.alternate === null)
            throw Error(h(340));
          Qn();
        }
        return a = l.flags, a & 65536 ? (l.flags = a & -65537 | 128, l) : null;
      case 19:
        return Sn(Ft), null;
      case 4:
        return uo(), null;
      case 10:
        return ao(l.type._context), null;
      case 22:
      case 23:
        return Gh(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var uc = !1, Er = !1, Cv = typeof WeakSet == "function" ? WeakSet : Set, gt = null;
  function Kl(a, l) {
    var m = a.ref;
    if (m !== null)
      if (typeof m == "function")
        try {
          m(null);
        } catch (k) {
          ur(a, l, k);
        }
      else
        m.current = null;
  }
  function cc(a, l, m) {
    try {
      m();
    } catch (k) {
      ur(a, l, k);
    }
  }
  var Av = !1;
  function Tv(a, l) {
    if (ch = Po, a = Jc(), ys(a)) {
      if ("selectionStart" in a)
        var m = { start: a.selectionStart, end: a.selectionEnd };
      else
        e: {
          m = (m = a.ownerDocument) && m.defaultView || window;
          var k = m.getSelection && m.getSelection();
          if (k && k.rangeCount !== 0) {
            m = k.anchorNode;
            var D = k.anchorOffset, z = k.focusNode;
            k = k.focusOffset;
            try {
              m.nodeType, z.nodeType;
            } catch {
              m = null;
              break e;
            }
            var $ = 0, ie = -1, ce = -1, Ee = 0, He = 0, Be = a, Fe = null;
            t:
              for (; ; ) {
                for (var lt; Be !== m || D !== 0 && Be.nodeType !== 3 || (ie = $ + D), Be !== z || k !== 0 && Be.nodeType !== 3 || (ce = $ + k), Be.nodeType === 3 && ($ += Be.nodeValue.length), (lt = Be.firstChild) !== null; )
                  Fe = Be, Be = lt;
                for (; ; ) {
                  if (Be === a)
                    break t;
                  if (Fe === m && ++Ee === D && (ie = $), Fe === z && ++He === k && (ce = $), (lt = Be.nextSibling) !== null)
                    break;
                  Be = Fe, Fe = Be.parentNode;
                }
                Be = lt;
              }
            m = ie === -1 || ce === -1 ? null : { start: ie, end: ce };
          } else
            m = null;
        }
      m = m || { start: 0, end: 0 };
    } else
      m = null;
    for (Yo = { focusedElem: a, selectionRange: m }, Po = !1, gt = l; gt !== null; )
      if (l = gt, a = l.child, (l.subtreeFlags & 1028) !== 0 && a !== null)
        a.return = l, gt = a;
      else
        for (; gt !== null; ) {
          l = gt;
          try {
            var xt = l.alternate;
            if (l.flags & 1024)
              switch (l.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (xt !== null) {
                    var Ct = xt.memoizedProps, hr = xt.memoizedState, me = l.stateNode, pe = me.getSnapshotBeforeUpdate(l.elementType === l.type ? Ct : ra(l.type, Ct), hr);
                    me.__reactInternalSnapshotBeforeUpdate = pe;
                  }
                  break;
                case 3:
                  var Se = l.stateNode.containerInfo;
                  Se.nodeType === 1 ? Se.textContent = "" : Se.nodeType === 9 && Se.documentElement && Se.removeChild(Se.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(h(163));
              }
          } catch ($e) {
            ur(l, l.return, $e);
          }
          if (a = l.sibling, a !== null) {
            a.return = l.return, gt = a;
            break;
          }
          gt = l.return;
        }
    return xt = Av, Av = !1, xt;
  }
  function dc(a, l, m) {
    var k = l.updateQueue;
    if (k = k !== null ? k.lastEffect : null, k !== null) {
      var D = k = k.next;
      do {
        if ((D.tag & a) === a) {
          var z = D.destroy;
          D.destroy = void 0, z !== void 0 && cc(l, m, z);
        }
        D = D.next;
      } while (D !== k);
    }
  }
  function fc(a, l) {
    if (l = l.updateQueue, l = l !== null ? l.lastEffect : null, l !== null) {
      var m = l = l.next;
      do {
        if ((m.tag & a) === a) {
          var k = m.create;
          m.destroy = k();
        }
        m = m.next;
      } while (m !== l);
    }
  }
  function Hh(a) {
    var l = a.ref;
    if (l !== null) {
      var m = a.stateNode;
      switch (a.tag) {
        case 5:
          a = m;
          break;
        default:
          a = m;
      }
      typeof l == "function" ? l(a) : l.current = a;
    }
  }
  function jh(a) {
    var l = a.alternate;
    l !== null && (a.alternate = null, jh(l)), a.child = null, a.deletions = null, a.sibling = null, a.tag === 5 && (l = a.stateNode, l !== null && (delete l[Ga], delete l[jo], delete l[hh], delete l[Ex], delete l[ph])), a.stateNode = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
  }
  function Ev(a) {
    return a.tag === 5 || a.tag === 3 || a.tag === 4;
  }
  function Yd(a) {
    e:
      for (; ; ) {
        for (; a.sibling === null; ) {
          if (a.return === null || Ev(a.return))
            return null;
          a = a.return;
        }
        for (a.sibling.return = a.return, a = a.sibling; a.tag !== 5 && a.tag !== 6 && a.tag !== 18; ) {
          if (a.flags & 2 || a.child === null || a.tag === 4)
            continue e;
          a.child.return = a, a = a.child;
        }
        if (!(a.flags & 2))
          return a.stateNode;
      }
  }
  function Jl(a, l, m) {
    var k = a.tag;
    if (k === 5 || k === 6)
      a = a.stateNode, l ? m.nodeType === 8 ? m.parentNode.insertBefore(a, l) : m.insertBefore(a, l) : (m.nodeType === 8 ? (l = m.parentNode, l.insertBefore(a, m)) : (l = m, l.appendChild(a)), m = m._reactRootContainer, m != null || l.onclick !== null || (l.onclick = ad));
    else if (k !== 4 && (a = a.child, a !== null))
      for (Jl(a, l, m), a = a.sibling; a !== null; )
        Jl(a, l, m), a = a.sibling;
  }
  function Qa(a, l, m) {
    var k = a.tag;
    if (k === 5 || k === 6)
      a = a.stateNode, l ? m.insertBefore(a, l) : m.appendChild(a);
    else if (k !== 4 && (a = a.child, a !== null))
      for (Qa(a, l, m), a = a.sibling; a !== null; )
        Qa(a, l, m), a = a.sibling;
  }
  var Zn = null, Ir = !1;
  function Sa(a, l, m) {
    for (m = m.child; m !== null; )
      eu(a, l, m), m = m.sibling;
  }
  function eu(a, l, m) {
    if (L && typeof L.onCommitFiberUnmount == "function")
      try {
        L.onCommitFiberUnmount(E, m);
      } catch {
      }
    switch (m.tag) {
      case 5:
        Er || Kl(m, l);
      case 6:
        var k = Zn, D = Ir;
        Zn = null, Sa(a, l, m), Zn = k, Ir = D, Zn !== null && (Ir ? (a = Zn, m = m.stateNode, a.nodeType === 8 ? a.parentNode.removeChild(m) : a.removeChild(m)) : Zn.removeChild(m.stateNode));
        break;
      case 18:
        Zn !== null && (Ir ? (a = Zn, m = m.stateNode, a.nodeType === 8 ? Js(a.parentNode, m) : a.nodeType === 1 && Js(a, m), Pu(a)) : Js(Zn, m.stateNode));
        break;
      case 4:
        k = Zn, D = Ir, Zn = m.stateNode.containerInfo, Ir = !0, Sa(a, l, m), Zn = k, Ir = D;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Er && (k = m.updateQueue, k !== null && (k = k.lastEffect, k !== null))) {
          D = k = k.next;
          do {
            var z = D, $ = z.destroy;
            z = z.tag, $ !== void 0 && (z & 2 || z & 4) && cc(m, l, $), D = D.next;
          } while (D !== k);
        }
        Sa(a, l, m);
        break;
      case 1:
        if (!Er && (Kl(m, l), k = m.stateNode, typeof k.componentWillUnmount == "function"))
          try {
            k.props = m.memoizedProps, k.state = m.memoizedState, k.componentWillUnmount();
          } catch (ie) {
            ur(m, l, ie);
          }
        Sa(a, l, m);
        break;
      case 21:
        Sa(a, l, m);
        break;
      case 22:
        m.mode & 1 ? (Er = (k = Er) || m.memoizedState !== null, Sa(a, l, m), Er = k) : Sa(a, l, m);
        break;
      default:
        Sa(a, l, m);
    }
  }
  function Es(a) {
    var l = a.updateQueue;
    if (l !== null) {
      a.updateQueue = null;
      var m = a.stateNode;
      m === null && (m = a.stateNode = new Cv()), l.forEach(function(k) {
        var D = Hx.bind(null, a, k);
        m.has(k) || (m.add(k), k.then(D, D));
      });
    }
  }
  function ja(a, l) {
    var m = l.deletions;
    if (m !== null)
      for (var k = 0; k < m.length; k++) {
        var D = m[k];
        try {
          var z = a, $ = l, ie = $;
          e:
            for (; ie !== null; ) {
              switch (ie.tag) {
                case 5:
                  Zn = ie.stateNode, Ir = !1;
                  break e;
                case 3:
                  Zn = ie.stateNode.containerInfo, Ir = !0;
                  break e;
                case 4:
                  Zn = ie.stateNode.containerInfo, Ir = !0;
                  break e;
              }
              ie = ie.return;
            }
          if (Zn === null)
            throw Error(h(160));
          eu(z, $, D), Zn = null, Ir = !1;
          var ce = D.alternate;
          ce !== null && (ce.return = null), D.return = null;
        } catch (Ee) {
          ur(D, l, Ee);
        }
      }
    if (l.subtreeFlags & 12854)
      for (l = l.child; l !== null; )
        Rv(l, a), l = l.sibling;
  }
  function Rv(a, l) {
    var m = a.alternate, k = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (ja(l, a), Ka(a), k & 4) {
          try {
            dc(3, a, a.return), fc(3, a);
          } catch (Ct) {
            ur(a, a.return, Ct);
          }
          try {
            dc(5, a, a.return);
          } catch (Ct) {
            ur(a, a.return, Ct);
          }
        }
        break;
      case 1:
        ja(l, a), Ka(a), k & 512 && m !== null && Kl(m, m.return);
        break;
      case 5:
        if (ja(l, a), Ka(a), k & 512 && m !== null && Kl(m, m.return), a.flags & 32) {
          var D = a.stateNode;
          try {
            Ki(D, "");
          } catch (Ct) {
            ur(a, a.return, Ct);
          }
        }
        if (k & 4 && (D = a.stateNode, D != null)) {
          var z = a.memoizedProps, $ = m !== null ? m.memoizedProps : z, ie = a.type, ce = a.updateQueue;
          if (a.updateQueue = null, ce !== null)
            try {
              ie === "input" && z.type === "radio" && z.name != null && Dr(D, z), $n(ie, $);
              var Ee = $n(ie, z);
              for ($ = 0; $ < ce.length; $ += 2) {
                var He = ce[$], Be = ce[$ + 1];
                He === "style" ? bn(D, Be) : He === "dangerouslySetInnerHTML" ? Pa(D, Be) : He === "children" ? Ki(D, Be) : we(D, He, Be, Ee);
              }
              switch (ie) {
                case "input":
                  Or(D, z);
                  break;
                case "textarea":
                  fa(D, z);
                  break;
                case "select":
                  var Fe = D._wrapperState.wasMultiple;
                  D._wrapperState.wasMultiple = !!z.multiple;
                  var lt = z.value;
                  lt != null ? da(D, !!z.multiple, lt, !1) : Fe !== !!z.multiple && (z.defaultValue != null ? da(
                    D,
                    !!z.multiple,
                    z.defaultValue,
                    !0
                  ) : da(D, !!z.multiple, z.multiple ? [] : "", !1));
              }
              D[jo] = z;
            } catch (Ct) {
              ur(a, a.return, Ct);
            }
        }
        break;
      case 6:
        if (ja(l, a), Ka(a), k & 4) {
          if (a.stateNode === null)
            throw Error(h(162));
          D = a.stateNode, z = a.memoizedProps;
          try {
            D.nodeValue = z;
          } catch (Ct) {
            ur(a, a.return, Ct);
          }
        }
        break;
      case 3:
        if (ja(l, a), Ka(a), k & 4 && m !== null && m.memoizedState.isDehydrated)
          try {
            Pu(l.containerInfo);
          } catch (Ct) {
            ur(a, a.return, Ct);
          }
        break;
      case 4:
        ja(l, a), Ka(a);
        break;
      case 13:
        ja(l, a), Ka(a), D = a.child, D.flags & 8192 && (z = D.memoizedState !== null, D.stateNode.isHidden = z, !z || D.alternate !== null && D.alternate.memoizedState !== null || (Wh = o())), k & 4 && Es(a);
        break;
      case 22:
        if (He = m !== null && m.memoizedState !== null, a.mode & 1 ? (Er = (Ee = Er) || He, ja(l, a), Er = Ee) : ja(l, a), Ka(a), k & 8192) {
          if (Ee = a.memoizedState !== null, (a.stateNode.isHidden = Ee) && !He && a.mode & 1)
            for (gt = a, He = a.child; He !== null; ) {
              for (Be = gt = He; gt !== null; ) {
                switch (Fe = gt, lt = Fe.child, Fe.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    dc(4, Fe, Fe.return);
                    break;
                  case 1:
                    Kl(Fe, Fe.return);
                    var xt = Fe.stateNode;
                    if (typeof xt.componentWillUnmount == "function") {
                      k = Fe, m = Fe.return;
                      try {
                        l = k, xt.props = l.memoizedProps, xt.state = l.memoizedState, xt.componentWillUnmount();
                      } catch (Ct) {
                        ur(k, m, Ct);
                      }
                    }
                    break;
                  case 5:
                    Kl(Fe, Fe.return);
                    break;
                  case 22:
                    if (Fe.memoizedState !== null) {
                      Uh(Be);
                      continue;
                    }
                }
                lt !== null ? (lt.return = Fe, gt = lt) : Uh(Be);
              }
              He = He.sibling;
            }
          e:
            for (He = null, Be = a; ; ) {
              if (Be.tag === 5) {
                if (He === null) {
                  He = Be;
                  try {
                    D = Be.stateNode, Ee ? (z = D.style, typeof z.setProperty == "function" ? z.setProperty("display", "none", "important") : z.display = "none") : (ie = Be.stateNode, ce = Be.memoizedProps.style, $ = ce != null && ce.hasOwnProperty("display") ? ce.display : null, ie.style.display = tn("display", $));
                  } catch (Ct) {
                    ur(a, a.return, Ct);
                  }
                }
              } else if (Be.tag === 6) {
                if (He === null)
                  try {
                    Be.stateNode.nodeValue = Ee ? "" : Be.memoizedProps;
                  } catch (Ct) {
                    ur(a, a.return, Ct);
                  }
              } else if ((Be.tag !== 22 && Be.tag !== 23 || Be.memoizedState === null || Be === a) && Be.child !== null) {
                Be.child.return = Be, Be = Be.child;
                continue;
              }
              if (Be === a)
                break e;
              for (; Be.sibling === null; ) {
                if (Be.return === null || Be.return === a)
                  break e;
                He === Be && (He = null), Be = Be.return;
              }
              He === Be && (He = null), Be.sibling.return = Be.return, Be = Be.sibling;
            }
        }
        break;
      case 19:
        ja(l, a), Ka(a), k & 4 && Es(a);
        break;
      case 21:
        break;
      default:
        ja(
          l,
          a
        ), Ka(a);
    }
  }
  function Ka(a) {
    var l = a.flags;
    if (l & 2) {
      try {
        e: {
          for (var m = a.return; m !== null; ) {
            if (Ev(m)) {
              var k = m;
              break e;
            }
            m = m.return;
          }
          throw Error(h(160));
        }
        switch (k.tag) {
          case 5:
            var D = k.stateNode;
            k.flags & 32 && (Ki(D, ""), k.flags &= -33);
            var z = Yd(a);
            Qa(a, z, D);
            break;
          case 3:
          case 4:
            var $ = k.stateNode.containerInfo, ie = Yd(a);
            Jl(a, ie, $);
            break;
          default:
            throw Error(h(161));
        }
      } catch (ce) {
        ur(a, a.return, ce);
      }
      a.flags &= -3;
    }
    l & 4096 && (a.flags &= -4097);
  }
  function Lv(a, l, m) {
    gt = a, tu(a);
  }
  function tu(a, l, m) {
    for (var k = (a.mode & 1) !== 0; gt !== null; ) {
      var D = gt, z = D.child;
      if (D.tag === 22 && k) {
        var $ = D.memoizedState !== null || uc;
        if (!$) {
          var ie = D.alternate, ce = ie !== null && ie.memoizedState !== null || Er;
          ie = uc;
          var Ee = Er;
          if (uc = $, (Er = ce) && !Ee)
            for (gt = D; gt !== null; )
              $ = gt, ce = $.child, $.tag === 22 && $.memoizedState !== null ? Dv(D) : ce !== null ? (ce.return = $, gt = ce) : Dv(D);
          for (; z !== null; )
            gt = z, tu(z), z = z.sibling;
          gt = D, uc = ie, Er = Ee;
        }
        Mv(a);
      } else
        D.subtreeFlags & 8772 && z !== null ? (z.return = D, gt = z) : Mv(a);
    }
  }
  function Mv(a) {
    for (; gt !== null; ) {
      var l = gt;
      if (l.flags & 8772) {
        var m = l.alternate;
        try {
          if (l.flags & 8772)
            switch (l.tag) {
              case 0:
              case 11:
              case 15:
                Er || fc(5, l);
                break;
              case 1:
                var k = l.stateNode;
                if (l.flags & 4 && !Er)
                  if (m === null)
                    k.componentDidMount();
                  else {
                    var D = l.elementType === l.type ? m.memoizedProps : ra(l.type, m.memoizedProps);
                    k.componentDidUpdate(D, m.memoizedState, k.__reactInternalSnapshotBeforeUpdate);
                  }
                var z = l.updateQueue;
                z !== null && Bo(l, z, k);
                break;
              case 3:
                var $ = l.updateQueue;
                if ($ !== null) {
                  if (m = null, l.child !== null)
                    switch (l.child.tag) {
                      case 5:
                        m = l.child.stateNode;
                        break;
                      case 1:
                        m = l.child.stateNode;
                    }
                  Bo(l, $, m);
                }
                break;
              case 5:
                var ie = l.stateNode;
                if (m === null && l.flags & 4) {
                  m = ie;
                  var ce = l.memoizedProps;
                  switch (l.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      ce.autoFocus && m.focus();
                      break;
                    case "img":
                      ce.src && (m.src = ce.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (l.memoizedState === null) {
                  var Ee = l.alternate;
                  if (Ee !== null) {
                    var He = Ee.memoizedState;
                    if (He !== null) {
                      var Be = He.dehydrated;
                      Be !== null && Pu(Be);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(h(163));
            }
          Er || l.flags & 512 && Hh(l);
        } catch (Fe) {
          ur(l, l.return, Fe);
        }
      }
      if (l === a) {
        gt = null;
        break;
      }
      if (m = l.sibling, m !== null) {
        m.return = l.return, gt = m;
        break;
      }
      gt = l.return;
    }
  }
  function Uh(a) {
    for (; gt !== null; ) {
      var l = gt;
      if (l === a) {
        gt = null;
        break;
      }
      var m = l.sibling;
      if (m !== null) {
        m.return = l.return, gt = m;
        break;
      }
      gt = l.return;
    }
  }
  function Dv(a) {
    for (; gt !== null; ) {
      var l = gt;
      try {
        switch (l.tag) {
          case 0:
          case 11:
          case 15:
            var m = l.return;
            try {
              fc(4, l);
            } catch (ce) {
              ur(l, m, ce);
            }
            break;
          case 1:
            var k = l.stateNode;
            if (typeof k.componentDidMount == "function") {
              var D = l.return;
              try {
                k.componentDidMount();
              } catch (ce) {
                ur(l, D, ce);
              }
            }
            var z = l.return;
            try {
              Hh(l);
            } catch (ce) {
              ur(l, z, ce);
            }
            break;
          case 5:
            var $ = l.return;
            try {
              Hh(l);
            } catch (ce) {
              ur(l, $, ce);
            }
        }
      } catch (ce) {
        ur(l, l.return, ce);
      }
      if (l === a) {
        gt = null;
        break;
      }
      var ie = l.sibling;
      if (ie !== null) {
        ie.return = l.return, gt = ie;
        break;
      }
      gt = l.return;
    }
  }
  var Hd = Math.ceil, hc = Re.ReactCurrentDispatcher, Bh = Re.ReactCurrentOwner, fi = Re.ReactCurrentBatchConfig, sn = 0, Jn = null, lr = null, Fr = 0, aa = 0, nu = Jt(0), Rr = 0, pc = null, Rs = 0, jd = 0, ru = 0, tl = null, wi = null, Wh = 0, iu = 1 / 0, Ls = null, Ud = !1, nl = null, Ja = null, po = !1, go = null, Bd = 0, au = 0, Wd = null, rl = -1, il = 0;
  function hi() {
    return sn & 6 ? o() : rl !== -1 ? rl : rl = o();
  }
  function wr(a) {
    return a.mode & 1 ? sn & 2 && Fr !== 0 ? Fr & -Fr : dd.transition !== null ? (il === 0 && (il = oe()), il) : (a = Ie, a !== 0 || (a = window.event, a = a === void 0 ? 16 : Wf(a.type)), a) : 1;
  }
  function pi(a, l, m, k) {
    if (50 < au)
      throw au = 0, Wd = null, Error(h(185));
    ke(a, m, k), (!(sn & 2) || a !== Jn) && (a === Jn && (!(sn & 2) && (jd |= m), Rr === 4 && ka(a, Fr)), gi(a, k), m === 1 && sn === 0 && !(l.mode & 1) && (iu = o() + 500, Nr && Ni()));
  }
  function gi(a, l) {
    var m = a.callbackNode;
    Q(a, l);
    var k = N(a, a === Jn ? Fr : 0);
    if (k === 0)
      m !== null && t(m), a.callbackNode = null, a.callbackPriority = 0;
    else if (l = k & -k, a.callbackPriority !== l) {
      if (m != null && t(m), l === 1)
        a.tag === 0 ? vh(Ov.bind(null, a)) : gh(Ov.bind(null, a)), fh(function() {
          !(sn & 6) && Ni();
        }), m = null;
      else {
        switch (at(k)) {
          case 1:
            m = f;
            break;
          case 4:
            m = p;
            break;
          case 16:
            m = y;
            break;
          case 536870912:
            m = A;
            break;
          default:
            m = y;
        }
        m = Zh(m, su.bind(null, a));
      }
      a.callbackPriority = l, a.callbackNode = m;
    }
  }
  function su(a, l) {
    if (rl = -1, il = 0, sn & 6)
      throw Error(h(327));
    var m = a.callbackNode;
    if (lu() && a.callbackNode !== m)
      return null;
    var k = N(a, a === Jn ? Fr : 0);
    if (k === 0)
      return null;
    if (k & 30 || k & a.expiredLanes || l)
      l = Vd(a, k);
    else {
      l = k;
      var D = sn;
      sn |= 2;
      var z = Xd();
      (Jn !== a || Fr !== l) && (Ls = null, iu = o() + 500, al(a, l));
      do
        try {
          zx();
          break;
        } catch (ie) {
          _v(a, ie);
        }
      while (1);
      Sh(), hc.current = z, sn = D, lr !== null ? l = 0 : (Jn = null, Fr = 0, l = Rr);
    }
    if (l !== 0) {
      if (l === 2 && (D = ee(a), D !== 0 && (k = D, l = Xh(a, D))), l === 1)
        throw m = pc, al(a, 0), ka(a, k), gi(a, o()), m;
      if (l === 6)
        ka(a, k);
      else {
        if (D = a.current.alternate, !(k & 30) && !Vh(D) && (l = Vd(a, k), l === 2 && (z = ee(a), z !== 0 && (k = z, l = Xh(a, z))), l === 1))
          throw m = pc, al(a, 0), ka(a, k), gi(a, o()), m;
        switch (a.finishedWork = D, a.finishedLanes = k, l) {
          case 0:
          case 1:
            throw Error(h(345));
          case 2:
            sl(a, wi, Ls);
            break;
          case 3:
            if (ka(a, k), (k & 130023424) === k && (l = Wh + 500 - o(), 10 < l)) {
              if (N(a, 0) !== 0)
                break;
              if (D = a.suspendedLanes, (D & k) !== k) {
                hi(), a.pingedLanes |= a.suspendedLanes & D;
                break;
              }
              a.timeoutHandle = Ho(sl.bind(null, a, wi, Ls), l);
              break;
            }
            sl(a, wi, Ls);
            break;
          case 4:
            if (ka(a, k), (k & 4194240) === k)
              break;
            for (l = a.eventTimes, D = -1; 0 < k; ) {
              var $ = 31 - P(k);
              z = 1 << $, $ = l[$], $ > D && (D = $), k &= ~z;
            }
            if (k = D, k = o() - k, k = (120 > k ? 120 : 480 > k ? 480 : 1080 > k ? 1080 : 1920 > k ? 1920 : 3e3 > k ? 3e3 : 4320 > k ? 4320 : 1960 * Hd(k / 1960)) - k, 10 < k) {
              a.timeoutHandle = Ho(sl.bind(null, a, wi, Ls), k);
              break;
            }
            sl(a, wi, Ls);
            break;
          case 5:
            sl(a, wi, Ls);
            break;
          default:
            throw Error(h(329));
        }
      }
    }
    return gi(a, o()), a.callbackNode === m ? su.bind(null, a) : null;
  }
  function Xh(a, l) {
    var m = tl;
    return a.current.memoizedState.isDehydrated && (al(a, l).flags |= 256), a = Vd(a, l), a !== 2 && (l = wi, wi = m, l !== null && gc(l)), a;
  }
  function gc(a) {
    wi === null ? wi = a : wi.push.apply(wi, a);
  }
  function Vh(a) {
    for (var l = a; ; ) {
      if (l.flags & 16384) {
        var m = l.updateQueue;
        if (m !== null && (m = m.stores, m !== null))
          for (var k = 0; k < m.length; k++) {
            var D = m[k], z = D.getSnapshot;
            D = D.value;
            try {
              if (!ha(z(), D))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (m = l.child, l.subtreeFlags & 16384 && m !== null)
        m.return = l, l = m;
      else {
        if (l === a)
          break;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === a)
            return !0;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    }
    return !0;
  }
  function ka(a, l) {
    for (l &= ~ru, l &= ~jd, a.suspendedLanes |= l, a.pingedLanes &= ~l, a = a.expirationTimes; 0 < l; ) {
      var m = 31 - P(l), k = 1 << m;
      a[m] = -1, l &= ~k;
    }
  }
  function Ov(a) {
    if (sn & 6)
      throw Error(h(327));
    lu();
    var l = N(a, 0);
    if (!(l & 1))
      return gi(a, o()), null;
    var m = Vd(a, l);
    if (a.tag !== 0 && m === 2) {
      var k = ee(a);
      k !== 0 && (l = k, m = Xh(a, k));
    }
    if (m === 1)
      throw m = pc, al(a, 0), ka(a, l), gi(a, o()), m;
    if (m === 6)
      throw Error(h(345));
    return a.finishedWork = a.current.alternate, a.finishedLanes = l, sl(a, wi, Ls), gi(a, o()), null;
  }
  function ou(a, l) {
    var m = sn;
    sn |= 1;
    try {
      return a(l);
    } finally {
      sn = m, sn === 0 && (iu = o() + 500, Nr && Ni());
    }
  }
  function vo(a) {
    go !== null && go.tag === 0 && !(sn & 6) && lu();
    var l = sn;
    sn |= 1;
    var m = fi.transition, k = Ie;
    try {
      if (fi.transition = null, Ie = 1, a)
        return a();
    } finally {
      Ie = k, fi.transition = m, sn = l, !(sn & 6) && Ni();
    }
  }
  function Gh() {
    aa = nu.current, Sn(nu);
  }
  function al(a, l) {
    a.finishedWork = null, a.finishedLanes = 0;
    var m = a.timeoutHandle;
    if (m !== -1 && (a.timeoutHandle = -1, sv(m)), lr !== null)
      for (m = lr.return; m !== null; ) {
        var k = m;
        switch (yh(k), k.tag) {
          case 1:
            k = k.type.childContextTypes, k != null && va();
            break;
          case 3:
            uo(), Sn(or), Sn(Wt), md();
            break;
          case 5:
            nn(k);
            break;
          case 4:
            uo();
            break;
          case 13:
            Sn(Ft);
            break;
          case 19:
            Sn(Ft);
            break;
          case 10:
            ao(k.type._context);
            break;
          case 22:
          case 23:
            Gh();
        }
        m = m.return;
      }
    if (Jn = a, lr = a = mo(a.current, null), Fr = aa = l, Rr = 0, pc = null, ru = jd = Rs = 0, wi = tl = null, Wr !== null) {
      for (l = 0; l < Wr.length; l++)
        if (m = Wr[l], k = m.interleaved, k !== null) {
          m.interleaved = null;
          var D = k.next, z = m.pending;
          if (z !== null) {
            var $ = z.next;
            z.next = D, k.next = $;
          }
          m.pending = k;
        }
      Wr = null;
    }
    return a;
  }
  function _v(a, l) {
    do {
      var m = lr;
      try {
        if (Sh(), yd.current = Pd, Yt) {
          for (var k = Xn.memoizedState; k !== null; ) {
            var D = k.queue;
            D !== null && (D.pending = null), k = k.next;
          }
          Yt = !1;
        }
        if (Xo = 0, dn = Pe = Xn = null, Za = !1, ia = 0, Bh.current = null, m === null || m.return === null) {
          Rr = 1, pc = l, lr = null;
          break;
        }
        e: {
          var z = a, $ = m.return, ie = m, ce = l;
          if (l = Fr, ie.flags |= 32768, ce !== null && typeof ce == "object" && typeof ce.then == "function") {
            var Ee = ce, He = ie, Be = He.tag;
            if (!(He.mode & 1) && (Be === 0 || Be === 11 || Be === 15)) {
              var Fe = He.alternate;
              Fe ? (He.updateQueue = Fe.updateQueue, He.memoizedState = Fe.memoizedState, He.lanes = Fe.lanes) : (He.updateQueue = null, He.memoizedState = null);
            }
            var lt = Dh($);
            if (lt !== null) {
              lt.flags &= -257, Oh(lt, $, ie, z, l), lt.mode & 1 && wv(z, Ee, l), l = lt, ce = Ee;
              var xt = l.updateQueue;
              if (xt === null) {
                var Ct = /* @__PURE__ */ new Set();
                Ct.add(ce), l.updateQueue = Ct;
              } else
                xt.add(ce);
              break e;
            } else {
              if (!(l & 1)) {
                wv(z, Ee, l), $h();
                break e;
              }
              ce = Error(h(426));
            }
          } else if (Wn && ie.mode & 1) {
            var hr = Dh($);
            if (hr !== null) {
              !(hr.flags & 65536) && (hr.flags |= 256), Oh(hr, $, ie, z, l), bh(ql(ce, ie));
              break e;
            }
          }
          z = ce = ql(ce, ie), Rr !== 4 && (Rr = 2), tl === null ? tl = [z] : tl.push(z), z = $;
          do {
            switch (z.tag) {
              case 3:
                z.flags |= 65536, l &= -l, z.lanes |= l;
                var me = bv(z, ce, l);
                Ah(z, me);
                break e;
              case 1:
                ie = ce;
                var pe = z.type, Se = z.stateNode;
                if (!(z.flags & 128) && (typeof pe.getDerivedStateFromError == "function" || Se !== null && typeof Se.componentDidCatch == "function" && (Ja === null || !Ja.has(Se)))) {
                  z.flags |= 65536, l &= -l, z.lanes |= l;
                  var $e = sc(z, ie, l);
                  Ah(z, $e);
                  break e;
                }
            }
            z = z.return;
          } while (z !== null);
        }
        qh(m);
      } catch (At) {
        l = At, lr === m && m !== null && (lr = m = m.return);
        continue;
      }
      break;
    } while (1);
  }
  function Xd() {
    var a = hc.current;
    return hc.current = Pd, a === null ? Pd : a;
  }
  function $h() {
    (Rr === 0 || Rr === 3 || Rr === 2) && (Rr = 4), Jn === null || !(Rs & 268435455) && !(jd & 268435455) || ka(Jn, Fr);
  }
  function Vd(a, l) {
    var m = sn;
    sn |= 2;
    var k = Xd();
    (Jn !== a || Fr !== l) && (Ls = null, al(a, l));
    do
      try {
        Nx();
        break;
      } catch (D) {
        _v(a, D);
      }
    while (1);
    if (Sh(), sn = m, hc.current = k, lr !== null)
      throw Error(h(261));
    return Jn = null, Fr = 0, Rr;
  }
  function Nx() {
    for (; lr !== null; )
      Pv(lr);
  }
  function zx() {
    for (; lr !== null && !n(); )
      Pv(lr);
  }
  function Pv(a) {
    var l = zv(a.alternate, a, aa);
    a.memoizedProps = a.pendingProps, l === null ? qh(a) : lr = l, Bh.current = null;
  }
  function qh(a) {
    var l = a;
    do {
      var m = l.alternate;
      if (a = l.return, l.flags & 32768) {
        if (m = Yh(m, l), m !== null) {
          m.flags &= 32767, lr = m;
          return;
        }
        if (a !== null)
          a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
        else {
          Rr = 6, lr = null;
          return;
        }
      } else if (m = Px(m, l, aa), m !== null) {
        lr = m;
        return;
      }
      if (l = l.sibling, l !== null) {
        lr = l;
        return;
      }
      lr = l = a;
    } while (l !== null);
    Rr === 0 && (Rr = 5);
  }
  function sl(a, l, m) {
    var k = Ie, D = fi.transition;
    try {
      fi.transition = null, Ie = 1, Ix(a, l, m, k);
    } finally {
      fi.transition = D, Ie = k;
    }
    return null;
  }
  function Ix(a, l, m, k) {
    do
      lu();
    while (go !== null);
    if (sn & 6)
      throw Error(h(327));
    m = a.finishedWork;
    var D = a.finishedLanes;
    if (m === null)
      return null;
    if (a.finishedWork = null, a.finishedLanes = 0, m === a.current)
      throw Error(h(177));
    a.callbackNode = null, a.callbackPriority = 0;
    var z = m.lanes | m.childLanes;
    if (_e(a, z), a === Jn && (lr = Jn = null, Fr = 0), !(m.subtreeFlags & 2064) && !(m.flags & 2064) || po || (po = !0, Zh(y, function() {
      return lu(), null;
    })), z = (m.flags & 15990) !== 0, m.subtreeFlags & 15990 || z) {
      z = fi.transition, fi.transition = null;
      var $ = Ie;
      Ie = 1;
      var ie = sn;
      sn |= 4, Bh.current = null, Tv(a, m), Rv(m, a), ed(Yo), Po = !!ch, Yo = ch = null, a.current = m, Lv(m), i(), sn = ie, Ie = $, fi.transition = z;
    } else
      a.current = m;
    if (po && (po = !1, go = a, Bd = D), z = a.pendingLanes, z === 0 && (Ja = null), O(m.stateNode), gi(a, o()), l !== null)
      for (k = a.onRecoverableError, m = 0; m < l.length; m++)
        D = l[m], k(D.value, { componentStack: D.stack, digest: D.digest });
    if (Ud)
      throw Ud = !1, a = nl, nl = null, a;
    return Bd & 1 && a.tag !== 0 && lu(), z = a.pendingLanes, z & 1 ? a === Wd ? au++ : (au = 0, Wd = a) : au = 0, Ni(), null;
  }
  function lu() {
    if (go !== null) {
      var a = at(Bd), l = fi.transition, m = Ie;
      try {
        if (fi.transition = null, Ie = 16 > a ? 16 : a, go === null)
          var k = !1;
        else {
          if (a = go, go = null, Bd = 0, sn & 6)
            throw Error(h(331));
          var D = sn;
          for (sn |= 4, gt = a.current; gt !== null; ) {
            var z = gt, $ = z.child;
            if (gt.flags & 16) {
              var ie = z.deletions;
              if (ie !== null) {
                for (var ce = 0; ce < ie.length; ce++) {
                  var Ee = ie[ce];
                  for (gt = Ee; gt !== null; ) {
                    var He = gt;
                    switch (He.tag) {
                      case 0:
                      case 11:
                      case 15:
                        dc(8, He, z);
                    }
                    var Be = He.child;
                    if (Be !== null)
                      Be.return = He, gt = Be;
                    else
                      for (; gt !== null; ) {
                        He = gt;
                        var Fe = He.sibling, lt = He.return;
                        if (jh(He), He === Ee) {
                          gt = null;
                          break;
                        }
                        if (Fe !== null) {
                          Fe.return = lt, gt = Fe;
                          break;
                        }
                        gt = lt;
                      }
                  }
                }
                var xt = z.alternate;
                if (xt !== null) {
                  var Ct = xt.child;
                  if (Ct !== null) {
                    xt.child = null;
                    do {
                      var hr = Ct.sibling;
                      Ct.sibling = null, Ct = hr;
                    } while (Ct !== null);
                  }
                }
                gt = z;
              }
            }
            if (z.subtreeFlags & 2064 && $ !== null)
              $.return = z, gt = $;
            else
              e:
                for (; gt !== null; ) {
                  if (z = gt, z.flags & 2048)
                    switch (z.tag) {
                      case 0:
                      case 11:
                      case 15:
                        dc(9, z, z.return);
                    }
                  var me = z.sibling;
                  if (me !== null) {
                    me.return = z.return, gt = me;
                    break e;
                  }
                  gt = z.return;
                }
          }
          var pe = a.current;
          for (gt = pe; gt !== null; ) {
            $ = gt;
            var Se = $.child;
            if ($.subtreeFlags & 2064 && Se !== null)
              Se.return = $, gt = Se;
            else
              e:
                for ($ = pe; gt !== null; ) {
                  if (ie = gt, ie.flags & 2048)
                    try {
                      switch (ie.tag) {
                        case 0:
                        case 11:
                        case 15:
                          fc(9, ie);
                      }
                    } catch (At) {
                      ur(ie, ie.return, At);
                    }
                  if (ie === $) {
                    gt = null;
                    break e;
                  }
                  var $e = ie.sibling;
                  if ($e !== null) {
                    $e.return = ie.return, gt = $e;
                    break e;
                  }
                  gt = ie.return;
                }
          }
          if (sn = D, Ni(), L && typeof L.onPostCommitFiberRoot == "function")
            try {
              L.onPostCommitFiberRoot(E, a);
            } catch {
            }
          k = !0;
        }
        return k;
      } finally {
        Ie = m, fi.transition = l;
      }
    }
    return !1;
  }
  function Nv(a, l, m) {
    l = ql(m, l), l = bv(a, l, 1), a = oo(a, l, 1), l = hi(), a !== null && (ke(a, 1, l), gi(a, l));
  }
  function ur(a, l, m) {
    if (a.tag === 3)
      Nv(a, a, m);
    else
      for (; l !== null; ) {
        if (l.tag === 3) {
          Nv(l, a, m);
          break;
        } else if (l.tag === 1) {
          var k = l.stateNode;
          if (typeof l.type.getDerivedStateFromError == "function" || typeof k.componentDidCatch == "function" && (Ja === null || !Ja.has(k))) {
            a = ql(m, a), a = sc(l, a, 1), l = oo(l, a, 1), a = hi(), l !== null && (ke(l, 1, a), gi(l, a));
            break;
          }
        }
        l = l.return;
      }
  }
  function Fx(a, l, m) {
    var k = a.pingCache;
    k !== null && k.delete(l), l = hi(), a.pingedLanes |= a.suspendedLanes & m, Jn === a && (Fr & m) === m && (Rr === 4 || Rr === 3 && (Fr & 130023424) === Fr && 500 > o() - Wh ? al(a, 0) : ru |= m), gi(a, l);
  }
  function Gd(a, l) {
    l === 0 && (a.mode & 1 ? (l = b, b <<= 1, !(b & 130023424) && (b = 4194304)) : l = 1);
    var m = hi();
    a = ks(a, l), a !== null && (ke(a, l, m), gi(a, m));
  }
  function Yx(a) {
    var l = a.memoizedState, m = 0;
    l !== null && (m = l.retryLane), Gd(a, m);
  }
  function Hx(a, l) {
    var m = 0;
    switch (a.tag) {
      case 13:
        var k = a.stateNode, D = a.memoizedState;
        D !== null && (m = D.retryLane);
        break;
      case 19:
        k = a.stateNode;
        break;
      default:
        throw Error(h(314));
    }
    k !== null && k.delete(l), Gd(a, m);
  }
  var zv;
  zv = function(a, l, m) {
    if (a !== null)
      if (a.memoizedProps !== l.pendingProps || or.current)
        br = !0;
      else {
        if (!(a.lanes & m) && !(l.flags & 128))
          return br = !1, Ts(a, l, m);
        br = !!(a.flags & 131072);
      }
    else
      br = !1, Wn && l.flags & 1048576 && mh(l, Ul, l.index);
    switch (l.lanes = 0, l.tag) {
      case 2:
        var k = l.type;
        ci(a, l), a = l.pendingProps;
        var D = ga(l, Wt.current);
        nt(l, m), D = co(null, l, k, a, D, m);
        var z = $o();
        return l.flags |= 1, typeof D == "object" && D !== null && typeof D.render == "function" && D.$$typeof === void 0 ? (l.tag = 1, l.memoizedState = null, l.updateQueue = null, qn(k) ? (z = !0, sd(l)) : z = !1, l.memoizedState = D.state !== null && D.state !== void 0 ? D.state : null, Ch(l), D.updater = pd, l.stateNode = D, D._reactInternals = l, gd(l, k, a, m), l = Sv(null, l, k, !0, z, m)) : (l.tag = 0, Wn && z && od(l), Ar(null, l, D, m), l = l.child), l;
      case 16:
        k = l.elementType;
        e: {
          switch (ci(a, l), a = l.pendingProps, D = k._init, k = D(k._payload), l.type = k, D = l.tag = Ux(k), a = ra(k, a), D) {
            case 0:
              l = Zl(null, l, k, a, m);
              break e;
            case 1:
              l = _h(null, l, k, a, m);
              break e;
            case 11:
              l = ho(null, l, k, a, m);
              break e;
            case 14:
              l = zd(null, l, k, ra(k.type, a), m);
              break e;
          }
          throw Error(h(
            306,
            k,
            ""
          ));
        }
        return l;
      case 0:
        return k = l.type, D = l.pendingProps, D = l.elementType === k ? D : ra(k, D), Zl(a, l, k, D, m);
      case 1:
        return k = l.type, D = l.pendingProps, D = l.elementType === k ? D : ra(k, D), _h(a, l, k, D, m);
      case 3:
        e: {
          if (kv(l), a === null)
            throw Error(h(387));
          k = l.pendingProps, z = l.memoizedState, D = z.element, Cr(a, l), lo(l, k, null, m);
          var $ = l.memoizedState;
          if (k = $.element, z.isDehydrated)
            if (z = { element: k, isDehydrated: !1, cache: $.cache, pendingSuspenseBoundaries: $.pendingSuspenseBoundaries, transitions: $.transitions }, l.updateQueue.baseState = z, l.memoizedState = z, l.flags & 256) {
              D = ql(Error(h(423)), l), l = Id(a, l, k, m, D);
              break e;
            } else if (k !== D) {
              D = ql(Error(h(424)), l), l = Id(a, l, k, m, D);
              break e;
            } else
              for (Fi = Ya(l.stateNode.containerInfo.firstChild), na = l, Wn = !0, ya = null, m = yv(l, null, k, m), l.child = m; m; )
                m.flags = m.flags & -3 | 4096, m = m.sibling;
          else {
            if (Qn(), k === D) {
              l = Xr(a, l, m);
              break e;
            }
            Ar(a, l, k, m);
          }
          l = l.child;
        }
        return l;
      case 5:
        return Nt(l), a === null && ud(l), k = l.type, D = l.pendingProps, z = a !== null ? a.memoizedProps : null, $ = D.children, $u(k, D) ? $ = null : z !== null && $u(k, z) && (l.flags |= 32), en(a, l), Ar(a, l, $, m), l.child;
      case 6:
        return a === null && ud(l), null;
      case 13:
        return Nh(a, l, m);
      case 4:
        return Eh(l, l.stateNode.containerInfo), k = l.pendingProps, a === null ? l.child = Wl(l, null, k, m) : Ar(a, l, k, m), l.child;
      case 11:
        return k = l.type, D = l.pendingProps, D = l.elementType === k ? D : ra(k, D), ho(a, l, k, D, m);
      case 7:
        return Ar(a, l, l.pendingProps, m), l.child;
      case 8:
        return Ar(a, l, l.pendingProps.children, m), l.child;
      case 12:
        return Ar(a, l, l.pendingProps.children, m), l.child;
      case 10:
        e: {
          if (k = l.type._context, D = l.pendingProps, z = l.memoizedProps, $ = D.value, An(qa, k._currentValue), k._currentValue = $, z !== null)
            if (ha(z.value, $)) {
              if (z.children === D.children && !or.current) {
                l = Xr(a, l, m);
                break e;
              }
            } else
              for (z = l.child, z !== null && (z.return = l); z !== null; ) {
                var ie = z.dependencies;
                if (ie !== null) {
                  $ = z.child;
                  for (var ce = ie.firstContext; ce !== null; ) {
                    if (ce.context === k) {
                      if (z.tag === 1) {
                        ce = Cs(-1, m & -m), ce.tag = 2;
                        var Ee = z.updateQueue;
                        if (Ee !== null) {
                          Ee = Ee.shared;
                          var He = Ee.pending;
                          He === null ? ce.next = ce : (ce.next = He.next, He.next = ce), Ee.pending = ce;
                        }
                      }
                      z.lanes |= m, ce = z.alternate, ce !== null && (ce.lanes |= m), zr(
                        z.return,
                        m,
                        l
                      ), ie.lanes |= m;
                      break;
                    }
                    ce = ce.next;
                  }
                } else if (z.tag === 10)
                  $ = z.type === l.type ? null : z.child;
                else if (z.tag === 18) {
                  if ($ = z.return, $ === null)
                    throw Error(h(341));
                  $.lanes |= m, ie = $.alternate, ie !== null && (ie.lanes |= m), zr($, m, l), $ = z.sibling;
                } else
                  $ = z.child;
                if ($ !== null)
                  $.return = z;
                else
                  for ($ = z; $ !== null; ) {
                    if ($ === l) {
                      $ = null;
                      break;
                    }
                    if (z = $.sibling, z !== null) {
                      z.return = $.return, $ = z;
                      break;
                    }
                    $ = $.return;
                  }
                z = $;
              }
          Ar(a, l, D.children, m), l = l.child;
        }
        return l;
      case 9:
        return D = l.type, k = l.pendingProps.children, nt(l, m), D = fr(D), k = k(D), l.flags |= 1, Ar(a, l, k, m), l.child;
      case 14:
        return k = l.type, D = ra(k, l.pendingProps), D = ra(k.type, D), zd(a, l, k, D, m);
      case 15:
        return ji(a, l, l.type, l.pendingProps, m);
      case 17:
        return k = l.type, D = l.pendingProps, D = l.elementType === k ? D : ra(k, D), ci(a, l), l.tag = 1, qn(k) ? (a = !0, sd(l)) : a = !1, nt(l, m), pv(l, k, D), gd(l, k, D, m), Sv(null, l, k, !0, a, m);
      case 19:
        return Fh(a, l, m);
      case 22:
        return Ko(a, l, m);
    }
    throw Error(h(156, l.tag));
  };
  function Zh(a, l) {
    return B(a, l);
  }
  function jx(a, l, m, k) {
    this.tag = a, this.key = m, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = k, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Ca(a, l, m, k) {
    return new jx(a, l, m, k);
  }
  function Qh(a) {
    return a = a.prototype, !(!a || !a.isReactComponent);
  }
  function Ux(a) {
    if (typeof a == "function")
      return Qh(a) ? 1 : 0;
    if (a != null) {
      if (a = a.$$typeof, a === dt)
        return 11;
      if (a === Vt)
        return 14;
    }
    return 2;
  }
  function mo(a, l) {
    var m = a.alternate;
    return m === null ? (m = Ca(a.tag, l, a.key, a.mode), m.elementType = a.elementType, m.type = a.type, m.stateNode = a.stateNode, m.alternate = a, a.alternate = m) : (m.pendingProps = l, m.type = a.type, m.flags = 0, m.subtreeFlags = 0, m.deletions = null), m.flags = a.flags & 14680064, m.childLanes = a.childLanes, m.lanes = a.lanes, m.child = a.child, m.memoizedProps = a.memoizedProps, m.memoizedState = a.memoizedState, m.updateQueue = a.updateQueue, l = a.dependencies, m.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }, m.sibling = a.sibling, m.index = a.index, m.ref = a.ref, m;
  }
  function $d(a, l, m, k, D, z) {
    var $ = 2;
    if (k = a, typeof a == "function")
      Qh(a) && ($ = 1);
    else if (typeof a == "string")
      $ = 5;
    else
      e:
        switch (a) {
          case Me:
            return ol(m.children, D, z, l);
          case et:
            $ = 8, D |= 8;
            break;
          case je:
            return a = Ca(12, m, l, D | 2), a.elementType = je, a.lanes = z, a;
          case Ke:
            return a = Ca(13, m, l, D), a.elementType = Ke, a.lanes = z, a;
          case Ze:
            return a = Ca(19, m, l, D), a.elementType = Ze, a.lanes = z, a;
          case an:
            return vc(m, D, z, l);
          default:
            if (typeof a == "object" && a !== null)
              switch (a.$$typeof) {
                case Ve:
                  $ = 10;
                  break e;
                case it:
                  $ = 9;
                  break e;
                case dt:
                  $ = 11;
                  break e;
                case Vt:
                  $ = 14;
                  break e;
                case Et:
                  $ = 16, k = null;
                  break e;
              }
            throw Error(h(130, a == null ? a : typeof a, ""));
        }
    return l = Ca($, m, l, D), l.elementType = a, l.type = k, l.lanes = z, l;
  }
  function ol(a, l, m, k) {
    return a = Ca(7, a, k, l), a.lanes = m, a;
  }
  function vc(a, l, m, k) {
    return a = Ca(22, a, k, l), a.elementType = an, a.lanes = m, a.stateNode = { isHidden: !1 }, a;
  }
  function mc(a, l, m) {
    return a = Ca(6, a, null, l), a.lanes = m, a;
  }
  function ll(a, l, m) {
    return l = Ca(4, a.children !== null ? a.children : [], a.key, l), l.lanes = m, l.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation }, l;
  }
  function Bx(a, l, m, k, D) {
    this.tag = l, this.containerInfo = a, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = fe(0), this.expirationTimes = fe(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = fe(0), this.identifierPrefix = k, this.onRecoverableError = D, this.mutableSourceEagerHydrationData = null;
  }
  function qd(a, l, m, k, D, z, $, ie, ce) {
    return a = new Bx(a, l, m, ie, ce), l === 1 ? (l = 1, z === !0 && (l |= 8)) : l = 0, z = Ca(3, null, null, l), a.current = z, z.stateNode = a, z.memoizedState = { element: k, isDehydrated: m, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Ch(z), a;
  }
  function Iv(a, l, m) {
    var k = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: ve, key: k == null ? null : "" + k, children: a, containerInfo: l, implementation: m };
  }
  function Kh(a) {
    if (!a)
      return $a;
    a = a._reactInternals;
    e: {
      if (qt(a) !== a || a.tag !== 1)
        throw Error(h(170));
      var l = a;
      do {
        switch (l.tag) {
          case 3:
            l = l.stateNode.context;
            break e;
          case 1:
            if (qn(l.type)) {
              l = l.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        l = l.return;
      } while (l !== null);
      throw Error(h(171));
    }
    if (a.tag === 1) {
      var m = a.type;
      if (qn(m))
        return Qu(a, m, l);
    }
    return l;
  }
  function Fv(a, l, m, k, D, z, $, ie, ce) {
    return a = qd(m, k, !0, a, D, z, $, ie, ce), a.context = Kh(null), m = a.current, k = hi(), D = wr(m), z = Cs(k, D), z.callback = l ?? null, oo(m, z, D), a.current.lanes = D, ke(a, D, k), gi(a, k), a;
  }
  function yc(a, l, m, k) {
    var D = l.current, z = hi(), $ = wr(D);
    return m = Kh(m), l.context === null ? l.context = m : l.pendingContext = m, l = Cs(z, $), l.payload = { element: a }, k = k === void 0 ? null : k, k !== null && (l.callback = k), a = oo(D, l, $), a !== null && (pi(a, D, $, z), hd(a, D, $)), $;
  }
  function Zd(a) {
    if (a = a.current, !a.child)
      return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function Yv(a, l) {
    if (a = a.memoizedState, a !== null && a.dehydrated !== null) {
      var m = a.retryLane;
      a.retryLane = m !== 0 && m < l ? m : l;
    }
  }
  function Jh(a, l) {
    Yv(a, l), (a = a.alternate) && Yv(a, l);
  }
  function Hv() {
    return null;
  }
  var ep = typeof reportError == "function" ? reportError : function(a) {
    console.error(a);
  };
  function Qd(a) {
    this._internalRoot = a;
  }
  Ms.prototype.render = Qd.prototype.render = function(a) {
    var l = this._internalRoot;
    if (l === null)
      throw Error(h(409));
    yc(a, l, null, null);
  }, Ms.prototype.unmount = Qd.prototype.unmount = function() {
    var a = this._internalRoot;
    if (a !== null) {
      this._internalRoot = null;
      var l = a.containerInfo;
      vo(function() {
        yc(null, a, null, null);
      }), l[ws] = null;
    }
  };
  function Ms(a) {
    this._internalRoot = a;
  }
  Ms.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var l = Mn();
      a = { blockedOn: null, target: a, priority: l };
      for (var m = 0; m < wn.length && l !== 0 && l < wn[m].priority; m++)
        ;
      wn.splice(m, 0, a), m === 0 && Ag(a);
    }
  };
  function tp(a) {
    return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11);
  }
  function Kd(a) {
    return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11 && (a.nodeType !== 8 || a.nodeValue !== " react-mount-point-unstable "));
  }
  function jv() {
  }
  function Wx(a, l, m, k, D) {
    if (D) {
      if (typeof k == "function") {
        var z = k;
        k = function() {
          var Ee = Zd($);
          z.call(Ee);
        };
      }
      var $ = Fv(l, k, a, 0, null, !1, !1, "", jv);
      return a._reactRootContainer = $, a[ws] = $.current, Hl(a.nodeType === 8 ? a.parentNode : a), vo(), $;
    }
    for (; D = a.lastChild; )
      a.removeChild(D);
    if (typeof k == "function") {
      var ie = k;
      k = function() {
        var Ee = Zd(ce);
        ie.call(Ee);
      };
    }
    var ce = qd(a, 0, !1, null, null, !1, !1, "", jv);
    return a._reactRootContainer = ce, a[ws] = ce.current, Hl(a.nodeType === 8 ? a.parentNode : a), vo(function() {
      yc(l, ce, m, k);
    }), ce;
  }
  function Jd(a, l, m, k, D) {
    var z = m._reactRootContainer;
    if (z) {
      var $ = z;
      if (typeof D == "function") {
        var ie = D;
        D = function() {
          var ce = Zd($);
          ie.call(ce);
        };
      }
      yc(l, $, a, D);
    } else
      $ = Wx(m, l, a, D, k);
    return Zd($);
  }
  Qt = function(a) {
    switch (a.tag) {
      case 3:
        var l = a.stateNode;
        if (l.current.memoizedState.isDehydrated) {
          var m = M(l.pendingLanes);
          m !== 0 && (Le(l, m | 1), gi(l, o()), !(sn & 6) && (iu = o() + 500, Ni()));
        }
        break;
      case 13:
        vo(function() {
          var k = ks(a, 1);
          if (k !== null) {
            var D = hi();
            pi(k, a, 1, D);
          }
        }), Jh(a, 1);
    }
  }, Kt = function(a) {
    if (a.tag === 13) {
      var l = ks(a, 134217728);
      if (l !== null) {
        var m = hi();
        pi(l, a, 134217728, m);
      }
      Jh(a, 134217728);
    }
  }, yt = function(a) {
    if (a.tag === 13) {
      var l = wr(a), m = ks(a, l);
      if (m !== null) {
        var k = hi();
        pi(m, a, l, k);
      }
      Jh(a, l);
    }
  }, Mn = function() {
    return Ie;
  }, zn = function(a, l) {
    var m = Ie;
    try {
      return Ie = a, l();
    } finally {
      Ie = m;
    }
  }, mr = function(a, l, m) {
    switch (l) {
      case "input":
        if (Or(a, m), l = m.name, m.type === "radio" && l != null) {
          for (m = a; m.parentNode; )
            m = m.parentNode;
          for (m = m.querySelectorAll("input[name=" + JSON.stringify("" + l) + '][type="radio"]'), l = 0; l < m.length; l++) {
            var k = m[l];
            if (k !== a && k.form === a.form) {
              var D = _t(k);
              if (!D)
                throw Error(h(90));
              qe(k), Or(k, D);
            }
          }
        }
        break;
      case "textarea":
        fa(a, m);
        break;
      case "select":
        l = m.value, l != null && da(a, !!m.multiple, l, !1);
    }
  }, Vs = ou, Ml = vo;
  var Xx = { usingClientEntryPoint: !1, Events: [Zu, jl, _t, ds, fs, ou] }, uu = { findFiberByHostInstance: pa, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, Vx = { bundleType: uu.bundleType, version: uu.version, rendererPackageName: uu.rendererPackageName, rendererConfig: uu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Re.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
    return a = sr(a), a === null ? null : a.stateNode;
  }, findFiberByHostInstance: uu.findFiberByHostInstance || Hv, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var ef = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!ef.isDisabled && ef.supportsFiber)
      try {
        E = ef.inject(Vx), L = ef;
      } catch {
      }
  }
  return Ma.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Xx, Ma.createPortal = function(a, l) {
    var m = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!tp(l))
      throw Error(h(200));
    return Iv(a, l, null, m);
  }, Ma.createRoot = function(a, l) {
    if (!tp(a))
      throw Error(h(299));
    var m = !1, k = "", D = ep;
    return l != null && (l.unstable_strictMode === !0 && (m = !0), l.identifierPrefix !== void 0 && (k = l.identifierPrefix), l.onRecoverableError !== void 0 && (D = l.onRecoverableError)), l = qd(a, 1, !1, null, null, m, !1, k, D), a[ws] = l.current, Hl(a.nodeType === 8 ? a.parentNode : a), new Qd(l);
  }, Ma.findDOMNode = function(a) {
    if (a == null)
      return null;
    if (a.nodeType === 1)
      return a;
    var l = a._reactInternals;
    if (l === void 0)
      throw typeof a.render == "function" ? Error(h(188)) : (a = Object.keys(a).join(","), Error(h(268, a)));
    return a = sr(l), a = a === null ? null : a.stateNode, a;
  }, Ma.flushSync = function(a) {
    return vo(a);
  }, Ma.hydrate = function(a, l, m) {
    if (!Kd(l))
      throw Error(h(200));
    return Jd(null, a, l, !0, m);
  }, Ma.hydrateRoot = function(a, l, m) {
    if (!tp(a))
      throw Error(h(405));
    var k = m != null && m.hydratedSources || null, D = !1, z = "", $ = ep;
    if (m != null && (m.unstable_strictMode === !0 && (D = !0), m.identifierPrefix !== void 0 && (z = m.identifierPrefix), m.onRecoverableError !== void 0 && ($ = m.onRecoverableError)), l = Fv(l, null, a, 1, m ?? null, D, !1, z, $), a[ws] = l.current, Hl(a), k)
      for (a = 0; a < k.length; a++)
        m = k[a], D = m._getVersion, D = D(m._source), l.mutableSourceEagerHydrationData == null ? l.mutableSourceEagerHydrationData = [m, D] : l.mutableSourceEagerHydrationData.push(
          m,
          D
        );
    return new Ms(l);
  }, Ma.render = function(a, l, m) {
    if (!Kd(l))
      throw Error(h(200));
    return Jd(null, a, l, !1, m);
  }, Ma.unmountComponentAtNode = function(a) {
    if (!Kd(a))
      throw Error(h(40));
    return a._reactRootContainer ? (vo(function() {
      Jd(null, null, a, !1, function() {
        a._reactRootContainer = null, a[ws] = null;
      });
    }), !0) : !1;
  }, Ma.unstable_batchedUpdates = ou, Ma.unstable_renderSubtreeIntoContainer = function(a, l, m, k) {
    if (!Kd(m))
      throw Error(h(200));
    if (a == null || a._reactInternals === void 0)
      throw Error(h(38));
    return Jd(a, l, m, !1, k);
  }, Ma.version = "18.2.0-next-9e3b772b8-20220608", Ma;
}
var Da = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var MT;
function jY() {
  return MT || (MT = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var s = mi, u = wR(), h = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, v = !1;
    function w(e) {
      v = e;
    }
    function C(e) {
      if (!v) {
        for (var r = arguments.length, c = new Array(r > 1 ? r - 1 : 0), g = 1; g < r; g++)
          c[g - 1] = arguments[g];
        F("warn", e, c);
      }
    }
    function T(e) {
      if (!v) {
        for (var r = arguments.length, c = new Array(r > 1 ? r - 1 : 0), g = 1; g < r; g++)
          c[g - 1] = arguments[g];
        F("error", e, c);
      }
    }
    function F(e, r, c) {
      {
        var g = h.ReactDebugCurrentFrame, x = g.getStackAddendum();
        x !== "" && (r += "%s", c = c.concat([x]));
        var R = c.map(function(_) {
          return String(_);
        });
        R.unshift("Warning: " + r), Function.prototype.apply.call(console[e], console, R);
      }
    }
    var Y = 0, U = 1, G = 2, q = 3, te = 4, se = 5, ae = 6, ue = 7, Ce = 8, Ne = 9, K = 10, we = 11, Re = 12, re = 13, ve = 14, Me = 15, et = 16, je = 17, Ve = 18, it = 19, dt = 21, Ke = 22, Ze = 23, Vt = 24, Et = 25, an = !0, We = !1, ft = !1, ye = !1, Ue = !1, Qe = !0, St = !1, kt = !1, Ht = !0, ot = !0, It = !0, Rt = /* @__PURE__ */ new Set(), jt = {}, Ut = {};
    function vn(e, r) {
      qe(e, r), qe(e + "Capture", r);
    }
    function qe(e, r) {
      jt[e] && T("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", e), jt[e] = r;
      {
        var c = e.toLowerCase();
        Ut[c] = e, e === "onDoubleClick" && (Ut.ondblclick = e);
      }
      for (var g = 0; g < r.length; g++)
        Rt.add(r[g]);
    }
    var pn = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", jn = Object.prototype.hasOwnProperty;
    function ir(e) {
      {
        var r = typeof Symbol == "function" && Symbol.toStringTag, c = r && e[Symbol.toStringTag] || e.constructor.name || "Object";
        return c;
      }
    }
    function Dr(e) {
      try {
        return Or(e), !1;
      } catch {
        return !0;
      }
    }
    function Or(e) {
      return "" + e;
    }
    function ti(e, r) {
      if (Dr(e))
        return T("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", r, ir(e)), Or(e);
    }
    function Zi(e) {
      if (Dr(e))
        return T("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ir(e)), Or(e);
    }
    function _a(e, r) {
      if (Dr(e))
        return T("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", r, ir(e)), Or(e);
    }
    function da(e, r) {
      if (Dr(e))
        return T("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", r, ir(e)), Or(e);
    }
    function Qi(e) {
      if (Dr(e))
        return T("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", ir(e)), Or(e);
    }
    function yi(e) {
      if (Dr(e))
        return T("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", ir(e)), Or(e);
    }
    var fa = 0, xi = 1, ni = 2, ar = 3, ri = 4, Pa = 5, Ki = 6, Je = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Lt = Je + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", tn = new RegExp("^[" + Je + "][" + Lt + "]*$"), bn = {}, Un = {};
    function vr(e) {
      return jn.call(Un, e) ? !0 : jn.call(bn, e) ? !1 : tn.test(e) ? (Un[e] = !0, !0) : (bn[e] = !0, T("Invalid attribute name: `%s`", e), !1);
    }
    function $n(e, r, c) {
      return r !== null ? r.type === fa : c ? !1 : e.length > 2 && (e[0] === "o" || e[0] === "O") && (e[1] === "n" || e[1] === "N");
    }
    function ii(e, r, c, g) {
      if (c !== null && c.type === fa)
        return !1;
      switch (typeof r) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (g)
            return !1;
          if (c !== null)
            return !c.acceptsBooleans;
          var x = e.toLowerCase().slice(0, 5);
          return x !== "data-" && x !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Ln(e, r, c, g) {
      if (r === null || typeof r > "u" || ii(e, r, c, g))
        return !0;
      if (g)
        return !1;
      if (c !== null)
        switch (c.type) {
          case ar:
            return !r;
          case ri:
            return r === !1;
          case Pa:
            return isNaN(r);
          case Ki:
            return isNaN(r) || r < 1;
        }
      return !1;
    }
    function mr(e) {
      return Cn.hasOwnProperty(e) ? Cn[e] : null;
    }
    function kn(e, r, c, g, x, R, _) {
      this.acceptsBooleans = r === ni || r === ar || r === ri, this.attributeName = g, this.attributeNamespace = x, this.mustUseProperty = c, this.propertyName = e, this.type = r, this.sanitizeURL = R, this.removeEmptyString = _;
    }
    var Cn = {}, cs = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    cs.forEach(function(e) {
      Cn[e] = new kn(
        e,
        fa,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(e) {
      var r = e[0], c = e[1];
      Cn[r] = new kn(
        r,
        xi,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
      Cn[e] = new kn(
        e,
        ni,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
      Cn[e] = new kn(
        e,
        ni,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(e) {
      Cn[e] = new kn(
        e,
        ar,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      Cn[e] = new kn(
        e,
        ar,
        !0,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      Cn[e] = new kn(
        e,
        ri,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      Cn[e] = new kn(
        e,
        Ki,
        !1,
        // mustUseProperty
        e,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(e) {
      Cn[e] = new kn(
        e,
        Pa,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var ds = /[\-\:]([a-z])/g, fs = function(e) {
      return e[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var r = e.replace(ds, fs);
      Cn[r] = new kn(
        r,
        xi,
        !1,
        // mustUseProperty
        e,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var r = e.replace(ds, fs);
      Cn[r] = new kn(
        r,
        xi,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(e) {
      var r = e.replace(ds, fs);
      Cn[r] = new kn(
        r,
        xi,
        !1,
        // mustUseProperty
        e,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(e) {
      Cn[e] = new kn(
        e,
        xi,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Vs = "xlinkHref";
    Cn[Vs] = new kn(
      "xlinkHref",
      xi,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(e) {
      Cn[e] = new kn(
        e,
        xi,
        !1,
        // mustUseProperty
        e.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var Ml = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, hs = !1;
    function Gs(e) {
      !hs && Ml.test(e) && (hs = !0, T("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(e)));
    }
    function ps(e, r, c, g) {
      if (g.mustUseProperty) {
        var x = g.propertyName;
        return e[x];
      } else {
        ti(c, r), g.sanitizeURL && Gs("" + c);
        var R = g.attributeName, _ = null;
        if (g.type === ri) {
          if (e.hasAttribute(R)) {
            var H = e.getAttribute(R);
            return H === "" ? !0 : Ln(r, c, g, !1) ? H : H === "" + c ? c : H;
          }
        } else if (e.hasAttribute(R)) {
          if (Ln(r, c, g, !1))
            return e.getAttribute(R);
          if (g.type === ar)
            return c;
          _ = e.getAttribute(R);
        }
        return Ln(r, c, g, !1) ? _ === null ? c : _ : _ === "" + c ? c : _;
      }
    }
    function $s(e, r, c, g) {
      {
        if (!vr(r))
          return;
        if (!e.hasAttribute(r))
          return c === void 0 ? void 0 : null;
        var x = e.getAttribute(r);
        return ti(c, r), x === "" + c ? c : x;
      }
    }
    function Oi(e, r, c, g) {
      var x = mr(r);
      if (!$n(r, x, g)) {
        if (Ln(r, c, x, g) && (c = null), g || x === null) {
          if (vr(r)) {
            var R = r;
            c === null ? e.removeAttribute(R) : (ti(c, r), e.setAttribute(R, "" + c));
          }
          return;
        }
        var _ = x.mustUseProperty;
        if (_) {
          var H = x.propertyName;
          if (c === null) {
            var W = x.type;
            e[H] = W === ar ? !1 : "";
          } else
            e[H] = c;
          return;
        }
        var J = x.attributeName, ne = x.attributeNamespace;
        if (c === null)
          e.removeAttribute(J);
        else {
          var ge = x.type, he;
          ge === ar || ge === ri && c === !0 ? he = "" : (ti(c, J), he = "" + c, x.sanitizeURL && Gs(he.toString())), ne ? e.setAttributeNS(ne, J, he) : e.setAttribute(J, he);
        }
      }
    }
    var Na = Symbol.for("react.element"), jr = Symbol.for("react.portal"), bi = Symbol.for("react.fragment"), ai = Symbol.for("react.strict_mode"), le = Symbol.for("react.profiler"), Ye = Symbol.for("react.provider"), tt = Symbol.for("react.context"), Dt = Symbol.for("react.forward_ref"), qt = Symbol.for("react.suspense"), cn = Symbol.for("react.suspense_list"), Zt = Symbol.for("react.memo"), Ot = Symbol.for("react.lazy"), sr = Symbol.for("react.scope"), Yn = Symbol.for("react.debug_trace_mode"), B = Symbol.for("react.offscreen"), t = Symbol.for("react.legacy_hidden"), n = Symbol.for("react.cache"), i = Symbol.for("react.tracing_marker"), o = Symbol.iterator, d = "@@iterator";
    function f(e) {
      if (e === null || typeof e != "object")
        return null;
      var r = o && e[o] || e[d];
      return typeof r == "function" ? r : null;
    }
    var p = Object.assign, y = 0, S, A, E, L, O, P, I;
    function j() {
    }
    j.__reactDisabledLog = !0;
    function V() {
      {
        if (y === 0) {
          S = console.log, A = console.info, E = console.warn, L = console.error, O = console.group, P = console.groupCollapsed, I = console.groupEnd;
          var e = {
            configurable: !0,
            enumerable: !0,
            value: j,
            writable: !0
          };
          Object.defineProperties(console, {
            info: e,
            log: e,
            warn: e,
            error: e,
            group: e,
            groupCollapsed: e,
            groupEnd: e
          });
        }
        y++;
      }
    }
    function Z() {
      {
        if (y--, y === 0) {
          var e = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: p({}, e, {
              value: S
            }),
            info: p({}, e, {
              value: A
            }),
            warn: p({}, e, {
              value: E
            }),
            error: p({}, e, {
              value: L
            }),
            group: p({}, e, {
              value: O
            }),
            groupCollapsed: p({}, e, {
              value: P
            }),
            groupEnd: p({}, e, {
              value: I
            })
          });
        }
        y < 0 && T("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var b = h.ReactCurrentDispatcher, M;
    function N(e, r, c) {
      {
        if (M === void 0)
          try {
            throw Error();
          } catch (x) {
            var g = x.stack.trim().match(/\n( *(at )?)/);
            M = g && g[1] || "";
          }
        return `
` + M + e;
      }
    }
    var X = !1, Q;
    {
      var ee = typeof WeakMap == "function" ? WeakMap : Map;
      Q = new ee();
    }
    function oe(e, r) {
      if (!e || X)
        return "";
      {
        var c = Q.get(e);
        if (c !== void 0)
          return c;
      }
      var g;
      X = !0;
      var x = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var R;
      R = b.current, b.current = null, V();
      try {
        if (r) {
          var _ = function() {
            throw Error();
          };
          if (Object.defineProperty(_.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(_, []);
            } catch (Te) {
              g = Te;
            }
            Reflect.construct(e, [], _);
          } else {
            try {
              _.call();
            } catch (Te) {
              g = Te;
            }
            e.call(_.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Te) {
            g = Te;
          }
          e();
        }
      } catch (Te) {
        if (Te && g && typeof Te.stack == "string") {
          for (var H = Te.stack.split(`
`), W = g.stack.split(`
`), J = H.length - 1, ne = W.length - 1; J >= 1 && ne >= 0 && H[J] !== W[ne]; )
            ne--;
          for (; J >= 1 && ne >= 0; J--, ne--)
            if (H[J] !== W[ne]) {
              if (J !== 1 || ne !== 1)
                do
                  if (J--, ne--, ne < 0 || H[J] !== W[ne]) {
                    var ge = `
` + H[J].replace(" at new ", " at ");
                    return e.displayName && ge.includes("<anonymous>") && (ge = ge.replace("<anonymous>", e.displayName)), typeof e == "function" && Q.set(e, ge), ge;
                  }
                while (J >= 1 && ne >= 0);
              break;
            }
        }
      } finally {
        X = !1, b.current = R, Z(), Error.prepareStackTrace = x;
      }
      var he = e ? e.displayName || e.name : "", Ae = he ? N(he) : "";
      return typeof e == "function" && Q.set(e, Ae), Ae;
    }
    function fe(e, r, c) {
      return oe(e, !0);
    }
    function ke(e, r, c) {
      return oe(e, !1);
    }
    function _e(e) {
      var r = e.prototype;
      return !!(r && r.isReactComponent);
    }
    function Le(e, r, c) {
      if (e == null)
        return "";
      if (typeof e == "function")
        return oe(e, _e(e));
      if (typeof e == "string")
        return N(e);
      switch (e) {
        case qt:
          return N("Suspense");
        case cn:
          return N("SuspenseList");
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case Dt:
            return ke(e.render);
          case Zt:
            return Le(e.type, r, c);
          case Ot: {
            var g = e, x = g._payload, R = g._init;
            try {
              return Le(R(x), r, c);
            } catch {
            }
          }
        }
      return "";
    }
    function Ie(e) {
      switch (e._debugOwner && e._debugOwner.type, e._debugSource, e.tag) {
        case se:
          return N(e.type);
        case et:
          return N("Lazy");
        case re:
          return N("Suspense");
        case it:
          return N("SuspenseList");
        case Y:
        case G:
        case Me:
          return ke(e.type);
        case we:
          return ke(e.type.render);
        case U:
          return fe(e.type);
        default:
          return "";
      }
    }
    function at(e) {
      try {
        var r = "", c = e;
        do
          r += Ie(c), c = c.return;
        while (c);
        return r;
      } catch (g) {
        return `
Error generating stack: ` + g.message + `
` + g.stack;
      }
    }
    function Qt(e, r, c) {
      var g = e.displayName;
      if (g)
        return g;
      var x = r.displayName || r.name || "";
      return x !== "" ? c + "(" + x + ")" : c;
    }
    function Kt(e) {
      return e.displayName || "Context";
    }
    function yt(e) {
      if (e == null)
        return null;
      if (typeof e.tag == "number" && T("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof e == "function")
        return e.displayName || e.name || null;
      if (typeof e == "string")
        return e;
      switch (e) {
        case bi:
          return "Fragment";
        case jr:
          return "Portal";
        case le:
          return "Profiler";
        case ai:
          return "StrictMode";
        case qt:
          return "Suspense";
        case cn:
          return "SuspenseList";
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case tt:
            var r = e;
            return Kt(r) + ".Consumer";
          case Ye:
            var c = e;
            return Kt(c._context) + ".Provider";
          case Dt:
            return Qt(e, e.render, "ForwardRef");
          case Zt:
            var g = e.displayName || null;
            return g !== null ? g : yt(e.type) || "Memo";
          case Ot: {
            var x = e, R = x._payload, _ = x._init;
            try {
              return yt(_(R));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Mn(e, r, c) {
      var g = r.displayName || r.name || "";
      return e.displayName || (g !== "" ? c + "(" + g + ")" : c);
    }
    function zn(e) {
      return e.displayName || "Context";
    }
    function vt(e) {
      var r = e.tag, c = e.type;
      switch (r) {
        case Vt:
          return "Cache";
        case Ne:
          var g = c;
          return zn(g) + ".Consumer";
        case K:
          var x = c;
          return zn(x._context) + ".Provider";
        case Ve:
          return "DehydratedFragment";
        case we:
          return Mn(c, c.render, "ForwardRef");
        case ue:
          return "Fragment";
        case se:
          return c;
        case te:
          return "Portal";
        case q:
          return "Root";
        case ae:
          return "Text";
        case et:
          return yt(c);
        case Ce:
          return c === ai ? "StrictMode" : "Mode";
        case Ke:
          return "Offscreen";
        case Re:
          return "Profiler";
        case dt:
          return "Scope";
        case re:
          return "Suspense";
        case it:
          return "SuspenseList";
        case Et:
          return "TracingMarker";
        case U:
        case Y:
        case je:
        case G:
        case ve:
        case Me:
          if (typeof c == "function")
            return c.displayName || c.name || null;
          if (typeof c == "string")
            return c;
          break;
      }
      return null;
    }
    var Ur = h.ReactDebugCurrentFrame, Dn = null, si = !1;
    function oi() {
      {
        if (Dn === null)
          return null;
        var e = Dn._debugOwner;
        if (e !== null && typeof e < "u")
          return vt(e);
      }
      return null;
    }
    function yr() {
      return Dn === null ? "" : at(Dn);
    }
    function ln() {
      Ur.getCurrentStack = null, Dn = null, si = !1;
    }
    function wn(e) {
      Ur.getCurrentStack = e === null ? null : yr, Dn = e, si = !1;
    }
    function cx() {
      return Dn;
    }
    function za(e) {
      si = e;
    }
    function li(e) {
      return "" + e;
    }
    function qs(e) {
      switch (typeof e) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return e;
        case "object":
          return yi(e), e;
        default:
          return "";
      }
    }
    var Ag = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Dl(e, r) {
      Ag[r.type] || r.onChange || r.onInput || r.readOnly || r.disabled || r.value == null || T("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), r.onChange || r.readOnly || r.disabled || r.checked == null || T("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Bf(e) {
      var r = e.type, c = e.nodeName;
      return c && c.toLowerCase() === "input" && (r === "checkbox" || r === "radio");
    }
    function Tg(e) {
      return e._valueTracker;
    }
    function _u(e) {
      e._valueTracker = null;
    }
    function Pu(e) {
      var r = "";
      return e && (Bf(e) ? r = e.checked ? "true" : "false" : r = e.value), r;
    }
    function Ol(e) {
      var r = Bf(e) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(e.constructor.prototype, r);
      yi(e[r]);
      var g = "" + e[r];
      if (!(e.hasOwnProperty(r) || typeof c > "u" || typeof c.get != "function" || typeof c.set != "function")) {
        var x = c.get, R = c.set;
        Object.defineProperty(e, r, {
          configurable: !0,
          get: function() {
            return x.call(this);
          },
          set: function(H) {
            yi(H), g = "" + H, R.call(this, H);
          }
        }), Object.defineProperty(e, r, {
          enumerable: c.enumerable
        });
        var _ = {
          getValue: function() {
            return g;
          },
          setValue: function(H) {
            yi(H), g = "" + H;
          },
          stopTracking: function() {
            _u(e), delete e[r];
          }
        };
        return _;
      }
    }
    function Po(e) {
      Tg(e) || (e._valueTracker = Ol(e));
    }
    function Eg(e) {
      if (!e)
        return !1;
      var r = Tg(e);
      if (!r)
        return !0;
      var c = r.getValue(), g = Pu(e);
      return g !== c ? (r.setValue(g), !0) : !1;
    }
    function Bc(e) {
      if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u")
        return null;
      try {
        return e.activeElement || e.body;
      } catch {
        return e.body;
      }
    }
    var Wc = !1, Nu = !1, Xc = !1, Wf = !1;
    function gs(e) {
      var r = e.type === "checkbox" || e.type === "radio";
      return r ? e.checked != null : e.value != null;
    }
    function zu(e, r) {
      var c = e, g = r.checked, x = p({}, r, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: g ?? c._wrapperState.initialChecked
      });
      return x;
    }
    function Iu(e, r) {
      Dl("input", r), r.checked !== void 0 && r.defaultChecked !== void 0 && !Nu && (T("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", oi() || "A component", r.type), Nu = !0), r.value !== void 0 && r.defaultValue !== void 0 && !Wc && (T("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", oi() || "A component", r.type), Wc = !0);
      var c = e, g = r.defaultValue == null ? "" : r.defaultValue;
      c._wrapperState = {
        initialChecked: r.checked != null ? r.checked : r.defaultChecked,
        initialValue: qs(r.value != null ? r.value : g),
        controlled: gs(r)
      };
    }
    function Xf(e, r) {
      var c = e, g = r.checked;
      g != null && Oi(c, "checked", g, !1);
    }
    function _l(e, r) {
      var c = e;
      {
        var g = gs(r);
        !c._wrapperState.controlled && g && !Wf && (T("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Wf = !0), c._wrapperState.controlled && !g && !Xc && (T("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Xc = !0);
      }
      Xf(e, r);
      var x = qs(r.value), R = r.type;
      if (x != null)
        R === "number" ? (x === 0 && c.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        c.value != x) && (c.value = li(x)) : c.value !== li(x) && (c.value = li(x));
      else if (R === "submit" || R === "reset") {
        c.removeAttribute("value");
        return;
      }
      r.hasOwnProperty("value") ? Zs(c, r.type, x) : r.hasOwnProperty("defaultValue") && Zs(c, r.type, qs(r.defaultValue)), r.checked == null && r.defaultChecked != null && (c.defaultChecked = !!r.defaultChecked);
    }
    function Fu(e, r, c) {
      var g = e;
      if (r.hasOwnProperty("value") || r.hasOwnProperty("defaultValue")) {
        var x = r.type, R = x === "submit" || x === "reset";
        if (R && (r.value === void 0 || r.value === null))
          return;
        var _ = li(g._wrapperState.initialValue);
        c || _ !== g.value && (g.value = _), g.defaultValue = _;
      }
      var H = g.name;
      H !== "" && (g.name = ""), g.defaultChecked = !g.defaultChecked, g.defaultChecked = !!g._wrapperState.initialChecked, H !== "" && (g.name = H);
    }
    function Rg(e, r) {
      var c = e;
      _l(c, r), Ji(c, r);
    }
    function Ji(e, r) {
      var c = r.name;
      if (r.type === "radio" && c != null) {
        for (var g = e; g.parentNode; )
          g = g.parentNode;
        ti(c, "name");
        for (var x = g.querySelectorAll("input[name=" + JSON.stringify("" + c) + '][type="radio"]'), R = 0; R < x.length; R++) {
          var _ = x[R];
          if (!(_ === e || _.form !== e.form)) {
            var H = im(_);
            if (!H)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            Eg(_), _l(_, H);
          }
        }
      }
    }
    function Zs(e, r, c) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (r !== "number" || Bc(e.ownerDocument) !== e) && (c == null ? e.defaultValue = li(e._wrapperState.initialValue) : e.defaultValue !== li(c) && (e.defaultValue = li(c)));
    }
    var Vc = !1, Pl = !1, Lg = !1;
    function Gc(e, r) {
      r.value == null && (typeof r.children == "object" && r.children !== null ? s.Children.forEach(r.children, function(c) {
        c != null && (typeof c == "string" || typeof c == "number" || Pl || (Pl = !0, T("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : r.dangerouslySetInnerHTML != null && (Lg || (Lg = !0, T("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), r.selected != null && !Vc && (T("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Vc = !0);
    }
    function Vf(e, r) {
      r.value != null && e.setAttribute("value", li(qs(r.value)));
    }
    var Yu = Array.isArray;
    function _r(e) {
      return Yu(e);
    }
    var $c;
    $c = !1;
    function Mg() {
      var e = oi();
      return e ? `

Check the render method of \`` + e + "`." : "";
    }
    var Dg = ["value", "defaultValue"];
    function dx(e) {
      {
        Dl("select", e);
        for (var r = 0; r < Dg.length; r++) {
          var c = Dg[r];
          if (e[c] != null) {
            var g = _r(e[c]);
            e.multiple && !g ? T("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", c, Mg()) : !e.multiple && g && T("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", c, Mg());
          }
        }
      }
    }
    function Qs(e, r, c, g) {
      var x = e.options;
      if (r) {
        for (var R = c, _ = {}, H = 0; H < R.length; H++)
          _["$" + R[H]] = !0;
        for (var W = 0; W < x.length; W++) {
          var J = _.hasOwnProperty("$" + x[W].value);
          x[W].selected !== J && (x[W].selected = J), J && g && (x[W].defaultSelected = !0);
        }
      } else {
        for (var ne = li(qs(c)), ge = null, he = 0; he < x.length; he++) {
          if (x[he].value === ne) {
            x[he].selected = !0, g && (x[he].defaultSelected = !0);
            return;
          }
          ge === null && !x[he].disabled && (ge = x[he]);
        }
        ge !== null && (ge.selected = !0);
      }
    }
    function Gf(e, r) {
      return p({}, r, {
        value: void 0
      });
    }
    function Og(e, r) {
      var c = e;
      dx(r), c._wrapperState = {
        wasMultiple: !!r.multiple
      }, r.value !== void 0 && r.defaultValue !== void 0 && !$c && (T("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), $c = !0);
    }
    function fx(e, r) {
      var c = e;
      c.multiple = !!r.multiple;
      var g = r.value;
      g != null ? Qs(c, !!r.multiple, g, !1) : r.defaultValue != null && Qs(c, !!r.multiple, r.defaultValue, !0);
    }
    function hx(e, r) {
      var c = e, g = c._wrapperState.wasMultiple;
      c._wrapperState.wasMultiple = !!r.multiple;
      var x = r.value;
      x != null ? Qs(c, !!r.multiple, x, !1) : g !== !!r.multiple && (r.defaultValue != null ? Qs(c, !!r.multiple, r.defaultValue, !0) : Qs(c, !!r.multiple, r.multiple ? [] : "", !1));
    }
    function px(e, r) {
      var c = e, g = r.value;
      g != null && Qs(c, !!r.multiple, g, !1);
    }
    var $f = !1;
    function qf(e, r) {
      var c = e;
      if (r.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var g = p({}, r, {
        value: void 0,
        defaultValue: void 0,
        children: li(c._wrapperState.initialValue)
      });
      return g;
    }
    function _g(e, r) {
      var c = e;
      Dl("textarea", r), r.value !== void 0 && r.defaultValue !== void 0 && !$f && (T("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", oi() || "A component"), $f = !0);
      var g = r.value;
      if (g == null) {
        var x = r.children, R = r.defaultValue;
        if (x != null) {
          T("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (R != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (_r(x)) {
              if (x.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              x = x[0];
            }
            R = x;
          }
        }
        R == null && (R = ""), g = R;
      }
      c._wrapperState = {
        initialValue: qs(g)
      };
    }
    function Pg(e, r) {
      var c = e, g = qs(r.value), x = qs(r.defaultValue);
      if (g != null) {
        var R = li(g);
        R !== c.value && (c.value = R), r.defaultValue == null && c.defaultValue !== R && (c.defaultValue = R);
      }
      x != null && (c.defaultValue = li(x));
    }
    function Ng(e, r) {
      var c = e, g = c.textContent;
      g === c._wrapperState.initialValue && g !== "" && g !== null && (c.value = g);
    }
    function Zf(e, r) {
      Pg(e, r);
    }
    var vs = "http://www.w3.org/1999/xhtml", gx = "http://www.w3.org/1998/Math/MathML", Qf = "http://www.w3.org/2000/svg";
    function qc(e) {
      switch (e) {
        case "svg":
          return Qf;
        case "math":
          return gx;
        default:
          return vs;
      }
    }
    function Kf(e, r) {
      return e == null || e === vs ? qc(r) : e === Qf && r === "foreignObject" ? vs : e;
    }
    var vx = function(e) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(r, c, g, x) {
        MSApp.execUnsafeLocalFunction(function() {
          return e(r, c, g, x);
        });
      } : e;
    }, Zc, zg = vx(function(e, r) {
      if (e.namespaceURI === Qf && !("innerHTML" in e)) {
        Zc = Zc || document.createElement("div"), Zc.innerHTML = "<svg>" + r.valueOf().toString() + "</svg>";
        for (var c = Zc.firstChild; e.firstChild; )
          e.removeChild(e.firstChild);
        for (; c.firstChild; )
          e.appendChild(c.firstChild);
        return;
      }
      e.innerHTML = r;
    }), _i = 1, ms = 3, xr = 8, Ia = 9, No = 11, Qc = function(e, r) {
      if (r) {
        var c = e.firstChild;
        if (c && c === e.lastChild && c.nodeType === ms) {
          c.nodeValue = r;
          return;
        }
      }
      e.textContent = r;
    }, Ig = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, Nl = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Fg(e, r) {
      return e + r.charAt(0).toUpperCase() + r.substring(1);
    }
    var Yg = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Nl).forEach(function(e) {
      Yg.forEach(function(r) {
        Nl[Fg(r, e)] = Nl[e];
      });
    });
    function Kc(e, r, c) {
      var g = r == null || typeof r == "boolean" || r === "";
      return g ? "" : !c && typeof r == "number" && r !== 0 && !(Nl.hasOwnProperty(e) && Nl[e]) ? r + "px" : (da(r, e), ("" + r).trim());
    }
    var zl = /([A-Z])/g, mx = /^ms-/;
    function yx(e) {
      return e.replace(zl, "-$1").toLowerCase().replace(mx, "-ms-");
    }
    var Hg = function() {
    };
    {
      var jg = /^(?:webkit|moz|o)[A-Z]/, Ug = /^-ms-/, Hu = /-(.)/g, Il = /;\s*$/, Fl = {}, Yl = {}, Bg = !1, Jf = !1, eh = function(e) {
        return e.replace(Hu, function(r, c) {
          return c.toUpperCase();
        });
      }, th = function(e) {
        Fl.hasOwnProperty(e) && Fl[e] || (Fl[e] = !0, T(
          "Unsupported style property %s. Did you mean %s?",
          e,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          eh(e.replace(Ug, "ms-"))
        ));
      }, Wg = function(e) {
        Fl.hasOwnProperty(e) && Fl[e] || (Fl[e] = !0, T("Unsupported vendor-prefixed style property %s. Did you mean %s?", e, e.charAt(0).toUpperCase() + e.slice(1)));
      }, Xg = function(e, r) {
        Yl.hasOwnProperty(r) && Yl[r] || (Yl[r] = !0, T(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, e, r.replace(Il, "")));
      }, Vg = function(e, r) {
        Bg || (Bg = !0, T("`NaN` is an invalid value for the `%s` css style property.", e));
      }, xx = function(e, r) {
        Jf || (Jf = !0, T("`Infinity` is an invalid value for the `%s` css style property.", e));
      };
      Hg = function(e, r) {
        e.indexOf("-") > -1 ? th(e) : jg.test(e) ? Wg(e) : Il.test(r) && Xg(e, r), typeof r == "number" && (isNaN(r) ? Vg(e, r) : isFinite(r) || xx(e, r));
      };
    }
    var bx = Hg;
    function wx(e) {
      {
        var r = "", c = "";
        for (var g in e)
          if (e.hasOwnProperty(g)) {
            var x = e[g];
            if (x != null) {
              var R = g.indexOf("--") === 0;
              r += c + (R ? g : yx(g)) + ":", r += Kc(g, x, R), c = ";";
            }
          }
        return r || null;
      }
    }
    function Gg(e, r) {
      var c = e.style;
      for (var g in r)
        if (r.hasOwnProperty(g)) {
          var x = g.indexOf("--") === 0;
          x || bx(g, r[g]);
          var R = Kc(g, r[g], x);
          g === "float" && (g = "cssFloat"), x ? c.setProperty(g, R) : c[g] = R;
        }
    }
    function Sx(e) {
      return e == null || typeof e == "boolean" || e === "";
    }
    function ha(e) {
      var r = {};
      for (var c in e)
        for (var g = Ig[c] || [c], x = 0; x < g.length; x++)
          r[g[x]] = c;
      return r;
    }
    function ju(e, r) {
      {
        if (!r)
          return;
        var c = ha(e), g = ha(r), x = {};
        for (var R in c) {
          var _ = c[R], H = g[R];
          if (H && _ !== H) {
            var W = _ + "," + H;
            if (x[W])
              continue;
            x[W] = !0, T("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", Sx(e[_]) ? "Removing" : "Updating", _, H);
          }
        }
      }
    }
    var $g = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, qg = p({
      menuitem: !0
    }, $g), Zg = "__html";
    function Jc(e, r) {
      if (r) {
        if (qg[e] && (r.children != null || r.dangerouslySetInnerHTML != null))
          throw new Error(e + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (r.dangerouslySetInnerHTML != null) {
          if (r.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof r.dangerouslySetInnerHTML != "object" || !(Zg in r.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!r.suppressContentEditableWarning && r.contentEditable && r.children != null && T("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), r.style != null && typeof r.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function ys(e, r) {
      if (e.indexOf("-") === -1)
        return typeof r.is == "string";
      switch (e) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var ed = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Qg = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Fa = {}, nh = new RegExp("^(aria)-[" + Lt + "]*$"), Uu = new RegExp("^(aria)[A-Z][" + Lt + "]*$");
    function rh(e, r) {
      {
        if (jn.call(Fa, r) && Fa[r])
          return !0;
        if (Uu.test(r)) {
          var c = "aria-" + r.slice(4).toLowerCase(), g = Qg.hasOwnProperty(c) ? c : null;
          if (g == null)
            return T("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", r), Fa[r] = !0, !0;
          if (r !== g)
            return T("Invalid ARIA attribute `%s`. Did you mean `%s`?", r, g), Fa[r] = !0, !0;
        }
        if (nh.test(r)) {
          var x = r.toLowerCase(), R = Qg.hasOwnProperty(x) ? x : null;
          if (R == null)
            return Fa[r] = !0, !1;
          if (r !== R)
            return T("Unknown ARIA attribute `%s`. Did you mean `%s`?", r, R), Fa[r] = !0, !0;
        }
      }
      return !0;
    }
    function Kg(e, r) {
      {
        var c = [];
        for (var g in r) {
          var x = rh(e, g);
          x || c.push(g);
        }
        var R = c.map(function(_) {
          return "`" + _ + "`";
        }).join(", ");
        c.length === 1 ? T("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", R, e) : c.length > 1 && T("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", R, e);
      }
    }
    function td(e, r) {
      ys(e, r) || Kg(e, r);
    }
    var zo = !1;
    function ih(e, r) {
      {
        if (e !== "input" && e !== "textarea" && e !== "select")
          return;
        r != null && r.value === null && !zo && (zo = !0, e === "select" && r.multiple ? T("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", e) : T("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", e));
      }
    }
    var ah = function() {
    };
    {
      var Pr = {}, sh = /^on./, Jg = /^on[^A-Z]/, ev = new RegExp("^(aria)-[" + Lt + "]*$"), tv = new RegExp("^(aria)[A-Z][" + Lt + "]*$");
      ah = function(e, r, c, g) {
        if (jn.call(Pr, r) && Pr[r])
          return !0;
        var x = r.toLowerCase();
        if (x === "onfocusin" || x === "onfocusout")
          return T("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Pr[r] = !0, !0;
        if (g != null) {
          var R = g.registrationNameDependencies, _ = g.possibleRegistrationNames;
          if (R.hasOwnProperty(r))
            return !0;
          var H = _.hasOwnProperty(x) ? _[x] : null;
          if (H != null)
            return T("Invalid event handler property `%s`. Did you mean `%s`?", r, H), Pr[r] = !0, !0;
          if (sh.test(r))
            return T("Unknown event handler property `%s`. It will be ignored.", r), Pr[r] = !0, !0;
        } else if (sh.test(r))
          return Jg.test(r) && T("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", r), Pr[r] = !0, !0;
        if (ev.test(r) || tv.test(r))
          return !0;
        if (x === "innerhtml")
          return T("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Pr[r] = !0, !0;
        if (x === "aria")
          return T("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Pr[r] = !0, !0;
        if (x === "is" && c !== null && c !== void 0 && typeof c != "string")
          return T("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof c), Pr[r] = !0, !0;
        if (typeof c == "number" && isNaN(c))
          return T("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", r), Pr[r] = !0, !0;
        var W = mr(r), J = W !== null && W.type === fa;
        if (ed.hasOwnProperty(x)) {
          var ne = ed[x];
          if (ne !== r)
            return T("Invalid DOM property `%s`. Did you mean `%s`?", r, ne), Pr[r] = !0, !0;
        } else if (!J && r !== x)
          return T("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", r, x), Pr[r] = !0, !0;
        return typeof c == "boolean" && ii(r, c, W, !1) ? (c ? T('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', c, r, r, c, r) : T('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', c, r, r, c, r, r, r), Pr[r] = !0, !0) : J ? !0 : ii(r, c, W, !1) ? (Pr[r] = !0, !1) : ((c === "false" || c === "true") && W !== null && W.type === ar && (T("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", c, r, c === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', r, c), Pr[r] = !0), !0);
      };
    }
    var nv = function(e, r, c) {
      {
        var g = [];
        for (var x in r) {
          var R = ah(e, x, r[x], c);
          R || g.push(x);
        }
        var _ = g.map(function(H) {
          return "`" + H + "`";
        }).join(", ");
        g.length === 1 ? T("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", _, e) : g.length > 1 && T("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", _, e);
      }
    };
    function rv(e, r, c) {
      ys(e, r) || nv(e, r, c);
    }
    var xs = 1, Bu = 2, Io = 4, kx = xs | Bu | Io, Wu = null;
    function Xu(e) {
      Wu !== null && T("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Wu = e;
    }
    function Cx() {
      Wu === null && T("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Wu = null;
    }
    function iv(e) {
      return e === Wu;
    }
    function nd(e) {
      var r = e.target || e.srcElement || window;
      return r.correspondingUseElement && (r = r.correspondingUseElement), r.nodeType === ms ? r.parentNode : r;
    }
    var In = null, Ks = null, bs = null;
    function Hl(e) {
      var r = fu(e);
      if (r) {
        if (typeof In != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var c = r.stateNode;
        if (c) {
          var g = im(c);
          In(r.stateNode, r.type, g);
        }
      }
    }
    function av(e) {
      In = e;
    }
    function rd(e) {
      Ks ? bs ? bs.push(e) : bs = [e] : Ks = e;
    }
    function Vu() {
      return Ks !== null || bs !== null;
    }
    function Gu() {
      if (Ks) {
        var e = Ks, r = bs;
        if (Ks = null, bs = null, Hl(e), r)
          for (var c = 0; c < r.length; c++)
            Hl(r[c]);
      }
    }
    var Fo = function(e, r) {
      return e(r);
    }, oh = function() {
    }, lh = !1;
    function Ax() {
      var e = Vu();
      e && (oh(), Gu());
    }
    function uh(e, r, c) {
      if (lh)
        return e(r, c);
      lh = !0;
      try {
        return Fo(e, r, c);
      } finally {
        lh = !1, Ax();
      }
    }
    function id(e, r, c) {
      Fo = e, oh = c;
    }
    function ad(e) {
      return e === "button" || e === "input" || e === "select" || e === "textarea";
    }
    function ch(e, r, c) {
      switch (e) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(c.disabled && ad(r));
        default:
          return !1;
      }
    }
    function Yo(e, r) {
      var c = e.stateNode;
      if (c === null)
        return null;
      var g = im(c);
      if (g === null)
        return null;
      var x = g[r];
      if (ch(r, e.type, g))
        return null;
      if (x && typeof x != "function")
        throw new Error("Expected `" + r + "` listener to be a function, instead got a value of `" + typeof x + "` type.");
      return x;
    }
    var $u = !1;
    if (pn)
      try {
        var Ho = {};
        Object.defineProperty(Ho, "passive", {
          get: function() {
            $u = !0;
          }
        }), window.addEventListener("test", Ho, Ho), window.removeEventListener("test", Ho, Ho);
      } catch {
        $u = !1;
      }
    function sv(e, r, c, g, x, R, _, H, W) {
      var J = Array.prototype.slice.call(arguments, 3);
      try {
        r.apply(c, J);
      } catch (ne) {
        this.onError(ne);
      }
    }
    var dh = sv;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var fh = document.createElement("react");
      dh = function(r, c, g, x, R, _, H, W, J) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var ne = document.createEvent("Event"), ge = !1, he = !0, Ae = window.event, Te = Object.getOwnPropertyDescriptor(window, "event");
        function De() {
          fh.removeEventListener(Oe, Pt, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Ae);
        }
        var ht = Array.prototype.slice.call(arguments, 3);
        function Pt() {
          ge = !0, De(), c.apply(g, ht), he = !1;
        }
        var Tt, hn = !1, on = !1;
        function xe(be) {
          if (Tt = be.error, hn = !0, Tt === null && be.colno === 0 && be.lineno === 0 && (on = !0), be.defaultPrevented && Tt != null && typeof Tt == "object")
            try {
              Tt._suppressLogging = !0;
            } catch {
            }
        }
        var Oe = "react-" + (r || "invokeguardedcallback");
        if (window.addEventListener("error", xe), fh.addEventListener(Oe, Pt, !1), ne.initEvent(Oe, !1, !1), fh.dispatchEvent(ne), Te && Object.defineProperty(window, "event", Te), ge && he && (hn ? on && (Tt = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Tt = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Tt)), window.removeEventListener("error", xe), !ge)
          return De(), sv.apply(this, arguments);
      };
    }
    var Tx = dh, Js = !1, Ya = null, qu = !1, eo = null, Ga = {
      onError: function(e) {
        Js = !0, Ya = e;
      }
    };
    function jo(e, r, c, g, x, R, _, H, W) {
      Js = !1, Ya = null, Tx.apply(Ga, arguments);
    }
    function ws(e, r, c, g, x, R, _, H, W) {
      if (jo.apply(this, arguments), Js) {
        var J = ph();
        qu || (qu = !0, eo = J);
      }
    }
    function hh() {
      if (qu) {
        var e = eo;
        throw qu = !1, eo = null, e;
      }
    }
    function Ex() {
      return Js;
    }
    function ph() {
      if (Js) {
        var e = Ya;
        return Js = !1, Ya = null, e;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function pa(e) {
      return e._reactInternals;
    }
    function Zu(e) {
      return e._reactInternals !== void 0;
    }
    function jl(e, r) {
      e._reactInternals = r;
    }
    var _t = (
      /*                      */
      0
    ), to = (
      /*                */
      1
    ), Bn = (
      /*                    */
      2
    ), Jt = (
      /*                       */
      4
    ), Sn = (
      /*                */
      16
    ), An = (
      /*                 */
      32
    ), $a = (
      /*                     */
      64
    ), Wt = (
      /*                   */
      128
    ), or = (
      /*            */
      256
    ), Pi = (
      /*                          */
      512
    ), ga = (
      /*                     */
      1024
    ), qn = (
      /*                      */
      2048
    ), va = (
      /*                    */
      4096
    ), no = (
      /*                   */
      8192
    ), Qu = (
      /*             */
      16384
    ), sd = qn | Jt | $a | Pi | ga | Qu, ov = (
      /*               */
      32767
    ), ea = (
      /*                   */
      32768
    ), Nr = (
      /*                */
      65536
    ), Ku = (
      /* */
      131072
    ), gh = (
      /*                       */
      1048576
    ), vh = (
      /*                    */
      2097152
    ), Ni = (
      /*                 */
      4194304
    ), ro = (
      /*                */
      8388608
    ), zi = (
      /*               */
      16777216
    ), Uo = (
      /*              */
      33554432
    ), Ul = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Jt | ga | 0
    ), Ii = Bn | Jt | Sn | An | Pi | va | no, ui = Jt | $a | Pi | no, ma = qn | Sn, Br = Ni | ro | vh, Ss = h.ReactCurrentOwner;
    function ta(e) {
      var r = e, c = e;
      if (e.alternate)
        for (; r.return; )
          r = r.return;
      else {
        var g = r;
        do
          r = g, (r.flags & (Bn | va)) !== _t && (c = r.return), g = r.return;
        while (g);
      }
      return r.tag === q ? c : null;
    }
    function mh(e) {
      if (e.tag === re) {
        var r = e.memoizedState;
        if (r === null) {
          var c = e.alternate;
          c !== null && (r = c.memoizedState);
        }
        if (r !== null)
          return r.dehydrated;
      }
      return null;
    }
    function od(e) {
      return e.tag === q ? e.stateNode.containerInfo : null;
    }
    function yh(e) {
      return ta(e) === e;
    }
    function na(e) {
      {
        var r = Ss.current;
        if (r !== null && r.tag === U) {
          var c = r, g = c.stateNode;
          g._warnedAboutRefsInRender || T("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", vt(c) || "A component"), g._warnedAboutRefsInRender = !0;
        }
      }
      var x = pa(e);
      return x ? ta(x) === x : !1;
    }
    function Fi(e) {
      if (ta(e) !== e)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Wn(e) {
      var r = e.alternate;
      if (!r) {
        var c = ta(e);
        if (c === null)
          throw new Error("Unable to find node on an unmounted component.");
        return c !== e ? null : e;
      }
      for (var g = e, x = r; ; ) {
        var R = g.return;
        if (R === null)
          break;
        var _ = R.alternate;
        if (_ === null) {
          var H = R.return;
          if (H !== null) {
            g = x = H;
            continue;
          }
          break;
        }
        if (R.child === _.child) {
          for (var W = R.child; W; ) {
            if (W === g)
              return Fi(R), e;
            if (W === x)
              return Fi(R), r;
            W = W.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (g.return !== x.return)
          g = R, x = _;
        else {
          for (var J = !1, ne = R.child; ne; ) {
            if (ne === g) {
              J = !0, g = R, x = _;
              break;
            }
            if (ne === x) {
              J = !0, x = R, g = _;
              break;
            }
            ne = ne.sibling;
          }
          if (!J) {
            for (ne = _.child; ne; ) {
              if (ne === g) {
                J = !0, g = _, x = R;
                break;
              }
              if (ne === x) {
                J = !0, x = _, g = R;
                break;
              }
              ne = ne.sibling;
            }
            if (!J)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (g.alternate !== x)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (g.tag !== q)
        throw new Error("Unable to find node on an unmounted component.");
      return g.stateNode.current === g ? e : r;
    }
    function ya(e) {
      var r = Wn(e);
      return r !== null ? xh(r) : null;
    }
    function xh(e) {
      if (e.tag === se || e.tag === ae)
        return e;
      for (var r = e.child; r !== null; ) {
        var c = xh(r);
        if (c !== null)
          return c;
        r = r.sibling;
      }
      return null;
    }
    function lv(e) {
      var r = Wn(e);
      return r !== null ? ld(r) : null;
    }
    function ld(e) {
      if (e.tag === se || e.tag === ae)
        return e;
      for (var r = e.child; r !== null; ) {
        if (r.tag !== te) {
          var c = ld(r);
          if (c !== null)
            return c;
        }
        r = r.sibling;
      }
      return null;
    }
    var ud = u.unstable_scheduleCallback, uv = u.unstable_cancelCallback, cd = u.unstable_shouldYield, cv = u.unstable_requestPaint, Qn = u.unstable_now, bh = u.unstable_getCurrentPriorityLevel, dd = u.unstable_ImmediatePriority, ra = u.unstable_UserBlockingPriority, qa = u.unstable_NormalPriority, fd = u.unstable_LowPriority, io = u.unstable_IdlePriority, wh = u.unstable_yieldValue, Sh = u.unstable_setDisableYieldValue, ao = null, zr = null, nt = null, fr = !1, Wr = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function kh(e) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var r = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (r.isDisabled)
        return !0;
      if (!r.supportsFiber)
        return T("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        Ht && (e = p({}, e, {
          getLaneLabelMap: oo,
          injectProfilingHooks: Cs
        })), ao = r.inject(e), zr = r;
      } catch (c) {
        T("React instrumentation encountered an error: %s.", c);
      }
      return !!r.checkDCE;
    }
    function dv(e, r) {
      if (zr && typeof zr.onScheduleFiberRoot == "function")
        try {
          zr.onScheduleFiberRoot(ao, e, r);
        } catch (c) {
          fr || (fr = !0, T("React instrumentation encountered an error: %s", c));
        }
    }
    function ks(e, r) {
      if (zr && typeof zr.onCommitFiberRoot == "function")
        try {
          var c = (e.current.flags & Wt) === Wt;
          if (ot) {
            var g;
            switch (r) {
              case ci:
                g = dd;
                break;
              case Xr:
                g = ra;
                break;
              case Ts:
                g = qa;
                break;
              case oc:
                g = io;
                break;
              default:
                g = qa;
                break;
            }
            zr.onCommitFiberRoot(ao, e, g, c);
          }
        } catch (x) {
          fr || (fr = !0, T("React instrumentation encountered an error: %s", x));
        }
    }
    function so(e) {
      if (zr && typeof zr.onPostCommitFiberRoot == "function")
        try {
          zr.onPostCommitFiberRoot(ao, e);
        } catch (r) {
          fr || (fr = !0, T("React instrumentation encountered an error: %s", r));
        }
    }
    function Ch(e) {
      if (zr && typeof zr.onCommitFiberUnmount == "function")
        try {
          zr.onCommitFiberUnmount(ao, e);
        } catch (r) {
          fr || (fr = !0, T("React instrumentation encountered an error: %s", r));
        }
    }
    function Cr(e) {
      if (typeof wh == "function" && (Sh(e), w(e)), zr && typeof zr.setStrictMode == "function")
        try {
          zr.setStrictMode(ao, e);
        } catch (r) {
          fr || (fr = !0, T("React instrumentation encountered an error: %s", r));
        }
    }
    function Cs(e) {
      nt = e;
    }
    function oo() {
      {
        for (var e = /* @__PURE__ */ new Map(), r = 1, c = 0; c < Xn; c++) {
          var g = Rx(r);
          e.set(r, g), r *= 2;
        }
        return e;
      }
    }
    function hd(e) {
      nt !== null && typeof nt.markCommitStarted == "function" && nt.markCommitStarted(e);
    }
    function Ah() {
      nt !== null && typeof nt.markCommitStopped == "function" && nt.markCommitStopped();
    }
    function lo(e) {
      nt !== null && typeof nt.markComponentRenderStarted == "function" && nt.markComponentRenderStarted(e);
    }
    function Bo() {
      nt !== null && typeof nt.markComponentRenderStopped == "function" && nt.markComponentRenderStopped();
    }
    function fv(e) {
      nt !== null && typeof nt.markComponentPassiveEffectMountStarted == "function" && nt.markComponentPassiveEffectMountStarted(e);
    }
    function Th() {
      nt !== null && typeof nt.markComponentPassiveEffectMountStopped == "function" && nt.markComponentPassiveEffectMountStopped();
    }
    function pd(e) {
      nt !== null && typeof nt.markComponentPassiveEffectUnmountStarted == "function" && nt.markComponentPassiveEffectUnmountStarted(e);
    }
    function hv() {
      nt !== null && typeof nt.markComponentPassiveEffectUnmountStopped == "function" && nt.markComponentPassiveEffectUnmountStopped();
    }
    function pv(e) {
      nt !== null && typeof nt.markComponentLayoutEffectMountStarted == "function" && nt.markComponentLayoutEffectMountStarted(e);
    }
    function gv() {
      nt !== null && typeof nt.markComponentLayoutEffectMountStopped == "function" && nt.markComponentLayoutEffectMountStopped();
    }
    function gd(e) {
      nt !== null && typeof nt.markComponentLayoutEffectUnmountStarted == "function" && nt.markComponentLayoutEffectUnmountStarted(e);
    }
    function Bl() {
      nt !== null && typeof nt.markComponentLayoutEffectUnmountStopped == "function" && nt.markComponentLayoutEffectUnmountStopped();
    }
    function vd(e, r, c) {
      nt !== null && typeof nt.markComponentErrored == "function" && nt.markComponentErrored(e, r, c);
    }
    function vv(e, r, c) {
      nt !== null && typeof nt.markComponentSuspended == "function" && nt.markComponentSuspended(e, r, c);
    }
    function mv(e) {
      nt !== null && typeof nt.markLayoutEffectsStarted == "function" && nt.markLayoutEffectsStarted(e);
    }
    function Wl() {
      nt !== null && typeof nt.markLayoutEffectsStopped == "function" && nt.markLayoutEffectsStopped();
    }
    function yv(e) {
      nt !== null && typeof nt.markPassiveEffectsStarted == "function" && nt.markPassiveEffectsStarted(e);
    }
    function Ju() {
      nt !== null && typeof nt.markPassiveEffectsStopped == "function" && nt.markPassiveEffectsStopped();
    }
    function Ha(e) {
      nt !== null && typeof nt.markRenderStarted == "function" && nt.markRenderStarted(e);
    }
    function ec() {
      nt !== null && typeof nt.markRenderYielded == "function" && nt.markRenderYielded();
    }
    function Xl() {
      nt !== null && typeof nt.markRenderStopped == "function" && nt.markRenderStopped();
    }
    function Wo(e) {
      nt !== null && typeof nt.markRenderScheduled == "function" && nt.markRenderScheduled(e);
    }
    function Eh(e, r) {
      nt !== null && typeof nt.markForceUpdateScheduled == "function" && nt.markForceUpdateScheduled(e, r);
    }
    function uo(e, r) {
      nt !== null && typeof nt.markStateUpdateScheduled == "function" && nt.markStateUpdateScheduled(e, r);
    }
    var Nt = (
      /*                         */
      0
    ), nn = (
      /*                 */
      1
    ), Ft = (
      /*                    */
      2
    ), Kn = (
      /*               */
      8
    ), xa = (
      /*              */
      16
    ), md = Math.clz32 ? Math.clz32 : Xo, yd = Math.log, Rh = Math.LN2;
    function Xo(e) {
      var r = e >>> 0;
      return r === 0 ? 32 : 31 - (yd(r) / Rh | 0) | 0;
    }
    var Xn = 31, Pe = (
      /*                        */
      0
    ), dn = (
      /*                          */
      0
    ), Yt = (
      /*                        */
      1
    ), Za = (
      /*    */
      2
    ), ia = (
      /*             */
      4
    ), Vo = (
      /*            */
      8
    ), Vn = (
      /*                     */
      16
    ), Go = (
      /*                */
      32
    ), co = (
      /*                       */
      4194240
    ), $o = (
      /*                        */
      64
    ), ba = (
      /*                        */
      128
    ), Yi = (
      /*                        */
      256
    ), qo = (
      /*                        */
      512
    ), tc = (
      /*                        */
      1024
    ), nc = (
      /*                        */
      2048
    ), xd = (
      /*                        */
      4096
    ), bd = (
      /*                        */
      8192
    ), wd = (
      /*                        */
      16384
    ), Sd = (
      /*                       */
      32768
    ), kd = (
      /*                       */
      65536
    ), Cd = (
      /*                       */
      131072
    ), Ad = (
      /*                       */
      262144
    ), Td = (
      /*                       */
      524288
    ), Zo = (
      /*                       */
      1048576
    ), Ed = (
      /*                       */
      2097152
    ), Qo = (
      /*                            */
      130023424
    ), As = (
      /*                             */
      4194304
    ), Rd = (
      /*                             */
      8388608
    ), rc = (
      /*                             */
      16777216
    ), Ld = (
      /*                             */
      33554432
    ), Md = (
      /*                             */
      67108864
    ), Lh = As, Vl = (
      /*          */
      134217728
    ), Dd = (
      /*                          */
      268435455
    ), Gl = (
      /*               */
      268435456
    ), fo = (
      /*                        */
      536870912
    ), Hi = (
      /*                   */
      1073741824
    );
    function Rx(e) {
      {
        if (e & Yt)
          return "Sync";
        if (e & Za)
          return "InputContinuousHydration";
        if (e & ia)
          return "InputContinuous";
        if (e & Vo)
          return "DefaultHydration";
        if (e & Vn)
          return "Default";
        if (e & Go)
          return "TransitionHydration";
        if (e & co)
          return "Transition";
        if (e & Qo)
          return "Retry";
        if (e & Vl)
          return "SelectiveHydration";
        if (e & Gl)
          return "IdleHydration";
        if (e & fo)
          return "Idle";
        if (e & Hi)
          return "Offscreen";
      }
    }
    var Fn = -1, Od = $o, _d = As;
    function $l(e) {
      switch (br(e)) {
        case Yt:
          return Yt;
        case Za:
          return Za;
        case ia:
          return ia;
        case Vo:
          return Vo;
        case Vn:
          return Vn;
        case Go:
          return Go;
        case $o:
        case ba:
        case Yi:
        case qo:
        case tc:
        case nc:
        case xd:
        case bd:
        case wd:
        case Sd:
        case kd:
        case Cd:
        case Ad:
        case Td:
        case Zo:
        case Ed:
          return e & co;
        case As:
        case Rd:
        case rc:
        case Ld:
        case Md:
          return e & Qo;
        case Vl:
          return Vl;
        case Gl:
          return Gl;
        case fo:
          return fo;
        case Hi:
          return Hi;
        default:
          return T("Should have found matching lanes. This is a bug in React."), e;
      }
    }
    function ic(e, r) {
      var c = e.pendingLanes;
      if (c === Pe)
        return Pe;
      var g = Pe, x = e.suspendedLanes, R = e.pingedLanes, _ = c & Dd;
      if (_ !== Pe) {
        var H = _ & ~x;
        if (H !== Pe)
          g = $l(H);
        else {
          var W = _ & R;
          W !== Pe && (g = $l(W));
        }
      } else {
        var J = c & ~x;
        J !== Pe ? g = $l(J) : R !== Pe && (g = $l(R));
      }
      if (g === Pe)
        return Pe;
      if (r !== Pe && r !== g && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (r & x) === Pe) {
        var ne = br(g), ge = br(r);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          ne >= ge || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          ne === Vn && (ge & co) !== Pe
        )
          return r;
      }
      (g & ia) !== Pe && (g |= c & Vn);
      var he = e.entangledLanes;
      if (he !== Pe)
        for (var Ae = e.entanglements, Te = g & he; Te > 0; ) {
          var De = ho(Te), ht = 1 << De;
          g |= Ae[De], Te &= ~ht;
        }
      return g;
    }
    function xv(e, r) {
      for (var c = e.eventTimes, g = Fn; r > 0; ) {
        var x = ho(r), R = 1 << x, _ = c[x];
        _ > g && (g = _), r &= ~R;
      }
      return g;
    }
    function Pd(e, r) {
      switch (e) {
        case Yt:
        case Za:
        case ia:
          return r + 250;
        case Vo:
        case Vn:
        case Go:
        case $o:
        case ba:
        case Yi:
        case qo:
        case tc:
        case nc:
        case xd:
        case bd:
        case wd:
        case Sd:
        case kd:
        case Cd:
        case Ad:
        case Td:
        case Zo:
        case Ed:
          return r + 5e3;
        case As:
        case Rd:
        case rc:
        case Ld:
        case Md:
          return Fn;
        case Vl:
        case Gl:
        case fo:
        case Hi:
          return Fn;
        default:
          return T("Should have found matching lanes. This is a bug in React."), Fn;
      }
    }
    function Lx(e, r) {
      for (var c = e.pendingLanes, g = e.suspendedLanes, x = e.pingedLanes, R = e.expirationTimes, _ = c; _ > 0; ) {
        var H = ho(_), W = 1 << H, J = R[H];
        J === Fn ? ((W & g) === Pe || (W & x) !== Pe) && (R[H] = Pd(W, r)) : J <= r && (e.expiredLanes |= W), _ &= ~W;
      }
    }
    function Mx(e) {
      return $l(e.pendingLanes);
    }
    function Mh(e) {
      var r = e.pendingLanes & ~Hi;
      return r !== Pe ? r : r & Hi ? Hi : Pe;
    }
    function ql(e) {
      return (e & Yt) !== Pe;
    }
    function ac(e) {
      return (e & Dd) !== Pe;
    }
    function Nd(e) {
      return (e & Qo) === e;
    }
    function Dx(e) {
      var r = Yt | ia | Vn;
      return (e & r) === Pe;
    }
    function bv(e) {
      return (e & co) === e;
    }
    function sc(e, r) {
      var c = Za | ia | Vo | Vn;
      return (r & c) !== Pe;
    }
    function wv(e, r) {
      return (r & e.expiredLanes) !== Pe;
    }
    function Dh(e) {
      return (e & co) !== Pe;
    }
    function Oh() {
      var e = Od;
      return Od <<= 1, (Od & co) === Pe && (Od = $o), e;
    }
    function Ox() {
      var e = _d;
      return _d <<= 1, (_d & Qo) === Pe && (_d = As), e;
    }
    function br(e) {
      return e & -e;
    }
    function Ar(e) {
      return br(e);
    }
    function ho(e) {
      return 31 - md(e);
    }
    function zd(e) {
      return ho(e);
    }
    function ji(e, r) {
      return (e & r) !== Pe;
    }
    function Ko(e, r) {
      return (e & r) === r;
    }
    function en(e, r) {
      return e | r;
    }
    function Zl(e, r) {
      return e & ~r;
    }
    function _h(e, r) {
      return e & r;
    }
    function Sv(e) {
      return e;
    }
    function kv(e, r) {
      return e !== dn && e < r ? e : r;
    }
    function Id(e) {
      for (var r = [], c = 0; c < Xn; c++)
        r.push(e);
      return r;
    }
    function Jo(e, r, c) {
      e.pendingLanes |= r, r !== fo && (e.suspendedLanes = Pe, e.pingedLanes = Pe);
      var g = e.eventTimes, x = zd(r);
      g[x] = c;
    }
    function Ph(e, r) {
      e.suspendedLanes |= r, e.pingedLanes &= ~r;
      for (var c = e.expirationTimes, g = r; g > 0; ) {
        var x = ho(g), R = 1 << x;
        c[x] = Fn, g &= ~R;
      }
    }
    function Nh(e, r, c) {
      e.pingedLanes |= e.suspendedLanes & r;
    }
    function zh(e, r) {
      var c = e.pendingLanes & ~r;
      e.pendingLanes = r, e.suspendedLanes = Pe, e.pingedLanes = Pe, e.expiredLanes &= r, e.mutableReadLanes &= r, e.entangledLanes &= r;
      for (var g = e.entanglements, x = e.eventTimes, R = e.expirationTimes, _ = c; _ > 0; ) {
        var H = ho(_), W = 1 << H;
        g[H] = Pe, x[H] = Fn, R[H] = Fn, _ &= ~W;
      }
    }
    function Ql(e, r) {
      for (var c = e.entangledLanes |= r, g = e.entanglements, x = c; x; ) {
        var R = ho(x), _ = 1 << R;
        // Is this one of the newly entangled lanes?
        _ & r | // Is this lane transitively entangled with the newly entangled lanes?
        g[R] & r && (g[R] |= r), x &= ~_;
      }
    }
    function _x(e, r) {
      var c = br(r), g;
      switch (c) {
        case ia:
          g = Za;
          break;
        case Vn:
          g = Vo;
          break;
        case $o:
        case ba:
        case Yi:
        case qo:
        case tc:
        case nc:
        case xd:
        case bd:
        case wd:
        case Sd:
        case kd:
        case Cd:
        case Ad:
        case Td:
        case Zo:
        case Ed:
        case As:
        case Rd:
        case rc:
        case Ld:
        case Md:
          g = Go;
          break;
        case fo:
          g = Gl;
          break;
        default:
          g = dn;
          break;
      }
      return (g & (e.suspendedLanes | r)) !== dn ? dn : g;
    }
    function Ih(e, r, c) {
      if (Wr)
        for (var g = e.pendingUpdatersLaneMap; c > 0; ) {
          var x = zd(c), R = 1 << x, _ = g[x];
          _.add(r), c &= ~R;
        }
    }
    function Fd(e, r) {
      if (Wr)
        for (var c = e.pendingUpdatersLaneMap, g = e.memoizedUpdaters; r > 0; ) {
          var x = zd(r), R = 1 << x, _ = c[x];
          _.size > 0 && (_.forEach(function(H) {
            var W = H.alternate;
            (W === null || !g.has(W)) && g.add(H);
          }), _.clear()), r &= ~R;
        }
    }
    function Fh(e, r) {
      return null;
    }
    var ci = Yt, Xr = ia, Ts = Vn, oc = fo, el = dn;
    function wa() {
      return el;
    }
    function Tr(e) {
      el = e;
    }
    function lc(e, r) {
      var c = el;
      try {
        return el = e, r();
      } finally {
        el = c;
      }
    }
    function di(e, r) {
      return e !== 0 && e < r ? e : r;
    }
    function Px(e, r) {
      return e === 0 || e > r ? e : r;
    }
    function Yh(e, r) {
      return e !== 0 && e < r;
    }
    function uc(e) {
      var r = br(e);
      return Yh(ci, r) ? Yh(Xr, r) ? ac(r) ? Ts : oc : Xr : ci;
    }
    function Er(e) {
      var r = e.current.memoizedState;
      return r.isDehydrated;
    }
    var Cv;
    function gt(e) {
      Cv = e;
    }
    function Kl(e) {
      Cv(e);
    }
    var cc;
    function Av(e) {
      cc = e;
    }
    var Tv;
    function dc(e) {
      Tv = e;
    }
    var fc;
    function Hh(e) {
      fc = e;
    }
    var jh;
    function Ev(e) {
      jh = e;
    }
    var Yd = !1, Jl = [], Qa = null, Zn = null, Ir = null, Sa = /* @__PURE__ */ new Map(), eu = /* @__PURE__ */ new Map(), Es = [], ja = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function Rv(e) {
      return ja.indexOf(e) > -1;
    }
    function Ka(e, r, c, g, x) {
      return {
        blockedOn: e,
        domEventName: r,
        eventSystemFlags: c,
        nativeEvent: x,
        targetContainers: [g]
      };
    }
    function Lv(e, r) {
      switch (e) {
        case "focusin":
        case "focusout":
          Qa = null;
          break;
        case "dragenter":
        case "dragleave":
          Zn = null;
          break;
        case "mouseover":
        case "mouseout":
          Ir = null;
          break;
        case "pointerover":
        case "pointerout": {
          var c = r.pointerId;
          Sa.delete(c);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var g = r.pointerId;
          eu.delete(g);
          break;
        }
      }
    }
    function tu(e, r, c, g, x, R) {
      if (e === null || e.nativeEvent !== R) {
        var _ = Ka(r, c, g, x, R);
        if (r !== null) {
          var H = fu(r);
          H !== null && cc(H);
        }
        return _;
      }
      e.eventSystemFlags |= g;
      var W = e.targetContainers;
      return x !== null && W.indexOf(x) === -1 && W.push(x), e;
    }
    function Mv(e, r, c, g, x) {
      switch (r) {
        case "focusin": {
          var R = x;
          return Qa = tu(Qa, e, r, c, g, R), !0;
        }
        case "dragenter": {
          var _ = x;
          return Zn = tu(Zn, e, r, c, g, _), !0;
        }
        case "mouseover": {
          var H = x;
          return Ir = tu(Ir, e, r, c, g, H), !0;
        }
        case "pointerover": {
          var W = x, J = W.pointerId;
          return Sa.set(J, tu(Sa.get(J) || null, e, r, c, g, W)), !0;
        }
        case "gotpointercapture": {
          var ne = x, ge = ne.pointerId;
          return eu.set(ge, tu(eu.get(ge) || null, e, r, c, g, ne)), !0;
        }
      }
      return !1;
    }
    function Uh(e) {
      var r = wc(e.target);
      if (r !== null) {
        var c = ta(r);
        if (c !== null) {
          var g = c.tag;
          if (g === re) {
            var x = mh(c);
            if (x !== null) {
              e.blockedOn = x, jh(e.priority, function() {
                Tv(c);
              });
              return;
            }
          } else if (g === q) {
            var R = c.stateNode;
            if (Er(R)) {
              e.blockedOn = od(c);
              return;
            }
          }
        }
      }
      e.blockedOn = null;
    }
    function Dv(e) {
      for (var r = fc(), c = {
        blockedOn: null,
        target: e,
        priority: r
      }, g = 0; g < Es.length && Yh(r, Es[g].priority); g++)
        ;
      Es.splice(g, 0, c), g === 0 && Uh(c);
    }
    function Hd(e) {
      if (e.blockedOn !== null)
        return !1;
      for (var r = e.targetContainers; r.length > 0; ) {
        var c = r[0], g = tl(e.domEventName, e.eventSystemFlags, c, e.nativeEvent);
        if (g === null) {
          var x = e.nativeEvent, R = new x.constructor(x.type, x);
          Xu(R), x.target.dispatchEvent(R), Cx();
        } else {
          var _ = fu(g);
          return _ !== null && cc(_), e.blockedOn = g, !1;
        }
        r.shift();
      }
      return !0;
    }
    function hc(e, r, c) {
      Hd(e) && c.delete(r);
    }
    function Bh() {
      Yd = !1, Qa !== null && Hd(Qa) && (Qa = null), Zn !== null && Hd(Zn) && (Zn = null), Ir !== null && Hd(Ir) && (Ir = null), Sa.forEach(hc), eu.forEach(hc);
    }
    function fi(e, r) {
      e.blockedOn === r && (e.blockedOn = null, Yd || (Yd = !0, u.unstable_scheduleCallback(u.unstable_NormalPriority, Bh)));
    }
    function sn(e) {
      if (Jl.length > 0) {
        fi(Jl[0], e);
        for (var r = 1; r < Jl.length; r++) {
          var c = Jl[r];
          c.blockedOn === e && (c.blockedOn = null);
        }
      }
      Qa !== null && fi(Qa, e), Zn !== null && fi(Zn, e), Ir !== null && fi(Ir, e);
      var g = function(H) {
        return fi(H, e);
      };
      Sa.forEach(g), eu.forEach(g);
      for (var x = 0; x < Es.length; x++) {
        var R = Es[x];
        R.blockedOn === e && (R.blockedOn = null);
      }
      for (; Es.length > 0; ) {
        var _ = Es[0];
        if (_.blockedOn !== null)
          break;
        Uh(_), _.blockedOn === null && Es.shift();
      }
    }
    var Jn = h.ReactCurrentBatchConfig, lr = !0;
    function Fr(e) {
      lr = !!e;
    }
    function aa() {
      return lr;
    }
    function nu(e, r, c) {
      var g = wi(r), x;
      switch (g) {
        case ci:
          x = Rr;
          break;
        case Xr:
          x = pc;
          break;
        case Ts:
        default:
          x = Rs;
          break;
      }
      return x.bind(null, r, c, e);
    }
    function Rr(e, r, c, g) {
      var x = wa(), R = Jn.transition;
      Jn.transition = null;
      try {
        Tr(ci), Rs(e, r, c, g);
      } finally {
        Tr(x), Jn.transition = R;
      }
    }
    function pc(e, r, c, g) {
      var x = wa(), R = Jn.transition;
      Jn.transition = null;
      try {
        Tr(Xr), Rs(e, r, c, g);
      } finally {
        Tr(x), Jn.transition = R;
      }
    }
    function Rs(e, r, c, g) {
      lr && jd(e, r, c, g);
    }
    function jd(e, r, c, g) {
      var x = tl(e, r, c, g);
      if (x === null) {
        eb(e, r, g, ru, c), Lv(e, g);
        return;
      }
      if (Mv(x, e, r, c, g)) {
        g.stopPropagation();
        return;
      }
      if (Lv(e, g), r & Io && Rv(e)) {
        for (; x !== null; ) {
          var R = fu(x);
          R !== null && Kl(R);
          var _ = tl(e, r, c, g);
          if (_ === null && eb(e, r, g, ru, c), _ === x)
            break;
          x = _;
        }
        x !== null && g.stopPropagation();
        return;
      }
      eb(e, r, g, null, c);
    }
    var ru = null;
    function tl(e, r, c, g) {
      ru = null;
      var x = nd(g), R = wc(x);
      if (R !== null) {
        var _ = ta(R);
        if (_ === null)
          R = null;
        else {
          var H = _.tag;
          if (H === re) {
            var W = mh(_);
            if (W !== null)
              return W;
            R = null;
          } else if (H === q) {
            var J = _.stateNode;
            if (Er(J))
              return od(_);
            R = null;
          } else
            _ !== R && (R = null);
        }
      }
      return ru = R, null;
    }
    function wi(e) {
      switch (e) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return ci;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Xr;
        case "message": {
          var r = bh();
          switch (r) {
            case dd:
              return ci;
            case ra:
              return Xr;
            case qa:
            case fd:
              return Ts;
            case io:
              return oc;
            default:
              return Ts;
          }
        }
        default:
          return Ts;
      }
    }
    function Wh(e, r, c) {
      return e.addEventListener(r, c, !1), c;
    }
    function iu(e, r, c) {
      return e.addEventListener(r, c, !0), c;
    }
    function Ls(e, r, c, g) {
      return e.addEventListener(r, c, {
        capture: !0,
        passive: g
      }), c;
    }
    function Ud(e, r, c, g) {
      return e.addEventListener(r, c, {
        passive: g
      }), c;
    }
    var nl = null, Ja = null, po = null;
    function go(e) {
      return nl = e, Ja = Wd(), !0;
    }
    function Bd() {
      nl = null, Ja = null, po = null;
    }
    function au() {
      if (po)
        return po;
      var e, r = Ja, c = r.length, g, x = Wd(), R = x.length;
      for (e = 0; e < c && r[e] === x[e]; e++)
        ;
      var _ = c - e;
      for (g = 1; g <= _ && r[c - g] === x[R - g]; g++)
        ;
      var H = g > 1 ? 1 - g : void 0;
      return po = x.slice(e, H), po;
    }
    function Wd() {
      return "value" in nl ? nl.value : nl.textContent;
    }
    function rl(e) {
      var r, c = e.keyCode;
      return "charCode" in e ? (r = e.charCode, r === 0 && c === 13 && (r = 13)) : r = c, r === 10 && (r = 13), r >= 32 || r === 13 ? r : 0;
    }
    function il() {
      return !0;
    }
    function hi() {
      return !1;
    }
    function wr(e) {
      function r(c, g, x, R, _) {
        this._reactName = c, this._targetInst = x, this.type = g, this.nativeEvent = R, this.target = _, this.currentTarget = null;
        for (var H in e)
          if (e.hasOwnProperty(H)) {
            var W = e[H];
            W ? this[H] = W(R) : this[H] = R[H];
          }
        var J = R.defaultPrevented != null ? R.defaultPrevented : R.returnValue === !1;
        return J ? this.isDefaultPrevented = il : this.isDefaultPrevented = hi, this.isPropagationStopped = hi, this;
      }
      return p(r.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var c = this.nativeEvent;
          c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = il);
        },
        stopPropagation: function() {
          var c = this.nativeEvent;
          c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = il);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: il
      }), r;
    }
    var pi = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(e) {
        return e.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, gi = wr(pi), su = p({}, pi, {
      view: 0,
      detail: 0
    }), Xh = wr(su), gc, Vh, ka;
    function Ov(e) {
      e !== ka && (ka && e.type === "mousemove" ? (gc = e.screenX - ka.screenX, Vh = e.screenY - ka.screenY) : (gc = 0, Vh = 0), ka = e);
    }
    var ou = p({}, su, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Gd,
      button: 0,
      buttons: 0,
      relatedTarget: function(e) {
        return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
      },
      movementX: function(e) {
        return "movementX" in e ? e.movementX : (Ov(e), gc);
      },
      movementY: function(e) {
        return "movementY" in e ? e.movementY : Vh;
      }
    }), vo = wr(ou), Gh = p({}, ou, {
      dataTransfer: 0
    }), al = wr(Gh), _v = p({}, su, {
      relatedTarget: 0
    }), Xd = wr(_v), $h = p({}, pi, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Vd = wr($h), Nx = p({}, pi, {
      clipboardData: function(e) {
        return "clipboardData" in e ? e.clipboardData : window.clipboardData;
      }
    }), zx = wr(Nx), Pv = p({}, pi, {
      data: 0
    }), qh = wr(Pv), sl = qh, Ix = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, lu = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function Nv(e) {
      if (e.key) {
        var r = Ix[e.key] || e.key;
        if (r !== "Unidentified")
          return r;
      }
      if (e.type === "keypress") {
        var c = rl(e);
        return c === 13 ? "Enter" : String.fromCharCode(c);
      }
      return e.type === "keydown" || e.type === "keyup" ? lu[e.keyCode] || "Unidentified" : "";
    }
    var ur = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function Fx(e) {
      var r = this, c = r.nativeEvent;
      if (c.getModifierState)
        return c.getModifierState(e);
      var g = ur[e];
      return g ? !!c[g] : !1;
    }
    function Gd(e) {
      return Fx;
    }
    var Yx = p({}, su, {
      key: Nv,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Gd,
      // Legacy Interface
      charCode: function(e) {
        return e.type === "keypress" ? rl(e) : 0;
      },
      keyCode: function(e) {
        return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      },
      which: function(e) {
        return e.type === "keypress" ? rl(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
      }
    }), Hx = wr(Yx), zv = p({}, ou, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), Zh = wr(zv), jx = p({}, su, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Gd
    }), Ca = wr(jx), Qh = p({}, pi, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Ux = wr(Qh), mo = p({}, ou, {
      deltaX: function(e) {
        return "deltaX" in e ? e.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in e ? -e.wheelDeltaX : 0
        );
      },
      deltaY: function(e) {
        return "deltaY" in e ? e.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in e ? -e.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in e ? -e.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), $d = wr(mo), ol = [9, 13, 27, 32], vc = 229, mc = pn && "CompositionEvent" in window, ll = null;
    pn && "documentMode" in document && (ll = document.documentMode);
    var Bx = pn && "TextEvent" in window && !ll, qd = pn && (!mc || ll && ll > 8 && ll <= 11), Iv = 32, Kh = String.fromCharCode(Iv);
    function Fv() {
      vn("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), vn("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), vn("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), vn("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var yc = !1;
    function Zd(e) {
      return (e.ctrlKey || e.altKey || e.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(e.ctrlKey && e.altKey);
    }
    function Yv(e) {
      switch (e) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function Jh(e, r) {
      return e === "keydown" && r.keyCode === vc;
    }
    function Hv(e, r) {
      switch (e) {
        case "keyup":
          return ol.indexOf(r.keyCode) !== -1;
        case "keydown":
          return r.keyCode !== vc;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function ep(e) {
      var r = e.detail;
      return typeof r == "object" && "data" in r ? r.data : null;
    }
    function Qd(e) {
      return e.locale === "ko";
    }
    var Ms = !1;
    function tp(e, r, c, g, x) {
      var R, _;
      if (mc ? R = Yv(r) : Ms ? Hv(r, g) && (R = "onCompositionEnd") : Jh(r, g) && (R = "onCompositionStart"), !R)
        return null;
      qd && !Qd(g) && (!Ms && R === "onCompositionStart" ? Ms = go(x) : R === "onCompositionEnd" && Ms && (_ = au()));
      var H = Xv(c, R);
      if (H.length > 0) {
        var W = new qh(R, r, null, g, x);
        if (e.push({
          event: W,
          listeners: H
        }), _)
          W.data = _;
        else {
          var J = ep(g);
          J !== null && (W.data = J);
        }
      }
    }
    function Kd(e, r) {
      switch (e) {
        case "compositionend":
          return ep(r);
        case "keypress":
          var c = r.which;
          return c !== Iv ? null : (yc = !0, Kh);
        case "textInput":
          var g = r.data;
          return g === Kh && yc ? null : g;
        default:
          return null;
      }
    }
    function jv(e, r) {
      if (Ms) {
        if (e === "compositionend" || !mc && Hv(e, r)) {
          var c = au();
          return Bd(), Ms = !1, c;
        }
        return null;
      }
      switch (e) {
        case "paste":
          return null;
        case "keypress":
          if (!Zd(r)) {
            if (r.char && r.char.length > 1)
              return r.char;
            if (r.which)
              return String.fromCharCode(r.which);
          }
          return null;
        case "compositionend":
          return qd && !Qd(r) ? null : r.data;
        default:
          return null;
      }
    }
    function Wx(e, r, c, g, x) {
      var R;
      if (Bx ? R = Kd(r, g) : R = jv(r, g), !R)
        return null;
      var _ = Xv(c, "onBeforeInput");
      if (_.length > 0) {
        var H = new sl("onBeforeInput", "beforeinput", null, g, x);
        e.push({
          event: H,
          listeners: _
        }), H.data = R;
      }
    }
    function Jd(e, r, c, g, x, R, _) {
      tp(e, r, c, g, x), Wx(e, r, c, g, x);
    }
    var Xx = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function uu(e) {
      var r = e && e.nodeName && e.nodeName.toLowerCase();
      return r === "input" ? !!Xx[e.type] : r === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function Vx(e) {
      if (!pn)
        return !1;
      var r = "on" + e, c = r in document;
      if (!c) {
        var g = document.createElement("div");
        g.setAttribute(r, "return;"), c = typeof g[r] == "function";
      }
      return c;
    }
    function ef() {
      vn("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function a(e, r, c, g) {
      rd(g);
      var x = Xv(r, "onChange");
      if (x.length > 0) {
        var R = new gi("onChange", "change", null, c, g);
        e.push({
          event: R,
          listeners: x
        });
      }
    }
    var l = null, m = null;
    function k(e) {
      var r = e.nodeName && e.nodeName.toLowerCase();
      return r === "select" || r === "input" && e.type === "file";
    }
    function D(e) {
      var r = [];
      a(r, m, e, nd(e)), uh(z, r);
    }
    function z(e) {
      RS(e, 0);
    }
    function $(e) {
      var r = of(e);
      if (Eg(r))
        return e;
    }
    function ie(e, r) {
      if (e === "change")
        return r;
    }
    var ce = !1;
    pn && (ce = Vx("input") && (!document.documentMode || document.documentMode > 9));
    function Ee(e, r) {
      l = e, m = r, l.attachEvent("onpropertychange", Be);
    }
    function He() {
      l && (l.detachEvent("onpropertychange", Be), l = null, m = null);
    }
    function Be(e) {
      e.propertyName === "value" && $(m) && D(e);
    }
    function Fe(e, r, c) {
      e === "focusin" ? (He(), Ee(r, c)) : e === "focusout" && He();
    }
    function lt(e, r) {
      if (e === "selectionchange" || e === "keyup" || e === "keydown")
        return $(m);
    }
    function xt(e) {
      var r = e.nodeName;
      return r && r.toLowerCase() === "input" && (e.type === "checkbox" || e.type === "radio");
    }
    function Ct(e, r) {
      if (e === "click")
        return $(r);
    }
    function hr(e, r) {
      if (e === "input" || e === "change")
        return $(r);
    }
    function me(e) {
      var r = e._wrapperState;
      !r || !r.controlled || e.type !== "number" || Zs(e, "number", e.value);
    }
    function pe(e, r, c, g, x, R, _) {
      var H = c ? of(c) : window, W, J;
      if (k(H) ? W = ie : uu(H) ? ce ? W = hr : (W = lt, J = Fe) : xt(H) && (W = Ct), W) {
        var ne = W(r, c);
        if (ne) {
          a(e, ne, g, x);
          return;
        }
      }
      J && J(r, H, c), r === "focusout" && me(H);
    }
    function Se() {
      qe("onMouseEnter", ["mouseout", "mouseover"]), qe("onMouseLeave", ["mouseout", "mouseover"]), qe("onPointerEnter", ["pointerout", "pointerover"]), qe("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function $e(e, r, c, g, x, R, _) {
      var H = r === "mouseover" || r === "pointerover", W = r === "mouseout" || r === "pointerout";
      if (H && !iv(g)) {
        var J = g.relatedTarget || g.fromElement;
        if (J && (wc(J) || gp(J)))
          return;
      }
      if (!(!W && !H)) {
        var ne;
        if (x.window === x)
          ne = x;
        else {
          var ge = x.ownerDocument;
          ge ? ne = ge.defaultView || ge.parentWindow : ne = window;
        }
        var he, Ae;
        if (W) {
          var Te = g.relatedTarget || g.toElement;
          if (he = c, Ae = Te ? wc(Te) : null, Ae !== null) {
            var De = ta(Ae);
            (Ae !== De || Ae.tag !== se && Ae.tag !== ae) && (Ae = null);
          }
        } else
          he = null, Ae = c;
        if (he !== Ae) {
          var ht = vo, Pt = "onMouseLeave", Tt = "onMouseEnter", hn = "mouse";
          (r === "pointerout" || r === "pointerover") && (ht = Zh, Pt = "onPointerLeave", Tt = "onPointerEnter", hn = "pointer");
          var on = he == null ? ne : of(he), xe = Ae == null ? ne : of(Ae), Oe = new ht(Pt, hn + "leave", he, g, x);
          Oe.target = on, Oe.relatedTarget = xe;
          var be = null, Xe = wc(x);
          if (Xe === c) {
            var pt = new ht(Tt, hn + "enter", Ae, g, x);
            pt.target = xe, pt.relatedTarget = on, be = pt;
          }
          gL(e, Oe, be, he, Ae);
        }
      }
    }
    function At(e, r) {
      return e === r && (e !== 0 || 1 / e === 1 / r) || e !== e && r !== r;
    }
    var bt = typeof Object.is == "function" ? Object.is : At;
    function Mt(e, r) {
      if (bt(e, r))
        return !0;
      if (typeof e != "object" || e === null || typeof r != "object" || r === null)
        return !1;
      var c = Object.keys(e), g = Object.keys(r);
      if (c.length !== g.length)
        return !1;
      for (var x = 0; x < c.length; x++) {
        var R = c[x];
        if (!jn.call(r, R) || !bt(e[R], r[R]))
          return !1;
      }
      return !0;
    }
    function Xt(e) {
      for (; e && e.firstChild; )
        e = e.firstChild;
      return e;
    }
    function Yr(e) {
      for (; e; ) {
        if (e.nextSibling)
          return e.nextSibling;
        e = e.parentNode;
      }
    }
    function gn(e, r) {
      for (var c = Xt(e), g = 0, x = 0; c; ) {
        if (c.nodeType === ms) {
          if (x = g + c.textContent.length, g <= r && x >= r)
            return {
              node: c,
              offset: r - g
            };
          g = x;
        }
        c = Xt(Yr(c));
      }
    }
    function yo(e) {
      var r = e.ownerDocument, c = r && r.defaultView || window, g = c.getSelection && c.getSelection();
      if (!g || g.rangeCount === 0)
        return null;
      var x = g.anchorNode, R = g.anchorOffset, _ = g.focusNode, H = g.focusOffset;
      try {
        x.nodeType, _.nodeType;
      } catch {
        return null;
      }
      return Gx(e, x, R, _, H);
    }
    function Gx(e, r, c, g, x) {
      var R = 0, _ = -1, H = -1, W = 0, J = 0, ne = e, ge = null;
      e:
        for (; ; ) {
          for (var he = null; ne === r && (c === 0 || ne.nodeType === ms) && (_ = R + c), ne === g && (x === 0 || ne.nodeType === ms) && (H = R + x), ne.nodeType === ms && (R += ne.nodeValue.length), (he = ne.firstChild) !== null; )
            ge = ne, ne = he;
          for (; ; ) {
            if (ne === e)
              break e;
            if (ge === r && ++W === c && (_ = R), ge === g && ++J === x && (H = R), (he = ne.nextSibling) !== null)
              break;
            ne = ge, ge = ne.parentNode;
          }
          ne = he;
        }
      return _ === -1 || H === -1 ? null : {
        start: _,
        end: H
      };
    }
    function ZR(e, r) {
      var c = e.ownerDocument || document, g = c && c.defaultView || window;
      if (g.getSelection) {
        var x = g.getSelection(), R = e.textContent.length, _ = Math.min(r.start, R), H = r.end === void 0 ? _ : Math.min(r.end, R);
        if (!x.extend && _ > H) {
          var W = H;
          H = _, _ = W;
        }
        var J = gn(e, _), ne = gn(e, H);
        if (J && ne) {
          if (x.rangeCount === 1 && x.anchorNode === J.node && x.anchorOffset === J.offset && x.focusNode === ne.node && x.focusOffset === ne.offset)
            return;
          var ge = c.createRange();
          ge.setStart(J.node, J.offset), x.removeAllRanges(), _ > H ? (x.addRange(ge), x.extend(ne.node, ne.offset)) : (ge.setEnd(ne.node, ne.offset), x.addRange(ge));
        }
      }
    }
    function vS(e) {
      return e && e.nodeType === ms;
    }
    function mS(e, r) {
      return !e || !r ? !1 : e === r ? !0 : vS(e) ? !1 : vS(r) ? mS(e, r.parentNode) : "contains" in e ? e.contains(r) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(r) & 16) : !1;
    }
    function QR(e) {
      return e && e.ownerDocument && mS(e.ownerDocument.documentElement, e);
    }
    function KR(e) {
      try {
        return typeof e.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function yS() {
      for (var e = window, r = Bc(); r instanceof e.HTMLIFrameElement; ) {
        if (KR(r))
          e = r.contentWindow;
        else
          return r;
        r = Bc(e.document);
      }
      return r;
    }
    function $x(e) {
      var r = e && e.nodeName && e.nodeName.toLowerCase();
      return r && (r === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || r === "textarea" || e.contentEditable === "true");
    }
    function JR() {
      var e = yS();
      return {
        focusedElem: e,
        selectionRange: $x(e) ? tL(e) : null
      };
    }
    function eL(e) {
      var r = yS(), c = e.focusedElem, g = e.selectionRange;
      if (r !== c && QR(c)) {
        g !== null && $x(c) && nL(c, g);
        for (var x = [], R = c; R = R.parentNode; )
          R.nodeType === _i && x.push({
            element: R,
            left: R.scrollLeft,
            top: R.scrollTop
          });
        typeof c.focus == "function" && c.focus();
        for (var _ = 0; _ < x.length; _++) {
          var H = x[_];
          H.element.scrollLeft = H.left, H.element.scrollTop = H.top;
        }
      }
    }
    function tL(e) {
      var r;
      return "selectionStart" in e ? r = {
        start: e.selectionStart,
        end: e.selectionEnd
      } : r = yo(e), r || {
        start: 0,
        end: 0
      };
    }
    function nL(e, r) {
      var c = r.start, g = r.end;
      g === void 0 && (g = c), "selectionStart" in e ? (e.selectionStart = c, e.selectionEnd = Math.min(g, e.value.length)) : ZR(e, r);
    }
    var rL = pn && "documentMode" in document && document.documentMode <= 11;
    function iL() {
      vn("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var tf = null, qx = null, np = null, Zx = !1;
    function aL(e) {
      if ("selectionStart" in e && $x(e))
        return {
          start: e.selectionStart,
          end: e.selectionEnd
        };
      var r = e.ownerDocument && e.ownerDocument.defaultView || window, c = r.getSelection();
      return {
        anchorNode: c.anchorNode,
        anchorOffset: c.anchorOffset,
        focusNode: c.focusNode,
        focusOffset: c.focusOffset
      };
    }
    function sL(e) {
      return e.window === e ? e.document : e.nodeType === Ia ? e : e.ownerDocument;
    }
    function xS(e, r, c) {
      var g = sL(c);
      if (!(Zx || tf == null || tf !== Bc(g))) {
        var x = aL(tf);
        if (!np || !Mt(np, x)) {
          np = x;
          var R = Xv(qx, "onSelect");
          if (R.length > 0) {
            var _ = new gi("onSelect", "select", null, r, c);
            e.push({
              event: _,
              listeners: R
            }), _.target = tf;
          }
        }
      }
    }
    function oL(e, r, c, g, x, R, _) {
      var H = c ? of(c) : window;
      switch (r) {
        case "focusin":
          (uu(H) || H.contentEditable === "true") && (tf = H, qx = c, np = null);
          break;
        case "focusout":
          tf = null, qx = null, np = null;
          break;
        case "mousedown":
          Zx = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Zx = !1, xS(e, g, x);
          break;
        case "selectionchange":
          if (rL)
            break;
        case "keydown":
        case "keyup":
          xS(e, g, x);
      }
    }
    function Uv(e, r) {
      var c = {};
      return c[e.toLowerCase()] = r.toLowerCase(), c["Webkit" + e] = "webkit" + r, c["Moz" + e] = "moz" + r, c;
    }
    var nf = {
      animationend: Uv("Animation", "AnimationEnd"),
      animationiteration: Uv("Animation", "AnimationIteration"),
      animationstart: Uv("Animation", "AnimationStart"),
      transitionend: Uv("Transition", "TransitionEnd")
    }, Qx = {}, bS = {};
    pn && (bS = document.createElement("div").style, "AnimationEvent" in window || (delete nf.animationend.animation, delete nf.animationiteration.animation, delete nf.animationstart.animation), "TransitionEvent" in window || delete nf.transitionend.transition);
    function Bv(e) {
      if (Qx[e])
        return Qx[e];
      if (!nf[e])
        return e;
      var r = nf[e];
      for (var c in r)
        if (r.hasOwnProperty(c) && c in bS)
          return Qx[e] = r[c];
      return e;
    }
    var wS = Bv("animationend"), SS = Bv("animationiteration"), kS = Bv("animationstart"), CS = Bv("transitionend"), AS = /* @__PURE__ */ new Map(), TS = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function cu(e, r) {
      AS.set(e, r), vn(r, [e]);
    }
    function lL() {
      for (var e = 0; e < TS.length; e++) {
        var r = TS[e], c = r.toLowerCase(), g = r[0].toUpperCase() + r.slice(1);
        cu(c, "on" + g);
      }
      cu(wS, "onAnimationEnd"), cu(SS, "onAnimationIteration"), cu(kS, "onAnimationStart"), cu("dblclick", "onDoubleClick"), cu("focusin", "onFocus"), cu("focusout", "onBlur"), cu(CS, "onTransitionEnd");
    }
    function uL(e, r, c, g, x, R, _) {
      var H = AS.get(r);
      if (H !== void 0) {
        var W = gi, J = r;
        switch (r) {
          case "keypress":
            if (rl(g) === 0)
              return;
          case "keydown":
          case "keyup":
            W = Hx;
            break;
          case "focusin":
            J = "focus", W = Xd;
            break;
          case "focusout":
            J = "blur", W = Xd;
            break;
          case "beforeblur":
          case "afterblur":
            W = Xd;
            break;
          case "click":
            if (g.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            W = vo;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            W = al;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            W = Ca;
            break;
          case wS:
          case SS:
          case kS:
            W = Vd;
            break;
          case CS:
            W = Ux;
            break;
          case "scroll":
            W = Xh;
            break;
          case "wheel":
            W = $d;
            break;
          case "copy":
          case "cut":
          case "paste":
            W = zx;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            W = Zh;
            break;
        }
        var ne = (R & Io) !== 0;
        {
          var ge = !ne && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          r === "scroll", he = hL(c, H, g.type, ne, ge);
          if (he.length > 0) {
            var Ae = new W(H, J, null, g, x);
            e.push({
              event: Ae,
              listeners: he
            });
          }
        }
      }
    }
    lL(), Se(), ef(), iL(), Fv();
    function cL(e, r, c, g, x, R, _) {
      uL(e, r, c, g, x, R);
      var H = (R & kx) === 0;
      H && ($e(e, r, c, g, x), pe(e, r, c, g, x), oL(e, r, c, g, x), Jd(e, r, c, g, x));
    }
    var rp = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], Kx = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(rp));
    function ES(e, r, c) {
      var g = e.type || "unknown-event";
      e.currentTarget = c, ws(g, r, void 0, e), e.currentTarget = null;
    }
    function dL(e, r, c) {
      var g;
      if (c)
        for (var x = r.length - 1; x >= 0; x--) {
          var R = r[x], _ = R.instance, H = R.currentTarget, W = R.listener;
          if (_ !== g && e.isPropagationStopped())
            return;
          ES(e, W, H), g = _;
        }
      else
        for (var J = 0; J < r.length; J++) {
          var ne = r[J], ge = ne.instance, he = ne.currentTarget, Ae = ne.listener;
          if (ge !== g && e.isPropagationStopped())
            return;
          ES(e, Ae, he), g = ge;
        }
    }
    function RS(e, r) {
      for (var c = (r & Io) !== 0, g = 0; g < e.length; g++) {
        var x = e[g], R = x.event, _ = x.listeners;
        dL(R, _, c);
      }
      hh();
    }
    function fL(e, r, c, g, x) {
      var R = nd(c), _ = [];
      cL(_, e, g, c, R, r), RS(_, r);
    }
    function er(e, r) {
      Kx.has(e) || T('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', e);
      var c = !1, g = UM(r), x = vL(e, c);
      g.has(x) || (LS(r, e, Bu, c), g.add(x));
    }
    function Jx(e, r, c) {
      Kx.has(e) && !r && T('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', e);
      var g = 0;
      r && (g |= Io), LS(c, e, g, r);
    }
    var Wv = "_reactListening" + Math.random().toString(36).slice(2);
    function ip(e) {
      if (!e[Wv]) {
        e[Wv] = !0, Rt.forEach(function(c) {
          c !== "selectionchange" && (Kx.has(c) || Jx(c, !1, e), Jx(c, !0, e));
        });
        var r = e.nodeType === Ia ? e : e.ownerDocument;
        r !== null && (r[Wv] || (r[Wv] = !0, Jx("selectionchange", !1, r)));
      }
    }
    function LS(e, r, c, g, x) {
      var R = nu(e, r, c), _ = void 0;
      $u && (r === "touchstart" || r === "touchmove" || r === "wheel") && (_ = !0), e = e, g ? _ !== void 0 ? Ls(e, r, R, _) : iu(e, r, R) : _ !== void 0 ? Ud(e, r, R, _) : Wh(e, r, R);
    }
    function MS(e, r) {
      return e === r || e.nodeType === xr && e.parentNode === r;
    }
    function eb(e, r, c, g, x) {
      var R = g;
      if (!(r & xs) && !(r & Bu)) {
        var _ = x;
        if (g !== null) {
          var H = g;
          e:
            for (; ; ) {
              if (H === null)
                return;
              var W = H.tag;
              if (W === q || W === te) {
                var J = H.stateNode.containerInfo;
                if (MS(J, _))
                  break;
                if (W === te)
                  for (var ne = H.return; ne !== null; ) {
                    var ge = ne.tag;
                    if (ge === q || ge === te) {
                      var he = ne.stateNode.containerInfo;
                      if (MS(he, _))
                        return;
                    }
                    ne = ne.return;
                  }
                for (; J !== null; ) {
                  var Ae = wc(J);
                  if (Ae === null)
                    return;
                  var Te = Ae.tag;
                  if (Te === se || Te === ae) {
                    H = R = Ae;
                    continue e;
                  }
                  J = J.parentNode;
                }
              }
              H = H.return;
            }
        }
      }
      uh(function() {
        return fL(e, r, c, R);
      });
    }
    function ap(e, r, c) {
      return {
        instance: e,
        listener: r,
        currentTarget: c
      };
    }
    function hL(e, r, c, g, x, R) {
      for (var _ = r !== null ? r + "Capture" : null, H = g ? _ : r, W = [], J = e, ne = null; J !== null; ) {
        var ge = J, he = ge.stateNode, Ae = ge.tag;
        if (Ae === se && he !== null && (ne = he, H !== null)) {
          var Te = Yo(J, H);
          Te != null && W.push(ap(J, Te, ne));
        }
        if (x)
          break;
        J = J.return;
      }
      return W;
    }
    function Xv(e, r) {
      for (var c = r + "Capture", g = [], x = e; x !== null; ) {
        var R = x, _ = R.stateNode, H = R.tag;
        if (H === se && _ !== null) {
          var W = _, J = Yo(x, c);
          J != null && g.unshift(ap(x, J, W));
          var ne = Yo(x, r);
          ne != null && g.push(ap(x, ne, W));
        }
        x = x.return;
      }
      return g;
    }
    function rf(e) {
      if (e === null)
        return null;
      do
        e = e.return;
      while (e && e.tag !== se);
      return e || null;
    }
    function pL(e, r) {
      for (var c = e, g = r, x = 0, R = c; R; R = rf(R))
        x++;
      for (var _ = 0, H = g; H; H = rf(H))
        _++;
      for (; x - _ > 0; )
        c = rf(c), x--;
      for (; _ - x > 0; )
        g = rf(g), _--;
      for (var W = x; W--; ) {
        if (c === g || g !== null && c === g.alternate)
          return c;
        c = rf(c), g = rf(g);
      }
      return null;
    }
    function DS(e, r, c, g, x) {
      for (var R = r._reactName, _ = [], H = c; H !== null && H !== g; ) {
        var W = H, J = W.alternate, ne = W.stateNode, ge = W.tag;
        if (J !== null && J === g)
          break;
        if (ge === se && ne !== null) {
          var he = ne;
          if (x) {
            var Ae = Yo(H, R);
            Ae != null && _.unshift(ap(H, Ae, he));
          } else if (!x) {
            var Te = Yo(H, R);
            Te != null && _.push(ap(H, Te, he));
          }
        }
        H = H.return;
      }
      _.length !== 0 && e.push({
        event: r,
        listeners: _
      });
    }
    function gL(e, r, c, g, x) {
      var R = g && x ? pL(g, x) : null;
      g !== null && DS(e, r, g, R, !1), x !== null && c !== null && DS(e, c, x, R, !0);
    }
    function vL(e, r) {
      return e + "__" + (r ? "capture" : "bubble");
    }
    var Aa = !1, sp = "dangerouslySetInnerHTML", Vv = "suppressContentEditableWarning", du = "suppressHydrationWarning", OS = "autoFocus", xc = "children", bc = "style", Gv = "__html", tb, $v, op, _S, qv, PS, NS;
    tb = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, $v = function(e, r) {
      td(e, r), ih(e, r), rv(e, r, {
        registrationNameDependencies: jt,
        possibleRegistrationNames: Ut
      });
    }, PS = pn && !document.documentMode, op = function(e, r, c) {
      if (!Aa) {
        var g = Zv(c), x = Zv(r);
        x !== g && (Aa = !0, T("Prop `%s` did not match. Server: %s Client: %s", e, JSON.stringify(x), JSON.stringify(g)));
      }
    }, _S = function(e) {
      if (!Aa) {
        Aa = !0;
        var r = [];
        e.forEach(function(c) {
          r.push(c);
        }), T("Extra attributes from the server: %s", r);
      }
    }, qv = function(e, r) {
      r === !1 ? T("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", e, e, e) : T("Expected `%s` listener to be a function, instead got a value of `%s` type.", e, typeof r);
    }, NS = function(e, r) {
      var c = e.namespaceURI === vs ? e.ownerDocument.createElement(e.tagName) : e.ownerDocument.createElementNS(e.namespaceURI, e.tagName);
      return c.innerHTML = r, c.innerHTML;
    };
    var mL = /\r\n?/g, yL = /\u0000|\uFFFD/g;
    function Zv(e) {
      Qi(e);
      var r = typeof e == "string" ? e : "" + e;
      return r.replace(mL, `
`).replace(yL, "");
    }
    function Qv(e, r, c, g) {
      var x = Zv(r), R = Zv(e);
      if (R !== x && (g && (Aa || (Aa = !0, T('Text content did not match. Server: "%s" Client: "%s"', R, x))), c && an))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function zS(e) {
      return e.nodeType === Ia ? e : e.ownerDocument;
    }
    function xL() {
    }
    function Kv(e) {
      e.onclick = xL;
    }
    function bL(e, r, c, g, x) {
      for (var R in g)
        if (g.hasOwnProperty(R)) {
          var _ = g[R];
          if (R === bc)
            _ && Object.freeze(_), Gg(r, _);
          else if (R === sp) {
            var H = _ ? _[Gv] : void 0;
            H != null && zg(r, H);
          } else if (R === xc)
            if (typeof _ == "string") {
              var W = e !== "textarea" || _ !== "";
              W && Qc(r, _);
            } else
              typeof _ == "number" && Qc(r, "" + _);
          else
            R === Vv || R === du || R === OS || (jt.hasOwnProperty(R) ? _ != null && (typeof _ != "function" && qv(R, _), R === "onScroll" && er("scroll", r)) : _ != null && Oi(r, R, _, x));
        }
    }
    function wL(e, r, c, g) {
      for (var x = 0; x < r.length; x += 2) {
        var R = r[x], _ = r[x + 1];
        R === bc ? Gg(e, _) : R === sp ? zg(e, _) : R === xc ? Qc(e, _) : Oi(e, R, _, g);
      }
    }
    function SL(e, r, c, g) {
      var x, R = zS(c), _, H = g;
      if (H === vs && (H = qc(e)), H === vs) {
        if (x = ys(e, r), !x && e !== e.toLowerCase() && T("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", e), e === "script") {
          var W = R.createElement("div");
          W.innerHTML = "<script><\/script>";
          var J = W.firstChild;
          _ = W.removeChild(J);
        } else if (typeof r.is == "string")
          _ = R.createElement(e, {
            is: r.is
          });
        else if (_ = R.createElement(e), e === "select") {
          var ne = _;
          r.multiple ? ne.multiple = !0 : r.size && (ne.size = r.size);
        }
      } else
        _ = R.createElementNS(H, e);
      return H === vs && !x && Object.prototype.toString.call(_) === "[object HTMLUnknownElement]" && !jn.call(tb, e) && (tb[e] = !0, T("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", e)), _;
    }
    function kL(e, r) {
      return zS(r).createTextNode(e);
    }
    function CL(e, r, c, g) {
      var x = ys(r, c);
      $v(r, c);
      var R;
      switch (r) {
        case "dialog":
          er("cancel", e), er("close", e), R = c;
          break;
        case "iframe":
        case "object":
        case "embed":
          er("load", e), R = c;
          break;
        case "video":
        case "audio":
          for (var _ = 0; _ < rp.length; _++)
            er(rp[_], e);
          R = c;
          break;
        case "source":
          er("error", e), R = c;
          break;
        case "img":
        case "image":
        case "link":
          er("error", e), er("load", e), R = c;
          break;
        case "details":
          er("toggle", e), R = c;
          break;
        case "input":
          Iu(e, c), R = zu(e, c), er("invalid", e);
          break;
        case "option":
          Gc(e, c), R = c;
          break;
        case "select":
          Og(e, c), R = Gf(e, c), er("invalid", e);
          break;
        case "textarea":
          _g(e, c), R = qf(e, c), er("invalid", e);
          break;
        default:
          R = c;
      }
      switch (Jc(r, R), bL(r, e, g, R, x), r) {
        case "input":
          Po(e), Fu(e, c, !1);
          break;
        case "textarea":
          Po(e), Ng(e);
          break;
        case "option":
          Vf(e, c);
          break;
        case "select":
          fx(e, c);
          break;
        default:
          typeof R.onClick == "function" && Kv(e);
          break;
      }
    }
    function AL(e, r, c, g, x) {
      $v(r, g);
      var R = null, _, H;
      switch (r) {
        case "input":
          _ = zu(e, c), H = zu(e, g), R = [];
          break;
        case "select":
          _ = Gf(e, c), H = Gf(e, g), R = [];
          break;
        case "textarea":
          _ = qf(e, c), H = qf(e, g), R = [];
          break;
        default:
          _ = c, H = g, typeof _.onClick != "function" && typeof H.onClick == "function" && Kv(e);
          break;
      }
      Jc(r, H);
      var W, J, ne = null;
      for (W in _)
        if (!(H.hasOwnProperty(W) || !_.hasOwnProperty(W) || _[W] == null))
          if (W === bc) {
            var ge = _[W];
            for (J in ge)
              ge.hasOwnProperty(J) && (ne || (ne = {}), ne[J] = "");
          } else
            W === sp || W === xc || W === Vv || W === du || W === OS || (jt.hasOwnProperty(W) ? R || (R = []) : (R = R || []).push(W, null));
      for (W in H) {
        var he = H[W], Ae = _ != null ? _[W] : void 0;
        if (!(!H.hasOwnProperty(W) || he === Ae || he == null && Ae == null))
          if (W === bc)
            if (he && Object.freeze(he), Ae) {
              for (J in Ae)
                Ae.hasOwnProperty(J) && (!he || !he.hasOwnProperty(J)) && (ne || (ne = {}), ne[J] = "");
              for (J in he)
                he.hasOwnProperty(J) && Ae[J] !== he[J] && (ne || (ne = {}), ne[J] = he[J]);
            } else
              ne || (R || (R = []), R.push(W, ne)), ne = he;
          else if (W === sp) {
            var Te = he ? he[Gv] : void 0, De = Ae ? Ae[Gv] : void 0;
            Te != null && De !== Te && (R = R || []).push(W, Te);
          } else
            W === xc ? (typeof he == "string" || typeof he == "number") && (R = R || []).push(W, "" + he) : W === Vv || W === du || (jt.hasOwnProperty(W) ? (he != null && (typeof he != "function" && qv(W, he), W === "onScroll" && er("scroll", e)), !R && Ae !== he && (R = [])) : (R = R || []).push(W, he));
      }
      return ne && (ju(ne, H[bc]), (R = R || []).push(bc, ne)), R;
    }
    function TL(e, r, c, g, x) {
      c === "input" && x.type === "radio" && x.name != null && Xf(e, x);
      var R = ys(c, g), _ = ys(c, x);
      switch (wL(e, r, R, _), c) {
        case "input":
          _l(e, x);
          break;
        case "textarea":
          Pg(e, x);
          break;
        case "select":
          hx(e, x);
          break;
      }
    }
    function EL(e) {
      {
        var r = e.toLowerCase();
        return ed.hasOwnProperty(r) && ed[r] || null;
      }
    }
    function RL(e, r, c, g, x, R, _) {
      var H, W;
      switch (H = ys(r, c), $v(r, c), r) {
        case "dialog":
          er("cancel", e), er("close", e);
          break;
        case "iframe":
        case "object":
        case "embed":
          er("load", e);
          break;
        case "video":
        case "audio":
          for (var J = 0; J < rp.length; J++)
            er(rp[J], e);
          break;
        case "source":
          er("error", e);
          break;
        case "img":
        case "image":
        case "link":
          er("error", e), er("load", e);
          break;
        case "details":
          er("toggle", e);
          break;
        case "input":
          Iu(e, c), er("invalid", e);
          break;
        case "option":
          Gc(e, c);
          break;
        case "select":
          Og(e, c), er("invalid", e);
          break;
        case "textarea":
          _g(e, c), er("invalid", e);
          break;
      }
      Jc(r, c);
      {
        W = /* @__PURE__ */ new Set();
        for (var ne = e.attributes, ge = 0; ge < ne.length; ge++) {
          var he = ne[ge].name.toLowerCase();
          switch (he) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              W.add(ne[ge].name);
          }
        }
      }
      var Ae = null;
      for (var Te in c)
        if (c.hasOwnProperty(Te)) {
          var De = c[Te];
          if (Te === xc)
            typeof De == "string" ? e.textContent !== De && (c[du] !== !0 && Qv(e.textContent, De, R, _), Ae = [xc, De]) : typeof De == "number" && e.textContent !== "" + De && (c[du] !== !0 && Qv(e.textContent, De, R, _), Ae = [xc, "" + De]);
          else if (jt.hasOwnProperty(Te))
            De != null && (typeof De != "function" && qv(Te, De), Te === "onScroll" && er("scroll", e));
          else if (_ && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof H == "boolean") {
            var ht = void 0, Pt = H && St ? null : mr(Te);
            if (c[du] !== !0) {
              if (!(Te === Vv || Te === du || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              Te === "value" || Te === "checked" || Te === "selected")) {
                if (Te === sp) {
                  var Tt = e.innerHTML, hn = De ? De[Gv] : void 0;
                  if (hn != null) {
                    var on = NS(e, hn);
                    on !== Tt && op(Te, Tt, on);
                  }
                } else if (Te === bc) {
                  if (W.delete(Te), PS) {
                    var xe = wx(De);
                    ht = e.getAttribute("style"), xe !== ht && op(Te, ht, xe);
                  }
                } else if (H && !St)
                  W.delete(Te.toLowerCase()), ht = $s(e, Te, De), De !== ht && op(Te, ht, De);
                else if (!$n(Te, Pt, H) && !Ln(Te, De, Pt, H)) {
                  var Oe = !1;
                  if (Pt !== null)
                    W.delete(Pt.attributeName), ht = ps(e, Te, De, Pt);
                  else {
                    var be = g;
                    if (be === vs && (be = qc(r)), be === vs)
                      W.delete(Te.toLowerCase());
                    else {
                      var Xe = EL(Te);
                      Xe !== null && Xe !== Te && (Oe = !0, W.delete(Xe)), W.delete(Te);
                    }
                    ht = $s(e, Te, De);
                  }
                  var pt = St;
                  !pt && De !== ht && !Oe && op(Te, ht, De);
                }
              }
            }
          }
        }
      switch (_ && // $FlowFixMe - Should be inferred as not undefined.
      W.size > 0 && c[du] !== !0 && _S(W), r) {
        case "input":
          Po(e), Fu(e, c, !0);
          break;
        case "textarea":
          Po(e), Ng(e);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof c.onClick == "function" && Kv(e);
          break;
      }
      return Ae;
    }
    function LL(e, r, c) {
      var g = e.nodeValue !== r;
      return g;
    }
    function nb(e, r) {
      {
        if (Aa)
          return;
        Aa = !0, T("Did not expect server HTML to contain a <%s> in <%s>.", r.nodeName.toLowerCase(), e.nodeName.toLowerCase());
      }
    }
    function rb(e, r) {
      {
        if (Aa)
          return;
        Aa = !0, T('Did not expect server HTML to contain the text node "%s" in <%s>.', r.nodeValue, e.nodeName.toLowerCase());
      }
    }
    function ib(e, r, c) {
      {
        if (Aa)
          return;
        Aa = !0, T("Expected server HTML to contain a matching <%s> in <%s>.", r, e.nodeName.toLowerCase());
      }
    }
    function ab(e, r) {
      {
        if (r === "" || Aa)
          return;
        Aa = !0, T('Expected server HTML to contain a matching text node for "%s" in <%s>.', r, e.nodeName.toLowerCase());
      }
    }
    function ML(e, r, c) {
      switch (r) {
        case "input":
          Rg(e, c);
          return;
        case "textarea":
          Zf(e, c);
          return;
        case "select":
          px(e, c);
          return;
      }
    }
    var lp = function() {
    }, up = function() {
    };
    {
      var DL = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], IS = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], OL = IS.concat(["button"]), _L = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], FS = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      up = function(e, r) {
        var c = p({}, e || FS), g = {
          tag: r
        };
        return IS.indexOf(r) !== -1 && (c.aTagInScope = null, c.buttonTagInScope = null, c.nobrTagInScope = null), OL.indexOf(r) !== -1 && (c.pTagInButtonScope = null), DL.indexOf(r) !== -1 && r !== "address" && r !== "div" && r !== "p" && (c.listItemTagAutoclosing = null, c.dlItemTagAutoclosing = null), c.current = g, r === "form" && (c.formTag = g), r === "a" && (c.aTagInScope = g), r === "button" && (c.buttonTagInScope = g), r === "nobr" && (c.nobrTagInScope = g), r === "p" && (c.pTagInButtonScope = g), r === "li" && (c.listItemTagAutoclosing = g), (r === "dd" || r === "dt") && (c.dlItemTagAutoclosing = g), c;
      };
      var PL = function(e, r) {
        switch (r) {
          case "select":
            return e === "option" || e === "optgroup" || e === "#text";
          case "optgroup":
            return e === "option" || e === "#text";
          case "option":
            return e === "#text";
          case "tr":
            return e === "th" || e === "td" || e === "style" || e === "script" || e === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return e === "tr" || e === "style" || e === "script" || e === "template";
          case "colgroup":
            return e === "col" || e === "template";
          case "table":
            return e === "caption" || e === "colgroup" || e === "tbody" || e === "tfoot" || e === "thead" || e === "style" || e === "script" || e === "template";
          case "head":
            return e === "base" || e === "basefont" || e === "bgsound" || e === "link" || e === "meta" || e === "title" || e === "noscript" || e === "noframes" || e === "style" || e === "script" || e === "template";
          case "html":
            return e === "head" || e === "body" || e === "frameset";
          case "frameset":
            return e === "frame";
          case "#document":
            return e === "html";
        }
        switch (e) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return r !== "h1" && r !== "h2" && r !== "h3" && r !== "h4" && r !== "h5" && r !== "h6";
          case "rp":
          case "rt":
            return _L.indexOf(r) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return r == null;
        }
        return !0;
      }, NL = function(e, r) {
        switch (e) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return r.pTagInButtonScope;
          case "form":
            return r.formTag || r.pTagInButtonScope;
          case "li":
            return r.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return r.dlItemTagAutoclosing;
          case "button":
            return r.buttonTagInScope;
          case "a":
            return r.aTagInScope;
          case "nobr":
            return r.nobrTagInScope;
        }
        return null;
      }, YS = {};
      lp = function(e, r, c) {
        c = c || FS;
        var g = c.current, x = g && g.tag;
        r != null && (e != null && T("validateDOMNesting: when childText is passed, childTag should be null"), e = "#text");
        var R = PL(e, x) ? null : g, _ = R ? null : NL(e, c), H = R || _;
        if (H) {
          var W = H.tag, J = !!R + "|" + e + "|" + W;
          if (!YS[J]) {
            YS[J] = !0;
            var ne = e, ge = "";
            if (e === "#text" ? /\S/.test(r) ? ne = "Text nodes" : (ne = "Whitespace text nodes", ge = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : ne = "<" + e + ">", R) {
              var he = "";
              W === "table" && e === "tr" && (he += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), T("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", ne, W, ge, he);
            } else
              T("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", ne, W);
          }
        }
      };
    }
    var Jv = "suppressHydrationWarning", em = "$", tm = "/$", cp = "$?", dp = "$!", zL = "style", sb = null, ob = null;
    function IL(e) {
      var r, c, g = e.nodeType;
      switch (g) {
        case Ia:
        case No: {
          r = g === Ia ? "#document" : "#fragment";
          var x = e.documentElement;
          c = x ? x.namespaceURI : Kf(null, "");
          break;
        }
        default: {
          var R = g === xr ? e.parentNode : e, _ = R.namespaceURI || null;
          r = R.tagName, c = Kf(_, r);
          break;
        }
      }
      {
        var H = r.toLowerCase(), W = up(null, H);
        return {
          namespace: c,
          ancestorInfo: W
        };
      }
    }
    function FL(e, r, c) {
      {
        var g = e, x = Kf(g.namespace, r), R = up(g.ancestorInfo, r);
        return {
          namespace: x,
          ancestorInfo: R
        };
      }
    }
    function zj(e) {
      return e;
    }
    function YL(e) {
      sb = aa(), ob = JR();
      var r = null;
      return Fr(!1), r;
    }
    function HL(e) {
      eL(ob), Fr(sb), sb = null, ob = null;
    }
    function jL(e, r, c, g, x) {
      var R;
      {
        var _ = g;
        if (lp(e, null, _.ancestorInfo), typeof r.children == "string" || typeof r.children == "number") {
          var H = "" + r.children, W = up(_.ancestorInfo, e);
          lp(null, H, W);
        }
        R = _.namespace;
      }
      var J = SL(e, r, c, R);
      return pp(x, J), gb(J, r), J;
    }
    function UL(e, r) {
      e.appendChild(r);
    }
    function BL(e, r, c, g, x) {
      switch (CL(e, r, c, g), r) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!c.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function WL(e, r, c, g, x, R) {
      {
        var _ = R;
        if (typeof g.children != typeof c.children && (typeof g.children == "string" || typeof g.children == "number")) {
          var H = "" + g.children, W = up(_.ancestorInfo, r);
          lp(null, H, W);
        }
      }
      return AL(e, r, c, g);
    }
    function lb(e, r) {
      return e === "textarea" || e === "noscript" || typeof r.children == "string" || typeof r.children == "number" || typeof r.dangerouslySetInnerHTML == "object" && r.dangerouslySetInnerHTML !== null && r.dangerouslySetInnerHTML.__html != null;
    }
    function XL(e, r, c, g) {
      {
        var x = c;
        lp(null, e, x.ancestorInfo);
      }
      var R = kL(e, r);
      return pp(g, R), R;
    }
    function VL() {
      var e = window.event;
      return e === void 0 ? Ts : wi(e.type);
    }
    var ub = typeof setTimeout == "function" ? setTimeout : void 0, GL = typeof clearTimeout == "function" ? clearTimeout : void 0, cb = -1, HS = typeof Promise == "function" ? Promise : void 0, $L = typeof queueMicrotask == "function" ? queueMicrotask : typeof HS < "u" ? function(e) {
      return HS.resolve(null).then(e).catch(qL);
    } : ub;
    function qL(e) {
      setTimeout(function() {
        throw e;
      });
    }
    function ZL(e, r, c, g) {
      switch (r) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          c.autoFocus && e.focus();
          return;
        case "img": {
          c.src && (e.src = c.src);
          return;
        }
      }
    }
    function QL(e, r, c, g, x, R) {
      TL(e, r, c, g, x), gb(e, x);
    }
    function jS(e) {
      Qc(e, "");
    }
    function KL(e, r, c) {
      e.nodeValue = c;
    }
    function JL(e, r) {
      e.appendChild(r);
    }
    function eM(e, r) {
      var c;
      e.nodeType === xr ? (c = e.parentNode, c.insertBefore(r, e)) : (c = e, c.appendChild(r));
      var g = e._reactRootContainer;
      g == null && c.onclick === null && Kv(c);
    }
    function tM(e, r, c) {
      e.insertBefore(r, c);
    }
    function nM(e, r, c) {
      e.nodeType === xr ? e.parentNode.insertBefore(r, c) : e.insertBefore(r, c);
    }
    function rM(e, r) {
      e.removeChild(r);
    }
    function iM(e, r) {
      e.nodeType === xr ? e.parentNode.removeChild(r) : e.removeChild(r);
    }
    function db(e, r) {
      var c = r, g = 0;
      do {
        var x = c.nextSibling;
        if (e.removeChild(c), x && x.nodeType === xr) {
          var R = x.data;
          if (R === tm)
            if (g === 0) {
              e.removeChild(x), sn(r);
              return;
            } else
              g--;
          else
            (R === em || R === cp || R === dp) && g++;
        }
        c = x;
      } while (c);
      sn(r);
    }
    function aM(e, r) {
      e.nodeType === xr ? db(e.parentNode, r) : e.nodeType === _i && db(e, r), sn(e);
    }
    function sM(e) {
      e = e;
      var r = e.style;
      typeof r.setProperty == "function" ? r.setProperty("display", "none", "important") : r.display = "none";
    }
    function oM(e) {
      e.nodeValue = "";
    }
    function lM(e, r) {
      e = e;
      var c = r[zL], g = c != null && c.hasOwnProperty("display") ? c.display : null;
      e.style.display = Kc("display", g);
    }
    function uM(e, r) {
      e.nodeValue = r;
    }
    function cM(e) {
      e.nodeType === _i ? e.textContent = "" : e.nodeType === Ia && e.documentElement && e.removeChild(e.documentElement);
    }
    function dM(e, r, c) {
      return e.nodeType !== _i || r.toLowerCase() !== e.nodeName.toLowerCase() ? null : e;
    }
    function fM(e, r) {
      return r === "" || e.nodeType !== ms ? null : e;
    }
    function hM(e) {
      return e.nodeType !== xr ? null : e;
    }
    function US(e) {
      return e.data === cp;
    }
    function fb(e) {
      return e.data === dp;
    }
    function pM(e) {
      var r = e.nextSibling && e.nextSibling.dataset, c, g, x;
      return r && (c = r.dgst, g = r.msg, x = r.stck), {
        message: g,
        digest: c,
        stack: x
      };
    }
    function gM(e, r) {
      e._reactRetry = r;
    }
    function nm(e) {
      for (; e != null; e = e.nextSibling) {
        var r = e.nodeType;
        if (r === _i || r === ms)
          break;
        if (r === xr) {
          var c = e.data;
          if (c === em || c === dp || c === cp)
            break;
          if (c === tm)
            return null;
        }
      }
      return e;
    }
    function fp(e) {
      return nm(e.nextSibling);
    }
    function vM(e) {
      return nm(e.firstChild);
    }
    function mM(e) {
      return nm(e.firstChild);
    }
    function yM(e) {
      return nm(e.nextSibling);
    }
    function xM(e, r, c, g, x, R, _) {
      pp(R, e), gb(e, c);
      var H;
      {
        var W = x;
        H = W.namespace;
      }
      var J = (R.mode & nn) !== Nt;
      return RL(e, r, c, H, g, J, _);
    }
    function bM(e, r, c, g) {
      return pp(c, e), c.mode & nn, LL(e, r);
    }
    function wM(e, r) {
      pp(r, e);
    }
    function SM(e) {
      for (var r = e.nextSibling, c = 0; r; ) {
        if (r.nodeType === xr) {
          var g = r.data;
          if (g === tm) {
            if (c === 0)
              return fp(r);
            c--;
          } else
            (g === em || g === dp || g === cp) && c++;
        }
        r = r.nextSibling;
      }
      return null;
    }
    function BS(e) {
      for (var r = e.previousSibling, c = 0; r; ) {
        if (r.nodeType === xr) {
          var g = r.data;
          if (g === em || g === dp || g === cp) {
            if (c === 0)
              return r;
            c--;
          } else
            g === tm && c++;
        }
        r = r.previousSibling;
      }
      return null;
    }
    function kM(e) {
      sn(e);
    }
    function CM(e) {
      sn(e);
    }
    function AM(e) {
      return e !== "head" && e !== "body";
    }
    function TM(e, r, c, g) {
      var x = !0;
      Qv(r.nodeValue, c, g, x);
    }
    function EM(e, r, c, g, x, R) {
      if (r[Jv] !== !0) {
        var _ = !0;
        Qv(g.nodeValue, x, R, _);
      }
    }
    function RM(e, r) {
      r.nodeType === _i ? nb(e, r) : r.nodeType === xr || rb(e, r);
    }
    function LM(e, r) {
      {
        var c = e.parentNode;
        c !== null && (r.nodeType === _i ? nb(c, r) : r.nodeType === xr || rb(c, r));
      }
    }
    function MM(e, r, c, g, x) {
      (x || r[Jv] !== !0) && (g.nodeType === _i ? nb(c, g) : g.nodeType === xr || rb(c, g));
    }
    function DM(e, r, c) {
      ib(e, r);
    }
    function OM(e, r) {
      ab(e, r);
    }
    function _M(e, r, c) {
      {
        var g = e.parentNode;
        g !== null && ib(g, r);
      }
    }
    function PM(e, r) {
      {
        var c = e.parentNode;
        c !== null && ab(c, r);
      }
    }
    function NM(e, r, c, g, x, R) {
      (R || r[Jv] !== !0) && ib(c, g);
    }
    function zM(e, r, c, g, x) {
      (x || r[Jv] !== !0) && ab(c, g);
    }
    function IM(e) {
      T("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", e.nodeName.toLowerCase());
    }
    function FM(e) {
      ip(e);
    }
    var af = Math.random().toString(36).slice(2), sf = "__reactFiber$" + af, hb = "__reactProps$" + af, hp = "__reactContainer$" + af, pb = "__reactEvents$" + af, YM = "__reactListeners$" + af, HM = "__reactHandles$" + af;
    function jM(e) {
      delete e[sf], delete e[hb], delete e[pb], delete e[YM], delete e[HM];
    }
    function pp(e, r) {
      r[sf] = e;
    }
    function rm(e, r) {
      r[hp] = e;
    }
    function WS(e) {
      e[hp] = null;
    }
    function gp(e) {
      return !!e[hp];
    }
    function wc(e) {
      var r = e[sf];
      if (r)
        return r;
      for (var c = e.parentNode; c; ) {
        if (r = c[hp] || c[sf], r) {
          var g = r.alternate;
          if (r.child !== null || g !== null && g.child !== null)
            for (var x = BS(e); x !== null; ) {
              var R = x[sf];
              if (R)
                return R;
              x = BS(x);
            }
          return r;
        }
        e = c, c = e.parentNode;
      }
      return null;
    }
    function fu(e) {
      var r = e[sf] || e[hp];
      return r && (r.tag === se || r.tag === ae || r.tag === re || r.tag === q) ? r : null;
    }
    function of(e) {
      if (e.tag === se || e.tag === ae)
        return e.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function im(e) {
      return e[hb] || null;
    }
    function gb(e, r) {
      e[hb] = r;
    }
    function UM(e) {
      var r = e[pb];
      return r === void 0 && (r = e[pb] = /* @__PURE__ */ new Set()), r;
    }
    var XS = {}, VS = h.ReactDebugCurrentFrame;
    function am(e) {
      if (e) {
        var r = e._owner, c = Le(e.type, e._source, r ? r.type : null);
        VS.setExtraStackFrame(c);
      } else
        VS.setExtraStackFrame(null);
    }
    function Ds(e, r, c, g, x) {
      {
        var R = Function.call.bind(jn);
        for (var _ in e)
          if (R(e, _)) {
            var H = void 0;
            try {
              if (typeof e[_] != "function") {
                var W = Error((g || "React class") + ": " + c + " type `" + _ + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e[_] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw W.name = "Invariant Violation", W;
              }
              H = e[_](r, _, g, c, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (J) {
              H = J;
            }
            H && !(H instanceof Error) && (am(x), T("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", g || "React class", c, _, typeof H), am(null)), H instanceof Error && !(H.message in XS) && (XS[H.message] = !0, am(x), T("Failed %s type: %s", c, H.message), am(null));
          }
      }
    }
    var vb = [], sm;
    sm = [];
    var ul = -1;
    function hu(e) {
      return {
        current: e
      };
    }
    function Ui(e, r) {
      if (ul < 0) {
        T("Unexpected pop.");
        return;
      }
      r !== sm[ul] && T("Unexpected Fiber popped."), e.current = vb[ul], vb[ul] = null, sm[ul] = null, ul--;
    }
    function Bi(e, r, c) {
      ul++, vb[ul] = e.current, sm[ul] = c, e.current = r;
    }
    var mb;
    mb = {};
    var Ua = {};
    Object.freeze(Ua);
    var cl = hu(Ua), xo = hu(!1), yb = Ua;
    function lf(e, r, c) {
      return c && bo(r) ? yb : cl.current;
    }
    function GS(e, r, c) {
      {
        var g = e.stateNode;
        g.__reactInternalMemoizedUnmaskedChildContext = r, g.__reactInternalMemoizedMaskedChildContext = c;
      }
    }
    function uf(e, r) {
      {
        var c = e.type, g = c.contextTypes;
        if (!g)
          return Ua;
        var x = e.stateNode;
        if (x && x.__reactInternalMemoizedUnmaskedChildContext === r)
          return x.__reactInternalMemoizedMaskedChildContext;
        var R = {};
        for (var _ in g)
          R[_] = r[_];
        {
          var H = vt(e) || "Unknown";
          Ds(g, R, "context", H);
        }
        return x && GS(e, r, R), R;
      }
    }
    function om() {
      return xo.current;
    }
    function bo(e) {
      {
        var r = e.childContextTypes;
        return r != null;
      }
    }
    function lm(e) {
      Ui(xo, e), Ui(cl, e);
    }
    function xb(e) {
      Ui(xo, e), Ui(cl, e);
    }
    function $S(e, r, c) {
      {
        if (cl.current !== Ua)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Bi(cl, r, e), Bi(xo, c, e);
      }
    }
    function qS(e, r, c) {
      {
        var g = e.stateNode, x = r.childContextTypes;
        if (typeof g.getChildContext != "function") {
          {
            var R = vt(e) || "Unknown";
            mb[R] || (mb[R] = !0, T("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", R, R));
          }
          return c;
        }
        var _ = g.getChildContext();
        for (var H in _)
          if (!(H in x))
            throw new Error((vt(e) || "Unknown") + '.getChildContext(): key "' + H + '" is not defined in childContextTypes.');
        {
          var W = vt(e) || "Unknown";
          Ds(x, _, "child context", W);
        }
        return p({}, c, _);
      }
    }
    function um(e) {
      {
        var r = e.stateNode, c = r && r.__reactInternalMemoizedMergedChildContext || Ua;
        return yb = cl.current, Bi(cl, c, e), Bi(xo, xo.current, e), !0;
      }
    }
    function ZS(e, r, c) {
      {
        var g = e.stateNode;
        if (!g)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (c) {
          var x = qS(e, r, yb);
          g.__reactInternalMemoizedMergedChildContext = x, Ui(xo, e), Ui(cl, e), Bi(cl, x, e), Bi(xo, c, e);
        } else
          Ui(xo, e), Bi(xo, c, e);
      }
    }
    function BM(e) {
      {
        if (!yh(e) || e.tag !== U)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var r = e;
        do {
          switch (r.tag) {
            case q:
              return r.stateNode.context;
            case U: {
              var c = r.type;
              if (bo(c))
                return r.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          r = r.return;
        } while (r !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var pu = 0, cm = 1, dl = null, bb = !1, wb = !1;
    function QS(e) {
      dl === null ? dl = [e] : dl.push(e);
    }
    function WM(e) {
      bb = !0, QS(e);
    }
    function KS() {
      bb && gu();
    }
    function gu() {
      if (!wb && dl !== null) {
        wb = !0;
        var e = 0, r = wa();
        try {
          var c = !0, g = dl;
          for (Tr(ci); e < g.length; e++) {
            var x = g[e];
            do
              x = x(c);
            while (x !== null);
          }
          dl = null, bb = !1;
        } catch (R) {
          throw dl !== null && (dl = dl.slice(e + 1)), ud(dd, gu), R;
        } finally {
          Tr(r), wb = !1;
        }
      }
      return null;
    }
    var cf = [], df = 0, dm = null, fm = 0, es = [], ts = 0, Sc = null, fl = 1, hl = "";
    function XM(e) {
      return Cc(), (e.flags & gh) !== _t;
    }
    function VM(e) {
      return Cc(), fm;
    }
    function GM() {
      var e = hl, r = fl, c = r & ~$M(r);
      return c.toString(32) + e;
    }
    function kc(e, r) {
      Cc(), cf[df++] = fm, cf[df++] = dm, dm = e, fm = r;
    }
    function JS(e, r, c) {
      Cc(), es[ts++] = fl, es[ts++] = hl, es[ts++] = Sc, Sc = e;
      var g = fl, x = hl, R = hm(g) - 1, _ = g & ~(1 << R), H = c + 1, W = hm(r) + R;
      if (W > 30) {
        var J = R - R % 5, ne = (1 << J) - 1, ge = (_ & ne).toString(32), he = _ >> J, Ae = R - J, Te = hm(r) + Ae, De = H << Ae, ht = De | he, Pt = ge + x;
        fl = 1 << Te | ht, hl = Pt;
      } else {
        var Tt = H << R, hn = Tt | _, on = x;
        fl = 1 << W | hn, hl = on;
      }
    }
    function Sb(e) {
      Cc();
      var r = e.return;
      if (r !== null) {
        var c = 1, g = 0;
        kc(e, c), JS(e, c, g);
      }
    }
    function hm(e) {
      return 32 - md(e);
    }
    function $M(e) {
      return 1 << hm(e) - 1;
    }
    function kb(e) {
      for (; e === dm; )
        dm = cf[--df], cf[df] = null, fm = cf[--df], cf[df] = null;
      for (; e === Sc; )
        Sc = es[--ts], es[ts] = null, hl = es[--ts], es[ts] = null, fl = es[--ts], es[ts] = null;
    }
    function qM() {
      return Cc(), Sc !== null ? {
        id: fl,
        overflow: hl
      } : null;
    }
    function ZM(e, r) {
      Cc(), es[ts++] = fl, es[ts++] = hl, es[ts++] = Sc, fl = r.id, hl = r.overflow, Sc = e;
    }
    function Cc() {
      ki() || T("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Si = null, ns = null, Os = !1, Ac = !1, vu = null;
    function QM() {
      Os && T("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function ek() {
      Ac = !0;
    }
    function KM() {
      return Ac;
    }
    function JM(e) {
      var r = e.stateNode.containerInfo;
      return ns = mM(r), Si = e, Os = !0, vu = null, Ac = !1, !0;
    }
    function eD(e, r, c) {
      return ns = yM(r), Si = e, Os = !0, vu = null, Ac = !1, c !== null && ZM(e, c), !0;
    }
    function tk(e, r) {
      switch (e.tag) {
        case q: {
          RM(e.stateNode.containerInfo, r);
          break;
        }
        case se: {
          var c = (e.mode & nn) !== Nt;
          MM(
            e.type,
            e.memoizedProps,
            e.stateNode,
            r,
            // TODO: Delete this argument when we remove the legacy root API.
            c
          );
          break;
        }
        case re: {
          var g = e.memoizedState;
          g.dehydrated !== null && LM(g.dehydrated, r);
          break;
        }
      }
    }
    function nk(e, r) {
      tk(e, r);
      var c = r_();
      c.stateNode = r, c.return = e;
      var g = e.deletions;
      g === null ? (e.deletions = [c], e.flags |= Sn) : g.push(c);
    }
    function Cb(e, r) {
      {
        if (Ac)
          return;
        switch (e.tag) {
          case q: {
            var c = e.stateNode.containerInfo;
            switch (r.tag) {
              case se:
                var g = r.type;
                r.pendingProps, DM(c, g);
                break;
              case ae:
                var x = r.pendingProps;
                OM(c, x);
                break;
            }
            break;
          }
          case se: {
            var R = e.type, _ = e.memoizedProps, H = e.stateNode;
            switch (r.tag) {
              case se: {
                var W = r.type, J = r.pendingProps, ne = (e.mode & nn) !== Nt;
                NM(
                  R,
                  _,
                  H,
                  W,
                  J,
                  // TODO: Delete this argument when we remove the legacy root API.
                  ne
                );
                break;
              }
              case ae: {
                var ge = r.pendingProps, he = (e.mode & nn) !== Nt;
                zM(
                  R,
                  _,
                  H,
                  ge,
                  // TODO: Delete this argument when we remove the legacy root API.
                  he
                );
                break;
              }
            }
            break;
          }
          case re: {
            var Ae = e.memoizedState, Te = Ae.dehydrated;
            if (Te !== null)
              switch (r.tag) {
                case se:
                  var De = r.type;
                  r.pendingProps, _M(Te, De);
                  break;
                case ae:
                  var ht = r.pendingProps;
                  PM(Te, ht);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function rk(e, r) {
      r.flags = r.flags & ~va | Bn, Cb(e, r);
    }
    function ik(e, r) {
      switch (e.tag) {
        case se: {
          var c = e.type;
          e.pendingProps;
          var g = dM(r, c);
          return g !== null ? (e.stateNode = g, Si = e, ns = vM(g), !0) : !1;
        }
        case ae: {
          var x = e.pendingProps, R = fM(r, x);
          return R !== null ? (e.stateNode = R, Si = e, ns = null, !0) : !1;
        }
        case re: {
          var _ = hM(r);
          if (_ !== null) {
            var H = {
              dehydrated: _,
              treeContext: qM(),
              retryLane: Hi
            };
            e.memoizedState = H;
            var W = i_(_);
            return W.return = e, e.child = W, Si = e, ns = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function Ab(e) {
      return (e.mode & nn) !== Nt && (e.flags & Wt) === _t;
    }
    function Tb(e) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function Eb(e) {
      if (Os) {
        var r = ns;
        if (!r) {
          Ab(e) && (Cb(Si, e), Tb()), rk(Si, e), Os = !1, Si = e;
          return;
        }
        var c = r;
        if (!ik(e, r)) {
          Ab(e) && (Cb(Si, e), Tb()), r = fp(c);
          var g = Si;
          if (!r || !ik(e, r)) {
            rk(Si, e), Os = !1, Si = e;
            return;
          }
          nk(g, c);
        }
      }
    }
    function tD(e, r, c) {
      var g = e.stateNode, x = !Ac, R = xM(g, e.type, e.memoizedProps, r, c, e, x);
      return e.updateQueue = R, R !== null;
    }
    function nD(e) {
      var r = e.stateNode, c = e.memoizedProps, g = bM(r, c, e);
      if (g) {
        var x = Si;
        if (x !== null)
          switch (x.tag) {
            case q: {
              var R = x.stateNode.containerInfo, _ = (x.mode & nn) !== Nt;
              TM(
                R,
                r,
                c,
                // TODO: Delete this argument when we remove the legacy root API.
                _
              );
              break;
            }
            case se: {
              var H = x.type, W = x.memoizedProps, J = x.stateNode, ne = (x.mode & nn) !== Nt;
              EM(
                H,
                W,
                J,
                r,
                c,
                // TODO: Delete this argument when we remove the legacy root API.
                ne
              );
              break;
            }
          }
      }
      return g;
    }
    function rD(e) {
      var r = e.memoizedState, c = r !== null ? r.dehydrated : null;
      if (!c)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      wM(c, e);
    }
    function iD(e) {
      var r = e.memoizedState, c = r !== null ? r.dehydrated : null;
      if (!c)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return SM(c);
    }
    function ak(e) {
      for (var r = e.return; r !== null && r.tag !== se && r.tag !== q && r.tag !== re; )
        r = r.return;
      Si = r;
    }
    function pm(e) {
      if (e !== Si)
        return !1;
      if (!Os)
        return ak(e), Os = !0, !1;
      if (e.tag !== q && (e.tag !== se || AM(e.type) && !lb(e.type, e.memoizedProps))) {
        var r = ns;
        if (r)
          if (Ab(e))
            sk(e), Tb();
          else
            for (; r; )
              nk(e, r), r = fp(r);
      }
      return ak(e), e.tag === re ? ns = iD(e) : ns = Si ? fp(e.stateNode) : null, !0;
    }
    function aD() {
      return Os && ns !== null;
    }
    function sk(e) {
      for (var r = ns; r; )
        tk(e, r), r = fp(r);
    }
    function ff() {
      Si = null, ns = null, Os = !1, Ac = !1;
    }
    function ok() {
      vu !== null && (tA(vu), vu = null);
    }
    function ki() {
      return Os;
    }
    function Rb(e) {
      vu === null ? vu = [e] : vu.push(e);
    }
    var sD = h.ReactCurrentBatchConfig, oD = null;
    function lD() {
      return sD.transition;
    }
    var _s = {
      recordUnsafeLifecycleWarnings: function(e, r) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(e, r) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var uD = function(e) {
        for (var r = null, c = e; c !== null; )
          c.mode & Kn && (r = c), c = c.return;
        return r;
      }, Tc = function(e) {
        var r = [];
        return e.forEach(function(c) {
          r.push(c);
        }), r.sort().join(", ");
      }, vp = [], mp = [], yp = [], xp = [], bp = [], wp = [], Ec = /* @__PURE__ */ new Set();
      _s.recordUnsafeLifecycleWarnings = function(e, r) {
        Ec.has(e.type) || (typeof r.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        r.componentWillMount.__suppressDeprecationWarning !== !0 && vp.push(e), e.mode & Kn && typeof r.UNSAFE_componentWillMount == "function" && mp.push(e), typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && yp.push(e), e.mode & Kn && typeof r.UNSAFE_componentWillReceiveProps == "function" && xp.push(e), typeof r.componentWillUpdate == "function" && r.componentWillUpdate.__suppressDeprecationWarning !== !0 && bp.push(e), e.mode & Kn && typeof r.UNSAFE_componentWillUpdate == "function" && wp.push(e));
      }, _s.flushPendingUnsafeLifecycleWarnings = function() {
        var e = /* @__PURE__ */ new Set();
        vp.length > 0 && (vp.forEach(function(he) {
          e.add(vt(he) || "Component"), Ec.add(he.type);
        }), vp = []);
        var r = /* @__PURE__ */ new Set();
        mp.length > 0 && (mp.forEach(function(he) {
          r.add(vt(he) || "Component"), Ec.add(he.type);
        }), mp = []);
        var c = /* @__PURE__ */ new Set();
        yp.length > 0 && (yp.forEach(function(he) {
          c.add(vt(he) || "Component"), Ec.add(he.type);
        }), yp = []);
        var g = /* @__PURE__ */ new Set();
        xp.length > 0 && (xp.forEach(function(he) {
          g.add(vt(he) || "Component"), Ec.add(he.type);
        }), xp = []);
        var x = /* @__PURE__ */ new Set();
        bp.length > 0 && (bp.forEach(function(he) {
          x.add(vt(he) || "Component"), Ec.add(he.type);
        }), bp = []);
        var R = /* @__PURE__ */ new Set();
        if (wp.length > 0 && (wp.forEach(function(he) {
          R.add(vt(he) || "Component"), Ec.add(he.type);
        }), wp = []), r.size > 0) {
          var _ = Tc(r);
          T(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, _);
        }
        if (g.size > 0) {
          var H = Tc(g);
          T(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, H);
        }
        if (R.size > 0) {
          var W = Tc(R);
          T(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, W);
        }
        if (e.size > 0) {
          var J = Tc(e);
          C(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, J);
        }
        if (c.size > 0) {
          var ne = Tc(c);
          C(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ne);
        }
        if (x.size > 0) {
          var ge = Tc(x);
          C(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ge);
        }
      };
      var gm = /* @__PURE__ */ new Map(), lk = /* @__PURE__ */ new Set();
      _s.recordLegacyContextWarning = function(e, r) {
        var c = uD(e);
        if (c === null) {
          T("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!lk.has(e.type)) {
          var g = gm.get(c);
          (e.type.contextTypes != null || e.type.childContextTypes != null || r !== null && typeof r.getChildContext == "function") && (g === void 0 && (g = [], gm.set(c, g)), g.push(e));
        }
      }, _s.flushLegacyContextWarning = function() {
        gm.forEach(function(e, r) {
          if (e.length !== 0) {
            var c = e[0], g = /* @__PURE__ */ new Set();
            e.forEach(function(R) {
              g.add(vt(R) || "Component"), lk.add(R.type);
            });
            var x = Tc(g);
            try {
              wn(c), T(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, x);
            } finally {
              ln();
            }
          }
        });
      }, _s.discardPendingWarnings = function() {
        vp = [], mp = [], yp = [], xp = [], bp = [], wp = [], gm = /* @__PURE__ */ new Map();
      };
    }
    function Ps(e, r) {
      if (e && e.defaultProps) {
        var c = p({}, r), g = e.defaultProps;
        for (var x in g)
          c[x] === void 0 && (c[x] = g[x]);
        return c;
      }
      return r;
    }
    var Lb = hu(null), Mb;
    Mb = {};
    var vm = null, hf = null, Db = null, mm = !1;
    function ym() {
      vm = null, hf = null, Db = null, mm = !1;
    }
    function uk() {
      mm = !0;
    }
    function ck() {
      mm = !1;
    }
    function dk(e, r, c) {
      Bi(Lb, r._currentValue, e), r._currentValue = c, r._currentRenderer !== void 0 && r._currentRenderer !== null && r._currentRenderer !== Mb && T("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), r._currentRenderer = Mb;
    }
    function Ob(e, r) {
      var c = Lb.current;
      Ui(Lb, r), e._currentValue = c;
    }
    function _b(e, r, c) {
      for (var g = e; g !== null; ) {
        var x = g.alternate;
        if (Ko(g.childLanes, r) ? x !== null && !Ko(x.childLanes, r) && (x.childLanes = en(x.childLanes, r)) : (g.childLanes = en(g.childLanes, r), x !== null && (x.childLanes = en(x.childLanes, r))), g === c)
          break;
        g = g.return;
      }
      g !== c && T("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function cD(e, r, c) {
      dD(e, r, c);
    }
    function dD(e, r, c) {
      var g = e.child;
      for (g !== null && (g.return = e); g !== null; ) {
        var x = void 0, R = g.dependencies;
        if (R !== null) {
          x = g.child;
          for (var _ = R.firstContext; _ !== null; ) {
            if (_.context === r) {
              if (g.tag === U) {
                var H = Ar(c), W = pl(Fn, H);
                W.tag = bm;
                var J = g.updateQueue;
                if (J !== null) {
                  var ne = J.shared, ge = ne.pending;
                  ge === null ? W.next = W : (W.next = ge.next, ge.next = W), ne.pending = W;
                }
              }
              g.lanes = en(g.lanes, c);
              var he = g.alternate;
              he !== null && (he.lanes = en(he.lanes, c)), _b(g.return, c, e), R.lanes = en(R.lanes, c);
              break;
            }
            _ = _.next;
          }
        } else if (g.tag === K)
          x = g.type === e.type ? null : g.child;
        else if (g.tag === Ve) {
          var Ae = g.return;
          if (Ae === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Ae.lanes = en(Ae.lanes, c);
          var Te = Ae.alternate;
          Te !== null && (Te.lanes = en(Te.lanes, c)), _b(Ae, c, e), x = g.sibling;
        } else
          x = g.child;
        if (x !== null)
          x.return = g;
        else
          for (x = g; x !== null; ) {
            if (x === e) {
              x = null;
              break;
            }
            var De = x.sibling;
            if (De !== null) {
              De.return = x.return, x = De;
              break;
            }
            x = x.return;
          }
        g = x;
      }
    }
    function pf(e, r) {
      vm = e, hf = null, Db = null;
      var c = e.dependencies;
      if (c !== null) {
        var g = c.firstContext;
        g !== null && (ji(c.lanes, r) && Np(), c.firstContext = null);
      }
    }
    function Hr(e) {
      mm && T("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var r = e._currentValue;
      if (Db !== e) {
        var c = {
          context: e,
          memoizedValue: r,
          next: null
        };
        if (hf === null) {
          if (vm === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          hf = c, vm.dependencies = {
            lanes: Pe,
            firstContext: c
          };
        } else
          hf = hf.next = c;
      }
      return r;
    }
    var Rc = null;
    function Pb(e) {
      Rc === null ? Rc = [e] : Rc.push(e);
    }
    function fD() {
      if (Rc !== null) {
        for (var e = 0; e < Rc.length; e++) {
          var r = Rc[e], c = r.interleaved;
          if (c !== null) {
            r.interleaved = null;
            var g = c.next, x = r.pending;
            if (x !== null) {
              var R = x.next;
              x.next = g, c.next = R;
            }
            r.pending = c;
          }
        }
        Rc = null;
      }
    }
    function fk(e, r, c, g) {
      var x = r.interleaved;
      return x === null ? (c.next = c, Pb(r)) : (c.next = x.next, x.next = c), r.interleaved = c, xm(e, g);
    }
    function hD(e, r, c, g) {
      var x = r.interleaved;
      x === null ? (c.next = c, Pb(r)) : (c.next = x.next, x.next = c), r.interleaved = c;
    }
    function pD(e, r, c, g) {
      var x = r.interleaved;
      return x === null ? (c.next = c, Pb(r)) : (c.next = x.next, x.next = c), r.interleaved = c, xm(e, g);
    }
    function Ta(e, r) {
      return xm(e, r);
    }
    var gD = xm;
    function xm(e, r) {
      e.lanes = en(e.lanes, r);
      var c = e.alternate;
      c !== null && (c.lanes = en(c.lanes, r)), c === null && (e.flags & (Bn | va)) !== _t && hA(e);
      for (var g = e, x = e.return; x !== null; )
        x.childLanes = en(x.childLanes, r), c = x.alternate, c !== null ? c.childLanes = en(c.childLanes, r) : (x.flags & (Bn | va)) !== _t && hA(e), g = x, x = x.return;
      if (g.tag === q) {
        var R = g.stateNode;
        return R;
      } else
        return null;
    }
    var hk = 0, pk = 1, bm = 2, Nb = 3, wm = !1, zb, Sm;
    zb = !1, Sm = null;
    function Ib(e) {
      var r = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Pe
        },
        effects: null
      };
      e.updateQueue = r;
    }
    function gk(e, r) {
      var c = r.updateQueue, g = e.updateQueue;
      if (c === g) {
        var x = {
          baseState: g.baseState,
          firstBaseUpdate: g.firstBaseUpdate,
          lastBaseUpdate: g.lastBaseUpdate,
          shared: g.shared,
          effects: g.effects
        };
        r.updateQueue = x;
      }
    }
    function pl(e, r) {
      var c = {
        eventTime: e,
        lane: r,
        tag: hk,
        payload: null,
        callback: null,
        next: null
      };
      return c;
    }
    function mu(e, r, c) {
      var g = e.updateQueue;
      if (g === null)
        return null;
      var x = g.shared;
      if (Sm === x && !zb && (T("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), zb = !0), g2()) {
        var R = x.pending;
        return R === null ? r.next = r : (r.next = R.next, R.next = r), x.pending = r, gD(e, c);
      } else
        return pD(e, x, r, c);
    }
    function km(e, r, c) {
      var g = r.updateQueue;
      if (g !== null) {
        var x = g.shared;
        if (Dh(c)) {
          var R = x.lanes;
          R = _h(R, e.pendingLanes);
          var _ = en(R, c);
          x.lanes = _, Ql(e, _);
        }
      }
    }
    function Fb(e, r) {
      var c = e.updateQueue, g = e.alternate;
      if (g !== null) {
        var x = g.updateQueue;
        if (c === x) {
          var R = null, _ = null, H = c.firstBaseUpdate;
          if (H !== null) {
            var W = H;
            do {
              var J = {
                eventTime: W.eventTime,
                lane: W.lane,
                tag: W.tag,
                payload: W.payload,
                callback: W.callback,
                next: null
              };
              _ === null ? R = _ = J : (_.next = J, _ = J), W = W.next;
            } while (W !== null);
            _ === null ? R = _ = r : (_.next = r, _ = r);
          } else
            R = _ = r;
          c = {
            baseState: x.baseState,
            firstBaseUpdate: R,
            lastBaseUpdate: _,
            shared: x.shared,
            effects: x.effects
          }, e.updateQueue = c;
          return;
        }
      }
      var ne = c.lastBaseUpdate;
      ne === null ? c.firstBaseUpdate = r : ne.next = r, c.lastBaseUpdate = r;
    }
    function vD(e, r, c, g, x, R) {
      switch (c.tag) {
        case pk: {
          var _ = c.payload;
          if (typeof _ == "function") {
            uk();
            var H = _.call(R, g, x);
            {
              if (e.mode & Kn) {
                Cr(!0);
                try {
                  _.call(R, g, x);
                } finally {
                  Cr(!1);
                }
              }
              ck();
            }
            return H;
          }
          return _;
        }
        case Nb:
          e.flags = e.flags & ~Nr | Wt;
        case hk: {
          var W = c.payload, J;
          if (typeof W == "function") {
            uk(), J = W.call(R, g, x);
            {
              if (e.mode & Kn) {
                Cr(!0);
                try {
                  W.call(R, g, x);
                } finally {
                  Cr(!1);
                }
              }
              ck();
            }
          } else
            J = W;
          return J == null ? g : p({}, g, J);
        }
        case bm:
          return wm = !0, g;
      }
      return g;
    }
    function Cm(e, r, c, g) {
      var x = e.updateQueue;
      wm = !1, Sm = x.shared;
      var R = x.firstBaseUpdate, _ = x.lastBaseUpdate, H = x.shared.pending;
      if (H !== null) {
        x.shared.pending = null;
        var W = H, J = W.next;
        W.next = null, _ === null ? R = J : _.next = J, _ = W;
        var ne = e.alternate;
        if (ne !== null) {
          var ge = ne.updateQueue, he = ge.lastBaseUpdate;
          he !== _ && (he === null ? ge.firstBaseUpdate = J : he.next = J, ge.lastBaseUpdate = W);
        }
      }
      if (R !== null) {
        var Ae = x.baseState, Te = Pe, De = null, ht = null, Pt = null, Tt = R;
        do {
          var hn = Tt.lane, on = Tt.eventTime;
          if (Ko(g, hn)) {
            if (Pt !== null) {
              var Oe = {
                eventTime: on,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: dn,
                tag: Tt.tag,
                payload: Tt.payload,
                callback: Tt.callback,
                next: null
              };
              Pt = Pt.next = Oe;
            }
            Ae = vD(e, x, Tt, Ae, r, c);
            var be = Tt.callback;
            if (be !== null && // If the update was already committed, we should not queue its
            // callback again.
            Tt.lane !== dn) {
              e.flags |= $a;
              var Xe = x.effects;
              Xe === null ? x.effects = [Tt] : Xe.push(Tt);
            }
          } else {
            var xe = {
              eventTime: on,
              lane: hn,
              tag: Tt.tag,
              payload: Tt.payload,
              callback: Tt.callback,
              next: null
            };
            Pt === null ? (ht = Pt = xe, De = Ae) : Pt = Pt.next = xe, Te = en(Te, hn);
          }
          if (Tt = Tt.next, Tt === null) {
            if (H = x.shared.pending, H === null)
              break;
            var pt = H, st = pt.next;
            pt.next = null, Tt = st, x.lastBaseUpdate = pt, x.shared.pending = null;
          }
        } while (!0);
        Pt === null && (De = Ae), x.baseState = De, x.firstBaseUpdate = ht, x.lastBaseUpdate = Pt;
        var Bt = x.shared.interleaved;
        if (Bt !== null) {
          var $t = Bt;
          do
            Te = en(Te, $t.lane), $t = $t.next;
          while ($t !== Bt);
        } else
          R === null && (x.shared.lanes = Pe);
        Gp(Te), e.lanes = Te, e.memoizedState = Ae;
      }
      Sm = null;
    }
    function mD(e, r) {
      if (typeof e != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + e));
      e.call(r);
    }
    function vk() {
      wm = !1;
    }
    function Am() {
      return wm;
    }
    function mk(e, r, c) {
      var g = r.effects;
      if (r.effects = null, g !== null)
        for (var x = 0; x < g.length; x++) {
          var R = g[x], _ = R.callback;
          _ !== null && (R.callback = null, mD(_, c));
        }
    }
    var Yb = {}, yk = new s.Component().refs, Hb, jb, Ub, Bb, Wb, xk, Tm, Xb, Vb, Gb;
    {
      Hb = /* @__PURE__ */ new Set(), jb = /* @__PURE__ */ new Set(), Ub = /* @__PURE__ */ new Set(), Bb = /* @__PURE__ */ new Set(), Xb = /* @__PURE__ */ new Set(), Wb = /* @__PURE__ */ new Set(), Vb = /* @__PURE__ */ new Set(), Gb = /* @__PURE__ */ new Set();
      var bk = /* @__PURE__ */ new Set();
      Tm = function(e, r) {
        if (!(e === null || typeof e == "function")) {
          var c = r + "_" + e;
          bk.has(c) || (bk.add(c), T("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", r, e));
        }
      }, xk = function(e, r) {
        if (r === void 0) {
          var c = yt(e) || "Component";
          Wb.has(c) || (Wb.add(c), T("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", c));
        }
      }, Object.defineProperty(Yb, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(Yb);
    }
    function $b(e, r, c, g) {
      var x = e.memoizedState, R = c(g, x);
      {
        if (e.mode & Kn) {
          Cr(!0);
          try {
            R = c(g, x);
          } finally {
            Cr(!1);
          }
        }
        xk(r, R);
      }
      var _ = R == null ? x : p({}, x, R);
      if (e.memoizedState = _, e.lanes === Pe) {
        var H = e.updateQueue;
        H.baseState = _;
      }
    }
    var qb = {
      isMounted: na,
      enqueueSetState: function(e, r, c) {
        var g = pa(e), x = la(), R = Au(g), _ = pl(x, R);
        _.payload = r, c != null && (Tm(c, "setState"), _.callback = c);
        var H = mu(g, _, R);
        H !== null && (Jr(H, g, R, x), km(H, g, R)), uo(g, R);
      },
      enqueueReplaceState: function(e, r, c) {
        var g = pa(e), x = la(), R = Au(g), _ = pl(x, R);
        _.tag = pk, _.payload = r, c != null && (Tm(c, "replaceState"), _.callback = c);
        var H = mu(g, _, R);
        H !== null && (Jr(H, g, R, x), km(H, g, R)), uo(g, R);
      },
      enqueueForceUpdate: function(e, r) {
        var c = pa(e), g = la(), x = Au(c), R = pl(g, x);
        R.tag = bm, r != null && (Tm(r, "forceUpdate"), R.callback = r);
        var _ = mu(c, R, x);
        _ !== null && (Jr(_, c, x, g), km(_, c, x)), Eh(c, x);
      }
    };
    function wk(e, r, c, g, x, R, _) {
      var H = e.stateNode;
      if (typeof H.shouldComponentUpdate == "function") {
        var W = H.shouldComponentUpdate(g, R, _);
        {
          if (e.mode & Kn) {
            Cr(!0);
            try {
              W = H.shouldComponentUpdate(g, R, _);
            } finally {
              Cr(!1);
            }
          }
          W === void 0 && T("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", yt(r) || "Component");
        }
        return W;
      }
      return r.prototype && r.prototype.isPureReactComponent ? !Mt(c, g) || !Mt(x, R) : !0;
    }
    function yD(e, r, c) {
      var g = e.stateNode;
      {
        var x = yt(r) || "Component", R = g.render;
        R || (r.prototype && typeof r.prototype.render == "function" ? T("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", x) : T("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", x)), g.getInitialState && !g.getInitialState.isReactClassApproved && !g.state && T("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", x), g.getDefaultProps && !g.getDefaultProps.isReactClassApproved && T("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", x), g.propTypes && T("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", x), g.contextType && T("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", x), g.contextTypes && T("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", x), r.contextType && r.contextTypes && !Vb.has(r) && (Vb.add(r), T("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", x)), typeof g.componentShouldUpdate == "function" && T("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", x), r.prototype && r.prototype.isPureReactComponent && typeof g.shouldComponentUpdate < "u" && T("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", yt(r) || "A pure component"), typeof g.componentDidUnmount == "function" && T("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", x), typeof g.componentDidReceiveProps == "function" && T("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", x), typeof g.componentWillRecieveProps == "function" && T("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", x), typeof g.UNSAFE_componentWillRecieveProps == "function" && T("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", x);
        var _ = g.props !== c;
        g.props !== void 0 && _ && T("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", x, x), g.defaultProps && T("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", x, x), typeof g.getSnapshotBeforeUpdate == "function" && typeof g.componentDidUpdate != "function" && !Ub.has(r) && (Ub.add(r), T("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", yt(r))), typeof g.getDerivedStateFromProps == "function" && T("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", x), typeof g.getDerivedStateFromError == "function" && T("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", x), typeof r.getSnapshotBeforeUpdate == "function" && T("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", x);
        var H = g.state;
        H && (typeof H != "object" || _r(H)) && T("%s.state: must be set to an object or null", x), typeof g.getChildContext == "function" && typeof r.childContextTypes != "object" && T("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", x);
      }
    }
    function Sk(e, r) {
      r.updater = qb, e.stateNode = r, jl(r, e), r._reactInternalInstance = Yb;
    }
    function kk(e, r, c) {
      var g = !1, x = Ua, R = Ua, _ = r.contextType;
      if ("contextType" in r) {
        var H = (
          // Allow null for conditional declaration
          _ === null || _ !== void 0 && _.$$typeof === tt && _._context === void 0
        );
        if (!H && !Gb.has(r)) {
          Gb.add(r);
          var W = "";
          _ === void 0 ? W = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof _ != "object" ? W = " However, it is set to a " + typeof _ + "." : _.$$typeof === Ye ? W = " Did you accidentally pass the Context.Provider instead?" : _._context !== void 0 ? W = " Did you accidentally pass the Context.Consumer instead?" : W = " However, it is set to an object with keys {" + Object.keys(_).join(", ") + "}.", T("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", yt(r) || "Component", W);
        }
      }
      if (typeof _ == "object" && _ !== null)
        R = Hr(_);
      else {
        x = lf(e, r, !0);
        var J = r.contextTypes;
        g = J != null, R = g ? uf(e, x) : Ua;
      }
      var ne = new r(c, R);
      if (e.mode & Kn) {
        Cr(!0);
        try {
          ne = new r(c, R);
        } finally {
          Cr(!1);
        }
      }
      var ge = e.memoizedState = ne.state !== null && ne.state !== void 0 ? ne.state : null;
      Sk(e, ne);
      {
        if (typeof r.getDerivedStateFromProps == "function" && ge === null) {
          var he = yt(r) || "Component";
          jb.has(he) || (jb.add(he), T("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", he, ne.state === null ? "null" : "undefined", he));
        }
        if (typeof r.getDerivedStateFromProps == "function" || typeof ne.getSnapshotBeforeUpdate == "function") {
          var Ae = null, Te = null, De = null;
          if (typeof ne.componentWillMount == "function" && ne.componentWillMount.__suppressDeprecationWarning !== !0 ? Ae = "componentWillMount" : typeof ne.UNSAFE_componentWillMount == "function" && (Ae = "UNSAFE_componentWillMount"), typeof ne.componentWillReceiveProps == "function" && ne.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Te = "componentWillReceiveProps" : typeof ne.UNSAFE_componentWillReceiveProps == "function" && (Te = "UNSAFE_componentWillReceiveProps"), typeof ne.componentWillUpdate == "function" && ne.componentWillUpdate.__suppressDeprecationWarning !== !0 ? De = "componentWillUpdate" : typeof ne.UNSAFE_componentWillUpdate == "function" && (De = "UNSAFE_componentWillUpdate"), Ae !== null || Te !== null || De !== null) {
            var ht = yt(r) || "Component", Pt = typeof r.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Bb.has(ht) || (Bb.add(ht), T(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, ht, Pt, Ae !== null ? `
  ` + Ae : "", Te !== null ? `
  ` + Te : "", De !== null ? `
  ` + De : ""));
          }
        }
      }
      return g && GS(e, x, R), ne;
    }
    function xD(e, r) {
      var c = r.state;
      typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), c !== r.state && (T("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", vt(e) || "Component"), qb.enqueueReplaceState(r, r.state, null));
    }
    function Ck(e, r, c, g) {
      var x = r.state;
      if (typeof r.componentWillReceiveProps == "function" && r.componentWillReceiveProps(c, g), typeof r.UNSAFE_componentWillReceiveProps == "function" && r.UNSAFE_componentWillReceiveProps(c, g), r.state !== x) {
        {
          var R = vt(e) || "Component";
          Hb.has(R) || (Hb.add(R), T("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", R));
        }
        qb.enqueueReplaceState(r, r.state, null);
      }
    }
    function Zb(e, r, c, g) {
      yD(e, r, c);
      var x = e.stateNode;
      x.props = c, x.state = e.memoizedState, x.refs = yk, Ib(e);
      var R = r.contextType;
      if (typeof R == "object" && R !== null)
        x.context = Hr(R);
      else {
        var _ = lf(e, r, !0);
        x.context = uf(e, _);
      }
      {
        if (x.state === c) {
          var H = yt(r) || "Component";
          Xb.has(H) || (Xb.add(H), T("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", H));
        }
        e.mode & Kn && _s.recordLegacyContextWarning(e, x), _s.recordUnsafeLifecycleWarnings(e, x);
      }
      x.state = e.memoizedState;
      var W = r.getDerivedStateFromProps;
      if (typeof W == "function" && ($b(e, r, W, c), x.state = e.memoizedState), typeof r.getDerivedStateFromProps != "function" && typeof x.getSnapshotBeforeUpdate != "function" && (typeof x.UNSAFE_componentWillMount == "function" || typeof x.componentWillMount == "function") && (xD(e, x), Cm(e, c, x, g), x.state = e.memoizedState), typeof x.componentDidMount == "function") {
        var J = Jt;
        J |= Ni, (e.mode & xa) !== Nt && (J |= zi), e.flags |= J;
      }
    }
    function bD(e, r, c, g) {
      var x = e.stateNode, R = e.memoizedProps;
      x.props = R;
      var _ = x.context, H = r.contextType, W = Ua;
      if (typeof H == "object" && H !== null)
        W = Hr(H);
      else {
        var J = lf(e, r, !0);
        W = uf(e, J);
      }
      var ne = r.getDerivedStateFromProps, ge = typeof ne == "function" || typeof x.getSnapshotBeforeUpdate == "function";
      !ge && (typeof x.UNSAFE_componentWillReceiveProps == "function" || typeof x.componentWillReceiveProps == "function") && (R !== c || _ !== W) && Ck(e, x, c, W), vk();
      var he = e.memoizedState, Ae = x.state = he;
      if (Cm(e, c, x, g), Ae = e.memoizedState, R === c && he === Ae && !om() && !Am()) {
        if (typeof x.componentDidMount == "function") {
          var Te = Jt;
          Te |= Ni, (e.mode & xa) !== Nt && (Te |= zi), e.flags |= Te;
        }
        return !1;
      }
      typeof ne == "function" && ($b(e, r, ne, c), Ae = e.memoizedState);
      var De = Am() || wk(e, r, R, c, he, Ae, W);
      if (De) {
        if (!ge && (typeof x.UNSAFE_componentWillMount == "function" || typeof x.componentWillMount == "function") && (typeof x.componentWillMount == "function" && x.componentWillMount(), typeof x.UNSAFE_componentWillMount == "function" && x.UNSAFE_componentWillMount()), typeof x.componentDidMount == "function") {
          var ht = Jt;
          ht |= Ni, (e.mode & xa) !== Nt && (ht |= zi), e.flags |= ht;
        }
      } else {
        if (typeof x.componentDidMount == "function") {
          var Pt = Jt;
          Pt |= Ni, (e.mode & xa) !== Nt && (Pt |= zi), e.flags |= Pt;
        }
        e.memoizedProps = c, e.memoizedState = Ae;
      }
      return x.props = c, x.state = Ae, x.context = W, De;
    }
    function wD(e, r, c, g, x) {
      var R = r.stateNode;
      gk(e, r);
      var _ = r.memoizedProps, H = r.type === r.elementType ? _ : Ps(r.type, _);
      R.props = H;
      var W = r.pendingProps, J = R.context, ne = c.contextType, ge = Ua;
      if (typeof ne == "object" && ne !== null)
        ge = Hr(ne);
      else {
        var he = lf(r, c, !0);
        ge = uf(r, he);
      }
      var Ae = c.getDerivedStateFromProps, Te = typeof Ae == "function" || typeof R.getSnapshotBeforeUpdate == "function";
      !Te && (typeof R.UNSAFE_componentWillReceiveProps == "function" || typeof R.componentWillReceiveProps == "function") && (_ !== W || J !== ge) && Ck(r, R, g, ge), vk();
      var De = r.memoizedState, ht = R.state = De;
      if (Cm(r, g, R, x), ht = r.memoizedState, _ === W && De === ht && !om() && !Am() && !ft)
        return typeof R.componentDidUpdate == "function" && (_ !== e.memoizedProps || De !== e.memoizedState) && (r.flags |= Jt), typeof R.getSnapshotBeforeUpdate == "function" && (_ !== e.memoizedProps || De !== e.memoizedState) && (r.flags |= ga), !1;
      typeof Ae == "function" && ($b(r, c, Ae, g), ht = r.memoizedState);
      var Pt = Am() || wk(r, c, H, g, De, ht, ge) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      ft;
      return Pt ? (!Te && (typeof R.UNSAFE_componentWillUpdate == "function" || typeof R.componentWillUpdate == "function") && (typeof R.componentWillUpdate == "function" && R.componentWillUpdate(g, ht, ge), typeof R.UNSAFE_componentWillUpdate == "function" && R.UNSAFE_componentWillUpdate(g, ht, ge)), typeof R.componentDidUpdate == "function" && (r.flags |= Jt), typeof R.getSnapshotBeforeUpdate == "function" && (r.flags |= ga)) : (typeof R.componentDidUpdate == "function" && (_ !== e.memoizedProps || De !== e.memoizedState) && (r.flags |= Jt), typeof R.getSnapshotBeforeUpdate == "function" && (_ !== e.memoizedProps || De !== e.memoizedState) && (r.flags |= ga), r.memoizedProps = g, r.memoizedState = ht), R.props = g, R.state = ht, R.context = ge, Pt;
    }
    var Qb, Kb, Jb, e0, t0, Ak = function(e, r) {
    };
    Qb = !1, Kb = !1, Jb = {}, e0 = {}, t0 = {}, Ak = function(e, r) {
      if (!(e === null || typeof e != "object") && !(!e._store || e._store.validated || e.key != null)) {
        if (typeof e._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        e._store.validated = !0;
        var c = vt(r) || "Component";
        e0[c] || (e0[c] = !0, T('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function Sp(e, r, c) {
      var g = c.ref;
      if (g !== null && typeof g != "function" && typeof g != "object") {
        if ((e.mode & Kn || kt) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(c._owner && c._self && c._owner.stateNode !== c._self)) {
          var x = vt(e) || "Component";
          Jb[x] || (T('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', g), Jb[x] = !0);
        }
        if (c._owner) {
          var R = c._owner, _;
          if (R) {
            var H = R;
            if (H.tag !== U)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            _ = H.stateNode;
          }
          if (!_)
            throw new Error("Missing owner for string ref " + g + ". This error is likely caused by a bug in React. Please file an issue.");
          var W = _;
          _a(g, "ref");
          var J = "" + g;
          if (r !== null && r.ref !== null && typeof r.ref == "function" && r.ref._stringRef === J)
            return r.ref;
          var ne = function(ge) {
            var he = W.refs;
            he === yk && (he = W.refs = {}), ge === null ? delete he[J] : he[J] = ge;
          };
          return ne._stringRef = J, ne;
        } else {
          if (typeof g != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!c._owner)
            throw new Error("Element ref was specified as a string (" + g + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return g;
    }
    function Em(e, r) {
      var c = Object.prototype.toString.call(r);
      throw new Error("Objects are not valid as a React child (found: " + (c === "[object Object]" ? "object with keys {" + Object.keys(r).join(", ") + "}" : c) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Rm(e) {
      {
        var r = vt(e) || "Component";
        if (t0[r])
          return;
        t0[r] = !0, T("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function Tk(e) {
      var r = e._payload, c = e._init;
      return c(r);
    }
    function Ek(e) {
      function r(xe, Oe) {
        if (e) {
          var be = xe.deletions;
          be === null ? (xe.deletions = [Oe], xe.flags |= Sn) : be.push(Oe);
        }
      }
      function c(xe, Oe) {
        if (!e)
          return null;
        for (var be = Oe; be !== null; )
          r(xe, be), be = be.sibling;
        return null;
      }
      function g(xe, Oe) {
        for (var be = /* @__PURE__ */ new Map(), Xe = Oe; Xe !== null; )
          Xe.key !== null ? be.set(Xe.key, Xe) : be.set(Xe.index, Xe), Xe = Xe.sibling;
        return be;
      }
      function x(xe, Oe) {
        var be = zc(xe, Oe);
        return be.index = 0, be.sibling = null, be;
      }
      function R(xe, Oe, be) {
        if (xe.index = be, !e)
          return xe.flags |= gh, Oe;
        var Xe = xe.alternate;
        if (Xe !== null) {
          var pt = Xe.index;
          return pt < Oe ? (xe.flags |= Bn, Oe) : pt;
        } else
          return xe.flags |= Bn, Oe;
      }
      function _(xe) {
        return e && xe.alternate === null && (xe.flags |= Bn), xe;
      }
      function H(xe, Oe, be, Xe) {
        if (Oe === null || Oe.tag !== ae) {
          var pt = Rw(be, xe.mode, Xe);
          return pt.return = xe, pt;
        } else {
          var st = x(Oe, be);
          return st.return = xe, st;
        }
      }
      function W(xe, Oe, be, Xe) {
        var pt = be.type;
        if (pt === bi)
          return ne(xe, Oe, be.props.children, Xe, be.key);
        if (Oe !== null && (Oe.elementType === pt || // Keep this check inline so it only runs on the false path:
        mA(Oe, be) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof pt == "object" && pt !== null && pt.$$typeof === Ot && Tk(pt) === Oe.type)) {
          var st = x(Oe, be.props);
          return st.ref = Sp(xe, Oe, be), st.return = xe, st._debugSource = be._source, st._debugOwner = be._owner, st;
        }
        var Bt = Ew(be, xe.mode, Xe);
        return Bt.ref = Sp(xe, Oe, be), Bt.return = xe, Bt;
      }
      function J(xe, Oe, be, Xe) {
        if (Oe === null || Oe.tag !== te || Oe.stateNode.containerInfo !== be.containerInfo || Oe.stateNode.implementation !== be.implementation) {
          var pt = Lw(be, xe.mode, Xe);
          return pt.return = xe, pt;
        } else {
          var st = x(Oe, be.children || []);
          return st.return = xe, st;
        }
      }
      function ne(xe, Oe, be, Xe, pt) {
        if (Oe === null || Oe.tag !== ue) {
          var st = Eu(be, xe.mode, Xe, pt);
          return st.return = xe, st;
        } else {
          var Bt = x(Oe, be);
          return Bt.return = xe, Bt;
        }
      }
      function ge(xe, Oe, be) {
        if (typeof Oe == "string" && Oe !== "" || typeof Oe == "number") {
          var Xe = Rw("" + Oe, xe.mode, be);
          return Xe.return = xe, Xe;
        }
        if (typeof Oe == "object" && Oe !== null) {
          switch (Oe.$$typeof) {
            case Na: {
              var pt = Ew(Oe, xe.mode, be);
              return pt.ref = Sp(xe, null, Oe), pt.return = xe, pt;
            }
            case jr: {
              var st = Lw(Oe, xe.mode, be);
              return st.return = xe, st;
            }
            case Ot: {
              var Bt = Oe._payload, $t = Oe._init;
              return ge(xe, $t(Bt), be);
            }
          }
          if (_r(Oe) || f(Oe)) {
            var _n = Eu(Oe, xe.mode, be, null);
            return _n.return = xe, _n;
          }
          Em(xe, Oe);
        }
        return typeof Oe == "function" && Rm(xe), null;
      }
      function he(xe, Oe, be, Xe) {
        var pt = Oe !== null ? Oe.key : null;
        if (typeof be == "string" && be !== "" || typeof be == "number")
          return pt !== null ? null : H(xe, Oe, "" + be, Xe);
        if (typeof be == "object" && be !== null) {
          switch (be.$$typeof) {
            case Na:
              return be.key === pt ? W(xe, Oe, be, Xe) : null;
            case jr:
              return be.key === pt ? J(xe, Oe, be, Xe) : null;
            case Ot: {
              var st = be._payload, Bt = be._init;
              return he(xe, Oe, Bt(st), Xe);
            }
          }
          if (_r(be) || f(be))
            return pt !== null ? null : ne(xe, Oe, be, Xe, null);
          Em(xe, be);
        }
        return typeof be == "function" && Rm(xe), null;
      }
      function Ae(xe, Oe, be, Xe, pt) {
        if (typeof Xe == "string" && Xe !== "" || typeof Xe == "number") {
          var st = xe.get(be) || null;
          return H(Oe, st, "" + Xe, pt);
        }
        if (typeof Xe == "object" && Xe !== null) {
          switch (Xe.$$typeof) {
            case Na: {
              var Bt = xe.get(Xe.key === null ? be : Xe.key) || null;
              return W(Oe, Bt, Xe, pt);
            }
            case jr: {
              var $t = xe.get(Xe.key === null ? be : Xe.key) || null;
              return J(Oe, $t, Xe, pt);
            }
            case Ot:
              var _n = Xe._payload, mn = Xe._init;
              return Ae(xe, Oe, be, mn(_n), pt);
          }
          if (_r(Xe) || f(Xe)) {
            var Lr = xe.get(be) || null;
            return ne(Oe, Lr, Xe, pt, null);
          }
          Em(Oe, Xe);
        }
        return typeof Xe == "function" && Rm(Oe), null;
      }
      function Te(xe, Oe, be) {
        {
          if (typeof xe != "object" || xe === null)
            return Oe;
          switch (xe.$$typeof) {
            case Na:
            case jr:
              Ak(xe, be);
              var Xe = xe.key;
              if (typeof Xe != "string")
                break;
              if (Oe === null) {
                Oe = /* @__PURE__ */ new Set(), Oe.add(Xe);
                break;
              }
              if (!Oe.has(Xe)) {
                Oe.add(Xe);
                break;
              }
              T("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", Xe);
              break;
            case Ot:
              var pt = xe._payload, st = xe._init;
              Te(st(pt), Oe, be);
              break;
          }
        }
        return Oe;
      }
      function De(xe, Oe, be, Xe) {
        for (var pt = null, st = 0; st < be.length; st++) {
          var Bt = be[st];
          pt = Te(Bt, pt, xe);
        }
        for (var $t = null, _n = null, mn = Oe, Lr = 0, yn = 0, Sr = null; mn !== null && yn < be.length; yn++) {
          mn.index > yn ? (Sr = mn, mn = null) : Sr = mn.sibling;
          var Xi = he(xe, mn, be[yn], Xe);
          if (Xi === null) {
            mn === null && (mn = Sr);
            break;
          }
          e && mn && Xi.alternate === null && r(xe, mn), Lr = R(Xi, Lr, yn), _n === null ? $t = Xi : _n.sibling = Xi, _n = Xi, mn = Sr;
        }
        if (yn === be.length) {
          if (c(xe, mn), ki()) {
            var Mi = yn;
            kc(xe, Mi);
          }
          return $t;
        }
        if (mn === null) {
          for (; yn < be.length; yn++) {
            var Wa = ge(xe, be[yn], Xe);
            Wa !== null && (Lr = R(Wa, Lr, yn), _n === null ? $t = Wa : _n.sibling = Wa, _n = Wa);
          }
          if (ki()) {
            var ua = yn;
            kc(xe, ua);
          }
          return $t;
        }
        for (var ca = g(xe, mn); yn < be.length; yn++) {
          var Vi = Ae(ca, xe, yn, be[yn], Xe);
          Vi !== null && (e && Vi.alternate !== null && ca.delete(Vi.key === null ? yn : Vi.key), Lr = R(Vi, Lr, yn), _n === null ? $t = Vi : _n.sibling = Vi, _n = Vi);
        }
        if (e && ca.forEach(function(Df) {
          return r(xe, Df);
        }), ki()) {
          var bl = yn;
          kc(xe, bl);
        }
        return $t;
      }
      function ht(xe, Oe, be, Xe) {
        var pt = f(be);
        if (typeof pt != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          be[Symbol.toStringTag] === "Generator" && (Kb || T("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Kb = !0), be.entries === pt && (Qb || T("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Qb = !0);
          var st = pt.call(be);
          if (st)
            for (var Bt = null, $t = st.next(); !$t.done; $t = st.next()) {
              var _n = $t.value;
              Bt = Te(_n, Bt, xe);
            }
        }
        var mn = pt.call(be);
        if (mn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Lr = null, yn = null, Sr = Oe, Xi = 0, Mi = 0, Wa = null, ua = mn.next(); Sr !== null && !ua.done; Mi++, ua = mn.next()) {
          Sr.index > Mi ? (Wa = Sr, Sr = null) : Wa = Sr.sibling;
          var ca = he(xe, Sr, ua.value, Xe);
          if (ca === null) {
            Sr === null && (Sr = Wa);
            break;
          }
          e && Sr && ca.alternate === null && r(xe, Sr), Xi = R(ca, Xi, Mi), yn === null ? Lr = ca : yn.sibling = ca, yn = ca, Sr = Wa;
        }
        if (ua.done) {
          if (c(xe, Sr), ki()) {
            var Vi = Mi;
            kc(xe, Vi);
          }
          return Lr;
        }
        if (Sr === null) {
          for (; !ua.done; Mi++, ua = mn.next()) {
            var bl = ge(xe, ua.value, Xe);
            bl !== null && (Xi = R(bl, Xi, Mi), yn === null ? Lr = bl : yn.sibling = bl, yn = bl);
          }
          if (ki()) {
            var Df = Mi;
            kc(xe, Df);
          }
          return Lr;
        }
        for (var Kp = g(xe, Sr); !ua.done; Mi++, ua = mn.next()) {
          var Ro = Ae(Kp, xe, Mi, ua.value, Xe);
          Ro !== null && (e && Ro.alternate !== null && Kp.delete(Ro.key === null ? Mi : Ro.key), Xi = R(Ro, Xi, Mi), yn === null ? Lr = Ro : yn.sibling = Ro, yn = Ro);
        }
        if (e && Kp.forEach(function(N_) {
          return r(xe, N_);
        }), ki()) {
          var P_ = Mi;
          kc(xe, P_);
        }
        return Lr;
      }
      function Pt(xe, Oe, be, Xe) {
        if (Oe !== null && Oe.tag === ae) {
          c(xe, Oe.sibling);
          var pt = x(Oe, be);
          return pt.return = xe, pt;
        }
        c(xe, Oe);
        var st = Rw(be, xe.mode, Xe);
        return st.return = xe, st;
      }
      function Tt(xe, Oe, be, Xe) {
        for (var pt = be.key, st = Oe; st !== null; ) {
          if (st.key === pt) {
            var Bt = be.type;
            if (Bt === bi) {
              if (st.tag === ue) {
                c(xe, st.sibling);
                var $t = x(st, be.props.children);
                return $t.return = xe, $t._debugSource = be._source, $t._debugOwner = be._owner, $t;
              }
            } else if (st.elementType === Bt || // Keep this check inline so it only runs on the false path:
            mA(st, be) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Bt == "object" && Bt !== null && Bt.$$typeof === Ot && Tk(Bt) === st.type) {
              c(xe, st.sibling);
              var _n = x(st, be.props);
              return _n.ref = Sp(xe, st, be), _n.return = xe, _n._debugSource = be._source, _n._debugOwner = be._owner, _n;
            }
            c(xe, st);
            break;
          } else
            r(xe, st);
          st = st.sibling;
        }
        if (be.type === bi) {
          var mn = Eu(be.props.children, xe.mode, Xe, be.key);
          return mn.return = xe, mn;
        } else {
          var Lr = Ew(be, xe.mode, Xe);
          return Lr.ref = Sp(xe, Oe, be), Lr.return = xe, Lr;
        }
      }
      function hn(xe, Oe, be, Xe) {
        for (var pt = be.key, st = Oe; st !== null; ) {
          if (st.key === pt)
            if (st.tag === te && st.stateNode.containerInfo === be.containerInfo && st.stateNode.implementation === be.implementation) {
              c(xe, st.sibling);
              var Bt = x(st, be.children || []);
              return Bt.return = xe, Bt;
            } else {
              c(xe, st);
              break;
            }
          else
            r(xe, st);
          st = st.sibling;
        }
        var $t = Lw(be, xe.mode, Xe);
        return $t.return = xe, $t;
      }
      function on(xe, Oe, be, Xe) {
        var pt = typeof be == "object" && be !== null && be.type === bi && be.key === null;
        if (pt && (be = be.props.children), typeof be == "object" && be !== null) {
          switch (be.$$typeof) {
            case Na:
              return _(Tt(xe, Oe, be, Xe));
            case jr:
              return _(hn(xe, Oe, be, Xe));
            case Ot:
              var st = be._payload, Bt = be._init;
              return on(xe, Oe, Bt(st), Xe);
          }
          if (_r(be))
            return De(xe, Oe, be, Xe);
          if (f(be))
            return ht(xe, Oe, be, Xe);
          Em(xe, be);
        }
        return typeof be == "string" && be !== "" || typeof be == "number" ? _(Pt(xe, Oe, "" + be, Xe)) : (typeof be == "function" && Rm(xe), c(xe, Oe));
      }
      return on;
    }
    var gf = Ek(!0), Rk = Ek(!1);
    function SD(e, r) {
      if (e !== null && r.child !== e.child)
        throw new Error("Resuming work not yet implemented.");
      if (r.child !== null) {
        var c = r.child, g = zc(c, c.pendingProps);
        for (r.child = g, g.return = r; c.sibling !== null; )
          c = c.sibling, g = g.sibling = zc(c, c.pendingProps), g.return = r;
        g.sibling = null;
      }
    }
    function kD(e, r) {
      for (var c = e.child; c !== null; )
        K2(c, r), c = c.sibling;
    }
    var kp = {}, yu = hu(kp), Cp = hu(kp), Lm = hu(kp);
    function Mm(e) {
      if (e === kp)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return e;
    }
    function Lk() {
      var e = Mm(Lm.current);
      return e;
    }
    function n0(e, r) {
      Bi(Lm, r, e), Bi(Cp, e, e), Bi(yu, kp, e);
      var c = IL(r);
      Ui(yu, e), Bi(yu, c, e);
    }
    function vf(e) {
      Ui(yu, e), Ui(Cp, e), Ui(Lm, e);
    }
    function r0() {
      var e = Mm(yu.current);
      return e;
    }
    function Mk(e) {
      Mm(Lm.current);
      var r = Mm(yu.current), c = FL(r, e.type);
      r !== c && (Bi(Cp, e, e), Bi(yu, c, e));
    }
    function i0(e) {
      Cp.current === e && (Ui(yu, e), Ui(Cp, e));
    }
    var CD = 0, Dk = 1, Ok = 1, Ap = 2, Ns = hu(CD);
    function a0(e, r) {
      return (e & r) !== 0;
    }
    function mf(e) {
      return e & Dk;
    }
    function s0(e, r) {
      return e & Dk | r;
    }
    function AD(e, r) {
      return e | r;
    }
    function xu(e, r) {
      Bi(Ns, r, e);
    }
    function yf(e) {
      Ui(Ns, e);
    }
    function TD(e, r) {
      var c = e.memoizedState;
      return c !== null ? c.dehydrated !== null : (e.memoizedProps, !0);
    }
    function Dm(e) {
      for (var r = e; r !== null; ) {
        if (r.tag === re) {
          var c = r.memoizedState;
          if (c !== null) {
            var g = c.dehydrated;
            if (g === null || US(g) || fb(g))
              return r;
          }
        } else if (r.tag === it && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        r.memoizedProps.revealOrder !== void 0) {
          var x = (r.flags & Wt) !== _t;
          if (x)
            return r;
        } else if (r.child !== null) {
          r.child.return = r, r = r.child;
          continue;
        }
        if (r === e)
          return null;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === e)
            return null;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
      return null;
    }
    var Ea = (
      /*   */
      0
    ), Vr = (
      /* */
      1
    ), wo = (
      /*  */
      2
    ), Gr = (
      /*    */
      4
    ), Ci = (
      /*   */
      8
    ), o0 = [];
    function l0() {
      for (var e = 0; e < o0.length; e++) {
        var r = o0[e];
        r._workInProgressVersionPrimary = null;
      }
      o0.length = 0;
    }
    function ED(e, r) {
      var c = r._getVersion, g = c(r._source);
      e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [r, g] : e.mutableSourceEagerHydrationData.push(r, g);
    }
    var ut = h.ReactCurrentDispatcher, Tp = h.ReactCurrentBatchConfig, u0, xf;
    u0 = /* @__PURE__ */ new Set();
    var Lc = Pe, On = null, $r = null, qr = null, Om = !1, Ep = !1, Rp = 0, RD = 0, LD = 25, ze = null, rs = null, bu = -1, c0 = !1;
    function Tn() {
      {
        var e = ze;
        rs === null ? rs = [e] : rs.push(e);
      }
    }
    function rt() {
      {
        var e = ze;
        rs !== null && (bu++, rs[bu] !== e && MD(e));
      }
    }
    function bf(e) {
      e != null && !_r(e) && T("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", ze, typeof e);
    }
    function MD(e) {
      {
        var r = vt(On);
        if (!u0.has(r) && (u0.add(r), rs !== null)) {
          for (var c = "", g = 30, x = 0; x <= bu; x++) {
            for (var R = rs[x], _ = x === bu ? e : R, H = x + 1 + ". " + R; H.length < g; )
              H += " ";
            H += _ + `
`, c += H;
          }
          T(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, r, c);
        }
      }
    }
    function Wi() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function d0(e, r) {
      if (c0)
        return !1;
      if (r === null)
        return T("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", ze), !1;
      e.length !== r.length && T(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, ze, "[" + r.join(", ") + "]", "[" + e.join(", ") + "]");
      for (var c = 0; c < r.length && c < e.length; c++)
        if (!bt(e[c], r[c]))
          return !1;
      return !0;
    }
    function wf(e, r, c, g, x, R) {
      Lc = R, On = r, rs = e !== null ? e._debugHookTypes : null, bu = -1, c0 = e !== null && e.type !== r.type, r.memoizedState = null, r.updateQueue = null, r.lanes = Pe, e !== null && e.memoizedState !== null ? ut.current = eC : rs !== null ? ut.current = Jk : ut.current = Kk;
      var _ = c(g, x);
      if (Ep) {
        var H = 0;
        do {
          if (Ep = !1, Rp = 0, H >= LD)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          H += 1, c0 = !1, $r = null, qr = null, r.updateQueue = null, bu = -1, ut.current = tC, _ = c(g, x);
        } while (Ep);
      }
      ut.current = Xm, r._debugHookTypes = rs;
      var W = $r !== null && $r.next !== null;
      if (Lc = Pe, On = null, $r = null, qr = null, ze = null, rs = null, bu = -1, e !== null && (e.flags & Br) !== (r.flags & Br) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (e.mode & nn) !== Nt && T("Internal React error: Expected static flag was missing. Please notify the React team."), Om = !1, W)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return _;
    }
    function Sf() {
      var e = Rp !== 0;
      return Rp = 0, e;
    }
    function _k(e, r, c) {
      r.updateQueue = e.updateQueue, (r.mode & xa) !== Nt ? r.flags &= ~(Uo | zi | qn | Jt) : r.flags &= ~(qn | Jt), e.lanes = Zl(e.lanes, c);
    }
    function Pk() {
      if (ut.current = Xm, Om) {
        for (var e = On.memoizedState; e !== null; ) {
          var r = e.queue;
          r !== null && (r.pending = null), e = e.next;
        }
        Om = !1;
      }
      Lc = Pe, On = null, $r = null, qr = null, rs = null, bu = -1, ze = null, Gk = !1, Ep = !1, Rp = 0;
    }
    function So() {
      var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return qr === null ? On.memoizedState = qr = e : qr = qr.next = e, qr;
    }
    function is() {
      var e;
      if ($r === null) {
        var r = On.alternate;
        r !== null ? e = r.memoizedState : e = null;
      } else
        e = $r.next;
      var c;
      if (qr === null ? c = On.memoizedState : c = qr.next, c !== null)
        qr = c, c = qr.next, $r = e;
      else {
        if (e === null)
          throw new Error("Rendered more hooks than during the previous render.");
        $r = e;
        var g = {
          memoizedState: $r.memoizedState,
          baseState: $r.baseState,
          baseQueue: $r.baseQueue,
          queue: $r.queue,
          next: null
        };
        qr === null ? On.memoizedState = qr = g : qr = qr.next = g;
      }
      return qr;
    }
    function Nk() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function f0(e, r) {
      return typeof r == "function" ? r(e) : r;
    }
    function h0(e, r, c) {
      var g = So(), x;
      c !== void 0 ? x = c(r) : x = r, g.memoizedState = g.baseState = x;
      var R = {
        pending: null,
        interleaved: null,
        lanes: Pe,
        dispatch: null,
        lastRenderedReducer: e,
        lastRenderedState: x
      };
      g.queue = R;
      var _ = R.dispatch = PD.bind(null, On, R);
      return [g.memoizedState, _];
    }
    function p0(e, r, c) {
      var g = is(), x = g.queue;
      if (x === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      x.lastRenderedReducer = e;
      var R = $r, _ = R.baseQueue, H = x.pending;
      if (H !== null) {
        if (_ !== null) {
          var W = _.next, J = H.next;
          _.next = J, H.next = W;
        }
        R.baseQueue !== _ && T("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), R.baseQueue = _ = H, x.pending = null;
      }
      if (_ !== null) {
        var ne = _.next, ge = R.baseState, he = null, Ae = null, Te = null, De = ne;
        do {
          var ht = De.lane;
          if (Ko(Lc, ht)) {
            if (Te !== null) {
              var Tt = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: dn,
                action: De.action,
                hasEagerState: De.hasEagerState,
                eagerState: De.eagerState,
                next: null
              };
              Te = Te.next = Tt;
            }
            if (De.hasEagerState)
              ge = De.eagerState;
            else {
              var hn = De.action;
              ge = e(ge, hn);
            }
          } else {
            var Pt = {
              lane: ht,
              action: De.action,
              hasEagerState: De.hasEagerState,
              eagerState: De.eagerState,
              next: null
            };
            Te === null ? (Ae = Te = Pt, he = ge) : Te = Te.next = Pt, On.lanes = en(On.lanes, ht), Gp(ht);
          }
          De = De.next;
        } while (De !== null && De !== ne);
        Te === null ? he = ge : Te.next = Ae, bt(ge, g.memoizedState) || Np(), g.memoizedState = ge, g.baseState = he, g.baseQueue = Te, x.lastRenderedState = ge;
      }
      var on = x.interleaved;
      if (on !== null) {
        var xe = on;
        do {
          var Oe = xe.lane;
          On.lanes = en(On.lanes, Oe), Gp(Oe), xe = xe.next;
        } while (xe !== on);
      } else
        _ === null && (x.lanes = Pe);
      var be = x.dispatch;
      return [g.memoizedState, be];
    }
    function g0(e, r, c) {
      var g = is(), x = g.queue;
      if (x === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      x.lastRenderedReducer = e;
      var R = x.dispatch, _ = x.pending, H = g.memoizedState;
      if (_ !== null) {
        x.pending = null;
        var W = _.next, J = W;
        do {
          var ne = J.action;
          H = e(H, ne), J = J.next;
        } while (J !== W);
        bt(H, g.memoizedState) || Np(), g.memoizedState = H, g.baseQueue === null && (g.baseState = H), x.lastRenderedState = H;
      }
      return [H, R];
    }
    function Ij(e, r, c) {
    }
    function Fj(e, r, c) {
    }
    function v0(e, r, c) {
      var g = On, x = So(), R, _ = ki();
      if (_) {
        if (c === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        R = c(), xf || R !== c() && (T("The result of getServerSnapshot should be cached to avoid an infinite loop"), xf = !0);
      } else {
        if (R = r(), !xf) {
          var H = r();
          bt(R, H) || (T("The result of getSnapshot should be cached to avoid an infinite loop"), xf = !0);
        }
        var W = uy();
        if (W === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        sc(W, Lc) || zk(g, r, R);
      }
      x.memoizedState = R;
      var J = {
        value: R,
        getSnapshot: r
      };
      return x.queue = J, Im(Fk.bind(null, g, J, e), [e]), g.flags |= qn, Lp(Vr | Ci, Ik.bind(null, g, J, R, r), void 0, null), R;
    }
    function _m(e, r, c) {
      var g = On, x = is(), R = r();
      if (!xf) {
        var _ = r();
        bt(R, _) || (T("The result of getSnapshot should be cached to avoid an infinite loop"), xf = !0);
      }
      var H = x.memoizedState, W = !bt(H, R);
      W && (x.memoizedState = R, Np());
      var J = x.queue;
      if (Dp(Fk.bind(null, g, J, e), [e]), J.getSnapshot !== r || W || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      qr !== null && qr.memoizedState.tag & Vr) {
        g.flags |= qn, Lp(Vr | Ci, Ik.bind(null, g, J, R, r), void 0, null);
        var ne = uy();
        if (ne === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        sc(ne, Lc) || zk(g, r, R);
      }
      return R;
    }
    function zk(e, r, c) {
      e.flags |= Qu;
      var g = {
        getSnapshot: r,
        value: c
      }, x = On.updateQueue;
      if (x === null)
        x = Nk(), On.updateQueue = x, x.stores = [g];
      else {
        var R = x.stores;
        R === null ? x.stores = [g] : R.push(g);
      }
    }
    function Ik(e, r, c, g) {
      r.value = c, r.getSnapshot = g, Yk(r) && Hk(e);
    }
    function Fk(e, r, c) {
      var g = function() {
        Yk(r) && Hk(e);
      };
      return c(g);
    }
    function Yk(e) {
      var r = e.getSnapshot, c = e.value;
      try {
        var g = r();
        return !bt(c, g);
      } catch {
        return !0;
      }
    }
    function Hk(e) {
      var r = Ta(e, Yt);
      r !== null && Jr(r, e, Yt, Fn);
    }
    function Pm(e) {
      var r = So();
      typeof e == "function" && (e = e()), r.memoizedState = r.baseState = e;
      var c = {
        pending: null,
        interleaved: null,
        lanes: Pe,
        dispatch: null,
        lastRenderedReducer: f0,
        lastRenderedState: e
      };
      r.queue = c;
      var g = c.dispatch = ND.bind(null, On, c);
      return [r.memoizedState, g];
    }
    function m0(e) {
      return p0(f0);
    }
    function y0(e) {
      return g0(f0);
    }
    function Lp(e, r, c, g) {
      var x = {
        tag: e,
        create: r,
        destroy: c,
        deps: g,
        // Circular
        next: null
      }, R = On.updateQueue;
      if (R === null)
        R = Nk(), On.updateQueue = R, R.lastEffect = x.next = x;
      else {
        var _ = R.lastEffect;
        if (_ === null)
          R.lastEffect = x.next = x;
        else {
          var H = _.next;
          _.next = x, x.next = H, R.lastEffect = x;
        }
      }
      return x;
    }
    function x0(e) {
      var r = So();
      {
        var c = {
          current: e
        };
        return r.memoizedState = c, c;
      }
    }
    function Nm(e) {
      var r = is();
      return r.memoizedState;
    }
    function Mp(e, r, c, g) {
      var x = So(), R = g === void 0 ? null : g;
      On.flags |= e, x.memoizedState = Lp(Vr | r, c, void 0, R);
    }
    function zm(e, r, c, g) {
      var x = is(), R = g === void 0 ? null : g, _ = void 0;
      if ($r !== null) {
        var H = $r.memoizedState;
        if (_ = H.destroy, R !== null) {
          var W = H.deps;
          if (d0(R, W)) {
            x.memoizedState = Lp(r, c, _, R);
            return;
          }
        }
      }
      On.flags |= e, x.memoizedState = Lp(Vr | r, c, _, R);
    }
    function Im(e, r) {
      return (On.mode & xa) !== Nt ? Mp(Uo | qn | ro, Ci, e, r) : Mp(qn | ro, Ci, e, r);
    }
    function Dp(e, r) {
      return zm(qn, Ci, e, r);
    }
    function b0(e, r) {
      return Mp(Jt, wo, e, r);
    }
    function Fm(e, r) {
      return zm(Jt, wo, e, r);
    }
    function w0(e, r) {
      var c = Jt;
      return c |= Ni, (On.mode & xa) !== Nt && (c |= zi), Mp(c, Gr, e, r);
    }
    function Ym(e, r) {
      return zm(Jt, Gr, e, r);
    }
    function jk(e, r) {
      if (typeof r == "function") {
        var c = r, g = e();
        return c(g), function() {
          c(null);
        };
      } else if (r != null) {
        var x = r;
        x.hasOwnProperty("current") || T("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(x).join(", ") + "}");
        var R = e();
        return x.current = R, function() {
          x.current = null;
        };
      }
    }
    function S0(e, r, c) {
      typeof r != "function" && T("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", r !== null ? typeof r : "null");
      var g = c != null ? c.concat([e]) : null, x = Jt;
      return x |= Ni, (On.mode & xa) !== Nt && (x |= zi), Mp(x, Gr, jk.bind(null, r, e), g);
    }
    function Hm(e, r, c) {
      typeof r != "function" && T("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", r !== null ? typeof r : "null");
      var g = c != null ? c.concat([e]) : null;
      return zm(Jt, Gr, jk.bind(null, r, e), g);
    }
    function DD(e, r) {
    }
    var jm = DD;
    function k0(e, r) {
      var c = So(), g = r === void 0 ? null : r;
      return c.memoizedState = [e, g], e;
    }
    function Um(e, r) {
      var c = is(), g = r === void 0 ? null : r, x = c.memoizedState;
      if (x !== null && g !== null) {
        var R = x[1];
        if (d0(g, R))
          return x[0];
      }
      return c.memoizedState = [e, g], e;
    }
    function C0(e, r) {
      var c = So(), g = r === void 0 ? null : r, x = e();
      return c.memoizedState = [x, g], x;
    }
    function Bm(e, r) {
      var c = is(), g = r === void 0 ? null : r, x = c.memoizedState;
      if (x !== null && g !== null) {
        var R = x[1];
        if (d0(g, R))
          return x[0];
      }
      var _ = e();
      return c.memoizedState = [_, g], _;
    }
    function A0(e) {
      var r = So();
      return r.memoizedState = e, e;
    }
    function Uk(e) {
      var r = is(), c = $r, g = c.memoizedState;
      return Wk(r, g, e);
    }
    function Bk(e) {
      var r = is();
      if ($r === null)
        return r.memoizedState = e, e;
      var c = $r.memoizedState;
      return Wk(r, c, e);
    }
    function Wk(e, r, c) {
      var g = !Dx(Lc);
      if (g) {
        if (!bt(c, r)) {
          var x = Oh();
          On.lanes = en(On.lanes, x), Gp(x), e.baseState = !0;
        }
        return r;
      } else
        return e.baseState && (e.baseState = !1, Np()), e.memoizedState = c, c;
    }
    function OD(e, r, c) {
      var g = wa();
      Tr(di(g, Xr)), e(!0);
      var x = Tp.transition;
      Tp.transition = {};
      var R = Tp.transition;
      Tp.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        e(!1), r();
      } finally {
        if (Tr(g), Tp.transition = x, x === null && R._updatedFibers) {
          var _ = R._updatedFibers.size;
          _ > 10 && C("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), R._updatedFibers.clear();
        }
      }
    }
    function T0() {
      var e = Pm(!1), r = e[0], c = e[1], g = OD.bind(null, c), x = So();
      return x.memoizedState = g, [r, g];
    }
    function Xk() {
      var e = m0(), r = e[0], c = is(), g = c.memoizedState;
      return [r, g];
    }
    function Vk() {
      var e = y0(), r = e[0], c = is(), g = c.memoizedState;
      return [r, g];
    }
    var Gk = !1;
    function _D() {
      return Gk;
    }
    function E0() {
      var e = So(), r = uy(), c = r.identifierPrefix, g;
      if (ki()) {
        var x = GM();
        g = ":" + c + "R" + x;
        var R = Rp++;
        R > 0 && (g += "H" + R.toString(32)), g += ":";
      } else {
        var _ = RD++;
        g = ":" + c + "r" + _.toString(32) + ":";
      }
      return e.memoizedState = g, g;
    }
    function Wm() {
      var e = is(), r = e.memoizedState;
      return r;
    }
    function PD(e, r, c) {
      typeof arguments[3] == "function" && T("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var g = Au(e), x = {
        lane: g,
        action: c,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if ($k(e))
        qk(r, x);
      else {
        var R = fk(e, r, x, g);
        if (R !== null) {
          var _ = la();
          Jr(R, e, g, _), Zk(R, r, g);
        }
      }
      Qk(e, g);
    }
    function ND(e, r, c) {
      typeof arguments[3] == "function" && T("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var g = Au(e), x = {
        lane: g,
        action: c,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if ($k(e))
        qk(r, x);
      else {
        var R = e.alternate;
        if (e.lanes === Pe && (R === null || R.lanes === Pe)) {
          var _ = r.lastRenderedReducer;
          if (_ !== null) {
            var H;
            H = ut.current, ut.current = zs;
            try {
              var W = r.lastRenderedState, J = _(W, c);
              if (x.hasEagerState = !0, x.eagerState = J, bt(J, W)) {
                hD(e, r, x, g);
                return;
              }
            } catch {
            } finally {
              ut.current = H;
            }
          }
        }
        var ne = fk(e, r, x, g);
        if (ne !== null) {
          var ge = la();
          Jr(ne, e, g, ge), Zk(ne, r, g);
        }
      }
      Qk(e, g);
    }
    function $k(e) {
      var r = e.alternate;
      return e === On || r !== null && r === On;
    }
    function qk(e, r) {
      Ep = Om = !0;
      var c = e.pending;
      c === null ? r.next = r : (r.next = c.next, c.next = r), e.pending = r;
    }
    function Zk(e, r, c) {
      if (Dh(c)) {
        var g = r.lanes;
        g = _h(g, e.pendingLanes);
        var x = en(g, c);
        r.lanes = x, Ql(e, x);
      }
    }
    function Qk(e, r, c) {
      uo(e, r);
    }
    var Xm = {
      readContext: Hr,
      useCallback: Wi,
      useContext: Wi,
      useEffect: Wi,
      useImperativeHandle: Wi,
      useInsertionEffect: Wi,
      useLayoutEffect: Wi,
      useMemo: Wi,
      useReducer: Wi,
      useRef: Wi,
      useState: Wi,
      useDebugValue: Wi,
      useDeferredValue: Wi,
      useTransition: Wi,
      useMutableSource: Wi,
      useSyncExternalStore: Wi,
      useId: Wi,
      unstable_isNewReconciler: We
    }, Kk = null, Jk = null, eC = null, tC = null, ko = null, zs = null, Vm = null;
    {
      var R0 = function() {
        T("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Gt = function() {
        T("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      Kk = {
        readContext: function(e) {
          return Hr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", Tn(), bf(r), k0(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", Tn(), Hr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", Tn(), bf(r), Im(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", Tn(), bf(c), S0(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", Tn(), bf(r), b0(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", Tn(), bf(r), w0(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", Tn(), bf(r);
          var c = ut.current;
          ut.current = ko;
          try {
            return C0(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", Tn();
          var g = ut.current;
          ut.current = ko;
          try {
            return h0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", Tn(), x0(e);
        },
        useState: function(e) {
          ze = "useState", Tn();
          var r = ut.current;
          ut.current = ko;
          try {
            return Pm(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", Tn(), void 0;
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", Tn(), A0(e);
        },
        useTransition: function() {
          return ze = "useTransition", Tn(), T0();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", Tn(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", Tn(), v0(e, r, c);
        },
        useId: function() {
          return ze = "useId", Tn(), E0();
        },
        unstable_isNewReconciler: We
      }, Jk = {
        readContext: function(e) {
          return Hr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", rt(), k0(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", rt(), Hr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", rt(), Im(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", rt(), S0(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", rt(), b0(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", rt(), w0(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", rt();
          var c = ut.current;
          ut.current = ko;
          try {
            return C0(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", rt();
          var g = ut.current;
          ut.current = ko;
          try {
            return h0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", rt(), x0(e);
        },
        useState: function(e) {
          ze = "useState", rt();
          var r = ut.current;
          ut.current = ko;
          try {
            return Pm(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", rt(), void 0;
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", rt(), A0(e);
        },
        useTransition: function() {
          return ze = "useTransition", rt(), T0();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", rt(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", rt(), v0(e, r, c);
        },
        useId: function() {
          return ze = "useId", rt(), E0();
        },
        unstable_isNewReconciler: We
      }, eC = {
        readContext: function(e) {
          return Hr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", rt(), Um(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", rt(), Hr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", rt(), Dp(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", rt(), Hm(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", rt(), Fm(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", rt(), Ym(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", rt();
          var c = ut.current;
          ut.current = zs;
          try {
            return Bm(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", rt();
          var g = ut.current;
          ut.current = zs;
          try {
            return p0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", rt(), Nm();
        },
        useState: function(e) {
          ze = "useState", rt();
          var r = ut.current;
          ut.current = zs;
          try {
            return m0(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", rt(), jm();
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", rt(), Uk(e);
        },
        useTransition: function() {
          return ze = "useTransition", rt(), Xk();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", rt(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", rt(), _m(e, r);
        },
        useId: function() {
          return ze = "useId", rt(), Wm();
        },
        unstable_isNewReconciler: We
      }, tC = {
        readContext: function(e) {
          return Hr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", rt(), Um(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", rt(), Hr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", rt(), Dp(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", rt(), Hm(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", rt(), Fm(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", rt(), Ym(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", rt();
          var c = ut.current;
          ut.current = Vm;
          try {
            return Bm(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", rt();
          var g = ut.current;
          ut.current = Vm;
          try {
            return g0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", rt(), Nm();
        },
        useState: function(e) {
          ze = "useState", rt();
          var r = ut.current;
          ut.current = Vm;
          try {
            return y0(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", rt(), jm();
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", rt(), Bk(e);
        },
        useTransition: function() {
          return ze = "useTransition", rt(), Vk();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", rt(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", rt(), _m(e, r);
        },
        useId: function() {
          return ze = "useId", rt(), Wm();
        },
        unstable_isNewReconciler: We
      }, ko = {
        readContext: function(e) {
          return R0(), Hr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", Gt(), Tn(), k0(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", Gt(), Tn(), Hr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", Gt(), Tn(), Im(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", Gt(), Tn(), S0(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", Gt(), Tn(), b0(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", Gt(), Tn(), w0(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", Gt(), Tn();
          var c = ut.current;
          ut.current = ko;
          try {
            return C0(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", Gt(), Tn();
          var g = ut.current;
          ut.current = ko;
          try {
            return h0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", Gt(), Tn(), x0(e);
        },
        useState: function(e) {
          ze = "useState", Gt(), Tn();
          var r = ut.current;
          ut.current = ko;
          try {
            return Pm(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", Gt(), Tn(), void 0;
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", Gt(), Tn(), A0(e);
        },
        useTransition: function() {
          return ze = "useTransition", Gt(), Tn(), T0();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", Gt(), Tn(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", Gt(), Tn(), v0(e, r, c);
        },
        useId: function() {
          return ze = "useId", Gt(), Tn(), E0();
        },
        unstable_isNewReconciler: We
      }, zs = {
        readContext: function(e) {
          return R0(), Hr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", Gt(), rt(), Um(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", Gt(), rt(), Hr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", Gt(), rt(), Dp(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", Gt(), rt(), Hm(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", Gt(), rt(), Fm(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", Gt(), rt(), Ym(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", Gt(), rt();
          var c = ut.current;
          ut.current = zs;
          try {
            return Bm(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", Gt(), rt();
          var g = ut.current;
          ut.current = zs;
          try {
            return p0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", Gt(), rt(), Nm();
        },
        useState: function(e) {
          ze = "useState", Gt(), rt();
          var r = ut.current;
          ut.current = zs;
          try {
            return m0(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", Gt(), rt(), jm();
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", Gt(), rt(), Uk(e);
        },
        useTransition: function() {
          return ze = "useTransition", Gt(), rt(), Xk();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", Gt(), rt(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", Gt(), rt(), _m(e, r);
        },
        useId: function() {
          return ze = "useId", Gt(), rt(), Wm();
        },
        unstable_isNewReconciler: We
      }, Vm = {
        readContext: function(e) {
          return R0(), Hr(e);
        },
        useCallback: function(e, r) {
          return ze = "useCallback", Gt(), rt(), Um(e, r);
        },
        useContext: function(e) {
          return ze = "useContext", Gt(), rt(), Hr(e);
        },
        useEffect: function(e, r) {
          return ze = "useEffect", Gt(), rt(), Dp(e, r);
        },
        useImperativeHandle: function(e, r, c) {
          return ze = "useImperativeHandle", Gt(), rt(), Hm(e, r, c);
        },
        useInsertionEffect: function(e, r) {
          return ze = "useInsertionEffect", Gt(), rt(), Fm(e, r);
        },
        useLayoutEffect: function(e, r) {
          return ze = "useLayoutEffect", Gt(), rt(), Ym(e, r);
        },
        useMemo: function(e, r) {
          ze = "useMemo", Gt(), rt();
          var c = ut.current;
          ut.current = zs;
          try {
            return Bm(e, r);
          } finally {
            ut.current = c;
          }
        },
        useReducer: function(e, r, c) {
          ze = "useReducer", Gt(), rt();
          var g = ut.current;
          ut.current = zs;
          try {
            return g0(e, r, c);
          } finally {
            ut.current = g;
          }
        },
        useRef: function(e) {
          return ze = "useRef", Gt(), rt(), Nm();
        },
        useState: function(e) {
          ze = "useState", Gt(), rt();
          var r = ut.current;
          ut.current = zs;
          try {
            return y0(e);
          } finally {
            ut.current = r;
          }
        },
        useDebugValue: function(e, r) {
          return ze = "useDebugValue", Gt(), rt(), jm();
        },
        useDeferredValue: function(e) {
          return ze = "useDeferredValue", Gt(), rt(), Bk(e);
        },
        useTransition: function() {
          return ze = "useTransition", Gt(), rt(), Vk();
        },
        useMutableSource: function(e, r, c) {
          return ze = "useMutableSource", Gt(), rt(), void 0;
        },
        useSyncExternalStore: function(e, r, c) {
          return ze = "useSyncExternalStore", Gt(), rt(), _m(e, r);
        },
        useId: function() {
          return ze = "useId", Gt(), rt(), Wm();
        },
        unstable_isNewReconciler: We
      };
    }
    var wu = u.unstable_now, nC = 0, Gm = -1, Op = -1, $m = -1, L0 = !1, qm = !1;
    function rC() {
      return L0;
    }
    function zD() {
      qm = !0;
    }
    function ID() {
      L0 = !1, qm = !1;
    }
    function FD() {
      L0 = qm, qm = !1;
    }
    function iC() {
      return nC;
    }
    function aC() {
      nC = wu();
    }
    function M0(e) {
      Op = wu(), e.actualStartTime < 0 && (e.actualStartTime = wu());
    }
    function sC(e) {
      Op = -1;
    }
    function Zm(e, r) {
      if (Op >= 0) {
        var c = wu() - Op;
        e.actualDuration += c, r && (e.selfBaseDuration = c), Op = -1;
      }
    }
    function Co(e) {
      if (Gm >= 0) {
        var r = wu() - Gm;
        Gm = -1;
        for (var c = e.return; c !== null; ) {
          switch (c.tag) {
            case q:
              var g = c.stateNode;
              g.effectDuration += r;
              return;
            case Re:
              var x = c.stateNode;
              x.effectDuration += r;
              return;
          }
          c = c.return;
        }
      }
    }
    function D0(e) {
      if ($m >= 0) {
        var r = wu() - $m;
        $m = -1;
        for (var c = e.return; c !== null; ) {
          switch (c.tag) {
            case q:
              var g = c.stateNode;
              g !== null && (g.passiveEffectDuration += r);
              return;
            case Re:
              var x = c.stateNode;
              x !== null && (x.passiveEffectDuration += r);
              return;
          }
          c = c.return;
        }
      }
    }
    function Ao() {
      Gm = wu();
    }
    function O0() {
      $m = wu();
    }
    function _0(e) {
      for (var r = e.child; r; )
        e.actualDuration += r.actualDuration, r = r.sibling;
    }
    function Mc(e, r) {
      return {
        value: e,
        source: r,
        stack: at(r),
        digest: null
      };
    }
    function P0(e, r, c) {
      return {
        value: e,
        source: null,
        stack: c ?? null,
        digest: r ?? null
      };
    }
    function YD(e, r) {
      return !0;
    }
    function N0(e, r) {
      try {
        var c = YD(e, r);
        if (c === !1)
          return;
        var g = r.value, x = r.source, R = r.stack, _ = R !== null ? R : "";
        if (g != null && g._suppressLogging) {
          if (e.tag === U)
            return;
          console.error(g);
        }
        var H = x ? vt(x) : null, W = H ? "The above error occurred in the <" + H + "> component:" : "The above error occurred in one of your React components:", J;
        if (e.tag === q)
          J = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var ne = vt(e) || "Anonymous";
          J = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + ne + ".");
        }
        var ge = W + `
` + _ + `

` + ("" + J);
        console.error(ge);
      } catch (he) {
        setTimeout(function() {
          throw he;
        });
      }
    }
    var HD = typeof WeakMap == "function" ? WeakMap : Map;
    function oC(e, r, c) {
      var g = pl(Fn, c);
      g.tag = Nb, g.payload = {
        element: null
      };
      var x = r.value;
      return g.callback = function() {
        O2(x), N0(e, r);
      }, g;
    }
    function z0(e, r, c) {
      var g = pl(Fn, c);
      g.tag = Nb;
      var x = e.type.getDerivedStateFromError;
      if (typeof x == "function") {
        var R = r.value;
        g.payload = function() {
          return x(R);
        }, g.callback = function() {
          yA(e), N0(e, r);
        };
      }
      var _ = e.stateNode;
      return _ !== null && typeof _.componentDidCatch == "function" && (g.callback = function() {
        yA(e), N0(e, r), typeof x != "function" && M2(this);
        var W = r.value, J = r.stack;
        this.componentDidCatch(W, {
          componentStack: J !== null ? J : ""
        }), typeof x != "function" && (ji(e.lanes, Yt) || T("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", vt(e) || "Unknown"));
      }), g;
    }
    function lC(e, r, c) {
      var g = e.pingCache, x;
      if (g === null ? (g = e.pingCache = new HD(), x = /* @__PURE__ */ new Set(), g.set(r, x)) : (x = g.get(r), x === void 0 && (x = /* @__PURE__ */ new Set(), g.set(r, x))), !x.has(c)) {
        x.add(c);
        var R = _2.bind(null, e, r, c);
        Wr && $p(e, c), r.then(R, R);
      }
    }
    function jD(e, r, c, g) {
      var x = e.updateQueue;
      if (x === null) {
        var R = /* @__PURE__ */ new Set();
        R.add(c), e.updateQueue = R;
      } else
        x.add(c);
    }
    function UD(e, r) {
      var c = e.tag;
      if ((e.mode & nn) === Nt && (c === Y || c === we || c === Me)) {
        var g = e.alternate;
        g ? (e.updateQueue = g.updateQueue, e.memoizedState = g.memoizedState, e.lanes = g.lanes) : (e.updateQueue = null, e.memoizedState = null);
      }
    }
    function uC(e) {
      var r = e;
      do {
        if (r.tag === re && TD(r))
          return r;
        r = r.return;
      } while (r !== null);
      return null;
    }
    function cC(e, r, c, g, x) {
      if ((e.mode & nn) === Nt) {
        if (e === r)
          e.flags |= Nr;
        else {
          if (e.flags |= Wt, c.flags |= Ku, c.flags &= ~(sd | ea), c.tag === U) {
            var R = c.alternate;
            if (R === null)
              c.tag = je;
            else {
              var _ = pl(Fn, Yt);
              _.tag = bm, mu(c, _, Yt);
            }
          }
          c.lanes = en(c.lanes, Yt);
        }
        return e;
      }
      return e.flags |= Nr, e.lanes = x, e;
    }
    function BD(e, r, c, g, x) {
      if (c.flags |= ea, Wr && $p(e, x), g !== null && typeof g == "object" && typeof g.then == "function") {
        var R = g;
        UD(c), ki() && c.mode & nn && ek();
        var _ = uC(r);
        if (_ !== null) {
          _.flags &= ~or, cC(_, r, c, e, x), _.mode & nn && lC(e, R, x), jD(_, e, R);
          return;
        } else {
          if (!ql(x)) {
            lC(e, R, x), gw();
            return;
          }
          var H = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          g = H;
        }
      } else if (ki() && c.mode & nn) {
        ek();
        var W = uC(r);
        if (W !== null) {
          (W.flags & Nr) === _t && (W.flags |= or), cC(W, r, c, e, x), Rb(Mc(g, c));
          return;
        }
      }
      g = Mc(g, c), S2(g);
      var J = r;
      do {
        switch (J.tag) {
          case q: {
            var ne = g;
            J.flags |= Nr;
            var ge = Ar(x);
            J.lanes = en(J.lanes, ge);
            var he = oC(J, ne, ge);
            Fb(J, he);
            return;
          }
          case U:
            var Ae = g, Te = J.type, De = J.stateNode;
            if ((J.flags & Wt) === _t && (typeof Te.getDerivedStateFromError == "function" || De !== null && typeof De.componentDidCatch == "function" && !uA(De))) {
              J.flags |= Nr;
              var ht = Ar(x);
              J.lanes = en(J.lanes, ht);
              var Pt = z0(J, Ae, ht);
              Fb(J, Pt);
              return;
            }
            break;
        }
        J = J.return;
      } while (J !== null);
    }
    function WD() {
      return null;
    }
    var _p = h.ReactCurrentOwner, Is = !1, I0, Pp, F0, Y0, H0, Dc, j0, Qm;
    I0 = {}, Pp = {}, F0 = {}, Y0 = {}, H0 = {}, Dc = !1, j0 = {}, Qm = {};
    function sa(e, r, c, g) {
      e === null ? r.child = Rk(r, null, c, g) : r.child = gf(r, e.child, c, g);
    }
    function XD(e, r, c, g) {
      r.child = gf(r, e.child, null, g), r.child = gf(r, null, c, g);
    }
    function dC(e, r, c, g, x) {
      if (r.type !== r.elementType) {
        var R = c.propTypes;
        R && Ds(
          R,
          g,
          // Resolved props
          "prop",
          yt(c)
        );
      }
      var _ = c.render, H = r.ref, W, J;
      pf(r, x), lo(r);
      {
        if (_p.current = r, za(!0), W = wf(e, r, _, g, H, x), J = Sf(), r.mode & Kn) {
          Cr(!0);
          try {
            W = wf(e, r, _, g, H, x), J = Sf();
          } finally {
            Cr(!1);
          }
        }
        za(!1);
      }
      return Bo(), e !== null && !Is ? (_k(e, r, x), gl(e, r, x)) : (ki() && J && Sb(r), r.flags |= to, sa(e, r, W, x), r.child);
    }
    function fC(e, r, c, g, x) {
      if (e === null) {
        var R = c.type;
        if (Z2(R) && c.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        c.defaultProps === void 0) {
          var _ = R;
          return _ = Mf(R), r.tag = Me, r.type = _, W0(r, R), hC(e, r, _, g, x);
        }
        {
          var H = R.propTypes;
          H && Ds(
            H,
            g,
            // Resolved props
            "prop",
            yt(R)
          );
        }
        var W = Tw(c.type, null, g, r, r.mode, x);
        return W.ref = r.ref, W.return = r, r.child = W, W;
      }
      {
        var J = c.type, ne = J.propTypes;
        ne && Ds(
          ne,
          g,
          // Resolved props
          "prop",
          yt(J)
        );
      }
      var ge = e.child, he = Z0(e, x);
      if (!he) {
        var Ae = ge.memoizedProps, Te = c.compare;
        if (Te = Te !== null ? Te : Mt, Te(Ae, g) && e.ref === r.ref)
          return gl(e, r, x);
      }
      r.flags |= to;
      var De = zc(ge, g);
      return De.ref = r.ref, De.return = r, r.child = De, De;
    }
    function hC(e, r, c, g, x) {
      if (r.type !== r.elementType) {
        var R = r.elementType;
        if (R.$$typeof === Ot) {
          var _ = R, H = _._payload, W = _._init;
          try {
            R = W(H);
          } catch {
            R = null;
          }
          var J = R && R.propTypes;
          J && Ds(
            J,
            g,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            yt(R)
          );
        }
      }
      if (e !== null) {
        var ne = e.memoizedProps;
        if (Mt(ne, g) && e.ref === r.ref && // Prevent bailout if the implementation changed due to hot reload.
        r.type === e.type)
          if (Is = !1, r.pendingProps = g = ne, Z0(e, x))
            (e.flags & Ku) !== _t && (Is = !0);
          else
            return r.lanes = e.lanes, gl(e, r, x);
      }
      return U0(e, r, c, g, x);
    }
    function pC(e, r, c) {
      var g = r.pendingProps, x = g.children, R = e !== null ? e.memoizedState : null;
      if (g.mode === "hidden" || ye)
        if ((r.mode & nn) === Nt) {
          var _ = {
            baseLanes: Pe,
            cachePool: null,
            transitions: null
          };
          r.memoizedState = _, cy(r, c);
        } else if (ji(c, Hi)) {
          var ge = {
            baseLanes: Pe,
            cachePool: null,
            transitions: null
          };
          r.memoizedState = ge;
          var he = R !== null ? R.baseLanes : c;
          cy(r, he);
        } else {
          var H = null, W;
          if (R !== null) {
            var J = R.baseLanes;
            W = en(J, c);
          } else
            W = c;
          r.lanes = r.childLanes = Hi;
          var ne = {
            baseLanes: W,
            cachePool: H,
            transitions: null
          };
          return r.memoizedState = ne, r.updateQueue = null, cy(r, W), null;
        }
      else {
        var Ae;
        R !== null ? (Ae = en(R.baseLanes, c), r.memoizedState = null) : Ae = c, cy(r, Ae);
      }
      return sa(e, r, x, c), r.child;
    }
    function VD(e, r, c) {
      var g = r.pendingProps;
      return sa(e, r, g, c), r.child;
    }
    function GD(e, r, c) {
      var g = r.pendingProps.children;
      return sa(e, r, g, c), r.child;
    }
    function $D(e, r, c) {
      {
        r.flags |= Jt;
        {
          var g = r.stateNode;
          g.effectDuration = 0, g.passiveEffectDuration = 0;
        }
      }
      var x = r.pendingProps, R = x.children;
      return sa(e, r, R, c), r.child;
    }
    function gC(e, r) {
      var c = r.ref;
      (e === null && c !== null || e !== null && e.ref !== c) && (r.flags |= Pi, r.flags |= vh);
    }
    function U0(e, r, c, g, x) {
      if (r.type !== r.elementType) {
        var R = c.propTypes;
        R && Ds(
          R,
          g,
          // Resolved props
          "prop",
          yt(c)
        );
      }
      var _;
      {
        var H = lf(r, c, !0);
        _ = uf(r, H);
      }
      var W, J;
      pf(r, x), lo(r);
      {
        if (_p.current = r, za(!0), W = wf(e, r, c, g, _, x), J = Sf(), r.mode & Kn) {
          Cr(!0);
          try {
            W = wf(e, r, c, g, _, x), J = Sf();
          } finally {
            Cr(!1);
          }
        }
        za(!1);
      }
      return Bo(), e !== null && !Is ? (_k(e, r, x), gl(e, r, x)) : (ki() && J && Sb(r), r.flags |= to, sa(e, r, W, x), r.child);
    }
    function vC(e, r, c, g, x) {
      {
        switch (d_(r)) {
          case !1: {
            var R = r.stateNode, _ = r.type, H = new _(r.memoizedProps, R.context), W = H.state;
            R.updater.enqueueSetState(R, W, null);
            break;
          }
          case !0: {
            r.flags |= Wt, r.flags |= Nr;
            var J = new Error("Simulated error coming from DevTools"), ne = Ar(x);
            r.lanes = en(r.lanes, ne);
            var ge = z0(r, Mc(J, r), ne);
            Fb(r, ge);
            break;
          }
        }
        if (r.type !== r.elementType) {
          var he = c.propTypes;
          he && Ds(
            he,
            g,
            // Resolved props
            "prop",
            yt(c)
          );
        }
      }
      var Ae;
      bo(c) ? (Ae = !0, um(r)) : Ae = !1, pf(r, x);
      var Te = r.stateNode, De;
      Te === null ? (Jm(e, r), kk(r, c, g), Zb(r, c, g, x), De = !0) : e === null ? De = bD(r, c, g, x) : De = wD(e, r, c, g, x);
      var ht = B0(e, r, c, De, Ae, x);
      {
        var Pt = r.stateNode;
        De && Pt.props !== g && (Dc || T("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", vt(r) || "a component"), Dc = !0);
      }
      return ht;
    }
    function B0(e, r, c, g, x, R) {
      gC(e, r);
      var _ = (r.flags & Wt) !== _t;
      if (!g && !_)
        return x && ZS(r, c, !1), gl(e, r, R);
      var H = r.stateNode;
      _p.current = r;
      var W;
      if (_ && typeof c.getDerivedStateFromError != "function")
        W = null, sC();
      else {
        lo(r);
        {
          if (za(!0), W = H.render(), r.mode & Kn) {
            Cr(!0);
            try {
              H.render();
            } finally {
              Cr(!1);
            }
          }
          za(!1);
        }
        Bo();
      }
      return r.flags |= to, e !== null && _ ? XD(e, r, W, R) : sa(e, r, W, R), r.memoizedState = H.state, x && ZS(r, c, !0), r.child;
    }
    function mC(e) {
      var r = e.stateNode;
      r.pendingContext ? $S(e, r.pendingContext, r.pendingContext !== r.context) : r.context && $S(e, r.context, !1), n0(e, r.containerInfo);
    }
    function qD(e, r, c) {
      if (mC(r), e === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var g = r.pendingProps, x = r.memoizedState, R = x.element;
      gk(e, r), Cm(r, g, null, c);
      var _ = r.memoizedState;
      r.stateNode;
      var H = _.element;
      if (x.isDehydrated) {
        var W = {
          element: H,
          isDehydrated: !1,
          cache: _.cache,
          pendingSuspenseBoundaries: _.pendingSuspenseBoundaries,
          transitions: _.transitions
        }, J = r.updateQueue;
        if (J.baseState = W, r.memoizedState = W, r.flags & or) {
          var ne = Mc(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), r);
          return yC(e, r, H, c, ne);
        } else if (H !== R) {
          var ge = Mc(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), r);
          return yC(e, r, H, c, ge);
        } else {
          JM(r);
          var he = Rk(r, null, H, c);
          r.child = he;
          for (var Ae = he; Ae; )
            Ae.flags = Ae.flags & ~Bn | va, Ae = Ae.sibling;
        }
      } else {
        if (ff(), H === R)
          return gl(e, r, c);
        sa(e, r, H, c);
      }
      return r.child;
    }
    function yC(e, r, c, g, x) {
      return ff(), Rb(x), r.flags |= or, sa(e, r, c, g), r.child;
    }
    function ZD(e, r, c) {
      Mk(r), e === null && Eb(r);
      var g = r.type, x = r.pendingProps, R = e !== null ? e.memoizedProps : null, _ = x.children, H = lb(g, x);
      return H ? _ = null : R !== null && lb(g, R) && (r.flags |= An), gC(e, r), sa(e, r, _, c), r.child;
    }
    function QD(e, r) {
      return e === null && Eb(r), null;
    }
    function KD(e, r, c, g) {
      Jm(e, r);
      var x = r.pendingProps, R = c, _ = R._payload, H = R._init, W = H(_);
      r.type = W;
      var J = r.tag = Q2(W), ne = Ps(W, x), ge;
      switch (J) {
        case Y:
          return W0(r, W), r.type = W = Mf(W), ge = U0(null, r, W, ne, g), ge;
        case U:
          return r.type = W = bw(W), ge = vC(null, r, W, ne, g), ge;
        case we:
          return r.type = W = ww(W), ge = dC(null, r, W, ne, g), ge;
        case ve: {
          if (r.type !== r.elementType) {
            var he = W.propTypes;
            he && Ds(
              he,
              ne,
              // Resolved for outer only
              "prop",
              yt(W)
            );
          }
          return ge = fC(
            null,
            r,
            W,
            Ps(W.type, ne),
            // The inner type can have defaults too
            g
          ), ge;
        }
      }
      var Ae = "";
      throw W !== null && typeof W == "object" && W.$$typeof === Ot && (Ae = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + W + ". " + ("Lazy element type must resolve to a class or function." + Ae));
    }
    function JD(e, r, c, g, x) {
      Jm(e, r), r.tag = U;
      var R;
      return bo(c) ? (R = !0, um(r)) : R = !1, pf(r, x), kk(r, c, g), Zb(r, c, g, x), B0(null, r, c, !0, R, x);
    }
    function eO(e, r, c, g) {
      Jm(e, r);
      var x = r.pendingProps, R;
      {
        var _ = lf(r, c, !1);
        R = uf(r, _);
      }
      pf(r, g);
      var H, W;
      lo(r);
      {
        if (c.prototype && typeof c.prototype.render == "function") {
          var J = yt(c) || "Unknown";
          I0[J] || (T("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", J, J), I0[J] = !0);
        }
        r.mode & Kn && _s.recordLegacyContextWarning(r, null), za(!0), _p.current = r, H = wf(null, r, c, x, R, g), W = Sf(), za(!1);
      }
      if (Bo(), r.flags |= to, typeof H == "object" && H !== null && typeof H.render == "function" && H.$$typeof === void 0) {
        var ne = yt(c) || "Unknown";
        Pp[ne] || (T("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ne, ne, ne), Pp[ne] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof H == "object" && H !== null && typeof H.render == "function" && H.$$typeof === void 0
      ) {
        {
          var ge = yt(c) || "Unknown";
          Pp[ge] || (T("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ge, ge, ge), Pp[ge] = !0);
        }
        r.tag = U, r.memoizedState = null, r.updateQueue = null;
        var he = !1;
        return bo(c) ? (he = !0, um(r)) : he = !1, r.memoizedState = H.state !== null && H.state !== void 0 ? H.state : null, Ib(r), Sk(r, H), Zb(r, c, x, g), B0(null, r, c, !0, he, g);
      } else {
        if (r.tag = Y, r.mode & Kn) {
          Cr(!0);
          try {
            H = wf(null, r, c, x, R, g), W = Sf();
          } finally {
            Cr(!1);
          }
        }
        return ki() && W && Sb(r), sa(null, r, H, g), W0(r, c), r.child;
      }
    }
    function W0(e, r) {
      {
        if (r && r.childContextTypes && T("%s(...): childContextTypes cannot be defined on a function component.", r.displayName || r.name || "Component"), e.ref !== null) {
          var c = "", g = oi();
          g && (c += `

Check the render method of \`` + g + "`.");
          var x = g || "", R = e._debugSource;
          R && (x = R.fileName + ":" + R.lineNumber), H0[x] || (H0[x] = !0, T("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", c));
        }
        if (typeof r.getDerivedStateFromProps == "function") {
          var _ = yt(r) || "Unknown";
          Y0[_] || (T("%s: Function components do not support getDerivedStateFromProps.", _), Y0[_] = !0);
        }
        if (typeof r.contextType == "object" && r.contextType !== null) {
          var H = yt(r) || "Unknown";
          F0[H] || (T("%s: Function components do not support contextType.", H), F0[H] = !0);
        }
      }
    }
    var X0 = {
      dehydrated: null,
      treeContext: null,
      retryLane: dn
    };
    function V0(e) {
      return {
        baseLanes: e,
        cachePool: WD(),
        transitions: null
      };
    }
    function tO(e, r) {
      var c = null;
      return {
        baseLanes: en(e.baseLanes, r),
        cachePool: c,
        transitions: e.transitions
      };
    }
    function nO(e, r, c, g) {
      if (r !== null) {
        var x = r.memoizedState;
        if (x === null)
          return !1;
      }
      return a0(e, Ap);
    }
    function rO(e, r) {
      return Zl(e.childLanes, r);
    }
    function xC(e, r, c) {
      var g = r.pendingProps;
      f_(r) && (r.flags |= Wt);
      var x = Ns.current, R = !1, _ = (r.flags & Wt) !== _t;
      if (_ || nO(x, e) ? (R = !0, r.flags &= ~Wt) : (e === null || e.memoizedState !== null) && (x = AD(x, Ok)), x = mf(x), xu(r, x), e === null) {
        Eb(r);
        var H = r.memoizedState;
        if (H !== null) {
          var W = H.dehydrated;
          if (W !== null)
            return lO(r, W);
        }
        var J = g.children, ne = g.fallback;
        if (R) {
          var ge = iO(r, J, ne, c), he = r.child;
          return he.memoizedState = V0(c), r.memoizedState = X0, ge;
        } else
          return G0(r, J);
      } else {
        var Ae = e.memoizedState;
        if (Ae !== null) {
          var Te = Ae.dehydrated;
          if (Te !== null)
            return uO(e, r, _, g, Te, Ae, c);
        }
        if (R) {
          var De = g.fallback, ht = g.children, Pt = sO(e, r, ht, De, c), Tt = r.child, hn = e.child.memoizedState;
          return Tt.memoizedState = hn === null ? V0(c) : tO(hn, c), Tt.childLanes = rO(e, c), r.memoizedState = X0, Pt;
        } else {
          var on = g.children, xe = aO(e, r, on, c);
          return r.memoizedState = null, xe;
        }
      }
    }
    function G0(e, r, c) {
      var g = e.mode, x = {
        mode: "visible",
        children: r
      }, R = $0(x, g);
      return R.return = e, e.child = R, R;
    }
    function iO(e, r, c, g) {
      var x = e.mode, R = e.child, _ = {
        mode: "hidden",
        children: r
      }, H, W;
      return (x & nn) === Nt && R !== null ? (H = R, H.childLanes = Pe, H.pendingProps = _, e.mode & Ft && (H.actualDuration = 0, H.actualStartTime = -1, H.selfBaseDuration = 0, H.treeBaseDuration = 0), W = Eu(c, x, g, null)) : (H = $0(_, x), W = Eu(c, x, g, null)), H.return = e, W.return = e, H.sibling = W, e.child = H, W;
    }
    function $0(e, r, c) {
      return bA(e, r, Pe, null);
    }
    function bC(e, r) {
      return zc(e, r);
    }
    function aO(e, r, c, g) {
      var x = e.child, R = x.sibling, _ = bC(x, {
        mode: "visible",
        children: c
      });
      if ((r.mode & nn) === Nt && (_.lanes = g), _.return = r, _.sibling = null, R !== null) {
        var H = r.deletions;
        H === null ? (r.deletions = [R], r.flags |= Sn) : H.push(R);
      }
      return r.child = _, _;
    }
    function sO(e, r, c, g, x) {
      var R = r.mode, _ = e.child, H = _.sibling, W = {
        mode: "hidden",
        children: c
      }, J;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (R & nn) === Nt && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        r.child !== _
      ) {
        var ne = r.child;
        J = ne, J.childLanes = Pe, J.pendingProps = W, r.mode & Ft && (J.actualDuration = 0, J.actualStartTime = -1, J.selfBaseDuration = _.selfBaseDuration, J.treeBaseDuration = _.treeBaseDuration), r.deletions = null;
      } else
        J = bC(_, W), J.subtreeFlags = _.subtreeFlags & Br;
      var ge;
      return H !== null ? ge = zc(H, g) : (ge = Eu(g, R, x, null), ge.flags |= Bn), ge.return = r, J.return = r, J.sibling = ge, r.child = J, ge;
    }
    function Km(e, r, c, g) {
      g !== null && Rb(g), gf(r, e.child, null, c);
      var x = r.pendingProps, R = x.children, _ = G0(r, R);
      return _.flags |= Bn, r.memoizedState = null, _;
    }
    function oO(e, r, c, g, x) {
      var R = r.mode, _ = {
        mode: "visible",
        children: c
      }, H = $0(_, R), W = Eu(g, R, x, null);
      return W.flags |= Bn, H.return = r, W.return = r, H.sibling = W, r.child = H, (r.mode & nn) !== Nt && gf(r, e.child, null, x), W;
    }
    function lO(e, r, c) {
      return (e.mode & nn) === Nt ? (T("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), e.lanes = Yt) : fb(r) ? e.lanes = Vo : e.lanes = Hi, null;
    }
    function uO(e, r, c, g, x, R, _) {
      if (c)
        if (r.flags & or) {
          r.flags &= ~or;
          var xe = P0(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return Km(e, r, _, xe);
        } else {
          if (r.memoizedState !== null)
            return r.child = e.child, r.flags |= Wt, null;
          var Oe = g.children, be = g.fallback, Xe = oO(e, r, Oe, be, _), pt = r.child;
          return pt.memoizedState = V0(_), r.memoizedState = X0, Xe;
        }
      else {
        if (QM(), (r.mode & nn) === Nt)
          return Km(
            e,
            r,
            _,
            // TODO: When we delete legacy mode, we should make this error argument
            // required — every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (fb(x)) {
          var H, W, J;
          {
            var ne = pM(x);
            H = ne.digest, W = ne.message, J = ne.stack;
          }
          var ge;
          W ? ge = new Error(W) : ge = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var he = P0(ge, H, J);
          return Km(e, r, _, he);
        }
        var Ae = ji(_, e.childLanes);
        if (Is || Ae) {
          var Te = uy();
          if (Te !== null) {
            var De = _x(Te, _);
            if (De !== dn && De !== R.retryLane) {
              R.retryLane = De;
              var ht = Fn;
              Ta(e, De), Jr(Te, e, De, ht);
            }
          }
          gw();
          var Pt = P0(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return Km(e, r, _, Pt);
        } else if (US(x)) {
          r.flags |= Wt, r.child = e.child;
          var Tt = P2.bind(null, e);
          return gM(x, Tt), null;
        } else {
          eD(r, x, R.treeContext);
          var hn = g.children, on = G0(r, hn);
          return on.flags |= va, on;
        }
      }
    }
    function wC(e, r, c) {
      e.lanes = en(e.lanes, r);
      var g = e.alternate;
      g !== null && (g.lanes = en(g.lanes, r)), _b(e.return, r, c);
    }
    function cO(e, r, c) {
      for (var g = r; g !== null; ) {
        if (g.tag === re) {
          var x = g.memoizedState;
          x !== null && wC(g, c, e);
        } else if (g.tag === it)
          wC(g, c, e);
        else if (g.child !== null) {
          g.child.return = g, g = g.child;
          continue;
        }
        if (g === e)
          return;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === e)
            return;
          g = g.return;
        }
        g.sibling.return = g.return, g = g.sibling;
      }
    }
    function dO(e) {
      for (var r = e, c = null; r !== null; ) {
        var g = r.alternate;
        g !== null && Dm(g) === null && (c = r), r = r.sibling;
      }
      return c;
    }
    function fO(e) {
      if (e !== void 0 && e !== "forwards" && e !== "backwards" && e !== "together" && !j0[e])
        if (j0[e] = !0, typeof e == "string")
          switch (e.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              T('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', e, e.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              T('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', e, e.toLowerCase());
              break;
            }
            default:
              T('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
              break;
          }
        else
          T('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', e);
    }
    function hO(e, r) {
      e !== void 0 && !Qm[e] && (e !== "collapsed" && e !== "hidden" ? (Qm[e] = !0, T('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', e)) : r !== "forwards" && r !== "backwards" && (Qm[e] = !0, T('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', e)));
    }
    function SC(e, r) {
      {
        var c = _r(e), g = !c && typeof f(e) == "function";
        if (c || g) {
          var x = c ? "array" : "iterable";
          return T("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", x, r, x), !1;
        }
      }
      return !0;
    }
    function pO(e, r) {
      if ((r === "forwards" || r === "backwards") && e !== void 0 && e !== null && e !== !1)
        if (_r(e)) {
          for (var c = 0; c < e.length; c++)
            if (!SC(e[c], c))
              return;
        } else {
          var g = f(e);
          if (typeof g == "function") {
            var x = g.call(e);
            if (x)
              for (var R = x.next(), _ = 0; !R.done; R = x.next()) {
                if (!SC(R.value, _))
                  return;
                _++;
              }
          } else
            T('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', r);
        }
    }
    function q0(e, r, c, g, x) {
      var R = e.memoizedState;
      R === null ? e.memoizedState = {
        isBackwards: r,
        rendering: null,
        renderingStartTime: 0,
        last: g,
        tail: c,
        tailMode: x
      } : (R.isBackwards = r, R.rendering = null, R.renderingStartTime = 0, R.last = g, R.tail = c, R.tailMode = x);
    }
    function kC(e, r, c) {
      var g = r.pendingProps, x = g.revealOrder, R = g.tail, _ = g.children;
      fO(x), hO(R, x), pO(_, x), sa(e, r, _, c);
      var H = Ns.current, W = a0(H, Ap);
      if (W)
        H = s0(H, Ap), r.flags |= Wt;
      else {
        var J = e !== null && (e.flags & Wt) !== _t;
        J && cO(r, r.child, c), H = mf(H);
      }
      if (xu(r, H), (r.mode & nn) === Nt)
        r.memoizedState = null;
      else
        switch (x) {
          case "forwards": {
            var ne = dO(r.child), ge;
            ne === null ? (ge = r.child, r.child = null) : (ge = ne.sibling, ne.sibling = null), q0(
              r,
              !1,
              // isBackwards
              ge,
              ne,
              R
            );
            break;
          }
          case "backwards": {
            var he = null, Ae = r.child;
            for (r.child = null; Ae !== null; ) {
              var Te = Ae.alternate;
              if (Te !== null && Dm(Te) === null) {
                r.child = Ae;
                break;
              }
              var De = Ae.sibling;
              Ae.sibling = he, he = Ae, Ae = De;
            }
            q0(
              r,
              !0,
              // isBackwards
              he,
              null,
              // last
              R
            );
            break;
          }
          case "together": {
            q0(
              r,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            r.memoizedState = null;
        }
      return r.child;
    }
    function gO(e, r, c) {
      n0(r, r.stateNode.containerInfo);
      var g = r.pendingProps;
      return e === null ? r.child = gf(r, null, g, c) : sa(e, r, g, c), r.child;
    }
    var CC = !1;
    function vO(e, r, c) {
      var g = r.type, x = g._context, R = r.pendingProps, _ = r.memoizedProps, H = R.value;
      {
        "value" in R || CC || (CC = !0, T("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var W = r.type.propTypes;
        W && Ds(W, R, "prop", "Context.Provider");
      }
      if (dk(r, x, H), _ !== null) {
        var J = _.value;
        if (bt(J, H)) {
          if (_.children === R.children && !om())
            return gl(e, r, c);
        } else
          cD(r, x, c);
      }
      var ne = R.children;
      return sa(e, r, ne, c), r.child;
    }
    var AC = !1;
    function mO(e, r, c) {
      var g = r.type;
      g._context === void 0 ? g !== g.Consumer && (AC || (AC = !0, T("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : g = g._context;
      var x = r.pendingProps, R = x.children;
      typeof R != "function" && T("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), pf(r, c);
      var _ = Hr(g);
      lo(r);
      var H;
      return _p.current = r, za(!0), H = R(_), za(!1), Bo(), r.flags |= to, sa(e, r, H, c), r.child;
    }
    function Np() {
      Is = !0;
    }
    function Jm(e, r) {
      (r.mode & nn) === Nt && e !== null && (e.alternate = null, r.alternate = null, r.flags |= Bn);
    }
    function gl(e, r, c) {
      return e !== null && (r.dependencies = e.dependencies), sC(), Gp(r.lanes), ji(c, r.childLanes) ? (SD(e, r), r.child) : null;
    }
    function yO(e, r, c) {
      {
        var g = r.return;
        if (g === null)
          throw new Error("Cannot swap the root fiber.");
        if (e.alternate = null, r.alternate = null, c.index = r.index, c.sibling = r.sibling, c.return = r.return, c.ref = r.ref, r === g.child)
          g.child = c;
        else {
          var x = g.child;
          if (x === null)
            throw new Error("Expected parent to have a child.");
          for (; x.sibling !== r; )
            if (x = x.sibling, x === null)
              throw new Error("Expected to find the previous sibling.");
          x.sibling = c;
        }
        var R = g.deletions;
        return R === null ? (g.deletions = [e], g.flags |= Sn) : R.push(e), c.flags |= Bn, c;
      }
    }
    function Z0(e, r) {
      var c = e.lanes;
      return !!ji(c, r);
    }
    function xO(e, r, c) {
      switch (r.tag) {
        case q:
          mC(r), r.stateNode, ff();
          break;
        case se:
          Mk(r);
          break;
        case U: {
          var g = r.type;
          bo(g) && um(r);
          break;
        }
        case te:
          n0(r, r.stateNode.containerInfo);
          break;
        case K: {
          var x = r.memoizedProps.value, R = r.type._context;
          dk(r, R, x);
          break;
        }
        case Re:
          {
            var _ = ji(c, r.childLanes);
            _ && (r.flags |= Jt);
            {
              var H = r.stateNode;
              H.effectDuration = 0, H.passiveEffectDuration = 0;
            }
          }
          break;
        case re: {
          var W = r.memoizedState;
          if (W !== null) {
            if (W.dehydrated !== null)
              return xu(r, mf(Ns.current)), r.flags |= Wt, null;
            var J = r.child, ne = J.childLanes;
            if (ji(c, ne))
              return xC(e, r, c);
            xu(r, mf(Ns.current));
            var ge = gl(e, r, c);
            return ge !== null ? ge.sibling : null;
          } else
            xu(r, mf(Ns.current));
          break;
        }
        case it: {
          var he = (e.flags & Wt) !== _t, Ae = ji(c, r.childLanes);
          if (he) {
            if (Ae)
              return kC(e, r, c);
            r.flags |= Wt;
          }
          var Te = r.memoizedState;
          if (Te !== null && (Te.rendering = null, Te.tail = null, Te.lastEffect = null), xu(r, Ns.current), Ae)
            break;
          return null;
        }
        case Ke:
        case Ze:
          return r.lanes = Pe, pC(e, r, c);
      }
      return gl(e, r, c);
    }
    function TC(e, r, c) {
      if (r._debugNeedsRemount && e !== null)
        return yO(e, r, Tw(r.type, r.key, r.pendingProps, r._debugOwner || null, r.mode, r.lanes));
      if (e !== null) {
        var g = e.memoizedProps, x = r.pendingProps;
        if (g !== x || om() || // Force a re-render if the implementation changed due to hot reload:
        r.type !== e.type)
          Is = !0;
        else {
          var R = Z0(e, c);
          if (!R && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (r.flags & Wt) === _t)
            return Is = !1, xO(e, r, c);
          (e.flags & Ku) !== _t ? Is = !0 : Is = !1;
        }
      } else if (Is = !1, ki() && XM(r)) {
        var _ = r.index, H = VM();
        JS(r, H, _);
      }
      switch (r.lanes = Pe, r.tag) {
        case G:
          return eO(e, r, r.type, c);
        case et: {
          var W = r.elementType;
          return KD(e, r, W, c);
        }
        case Y: {
          var J = r.type, ne = r.pendingProps, ge = r.elementType === J ? ne : Ps(J, ne);
          return U0(e, r, J, ge, c);
        }
        case U: {
          var he = r.type, Ae = r.pendingProps, Te = r.elementType === he ? Ae : Ps(he, Ae);
          return vC(e, r, he, Te, c);
        }
        case q:
          return qD(e, r, c);
        case se:
          return ZD(e, r, c);
        case ae:
          return QD(e, r);
        case re:
          return xC(e, r, c);
        case te:
          return gO(e, r, c);
        case we: {
          var De = r.type, ht = r.pendingProps, Pt = r.elementType === De ? ht : Ps(De, ht);
          return dC(e, r, De, Pt, c);
        }
        case ue:
          return VD(e, r, c);
        case Ce:
          return GD(e, r, c);
        case Re:
          return $D(e, r, c);
        case K:
          return vO(e, r, c);
        case Ne:
          return mO(e, r, c);
        case ve: {
          var Tt = r.type, hn = r.pendingProps, on = Ps(Tt, hn);
          if (r.type !== r.elementType) {
            var xe = Tt.propTypes;
            xe && Ds(
              xe,
              on,
              // Resolved for outer only
              "prop",
              yt(Tt)
            );
          }
          return on = Ps(Tt.type, on), fC(e, r, Tt, on, c);
        }
        case Me:
          return hC(e, r, r.type, r.pendingProps, c);
        case je: {
          var Oe = r.type, be = r.pendingProps, Xe = r.elementType === Oe ? be : Ps(Oe, be);
          return JD(e, r, Oe, Xe, c);
        }
        case it:
          return kC(e, r, c);
        case dt:
          break;
        case Ke:
          return pC(e, r, c);
      }
      throw new Error("Unknown unit of work tag (" + r.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function kf(e) {
      e.flags |= Jt;
    }
    function EC(e) {
      e.flags |= Pi, e.flags |= vh;
    }
    var RC, Q0, LC, MC;
    RC = function(e, r, c, g) {
      for (var x = r.child; x !== null; ) {
        if (x.tag === se || x.tag === ae)
          UL(e, x.stateNode);
        else if (x.tag !== te) {
          if (x.child !== null) {
            x.child.return = x, x = x.child;
            continue;
          }
        }
        if (x === r)
          return;
        for (; x.sibling === null; ) {
          if (x.return === null || x.return === r)
            return;
          x = x.return;
        }
        x.sibling.return = x.return, x = x.sibling;
      }
    }, Q0 = function(e, r) {
    }, LC = function(e, r, c, g, x) {
      var R = e.memoizedProps;
      if (R !== g) {
        var _ = r.stateNode, H = r0(), W = WL(_, c, R, g, x, H);
        r.updateQueue = W, W && kf(r);
      }
    }, MC = function(e, r, c, g) {
      c !== g && kf(r);
    };
    function zp(e, r) {
      if (!ki())
        switch (e.tailMode) {
          case "hidden": {
            for (var c = e.tail, g = null; c !== null; )
              c.alternate !== null && (g = c), c = c.sibling;
            g === null ? e.tail = null : g.sibling = null;
            break;
          }
          case "collapsed": {
            for (var x = e.tail, R = null; x !== null; )
              x.alternate !== null && (R = x), x = x.sibling;
            R === null ? !r && e.tail !== null ? e.tail.sibling = null : e.tail = null : R.sibling = null;
            break;
          }
        }
    }
    function Ai(e) {
      var r = e.alternate !== null && e.alternate.child === e.child, c = Pe, g = _t;
      if (r) {
        if ((e.mode & Ft) !== Nt) {
          for (var W = e.selfBaseDuration, J = e.child; J !== null; )
            c = en(c, en(J.lanes, J.childLanes)), g |= J.subtreeFlags & Br, g |= J.flags & Br, W += J.treeBaseDuration, J = J.sibling;
          e.treeBaseDuration = W;
        } else
          for (var ne = e.child; ne !== null; )
            c = en(c, en(ne.lanes, ne.childLanes)), g |= ne.subtreeFlags & Br, g |= ne.flags & Br, ne.return = e, ne = ne.sibling;
        e.subtreeFlags |= g;
      } else {
        if ((e.mode & Ft) !== Nt) {
          for (var x = e.actualDuration, R = e.selfBaseDuration, _ = e.child; _ !== null; )
            c = en(c, en(_.lanes, _.childLanes)), g |= _.subtreeFlags, g |= _.flags, x += _.actualDuration, R += _.treeBaseDuration, _ = _.sibling;
          e.actualDuration = x, e.treeBaseDuration = R;
        } else
          for (var H = e.child; H !== null; )
            c = en(c, en(H.lanes, H.childLanes)), g |= H.subtreeFlags, g |= H.flags, H.return = e, H = H.sibling;
        e.subtreeFlags |= g;
      }
      return e.childLanes = c, r;
    }
    function bO(e, r, c) {
      if (aD() && (r.mode & nn) !== Nt && (r.flags & Wt) === _t)
        return sk(r), ff(), r.flags |= or | ea | Nr, !1;
      var g = pm(r);
      if (c !== null && c.dehydrated !== null)
        if (e === null) {
          if (!g)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (rD(r), Ai(r), (r.mode & Ft) !== Nt) {
            var x = c !== null;
            if (x) {
              var R = r.child;
              R !== null && (r.treeBaseDuration -= R.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (ff(), (r.flags & Wt) === _t && (r.memoizedState = null), r.flags |= Jt, Ai(r), (r.mode & Ft) !== Nt) {
            var _ = c !== null;
            if (_) {
              var H = r.child;
              H !== null && (r.treeBaseDuration -= H.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return ok(), !0;
    }
    function DC(e, r, c) {
      var g = r.pendingProps;
      switch (kb(r), r.tag) {
        case G:
        case et:
        case Me:
        case Y:
        case we:
        case ue:
        case Ce:
        case Re:
        case Ne:
        case ve:
          return Ai(r), null;
        case U: {
          var x = r.type;
          return bo(x) && lm(r), Ai(r), null;
        }
        case q: {
          var R = r.stateNode;
          if (vf(r), xb(r), l0(), R.pendingContext && (R.context = R.pendingContext, R.pendingContext = null), e === null || e.child === null) {
            var _ = pm(r);
            if (_)
              kf(r);
            else if (e !== null) {
              var H = e.memoizedState;
              // Check if this is a client root
              (!H.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (r.flags & or) !== _t) && (r.flags |= ga, ok());
            }
          }
          return Q0(e, r), Ai(r), null;
        }
        case se: {
          i0(r);
          var W = Lk(), J = r.type;
          if (e !== null && r.stateNode != null)
            LC(e, r, J, g, W), e.ref !== r.ref && EC(r);
          else {
            if (!g) {
              if (r.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Ai(r), null;
            }
            var ne = r0(), ge = pm(r);
            if (ge)
              tD(r, W, ne) && kf(r);
            else {
              var he = jL(J, g, W, ne, r);
              RC(he, r, !1, !1), r.stateNode = he, BL(he, J, g, W) && kf(r);
            }
            r.ref !== null && EC(r);
          }
          return Ai(r), null;
        }
        case ae: {
          var Ae = g;
          if (e && r.stateNode != null) {
            var Te = e.memoizedProps;
            MC(e, r, Te, Ae);
          } else {
            if (typeof Ae != "string" && r.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var De = Lk(), ht = r0(), Pt = pm(r);
            Pt ? nD(r) && kf(r) : r.stateNode = XL(Ae, De, ht, r);
          }
          return Ai(r), null;
        }
        case re: {
          yf(r);
          var Tt = r.memoizedState;
          if (e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
            var hn = bO(e, r, Tt);
            if (!hn)
              return r.flags & Nr ? r : null;
          }
          if ((r.flags & Wt) !== _t)
            return r.lanes = c, (r.mode & Ft) !== Nt && _0(r), r;
          var on = Tt !== null, xe = e !== null && e.memoizedState !== null;
          if (on !== xe && on) {
            var Oe = r.child;
            if (Oe.flags |= no, (r.mode & nn) !== Nt) {
              var be = e === null && (r.memoizedProps.unstable_avoidThisFallback !== !0 || !Ue);
              be || a0(Ns.current, Ok) ? w2() : gw();
            }
          }
          var Xe = r.updateQueue;
          if (Xe !== null && (r.flags |= Jt), Ai(r), (r.mode & Ft) !== Nt && on) {
            var pt = r.child;
            pt !== null && (r.treeBaseDuration -= pt.treeBaseDuration);
          }
          return null;
        }
        case te:
          return vf(r), Q0(e, r), e === null && FM(r.stateNode.containerInfo), Ai(r), null;
        case K:
          var st = r.type._context;
          return Ob(st, r), Ai(r), null;
        case je: {
          var Bt = r.type;
          return bo(Bt) && lm(r), Ai(r), null;
        }
        case it: {
          yf(r);
          var $t = r.memoizedState;
          if ($t === null)
            return Ai(r), null;
          var _n = (r.flags & Wt) !== _t, mn = $t.rendering;
          if (mn === null)
            if (_n)
              zp($t, !1);
            else {
              var Lr = k2() && (e === null || (e.flags & Wt) === _t);
              if (!Lr)
                for (var yn = r.child; yn !== null; ) {
                  var Sr = Dm(yn);
                  if (Sr !== null) {
                    _n = !0, r.flags |= Wt, zp($t, !1);
                    var Xi = Sr.updateQueue;
                    return Xi !== null && (r.updateQueue = Xi, r.flags |= Jt), r.subtreeFlags = _t, kD(r, c), xu(r, s0(Ns.current, Ap)), r.child;
                  }
                  yn = yn.sibling;
                }
              $t.tail !== null && Qn() > KC() && (r.flags |= Wt, _n = !0, zp($t, !1), r.lanes = Lh);
            }
          else {
            if (!_n) {
              var Mi = Dm(mn);
              if (Mi !== null) {
                r.flags |= Wt, _n = !0;
                var Wa = Mi.updateQueue;
                if (Wa !== null && (r.updateQueue = Wa, r.flags |= Jt), zp($t, !0), $t.tail === null && $t.tailMode === "hidden" && !mn.alternate && !ki())
                  return Ai(r), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                Qn() * 2 - $t.renderingStartTime > KC() && c !== Hi && (r.flags |= Wt, _n = !0, zp($t, !1), r.lanes = Lh);
            }
            if ($t.isBackwards)
              mn.sibling = r.child, r.child = mn;
            else {
              var ua = $t.last;
              ua !== null ? ua.sibling = mn : r.child = mn, $t.last = mn;
            }
          }
          if ($t.tail !== null) {
            var ca = $t.tail;
            $t.rendering = ca, $t.tail = ca.sibling, $t.renderingStartTime = Qn(), ca.sibling = null;
            var Vi = Ns.current;
            return _n ? Vi = s0(Vi, Ap) : Vi = mf(Vi), xu(r, Vi), ca;
          }
          return Ai(r), null;
        }
        case dt:
          break;
        case Ke:
        case Ze: {
          pw(r);
          var bl = r.memoizedState, Df = bl !== null;
          if (e !== null) {
            var Kp = e.memoizedState, Ro = Kp !== null;
            Ro !== Df && // LegacyHidden doesn't do any hiding — it only pre-renders.
            !ye && (r.flags |= no);
          }
          return !Df || (r.mode & nn) === Nt ? Ai(r) : ji(Eo, Hi) && (Ai(r), r.subtreeFlags & (Bn | Jt) && (r.flags |= no)), null;
        }
        case Vt:
          return null;
        case Et:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + r.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function wO(e, r, c) {
      switch (kb(r), r.tag) {
        case U: {
          var g = r.type;
          bo(g) && lm(r);
          var x = r.flags;
          return x & Nr ? (r.flags = x & ~Nr | Wt, (r.mode & Ft) !== Nt && _0(r), r) : null;
        }
        case q: {
          r.stateNode, vf(r), xb(r), l0();
          var R = r.flags;
          return (R & Nr) !== _t && (R & Wt) === _t ? (r.flags = R & ~Nr | Wt, r) : null;
        }
        case se:
          return i0(r), null;
        case re: {
          yf(r);
          var _ = r.memoizedState;
          if (_ !== null && _.dehydrated !== null) {
            if (r.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            ff();
          }
          var H = r.flags;
          return H & Nr ? (r.flags = H & ~Nr | Wt, (r.mode & Ft) !== Nt && _0(r), r) : null;
        }
        case it:
          return yf(r), null;
        case te:
          return vf(r), null;
        case K:
          var W = r.type._context;
          return Ob(W, r), null;
        case Ke:
        case Ze:
          return pw(r), null;
        case Vt:
          return null;
        default:
          return null;
      }
    }
    function OC(e, r, c) {
      switch (kb(r), r.tag) {
        case U: {
          var g = r.type.childContextTypes;
          g != null && lm(r);
          break;
        }
        case q: {
          r.stateNode, vf(r), xb(r), l0();
          break;
        }
        case se: {
          i0(r);
          break;
        }
        case te:
          vf(r);
          break;
        case re:
          yf(r);
          break;
        case it:
          yf(r);
          break;
        case K:
          var x = r.type._context;
          Ob(x, r);
          break;
        case Ke:
        case Ze:
          pw(r);
          break;
      }
    }
    var _C = null;
    _C = /* @__PURE__ */ new Set();
    var ey = !1, Ti = !1, SO = typeof WeakSet == "function" ? WeakSet : Set, wt = null, Cf = null, Af = null;
    function kO(e) {
      jo(null, function() {
        throw e;
      }), ph();
    }
    var CO = function(e, r) {
      if (r.props = e.memoizedProps, r.state = e.memoizedState, e.mode & Ft)
        try {
          Ao(), r.componentWillUnmount();
        } finally {
          Co(e);
        }
      else
        r.componentWillUnmount();
    };
    function PC(e, r) {
      try {
        Su(Gr, e);
      } catch (c) {
        Gn(e, r, c);
      }
    }
    function K0(e, r, c) {
      try {
        CO(e, c);
      } catch (g) {
        Gn(e, r, g);
      }
    }
    function AO(e, r, c) {
      try {
        c.componentDidMount();
      } catch (g) {
        Gn(e, r, g);
      }
    }
    function NC(e, r) {
      try {
        IC(e);
      } catch (c) {
        Gn(e, r, c);
      }
    }
    function Tf(e, r) {
      var c = e.ref;
      if (c !== null)
        if (typeof c == "function") {
          var g;
          try {
            if (ot && It && e.mode & Ft)
              try {
                Ao(), g = c(null);
              } finally {
                Co(e);
              }
            else
              g = c(null);
          } catch (x) {
            Gn(e, r, x);
          }
          typeof g == "function" && T("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", vt(e));
        } else
          c.current = null;
    }
    function ty(e, r, c) {
      try {
        c();
      } catch (g) {
        Gn(e, r, g);
      }
    }
    var zC = !1;
    function TO(e, r) {
      YL(e.containerInfo), wt = r, EO();
      var c = zC;
      return zC = !1, c;
    }
    function EO() {
      for (; wt !== null; ) {
        var e = wt, r = e.child;
        (e.subtreeFlags & Ul) !== _t && r !== null ? (r.return = e, wt = r) : RO();
      }
    }
    function RO() {
      for (; wt !== null; ) {
        var e = wt;
        wn(e);
        try {
          LO(e);
        } catch (c) {
          Gn(e, e.return, c);
        }
        ln();
        var r = e.sibling;
        if (r !== null) {
          r.return = e.return, wt = r;
          return;
        }
        wt = e.return;
      }
    }
    function LO(e) {
      var r = e.alternate, c = e.flags;
      if ((c & ga) !== _t) {
        switch (wn(e), e.tag) {
          case Y:
          case we:
          case Me:
            break;
          case U: {
            if (r !== null) {
              var g = r.memoizedProps, x = r.memoizedState, R = e.stateNode;
              e.type === e.elementType && !Dc && (R.props !== e.memoizedProps && T("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", vt(e) || "instance"), R.state !== e.memoizedState && T("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", vt(e) || "instance"));
              var _ = R.getSnapshotBeforeUpdate(e.elementType === e.type ? g : Ps(e.type, g), x);
              {
                var H = _C;
                _ === void 0 && !H.has(e.type) && (H.add(e.type), T("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", vt(e)));
              }
              R.__reactInternalSnapshotBeforeUpdate = _;
            }
            break;
          }
          case q: {
            {
              var W = e.stateNode;
              cM(W.containerInfo);
            }
            break;
          }
          case se:
          case ae:
          case te:
          case je:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        ln();
      }
    }
    function Fs(e, r, c) {
      var g = r.updateQueue, x = g !== null ? g.lastEffect : null;
      if (x !== null) {
        var R = x.next, _ = R;
        do {
          if ((_.tag & e) === e) {
            var H = _.destroy;
            _.destroy = void 0, H !== void 0 && ((e & Ci) !== Ea ? pd(r) : (e & Gr) !== Ea && gd(r), (e & wo) !== Ea && qp(!0), ty(r, c, H), (e & wo) !== Ea && qp(!1), (e & Ci) !== Ea ? hv() : (e & Gr) !== Ea && Bl());
          }
          _ = _.next;
        } while (_ !== R);
      }
    }
    function Su(e, r) {
      var c = r.updateQueue, g = c !== null ? c.lastEffect : null;
      if (g !== null) {
        var x = g.next, R = x;
        do {
          if ((R.tag & e) === e) {
            (e & Ci) !== Ea ? fv(r) : (e & Gr) !== Ea && pv(r);
            var _ = R.create;
            (e & wo) !== Ea && qp(!0), R.destroy = _(), (e & wo) !== Ea && qp(!1), (e & Ci) !== Ea ? Th() : (e & Gr) !== Ea && gv();
            {
              var H = R.destroy;
              if (H !== void 0 && typeof H != "function") {
                var W = void 0;
                (R.tag & Gr) !== _t ? W = "useLayoutEffect" : (R.tag & wo) !== _t ? W = "useInsertionEffect" : W = "useEffect";
                var J = void 0;
                H === null ? J = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof H.then == "function" ? J = `

It looks like you wrote ` + W + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + W + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : J = " You returned: " + H, T("%s must not return anything besides a function, which is used for clean-up.%s", W, J);
              }
            }
          }
          R = R.next;
        } while (R !== x);
      }
    }
    function MO(e, r) {
      if ((r.flags & Jt) !== _t)
        switch (r.tag) {
          case Re: {
            var c = r.stateNode.passiveEffectDuration, g = r.memoizedProps, x = g.id, R = g.onPostCommit, _ = iC(), H = r.alternate === null ? "mount" : "update";
            rC() && (H = "nested-update"), typeof R == "function" && R(x, H, c, _);
            var W = r.return;
            e:
              for (; W !== null; ) {
                switch (W.tag) {
                  case q:
                    var J = W.stateNode;
                    J.passiveEffectDuration += c;
                    break e;
                  case Re:
                    var ne = W.stateNode;
                    ne.passiveEffectDuration += c;
                    break e;
                }
                W = W.return;
              }
            break;
          }
        }
    }
    function DO(e, r, c, g) {
      if ((c.flags & ui) !== _t)
        switch (c.tag) {
          case Y:
          case we:
          case Me: {
            if (!Ti)
              if (c.mode & Ft)
                try {
                  Ao(), Su(Gr | Vr, c);
                } finally {
                  Co(c);
                }
              else
                Su(Gr | Vr, c);
            break;
          }
          case U: {
            var x = c.stateNode;
            if (c.flags & Jt && !Ti)
              if (r === null)
                if (c.type === c.elementType && !Dc && (x.props !== c.memoizedProps && T("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", vt(c) || "instance"), x.state !== c.memoizedState && T("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", vt(c) || "instance")), c.mode & Ft)
                  try {
                    Ao(), x.componentDidMount();
                  } finally {
                    Co(c);
                  }
                else
                  x.componentDidMount();
              else {
                var R = c.elementType === c.type ? r.memoizedProps : Ps(c.type, r.memoizedProps), _ = r.memoizedState;
                if (c.type === c.elementType && !Dc && (x.props !== c.memoizedProps && T("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", vt(c) || "instance"), x.state !== c.memoizedState && T("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", vt(c) || "instance")), c.mode & Ft)
                  try {
                    Ao(), x.componentDidUpdate(R, _, x.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Co(c);
                  }
                else
                  x.componentDidUpdate(R, _, x.__reactInternalSnapshotBeforeUpdate);
              }
            var H = c.updateQueue;
            H !== null && (c.type === c.elementType && !Dc && (x.props !== c.memoizedProps && T("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", vt(c) || "instance"), x.state !== c.memoizedState && T("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", vt(c) || "instance")), mk(c, H, x));
            break;
          }
          case q: {
            var W = c.updateQueue;
            if (W !== null) {
              var J = null;
              if (c.child !== null)
                switch (c.child.tag) {
                  case se:
                    J = c.child.stateNode;
                    break;
                  case U:
                    J = c.child.stateNode;
                    break;
                }
              mk(c, W, J);
            }
            break;
          }
          case se: {
            var ne = c.stateNode;
            if (r === null && c.flags & Jt) {
              var ge = c.type, he = c.memoizedProps;
              ZL(ne, ge, he);
            }
            break;
          }
          case ae:
            break;
          case te:
            break;
          case Re: {
            {
              var Ae = c.memoizedProps, Te = Ae.onCommit, De = Ae.onRender, ht = c.stateNode.effectDuration, Pt = iC(), Tt = r === null ? "mount" : "update";
              rC() && (Tt = "nested-update"), typeof De == "function" && De(c.memoizedProps.id, Tt, c.actualDuration, c.treeBaseDuration, c.actualStartTime, Pt);
              {
                typeof Te == "function" && Te(c.memoizedProps.id, Tt, ht, Pt), R2(c);
                var hn = c.return;
                e:
                  for (; hn !== null; ) {
                    switch (hn.tag) {
                      case q:
                        var on = hn.stateNode;
                        on.effectDuration += ht;
                        break e;
                      case Re:
                        var xe = hn.stateNode;
                        xe.effectDuration += ht;
                        break e;
                    }
                    hn = hn.return;
                  }
              }
            }
            break;
          }
          case re: {
            YO(e, c);
            break;
          }
          case it:
          case je:
          case dt:
          case Ke:
          case Ze:
          case Et:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Ti || c.flags & Pi && IC(c);
    }
    function OO(e) {
      switch (e.tag) {
        case Y:
        case we:
        case Me: {
          if (e.mode & Ft)
            try {
              Ao(), PC(e, e.return);
            } finally {
              Co(e);
            }
          else
            PC(e, e.return);
          break;
        }
        case U: {
          var r = e.stateNode;
          typeof r.componentDidMount == "function" && AO(e, e.return, r), NC(e, e.return);
          break;
        }
        case se: {
          NC(e, e.return);
          break;
        }
      }
    }
    function _O(e, r) {
      for (var c = null, g = e; ; ) {
        if (g.tag === se) {
          if (c === null) {
            c = g;
            try {
              var x = g.stateNode;
              r ? sM(x) : lM(g.stateNode, g.memoizedProps);
            } catch (_) {
              Gn(e, e.return, _);
            }
          }
        } else if (g.tag === ae) {
          if (c === null)
            try {
              var R = g.stateNode;
              r ? oM(R) : uM(R, g.memoizedProps);
            } catch (_) {
              Gn(e, e.return, _);
            }
        } else if (!((g.tag === Ke || g.tag === Ze) && g.memoizedState !== null && g !== e)) {
          if (g.child !== null) {
            g.child.return = g, g = g.child;
            continue;
          }
        }
        if (g === e)
          return;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === e)
            return;
          c === g && (c = null), g = g.return;
        }
        c === g && (c = null), g.sibling.return = g.return, g = g.sibling;
      }
    }
    function IC(e) {
      var r = e.ref;
      if (r !== null) {
        var c = e.stateNode, g;
        switch (e.tag) {
          case se:
            g = c;
            break;
          default:
            g = c;
        }
        if (typeof r == "function") {
          var x;
          if (e.mode & Ft)
            try {
              Ao(), x = r(g);
            } finally {
              Co(e);
            }
          else
            x = r(g);
          typeof x == "function" && T("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", vt(e));
        } else
          r.hasOwnProperty("current") || T("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", vt(e)), r.current = g;
      }
    }
    function PO(e) {
      var r = e.alternate;
      r !== null && (r.return = null), e.return = null;
    }
    function FC(e) {
      var r = e.alternate;
      r !== null && (e.alternate = null, FC(r));
      {
        if (e.child = null, e.deletions = null, e.sibling = null, e.tag === se) {
          var c = e.stateNode;
          c !== null && jM(c);
        }
        e.stateNode = null, e._debugOwner = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
      }
    }
    function NO(e) {
      for (var r = e.return; r !== null; ) {
        if (YC(r))
          return r;
        r = r.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function YC(e) {
      return e.tag === se || e.tag === q || e.tag === te;
    }
    function HC(e) {
      var r = e;
      e:
        for (; ; ) {
          for (; r.sibling === null; ) {
            if (r.return === null || YC(r.return))
              return null;
            r = r.return;
          }
          for (r.sibling.return = r.return, r = r.sibling; r.tag !== se && r.tag !== ae && r.tag !== Ve; ) {
            if (r.flags & Bn || r.child === null || r.tag === te)
              continue e;
            r.child.return = r, r = r.child;
          }
          if (!(r.flags & Bn))
            return r.stateNode;
        }
    }
    function zO(e) {
      var r = NO(e);
      switch (r.tag) {
        case se: {
          var c = r.stateNode;
          r.flags & An && (jS(c), r.flags &= ~An);
          var g = HC(e);
          ew(e, g, c);
          break;
        }
        case q:
        case te: {
          var x = r.stateNode.containerInfo, R = HC(e);
          J0(e, R, x);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function J0(e, r, c) {
      var g = e.tag, x = g === se || g === ae;
      if (x) {
        var R = e.stateNode;
        r ? nM(c, R, r) : eM(c, R);
      } else if (g !== te) {
        var _ = e.child;
        if (_ !== null) {
          J0(_, r, c);
          for (var H = _.sibling; H !== null; )
            J0(H, r, c), H = H.sibling;
        }
      }
    }
    function ew(e, r, c) {
      var g = e.tag, x = g === se || g === ae;
      if (x) {
        var R = e.stateNode;
        r ? tM(c, R, r) : JL(c, R);
      } else if (g !== te) {
        var _ = e.child;
        if (_ !== null) {
          ew(_, r, c);
          for (var H = _.sibling; H !== null; )
            ew(H, r, c), H = H.sibling;
        }
      }
    }
    var Ei = null, Ys = !1;
    function IO(e, r, c) {
      {
        var g = r;
        e:
          for (; g !== null; ) {
            switch (g.tag) {
              case se: {
                Ei = g.stateNode, Ys = !1;
                break e;
              }
              case q: {
                Ei = g.stateNode.containerInfo, Ys = !0;
                break e;
              }
              case te: {
                Ei = g.stateNode.containerInfo, Ys = !0;
                break e;
              }
            }
            g = g.return;
          }
        if (Ei === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        jC(e, r, c), Ei = null, Ys = !1;
      }
      PO(c);
    }
    function ku(e, r, c) {
      for (var g = c.child; g !== null; )
        jC(e, r, g), g = g.sibling;
    }
    function jC(e, r, c) {
      switch (Ch(c), c.tag) {
        case se:
          Ti || Tf(c, r);
        case ae: {
          {
            var g = Ei, x = Ys;
            Ei = null, ku(e, r, c), Ei = g, Ys = x, Ei !== null && (Ys ? iM(Ei, c.stateNode) : rM(Ei, c.stateNode));
          }
          return;
        }
        case Ve: {
          Ei !== null && (Ys ? aM(Ei, c.stateNode) : db(Ei, c.stateNode));
          return;
        }
        case te: {
          {
            var R = Ei, _ = Ys;
            Ei = c.stateNode.containerInfo, Ys = !0, ku(e, r, c), Ei = R, Ys = _;
          }
          return;
        }
        case Y:
        case we:
        case ve:
        case Me: {
          if (!Ti) {
            var H = c.updateQueue;
            if (H !== null) {
              var W = H.lastEffect;
              if (W !== null) {
                var J = W.next, ne = J;
                do {
                  var ge = ne, he = ge.destroy, Ae = ge.tag;
                  he !== void 0 && ((Ae & wo) !== Ea ? ty(c, r, he) : (Ae & Gr) !== Ea && (gd(c), c.mode & Ft ? (Ao(), ty(c, r, he), Co(c)) : ty(c, r, he), Bl())), ne = ne.next;
                } while (ne !== J);
              }
            }
          }
          ku(e, r, c);
          return;
        }
        case U: {
          if (!Ti) {
            Tf(c, r);
            var Te = c.stateNode;
            typeof Te.componentWillUnmount == "function" && K0(c, r, Te);
          }
          ku(e, r, c);
          return;
        }
        case dt: {
          ku(e, r, c);
          return;
        }
        case Ke: {
          if (
            // TODO: Remove this dead flag
            c.mode & nn
          ) {
            var De = Ti;
            Ti = De || c.memoizedState !== null, ku(e, r, c), Ti = De;
          } else
            ku(e, r, c);
          break;
        }
        default: {
          ku(e, r, c);
          return;
        }
      }
    }
    function FO(e) {
      e.memoizedState;
    }
    function YO(e, r) {
      var c = r.memoizedState;
      if (c === null) {
        var g = r.alternate;
        if (g !== null) {
          var x = g.memoizedState;
          if (x !== null) {
            var R = x.dehydrated;
            R !== null && CM(R);
          }
        }
      }
    }
    function UC(e) {
      var r = e.updateQueue;
      if (r !== null) {
        e.updateQueue = null;
        var c = e.stateNode;
        c === null && (c = e.stateNode = new SO()), r.forEach(function(g) {
          var x = N2.bind(null, e, g);
          if (!c.has(g)) {
            if (c.add(g), Wr)
              if (Cf !== null && Af !== null)
                $p(Af, Cf);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            g.then(x, x);
          }
        });
      }
    }
    function HO(e, r, c) {
      Cf = c, Af = e, wn(r), BC(r, e), wn(r), Cf = null, Af = null;
    }
    function Hs(e, r, c) {
      var g = r.deletions;
      if (g !== null)
        for (var x = 0; x < g.length; x++) {
          var R = g[x];
          try {
            IO(e, r, R);
          } catch (W) {
            Gn(R, r, W);
          }
        }
      var _ = cx();
      if (r.subtreeFlags & Ii)
        for (var H = r.child; H !== null; )
          wn(H), BC(H, e), H = H.sibling;
      wn(_);
    }
    function BC(e, r, c) {
      var g = e.alternate, x = e.flags;
      switch (e.tag) {
        case Y:
        case we:
        case ve:
        case Me: {
          if (Hs(r, e), To(e), x & Jt) {
            try {
              Fs(wo | Vr, e, e.return), Su(wo | Vr, e);
            } catch (Bt) {
              Gn(e, e.return, Bt);
            }
            if (e.mode & Ft) {
              try {
                Ao(), Fs(Gr | Vr, e, e.return);
              } catch (Bt) {
                Gn(e, e.return, Bt);
              }
              Co(e);
            } else
              try {
                Fs(Gr | Vr, e, e.return);
              } catch (Bt) {
                Gn(e, e.return, Bt);
              }
          }
          return;
        }
        case U: {
          Hs(r, e), To(e), x & Pi && g !== null && Tf(g, g.return);
          return;
        }
        case se: {
          Hs(r, e), To(e), x & Pi && g !== null && Tf(g, g.return);
          {
            if (e.flags & An) {
              var R = e.stateNode;
              try {
                jS(R);
              } catch (Bt) {
                Gn(e, e.return, Bt);
              }
            }
            if (x & Jt) {
              var _ = e.stateNode;
              if (_ != null) {
                var H = e.memoizedProps, W = g !== null ? g.memoizedProps : H, J = e.type, ne = e.updateQueue;
                if (e.updateQueue = null, ne !== null)
                  try {
                    QL(_, ne, J, W, H, e);
                  } catch (Bt) {
                    Gn(e, e.return, Bt);
                  }
              }
            }
          }
          return;
        }
        case ae: {
          if (Hs(r, e), To(e), x & Jt) {
            if (e.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var ge = e.stateNode, he = e.memoizedProps, Ae = g !== null ? g.memoizedProps : he;
            try {
              KL(ge, Ae, he);
            } catch (Bt) {
              Gn(e, e.return, Bt);
            }
          }
          return;
        }
        case q: {
          if (Hs(r, e), To(e), x & Jt && g !== null) {
            var Te = g.memoizedState;
            if (Te.isDehydrated)
              try {
                kM(r.containerInfo);
              } catch (Bt) {
                Gn(e, e.return, Bt);
              }
          }
          return;
        }
        case te: {
          Hs(r, e), To(e);
          return;
        }
        case re: {
          Hs(r, e), To(e);
          var De = e.child;
          if (De.flags & no) {
            var ht = De.stateNode, Pt = De.memoizedState, Tt = Pt !== null;
            if (ht.isHidden = Tt, Tt) {
              var hn = De.alternate !== null && De.alternate.memoizedState !== null;
              hn || b2();
            }
          }
          if (x & Jt) {
            try {
              FO(e);
            } catch (Bt) {
              Gn(e, e.return, Bt);
            }
            UC(e);
          }
          return;
        }
        case Ke: {
          var on = g !== null && g.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            e.mode & nn
          ) {
            var xe = Ti;
            Ti = xe || on, Hs(r, e), Ti = xe;
          } else
            Hs(r, e);
          if (To(e), x & no) {
            var Oe = e.stateNode, be = e.memoizedState, Xe = be !== null, pt = e;
            if (Oe.isHidden = Xe, Xe && !on && (pt.mode & nn) !== Nt) {
              wt = pt;
              for (var st = pt.child; st !== null; )
                wt = st, UO(st), st = st.sibling;
            }
            _O(pt, Xe);
          }
          return;
        }
        case it: {
          Hs(r, e), To(e), x & Jt && UC(e);
          return;
        }
        case dt:
          return;
        default: {
          Hs(r, e), To(e);
          return;
        }
      }
    }
    function To(e) {
      var r = e.flags;
      if (r & Bn) {
        try {
          zO(e);
        } catch (c) {
          Gn(e, e.return, c);
        }
        e.flags &= ~Bn;
      }
      r & va && (e.flags &= ~va);
    }
    function jO(e, r, c) {
      Cf = c, Af = r, wt = e, WC(e, r, c), Cf = null, Af = null;
    }
    function WC(e, r, c) {
      for (var g = (e.mode & nn) !== Nt; wt !== null; ) {
        var x = wt, R = x.child;
        if (x.tag === Ke && g) {
          var _ = x.memoizedState !== null, H = _ || ey;
          if (H) {
            tw(e, r, c);
            continue;
          } else {
            var W = x.alternate, J = W !== null && W.memoizedState !== null, ne = J || Ti, ge = ey, he = Ti;
            ey = H, Ti = ne, Ti && !he && (wt = x, BO(x));
            for (var Ae = R; Ae !== null; )
              wt = Ae, WC(
                Ae,
                // New root; bubble back up to here and stop.
                r,
                c
              ), Ae = Ae.sibling;
            wt = x, ey = ge, Ti = he, tw(e, r, c);
            continue;
          }
        }
        (x.subtreeFlags & ui) !== _t && R !== null ? (R.return = x, wt = R) : tw(e, r, c);
      }
    }
    function tw(e, r, c) {
      for (; wt !== null; ) {
        var g = wt;
        if ((g.flags & ui) !== _t) {
          var x = g.alternate;
          wn(g);
          try {
            DO(r, x, g, c);
          } catch (_) {
            Gn(g, g.return, _);
          }
          ln();
        }
        if (g === e) {
          wt = null;
          return;
        }
        var R = g.sibling;
        if (R !== null) {
          R.return = g.return, wt = R;
          return;
        }
        wt = g.return;
      }
    }
    function UO(e) {
      for (; wt !== null; ) {
        var r = wt, c = r.child;
        switch (r.tag) {
          case Y:
          case we:
          case ve:
          case Me: {
            if (r.mode & Ft)
              try {
                Ao(), Fs(Gr, r, r.return);
              } finally {
                Co(r);
              }
            else
              Fs(Gr, r, r.return);
            break;
          }
          case U: {
            Tf(r, r.return);
            var g = r.stateNode;
            typeof g.componentWillUnmount == "function" && K0(r, r.return, g);
            break;
          }
          case se: {
            Tf(r, r.return);
            break;
          }
          case Ke: {
            var x = r.memoizedState !== null;
            if (x) {
              XC(e);
              continue;
            }
            break;
          }
        }
        c !== null ? (c.return = r, wt = c) : XC(e);
      }
    }
    function XC(e) {
      for (; wt !== null; ) {
        var r = wt;
        if (r === e) {
          wt = null;
          return;
        }
        var c = r.sibling;
        if (c !== null) {
          c.return = r.return, wt = c;
          return;
        }
        wt = r.return;
      }
    }
    function BO(e) {
      for (; wt !== null; ) {
        var r = wt, c = r.child;
        if (r.tag === Ke) {
          var g = r.memoizedState !== null;
          if (g) {
            VC(e);
            continue;
          }
        }
        c !== null ? (c.return = r, wt = c) : VC(e);
      }
    }
    function VC(e) {
      for (; wt !== null; ) {
        var r = wt;
        wn(r);
        try {
          OO(r);
        } catch (g) {
          Gn(r, r.return, g);
        }
        if (ln(), r === e) {
          wt = null;
          return;
        }
        var c = r.sibling;
        if (c !== null) {
          c.return = r.return, wt = c;
          return;
        }
        wt = r.return;
      }
    }
    function WO(e, r, c, g) {
      wt = r, XO(r, e, c, g);
    }
    function XO(e, r, c, g) {
      for (; wt !== null; ) {
        var x = wt, R = x.child;
        (x.subtreeFlags & ma) !== _t && R !== null ? (R.return = x, wt = R) : VO(e, r, c, g);
      }
    }
    function VO(e, r, c, g) {
      for (; wt !== null; ) {
        var x = wt;
        if ((x.flags & qn) !== _t) {
          wn(x);
          try {
            GO(r, x, c, g);
          } catch (_) {
            Gn(x, x.return, _);
          }
          ln();
        }
        if (x === e) {
          wt = null;
          return;
        }
        var R = x.sibling;
        if (R !== null) {
          R.return = x.return, wt = R;
          return;
        }
        wt = x.return;
      }
    }
    function GO(e, r, c, g) {
      switch (r.tag) {
        case Y:
        case we:
        case Me: {
          if (r.mode & Ft) {
            O0();
            try {
              Su(Ci | Vr, r);
            } finally {
              D0(r);
            }
          } else
            Su(Ci | Vr, r);
          break;
        }
      }
    }
    function $O(e) {
      wt = e, qO();
    }
    function qO() {
      for (; wt !== null; ) {
        var e = wt, r = e.child;
        if ((wt.flags & Sn) !== _t) {
          var c = e.deletions;
          if (c !== null) {
            for (var g = 0; g < c.length; g++) {
              var x = c[g];
              wt = x, KO(x, e);
            }
            {
              var R = e.alternate;
              if (R !== null) {
                var _ = R.child;
                if (_ !== null) {
                  R.child = null;
                  do {
                    var H = _.sibling;
                    _.sibling = null, _ = H;
                  } while (_ !== null);
                }
              }
            }
            wt = e;
          }
        }
        (e.subtreeFlags & ma) !== _t && r !== null ? (r.return = e, wt = r) : ZO();
      }
    }
    function ZO() {
      for (; wt !== null; ) {
        var e = wt;
        (e.flags & qn) !== _t && (wn(e), QO(e), ln());
        var r = e.sibling;
        if (r !== null) {
          r.return = e.return, wt = r;
          return;
        }
        wt = e.return;
      }
    }
    function QO(e) {
      switch (e.tag) {
        case Y:
        case we:
        case Me: {
          e.mode & Ft ? (O0(), Fs(Ci | Vr, e, e.return), D0(e)) : Fs(Ci | Vr, e, e.return);
          break;
        }
      }
    }
    function KO(e, r) {
      for (; wt !== null; ) {
        var c = wt;
        wn(c), e2(c, r), ln();
        var g = c.child;
        g !== null ? (g.return = c, wt = g) : JO(e);
      }
    }
    function JO(e) {
      for (; wt !== null; ) {
        var r = wt, c = r.sibling, g = r.return;
        if (FC(r), r === e) {
          wt = null;
          return;
        }
        if (c !== null) {
          c.return = g, wt = c;
          return;
        }
        wt = g;
      }
    }
    function e2(e, r) {
      switch (e.tag) {
        case Y:
        case we:
        case Me: {
          e.mode & Ft ? (O0(), Fs(Ci, e, r), D0(e)) : Fs(Ci, e, r);
          break;
        }
      }
    }
    function t2(e) {
      switch (e.tag) {
        case Y:
        case we:
        case Me: {
          try {
            Su(Gr | Vr, e);
          } catch (c) {
            Gn(e, e.return, c);
          }
          break;
        }
        case U: {
          var r = e.stateNode;
          try {
            r.componentDidMount();
          } catch (c) {
            Gn(e, e.return, c);
          }
          break;
        }
      }
    }
    function n2(e) {
      switch (e.tag) {
        case Y:
        case we:
        case Me: {
          try {
            Su(Ci | Vr, e);
          } catch (r) {
            Gn(e, e.return, r);
          }
          break;
        }
      }
    }
    function r2(e) {
      switch (e.tag) {
        case Y:
        case we:
        case Me: {
          try {
            Fs(Gr | Vr, e, e.return);
          } catch (c) {
            Gn(e, e.return, c);
          }
          break;
        }
        case U: {
          var r = e.stateNode;
          typeof r.componentWillUnmount == "function" && K0(e, e.return, r);
          break;
        }
      }
    }
    function i2(e) {
      switch (e.tag) {
        case Y:
        case we:
        case Me:
          try {
            Fs(Ci | Vr, e, e.return);
          } catch (r) {
            Gn(e, e.return, r);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var Ip = Symbol.for;
      Ip("selector.component"), Ip("selector.has_pseudo_class"), Ip("selector.role"), Ip("selector.test_id"), Ip("selector.text");
    }
    var a2 = [];
    function s2() {
      a2.forEach(function(e) {
        return e();
      });
    }
    var o2 = h.ReactCurrentActQueue;
    function l2(e) {
      {
        var r = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), c = typeof jest < "u";
        return c && r !== !1;
      }
    }
    function GC() {
      {
        var e = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !e && o2.current !== null && T("The current testing environment is not configured to support act(...)"), e;
      }
    }
    var u2 = Math.ceil, nw = h.ReactCurrentDispatcher, rw = h.ReactCurrentOwner, Ri = h.ReactCurrentBatchConfig, js = h.ReactCurrentActQueue, Zr = (
      /*             */
      0
    ), $C = (
      /*               */
      1
    ), Li = (
      /*                */
      2
    ), as = (
      /*                */
      4
    ), vl = 0, Fp = 1, Oc = 2, ny = 3, Yp = 4, qC = 5, iw = 6, fn = Zr, oa = null, pr = null, Qr = Pe, Eo = Pe, aw = hu(Pe), Kr = vl, Hp = null, ry = Pe, jp = Pe, iy = Pe, Up = null, Ra = null, sw = 0, ZC = 500, QC = 1 / 0, c2 = 500, ml = null;
    function Bp() {
      QC = Qn() + c2;
    }
    function KC() {
      return QC;
    }
    var ay = !1, ow = null, Ef = null, _c = !1, Cu = null, Wp = Pe, lw = [], uw = null, d2 = 50, Xp = 0, cw = null, dw = !1, sy = !1, f2 = 50, Rf = 0, oy = null, Vp = Fn, ly = Pe, JC = !1;
    function uy() {
      return oa;
    }
    function la() {
      return (fn & (Li | as)) !== Zr ? Qn() : (Vp !== Fn || (Vp = Qn()), Vp);
    }
    function Au(e) {
      var r = e.mode;
      if ((r & nn) === Nt)
        return Yt;
      if ((fn & Li) !== Zr && Qr !== Pe)
        return Ar(Qr);
      var c = lD() !== oD;
      if (c) {
        if (Ri.transition !== null) {
          var g = Ri.transition;
          g._updatedFibers || (g._updatedFibers = /* @__PURE__ */ new Set()), g._updatedFibers.add(e);
        }
        return ly === dn && (ly = Oh()), ly;
      }
      var x = wa();
      if (x !== dn)
        return x;
      var R = VL();
      return R;
    }
    function h2(e) {
      var r = e.mode;
      return (r & nn) === Nt ? Yt : Ox();
    }
    function Jr(e, r, c, g) {
      I2(), JC && T("useInsertionEffect must not schedule updates."), dw && (sy = !0), Jo(e, c, g), (fn & Li) !== Pe && e === oa ? H2(r) : (Wr && Ih(e, r, c), j2(r), e === oa && ((fn & Li) === Zr && (jp = en(jp, c)), Kr === Yp && Tu(e, Qr)), La(e, g), c === Yt && fn === Zr && (r.mode & nn) === Nt && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !js.isBatchingLegacy && (Bp(), KS()));
    }
    function p2(e, r, c) {
      var g = e.current;
      g.lanes = r, Jo(e, r, c), La(e, c);
    }
    function g2(e) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (fn & Li) !== Zr
      );
    }
    function La(e, r) {
      var c = e.callbackNode;
      Lx(e, r);
      var g = ic(e, e === oa ? Qr : Pe);
      if (g === Pe) {
        c !== null && gA(c), e.callbackNode = null, e.callbackPriority = dn;
        return;
      }
      var x = br(g), R = e.callbackPriority;
      if (R === x && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(js.current !== null && c !== yw)) {
        c == null && R !== Yt && T("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      c != null && gA(c);
      var _;
      if (x === Yt)
        e.tag === pu ? (js.isBatchingLegacy !== null && (js.didScheduleLegacyUpdate = !0), WM(nA.bind(null, e))) : QS(nA.bind(null, e)), js.current !== null ? js.current.push(gu) : $L(function() {
          (fn & (Li | as)) === Zr && gu();
        }), _ = null;
      else {
        var H;
        switch (uc(g)) {
          case ci:
            H = dd;
            break;
          case Xr:
            H = ra;
            break;
          case Ts:
            H = qa;
            break;
          case oc:
            H = io;
            break;
          default:
            H = qa;
            break;
        }
        _ = xw(H, eA.bind(null, e));
      }
      e.callbackPriority = x, e.callbackNode = _;
    }
    function eA(e, r) {
      if (ID(), Vp = Fn, ly = Pe, (fn & (Li | as)) !== Zr)
        throw new Error("Should not already be working.");
      var c = e.callbackNode, g = xl();
      if (g && e.callbackNode !== c)
        return null;
      var x = ic(e, e === oa ? Qr : Pe);
      if (x === Pe)
        return null;
      var R = !sc(e, x) && !wv(e, x) && !r, _ = R ? A2(e, x) : dy(e, x);
      if (_ !== vl) {
        if (_ === Oc) {
          var H = Mh(e);
          H !== Pe && (x = H, _ = fw(e, H));
        }
        if (_ === Fp) {
          var W = Hp;
          throw Pc(e, Pe), Tu(e, x), La(e, Qn()), W;
        }
        if (_ === iw)
          Tu(e, x);
        else {
          var J = !sc(e, x), ne = e.current.alternate;
          if (J && !m2(ne)) {
            if (_ = dy(e, x), _ === Oc) {
              var ge = Mh(e);
              ge !== Pe && (x = ge, _ = fw(e, ge));
            }
            if (_ === Fp) {
              var he = Hp;
              throw Pc(e, Pe), Tu(e, x), La(e, Qn()), he;
            }
          }
          e.finishedWork = ne, e.finishedLanes = x, v2(e, _, x);
        }
      }
      return La(e, Qn()), e.callbackNode === c ? eA.bind(null, e) : null;
    }
    function fw(e, r) {
      var c = Up;
      if (Er(e)) {
        var g = Pc(e, r);
        g.flags |= or, IM(e.containerInfo);
      }
      var x = dy(e, r);
      if (x !== Oc) {
        var R = Ra;
        Ra = c, R !== null && tA(R);
      }
      return x;
    }
    function tA(e) {
      Ra === null ? Ra = e : Ra.push.apply(Ra, e);
    }
    function v2(e, r, c) {
      switch (r) {
        case vl:
        case Fp:
          throw new Error("Root did not complete. This is a bug in React.");
        case Oc: {
          Nc(e, Ra, ml);
          break;
        }
        case ny: {
          if (Tu(e, c), Nd(c) && // do not delay if we're inside an act() scope
          !vA()) {
            var g = sw + ZC - Qn();
            if (g > 10) {
              var x = ic(e, Pe);
              if (x !== Pe)
                break;
              var R = e.suspendedLanes;
              if (!Ko(R, c)) {
                la(), Nh(e, R);
                break;
              }
              e.timeoutHandle = ub(Nc.bind(null, e, Ra, ml), g);
              break;
            }
          }
          Nc(e, Ra, ml);
          break;
        }
        case Yp: {
          if (Tu(e, c), bv(c))
            break;
          if (!vA()) {
            var _ = xv(e, c), H = _, W = Qn() - H, J = z2(W) - W;
            if (J > 10) {
              e.timeoutHandle = ub(Nc.bind(null, e, Ra, ml), J);
              break;
            }
          }
          Nc(e, Ra, ml);
          break;
        }
        case qC: {
          Nc(e, Ra, ml);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function m2(e) {
      for (var r = e; ; ) {
        if (r.flags & Qu) {
          var c = r.updateQueue;
          if (c !== null) {
            var g = c.stores;
            if (g !== null)
              for (var x = 0; x < g.length; x++) {
                var R = g[x], _ = R.getSnapshot, H = R.value;
                try {
                  if (!bt(_(), H))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var W = r.child;
        if (r.subtreeFlags & Qu && W !== null) {
          W.return = r, r = W;
          continue;
        }
        if (r === e)
          return !0;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === e)
            return !0;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
      return !0;
    }
    function Tu(e, r) {
      r = Zl(r, iy), r = Zl(r, jp), Ph(e, r);
    }
    function nA(e) {
      if (FD(), (fn & (Li | as)) !== Zr)
        throw new Error("Should not already be working.");
      xl();
      var r = ic(e, Pe);
      if (!ji(r, Yt))
        return La(e, Qn()), null;
      var c = dy(e, r);
      if (e.tag !== pu && c === Oc) {
        var g = Mh(e);
        g !== Pe && (r = g, c = fw(e, g));
      }
      if (c === Fp) {
        var x = Hp;
        throw Pc(e, Pe), Tu(e, r), La(e, Qn()), x;
      }
      if (c === iw)
        throw new Error("Root did not complete. This is a bug in React.");
      var R = e.current.alternate;
      return e.finishedWork = R, e.finishedLanes = r, Nc(e, Ra, ml), La(e, Qn()), null;
    }
    function y2(e, r) {
      r !== Pe && (Ql(e, en(r, Yt)), La(e, Qn()), (fn & (Li | as)) === Zr && (Bp(), gu()));
    }
    function hw(e, r) {
      var c = fn;
      fn |= $C;
      try {
        return e(r);
      } finally {
        fn = c, fn === Zr && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !js.isBatchingLegacy && (Bp(), KS());
      }
    }
    function x2(e, r, c, g, x) {
      var R = wa(), _ = Ri.transition;
      try {
        return Ri.transition = null, Tr(ci), e(r, c, g, x);
      } finally {
        Tr(R), Ri.transition = _, fn === Zr && Bp();
      }
    }
    function yl(e) {
      Cu !== null && Cu.tag === pu && (fn & (Li | as)) === Zr && xl();
      var r = fn;
      fn |= $C;
      var c = Ri.transition, g = wa();
      try {
        return Ri.transition = null, Tr(ci), e ? e() : void 0;
      } finally {
        Tr(g), Ri.transition = c, fn = r, (fn & (Li | as)) === Zr && gu();
      }
    }
    function rA() {
      return (fn & (Li | as)) !== Zr;
    }
    function cy(e, r) {
      Bi(aw, Eo, e), Eo = en(Eo, r);
    }
    function pw(e) {
      Eo = aw.current, Ui(aw, e);
    }
    function Pc(e, r) {
      e.finishedWork = null, e.finishedLanes = Pe;
      var c = e.timeoutHandle;
      if (c !== cb && (e.timeoutHandle = cb, GL(c)), pr !== null)
        for (var g = pr.return; g !== null; ) {
          var x = g.alternate;
          OC(x, g), g = g.return;
        }
      oa = e;
      var R = zc(e.current, null);
      return pr = R, Qr = Eo = r, Kr = vl, Hp = null, ry = Pe, jp = Pe, iy = Pe, Up = null, Ra = null, fD(), _s.discardPendingWarnings(), R;
    }
    function iA(e, r) {
      do {
        var c = pr;
        try {
          if (ym(), Pk(), ln(), rw.current = null, c === null || c.return === null) {
            Kr = Fp, Hp = r, pr = null;
            return;
          }
          if (ot && c.mode & Ft && Zm(c, !0), Ht)
            if (Bo(), r !== null && typeof r == "object" && typeof r.then == "function") {
              var g = r;
              vv(c, g, Qr);
            } else
              vd(c, r, Qr);
          BD(e, c.return, c, r, Qr), lA(c);
        } catch (x) {
          r = x, pr === c && c !== null ? (c = c.return, pr = c) : c = pr;
          continue;
        }
        return;
      } while (!0);
    }
    function aA() {
      var e = nw.current;
      return nw.current = Xm, e === null ? Xm : e;
    }
    function sA(e) {
      nw.current = e;
    }
    function b2() {
      sw = Qn();
    }
    function Gp(e) {
      ry = en(e, ry);
    }
    function w2() {
      Kr === vl && (Kr = ny);
    }
    function gw() {
      (Kr === vl || Kr === ny || Kr === Oc) && (Kr = Yp), oa !== null && (ac(ry) || ac(jp)) && Tu(oa, Qr);
    }
    function S2(e) {
      Kr !== Yp && (Kr = Oc), Up === null ? Up = [e] : Up.push(e);
    }
    function k2() {
      return Kr === vl;
    }
    function dy(e, r) {
      var c = fn;
      fn |= Li;
      var g = aA();
      if (oa !== e || Qr !== r) {
        if (Wr) {
          var x = e.memoizedUpdaters;
          x.size > 0 && ($p(e, Qr), x.clear()), Fd(e, r);
        }
        ml = Fh(), Pc(e, r);
      }
      Ha(r);
      do
        try {
          C2();
          break;
        } catch (R) {
          iA(e, R);
        }
      while (!0);
      if (ym(), fn = c, sA(g), pr !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Xl(), oa = null, Qr = Pe, Kr;
    }
    function C2() {
      for (; pr !== null; )
        oA(pr);
    }
    function A2(e, r) {
      var c = fn;
      fn |= Li;
      var g = aA();
      if (oa !== e || Qr !== r) {
        if (Wr) {
          var x = e.memoizedUpdaters;
          x.size > 0 && ($p(e, Qr), x.clear()), Fd(e, r);
        }
        ml = Fh(), Bp(), Pc(e, r);
      }
      Ha(r);
      do
        try {
          T2();
          break;
        } catch (R) {
          iA(e, R);
        }
      while (!0);
      return ym(), sA(g), fn = c, pr !== null ? (ec(), vl) : (Xl(), oa = null, Qr = Pe, Kr);
    }
    function T2() {
      for (; pr !== null && !cd(); )
        oA(pr);
    }
    function oA(e) {
      var r = e.alternate;
      wn(e);
      var c;
      (e.mode & Ft) !== Nt ? (M0(e), c = vw(r, e, Eo), Zm(e, !0)) : c = vw(r, e, Eo), ln(), e.memoizedProps = e.pendingProps, c === null ? lA(e) : pr = c, rw.current = null;
    }
    function lA(e) {
      var r = e;
      do {
        var c = r.alternate, g = r.return;
        if ((r.flags & ea) === _t) {
          wn(r);
          var x = void 0;
          if ((r.mode & Ft) === Nt ? x = DC(c, r, Eo) : (M0(r), x = DC(c, r, Eo), Zm(r, !1)), ln(), x !== null) {
            pr = x;
            return;
          }
        } else {
          var R = wO(c, r);
          if (R !== null) {
            R.flags &= ov, pr = R;
            return;
          }
          if ((r.mode & Ft) !== Nt) {
            Zm(r, !1);
            for (var _ = r.actualDuration, H = r.child; H !== null; )
              _ += H.actualDuration, H = H.sibling;
            r.actualDuration = _;
          }
          if (g !== null)
            g.flags |= ea, g.subtreeFlags = _t, g.deletions = null;
          else {
            Kr = iw, pr = null;
            return;
          }
        }
        var W = r.sibling;
        if (W !== null) {
          pr = W;
          return;
        }
        r = g, pr = r;
      } while (r !== null);
      Kr === vl && (Kr = qC);
    }
    function Nc(e, r, c) {
      var g = wa(), x = Ri.transition;
      try {
        Ri.transition = null, Tr(ci), E2(e, r, c, g);
      } finally {
        Ri.transition = x, Tr(g);
      }
      return null;
    }
    function E2(e, r, c, g) {
      do
        xl();
      while (Cu !== null);
      if (F2(), (fn & (Li | as)) !== Zr)
        throw new Error("Should not already be working.");
      var x = e.finishedWork, R = e.finishedLanes;
      if (hd(R), x === null)
        return Ah(), null;
      if (R === Pe && T("root.finishedLanes should not be empty during a commit. This is a bug in React."), e.finishedWork = null, e.finishedLanes = Pe, x === e.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      e.callbackNode = null, e.callbackPriority = dn;
      var _ = en(x.lanes, x.childLanes);
      zh(e, _), e === oa && (oa = null, pr = null, Qr = Pe), ((x.subtreeFlags & ma) !== _t || (x.flags & ma) !== _t) && (_c || (_c = !0, uw = c, xw(qa, function() {
        return xl(), null;
      })));
      var H = (x.subtreeFlags & (Ul | Ii | ui | ma)) !== _t, W = (x.flags & (Ul | Ii | ui | ma)) !== _t;
      if (H || W) {
        var J = Ri.transition;
        Ri.transition = null;
        var ne = wa();
        Tr(ci);
        var ge = fn;
        fn |= as, rw.current = null, TO(e, x), aC(), HO(e, x, R), HL(e.containerInfo), e.current = x, mv(R), jO(x, e, R), Wl(), cv(), fn = ge, Tr(ne), Ri.transition = J;
      } else
        e.current = x, aC();
      var he = _c;
      if (_c ? (_c = !1, Cu = e, Wp = R) : (Rf = 0, oy = null), _ = e.pendingLanes, _ === Pe && (Ef = null), he || fA(e.current, !1), ks(x.stateNode, g), Wr && e.memoizedUpdaters.clear(), s2(), La(e, Qn()), r !== null)
        for (var Ae = e.onRecoverableError, Te = 0; Te < r.length; Te++) {
          var De = r[Te], ht = De.stack, Pt = De.digest;
          Ae(De.value, {
            componentStack: ht,
            digest: Pt
          });
        }
      if (ay) {
        ay = !1;
        var Tt = ow;
        throw ow = null, Tt;
      }
      return ji(Wp, Yt) && e.tag !== pu && xl(), _ = e.pendingLanes, ji(_, Yt) ? (zD(), e === cw ? Xp++ : (Xp = 0, cw = e)) : Xp = 0, gu(), Ah(), null;
    }
    function xl() {
      if (Cu !== null) {
        var e = uc(Wp), r = Px(Ts, e), c = Ri.transition, g = wa();
        try {
          return Ri.transition = null, Tr(r), L2();
        } finally {
          Tr(g), Ri.transition = c;
        }
      }
      return !1;
    }
    function R2(e) {
      lw.push(e), _c || (_c = !0, xw(qa, function() {
        return xl(), null;
      }));
    }
    function L2() {
      if (Cu === null)
        return !1;
      var e = uw;
      uw = null;
      var r = Cu, c = Wp;
      if (Cu = null, Wp = Pe, (fn & (Li | as)) !== Zr)
        throw new Error("Cannot flush passive effects while already rendering.");
      dw = !0, sy = !1, yv(c);
      var g = fn;
      fn |= as, $O(r.current), WO(r, r.current, c, e);
      {
        var x = lw;
        lw = [];
        for (var R = 0; R < x.length; R++) {
          var _ = x[R];
          MO(r, _);
        }
      }
      Ju(), fA(r.current, !0), fn = g, gu(), sy ? r === oy ? Rf++ : (Rf = 0, oy = r) : Rf = 0, dw = !1, sy = !1, so(r);
      {
        var H = r.current.stateNode;
        H.effectDuration = 0, H.passiveEffectDuration = 0;
      }
      return !0;
    }
    function uA(e) {
      return Ef !== null && Ef.has(e);
    }
    function M2(e) {
      Ef === null ? Ef = /* @__PURE__ */ new Set([e]) : Ef.add(e);
    }
    function D2(e) {
      ay || (ay = !0, ow = e);
    }
    var O2 = D2;
    function cA(e, r, c) {
      var g = Mc(c, r), x = oC(e, g, Yt), R = mu(e, x, Yt), _ = la();
      R !== null && (Jo(R, Yt, _), La(R, _));
    }
    function Gn(e, r, c) {
      if (kO(c), qp(!1), e.tag === q) {
        cA(e, e, c);
        return;
      }
      var g = null;
      for (g = r; g !== null; ) {
        if (g.tag === q) {
          cA(g, e, c);
          return;
        } else if (g.tag === U) {
          var x = g.type, R = g.stateNode;
          if (typeof x.getDerivedStateFromError == "function" || typeof R.componentDidCatch == "function" && !uA(R)) {
            var _ = Mc(c, e), H = z0(g, _, Yt), W = mu(g, H, Yt), J = la();
            W !== null && (Jo(W, Yt, J), La(W, J));
            return;
          }
        }
        g = g.return;
      }
      T(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, c);
    }
    function _2(e, r, c) {
      var g = e.pingCache;
      g !== null && g.delete(r);
      var x = la();
      Nh(e, c), U2(e), oa === e && Ko(Qr, c) && (Kr === Yp || Kr === ny && Nd(Qr) && Qn() - sw < ZC ? Pc(e, Pe) : iy = en(iy, c)), La(e, x);
    }
    function dA(e, r) {
      r === dn && (r = h2(e));
      var c = la(), g = Ta(e, r);
      g !== null && (Jo(g, r, c), La(g, c));
    }
    function P2(e) {
      var r = e.memoizedState, c = dn;
      r !== null && (c = r.retryLane), dA(e, c);
    }
    function N2(e, r) {
      var c = dn, g;
      switch (e.tag) {
        case re:
          g = e.stateNode;
          var x = e.memoizedState;
          x !== null && (c = x.retryLane);
          break;
        case it:
          g = e.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      g !== null && g.delete(r), dA(e, c);
    }
    function z2(e) {
      return e < 120 ? 120 : e < 480 ? 480 : e < 1080 ? 1080 : e < 1920 ? 1920 : e < 3e3 ? 3e3 : e < 4320 ? 4320 : u2(e / 1960) * 1960;
    }
    function I2() {
      if (Xp > d2)
        throw Xp = 0, cw = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Rf > f2 && (Rf = 0, oy = null, T("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function F2() {
      _s.flushLegacyContextWarning(), _s.flushPendingUnsafeLifecycleWarnings();
    }
    function fA(e, r) {
      wn(e), fy(e, zi, r2), r && fy(e, Uo, i2), fy(e, zi, t2), r && fy(e, Uo, n2), ln();
    }
    function fy(e, r, c) {
      for (var g = e, x = null; g !== null; ) {
        var R = g.subtreeFlags & r;
        g !== x && g.child !== null && R !== _t ? g = g.child : ((g.flags & r) !== _t && c(g), g.sibling !== null ? g = g.sibling : g = x = g.return);
      }
    }
    var hy = null;
    function hA(e) {
      {
        if ((fn & Li) !== Zr || !(e.mode & nn))
          return;
        var r = e.tag;
        if (r !== G && r !== q && r !== U && r !== Y && r !== we && r !== ve && r !== Me)
          return;
        var c = vt(e) || "ReactComponent";
        if (hy !== null) {
          if (hy.has(c))
            return;
          hy.add(c);
        } else
          hy = /* @__PURE__ */ new Set([c]);
        var g = Dn;
        try {
          wn(e), T("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          g ? wn(e) : ln();
        }
      }
    }
    var vw;
    {
      var Y2 = null;
      vw = function(e, r, c) {
        var g = wA(Y2, r);
        try {
          return TC(e, r, c);
        } catch (R) {
          if (KM() || R !== null && typeof R == "object" && typeof R.then == "function")
            throw R;
          if (ym(), Pk(), OC(e, r), wA(r, g), r.mode & Ft && M0(r), jo(null, TC, null, e, r, c), Ex()) {
            var x = ph();
            typeof x == "object" && x !== null && x._suppressLogging && typeof R == "object" && R !== null && !R._suppressLogging && (R._suppressLogging = !0);
          }
          throw R;
        }
      };
    }
    var pA = !1, mw;
    mw = /* @__PURE__ */ new Set();
    function H2(e) {
      if (si && !_D())
        switch (e.tag) {
          case Y:
          case we:
          case Me: {
            var r = pr && vt(pr) || "Unknown", c = r;
            if (!mw.has(c)) {
              mw.add(c);
              var g = vt(e) || "Unknown";
              T("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", g, r, r);
            }
            break;
          }
          case U: {
            pA || (T("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), pA = !0);
            break;
          }
        }
    }
    function $p(e, r) {
      if (Wr) {
        var c = e.memoizedUpdaters;
        c.forEach(function(g) {
          Ih(e, g, r);
        });
      }
    }
    var yw = {};
    function xw(e, r) {
      {
        var c = js.current;
        return c !== null ? (c.push(r), yw) : ud(e, r);
      }
    }
    function gA(e) {
      if (e !== yw)
        return uv(e);
    }
    function vA() {
      return js.current !== null;
    }
    function j2(e) {
      {
        if (e.mode & nn) {
          if (!GC())
            return;
        } else if (!l2() || fn !== Zr || e.tag !== Y && e.tag !== we && e.tag !== Me)
          return;
        if (js.current === null) {
          var r = Dn;
          try {
            wn(e), T(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, vt(e));
          } finally {
            r ? wn(e) : ln();
          }
        }
      }
    }
    function U2(e) {
      e.tag !== pu && GC() && js.current === null && T(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function qp(e) {
      JC = e;
    }
    var ss = null, Lf = null, B2 = function(e) {
      ss = e;
    };
    function Mf(e) {
      {
        if (ss === null)
          return e;
        var r = ss(e);
        return r === void 0 ? e : r.current;
      }
    }
    function bw(e) {
      return Mf(e);
    }
    function ww(e) {
      {
        if (ss === null)
          return e;
        var r = ss(e);
        if (r === void 0) {
          if (e != null && typeof e.render == "function") {
            var c = Mf(e.render);
            if (e.render !== c) {
              var g = {
                $$typeof: Dt,
                render: c
              };
              return e.displayName !== void 0 && (g.displayName = e.displayName), g;
            }
          }
          return e;
        }
        return r.current;
      }
    }
    function mA(e, r) {
      {
        if (ss === null)
          return !1;
        var c = e.elementType, g = r.type, x = !1, R = typeof g == "object" && g !== null ? g.$$typeof : null;
        switch (e.tag) {
          case U: {
            typeof g == "function" && (x = !0);
            break;
          }
          case Y: {
            (typeof g == "function" || R === Ot) && (x = !0);
            break;
          }
          case we: {
            (R === Dt || R === Ot) && (x = !0);
            break;
          }
          case ve:
          case Me: {
            (R === Zt || R === Ot) && (x = !0);
            break;
          }
          default:
            return !1;
        }
        if (x) {
          var _ = ss(c);
          if (_ !== void 0 && _ === ss(g))
            return !0;
        }
        return !1;
      }
    }
    function yA(e) {
      {
        if (ss === null || typeof WeakSet != "function")
          return;
        Lf === null && (Lf = /* @__PURE__ */ new WeakSet()), Lf.add(e);
      }
    }
    var W2 = function(e, r) {
      {
        if (ss === null)
          return;
        var c = r.staleFamilies, g = r.updatedFamilies;
        xl(), yl(function() {
          Sw(e.current, g, c);
        });
      }
    }, X2 = function(e, r) {
      {
        if (e.context !== Ua)
          return;
        xl(), yl(function() {
          Zp(r, e, null, null);
        });
      }
    };
    function Sw(e, r, c) {
      {
        var g = e.alternate, x = e.child, R = e.sibling, _ = e.tag, H = e.type, W = null;
        switch (_) {
          case Y:
          case Me:
          case U:
            W = H;
            break;
          case we:
            W = H.render;
            break;
        }
        if (ss === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var J = !1, ne = !1;
        if (W !== null) {
          var ge = ss(W);
          ge !== void 0 && (c.has(ge) ? ne = !0 : r.has(ge) && (_ === U ? ne = !0 : J = !0));
        }
        if (Lf !== null && (Lf.has(e) || g !== null && Lf.has(g)) && (ne = !0), ne && (e._debugNeedsRemount = !0), ne || J) {
          var he = Ta(e, Yt);
          he !== null && Jr(he, e, Yt, Fn);
        }
        x !== null && !ne && Sw(x, r, c), R !== null && Sw(R, r, c);
      }
    }
    var V2 = function(e, r) {
      {
        var c = /* @__PURE__ */ new Set(), g = new Set(r.map(function(x) {
          return x.current;
        }));
        return kw(e.current, g, c), c;
      }
    };
    function kw(e, r, c) {
      {
        var g = e.child, x = e.sibling, R = e.tag, _ = e.type, H = null;
        switch (R) {
          case Y:
          case Me:
          case U:
            H = _;
            break;
          case we:
            H = _.render;
            break;
        }
        var W = !1;
        H !== null && r.has(H) && (W = !0), W ? G2(e, c) : g !== null && kw(g, r, c), x !== null && kw(x, r, c);
      }
    }
    function G2(e, r) {
      {
        var c = $2(e, r);
        if (c)
          return;
        for (var g = e; ; ) {
          switch (g.tag) {
            case se:
              r.add(g.stateNode);
              return;
            case te:
              r.add(g.stateNode.containerInfo);
              return;
            case q:
              r.add(g.stateNode.containerInfo);
              return;
          }
          if (g.return === null)
            throw new Error("Expected to reach root first.");
          g = g.return;
        }
      }
    }
    function $2(e, r) {
      for (var c = e, g = !1; ; ) {
        if (c.tag === se)
          g = !0, r.add(c.stateNode);
        else if (c.child !== null) {
          c.child.return = c, c = c.child;
          continue;
        }
        if (c === e)
          return g;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === e)
            return g;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
      return !1;
    }
    var Cw;
    {
      Cw = !1;
      try {
        var xA = Object.preventExtensions({});
      } catch {
        Cw = !0;
      }
    }
    function q2(e, r, c, g) {
      this.tag = e, this.key = c, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = r, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = g, this.flags = _t, this.subtreeFlags = _t, this.deletions = null, this.lanes = Pe, this.childLanes = Pe, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !Cw && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Ba = function(e, r, c, g) {
      return new q2(e, r, c, g);
    };
    function Aw(e) {
      var r = e.prototype;
      return !!(r && r.isReactComponent);
    }
    function Z2(e) {
      return typeof e == "function" && !Aw(e) && e.defaultProps === void 0;
    }
    function Q2(e) {
      if (typeof e == "function")
        return Aw(e) ? U : Y;
      if (e != null) {
        var r = e.$$typeof;
        if (r === Dt)
          return we;
        if (r === Zt)
          return ve;
      }
      return G;
    }
    function zc(e, r) {
      var c = e.alternate;
      c === null ? (c = Ba(e.tag, r, e.key, e.mode), c.elementType = e.elementType, c.type = e.type, c.stateNode = e.stateNode, c._debugSource = e._debugSource, c._debugOwner = e._debugOwner, c._debugHookTypes = e._debugHookTypes, c.alternate = e, e.alternate = c) : (c.pendingProps = r, c.type = e.type, c.flags = _t, c.subtreeFlags = _t, c.deletions = null, c.actualDuration = 0, c.actualStartTime = -1), c.flags = e.flags & Br, c.childLanes = e.childLanes, c.lanes = e.lanes, c.child = e.child, c.memoizedProps = e.memoizedProps, c.memoizedState = e.memoizedState, c.updateQueue = e.updateQueue;
      var g = e.dependencies;
      switch (c.dependencies = g === null ? null : {
        lanes: g.lanes,
        firstContext: g.firstContext
      }, c.sibling = e.sibling, c.index = e.index, c.ref = e.ref, c.selfBaseDuration = e.selfBaseDuration, c.treeBaseDuration = e.treeBaseDuration, c._debugNeedsRemount = e._debugNeedsRemount, c.tag) {
        case G:
        case Y:
        case Me:
          c.type = Mf(e.type);
          break;
        case U:
          c.type = bw(e.type);
          break;
        case we:
          c.type = ww(e.type);
          break;
      }
      return c;
    }
    function K2(e, r) {
      e.flags &= Br | Bn;
      var c = e.alternate;
      if (c === null)
        e.childLanes = Pe, e.lanes = r, e.child = null, e.subtreeFlags = _t, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null, e.selfBaseDuration = 0, e.treeBaseDuration = 0;
      else {
        e.childLanes = c.childLanes, e.lanes = c.lanes, e.child = c.child, e.subtreeFlags = _t, e.deletions = null, e.memoizedProps = c.memoizedProps, e.memoizedState = c.memoizedState, e.updateQueue = c.updateQueue, e.type = c.type;
        var g = c.dependencies;
        e.dependencies = g === null ? null : {
          lanes: g.lanes,
          firstContext: g.firstContext
        }, e.selfBaseDuration = c.selfBaseDuration, e.treeBaseDuration = c.treeBaseDuration;
      }
      return e;
    }
    function J2(e, r, c) {
      var g;
      return e === cm ? (g = nn, r === !0 && (g |= Kn, g |= xa)) : g = Nt, Wr && (g |= Ft), Ba(q, null, null, g);
    }
    function Tw(e, r, c, g, x, R) {
      var _ = G, H = e;
      if (typeof e == "function")
        Aw(e) ? (_ = U, H = bw(H)) : H = Mf(H);
      else if (typeof e == "string")
        _ = se;
      else
        e:
          switch (e) {
            case bi:
              return Eu(c.children, x, R, r);
            case ai:
              _ = Ce, x |= Kn, (x & nn) !== Nt && (x |= xa);
              break;
            case le:
              return e_(c, x, R, r);
            case qt:
              return t_(c, x, R, r);
            case cn:
              return n_(c, x, R, r);
            case B:
              return bA(c, x, R, r);
            case t:
            case sr:
            case n:
            case i:
            case Yn:
            default: {
              if (typeof e == "object" && e !== null)
                switch (e.$$typeof) {
                  case Ye:
                    _ = K;
                    break e;
                  case tt:
                    _ = Ne;
                    break e;
                  case Dt:
                    _ = we, H = ww(H);
                    break e;
                  case Zt:
                    _ = ve;
                    break e;
                  case Ot:
                    _ = et, H = null;
                    break e;
                }
              var W = "";
              {
                (e === void 0 || typeof e == "object" && e !== null && Object.keys(e).length === 0) && (W += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var J = g ? vt(g) : null;
                J && (W += `

Check the render method of \`` + J + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (e == null ? e : typeof e) + "." + W));
            }
          }
      var ne = Ba(_, c, r, x);
      return ne.elementType = e, ne.type = H, ne.lanes = R, ne._debugOwner = g, ne;
    }
    function Ew(e, r, c) {
      var g = null;
      g = e._owner;
      var x = e.type, R = e.key, _ = e.props, H = Tw(x, R, _, g, r, c);
      return H._debugSource = e._source, H._debugOwner = e._owner, H;
    }
    function Eu(e, r, c, g) {
      var x = Ba(ue, e, g, r);
      return x.lanes = c, x;
    }
    function e_(e, r, c, g) {
      typeof e.id != "string" && T('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof e.id);
      var x = Ba(Re, e, g, r | Ft);
      return x.elementType = le, x.lanes = c, x.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, x;
    }
    function t_(e, r, c, g) {
      var x = Ba(re, e, g, r);
      return x.elementType = qt, x.lanes = c, x;
    }
    function n_(e, r, c, g) {
      var x = Ba(it, e, g, r);
      return x.elementType = cn, x.lanes = c, x;
    }
    function bA(e, r, c, g) {
      var x = Ba(Ke, e, g, r);
      x.elementType = B, x.lanes = c;
      var R = {
        isHidden: !1
      };
      return x.stateNode = R, x;
    }
    function Rw(e, r, c) {
      var g = Ba(ae, e, null, r);
      return g.lanes = c, g;
    }
    function r_() {
      var e = Ba(se, null, null, Nt);
      return e.elementType = "DELETED", e;
    }
    function i_(e) {
      var r = Ba(Ve, null, null, Nt);
      return r.stateNode = e, r;
    }
    function Lw(e, r, c) {
      var g = e.children !== null ? e.children : [], x = Ba(te, g, e.key, r);
      return x.lanes = c, x.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: e.implementation
      }, x;
    }
    function wA(e, r) {
      return e === null && (e = Ba(G, null, null, Nt)), e.tag = r.tag, e.key = r.key, e.elementType = r.elementType, e.type = r.type, e.stateNode = r.stateNode, e.return = r.return, e.child = r.child, e.sibling = r.sibling, e.index = r.index, e.ref = r.ref, e.pendingProps = r.pendingProps, e.memoizedProps = r.memoizedProps, e.updateQueue = r.updateQueue, e.memoizedState = r.memoizedState, e.dependencies = r.dependencies, e.mode = r.mode, e.flags = r.flags, e.subtreeFlags = r.subtreeFlags, e.deletions = r.deletions, e.lanes = r.lanes, e.childLanes = r.childLanes, e.alternate = r.alternate, e.actualDuration = r.actualDuration, e.actualStartTime = r.actualStartTime, e.selfBaseDuration = r.selfBaseDuration, e.treeBaseDuration = r.treeBaseDuration, e._debugSource = r._debugSource, e._debugOwner = r._debugOwner, e._debugNeedsRemount = r._debugNeedsRemount, e._debugHookTypes = r._debugHookTypes, e;
    }
    function a_(e, r, c, g, x) {
      this.tag = r, this.containerInfo = e, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = cb, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = dn, this.eventTimes = Id(Pe), this.expirationTimes = Id(Fn), this.pendingLanes = Pe, this.suspendedLanes = Pe, this.pingedLanes = Pe, this.expiredLanes = Pe, this.mutableReadLanes = Pe, this.finishedLanes = Pe, this.entangledLanes = Pe, this.entanglements = Id(Pe), this.identifierPrefix = g, this.onRecoverableError = x, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var R = this.pendingUpdatersLaneMap = [], _ = 0; _ < Xn; _++)
          R.push(/* @__PURE__ */ new Set());
      }
      switch (r) {
        case cm:
          this._debugRootType = c ? "hydrateRoot()" : "createRoot()";
          break;
        case pu:
          this._debugRootType = c ? "hydrate()" : "render()";
          break;
      }
    }
    function SA(e, r, c, g, x, R, _, H, W, J) {
      var ne = new a_(e, r, c, H, W), ge = J2(r, R);
      ne.current = ge, ge.stateNode = ne;
      {
        var he = {
          element: g,
          isDehydrated: c,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        ge.memoizedState = he;
      }
      return Ib(ge), ne;
    }
    var Mw = "18.2.0";
    function s_(e, r, c) {
      var g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Zi(g), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: jr,
        key: g == null ? null : "" + g,
        children: e,
        containerInfo: r,
        implementation: c
      };
    }
    var Dw, Ow;
    Dw = !1, Ow = {};
    function kA(e) {
      if (!e)
        return Ua;
      var r = pa(e), c = BM(r);
      if (r.tag === U) {
        var g = r.type;
        if (bo(g))
          return qS(r, g, c);
      }
      return c;
    }
    function o_(e, r) {
      {
        var c = pa(e);
        if (c === void 0) {
          if (typeof e.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var g = Object.keys(e).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + g);
        }
        var x = ya(c);
        if (x === null)
          return null;
        if (x.mode & Kn) {
          var R = vt(c) || "Component";
          if (!Ow[R]) {
            Ow[R] = !0;
            var _ = Dn;
            try {
              wn(x), c.mode & Kn ? T("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", r, r, R) : T("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", r, r, R);
            } finally {
              _ ? wn(_) : ln();
            }
          }
        }
        return x.stateNode;
      }
    }
    function CA(e, r, c, g, x, R, _, H) {
      var W = !1, J = null;
      return SA(e, r, W, J, c, g, x, R, _);
    }
    function AA(e, r, c, g, x, R, _, H, W, J) {
      var ne = !0, ge = SA(c, g, ne, e, x, R, _, H, W);
      ge.context = kA(null);
      var he = ge.current, Ae = la(), Te = Au(he), De = pl(Ae, Te);
      return De.callback = r ?? null, mu(he, De, Te), p2(ge, Te, Ae), ge;
    }
    function Zp(e, r, c, g) {
      dv(r, e);
      var x = r.current, R = la(), _ = Au(x);
      Wo(_);
      var H = kA(c);
      r.context === null ? r.context = H : r.pendingContext = H, si && Dn !== null && !Dw && (Dw = !0, T(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, vt(Dn) || "Unknown"));
      var W = pl(R, _);
      W.payload = {
        element: e
      }, g = g === void 0 ? null : g, g !== null && (typeof g != "function" && T("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", g), W.callback = g);
      var J = mu(x, W, _);
      return J !== null && (Jr(J, x, _, R), km(J, x, _)), _;
    }
    function py(e) {
      var r = e.current;
      if (!r.child)
        return null;
      switch (r.child.tag) {
        case se:
          return r.child.stateNode;
        default:
          return r.child.stateNode;
      }
    }
    function l_(e) {
      switch (e.tag) {
        case q: {
          var r = e.stateNode;
          if (Er(r)) {
            var c = Mx(r);
            y2(r, c);
          }
          break;
        }
        case re: {
          yl(function() {
            var x = Ta(e, Yt);
            if (x !== null) {
              var R = la();
              Jr(x, e, Yt, R);
            }
          });
          var g = Yt;
          _w(e, g);
          break;
        }
      }
    }
    function TA(e, r) {
      var c = e.memoizedState;
      c !== null && c.dehydrated !== null && (c.retryLane = kv(c.retryLane, r));
    }
    function _w(e, r) {
      TA(e, r);
      var c = e.alternate;
      c && TA(c, r);
    }
    function u_(e) {
      if (e.tag === re) {
        var r = Vl, c = Ta(e, r);
        if (c !== null) {
          var g = la();
          Jr(c, e, r, g);
        }
        _w(e, r);
      }
    }
    function c_(e) {
      if (e.tag === re) {
        var r = Au(e), c = Ta(e, r);
        if (c !== null) {
          var g = la();
          Jr(c, e, r, g);
        }
        _w(e, r);
      }
    }
    function EA(e) {
      var r = lv(e);
      return r === null ? null : r.stateNode;
    }
    var RA = function(e) {
      return null;
    };
    function d_(e) {
      return RA(e);
    }
    var LA = function(e) {
      return !1;
    };
    function f_(e) {
      return LA(e);
    }
    var MA = null, DA = null, OA = null, _A = null, PA = null, NA = null, zA = null, IA = null, FA = null;
    {
      var YA = function(e, r, c) {
        var g = r[c], x = _r(e) ? e.slice() : p({}, e);
        return c + 1 === r.length ? (_r(x) ? x.splice(g, 1) : delete x[g], x) : (x[g] = YA(e[g], r, c + 1), x);
      }, HA = function(e, r) {
        return YA(e, r, 0);
      }, jA = function(e, r, c, g) {
        var x = r[g], R = _r(e) ? e.slice() : p({}, e);
        if (g + 1 === r.length) {
          var _ = c[g];
          R[_] = R[x], _r(R) ? R.splice(x, 1) : delete R[x];
        } else
          R[x] = jA(
            // $FlowFixMe number or string is fine here
            e[x],
            r,
            c,
            g + 1
          );
        return R;
      }, UA = function(e, r, c) {
        if (r.length !== c.length) {
          C("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var g = 0; g < c.length - 1; g++)
            if (r[g] !== c[g]) {
              C("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return jA(e, r, c, 0);
      }, BA = function(e, r, c, g) {
        if (c >= r.length)
          return g;
        var x = r[c], R = _r(e) ? e.slice() : p({}, e);
        return R[x] = BA(e[x], r, c + 1, g), R;
      }, WA = function(e, r, c) {
        return BA(e, r, 0, c);
      }, Pw = function(e, r) {
        for (var c = e.memoizedState; c !== null && r > 0; )
          c = c.next, r--;
        return c;
      };
      MA = function(e, r, c, g) {
        var x = Pw(e, r);
        if (x !== null) {
          var R = WA(x.memoizedState, c, g);
          x.memoizedState = R, x.baseState = R, e.memoizedProps = p({}, e.memoizedProps);
          var _ = Ta(e, Yt);
          _ !== null && Jr(_, e, Yt, Fn);
        }
      }, DA = function(e, r, c) {
        var g = Pw(e, r);
        if (g !== null) {
          var x = HA(g.memoizedState, c);
          g.memoizedState = x, g.baseState = x, e.memoizedProps = p({}, e.memoizedProps);
          var R = Ta(e, Yt);
          R !== null && Jr(R, e, Yt, Fn);
        }
      }, OA = function(e, r, c, g) {
        var x = Pw(e, r);
        if (x !== null) {
          var R = UA(x.memoizedState, c, g);
          x.memoizedState = R, x.baseState = R, e.memoizedProps = p({}, e.memoizedProps);
          var _ = Ta(e, Yt);
          _ !== null && Jr(_, e, Yt, Fn);
        }
      }, _A = function(e, r, c) {
        e.pendingProps = WA(e.memoizedProps, r, c), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var g = Ta(e, Yt);
        g !== null && Jr(g, e, Yt, Fn);
      }, PA = function(e, r) {
        e.pendingProps = HA(e.memoizedProps, r), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var c = Ta(e, Yt);
        c !== null && Jr(c, e, Yt, Fn);
      }, NA = function(e, r, c) {
        e.pendingProps = UA(e.memoizedProps, r, c), e.alternate && (e.alternate.pendingProps = e.pendingProps);
        var g = Ta(e, Yt);
        g !== null && Jr(g, e, Yt, Fn);
      }, zA = function(e) {
        var r = Ta(e, Yt);
        r !== null && Jr(r, e, Yt, Fn);
      }, IA = function(e) {
        RA = e;
      }, FA = function(e) {
        LA = e;
      };
    }
    function h_(e) {
      var r = ya(e);
      return r === null ? null : r.stateNode;
    }
    function p_(e) {
      return null;
    }
    function g_() {
      return Dn;
    }
    function v_(e) {
      var r = e.findFiberByHostInstance, c = h.ReactCurrentDispatcher;
      return kh({
        bundleType: e.bundleType,
        version: e.version,
        rendererPackageName: e.rendererPackageName,
        rendererConfig: e.rendererConfig,
        overrideHookState: MA,
        overrideHookStateDeletePath: DA,
        overrideHookStateRenamePath: OA,
        overrideProps: _A,
        overridePropsDeletePath: PA,
        overridePropsRenamePath: NA,
        setErrorHandler: IA,
        setSuspenseHandler: FA,
        scheduleUpdate: zA,
        currentDispatcherRef: c,
        findHostInstanceByFiber: h_,
        findFiberByHostInstance: r || p_,
        // React Refresh
        findHostInstancesForRefresh: V2,
        scheduleRefresh: W2,
        scheduleRoot: X2,
        setRefreshHandler: B2,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: g_,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: Mw
      });
    }
    var XA = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(e) {
      console.error(e);
    };
    function Nw(e) {
      this._internalRoot = e;
    }
    gy.prototype.render = Nw.prototype.render = function(e) {
      var r = this._internalRoot;
      if (r === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? T("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : vy(arguments[1]) ? T("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && T("You passed a second argument to root.render(...) but it only accepts one argument.");
        var c = r.containerInfo;
        if (c.nodeType !== xr) {
          var g = EA(r.current);
          g && g.parentNode !== c && T("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      Zp(e, r, null, null);
    }, gy.prototype.unmount = Nw.prototype.unmount = function() {
      typeof arguments[0] == "function" && T("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var e = this._internalRoot;
      if (e !== null) {
        this._internalRoot = null;
        var r = e.containerInfo;
        rA() && T("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), yl(function() {
          Zp(null, e, null, null);
        }), WS(r);
      }
    };
    function m_(e, r) {
      if (!vy(e))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      VA(e);
      var c = !1, g = !1, x = "", R = XA;
      r != null && (r.hydrate ? C("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof r == "object" && r !== null && r.$$typeof === Na && T(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), r.unstable_strictMode === !0 && (c = !0), r.identifierPrefix !== void 0 && (x = r.identifierPrefix), r.onRecoverableError !== void 0 && (R = r.onRecoverableError), r.transitionCallbacks !== void 0 && r.transitionCallbacks);
      var _ = CA(e, cm, null, c, g, x, R);
      rm(_.current, e);
      var H = e.nodeType === xr ? e.parentNode : e;
      return ip(H), new Nw(_);
    }
    function gy(e) {
      this._internalRoot = e;
    }
    function y_(e) {
      e && Dv(e);
    }
    gy.prototype.unstable_scheduleHydration = y_;
    function x_(e, r, c) {
      if (!vy(e))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      VA(e), r === void 0 && T("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var g = c ?? null, x = c != null && c.hydratedSources || null, R = !1, _ = !1, H = "", W = XA;
      c != null && (c.unstable_strictMode === !0 && (R = !0), c.identifierPrefix !== void 0 && (H = c.identifierPrefix), c.onRecoverableError !== void 0 && (W = c.onRecoverableError));
      var J = AA(r, null, e, cm, g, R, _, H, W);
      if (rm(J.current, e), ip(e), x)
        for (var ne = 0; ne < x.length; ne++) {
          var ge = x[ne];
          ED(J, ge);
        }
      return new gy(J);
    }
    function vy(e) {
      return !!(e && (e.nodeType === _i || e.nodeType === Ia || e.nodeType === No || !Qe));
    }
    function Qp(e) {
      return !!(e && (e.nodeType === _i || e.nodeType === Ia || e.nodeType === No || e.nodeType === xr && e.nodeValue === " react-mount-point-unstable "));
    }
    function VA(e) {
      e.nodeType === _i && e.tagName && e.tagName.toUpperCase() === "BODY" && T("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), gp(e) && (e._reactRootContainer ? T("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : T("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var b_ = h.ReactCurrentOwner, GA;
    GA = function(e) {
      if (e._reactRootContainer && e.nodeType !== xr) {
        var r = EA(e._reactRootContainer.current);
        r && r.parentNode !== e && T("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var c = !!e._reactRootContainer, g = zw(e), x = !!(g && fu(g));
      x && !c && T("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), e.nodeType === _i && e.tagName && e.tagName.toUpperCase() === "BODY" && T("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function zw(e) {
      return e ? e.nodeType === Ia ? e.documentElement : e.firstChild : null;
    }
    function $A() {
    }
    function w_(e, r, c, g, x) {
      if (x) {
        if (typeof g == "function") {
          var R = g;
          g = function() {
            var he = py(_);
            R.call(he);
          };
        }
        var _ = AA(
          r,
          g,
          e,
          pu,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          $A
        );
        e._reactRootContainer = _, rm(_.current, e);
        var H = e.nodeType === xr ? e.parentNode : e;
        return ip(H), yl(), _;
      } else {
        for (var W; W = e.lastChild; )
          e.removeChild(W);
        if (typeof g == "function") {
          var J = g;
          g = function() {
            var he = py(ne);
            J.call(he);
          };
        }
        var ne = CA(
          e,
          pu,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          $A
        );
        e._reactRootContainer = ne, rm(ne.current, e);
        var ge = e.nodeType === xr ? e.parentNode : e;
        return ip(ge), yl(function() {
          Zp(r, ne, c, g);
        }), ne;
      }
    }
    function S_(e, r) {
      e !== null && typeof e != "function" && T("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", r, e);
    }
    function my(e, r, c, g, x) {
      GA(c), S_(x === void 0 ? null : x, "render");
      var R = c._reactRootContainer, _;
      if (!R)
        _ = w_(c, r, e, x, g);
      else {
        if (_ = R, typeof x == "function") {
          var H = x;
          x = function() {
            var W = py(_);
            H.call(W);
          };
        }
        Zp(r, _, e, x);
      }
      return py(_);
    }
    function k_(e) {
      {
        var r = b_.current;
        if (r !== null && r.stateNode !== null) {
          var c = r.stateNode._warnedAboutRefsInRender;
          c || T("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", yt(r.type) || "A component"), r.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return e == null ? null : e.nodeType === _i ? e : o_(e, "findDOMNode");
    }
    function C_(e, r, c) {
      if (T("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Qp(r))
        throw new Error("Target container is not a DOM element.");
      {
        var g = gp(r) && r._reactRootContainer === void 0;
        g && T("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return my(null, e, r, !0, c);
    }
    function A_(e, r, c) {
      if (T("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Qp(r))
        throw new Error("Target container is not a DOM element.");
      {
        var g = gp(r) && r._reactRootContainer === void 0;
        g && T("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return my(null, e, r, !1, c);
    }
    function T_(e, r, c, g) {
      if (T("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Qp(c))
        throw new Error("Target container is not a DOM element.");
      if (e == null || !Zu(e))
        throw new Error("parentComponent must be a valid React Component");
      return my(e, r, c, !1, g);
    }
    function E_(e) {
      if (!Qp(e))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var r = gp(e) && e._reactRootContainer === void 0;
        r && T("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (e._reactRootContainer) {
        {
          var c = zw(e), g = c && !fu(c);
          g && T("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return yl(function() {
          my(null, null, e, !1, function() {
            e._reactRootContainer = null, WS(e);
          });
        }), !0;
      } else {
        {
          var x = zw(e), R = !!(x && fu(x)), _ = e.nodeType === _i && Qp(e.parentNode) && !!e.parentNode._reactRootContainer;
          R && T("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", _ ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    gt(l_), Av(u_), dc(c_), Hh(wa), Ev(lc), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && T("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), av(ML), id(hw, x2, yl);
    function R_(e, r) {
      var c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!vy(r))
        throw new Error("Target container is not a DOM element.");
      return s_(e, r, null, c);
    }
    function L_(e, r, c, g) {
      return T_(e, r, c, g);
    }
    var Iw = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [fu, of, im, rd, Gu, hw]
    };
    function M_(e, r) {
      return Iw.usingClientEntryPoint || T('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), m_(e, r);
    }
    function D_(e, r, c) {
      return Iw.usingClientEntryPoint || T('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), x_(e, r, c);
    }
    function O_(e) {
      return rA() && T("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), yl(e);
    }
    var __ = v_({
      findFiberByHostInstance: wc,
      bundleType: 1,
      version: Mw,
      rendererPackageName: "react-dom"
    });
    if (!__ && pn && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var qA = window.location.protocol;
      /^(https?|file):$/.test(qA) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (qA === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    Da.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Iw, Da.createPortal = R_, Da.createRoot = M_, Da.findDOMNode = k_, Da.flushSync = O_, Da.hydrate = C_, Da.hydrateRoot = D_, Da.render = A_, Da.unmountComponentAtNode = E_, Da.unstable_batchedUpdates = hw, Da.unstable_renderSubtreeIntoContainer = L_, Da.version = Mw, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Da;
}
function SR() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(SR);
    } catch (s) {
      console.error(s);
    }
  }
}
process.env.NODE_ENV === "production" ? (SR(), w1.exports = HY()) : w1.exports = jY();
var UY = w1.exports;
const dg = /^[a-z0-9]+(-[a-z0-9]+)*$/, lx = (s, u, h, v = "") => {
  const w = s.split(":");
  if (s.slice(0, 1) === "@") {
    if (w.length < 2 || w.length > 3)
      return null;
    v = w.shift().slice(1);
  }
  if (w.length > 3 || !w.length)
    return null;
  if (w.length > 1) {
    const F = w.pop(), Y = w.pop(), U = {
      // Allow provider without '@': "provider:prefix:name"
      provider: w.length > 0 ? w[0] : v,
      prefix: Y,
      name: F
    };
    return u && !Dy(U) ? null : U;
  }
  const C = w[0], T = C.split("-");
  if (T.length > 1) {
    const F = {
      provider: v,
      prefix: T.shift(),
      name: T.join("-")
    };
    return u && !Dy(F) ? null : F;
  }
  if (h && v === "") {
    const F = {
      provider: v,
      prefix: "",
      name: C
    };
    return u && !Dy(F, h) ? null : F;
  }
  return null;
}, Dy = (s, u) => s ? !!((s.provider === "" || s.provider.match(dg)) && (u && s.prefix === "" || s.prefix.match(dg)) && s.name.match(dg)) : !1, kR = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
), Vy = Object.freeze({
  rotate: 0,
  vFlip: !1,
  hFlip: !1
}), oS = Object.freeze({
  ...kR,
  ...Vy
}), S1 = Object.freeze({
  ...oS,
  body: "",
  hidden: !1
});
function BY(s, u) {
  const h = {};
  !s.hFlip != !u.hFlip && (h.hFlip = !0), !s.vFlip != !u.vFlip && (h.vFlip = !0);
  const v = ((s.rotate || 0) + (u.rotate || 0)) % 4;
  return v && (h.rotate = v), h;
}
function DT(s, u) {
  const h = BY(s, u);
  for (const v in S1)
    v in Vy ? v in s && !(v in h) && (h[v] = Vy[v]) : v in u ? h[v] = u[v] : v in s && (h[v] = s[v]);
  return h;
}
function WY(s, u) {
  const h = s.icons, v = s.aliases || /* @__PURE__ */ Object.create(null), w = /* @__PURE__ */ Object.create(null);
  function C(T) {
    if (h[T])
      return w[T] = [];
    if (!(T in w)) {
      w[T] = null;
      const F = v[T] && v[T].parent, Y = F && C(F);
      Y && (w[T] = [F].concat(Y));
    }
    return w[T];
  }
  return (u || Object.keys(h).concat(Object.keys(v))).forEach(C), w;
}
function XY(s, u, h) {
  const v = s.icons, w = s.aliases || /* @__PURE__ */ Object.create(null);
  let C = {};
  function T(F) {
    C = DT(
      v[F] || w[F],
      C
    );
  }
  return T(u), h.forEach(T), DT(s, C);
}
function CR(s, u) {
  const h = [];
  if (typeof s != "object" || typeof s.icons != "object")
    return h;
  s.not_found instanceof Array && s.not_found.forEach((w) => {
    u(w, null), h.push(w);
  });
  const v = WY(s);
  for (const w in v) {
    const C = v[w];
    C && (u(w, XY(s, w, C)), h.push(w));
  }
  return h;
}
const VY = {
  provider: "",
  aliases: {},
  not_found: {},
  ...kR
};
function $w(s, u) {
  for (const h in u)
    if (h in s && typeof s[h] != typeof u[h])
      return !1;
  return !0;
}
function AR(s) {
  if (typeof s != "object" || s === null)
    return null;
  const u = s;
  if (typeof u.prefix != "string" || !s.icons || typeof s.icons != "object" || !$w(s, VY))
    return null;
  const h = u.icons;
  for (const w in h) {
    const C = h[w];
    if (!w.match(dg) || typeof C.body != "string" || !$w(
      C,
      S1
    ))
      return null;
  }
  const v = u.aliases || /* @__PURE__ */ Object.create(null);
  for (const w in v) {
    const C = v[w], T = C.parent;
    if (!w.match(dg) || typeof T != "string" || !h[T] && !v[T] || !$w(
      C,
      S1
    ))
      return null;
  }
  return u;
}
const OT = /* @__PURE__ */ Object.create(null);
function GY(s, u) {
  return {
    provider: s,
    prefix: u,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function jc(s, u) {
  const h = OT[s] || (OT[s] = /* @__PURE__ */ Object.create(null));
  return h[u] || (h[u] = GY(s, u));
}
function lS(s, u) {
  return AR(u) ? CR(u, (h, v) => {
    v ? s.icons[h] = v : s.missing.add(h);
  }) : [];
}
function $Y(s, u, h) {
  try {
    if (typeof h.body == "string")
      return s.icons[u] = { ...h }, !0;
  } catch {
  }
  return !1;
}
let xg = !1;
function TR(s) {
  return typeof s == "boolean" && (xg = s), xg;
}
function qY(s) {
  const u = typeof s == "string" ? lx(s, !0, xg) : s;
  if (u) {
    const h = jc(u.provider, u.prefix), v = u.name;
    return h.icons[v] || (h.missing.has(v) ? null : void 0);
  }
}
function ZY(s, u) {
  const h = lx(s, !0, xg);
  if (!h)
    return !1;
  const v = jc(h.provider, h.prefix);
  return $Y(v, h.name, u);
}
function QY(s, u) {
  if (typeof s != "object")
    return !1;
  if (typeof u != "string" && (u = s.provider || ""), xg && !u && !s.prefix) {
    let w = !1;
    return AR(s) && (s.prefix = "", CR(s, (C, T) => {
      T && ZY(C, T) && (w = !0);
    })), w;
  }
  const h = s.prefix;
  if (!Dy({
    provider: u,
    prefix: h,
    name: "a"
  }))
    return !1;
  const v = jc(u, h);
  return !!lS(v, s);
}
const ER = Object.freeze({
  width: null,
  height: null
}), RR = Object.freeze({
  // Dimensions
  ...ER,
  // Transformations
  ...Vy
}), KY = /(-?[0-9.]*[0-9]+[0-9.]*)/g, JY = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function _T(s, u, h) {
  if (u === 1)
    return s;
  if (h = h || 100, typeof s == "number")
    return Math.ceil(s * u * h) / h;
  if (typeof s != "string")
    return s;
  const v = s.split(KY);
  if (v === null || !v.length)
    return s;
  const w = [];
  let C = v.shift(), T = JY.test(C);
  for (; ; ) {
    if (T) {
      const F = parseFloat(C);
      isNaN(F) ? w.push(C) : w.push(Math.ceil(F * u * h) / h);
    } else
      w.push(C);
    if (C = v.shift(), C === void 0)
      return w.join("");
    T = !T;
  }
}
const eH = (s) => s === "unset" || s === "undefined" || s === "none";
function tH(s, u) {
  const h = {
    ...oS,
    ...s
  }, v = {
    ...RR,
    ...u
  }, w = {
    left: h.left,
    top: h.top,
    width: h.width,
    height: h.height
  };
  let C = h.body;
  [h, v].forEach((ae) => {
    const ue = [], Ce = ae.hFlip, Ne = ae.vFlip;
    let K = ae.rotate;
    Ce ? Ne ? K += 2 : (ue.push(
      "translate(" + (w.width + w.left).toString() + " " + (0 - w.top).toString() + ")"
    ), ue.push("scale(-1 1)"), w.top = w.left = 0) : Ne && (ue.push(
      "translate(" + (0 - w.left).toString() + " " + (w.height + w.top).toString() + ")"
    ), ue.push("scale(1 -1)"), w.top = w.left = 0);
    let we;
    switch (K < 0 && (K -= Math.floor(K / 4) * 4), K = K % 4, K) {
      case 1:
        we = w.height / 2 + w.top, ue.unshift(
          "rotate(90 " + we.toString() + " " + we.toString() + ")"
        );
        break;
      case 2:
        ue.unshift(
          "rotate(180 " + (w.width / 2 + w.left).toString() + " " + (w.height / 2 + w.top).toString() + ")"
        );
        break;
      case 3:
        we = w.width / 2 + w.left, ue.unshift(
          "rotate(-90 " + we.toString() + " " + we.toString() + ")"
        );
        break;
    }
    K % 2 === 1 && (w.left !== w.top && (we = w.left, w.left = w.top, w.top = we), w.width !== w.height && (we = w.width, w.width = w.height, w.height = we)), ue.length && (C = '<g transform="' + ue.join(" ") + '">' + C + "</g>");
  });
  const T = v.width, F = v.height, Y = w.width, U = w.height;
  let G, q;
  T === null ? (q = F === null ? "1em" : F === "auto" ? U : F, G = _T(q, Y / U)) : (G = T === "auto" ? Y : T, q = F === null ? _T(G, U / Y) : F === "auto" ? U : F);
  const te = {}, se = (ae, ue) => {
    eH(ue) || (te[ae] = ue.toString());
  };
  return se("width", G), se("height", q), te.viewBox = w.left.toString() + " " + w.top.toString() + " " + Y.toString() + " " + U.toString(), {
    attributes: te,
    body: C
  };
}
const nH = /\sid="(\S+)"/g, rH = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let iH = 0;
function aH(s, u = rH) {
  const h = [];
  let v;
  for (; v = nH.exec(s); )
    h.push(v[1]);
  if (!h.length)
    return s;
  const w = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return h.forEach((C) => {
    const T = typeof u == "function" ? u(C) : u + (iH++).toString(), F = C.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    s = s.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + F + ')([")]|\\.[a-z])', "g"),
      "$1" + T + w + "$3"
    );
  }), s = s.replace(new RegExp(w, "g"), ""), s;
}
const k1 = /* @__PURE__ */ Object.create(null);
function sH(s, u) {
  k1[s] = u;
}
function C1(s) {
  return k1[s] || k1[""];
}
function uS(s) {
  let u;
  if (typeof s.resources == "string")
    u = [s.resources];
  else if (u = s.resources, !(u instanceof Array) || !u.length)
    return null;
  return {
    // API hosts
    resources: u,
    // Root path
    path: s.path || "/",
    // URL length limit
    maxURL: s.maxURL || 500,
    // Timeout before next host is used.
    rotate: s.rotate || 750,
    // Timeout before failing query.
    timeout: s.timeout || 5e3,
    // Randomise default API end point.
    random: s.random === !0,
    // Start index
    index: s.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: s.dataAfterTimeout !== !1
  };
}
const cS = /* @__PURE__ */ Object.create(null), ag = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
], Oy = [];
for (; ag.length > 0; )
  ag.length === 1 || Math.random() > 0.5 ? Oy.push(ag.shift()) : Oy.push(ag.pop());
cS[""] = uS({
  resources: ["https://api.iconify.design"].concat(Oy)
});
function oH(s, u) {
  const h = uS(u);
  return h === null ? !1 : (cS[s] = h, !0);
}
function dS(s) {
  return cS[s];
}
const lH = () => {
  let s;
  try {
    if (s = fetch, typeof s == "function")
      return s;
  } catch {
  }
};
let PT = lH();
function uH(s, u) {
  const h = dS(s);
  if (!h)
    return 0;
  let v;
  if (!h.maxURL)
    v = 0;
  else {
    let w = 0;
    h.resources.forEach((T) => {
      w = Math.max(w, T.length);
    });
    const C = u + ".json?icons=";
    v = h.maxURL - w - h.path.length - C.length;
  }
  return v;
}
function cH(s) {
  return s === 404;
}
const dH = (s, u, h) => {
  const v = [], w = uH(s, u), C = "icons";
  let T = {
    type: C,
    provider: s,
    prefix: u,
    icons: []
  }, F = 0;
  return h.forEach((Y, U) => {
    F += Y.length + 1, F >= w && U > 0 && (v.push(T), T = {
      type: C,
      provider: s,
      prefix: u,
      icons: []
    }, F = Y.length), T.icons.push(Y);
  }), v.push(T), v;
};
function fH(s) {
  if (typeof s == "string") {
    const u = dS(s);
    if (u)
      return u.path;
  }
  return "/";
}
const hH = (s, u, h) => {
  if (!PT) {
    h("abort", 424);
    return;
  }
  let v = fH(u.provider);
  switch (u.type) {
    case "icons": {
      const C = u.prefix, F = u.icons.join(","), Y = new URLSearchParams({
        icons: F
      });
      v += C + ".json?" + Y.toString();
      break;
    }
    case "custom": {
      const C = u.uri;
      v += C.slice(0, 1) === "/" ? C.slice(1) : C;
      break;
    }
    default:
      h("abort", 400);
      return;
  }
  let w = 503;
  PT(s + v).then((C) => {
    const T = C.status;
    if (T !== 200) {
      setTimeout(() => {
        h(cH(T) ? "abort" : "next", T);
      });
      return;
    }
    return w = 501, C.json();
  }).then((C) => {
    if (typeof C != "object" || C === null) {
      setTimeout(() => {
        C === 404 ? h("abort", C) : h("next", w);
      });
      return;
    }
    setTimeout(() => {
      h("success", C);
    });
  }).catch(() => {
    h("next", w);
  });
}, pH = {
  prepare: dH,
  send: hH
};
function gH(s) {
  const u = {
    loaded: [],
    missing: [],
    pending: []
  }, h = /* @__PURE__ */ Object.create(null);
  s.sort((w, C) => w.provider !== C.provider ? w.provider.localeCompare(C.provider) : w.prefix !== C.prefix ? w.prefix.localeCompare(C.prefix) : w.name.localeCompare(C.name));
  let v = {
    provider: "",
    prefix: "",
    name: ""
  };
  return s.forEach((w) => {
    if (v.name === w.name && v.prefix === w.prefix && v.provider === w.provider)
      return;
    v = w;
    const C = w.provider, T = w.prefix, F = w.name, Y = h[C] || (h[C] = /* @__PURE__ */ Object.create(null)), U = Y[T] || (Y[T] = jc(C, T));
    let G;
    F in U.icons ? G = u.loaded : T === "" || U.missing.has(F) ? G = u.missing : G = u.pending;
    const q = {
      provider: C,
      prefix: T,
      name: F
    };
    G.push(q);
  }), u;
}
function LR(s, u) {
  s.forEach((h) => {
    const v = h.loaderCallbacks;
    v && (h.loaderCallbacks = v.filter((w) => w.id !== u));
  });
}
function vH(s) {
  s.pendingCallbacksFlag || (s.pendingCallbacksFlag = !0, setTimeout(() => {
    s.pendingCallbacksFlag = !1;
    const u = s.loaderCallbacks ? s.loaderCallbacks.slice(0) : [];
    if (!u.length)
      return;
    let h = !1;
    const v = s.provider, w = s.prefix;
    u.forEach((C) => {
      const T = C.icons, F = T.pending.length;
      T.pending = T.pending.filter((Y) => {
        if (Y.prefix !== w)
          return !0;
        const U = Y.name;
        if (s.icons[U])
          T.loaded.push({
            provider: v,
            prefix: w,
            name: U
          });
        else if (s.missing.has(U))
          T.missing.push({
            provider: v,
            prefix: w,
            name: U
          });
        else
          return h = !0, !0;
        return !1;
      }), T.pending.length !== F && (h || LR([s], C.id), C.callback(
        T.loaded.slice(0),
        T.missing.slice(0),
        T.pending.slice(0),
        C.abort
      ));
    });
  }));
}
let mH = 0;
function yH(s, u, h) {
  const v = mH++, w = LR.bind(null, h, v);
  if (!u.pending.length)
    return w;
  const C = {
    id: v,
    icons: u,
    callback: s,
    abort: w
  };
  return h.forEach((T) => {
    (T.loaderCallbacks || (T.loaderCallbacks = [])).push(C);
  }), w;
}
function xH(s, u = !0, h = !1) {
  const v = [];
  return s.forEach((w) => {
    const C = typeof w == "string" ? lx(w, u, h) : w;
    C && v.push(C);
  }), v;
}
var bH = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: !1,
  dataAfterTimeout: !1
};
function wH(s, u, h, v) {
  const w = s.resources.length, C = s.random ? Math.floor(Math.random() * w) : s.index;
  let T;
  if (s.random) {
    let ve = s.resources.slice(0);
    for (T = []; ve.length > 1; ) {
      const Me = Math.floor(Math.random() * ve.length);
      T.push(ve[Me]), ve = ve.slice(0, Me).concat(ve.slice(Me + 1));
    }
    T = T.concat(ve);
  } else
    T = s.resources.slice(C).concat(s.resources.slice(0, C));
  const F = Date.now();
  let Y = "pending", U = 0, G, q = null, te = [], se = [];
  typeof v == "function" && se.push(v);
  function ae() {
    q && (clearTimeout(q), q = null);
  }
  function ue() {
    Y === "pending" && (Y = "aborted"), ae(), te.forEach((ve) => {
      ve.status === "pending" && (ve.status = "aborted");
    }), te = [];
  }
  function Ce(ve, Me) {
    Me && (se = []), typeof ve == "function" && se.push(ve);
  }
  function Ne() {
    return {
      startTime: F,
      payload: u,
      status: Y,
      queriesSent: U,
      queriesPending: te.length,
      subscribe: Ce,
      abort: ue
    };
  }
  function K() {
    Y = "failed", se.forEach((ve) => {
      ve(void 0, G);
    });
  }
  function we() {
    te.forEach((ve) => {
      ve.status === "pending" && (ve.status = "aborted");
    }), te = [];
  }
  function Re(ve, Me, et) {
    const je = Me !== "success";
    switch (te = te.filter((Ve) => Ve !== ve), Y) {
      case "pending":
        break;
      case "failed":
        if (je || !s.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (Me === "abort") {
      G = et, K();
      return;
    }
    if (je) {
      G = et, te.length || (T.length ? re() : K());
      return;
    }
    if (ae(), we(), !s.random) {
      const Ve = s.resources.indexOf(ve.resource);
      Ve !== -1 && Ve !== s.index && (s.index = Ve);
    }
    Y = "completed", se.forEach((Ve) => {
      Ve(et);
    });
  }
  function re() {
    if (Y !== "pending")
      return;
    ae();
    const ve = T.shift();
    if (ve === void 0) {
      if (te.length) {
        q = setTimeout(() => {
          ae(), Y === "pending" && (we(), K());
        }, s.timeout);
        return;
      }
      K();
      return;
    }
    const Me = {
      status: "pending",
      resource: ve,
      callback: (et, je) => {
        Re(Me, et, je);
      }
    };
    te.push(Me), U++, q = setTimeout(re, s.rotate), h(ve, u, Me.callback);
  }
  return setTimeout(re), Ne;
}
function MR(s) {
  const u = {
    ...bH,
    ...s
  };
  let h = [];
  function v() {
    h = h.filter((F) => F().status === "pending");
  }
  function w(F, Y, U) {
    const G = wH(
      u,
      F,
      Y,
      (q, te) => {
        v(), U && U(q, te);
      }
    );
    return h.push(G), G;
  }
  function C(F) {
    return h.find((Y) => F(Y)) || null;
  }
  return {
    query: w,
    find: C,
    setIndex: (F) => {
      u.index = F;
    },
    getIndex: () => u.index,
    cleanup: v
  };
}
function NT() {
}
const qw = /* @__PURE__ */ Object.create(null);
function SH(s) {
  if (!qw[s]) {
    const u = dS(s);
    if (!u)
      return;
    const h = MR(u), v = {
      config: u,
      redundancy: h
    };
    qw[s] = v;
  }
  return qw[s];
}
function kH(s, u, h) {
  let v, w;
  if (typeof s == "string") {
    const C = C1(s);
    if (!C)
      return h(void 0, 424), NT;
    w = C.send;
    const T = SH(s);
    T && (v = T.redundancy);
  } else {
    const C = uS(s);
    if (C) {
      v = MR(C);
      const T = s.resources ? s.resources[0] : "", F = C1(T);
      F && (w = F.send);
    }
  }
  return !v || !w ? (h(void 0, 424), NT) : v.query(u, w, h)().abort;
}
const zT = "iconify2", bg = "iconify", DR = bg + "-count", IT = bg + "-version", OR = 36e5, CH = 168;
function A1(s, u) {
  try {
    return s.getItem(u);
  } catch {
  }
}
function fS(s, u, h) {
  try {
    return s.setItem(u, h), !0;
  } catch {
  }
}
function FT(s, u) {
  try {
    s.removeItem(u);
  } catch {
  }
}
function T1(s, u) {
  return fS(s, DR, u.toString());
}
function E1(s) {
  return parseInt(A1(s, DR)) || 0;
}
const ux = {
  local: !0,
  session: !0
}, _R = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let hS = !1;
function AH(s) {
  hS = s;
}
let ky = typeof window > "u" ? {} : window;
function PR(s) {
  const u = s + "Storage";
  try {
    if (ky && ky[u] && typeof ky[u].length == "number")
      return ky[u];
  } catch {
  }
  ux[s] = !1;
}
function NR(s, u) {
  const h = PR(s);
  if (!h)
    return;
  const v = A1(h, IT);
  if (v !== zT) {
    if (v) {
      const F = E1(h);
      for (let Y = 0; Y < F; Y++)
        FT(h, bg + Y.toString());
    }
    fS(h, IT, zT), T1(h, 0);
    return;
  }
  const w = Math.floor(Date.now() / OR) - CH, C = (F) => {
    const Y = bg + F.toString(), U = A1(h, Y);
    if (typeof U == "string") {
      try {
        const G = JSON.parse(U);
        if (typeof G == "object" && typeof G.cached == "number" && G.cached > w && typeof G.provider == "string" && typeof G.data == "object" && typeof G.data.prefix == "string" && // Valid item: run callback
        u(G, F))
          return !0;
      } catch {
      }
      FT(h, Y);
    }
  };
  let T = E1(h);
  for (let F = T - 1; F >= 0; F--)
    C(F) || (F === T - 1 ? (T--, T1(h, T)) : _R[s].add(F));
}
function zR() {
  if (!hS) {
    AH(!0);
    for (const s in ux)
      NR(s, (u) => {
        const h = u.data, v = u.provider, w = h.prefix, C = jc(
          v,
          w
        );
        if (!lS(C, h).length)
          return !1;
        const T = h.lastModified || -1;
        return C.lastModifiedCached = C.lastModifiedCached ? Math.min(C.lastModifiedCached, T) : T, !0;
      });
  }
}
function TH(s, u) {
  const h = s.lastModifiedCached;
  if (
    // Matches or newer
    h && h >= u
  )
    return h === u;
  if (s.lastModifiedCached = u, h)
    for (const v in ux)
      NR(v, (w) => {
        const C = w.data;
        return w.provider !== s.provider || C.prefix !== s.prefix || C.lastModified === u;
      });
  return !0;
}
function EH(s, u) {
  hS || zR();
  function h(v) {
    let w;
    if (!ux[v] || !(w = PR(v)))
      return;
    const C = _R[v];
    let T;
    if (C.size)
      C.delete(T = Array.from(C).shift());
    else if (T = E1(w), !T1(w, T + 1))
      return;
    const F = {
      cached: Math.floor(Date.now() / OR),
      provider: s.provider,
      data: u
    };
    return fS(
      w,
      bg + T.toString(),
      JSON.stringify(F)
    );
  }
  u.lastModified && !TH(s, u.lastModified) || Object.keys(u.icons).length && (u.not_found && (u = Object.assign({}, u), delete u.not_found), h("local") || h("session"));
}
function YT() {
}
function RH(s) {
  s.iconsLoaderFlag || (s.iconsLoaderFlag = !0, setTimeout(() => {
    s.iconsLoaderFlag = !1, vH(s);
  }));
}
function LH(s, u) {
  s.iconsToLoad ? s.iconsToLoad = s.iconsToLoad.concat(u).sort() : s.iconsToLoad = u, s.iconsQueueFlag || (s.iconsQueueFlag = !0, setTimeout(() => {
    s.iconsQueueFlag = !1;
    const { provider: h, prefix: v } = s, w = s.iconsToLoad;
    delete s.iconsToLoad;
    let C;
    if (!w || !(C = C1(h)))
      return;
    C.prepare(h, v, w).forEach((F) => {
      kH(h, F, (Y) => {
        if (typeof Y != "object")
          F.icons.forEach((U) => {
            s.missing.add(U);
          });
        else
          try {
            const U = lS(
              s,
              Y
            );
            if (!U.length)
              return;
            const G = s.pendingIcons;
            G && U.forEach((q) => {
              G.delete(q);
            }), EH(s, Y);
          } catch (U) {
            console.error(U);
          }
        RH(s);
      });
    });
  }));
}
const MH = (s, u) => {
  const h = xH(s, !0, TR()), v = gH(h);
  if (!v.pending.length) {
    let Y = !0;
    return u && setTimeout(() => {
      Y && u(
        v.loaded,
        v.missing,
        v.pending,
        YT
      );
    }), () => {
      Y = !1;
    };
  }
  const w = /* @__PURE__ */ Object.create(null), C = [];
  let T, F;
  return v.pending.forEach((Y) => {
    const { provider: U, prefix: G } = Y;
    if (G === F && U === T)
      return;
    T = U, F = G, C.push(jc(U, G));
    const q = w[U] || (w[U] = /* @__PURE__ */ Object.create(null));
    q[G] || (q[G] = []);
  }), v.pending.forEach((Y) => {
    const { provider: U, prefix: G, name: q } = Y, te = jc(U, G), se = te.pendingIcons || (te.pendingIcons = /* @__PURE__ */ new Set());
    se.has(q) || (se.add(q), w[U][G].push(q));
  }), C.forEach((Y) => {
    const { provider: U, prefix: G } = Y;
    w[U][G].length && LH(Y, w[U][G]);
  }), u ? yH(u, v, C) : YT;
};
function DH(s, u) {
  const h = {
    ...s
  };
  for (const v in u) {
    const w = u[v], C = typeof w;
    v in ER ? (w === null || w && (C === "string" || C === "number")) && (h[v] = w) : C === typeof h[v] && (h[v] = v === "rotate" ? w % 4 : w);
  }
  return h;
}
const OH = /[\s,]+/;
function _H(s, u) {
  u.split(OH).forEach((h) => {
    switch (h.trim()) {
      case "horizontal":
        s.hFlip = !0;
        break;
      case "vertical":
        s.vFlip = !0;
        break;
    }
  });
}
function PH(s, u = 0) {
  const h = s.replace(/^-?[0-9.]*/, "");
  function v(w) {
    for (; w < 0; )
      w += 4;
    return w % 4;
  }
  if (h === "") {
    const w = parseInt(s);
    return isNaN(w) ? 0 : v(w);
  } else if (h !== s) {
    let w = 0;
    switch (h) {
      case "%":
        w = 25;
        break;
      case "deg":
        w = 90;
    }
    if (w) {
      let C = parseFloat(s.slice(0, s.length - h.length));
      return isNaN(C) ? 0 : (C = C / w, C % 1 === 0 ? v(C) : 0);
    }
  }
  return u;
}
function NH(s, u) {
  let h = s.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const v in u)
    h += " " + v + '="' + u[v] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + h + ">" + s + "</svg>";
}
function zH(s) {
  return s.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function IH(s) {
  return "data:image/svg+xml," + zH(s);
}
function FH(s) {
  return 'url("' + IH(s) + '")';
}
let fg;
function YH() {
  try {
    fg = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (s) => s
    });
  } catch {
    fg = null;
  }
}
function HH(s) {
  return fg === void 0 && YH(), fg ? fg.createHTML(s) : s;
}
const IR = {
  ...RR,
  inline: !1
}, jH = {
  xmlns: "http://www.w3.org/2000/svg",
  xmlnsXlink: "http://www.w3.org/1999/xlink",
  "aria-hidden": !0,
  role: "img"
}, UH = {
  display: "inline-block"
}, R1 = {
  backgroundColor: "currentColor"
}, FR = {
  backgroundColor: "transparent"
}, HT = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
}, jT = {
  WebkitMask: R1,
  mask: R1,
  background: FR
};
for (const s in jT) {
  const u = jT[s];
  for (const h in HT)
    u[s + h] = HT[h];
}
const BH = {
  ...IR,
  inline: !0
};
function UT(s) {
  return s + (s.match(/^[-0-9.]+$/) ? "px" : "");
}
const WH = (s, u, h, v) => {
  const w = h ? BH : IR, C = DH(w, u), T = u.mode || "svg", F = {}, Y = u.style || {}, U = {
    ...T === "svg" ? jH : {},
    ref: v
  };
  for (let Ne in u) {
    const K = u[Ne];
    if (K !== void 0)
      switch (Ne) {
        case "icon":
        case "style":
        case "children":
        case "onLoad":
        case "mode":
        case "_ref":
        case "_inline":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          C[Ne] = K === !0 || K === "true" || K === 1;
          break;
        case "flip":
          typeof K == "string" && _H(C, K);
          break;
        case "color":
          F.color = K;
          break;
        case "rotate":
          typeof K == "string" ? C[Ne] = PH(K) : typeof K == "number" && (C[Ne] = K);
          break;
        case "ariaHidden":
        case "aria-hidden":
          K !== !0 && K !== "true" && delete U["aria-hidden"];
          break;
        default:
          w[Ne] === void 0 && (U[Ne] = K);
      }
  }
  const G = tH(s, C), q = G.attributes;
  if (C.inline && (F.verticalAlign = "-0.125em"), T === "svg") {
    U.style = {
      ...F,
      ...Y
    }, Object.assign(U, q);
    let Ne = 0, K = u.id;
    return typeof K == "string" && (K = K.replace(/-/g, "_")), U.dangerouslySetInnerHTML = {
      __html: HH(aH(G.body, K ? () => K + "ID" + Ne++ : "iconifyReact"))
    }, mi.createElement("svg", U);
  }
  const { body: te, width: se, height: ae } = s, ue = T === "mask" || (T === "bg" ? !1 : te.indexOf("currentColor") !== -1), Ce = NH(te, {
    ...q,
    width: se + "",
    height: ae + ""
  });
  return U.style = {
    ...F,
    "--svg": FH(Ce),
    width: UT(q.width),
    height: UT(q.height),
    ...UH,
    ...ue ? R1 : FR,
    ...Y
  }, mi.createElement("span", U);
};
TR(!0);
sH("", pH);
if (typeof document < "u" && typeof window < "u") {
  zR();
  const s = window;
  if (s.IconifyPreload !== void 0) {
    const u = s.IconifyPreload, h = "Invalid IconifyPreload syntax.";
    typeof u == "object" && u !== null && (u instanceof Array ? u : [u]).forEach((v) => {
      try {
        // Check if item is an object and not null/array
        (typeof v != "object" || v === null || v instanceof Array || // Check for 'icons' and 'prefix'
        typeof v.icons != "object" || typeof v.prefix != "string" || // Add icon set
        !QY(v)) && console.error(h);
      } catch {
        console.error(h);
      }
    });
  }
  if (s.IconifyProviders !== void 0) {
    const u = s.IconifyProviders;
    if (typeof u == "object" && u !== null)
      for (let h in u) {
        const v = "IconifyProviders[" + h + "] is invalid.";
        try {
          const w = u[h];
          if (typeof w != "object" || !w || w.resources === void 0)
            continue;
          oH(h, w) || console.error(v);
        } catch {
          console.error(v);
        }
      }
  }
}
class YR extends mi.Component {
  constructor(u) {
    super(u), this.state = {
      // Render placeholder before component is mounted
      icon: null
    };
  }
  /**
   * Abort loading icon
   */
  _abortLoading() {
    this._loading && (this._loading.abort(), this._loading = null);
  }
  /**
   * Update state
   */
  _setData(u) {
    this.state.icon !== u && this.setState({
      icon: u
    });
  }
  /**
   * Check if icon should be loaded
   */
  _checkIcon(u) {
    const h = this.state, v = this.props.icon;
    if (typeof v == "object" && v !== null && typeof v.body == "string") {
      this._icon = "", this._abortLoading(), (u || h.icon === null) && this._setData({
        data: v
      });
      return;
    }
    let w;
    if (typeof v != "string" || (w = lx(v, !1, !0)) === null) {
      this._abortLoading(), this._setData(null);
      return;
    }
    const C = qY(w);
    if (!C) {
      (!this._loading || this._loading.name !== v) && (this._abortLoading(), this._icon = "", this._setData(null), C !== null && (this._loading = {
        name: v,
        abort: MH([w], this._checkIcon.bind(this, !1))
      }));
      return;
    }
    if (this._icon !== v || h.icon === null) {
      this._abortLoading(), this._icon = v;
      const T = ["iconify"];
      w.prefix !== "" && T.push("iconify--" + w.prefix), w.provider !== "" && T.push("iconify--" + w.provider), this._setData({
        data: C,
        classes: T
      }), this.props.onLoad && this.props.onLoad(v);
    }
  }
  /**
   * Component mounted
   */
  componentDidMount() {
    this._checkIcon(!1);
  }
  /**
   * Component updated
   */
  componentDidUpdate(u) {
    u.icon !== this.props.icon && this._checkIcon(!0);
  }
  /**
   * Abort loading
   */
  componentWillUnmount() {
    this._abortLoading();
  }
  /**
   * Render
   */
  render() {
    const u = this.props, h = this.state.icon;
    if (h === null)
      return u.children ? u.children : mi.createElement("span", {});
    let v = u;
    return h.classes && (v = {
      ...u,
      className: (typeof u.className == "string" ? u.className + " " : "") + h.classes.join(" ")
    }), WH({
      ...oS,
      ...h.data
    }, v, u._inline, u._ref);
  }
}
const XH = mi.forwardRef(function(u, h) {
  const v = {
    ...u,
    _ref: h,
    _inline: !1
  };
  return mi.createElement(YR, v);
});
mi.forwardRef(function(u, h) {
  const v = {
    ...u,
    _ref: h,
    _inline: !0
  };
  return mi.createElement(YR, v);
});
const BT = (s) => {
  let u;
  const h = /* @__PURE__ */ new Set(), v = (Y, U) => {
    const G = typeof Y == "function" ? Y(u) : Y;
    if (!Object.is(G, u)) {
      const q = u;
      u = U ?? typeof G != "object" ? G : Object.assign({}, u, G), h.forEach((te) => te(u, q));
    }
  }, w = () => u, F = { setState: v, getState: w, subscribe: (Y) => (h.add(Y), () => h.delete(Y)), destroy: () => {
    h.clear();
  } };
  return u = s(v, w, F), F;
}, VH = (s) => s ? BT(s) : BT;
var L1 = { exports: {} }, Zw = {}, Cy = { exports: {} }, Qw = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WT;
function GH() {
  if (WT)
    return Qw;
  WT = 1;
  var s = mi;
  function u(q, te) {
    return q === te && (q !== 0 || 1 / q === 1 / te) || q !== q && te !== te;
  }
  var h = typeof Object.is == "function" ? Object.is : u, v = s.useState, w = s.useEffect, C = s.useLayoutEffect, T = s.useDebugValue;
  function F(q, te) {
    var se = te(), ae = v({ inst: { value: se, getSnapshot: te } }), ue = ae[0].inst, Ce = ae[1];
    return C(function() {
      ue.value = se, ue.getSnapshot = te, Y(ue) && Ce({ inst: ue });
    }, [q, se, te]), w(function() {
      return Y(ue) && Ce({ inst: ue }), q(function() {
        Y(ue) && Ce({ inst: ue });
      });
    }, [q]), T(se), se;
  }
  function Y(q) {
    var te = q.getSnapshot;
    q = q.value;
    try {
      var se = te();
      return !h(q, se);
    } catch {
      return !0;
    }
  }
  function U(q, te) {
    return te();
  }
  var G = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? U : F;
  return Qw.useSyncExternalStore = s.useSyncExternalStore !== void 0 ? s.useSyncExternalStore : G, Qw;
}
var Kw = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XT;
function $H() {
  return XT || (XT = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var s = mi, u = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function h(we) {
      {
        for (var Re = arguments.length, re = new Array(Re > 1 ? Re - 1 : 0), ve = 1; ve < Re; ve++)
          re[ve - 1] = arguments[ve];
        v("error", we, re);
      }
    }
    function v(we, Re, re) {
      {
        var ve = u.ReactDebugCurrentFrame, Me = ve.getStackAddendum();
        Me !== "" && (Re += "%s", re = re.concat([Me]));
        var et = re.map(function(je) {
          return String(je);
        });
        et.unshift("Warning: " + Re), Function.prototype.apply.call(console[we], console, et);
      }
    }
    function w(we, Re) {
      return we === Re && (we !== 0 || 1 / we === 1 / Re) || we !== we && Re !== Re;
    }
    var C = typeof Object.is == "function" ? Object.is : w, T = s.useState, F = s.useEffect, Y = s.useLayoutEffect, U = s.useDebugValue, G = !1, q = !1;
    function te(we, Re, re) {
      G || s.startTransition !== void 0 && (G = !0, h("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var ve = Re();
      if (!q) {
        var Me = Re();
        C(ve, Me) || (h("The result of getSnapshot should be cached to avoid an infinite loop"), q = !0);
      }
      var et = T({
        inst: {
          value: ve,
          getSnapshot: Re
        }
      }), je = et[0].inst, Ve = et[1];
      return Y(function() {
        je.value = ve, je.getSnapshot = Re, se(je) && Ve({
          inst: je
        });
      }, [we, ve, Re]), F(function() {
        se(je) && Ve({
          inst: je
        });
        var it = function() {
          se(je) && Ve({
            inst: je
          });
        };
        return we(it);
      }, [we]), U(ve), ve;
    }
    function se(we) {
      var Re = we.getSnapshot, re = we.value;
      try {
        var ve = Re();
        return !C(re, ve);
      } catch {
        return !0;
      }
    }
    function ae(we, Re, re) {
      return Re();
    }
    var ue = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Ce = !ue, Ne = Ce ? ae : te, K = s.useSyncExternalStore !== void 0 ? s.useSyncExternalStore : Ne;
    Kw.useSyncExternalStore = K, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Kw;
}
var VT;
function HR() {
  return VT || (VT = 1, process.env.NODE_ENV === "production" ? Cy.exports = GH() : Cy.exports = $H()), Cy.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var GT;
function qH() {
  if (GT)
    return Zw;
  GT = 1;
  var s = mi, u = HR();
  function h(U, G) {
    return U === G && (U !== 0 || 1 / U === 1 / G) || U !== U && G !== G;
  }
  var v = typeof Object.is == "function" ? Object.is : h, w = u.useSyncExternalStore, C = s.useRef, T = s.useEffect, F = s.useMemo, Y = s.useDebugValue;
  return Zw.useSyncExternalStoreWithSelector = function(U, G, q, te, se) {
    var ae = C(null);
    if (ae.current === null) {
      var ue = { hasValue: !1, value: null };
      ae.current = ue;
    } else
      ue = ae.current;
    ae = F(function() {
      function Ne(ve) {
        if (!K) {
          if (K = !0, we = ve, ve = te(ve), se !== void 0 && ue.hasValue) {
            var Me = ue.value;
            if (se(Me, ve))
              return Re = Me;
          }
          return Re = ve;
        }
        if (Me = Re, v(we, ve))
          return Me;
        var et = te(ve);
        return se !== void 0 && se(Me, et) ? Me : (we = ve, Re = et);
      }
      var K = !1, we, Re, re = q === void 0 ? null : q;
      return [function() {
        return Ne(G());
      }, re === null ? void 0 : function() {
        return Ne(re());
      }];
    }, [G, q, te, se]);
    var Ce = w(U, ae[0], ae[1]);
    return T(function() {
      ue.hasValue = !0, ue.value = Ce;
    }, [Ce]), Y(Ce), Ce;
  }, Zw;
}
var Jw = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $T;
function ZH() {
  return $T || ($T = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var s = mi, u = HR();
    function h(G, q) {
      return G === q && (G !== 0 || 1 / G === 1 / q) || G !== G && q !== q;
    }
    var v = typeof Object.is == "function" ? Object.is : h, w = u.useSyncExternalStore, C = s.useRef, T = s.useEffect, F = s.useMemo, Y = s.useDebugValue;
    function U(G, q, te, se, ae) {
      var ue = C(null), Ce;
      ue.current === null ? (Ce = {
        hasValue: !1,
        value: null
      }, ue.current = Ce) : Ce = ue.current;
      var Ne = F(function() {
        var re = !1, ve, Me, et = function(dt) {
          if (!re) {
            re = !0, ve = dt;
            var Ke = se(dt);
            if (ae !== void 0 && Ce.hasValue) {
              var Ze = Ce.value;
              if (ae(Ze, Ke))
                return Me = Ze, Ze;
            }
            return Me = Ke, Ke;
          }
          var Vt = ve, Et = Me;
          if (v(Vt, dt))
            return Et;
          var an = se(dt);
          return ae !== void 0 && ae(Et, an) ? Et : (ve = dt, Me = an, an);
        }, je = te === void 0 ? null : te, Ve = function() {
          return et(q());
        }, it = je === null ? void 0 : function() {
          return et(je());
        };
        return [Ve, it];
      }, [q, te, se, ae]), K = Ne[0], we = Ne[1], Re = w(G, K, we);
      return T(function() {
        Ce.hasValue = !0, Ce.value = Re;
      }, [Re]), Y(Re), Re;
    }
    Jw.useSyncExternalStoreWithSelector = U, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Jw;
}
process.env.NODE_ENV === "production" ? L1.exports = qH() : L1.exports = ZH();
var QH = L1.exports;
const KH = /* @__PURE__ */ I_(QH), { useSyncExternalStoreWithSelector: JH } = KH;
function ej(s, u = s.getState, h) {
  const v = JH(
    s.subscribe,
    s.getState,
    s.getServerState || s.getState,
    u,
    h
  );
  return z_(v), v;
}
const qT = (s) => {
  const u = typeof s == "function" ? VH(s) : s, h = (v, w) => ej(u, v, w);
  return Object.assign(h, u), h;
}, jR = (s) => s ? qT(s) : qT, UR = (s, u) => (...h) => Object.assign({}, s, u(...h)), BR = jR(
  UR(
    {
      currentOpen: []
    },
    (s, u) => ({
      openModal: (h) => {
        if (u().currentOpen.includes(h))
          return;
        const v = [...u().currentOpen, h];
        console.log("Updated openModal: ", v), s({ currentOpen: v });
      },
      closeModal: () => {
        const h = document.querySelector("#modal-root");
        h && (h.classList.add("closed"), setTimeout(() => {
          h.classList.remove("closed");
          const v = u().currentOpen.slice(
            0,
            u().currentOpen.length - 1
          );
          console.log("Updated openModal: ", v), s({ currentOpen: v });
        }, 190));
      },
      closeAllModals: () => {
        const h = document.querySelector("#modal-root");
        h && (h.classList.add("closed"), setTimeout(() => {
          h.classList.remove("closed"), s({ currentOpen: [] });
        }, 190));
      }
    })
  )
), tj = ({
  children: s,
  currentName: u,
  variant: h = "neutral",
  size: v = "normal",
  closeButton: w = !1,
  onClose: C = () => {
  }
}) => {
  const { currentOpen: T, closeModal: F } = BR(), Y = document.querySelector("#modal-root"), U = gr(null);
  return Hf(() => {
    var G;
    T.length > 0 && U.current && (U.current.focus(), Y.classList.add("shown")), (T.length === 0 || ((G = U.current) == null ? void 0 : G.childNodes.length) === 0) && Y.classList.remove("shown");
  }, [T, Y]), T.includes(u) && Y ? UY.createPortal(
    /* @__PURE__ */ de.jsxs(
      "div",
      {
        tabIndex: 0,
        ref: U,
        onKeyDown: (G) => {
          G.key === "Escape" && (C(), F());
        },
        className: "modal",
        children: [
          /* @__PURE__ */ de.jsx(
            "div",
            {
              className: "modal-overlay",
              onClick: () => {
                C(), F();
              }
            }
          ),
          /* @__PURE__ */ de.jsxs(
            "div",
            {
              className: `modal-body container rounded-box bg-${h} ${v}`,
              children: [
                w && /* @__PURE__ */ de.jsx(
                  "button",
                  {
                    type: "button",
                    className: "close-btn",
                    onClick: () => {
                      C(), F();
                    },
                    children: /* @__PURE__ */ de.jsx(XH, { icon: "mingcute:close-fill", height: 16 })
                  }
                ),
                s
              ]
            }
          )
        ]
      }
    ),
    Y
  ) : null;
}, nj = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100], rj = ({
  children: s,
  data: u,
  itemsPerPage: h = 30
}) => {
  const v = Du(() => u.length, [u]), [w, C] = dr(1), [T, F] = dr(h), Y = Du(() => u.slice(
    (w - 1) * T,
    w * T
  ), [u, w, T]);
  return /* @__PURE__ */ de.jsxs(de.Fragment, { children: [
    /* @__PURE__ */ de.jsx("div", { className: "table-content custom-scroll", children: s({ data: Y() }) }),
    /* @__PURE__ */ de.jsxs("footer", { className: "table-footer", children: [
      /* @__PURE__ */ de.jsx(
        "button",
        {
          className: "btn btn-icon btn-square btn-sm ring-info",
          title: "First Page",
          disabled: w === 1,
          onClick: () => C(1),
          children: /* @__PURE__ */ de.jsx(vi, { hFlip: !0, icon: "ic:round-fast-forward" })
        }
      ),
      /* @__PURE__ */ de.jsx(
        "button",
        {
          className: "btn btn-icon btn-square btn-sm ring-info",
          title: "Previous Page",
          disabled: w === 1,
          onClick: () => C((U) => U - 1),
          children: /* @__PURE__ */ de.jsx(vi, { hFlip: !0, icon: "ic:round-skip-next" })
        }
      ),
      /* @__PURE__ */ de.jsxs("span", { children: [
        kr("table.page"),
        " ",
        /* @__PURE__ */ de.jsx("span", { className: "page", children: w }),
        " ",
        kr("table.of"),
        " ",
        /* @__PURE__ */ de.jsx("span", { className: "page", children: Math.ceil(v() / T) })
      ] }),
      /* @__PURE__ */ de.jsx(
        Yy,
        {
          items: nj,
          currentSelected: h,
          labelExtractor: (U) => `${kr("table.per-page")} ${U}`,
          keyExtractor: (U) => U,
          showQty: 3,
          position: "bottom",
          onChange: (U, G) => {
            const q = Math.ceil(v() / G), te = w * T, ae = (w > q ? q * G : w * G) / te, ue = ae !== 1 ? Math.floor(w / ae) : w;
            w > q ? C(q) : C(ue < 1 ? 1 : ue), F(G);
          }
        }
      ),
      /* @__PURE__ */ de.jsx(
        "button",
        {
          className: "btn btn-icon btn-square btn-sm ring-info",
          title: "Next Page",
          disabled: Math.ceil(v() / T) === w,
          onClick: () => C((U) => U + 1),
          children: /* @__PURE__ */ de.jsx(vi, { icon: "ic:round-skip-next" })
        }
      ),
      /* @__PURE__ */ de.jsx(
        "button",
        {
          className: "btn btn-icon btn-square btn-sm ring-info",
          disabled: Math.ceil(v() / T) === w,
          onClick: () => C(Math.ceil(v() / T)),
          title: "Last Page",
          children: /* @__PURE__ */ de.jsx(vi, { icon: "ic:round-fast-forward" })
        }
      ),
      /* @__PURE__ */ de.jsxs("span", { children: [
        v(),
        " ",
        kr("table.items")
      ] })
    ] })
  ] });
}, ij = (s) => {
  const [u, h] = dr(s ?? null), [v, w] = dr({
    top: (u == null ? void 0 : u.scrollTop) ?? 0,
    scrollHeight: (u == null ? void 0 : u.scrollHeight) ?? 0,
    height: (u == null ? void 0 : u.clientHeight) ?? 0
  });
  return Hf(() => {
    const C = () => {
      u && w({
        top: u.scrollTop,
        scrollHeight: u.scrollHeight,
        height: u.clientHeight
      });
    };
    if (u)
      return u == null || u.addEventListener("scroll", H1(C, 150)), () => {
        u == null || u.removeEventListener("scroll", C);
      };
  }, [u]), u ? { ...v, scrollTo: u.scrollTo, root: u, setRoot: h, changeScrollData: w } : {
    top: 0,
    scrollHeight: 0,
    height: 0,
    scrollTo: () => {
    },
    root: u,
    setRoot: h,
    changeScrollData: w
  };
}, aj = ({
  children: s,
  data: u,
  tableContainerRef: h
}) => {
  const { height: v, scrollHeight: w, top: C, root: T, setRoot: F, changeScrollData: Y } = ij(h == null ? void 0 : h.current), U = gr(0), G = gr(U.current * 2), q = 40, te = Du(() => h.current === null ? 10 : Math.ceil(h.current.clientHeight / q), [h]);
  Hf(() => (T === null && F(h.current), U.current = te(), () => {
  }), [te, h, T, F, Y]);
  const se = Du(() => {
    let ae = 0;
    return T === null ? [] : (U.current < 10 && (U.current = te() * 2), Math.ceil(v + C) === w && (G.current += U.current, T.scrollTo({
      top: U.current * q
    })), G.current > U.current * 3 && C > 0 && (ae = G.current - U.current * 3), C === 0 && G.current > U.current * 3 && (G.current -= U.current, ae = G.current - U.current * 3, T.scrollTo({
      top: U.current * q
    })), u.slice(ae, G.current));
  }, [u, v, te, w, C, T, U]);
  return s({ data: se() });
}, sj = {
  scroll: aj,
  pagination: rj
}, oj = ({
  mode: s,
  children: u,
  data: h
}) => {
  const v = gr(null), w = sj[s];
  return /* @__PURE__ */ de.jsx("div", { className: `table-container ${s}`, ref: v, children: /* @__PURE__ */ de.jsx(w, { tableContainerRef: v, data: h, children: u }) });
}, ZT = [
  "info",
  "info-hover",
  "danger",
  "danger-hover",
  "warning",
  "warning-hover",
  "primary",
  "primary-hover",
  "secondary",
  "secondary-hover"
], lj = [
  "none",
  "above",
  "aboveOrEqual",
  "less",
  "lessOrEqual",
  "equal",
  "different"
], QT = lj.map((s) => ({ type: s })), uj = ({
  closeModal: s,
  config: u,
  updateConfig: h,
  hidden: v,
  translation: w
}) => {
  const [C, T] = dr(u), F = (Y, U) => {
    T((G) => ({
      ...G,
      [Y]: {
        ...G[Y],
        ...U
      }
    }));
  };
  return /* @__PURE__ */ de.jsxs(tj, { currentName: "table-config-modal", children: [
    Object.keys(C).map((Y, U) => {
      if (v.includes(Y))
        return null;
      const G = QT.findIndex(
        (te) => te.type === u[Y].condition
      ), q = ZT.findIndex(
        (te) => te === C[Y].color
      );
      return /* @__PURE__ */ de.jsxs(
        "div",
        {
          className: "container row row-selectable between-center" + (C[Y].enabled ? "" : " row-disabled"),
          children: [
            /* @__PURE__ */ de.jsxs("div", { className: "container row", style: { alignItems: "center" }, children: [
              /* @__PURE__ */ de.jsx(
                "input",
                {
                  type: "checkbox",
                  name: Y,
                  id: Y,
                  className: "checkbox checkbox-base-200",
                  onChange: () => F(Y, {
                    enabled: !C[Y].enabled
                  })
                }
              ),
              /* @__PURE__ */ de.jsx("label", { htmlFor: Y, children: kr(
                `data.${w}.${Y}`
              ) })
            ] }),
            /* @__PURE__ */ de.jsx(
              Yy,
              {
                selected: G,
                selector: "type",
                style: { width: "20ch" },
                variant: "neutral",
                items: QT,
                disabled: !C[Y].enabled
              }
            ),
            /* @__PURE__ */ de.jsx(
              "input",
              {
                type: "number",
                className: "input input-base-200",
                style: { color: "var(--text-content)" },
                placeholder: "Ex:. 200"
              }
            ),
            /* @__PURE__ */ de.jsx(
              Yy,
              {
                selected: q,
                style: { width: "20ch" },
                variant: "neutral",
                items: ZT,
                keyExtractor: (te) => /* @__PURE__ */ de.jsx(
                  "span",
                  {
                    style: {
                      position: "absolute",
                      width: "100%",
                      height: "100%",
                      top: 0,
                      left: 0,
                      backgroundColor: `var(--${te})`
                    }
                  }
                ),
                disabled: !C[Y].enabled
              }
            )
          ]
        },
        U
      );
    }),
    /* @__PURE__ */ de.jsx(
      "button",
      {
        className: "btn btn-primary ring-info",
        onClick: () => {
          h(C), s();
        },
        children: kr("common.save")
      }
    )
  ] });
}, cj = ({
  index: s,
  lastIndex: u,
  translation: h,
  column: v,
  ordersType: w,
  orderedHeader: C,
  order: T,
  setOrder: F,
  tBodyRef: Y,
  mousePosition: U
}) => /* @__PURE__ */ de.jsx("th", { children: /* @__PURE__ */ de.jsxs("div", { className: "table-column", children: [
  /* @__PURE__ */ de.jsx("span", { children: kr(
    `data.${h}.${v}`
  ) }),
  /* @__PURE__ */ de.jsxs("div", { className: "group-vertical rounded-box no-print", children: [
    /* @__PURE__ */ de.jsx(
      "button",
      {
        className: `btn btn-square btn-xs ${w[T] === "asc" && C.current === v ? "active" : ""}`,
        onClick: () => {
          F(
            (G) => G === 1 && C.current === v ? 0 : 1
          ), C.current = v;
        },
        children: /* @__PURE__ */ de.jsx(vi, { icon: "eva:arrow-up-fill" })
      }
    ),
    /* @__PURE__ */ de.jsx(
      "button",
      {
        className: `btn btn-square btn-xs ${w[T] === "desc" && C.current === v ? "active" : ""}`,
        onClick: () => {
          F(
            (G) => G === 2 && C.current === v ? 0 : 2
          ), C.current = v;
        },
        children: /* @__PURE__ */ de.jsx(vi, { icon: "eva:arrow-down-fill" })
      }
    )
  ] }),
  !u && /* @__PURE__ */ de.jsxs(
    "button",
    {
      className: "handler",
      title: "Resize Column",
      onMouseDown: (G) => {
        U.current.startPosition = G.clientX;
      },
      onMouseMove: (G) => {
        var ae;
        if (Y.current === null || U.current.startPosition === 0)
          return;
        U.current.currentPosition = G.clientX;
        const q = (ae = Y.current.firstChild) == null ? void 0 : ae.childNodes[s];
        if (q === null)
          return;
        const te = q.getBoundingClientRect().width, se = U.current.currentPosition - U.current.startPosition;
        q.style.width = `${te + se}px`, U.current.startPosition = U.current.currentPosition;
      },
      onMouseUp: () => {
        U.current = {
          startPosition: 0,
          currentPosition: 0,
          endPosition: 0
        };
      },
      onMouseLeave: () => {
        U.current = {
          startPosition: 0,
          currentPosition: 0,
          endPosition: 0
        };
      },
      onClick: (G) => {
        var te;
        if (G.detail < 2 || Y.current === null)
          return;
        const q = (te = Y.current.firstChild) == null ? void 0 : te.childNodes[s];
        q !== null && (q.style.width = "auto");
      },
      children: [
        /* @__PURE__ */ de.jsx("span", {}),
        /* @__PURE__ */ de.jsx("span", {})
      ]
    }
  )
] }) }), dj = (s, u, h = "asc") => {
  if (h === "default" || u === null)
    return s;
  const v = h === "asc" ? 1 : -1;
  return s.slice().sort((w, C) => {
    const T = w[u], F = C[u];
    return T < F ? -1 * v : T > F ? 1 * v : 0;
  });
}, fj = (s, u) => {
  const h = {};
  return s.length === 0 || (console.log("Current items: ", s, u), Object.keys(s[0]).forEach((v) => {
    u.includes(v) || (h[v] = {
      enabled: !1,
      color: "info",
      value: 0,
      condition: "none"
    });
  })), h;
}, KT = ["default", "asc", "desc"], qj = ({
  headers: s,
  data: u,
  dataConfig: h,
  tableConfig: v,
  showObject: w,
  noWrap: C = !0,
  // headersConfig,
  translation: T = "workgroups",
  action: F,
  loading: Y = !1,
  hideColumn: U = [],
  mode: G = "pagination"
}) => {
  const { closeModal: q, openModal: te } = BR(), [se] = dr(G), [ae, ue] = dr(0), Ce = gr(null), Ne = gr(null), K = gr({
    startPosition: 0,
    currentPosition: 0,
    endPosition: 0
  }), [we, Re] = dr(v ?? fj(u, U)), [re, ve] = dr(""), Me = Du(() => Y ? [] : u.filter((je) => {
    if (re.trim() === "")
      return u;
    const Ve = re.toLowerCase().trim();
    return Object.entries(je).some(([dt, Ke]) => {
      var Ze;
      return U.includes(dt) ? !1 : typeof Ke == "object" && Object.hasOwnProperty.call(h, dt) ? String(
        (Ze = h == null ? void 0 : h[dt]) == null ? void 0 : Ze.call(h, Ke, je)
      ).toLowerCase().includes(Ve) : typeof Ke == "object" ? String(Object.values(Ke)[0]).toLowerCase().includes(Ve) : String(Ke).toLowerCase().includes(Ve);
    });
  }), [re, U, u, h, Y]), et = Du(() => dj(Me(), Ce.current, KT[ae]), [ae, Me, Ce]);
  return /* @__PURE__ */ de.jsxs("div", { className: "table-full", children: [
    /* @__PURE__ */ de.jsxs("div", { className: "group rounded-box no-print", children: [
      /* @__PURE__ */ de.jsx("label", { className: "bg-primary", htmlFor: "find-all-table", children: kr("common.search") }),
      /* @__PURE__ */ de.jsx(
        "input",
        {
          className: "input input-neutral ring-info",
          id: "find-all-table",
          placeholder: "Filtrar por....",
          style: { flex: "1" },
          onChange: H1((je) => {
            ve(je.target.value);
          }, 300)
        }
      ),
      /* @__PURE__ */ de.jsx(
        "button",
        {
          className: "btn btn-primary btn-icon",
          style: { flex: "0" },
          onClick: () => te("table-config-modal"),
          children: /* @__PURE__ */ de.jsx(vi, { icon: "mdi:gear" })
        }
      )
    ] }),
    /* @__PURE__ */ de.jsx(oj, { mode: se, data: et(), children: ({ data: je }) => {
      let Ve = 0;
      return /* @__PURE__ */ de.jsxs("table", { className: "table", children: [
        /* @__PURE__ */ de.jsx("thead", { className: C ? "no-wrap" : "", children: /* @__PURE__ */ de.jsxs("tr", { children: [
          s && s.map((it, dt) => U.includes(it) ? null : (dt++, /* @__PURE__ */ de.jsx("th", { children: it }, dt))),
          s === void 0 && je.length > 0 && Object.keys(je[0]).map((it, dt) => U.includes(it) ? null : (Ve++, /* @__PURE__ */ de.jsx(
            cj,
            {
              tBodyRef: Ne,
              mousePosition: K,
              lastIndex: Object.keys(je[0]).length - 1 === dt,
              orderedHeader: Ce,
              order: ae,
              setOrder: ue,
              column: it,
              index: Ve - 1,
              ordersType: KT,
              translation: T
            },
            Ve - 1
          ))),
          Y && /* @__PURE__ */ de.jsx("th", {}),
          F && /* @__PURE__ */ de.jsx("th", { children: kr("common.action") })
        ] }) }),
        /* @__PURE__ */ de.jsxs("tbody", { ref: Ne, children: [
          Y && /* @__PURE__ */ de.jsxs(
            "span",
            {
              className: "subtitle",
              style: {
                margin: "auto",
                marginTop: "1rem",
                width: "fit-content"
              },
              children: [
                kr("common.loading"),
                "..."
              ]
            }
          ),
          !Y && je.map((it, dt) => /* @__PURE__ */ de.jsxs("tr", { tabIndex: 0, children: [
            Object.entries(it).map(([Ke, Ze], Vt) => {
              var an;
              let Et;
              return U.includes(Ke) ? null : (typeof Ze == "object" && (h == null ? void 0 : h[Ke]) === void 0 ? Et = Object.values(Ze)[0] : Object.hasOwnProperty.call(h ?? {}, Ke) ? Et = (an = h == null ? void 0 : h[Ke]) == null ? void 0 : an.call(
                h,
                Ze,
                it
              ) : Et = Ze, /* @__PURE__ */ de.jsx(
                "td",
                {
                  title: "Click to copy",
                  style: { width: "auto" },
                  children: typeof Ze != "object" || !(w != null && w[Ke]) ? Et : /* @__PURE__ */ de.jsx("div", { className: "cell-container", children: /* @__PURE__ */ de.jsxs("div", { className: "cell-container--header", children: [
                    Et,
                    /* @__PURE__ */ de.jsx(
                      "button",
                      {
                        className: "btn btn-primary btn-icon btn-xs btn-square",
                        onClick: (We) => {
                          var Ue;
                          const ft = (Ue = We.currentTarget.parentNode) == null ? void 0 : Ue.parentNode;
                          if (ft === null)
                            return;
                          if (ft.lastChild.className === "content") {
                            ft.removeChild(
                              ft.lastChild
                            );
                            return;
                          }
                          const ye = document.createElement("ul");
                          ye.className = "content", Object.entries(Ze).forEach(
                            ([Qe, St]) => {
                              const kt = document.createElement("li");
                              kt.innerText = `${kr(
                                `data.${T}.${Qe}`
                              )}: ${St}`, ye.appendChild(kt);
                            }
                          ), ft.appendChild(
                            ye
                          );
                        },
                        children: /* @__PURE__ */ de.jsx(vi, { icon: "eva:arrow-down-fill" })
                      }
                    )
                  ] }) })
                },
                Vt
              ));
            }),
            F && F(it, dt)
          ] }, dt))
        ] })
      ] });
    } }),
    !Y && u.length > 0 && /* @__PURE__ */ de.jsx(
      uj,
      {
        translation: T,
        config: we,
        updateConfig: Re,
        closeModal: q,
        hidden: U
      }
    )
  ] });
}, hj = {
  small: "4rem",
  medium: "6rem",
  large: "8rem"
}, Zj = jR(
  UR(
    {
      currentOpen: []
    },
    () => ({
      dispatch: (s) => {
        const u = document.querySelector("#toast-root"), h = document.createElement("div");
        h.className = "toast";
        const v = document.createElement("div");
        v.className = `toast-body shadow-md container rounded-box bg-${(s == null ? void 0 : s.variant) ?? "neutral"}`, h.append(v), h.style.setProperty(
          "--toast-size",
          `${hj[(s == null ? void 0 : s.size) ?? "small"]}`
        );
        const w = document.createElement("span");
        w.innerText = s.message;
        const C = document.createElement("button");
        C.className = "close-btn", C.innerText = "x", C.addEventListener("click", () => {
          h.classList.add("closed"), setTimeout(() => {
            h.remove();
          }, 200);
        });
        const T = document.createElement("div");
        T.className = "fill-bar", T.style.setProperty(
          "--fill-color",
          `var(--${(s == null ? void 0 : s.type) ?? "info"})`
        ), setTimeout(() => {
          h.classList.add("closed");
        }, 2.8 * 1e3), setTimeout(() => {
          h.remove();
        }, 3 * 1e3), v.append(w, C, T), u == null || u.appendChild(h);
      }
    })
  )
), Qj = fE, Kj = cP;
var WR = {}, M1 = { exports: {} };
/*!
 * ApexCharts v3.42.0
 * (c) 2018-2023 ApexCharts
 * Released under the MIT License.
 */
(function(s, u) {
  function h(B, t) {
    var n = Object.keys(B);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(B);
      t && (i = i.filter(function(o) {
        return Object.getOwnPropertyDescriptor(B, o).enumerable;
      })), n.push.apply(n, i);
    }
    return n;
  }
  function v(B) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t] != null ? arguments[t] : {};
      t % 2 ? h(Object(n), !0).forEach(function(i) {
        Y(B, i, n[i]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(B, Object.getOwnPropertyDescriptors(n)) : h(Object(n)).forEach(function(i) {
        Object.defineProperty(B, i, Object.getOwnPropertyDescriptor(n, i));
      });
    }
    return B;
  }
  function w(B) {
    return w = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t;
    } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, w(B);
  }
  function C(B, t) {
    if (!(B instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  function T(B, t) {
    for (var n = 0; n < t.length; n++) {
      var i = t[n];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(B, i.key, i);
    }
  }
  function F(B, t, n) {
    return t && T(B.prototype, t), n && T(B, n), B;
  }
  function Y(B, t, n) {
    return t in B ? Object.defineProperty(B, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : B[t] = n, B;
  }
  function U(B, t) {
    if (typeof t != "function" && t !== null)
      throw new TypeError("Super expression must either be null or a function");
    B.prototype = Object.create(t && t.prototype, { constructor: { value: B, writable: !0, configurable: !0 } }), t && q(B, t);
  }
  function G(B) {
    return G = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, G(B);
  }
  function q(B, t) {
    return q = Object.setPrototypeOf || function(n, i) {
      return n.__proto__ = i, n;
    }, q(B, t);
  }
  function te(B, t) {
    if (t && (typeof t == "object" || typeof t == "function"))
      return t;
    if (t !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return function(n) {
      if (n === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return n;
    }(B);
  }
  function se(B) {
    var t = function() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
      if (typeof Proxy == "function")
        return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }();
    return function() {
      var n, i = G(B);
      if (t) {
        var o = G(this).constructor;
        n = Reflect.construct(i, arguments, o);
      } else
        n = i.apply(this, arguments);
      return te(this, n);
    };
  }
  function ae(B, t) {
    return function(n) {
      if (Array.isArray(n))
        return n;
    }(B) || function(n, i) {
      var o = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
      if (o != null) {
        var d, f, p = [], y = !0, S = !1;
        try {
          for (o = o.call(n); !(y = (d = o.next()).done) && (p.push(d.value), !i || p.length !== i); y = !0)
            ;
        } catch (A) {
          S = !0, f = A;
        } finally {
          try {
            y || o.return == null || o.return();
          } finally {
            if (S)
              throw f;
          }
        }
        return p;
      }
    }(B, t) || Ce(B, t) || function() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }();
  }
  function ue(B) {
    return function(t) {
      if (Array.isArray(t))
        return Ne(t);
    }(B) || function(t) {
      if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
        return Array.from(t);
    }(B) || Ce(B) || function() {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }();
  }
  function Ce(B, t) {
    if (B) {
      if (typeof B == "string")
        return Ne(B, t);
      var n = Object.prototype.toString.call(B).slice(8, -1);
      return n === "Object" && B.constructor && (n = B.constructor.name), n === "Map" || n === "Set" ? Array.from(B) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Ne(B, t) : void 0;
    }
  }
  function Ne(B, t) {
    (t == null || t > B.length) && (t = B.length);
    for (var n = 0, i = new Array(t); n < t; n++)
      i[n] = B[n];
    return i;
  }
  var K = function() {
    function B() {
      C(this, B);
    }
    return F(B, [{ key: "shadeRGBColor", value: function(t, n) {
      var i = n.split(","), o = t < 0 ? 0 : 255, d = t < 0 ? -1 * t : t, f = parseInt(i[0].slice(4), 10), p = parseInt(i[1], 10), y = parseInt(i[2], 10);
      return "rgb(" + (Math.round((o - f) * d) + f) + "," + (Math.round((o - p) * d) + p) + "," + (Math.round((o - y) * d) + y) + ")";
    } }, { key: "shadeHexColor", value: function(t, n) {
      var i = parseInt(n.slice(1), 16), o = t < 0 ? 0 : 255, d = t < 0 ? -1 * t : t, f = i >> 16, p = i >> 8 & 255, y = 255 & i;
      return "#" + (16777216 + 65536 * (Math.round((o - f) * d) + f) + 256 * (Math.round((o - p) * d) + p) + (Math.round((o - y) * d) + y)).toString(16).slice(1);
    } }, { key: "shadeColor", value: function(t, n) {
      return B.isColorHex(n) ? this.shadeHexColor(t, n) : this.shadeRGBColor(t, n);
    } }], [{ key: "bind", value: function(t, n) {
      return function() {
        return t.apply(n, arguments);
      };
    } }, { key: "isObject", value: function(t) {
      return t && w(t) === "object" && !Array.isArray(t) && t != null;
    } }, { key: "is", value: function(t, n) {
      return Object.prototype.toString.call(n) === "[object " + t + "]";
    } }, { key: "listToArray", value: function(t) {
      var n, i = [];
      for (n = 0; n < t.length; n++)
        i[n] = t[n];
      return i;
    } }, { key: "extend", value: function(t, n) {
      var i = this;
      typeof Object.assign != "function" && (Object.assign = function(d) {
        if (d == null)
          throw new TypeError("Cannot convert undefined or null to object");
        for (var f = Object(d), p = 1; p < arguments.length; p++) {
          var y = arguments[p];
          if (y != null)
            for (var S in y)
              y.hasOwnProperty(S) && (f[S] = y[S]);
        }
        return f;
      });
      var o = Object.assign({}, t);
      return this.isObject(t) && this.isObject(n) && Object.keys(n).forEach(function(d) {
        i.isObject(n[d]) && d in t ? o[d] = i.extend(t[d], n[d]) : Object.assign(o, Y({}, d, n[d]));
      }), o;
    } }, { key: "extendArray", value: function(t, n) {
      var i = [];
      return t.map(function(o) {
        i.push(B.extend(n, o));
      }), t = i;
    } }, { key: "monthMod", value: function(t) {
      return t % 12;
    } }, { key: "clone", value: function(t) {
      if (B.is("Array", t)) {
        for (var n = [], i = 0; i < t.length; i++)
          n[i] = this.clone(t[i]);
        return n;
      }
      if (B.is("Null", t))
        return null;
      if (B.is("Date", t))
        return t;
      if (w(t) === "object") {
        var o = {};
        for (var d in t)
          t.hasOwnProperty(d) && (o[d] = this.clone(t[d]));
        return o;
      }
      return t;
    } }, { key: "log10", value: function(t) {
      return Math.log(t) / Math.LN10;
    } }, { key: "roundToBase10", value: function(t) {
      return Math.pow(10, Math.floor(Math.log10(t)));
    } }, { key: "roundToBase", value: function(t, n) {
      return Math.pow(n, Math.floor(Math.log(t) / Math.log(n)));
    } }, { key: "parseNumber", value: function(t) {
      return t === null ? t : parseFloat(t);
    } }, { key: "stripNumber", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
      return parseFloat(t.toPrecision(n));
    } }, { key: "randomId", value: function() {
      return (Math.random() + 1).toString(36).substring(4);
    } }, { key: "noExponents", value: function(t) {
      var n = String(t).split(/[eE]/);
      if (n.length === 1)
        return n[0];
      var i = "", o = t < 0 ? "-" : "", d = n[0].replace(".", ""), f = Number(n[1]) + 1;
      if (f < 0) {
        for (i = o + "0."; f++; )
          i += "0";
        return i + d.replace(/^-/, "");
      }
      for (f -= d.length; f--; )
        i += "0";
      return d + i;
    } }, { key: "getDimensions", value: function(t) {
      var n = getComputedStyle(t, null), i = t.clientHeight, o = t.clientWidth;
      return i -= parseFloat(n.paddingTop) + parseFloat(n.paddingBottom), [o -= parseFloat(n.paddingLeft) + parseFloat(n.paddingRight), i];
    } }, { key: "getBoundingClientRect", value: function(t) {
      var n = t.getBoundingClientRect();
      return { top: n.top, right: n.right, bottom: n.bottom, left: n.left, width: t.clientWidth, height: t.clientHeight, x: n.left, y: n.top };
    } }, { key: "getLargestStringFromArr", value: function(t) {
      return t.reduce(function(n, i) {
        return Array.isArray(i) && (i = i.reduce(function(o, d) {
          return o.length > d.length ? o : d;
        })), n.length > i.length ? n : i;
      }, 0);
    } }, { key: "hexToRgba", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "#999999", n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.6;
      t.substring(0, 1) !== "#" && (t = "#999999");
      var i = t.replace("#", "");
      i = i.match(new RegExp("(.{" + i.length / 3 + "})", "g"));
      for (var o = 0; o < i.length; o++)
        i[o] = parseInt(i[o].length === 1 ? i[o] + i[o] : i[o], 16);
      return n !== void 0 && i.push(n), "rgba(" + i.join(",") + ")";
    } }, { key: "getOpacityFromRGBA", value: function(t) {
      return parseFloat(t.replace(/^.*,(.+)\)/, "$1"));
    } }, { key: "rgb2hex", value: function(t) {
      return (t = t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && t.length === 4 ? "#" + ("0" + parseInt(t[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t[3], 10).toString(16)).slice(-2) : "";
    } }, { key: "isColorHex", value: function(t) {
      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t);
    } }, { key: "getPolygonPos", value: function(t, n) {
      for (var i = [], o = 2 * Math.PI / n, d = 0; d < n; d++) {
        var f = {};
        f.x = t * Math.sin(d * o), f.y = -t * Math.cos(d * o), i.push(f);
      }
      return i;
    } }, { key: "polarToCartesian", value: function(t, n, i, o) {
      var d = (o - 90) * Math.PI / 180;
      return { x: t + i * Math.cos(d), y: n + i * Math.sin(d) };
    } }, { key: "escapeString", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x", i = t.toString().slice();
      return i = i.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, n);
    } }, { key: "negToZero", value: function(t) {
      return t < 0 ? 0 : t;
    } }, { key: "moveIndexInArray", value: function(t, n, i) {
      if (i >= t.length)
        for (var o = i - t.length + 1; o--; )
          t.push(void 0);
      return t.splice(i, 0, t.splice(n, 1)[0]), t;
    } }, { key: "extractNumber", value: function(t) {
      return parseFloat(t.replace(/[^\d.]*/g, ""));
    } }, { key: "findAncestor", value: function(t, n) {
      for (; (t = t.parentElement) && !t.classList.contains(n); )
        ;
      return t;
    } }, { key: "setELstyles", value: function(t, n) {
      for (var i in n)
        n.hasOwnProperty(i) && (t.style.key = n[i]);
    } }, { key: "isNumber", value: function(t) {
      return !isNaN(t) && parseFloat(Number(t)) === t && !isNaN(parseInt(t, 10));
    } }, { key: "isFloat", value: function(t) {
      return Number(t) === t && t % 1 != 0;
    } }, { key: "isSafari", value: function() {
      return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    } }, { key: "isFirefox", value: function() {
      return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
    } }, { key: "isIE11", value: function() {
      if (window.navigator.userAgent.indexOf("MSIE") !== -1 || window.navigator.appVersion.indexOf("Trident/") > -1)
        return !0;
    } }, { key: "isIE", value: function() {
      var t = window.navigator.userAgent, n = t.indexOf("MSIE ");
      if (n > 0)
        return parseInt(t.substring(n + 5, t.indexOf(".", n)), 10);
      if (t.indexOf("Trident/") > 0) {
        var i = t.indexOf("rv:");
        return parseInt(t.substring(i + 3, t.indexOf(".", i)), 10);
      }
      var o = t.indexOf("Edge/");
      return o > 0 && parseInt(t.substring(o + 5, t.indexOf(".", o)), 10);
    } }]), B;
  }(), we = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w, this.setEasingFunctions();
    }
    return F(B, [{ key: "setEasingFunctions", value: function() {
      var t;
      if (!this.w.globals.easing) {
        switch (this.w.config.chart.animations.easing) {
          case "linear":
            t = "-";
            break;
          case "easein":
            t = "<";
            break;
          case "easeout":
            t = ">";
            break;
          case "easeinout":
          default:
            t = "<>";
            break;
          case "swing":
            t = function(n) {
              var i = 1.70158;
              return (n -= 1) * n * ((i + 1) * n + i) + 1;
            };
            break;
          case "bounce":
            t = function(n) {
              return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375;
            };
            break;
          case "elastic":
            t = function(n) {
              return n === !!n ? n : Math.pow(2, -10 * n) * Math.sin((n - 0.075) * (2 * Math.PI) / 0.3) + 1;
            };
        }
        this.w.globals.easing = t;
      }
    } }, { key: "animateLine", value: function(t, n, i, o) {
      t.attr(n).animate(o).attr(i);
    } }, { key: "animateMarker", value: function(t, n, i, o, d, f) {
      n || (n = 0), t.attr({ r: n, width: n, height: n }).animate(o, d).attr({ r: i, width: i.width, height: i.height }).afterAll(function() {
        f();
      });
    } }, { key: "animateCircle", value: function(t, n, i, o, d) {
      t.attr({ r: n.r, cx: n.cx, cy: n.cy }).animate(o, d).attr({ r: i.r, cx: i.cx, cy: i.cy });
    } }, { key: "animateRect", value: function(t, n, i, o, d) {
      t.attr(n).animate(o).attr(i).afterAll(function() {
        return d();
      });
    } }, { key: "animatePathsGradually", value: function(t) {
      var n = t.el, i = t.realIndex, o = t.j, d = t.fill, f = t.pathFrom, p = t.pathTo, y = t.speed, S = t.delay, A = this.w, E = 0;
      A.config.chart.animations.animateGradually.enabled && (E = A.config.chart.animations.animateGradually.delay), A.config.chart.animations.dynamicAnimation.enabled && A.globals.dataChanged && A.config.chart.type !== "bar" && (E = 0), this.morphSVG(n, i, o, A.config.chart.type !== "line" || A.globals.comboCharts ? d : "stroke", f, p, y, S * E);
    } }, { key: "showDelayedElements", value: function() {
      this.w.globals.delayedElements.forEach(function(t) {
        var n = t.el;
        n.classList.remove("apexcharts-element-hidden"), n.classList.add("apexcharts-hidden-element-shown");
      });
    } }, { key: "animationCompleted", value: function(t) {
      var n = this.w;
      n.globals.animationEnded || (n.globals.animationEnded = !0, this.showDelayedElements(), typeof n.config.chart.events.animationEnd == "function" && n.config.chart.events.animationEnd(this.ctx, { el: t, w: n }));
    } }, { key: "morphSVG", value: function(t, n, i, o, d, f, p, y) {
      var S = this, A = this.w;
      d || (d = t.attr("pathFrom")), f || (f = t.attr("pathTo"));
      var E = function(L) {
        return A.config.chart.type === "radar" && (p = 1), "M 0 ".concat(A.globals.gridHeight);
      };
      (!d || d.indexOf("undefined") > -1 || d.indexOf("NaN") > -1) && (d = E()), (!f || f.indexOf("undefined") > -1 || f.indexOf("NaN") > -1) && (f = E()), A.globals.shouldAnimate || (p = 1), t.plot(d).animate(1, A.globals.easing, y).plot(d).animate(p, A.globals.easing, y).plot(f).afterAll(function() {
        K.isNumber(i) ? i === A.globals.series[A.globals.maxValsInArrayIndex].length - 2 && A.globals.shouldAnimate && S.animationCompleted(t) : o !== "none" && A.globals.shouldAnimate && (!A.globals.comboCharts && n === A.globals.series.length - 1 || A.globals.comboCharts) && S.animationCompleted(t), S.showDelayedElements();
      });
    } }]), B;
  }(), Re = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "getDefaultFilter", value: function(t, n) {
      var i = this.w;
      t.unfilter(!0), new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"), i.config.states.normal.filter !== "none" ? this.applyFilter(t, n, i.config.states.normal.filter.type, i.config.states.normal.filter.value) : i.config.chart.dropShadow.enabled && this.dropShadow(t, i.config.chart.dropShadow, n);
    } }, { key: "addNormalFilter", value: function(t, n) {
      var i = this.w;
      i.config.chart.dropShadow.enabled && !t.node.classList.contains("apexcharts-marker") && this.dropShadow(t, i.config.chart.dropShadow, n);
    } }, { key: "addLightenFilter", value: function(t, n, i) {
      var o = this, d = this.w, f = i.intensity;
      t.unfilter(!0), new window.SVG.Filter(), t.filter(function(p) {
        var y = d.config.chart.dropShadow;
        (y.enabled ? o.addShadow(p, n, y) : p).componentTransfer({ rgb: { type: "linear", slope: 1.5, intercept: f } });
      }), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node);
    } }, { key: "addDarkenFilter", value: function(t, n, i) {
      var o = this, d = this.w, f = i.intensity;
      t.unfilter(!0), new window.SVG.Filter(), t.filter(function(p) {
        var y = d.config.chart.dropShadow;
        (y.enabled ? o.addShadow(p, n, y) : p).componentTransfer({ rgb: { type: "linear", slope: f } });
      }), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node);
    } }, { key: "applyFilter", value: function(t, n, i) {
      var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.5;
      switch (i) {
        case "none":
          this.addNormalFilter(t, n);
          break;
        case "lighten":
          this.addLightenFilter(t, n, { intensity: o });
          break;
        case "darken":
          this.addDarkenFilter(t, n, { intensity: o });
      }
    } }, { key: "addShadow", value: function(t, n, i) {
      var o = i.blur, d = i.top, f = i.left, p = i.color, y = i.opacity, S = t.flood(Array.isArray(p) ? p[n] : p, y).composite(t.sourceAlpha, "in").offset(f, d).gaussianBlur(o).merge(t.source);
      return t.blend(t.source, S);
    } }, { key: "dropShadow", value: function(t, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, o = n.top, d = n.left, f = n.blur, p = n.color, y = n.opacity, S = n.noUserSpaceOnUse, A = this.w;
      return t.unfilter(!0), K.isIE() && A.config.chart.type === "radialBar" || (p = Array.isArray(p) ? p[i] : p, t.filter(function(E) {
        var L = null;
        L = K.isSafari() || K.isFirefox() || K.isIE() ? E.flood(p, y).composite(E.sourceAlpha, "in").offset(d, o).gaussianBlur(f) : E.flood(p, y).composite(E.sourceAlpha, "in").offset(d, o).gaussianBlur(f).merge(E.source), E.blend(E.source, L);
      }), S || t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)), t;
    } }, { key: "setSelectionFilter", value: function(t, n, i) {
      var o = this.w;
      if (o.globals.selectedDataPoints[n] !== void 0 && o.globals.selectedDataPoints[n].indexOf(i) > -1) {
        t.node.setAttribute("selected", !0);
        var d = o.config.states.active.filter;
        d !== "none" && this.applyFilter(t, n, d.type, d.value);
      }
    } }, { key: "_scaleFilterSize", value: function(t) {
      (function(n) {
        for (var i in n)
          n.hasOwnProperty(i) && t.setAttribute(i, n[i]);
      })({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
    } }]), B;
  }(), re = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "roundPathCorners", value: function(t, n) {
      function i(ee, oe, fe) {
        var ke = oe.x - ee.x, _e = oe.y - ee.y, Le = Math.sqrt(ke * ke + _e * _e);
        return o(ee, oe, Math.min(1, fe / Le));
      }
      function o(ee, oe, fe) {
        return { x: ee.x + (oe.x - ee.x) * fe, y: ee.y + (oe.y - ee.y) * fe };
      }
      function d(ee, oe) {
        ee.length > 2 && (ee[ee.length - 2] = oe.x, ee[ee.length - 1] = oe.y);
      }
      function f(ee) {
        return { x: parseFloat(ee[ee.length - 2]), y: parseFloat(ee[ee.length - 1]) };
      }
      t.indexOf("NaN") > -1 && (t = "");
      var p = t.split(/[,\s]/).reduce(function(ee, oe) {
        var fe = oe.match("([a-zA-Z])(.+)");
        return fe ? (ee.push(fe[1]), ee.push(fe[2])) : ee.push(oe), ee;
      }, []).reduce(function(ee, oe) {
        return parseFloat(oe) == oe && ee.length ? ee[ee.length - 1].push(oe) : ee.push([oe]), ee;
      }, []), y = [];
      if (p.length > 1) {
        var S = f(p[0]), A = null;
        p[p.length - 1][0] == "Z" && p[0].length > 2 && (A = ["L", S.x, S.y], p[p.length - 1] = A), y.push(p[0]);
        for (var E = 1; E < p.length; E++) {
          var L = y[y.length - 1], O = p[E], P = O == A ? p[1] : p[E + 1];
          if (P && L && L.length > 2 && O[0] == "L" && P.length > 2 && P[0] == "L") {
            var I, j, V = f(L), Z = f(O), b = f(P);
            I = i(Z, V, n), j = i(Z, b, n), d(O, I), O.origPoint = Z, y.push(O);
            var M = o(I, Z, 0.5), N = o(Z, j, 0.5), X = ["C", M.x, M.y, N.x, N.y, j.x, j.y];
            X.origPoint = Z, y.push(X);
          } else
            y.push(O);
        }
        if (A) {
          var Q = f(y[y.length - 1]);
          y.push(["Z"]), d(y[0], Q);
        }
      } else
        y = p;
      return y.reduce(function(ee, oe) {
        return ee + oe.join(" ") + " ";
      }, "");
    } }, { key: "drawLine", value: function(t, n, i, o) {
      var d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "#a8a8a8", f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0, p = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, y = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "butt";
      return this.w.globals.dom.Paper.line().attr({ x1: t, y1: n, x2: i, y2: o, stroke: d, "stroke-dasharray": f, "stroke-width": p, "stroke-linecap": y });
    } }, { key: "drawRect", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "#fefefe", p = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1, y = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null, S = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : null, A = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 0, E = this.w.globals.dom.Paper.rect();
      return E.attr({ x: t, y: n, width: i > 0 ? i : 0, height: o > 0 ? o : 0, rx: d, ry: d, opacity: p, "stroke-width": y !== null ? y : 0, stroke: S !== null ? S : "none", "stroke-dasharray": A }), E.node.setAttribute("fill", f), E;
    } }, { key: "drawPolygon", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "#e1e1e1", i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "none";
      return this.w.globals.dom.Paper.polygon(t).attr({ fill: o, stroke: n, "stroke-width": i });
    } }, { key: "drawCircle", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      t < 0 && (t = 0);
      var i = this.w.globals.dom.Paper.circle(2 * t);
      return n !== null && i.attr(n), i;
    } }, { key: "drawPath", value: function(t) {
      var n = t.d, i = n === void 0 ? "" : n, o = t.stroke, d = o === void 0 ? "#a8a8a8" : o, f = t.strokeWidth, p = f === void 0 ? 1 : f, y = t.fill, S = t.fillOpacity, A = S === void 0 ? 1 : S, E = t.strokeOpacity, L = E === void 0 ? 1 : E, O = t.classes, P = t.strokeLinecap, I = P === void 0 ? null : P, j = t.strokeDashArray, V = j === void 0 ? 0 : j, Z = this.w;
      return I === null && (I = Z.config.stroke.lineCap), (i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = "M 0 ".concat(Z.globals.gridHeight)), Z.globals.dom.Paper.path(i).attr({ fill: y, "fill-opacity": A, stroke: d, "stroke-opacity": L, "stroke-linecap": I, "stroke-width": p, "stroke-dasharray": V, class: O });
    } }, { key: "group", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, n = this.w.globals.dom.Paper.group();
      return t !== null && n.attr(t), n;
    } }, { key: "move", value: function(t, n) {
      var i = ["M", t, n].join(" ");
      return i;
    } }, { key: "line", value: function(t, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, o = null;
      return i === null ? o = [" L", t, n].join(" ") : i === "H" ? o = [" H", t].join(" ") : i === "V" && (o = [" V", n].join(" ")), o;
    } }, { key: "curve", value: function(t, n, i, o, d, f) {
      var p = ["C", t, n, i, o, d, f].join(" ");
      return p;
    } }, { key: "quadraticCurve", value: function(t, n, i, o) {
      return ["Q", t, n, i, o].join(" ");
    } }, { key: "arc", value: function(t, n, i, o, d, f, p) {
      var y = "A";
      arguments.length > 7 && arguments[7] !== void 0 && arguments[7] && (y = "a");
      var S = [y, t, n, i, o, d, f, p].join(" ");
      return S;
    } }, { key: "renderPaths", value: function(t) {
      var n, i = t.j, o = t.realIndex, d = t.pathFrom, f = t.pathTo, p = t.stroke, y = t.strokeWidth, S = t.strokeLinecap, A = t.fill, E = t.animationDelay, L = t.initialSpeed, O = t.dataChangeSpeed, P = t.className, I = t.shouldClipToGrid, j = I === void 0 || I, V = t.bindEventsOnPaths, Z = V === void 0 || V, b = t.drawShadow, M = b === void 0 || b, N = this.w, X = new Re(this.ctx), Q = new we(this.ctx), ee = this.w.config.chart.animations.enabled, oe = ee && this.w.config.chart.animations.dynamicAnimation.enabled, fe = !!(ee && !N.globals.resized || oe && N.globals.dataChanged && N.globals.shouldAnimate);
      fe ? n = d : (n = f, N.globals.animationEnded = !0);
      var ke = N.config.stroke.dashArray, _e = 0;
      _e = Array.isArray(ke) ? ke[o] : N.config.stroke.dashArray;
      var Le = this.drawPath({ d: n, stroke: p, strokeWidth: y, fill: A, fillOpacity: 1, classes: P, strokeLinecap: S, strokeDashArray: _e });
      if (Le.attr("index", o), j && Le.attr({ "clip-path": "url(#gridRectMask".concat(N.globals.cuid, ")") }), N.config.states.normal.filter.type !== "none")
        X.getDefaultFilter(Le, o);
      else if (N.config.chart.dropShadow.enabled && M && (!N.config.chart.dropShadow.enabledOnSeries || N.config.chart.dropShadow.enabledOnSeries && N.config.chart.dropShadow.enabledOnSeries.indexOf(o) !== -1)) {
        var Ie = N.config.chart.dropShadow;
        X.dropShadow(Le, Ie, o);
      }
      Z && (Le.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, Le)), Le.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, Le)), Le.node.addEventListener("mousedown", this.pathMouseDown.bind(this, Le))), Le.attr({ pathTo: f, pathFrom: d });
      var at = { el: Le, j: i, realIndex: o, pathFrom: d, pathTo: f, fill: A, strokeWidth: y, delay: E };
      return !ee || N.globals.resized || N.globals.dataChanged ? !N.globals.resized && N.globals.dataChanged || Q.showDelayedElements() : Q.animatePathsGradually(v(v({}, at), {}, { speed: L })), N.globals.dataChanged && oe && fe && Q.animatePathsGradually(v(v({}, at), {}, { speed: O })), Le;
    } }, { key: "drawPattern", value: function(t, n, i) {
      var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "#a8a8a8", d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
      return this.w.globals.dom.Paper.pattern(n, i, function(f) {
        t === "horizontalLines" ? f.line(0, 0, i, 0).stroke({ color: o, width: d + 1 }) : t === "verticalLines" ? f.line(0, 0, 0, n).stroke({ color: o, width: d + 1 }) : t === "slantedLines" ? f.line(0, 0, n, i).stroke({ color: o, width: d }) : t === "squares" ? f.rect(n, i).fill("none").stroke({ color: o, width: d }) : t === "circles" && f.circle(n).fill("none").stroke({ color: o, width: d });
      });
    } }, { key: "drawGradient", value: function(t, n, i, o, d) {
      var f, p = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, y = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, S = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null, A = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 0, E = this.w;
      n.length < 9 && n.indexOf("#") === 0 && (n = K.hexToRgba(n, o)), i.length < 9 && i.indexOf("#") === 0 && (i = K.hexToRgba(i, d));
      var L = 0, O = 1, P = 1, I = null;
      y !== null && (L = y[0] !== void 0 ? y[0] / 100 : 0, O = y[1] !== void 0 ? y[1] / 100 : 1, P = y[2] !== void 0 ? y[2] / 100 : 1, I = y[3] !== void 0 ? y[3] / 100 : null);
      var j = !(E.config.chart.type !== "donut" && E.config.chart.type !== "pie" && E.config.chart.type !== "polarArea" && E.config.chart.type !== "bubble");
      if (f = S === null || S.length === 0 ? E.globals.dom.Paper.gradient(j ? "radial" : "linear", function(b) {
        b.at(L, n, o), b.at(O, i, d), b.at(P, i, d), I !== null && b.at(I, n, o);
      }) : E.globals.dom.Paper.gradient(j ? "radial" : "linear", function(b) {
        (Array.isArray(S[A]) ? S[A] : S).forEach(function(M) {
          b.at(M.offset / 100, M.color, M.opacity);
        });
      }), j) {
        var V = E.globals.gridWidth / 2, Z = E.globals.gridHeight / 2;
        E.config.chart.type !== "bubble" ? f.attr({ gradientUnits: "userSpaceOnUse", cx: V, cy: Z, r: p }) : f.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
      } else
        t === "vertical" ? f.from(0, 0).to(0, 1) : t === "diagonal" ? f.from(0, 0).to(1, 1) : t === "horizontal" ? f.from(0, 1).to(1, 1) : t === "diagonal2" && f.from(1, 0).to(0, 1);
      return f;
    } }, { key: "getTextBasedOnMaxWidth", value: function(t) {
      var n = t.text, i = t.maxWidth, o = t.fontSize, d = t.fontFamily, f = this.getTextRects(n, o, d), p = f.width / n.length, y = Math.floor(i / p);
      return i < f.width ? n.slice(0, y - 3) + "..." : n;
    } }, { key: "drawText", value: function(t) {
      var n = this, i = t.x, o = t.y, d = t.text, f = t.textAnchor, p = t.fontSize, y = t.fontFamily, S = t.fontWeight, A = t.foreColor, E = t.opacity, L = t.maxWidth, O = t.cssClass, P = O === void 0 ? "" : O, I = t.isPlainText, j = I === void 0 || I, V = this.w;
      d === void 0 && (d = "");
      var Z = d;
      f || (f = "start"), A && A.length || (A = V.config.chart.foreColor), y = y || V.config.chart.fontFamily, S = S || "regular";
      var b, M = { maxWidth: L, fontSize: p = p || "11px", fontFamily: y };
      return Array.isArray(d) ? b = V.globals.dom.Paper.text(function(N) {
        for (var X = 0; X < d.length; X++)
          Z = d[X], L && (Z = n.getTextBasedOnMaxWidth(v({ text: d[X] }, M))), X === 0 ? N.tspan(Z) : N.tspan(Z).newLine();
      }) : (L && (Z = this.getTextBasedOnMaxWidth(v({ text: d }, M))), b = j ? V.globals.dom.Paper.plain(d) : V.globals.dom.Paper.text(function(N) {
        return N.tspan(Z);
      })), b.attr({ x: i, y: o, "text-anchor": f, "dominant-baseline": "auto", "font-size": p, "font-family": y, "font-weight": S, fill: A, class: "apexcharts-text " + P }), b.node.style.fontFamily = y, b.node.style.opacity = E, b;
    } }, { key: "drawMarker", value: function(t, n, i) {
      t = t || 0;
      var o = i.pSize || 0, d = null;
      if (i.shape === "square" || i.shape === "rect") {
        var f = i.pRadius === void 0 ? o / 2 : i.pRadius;
        n !== null && o || (o = 0, f = 0);
        var p = 1.2 * o + f, y = this.drawRect(p, p, p, p, f);
        y.attr({ x: t - p / 2, y: n - p / 2, cx: t, cy: n, class: i.class ? i.class : "", fill: i.pointFillColor, "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1, stroke: i.pointStrokeColor, "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0, "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1 }), d = y;
      } else
        i.shape !== "circle" && i.shape || (K.isNumber(n) || (o = 0, n = 0), d = this.drawCircle(o, { cx: t, cy: n, class: i.class ? i.class : "", stroke: i.pointStrokeColor, fill: i.pointFillColor, "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1, "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0, "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1 }));
      return d;
    } }, { key: "pathMouseEnter", value: function(t, n) {
      var i = this.w, o = new Re(this.ctx), d = parseInt(t.node.getAttribute("index"), 10), f = parseInt(t.node.getAttribute("j"), 10);
      if (typeof i.config.chart.events.dataPointMouseEnter == "function" && i.config.chart.events.dataPointMouseEnter(n, this.ctx, { seriesIndex: d, dataPointIndex: f, w: i }), this.ctx.events.fireEvent("dataPointMouseEnter", [n, this.ctx, { seriesIndex: d, dataPointIndex: f, w: i }]), (i.config.states.active.filter.type === "none" || t.node.getAttribute("selected") !== "true") && i.config.states.hover.filter.type !== "none" && !i.globals.isTouchDevice) {
        var p = i.config.states.hover.filter;
        o.applyFilter(t, d, p.type, p.value);
      }
    } }, { key: "pathMouseLeave", value: function(t, n) {
      var i = this.w, o = new Re(this.ctx), d = parseInt(t.node.getAttribute("index"), 10), f = parseInt(t.node.getAttribute("j"), 10);
      typeof i.config.chart.events.dataPointMouseLeave == "function" && i.config.chart.events.dataPointMouseLeave(n, this.ctx, { seriesIndex: d, dataPointIndex: f, w: i }), this.ctx.events.fireEvent("dataPointMouseLeave", [n, this.ctx, { seriesIndex: d, dataPointIndex: f, w: i }]), i.config.states.active.filter.type !== "none" && t.node.getAttribute("selected") === "true" || i.config.states.hover.filter.type !== "none" && o.getDefaultFilter(t, d);
    } }, { key: "pathMouseDown", value: function(t, n) {
      var i = this.w, o = new Re(this.ctx), d = parseInt(t.node.getAttribute("index"), 10), f = parseInt(t.node.getAttribute("j"), 10), p = "false";
      if (t.node.getAttribute("selected") === "true") {
        if (t.node.setAttribute("selected", "false"), i.globals.selectedDataPoints[d].indexOf(f) > -1) {
          var y = i.globals.selectedDataPoints[d].indexOf(f);
          i.globals.selectedDataPoints[d].splice(y, 1);
        }
      } else {
        if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) {
          i.globals.selectedDataPoints = [];
          var S = i.globals.dom.Paper.select(".apexcharts-series path").members, A = i.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members, E = function(P) {
            Array.prototype.forEach.call(P, function(I) {
              I.node.setAttribute("selected", "false"), o.getDefaultFilter(I, d);
            });
          };
          E(S), E(A);
        }
        t.node.setAttribute("selected", "true"), p = "true", i.globals.selectedDataPoints[d] === void 0 && (i.globals.selectedDataPoints[d] = []), i.globals.selectedDataPoints[d].push(f);
      }
      if (p === "true") {
        var L = i.config.states.active.filter;
        if (L !== "none")
          o.applyFilter(t, d, L.type, L.value);
        else if (i.config.states.hover.filter !== "none" && !i.globals.isTouchDevice) {
          var O = i.config.states.hover.filter;
          o.applyFilter(t, d, O.type, O.value);
        }
      } else
        i.config.states.active.filter.type !== "none" && (i.config.states.hover.filter.type === "none" || i.globals.isTouchDevice ? o.getDefaultFilter(t, d) : (O = i.config.states.hover.filter, o.applyFilter(t, d, O.type, O.value)));
      typeof i.config.chart.events.dataPointSelection == "function" && i.config.chart.events.dataPointSelection(n, this.ctx, { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: d, dataPointIndex: f, w: i }), n && this.ctx.events.fireEvent("dataPointSelection", [n, this.ctx, { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: d, dataPointIndex: f, w: i }]);
    } }, { key: "rotateAroundCenter", value: function(t) {
      var n = {};
      return t && typeof t.getBBox == "function" && (n = t.getBBox()), { x: n.x + n.width / 2, y: n.y + n.height / 2 };
    } }, { key: "getTextRects", value: function(t, n, i, o) {
      var d = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], f = this.w, p = this.drawText({ x: -200, y: -200, text: t, textAnchor: "start", fontSize: n, fontFamily: i, foreColor: "#fff", opacity: 0 });
      o && p.attr("transform", o), f.globals.dom.Paper.add(p);
      var y = p.bbox();
      return d || (y = p.node.getBoundingClientRect()), p.remove(), { width: y.width, height: y.height };
    } }, { key: "placeTextWithEllipsis", value: function(t, n, i) {
      if (typeof t.getComputedTextLength == "function" && (t.textContent = n, n.length > 0 && t.getComputedTextLength() >= i / 1.1)) {
        for (var o = n.length - 3; o > 0; o -= 3)
          if (t.getSubStringLength(0, o) <= i / 1.1)
            return void (t.textContent = n.substring(0, o) + "...");
        t.textContent = ".";
      }
    } }], [{ key: "setAttrs", value: function(t, n) {
      for (var i in n)
        n.hasOwnProperty(i) && t.setAttribute(i, n[i]);
    } }]), B;
  }(), ve = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "getStackedSeriesTotals", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = this.w, i = [];
      if (n.globals.series.length === 0)
        return i;
      for (var o = 0; o < n.globals.series[n.globals.maxValsInArrayIndex].length; o++) {
        for (var d = 0, f = 0; f < n.globals.series.length; f++)
          n.globals.series[f][o] !== void 0 && t.indexOf(f) === -1 && (d += n.globals.series[f][o]);
        i.push(d);
      }
      return i;
    } }, { key: "getSeriesTotalByIndex", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return t === null ? this.w.config.series.reduce(function(n, i) {
        return n + i;
      }, 0) : this.w.globals.series[t].reduce(function(n, i) {
        return n + i;
      }, 0);
    } }, { key: "isSeriesNull", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return (t === null ? this.w.config.series.filter(function(n) {
        return n !== null;
      }) : this.w.config.series[t].data.filter(function(n) {
        return n !== null;
      })).length === 0;
    } }, { key: "seriesHaveSameValues", value: function(t) {
      return this.w.globals.series[t].every(function(n, i, o) {
        return n === o[0];
      });
    } }, { key: "getCategoryLabels", value: function(t) {
      var n = this.w, i = t.slice();
      return n.config.xaxis.convertedCatToNumeric && (i = t.map(function(o, d) {
        return n.config.xaxis.labels.formatter(o - n.globals.minX + 1);
      })), i;
    } }, { key: "getLargestSeries", value: function() {
      var t = this.w;
      t.globals.maxValsInArrayIndex = t.globals.series.map(function(n) {
        return n.length;
      }).indexOf(Math.max.apply(Math, t.globals.series.map(function(n) {
        return n.length;
      })));
    } }, { key: "getLargestMarkerSize", value: function() {
      var t = this.w, n = 0;
      return t.globals.markers.size.forEach(function(i) {
        n = Math.max(n, i);
      }), t.config.markers.discrete && t.config.markers.discrete.length && t.config.markers.discrete.forEach(function(i) {
        n = Math.max(n, i.size);
      }), n > 0 && (n += t.config.markers.hover.sizeOffset + 1), t.globals.markers.largestSize = n, n;
    } }, { key: "getSeriesTotals", value: function() {
      var t = this.w;
      t.globals.seriesTotals = t.globals.series.map(function(n, i) {
        var o = 0;
        if (Array.isArray(n))
          for (var d = 0; d < n.length; d++)
            o += n[d];
        else
          o += n;
        return o;
      });
    } }, { key: "getSeriesTotalsXRange", value: function(t, n) {
      var i = this.w;
      return i.globals.series.map(function(o, d) {
        for (var f = 0, p = 0; p < o.length; p++)
          i.globals.seriesX[d][p] > t && i.globals.seriesX[d][p] < n && (f += o[p]);
        return f;
      });
    } }, { key: "getPercentSeries", value: function() {
      var t = this.w;
      t.globals.seriesPercent = t.globals.series.map(function(n, i) {
        var o = [];
        if (Array.isArray(n))
          for (var d = 0; d < n.length; d++) {
            var f = t.globals.stackedSeriesTotals[d], p = 0;
            f && (p = 100 * n[d] / f), o.push(p);
          }
        else {
          var y = 100 * n / t.globals.seriesTotals.reduce(function(S, A) {
            return S + A;
          }, 0);
          o.push(y);
        }
        return o;
      });
    } }, { key: "getCalculatedRatios", value: function() {
      var t, n, i, o, d = this.w.globals, f = [], p = 0, y = [], S = 0.1, A = 0;
      if (d.yRange = [], d.isMultipleYAxis)
        for (var E = 0; E < d.minYArr.length; E++)
          d.yRange.push(Math.abs(d.minYArr[E] - d.maxYArr[E])), y.push(0);
      else
        d.yRange.push(Math.abs(d.minY - d.maxY));
      d.xRange = Math.abs(d.maxX - d.minX), d.zRange = Math.abs(d.maxZ - d.minZ);
      for (var L = 0; L < d.yRange.length; L++)
        f.push(d.yRange[L] / d.gridHeight);
      if (n = d.xRange / d.gridWidth, i = Math.abs(d.initialMaxX - d.initialMinX) / d.gridWidth, t = d.yRange / d.gridWidth, o = d.xRange / d.gridHeight, (p = d.zRange / d.gridHeight * 16) || (p = 1), d.minY !== Number.MIN_VALUE && Math.abs(d.minY) !== 0 && (d.hasNegs = !0), d.isMultipleYAxis) {
        y = [];
        for (var O = 0; O < f.length; O++)
          y.push(-d.minYArr[O] / f[O]);
      } else
        y.push(-d.minY / f[0]), d.minY !== Number.MIN_VALUE && Math.abs(d.minY) !== 0 && (S = -d.minY / t, A = d.minX / n);
      return { yRatio: f, invertedYRatio: t, zRatio: p, xRatio: n, initialXRatio: i, invertedXRatio: o, baseLineInvertedY: S, baseLineY: y, baseLineX: A };
    } }, { key: "getLogSeries", value: function(t) {
      var n = this, i = this.w;
      return i.globals.seriesLog = t.map(function(o, d) {
        return i.config.yaxis[d] && i.config.yaxis[d].logarithmic ? o.map(function(f) {
          return f === null ? null : n.getLogVal(i.config.yaxis[d].logBase, f, d);
        }) : o;
      }), i.globals.invalidLogScale ? t : i.globals.seriesLog;
    } }, { key: "getBaseLog", value: function(t, n) {
      return Math.log(n) / Math.log(t);
    } }, { key: "getLogVal", value: function(t, n, i) {
      if (n === 0)
        return 0;
      var o = this.w, d = o.globals.minYArr[i] === 0 ? -1 : this.getBaseLog(t, o.globals.minYArr[i]), f = (o.globals.maxYArr[i] === 0 ? 0 : this.getBaseLog(t, o.globals.maxYArr[i])) - d;
      return n < 1 ? n / f : (this.getBaseLog(t, n) - d) / f;
    } }, { key: "getLogYRatios", value: function(t) {
      var n = this, i = this.w, o = this.w.globals;
      return o.yLogRatio = t.slice(), o.logYRange = o.yRange.map(function(d, f) {
        if (i.config.yaxis[f] && n.w.config.yaxis[f].logarithmic) {
          var p, y = -Number.MAX_VALUE, S = Number.MIN_VALUE;
          return o.seriesLog.forEach(function(A, E) {
            A.forEach(function(L) {
              i.config.yaxis[E] && i.config.yaxis[E].logarithmic && (y = Math.max(L, y), S = Math.min(L, S));
            });
          }), p = Math.pow(o.yRange[f], Math.abs(S - y) / o.yRange[f]), o.yLogRatio[f] = p / o.gridHeight, p;
        }
      }), o.invalidLogScale ? t.slice() : o.yLogRatio;
    } }], [{ key: "checkComboSeries", value: function(t) {
      var n = !1, i = 0, o = 0;
      return t.length && t[0].type !== void 0 && t.forEach(function(d) {
        d.type !== "bar" && d.type !== "column" && d.type !== "candlestick" && d.type !== "boxPlot" || i++, d.type !== void 0 && o++;
      }), o > 0 && (n = !0), { comboBarCount: i, comboCharts: n };
    } }, { key: "extendArrayProps", value: function(t, n, i) {
      return n.yaxis && (n = t.extendYAxis(n, i)), n.annotations && (n.annotations.yaxis && (n = t.extendYAxisAnnotations(n)), n.annotations.xaxis && (n = t.extendXAxisAnnotations(n)), n.annotations.points && (n = t.extendPointAnnotations(n))), n;
    } }]), B;
  }(), Me = function() {
    function B(t) {
      C(this, B), this.w = t.w, this.annoCtx = t;
    }
    return F(B, [{ key: "setOrientations", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = this.w;
      if (t.label.orientation === "vertical") {
        var o = n !== null ? n : 0, d = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(o, "']"));
        if (d !== null) {
          var f = d.getBoundingClientRect();
          d.setAttribute("x", parseFloat(d.getAttribute("x")) - f.height + 4), t.label.position === "top" ? d.setAttribute("y", parseFloat(d.getAttribute("y")) + f.width) : d.setAttribute("y", parseFloat(d.getAttribute("y")) - f.width);
          var p = this.annoCtx.graphics.rotateAroundCenter(d), y = p.x, S = p.y;
          d.setAttribute("transform", "rotate(-90 ".concat(y, " ").concat(S, ")"));
        }
      }
    } }, { key: "addBackgroundToAnno", value: function(t, n) {
      var i = this.w;
      if (!t || n.label.text === void 0 || n.label.text !== void 0 && !String(n.label.text).trim())
        return null;
      var o = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), d = t.getBoundingClientRect(), f = n.label.style.padding.left, p = n.label.style.padding.right, y = n.label.style.padding.top, S = n.label.style.padding.bottom;
      n.label.orientation === "vertical" && (y = n.label.style.padding.left, S = n.label.style.padding.right, f = n.label.style.padding.top, p = n.label.style.padding.bottom);
      var A = d.left - o.left - f, E = d.top - o.top - y, L = this.annoCtx.graphics.drawRect(A - i.globals.barPadForNumericAxis, E, d.width + f + p, d.height + y + S, n.label.borderRadius, n.label.style.background, 1, n.label.borderWidth, n.label.borderColor, 0);
      return n.id && L.node.classList.add(n.id), L;
    } }, { key: "annotationsBackground", value: function() {
      var t = this, n = this.w, i = function(o, d, f) {
        var p = n.globals.dom.baseEl.querySelector(".apexcharts-".concat(f, "-annotations .apexcharts-").concat(f, "-annotation-label[rel='").concat(d, "']"));
        if (p) {
          var y = p.parentNode, S = t.addBackgroundToAnno(p, o);
          S && (y.insertBefore(S.node, p), o.label.mouseEnter && S.node.addEventListener("mouseenter", o.label.mouseEnter.bind(t, o)), o.label.mouseLeave && S.node.addEventListener("mouseleave", o.label.mouseLeave.bind(t, o)), o.label.click && S.node.addEventListener("click", o.label.click.bind(t, o)));
        }
      };
      n.config.annotations.xaxis.map(function(o, d) {
        i(o, d, "xaxis");
      }), n.config.annotations.yaxis.map(function(o, d) {
        i(o, d, "yaxis");
      }), n.config.annotations.points.map(function(o, d) {
        i(o, d, "point");
      });
    } }, { key: "getY1Y2", value: function(t, n) {
      var i, o = t === "y1" ? n.y : n.y2, d = this.w;
      if (this.annoCtx.invertAxis) {
        var f = d.globals.labels.indexOf(o);
        d.config.xaxis.convertedCatToNumeric && (f = d.globals.categoryLabels.indexOf(o));
        var p = d.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (f + 1) + ")");
        p && (i = parseFloat(p.getAttribute("y")));
      } else {
        var y;
        d.config.yaxis[n.yAxisIndex].logarithmic ? y = (o = new ve(this.annoCtx.ctx).getLogVal(o, n.yAxisIndex)) / d.globals.yLogRatio[n.yAxisIndex] : y = (o - d.globals.minYArr[n.yAxisIndex]) / (d.globals.yRange[n.yAxisIndex] / d.globals.gridHeight), i = d.globals.gridHeight - y, !n.marker || n.y !== void 0 && n.y !== null || (i = 0), d.config.yaxis[n.yAxisIndex] && d.config.yaxis[n.yAxisIndex].reversed && (i = y);
      }
      return typeof o == "string" && o.indexOf("px") > -1 && (i = parseFloat(o)), i;
    } }, { key: "getX1X2", value: function(t, n) {
      var i = this.w, o = this.annoCtx.invertAxis ? i.globals.minY : i.globals.minX, d = this.annoCtx.invertAxis ? i.globals.maxY : i.globals.maxX, f = this.annoCtx.invertAxis ? i.globals.yRange[0] : i.globals.xRange, p = (n.x - o) / (f / i.globals.gridWidth);
      this.annoCtx.inversedReversedAxis && (p = (d - n.x) / (f / i.globals.gridWidth)), i.config.xaxis.type !== "category" && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || (p = this.getStringX(n.x));
      var y = (n.x2 - o) / (f / i.globals.gridWidth);
      return this.annoCtx.inversedReversedAxis && (y = (d - n.x2) / (f / i.globals.gridWidth)), i.config.xaxis.type !== "category" && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || (y = this.getStringX(n.x2)), n.x !== void 0 && n.x !== null || !n.marker || (p = i.globals.gridWidth), t === "x1" && typeof n.x == "string" && n.x.indexOf("px") > -1 && (p = parseFloat(n.x)), t === "x2" && typeof n.x2 == "string" && n.x2.indexOf("px") > -1 && (y = parseFloat(n.x2)), t === "x1" ? p : y;
    } }, { key: "getStringX", value: function(t) {
      var n = this.w, i = t;
      n.config.xaxis.convertedCatToNumeric && n.globals.categoryLabels.length && (t = n.globals.categoryLabels.indexOf(t) + 1);
      var o = n.globals.labels.indexOf(t), d = n.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (o + 1) + ")");
      return d && (i = parseFloat(d.getAttribute("x"))), i;
    } }]), B;
  }(), et = function() {
    function B(t) {
      C(this, B), this.w = t.w, this.annoCtx = t, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new Me(this.annoCtx);
    }
    return F(B, [{ key: "addXaxisAnnotation", value: function(t, n, i) {
      var o, d = this.w, f = this.helpers.getX1X2("x1", t), p = t.label.text, y = t.strokeDashArray;
      if (K.isNumber(f)) {
        if (t.x2 === null || t.x2 === void 0) {
          var S = this.annoCtx.graphics.drawLine(f + t.offsetX, 0 + t.offsetY, f + t.offsetX, d.globals.gridHeight + t.offsetY, t.borderColor, y, t.borderWidth);
          n.appendChild(S.node), t.id && S.node.classList.add(t.id);
        } else {
          if ((o = this.helpers.getX1X2("x2", t)) < f) {
            var A = f;
            f = o, o = A;
          }
          var E = this.annoCtx.graphics.drawRect(f + t.offsetX, 0 + t.offsetY, o - f, d.globals.gridHeight + t.offsetY, 0, t.fillColor, t.opacity, 1, t.borderColor, y);
          E.node.classList.add("apexcharts-annotation-rect"), E.attr("clip-path", "url(#gridRectMask".concat(d.globals.cuid, ")")), n.appendChild(E.node), t.id && E.node.classList.add(t.id);
        }
        var L = this.annoCtx.graphics.getTextRects(p, parseFloat(t.label.style.fontSize)), O = t.label.position === "top" ? 4 : t.label.position === "center" ? d.globals.gridHeight / 2 + (t.label.orientation === "vertical" ? L.width / 2 : 0) : d.globals.gridHeight, P = this.annoCtx.graphics.drawText({ x: f + t.label.offsetX, y: O + t.label.offsetY - (t.label.orientation === "vertical" ? t.label.position === "top" ? L.width / 2 - 12 : -L.width / 2 : 0), text: p, textAnchor: t.label.textAnchor, fontSize: t.label.style.fontSize, fontFamily: t.label.style.fontFamily, fontWeight: t.label.style.fontWeight, foreColor: t.label.style.color, cssClass: "apexcharts-xaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "") });
        P.attr({ rel: i }), n.appendChild(P.node), this.annoCtx.helpers.setOrientations(t, i);
      }
    } }, { key: "drawXAxisAnnotations", value: function() {
      var t = this, n = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
      return n.config.annotations.xaxis.map(function(o, d) {
        t.addXaxisAnnotation(o, i.node, d);
      }), i;
    } }]), B;
  }(), je = function() {
    function B(t) {
      C(this, B), this.w = t.w, this.annoCtx = t, this.helpers = new Me(this.annoCtx);
    }
    return F(B, [{ key: "addYaxisAnnotation", value: function(t, n, i) {
      var o, d = this.w, f = t.strokeDashArray, p = this.helpers.getY1Y2("y1", t), y = t.label.text;
      if (t.y2 === null || t.y2 === void 0) {
        var S = this.annoCtx.graphics.drawLine(0 + t.offsetX, p + t.offsetY, this._getYAxisAnnotationWidth(t), p + t.offsetY, t.borderColor, f, t.borderWidth);
        n.appendChild(S.node), t.id && S.node.classList.add(t.id);
      } else {
        if ((o = this.helpers.getY1Y2("y2", t)) > p) {
          var A = p;
          p = o, o = A;
        }
        var E = this.annoCtx.graphics.drawRect(0 + t.offsetX, o + t.offsetY, this._getYAxisAnnotationWidth(t), p - o, 0, t.fillColor, t.opacity, 1, t.borderColor, f);
        E.node.classList.add("apexcharts-annotation-rect"), E.attr("clip-path", "url(#gridRectMask".concat(d.globals.cuid, ")")), n.appendChild(E.node), t.id && E.node.classList.add(t.id);
      }
      var L = t.label.position === "right" ? d.globals.gridWidth : t.label.position === "center" ? d.globals.gridWidth / 2 : 0, O = this.annoCtx.graphics.drawText({ x: L + t.label.offsetX, y: (o ?? p) + t.label.offsetY - 3, text: y, textAnchor: t.label.textAnchor, fontSize: t.label.style.fontSize, fontFamily: t.label.style.fontFamily, fontWeight: t.label.style.fontWeight, foreColor: t.label.style.color, cssClass: "apexcharts-yaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "") });
      O.attr({ rel: i }), n.appendChild(O.node);
    } }, { key: "_getYAxisAnnotationWidth", value: function(t) {
      var n = this.w;
      return n.globals.gridWidth, (t.width.indexOf("%") > -1 ? n.globals.gridWidth * parseInt(t.width, 10) / 100 : parseInt(t.width, 10)) + t.offsetX;
    } }, { key: "drawYAxisAnnotations", value: function() {
      var t = this, n = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
      return n.config.annotations.yaxis.map(function(o, d) {
        t.addYaxisAnnotation(o, i.node, d);
      }), i;
    } }]), B;
  }(), Ve = function() {
    function B(t) {
      C(this, B), this.w = t.w, this.annoCtx = t, this.helpers = new Me(this.annoCtx);
    }
    return F(B, [{ key: "addPointAnnotation", value: function(t, n, i) {
      this.w;
      var o = this.helpers.getX1X2("x1", t), d = this.helpers.getY1Y2("y1", t);
      if (K.isNumber(o)) {
        var f = { pSize: t.marker.size, pointStrokeWidth: t.marker.strokeWidth, pointFillColor: t.marker.fillColor, pointStrokeColor: t.marker.strokeColor, shape: t.marker.shape, pRadius: t.marker.radius, class: "apexcharts-point-annotation-marker ".concat(t.marker.cssClass, " ").concat(t.id ? t.id : "") }, p = this.annoCtx.graphics.drawMarker(o + t.marker.offsetX, d + t.marker.offsetY, f);
        n.appendChild(p.node);
        var y = t.label.text ? t.label.text : "", S = this.annoCtx.graphics.drawText({ x: o + t.label.offsetX, y: d + t.label.offsetY - t.marker.size - parseFloat(t.label.style.fontSize) / 1.6, text: y, textAnchor: t.label.textAnchor, fontSize: t.label.style.fontSize, fontFamily: t.label.style.fontFamily, fontWeight: t.label.style.fontWeight, foreColor: t.label.style.color, cssClass: "apexcharts-point-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "") });
        if (S.attr({ rel: i }), n.appendChild(S.node), t.customSVG.SVG) {
          var A = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + t.customSVG.cssClass });
          A.attr({ transform: "translate(".concat(o + t.customSVG.offsetX, ", ").concat(d + t.customSVG.offsetY, ")") }), A.node.innerHTML = t.customSVG.SVG, n.appendChild(A.node);
        }
        if (t.image.path) {
          var E = t.image.width ? t.image.width : 20, L = t.image.height ? t.image.height : 20;
          p = this.annoCtx.addImage({ x: o + t.image.offsetX - E / 2, y: d + t.image.offsetY - L / 2, width: E, height: L, path: t.image.path, appendTo: ".apexcharts-point-annotations" });
        }
        t.mouseEnter && p.node.addEventListener("mouseenter", t.mouseEnter.bind(this, t)), t.mouseLeave && p.node.addEventListener("mouseleave", t.mouseLeave.bind(this, t)), t.click && p.node.addEventListener("click", t.click.bind(this, t));
      }
    } }, { key: "drawPointAnnotations", value: function() {
      var t = this, n = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
      return n.config.annotations.points.map(function(o, d) {
        t.addPointAnnotation(o, i.node, d);
      }), i;
    } }]), B;
  }(), it = { name: "en", options: { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", exportToCSV: "Download CSV", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } } }, dt = function() {
    function B() {
      C(this, B), this.yAxis = { show: !0, showAlways: !1, showForNullSeries: !0, seriesName: void 0, opposite: !1, reversed: !1, logarithmic: !1, logBase: 10, tickAmount: void 0, forceNiceScale: !1, max: void 0, min: void 0, floating: !1, decimalsInFloat: void 0, labels: { show: !0, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, formatter: void 0 }, axisBorder: { show: !1, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: !1, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: -90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, tooltip: { enabled: !1, offsetX: 0 }, crosshairs: { show: !0, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: void 0, x: 0, y: null, yAxisIndex: 0, seriesIndex: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, radius: 2, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 }, image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: void 0, y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: "100%", yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: void 0, x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: "", textAnchor: "start", foreColor: void 0, fontSize: "13px", fontFamily: void 0, fontWeight: 400, appendTo: ".apexcharts-annotations", backgroundColor: "transparent", borderColor: "#c2c2c2", borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
    }
    return F(B, [{ key: "init", value: function() {
      return { annotations: { yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: !0, easing: "easeinout", speed: 800, animateGradually: { delay: 150, enabled: !0 }, dynamicAnimation: { enabled: !0, speed: 350 } }, background: "transparent", locales: [it], defaultLocale: "en", dropShadow: { enabled: !1, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.35 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, mouseLeave: void 0, xAxisLabelClick: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, beforeResetZoom: void 0, zoomed: void 0, scrolled: void 0, brushScrolled: void 0 }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, redrawOnParentResize: !0, redrawOnWindowResize: !0, id: void 0, group: void 0, offsetX: 0, offsetY: 0, selection: { enabled: !1, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: !1 }, brush: { enabled: !1, autoScaleYaxis: !0, target: void 0, targets: void 0 }, stacked: !1, stackType: "normal", toolbar: { show: !0, offsetX: 0, offsetY: 0, tools: { download: !0, selection: !0, zoom: !0, zoomin: !0, zoomout: !0, pan: !0, reset: !0, customIcons: [] }, export: { csv: { filename: void 0, columnDelimiter: ",", headerCategory: "category", headerValue: "value", dateFormatter: function(t) {
        return new Date(t).toDateString();
      } }, png: { filename: void 0 }, svg: { filename: void 0 } }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: !0, type: "x", autoScaleYaxis: !1, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { area: { fillTo: "origin" }, bar: { horizontal: !1, columnWidth: "70%", barHeight: "70%", distributed: !1, borderRadius: 0, borderRadiusApplication: "around", borderRadiusWhenStacked: "last", rangeBarOverlap: !0, rangeBarGroupRows: !1, hideZeroBarsWhenGrouped: !1, isDumbbell: !1, dumbbellColors: void 0, isFunnel: !1, isFunnel3d: !0, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: "top", maxItems: 100, hideOverflowingLabels: !0, orientation: "horizontal", total: { enabled: !1, formatter: void 0, offsetX: 0, offsetY: 0, style: { color: "#373d3f", fontSize: "12px", fontFamily: void 0, fontWeight: 600 } } } }, bubble: { zScaling: !0, minBubbleRadius: void 0, maxBubbleRadius: void 0 }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: !0 } }, boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } }, heatmap: { radius: 2, enableShades: !0, shadeIntensity: 0.5, reverseNegativeShade: !1, distributed: !1, useFillColorAsStroke: !1, colorScale: { inverse: !1, ranges: [], min: void 0, max: void 0 } }, treemap: { enableShades: !0, shadeIntensity: 0.5, distributed: !1, reverseNegativeShade: !1, useFillColorAsStroke: !1, dataLabels: { format: "scale" }, colorScale: { inverse: !1, ranges: [], min: void 0, max: void 0 } }, radialBar: { inverseOrder: !1, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: !0, position: "front", dropShadow: { enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: !0, startAngle: void 0, endAngle: void 0, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: !0, name: { show: !0, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter: function(t) {
        return t;
      } }, value: { show: !0, fontSize: "14px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter: function(t) {
        return t + "%";
      } }, total: { show: !1, label: "Total", fontSize: "16px", fontWeight: 600, fontFamily: void 0, color: void 0, formatter: function(t) {
        return t.globals.seriesTotals.reduce(function(n, i) {
          return n + i;
        }, 0) / t.globals.series.length + "%";
      } } } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: !0, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: !1, name: { show: !0, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter: function(t) {
        return t;
      } }, value: { show: !0, fontSize: "20px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter: function(t) {
        return t;
      } }, total: { show: !1, showAlways: !1, label: "Total", fontSize: "16px", fontWeight: 400, fontFamily: void 0, color: void 0, formatter: function(t) {
        return t.globals.seriesTotals.reduce(function(n, i) {
          return n + i;
        }, 0);
      } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: "#e8e8e8" }, spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: !0, enabledOnSeries: void 0, formatter: function(t) {
        return t !== null ? t : "";
      }, textAnchor: "middle", distributed: !1, offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0 }, background: { enabled: !0, foreColor: "#fff", borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: "#fff", dropShadow: { enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, dropShadow: { enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.45 } }, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: !0, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 }, grid: { show: !0, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: !1 } }, yaxis: { lines: { show: !0 } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: !0, showForSingleSeries: !1, showForNullSeries: !0, showForZeroSeries: !0, floating: !1, position: "bottom", horizontalAlign: "center", inverseOrder: !1, fontSize: "12px", fontFamily: void 0, fontWeight: 400, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 4, customLegendItems: [], labels: { colors: void 0, useSeriesColors: !1 }, markers: { width: 12, height: 12, strokeWidth: 0, fillColors: void 0, strokeColor: "#fff", radius: 12, customHTML: void 0, offsetX: 0, offsetY: 0, onClick: void 0 }, itemMargin: { horizontal: 5, vertical: 2 }, onItemClick: { toggleDataSeries: !0 }, onItemHover: { highlightDataSeries: !0 } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: "circle", width: 8, height: 8, radius: 2, offsetX: 0, offsetY: 0, onClick: void 0, onDblClick: void 0, showNullDataPoints: !0, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "14px", fontFamily: void 0 } }, responsive: [], series: void 0, states: { normal: { filter: { type: "none", value: 0 } }, hover: { filter: { type: "lighten", value: 0.1 } }, active: { allowMultipleDataPointsSelection: !1, filter: { type: "darken", value: 0.5 } } }, title: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 0, floating: !1, style: { fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 30, floating: !1, style: { fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0 } }, stroke: { show: !0, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: !0, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] } } }, tooltip: { enabled: !0, enabledOnSeries: void 0, shared: !0, followCursor: !1, intersect: !1, inverseOrder: !1, custom: void 0, fillSeriesColor: !1, theme: "light", cssClass: "", style: { fontSize: "12px", fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: !1 }, x: { show: !0, format: "dd MMM", formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(t) {
        return t ? t + ": " : "";
      } } }, z: { formatter: void 0, title: "Size: " }, marker: { show: !0, fillColors: void 0 }, items: { display: "flex" }, fixed: { enabled: !1, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], convertedCatToNumeric: !1, offsetX: 0, offsetY: 0, overwriteCategories: void 0, labels: { show: !0, rotate: -45, rotateAlways: !1, hideOverlappingLabels: !0, trim: !1, minHeight: void 0, maxHeight: 120, showDuplicates: !0, style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeUTC: !0, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss", second: "HH:mm:ss" } }, group: { groups: [], style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" } }, axisBorder: { show: !0, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: !0, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 }, tickAmount: void 0, tickPlacement: "on", min: void 0, max: void 0, range: void 0, floating: !1, decimalsInFloat: void 0, position: "bottom", title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, crosshairs: { show: !0, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: !1, left: 0, top: 0, blur: 1, opacity: 0.4 } }, tooltip: { enabled: !0, offsetY: 0, formatter: void 0, style: { fontSize: "12px", fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: "light", palette: "palette1", monochrome: { enabled: !1, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
    } }]), B;
  }(), Ke = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w, this.graphics = new re(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new Me(this), this.xAxisAnnotations = new et(this), this.yAxisAnnotations = new je(this), this.pointsAnnotations = new Ve(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
    }
    return F(B, [{ key: "drawAxesAnnotations", value: function() {
      var t = this.w;
      if (t.globals.axisCharts) {
        for (var n = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), o = this.pointsAnnotations.drawPointAnnotations(), d = t.config.chart.animations.enabled, f = [n, i, o], p = [i.node, n.node, o.node], y = 0; y < 3; y++)
          t.globals.dom.elGraphical.add(f[y]), !d || t.globals.resized || t.globals.dataChanged || t.config.chart.type !== "scatter" && t.config.chart.type !== "bubble" && t.globals.dataPoints > 1 && p[y].classList.add("apexcharts-element-hidden"), t.globals.delayedElements.push({ el: p[y], index: 0 });
        this.helpers.annotationsBackground();
      }
    } }, { key: "drawImageAnnos", value: function() {
      var t = this;
      this.w.config.annotations.images.map(function(n, i) {
        t.addImage(n, i);
      });
    } }, { key: "drawTextAnnos", value: function() {
      var t = this;
      this.w.config.annotations.texts.map(function(n, i) {
        t.addText(n, i);
      });
    } }, { key: "addXaxisAnnotation", value: function(t, n, i) {
      this.xAxisAnnotations.addXaxisAnnotation(t, n, i);
    } }, { key: "addYaxisAnnotation", value: function(t, n, i) {
      this.yAxisAnnotations.addYaxisAnnotation(t, n, i);
    } }, { key: "addPointAnnotation", value: function(t, n, i) {
      this.pointsAnnotations.addPointAnnotation(t, n, i);
    } }, { key: "addText", value: function(t, n) {
      var i = t.x, o = t.y, d = t.text, f = t.textAnchor, p = t.foreColor, y = t.fontSize, S = t.fontFamily, A = t.fontWeight, E = t.cssClass, L = t.backgroundColor, O = t.borderWidth, P = t.strokeDashArray, I = t.borderRadius, j = t.borderColor, V = t.appendTo, Z = V === void 0 ? ".apexcharts-annotations" : V, b = t.paddingLeft, M = b === void 0 ? 4 : b, N = t.paddingRight, X = N === void 0 ? 4 : N, Q = t.paddingBottom, ee = Q === void 0 ? 2 : Q, oe = t.paddingTop, fe = oe === void 0 ? 2 : oe, ke = this.w, _e = this.graphics.drawText({ x: i, y: o, text: d, textAnchor: f || "start", fontSize: y || "12px", fontWeight: A || "regular", fontFamily: S || ke.config.chart.fontFamily, foreColor: p || ke.config.chart.foreColor, cssClass: E }), Le = ke.globals.dom.baseEl.querySelector(Z);
      Le && Le.appendChild(_e.node);
      var Ie = _e.bbox();
      if (d) {
        var at = this.graphics.drawRect(Ie.x - M, Ie.y - fe, Ie.width + M + X, Ie.height + ee + fe, I, L || "transparent", 1, O, j, P);
        Le.insertBefore(at.node, _e.node);
      }
    } }, { key: "addImage", value: function(t, n) {
      var i = this.w, o = t.path, d = t.x, f = d === void 0 ? 0 : d, p = t.y, y = p === void 0 ? 0 : p, S = t.width, A = S === void 0 ? 20 : S, E = t.height, L = E === void 0 ? 20 : E, O = t.appendTo, P = O === void 0 ? ".apexcharts-annotations" : O, I = i.globals.dom.Paper.image(o);
      I.size(A, L).move(f, y);
      var j = i.globals.dom.baseEl.querySelector(P);
      return j && j.appendChild(I.node), I;
    } }, { key: "addXaxisAnnotationExternal", value: function(t, n, i) {
      return this.addAnnotationExternal({ params: t, pushToMemory: n, context: i, type: "xaxis", contextMethod: i.addXaxisAnnotation }), i;
    } }, { key: "addYaxisAnnotationExternal", value: function(t, n, i) {
      return this.addAnnotationExternal({ params: t, pushToMemory: n, context: i, type: "yaxis", contextMethod: i.addYaxisAnnotation }), i;
    } }, { key: "addPointAnnotationExternal", value: function(t, n, i) {
      return this.invertAxis === void 0 && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: t, pushToMemory: n, context: i, type: "point", contextMethod: i.addPointAnnotation }), i;
    } }, { key: "addAnnotationExternal", value: function(t) {
      var n = t.params, i = t.pushToMemory, o = t.context, d = t.type, f = t.contextMethod, p = o, y = p.w, S = y.globals.dom.baseEl.querySelector(".apexcharts-".concat(d, "-annotations")), A = S.childNodes.length + 1, E = new dt(), L = Object.assign({}, d === "xaxis" ? E.xAxisAnnotation : d === "yaxis" ? E.yAxisAnnotation : E.pointAnnotation), O = K.extend(L, n);
      switch (d) {
        case "xaxis":
          this.addXaxisAnnotation(O, S, A);
          break;
        case "yaxis":
          this.addYaxisAnnotation(O, S, A);
          break;
        case "point":
          this.addPointAnnotation(O, S, A);
      }
      var P = y.globals.dom.baseEl.querySelector(".apexcharts-".concat(d, "-annotations .apexcharts-").concat(d, "-annotation-label[rel='").concat(A, "']")), I = this.helpers.addBackgroundToAnno(P, O);
      return I && S.insertBefore(I.node, P), i && y.globals.memory.methodsToExec.push({ context: p, id: O.id ? O.id : K.randomId(), method: f, label: "addAnnotation", params: n }), o;
    } }, { key: "clearAnnotations", value: function(t) {
      var n = t.w, i = n.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
      n.globals.memory.methodsToExec.map(function(o, d) {
        o.label !== "addText" && o.label !== "addAnnotation" || n.globals.memory.methodsToExec.splice(d, 1);
      }), i = K.listToArray(i), Array.prototype.forEach.call(i, function(o) {
        for (; o.firstChild; )
          o.removeChild(o.firstChild);
      });
    } }, { key: "removeAnnotation", value: function(t, n) {
      var i = t.w, o = i.globals.dom.baseEl.querySelectorAll(".".concat(n));
      o && (i.globals.memory.methodsToExec.map(function(d, f) {
        d.id === n && i.globals.memory.methodsToExec.splice(f, 1);
      }), Array.prototype.forEach.call(o, function(d) {
        d.parentElement.removeChild(d);
      }));
    } }]), B;
  }(), Ze = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    }
    return F(B, [{ key: "isValidDate", value: function(t) {
      return !isNaN(this.parseDate(t));
    } }, { key: "getTimeStamp", value: function(t) {
      return Date.parse(t) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toISOString().substr(0, 25)).getTime() : new Date(t).getTime() : t;
    } }, { key: "getDate", value: function(t) {
      return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toUTCString()) : new Date(t);
    } }, { key: "parseDate", value: function(t) {
      var n = Date.parse(t);
      if (!isNaN(n))
        return this.getTimeStamp(t);
      var i = Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
      return i = this.getTimeStamp(i);
    } }, { key: "parseDateWithTimezone", value: function(t) {
      return Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
    } }, { key: "formatDate", value: function(t, n) {
      var i = this.w.globals.locale, o = this.w.config.xaxis.labels.datetimeUTC, d = ["\0"].concat(ue(i.months)), f = [""].concat(ue(i.shortMonths)), p = [""].concat(ue(i.days)), y = [""].concat(ue(i.shortDays));
      function S(ee, oe) {
        var fe = ee + "";
        for (oe = oe || 2; fe.length < oe; )
          fe = "0" + fe;
        return fe;
      }
      var A = o ? t.getUTCFullYear() : t.getFullYear();
      n = (n = (n = n.replace(/(^|[^\\])yyyy+/g, "$1" + A)).replace(/(^|[^\\])yy/g, "$1" + A.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + A);
      var E = (o ? t.getUTCMonth() : t.getMonth()) + 1;
      n = (n = (n = (n = n.replace(/(^|[^\\])MMMM+/g, "$1" + d[0])).replace(/(^|[^\\])MMM/g, "$1" + f[0])).replace(/(^|[^\\])MM/g, "$1" + S(E))).replace(/(^|[^\\])M/g, "$1" + E);
      var L = o ? t.getUTCDate() : t.getDate();
      n = (n = (n = (n = n.replace(/(^|[^\\])dddd+/g, "$1" + p[0])).replace(/(^|[^\\])ddd/g, "$1" + y[0])).replace(/(^|[^\\])dd/g, "$1" + S(L))).replace(/(^|[^\\])d/g, "$1" + L);
      var O = o ? t.getUTCHours() : t.getHours(), P = O > 12 ? O - 12 : O === 0 ? 12 : O;
      n = (n = (n = (n = n.replace(/(^|[^\\])HH+/g, "$1" + S(O))).replace(/(^|[^\\])H/g, "$1" + O)).replace(/(^|[^\\])hh+/g, "$1" + S(P))).replace(/(^|[^\\])h/g, "$1" + P);
      var I = o ? t.getUTCMinutes() : t.getMinutes();
      n = (n = n.replace(/(^|[^\\])mm+/g, "$1" + S(I))).replace(/(^|[^\\])m/g, "$1" + I);
      var j = o ? t.getUTCSeconds() : t.getSeconds();
      n = (n = n.replace(/(^|[^\\])ss+/g, "$1" + S(j))).replace(/(^|[^\\])s/g, "$1" + j);
      var V = o ? t.getUTCMilliseconds() : t.getMilliseconds();
      n = n.replace(/(^|[^\\])fff+/g, "$1" + S(V, 3)), V = Math.round(V / 10), n = n.replace(/(^|[^\\])ff/g, "$1" + S(V)), V = Math.round(V / 10);
      var Z = O < 12 ? "AM" : "PM";
      n = (n = (n = n.replace(/(^|[^\\])f/g, "$1" + V)).replace(/(^|[^\\])TT+/g, "$1" + Z)).replace(/(^|[^\\])T/g, "$1" + Z.charAt(0));
      var b = Z.toLowerCase();
      n = (n = n.replace(/(^|[^\\])tt+/g, "$1" + b)).replace(/(^|[^\\])t/g, "$1" + b.charAt(0));
      var M = -t.getTimezoneOffset(), N = o || !M ? "Z" : M > 0 ? "+" : "-";
      if (!o) {
        var X = (M = Math.abs(M)) % 60;
        N += S(Math.floor(M / 60)) + ":" + S(X);
      }
      n = n.replace(/(^|[^\\])K/g, "$1" + N);
      var Q = (o ? t.getUTCDay() : t.getDay()) + 1;
      return n = (n = (n = (n = (n = n.replace(new RegExp(p[0], "g"), p[Q])).replace(new RegExp(y[0], "g"), y[Q])).replace(new RegExp(d[0], "g"), d[E])).replace(new RegExp(f[0], "g"), f[E])).replace(/\\(.)/g, "$1");
    } }, { key: "getTimeUnitsfromTimestamp", value: function(t, n, i) {
      var o = this.w;
      o.config.xaxis.min !== void 0 && (t = o.config.xaxis.min), o.config.xaxis.max !== void 0 && (n = o.config.xaxis.max);
      var d = this.getDate(t), f = this.getDate(n), p = this.formatDate(d, "yyyy MM dd HH mm ss fff").split(" "), y = this.formatDate(f, "yyyy MM dd HH mm ss fff").split(" ");
      return { minMillisecond: parseInt(p[6], 10), maxMillisecond: parseInt(y[6], 10), minSecond: parseInt(p[5], 10), maxSecond: parseInt(y[5], 10), minMinute: parseInt(p[4], 10), maxMinute: parseInt(y[4], 10), minHour: parseInt(p[3], 10), maxHour: parseInt(y[3], 10), minDate: parseInt(p[2], 10), maxDate: parseInt(y[2], 10), minMonth: parseInt(p[1], 10) - 1, maxMonth: parseInt(y[1], 10) - 1, minYear: parseInt(p[0], 10), maxYear: parseInt(y[0], 10) };
    } }, { key: "isLeapYear", value: function(t) {
      return t % 4 == 0 && t % 100 != 0 || t % 400 == 0;
    } }, { key: "calculcateLastDaysOfMonth", value: function(t, n, i) {
      return this.determineDaysOfMonths(t, n) - i;
    } }, { key: "determineDaysOfYear", value: function(t) {
      var n = 365;
      return this.isLeapYear(t) && (n = 366), n;
    } }, { key: "determineRemainingDaysOfYear", value: function(t, n, i) {
      var o = this.daysCntOfYear[n] + i;
      return n > 1 && this.isLeapYear() && o++, o;
    } }, { key: "determineDaysOfMonths", value: function(t, n) {
      var i = 30;
      switch (t = K.monthMod(t), !0) {
        case this.months30.indexOf(t) > -1:
          t === 2 && (i = this.isLeapYear(n) ? 29 : 28);
          break;
        case this.months31.indexOf(t) > -1:
        default:
          i = 31;
      }
      return i;
    } }]), B;
  }(), Vt = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w, this.tooltipKeyFormat = "dd MMM";
    }
    return F(B, [{ key: "xLabelFormat", value: function(t, n, i, o) {
      var d = this.w;
      if (d.config.xaxis.type === "datetime" && d.config.xaxis.labels.formatter === void 0 && d.config.tooltip.x.formatter === void 0) {
        var f = new Ze(this.ctx);
        return f.formatDate(f.getDate(n), d.config.tooltip.x.format);
      }
      return t(n, i, o);
    } }, { key: "defaultGeneralFormatter", value: function(t) {
      return Array.isArray(t) ? t.map(function(n) {
        return n;
      }) : t;
    } }, { key: "defaultYFormatter", value: function(t, n, i) {
      var o = this.w;
      return K.isNumber(t) && (t = o.globals.yValueDecimal !== 0 ? t.toFixed(n.decimalsInFloat !== void 0 ? n.decimalsInFloat : o.globals.yValueDecimal) : o.globals.maxYArr[i] - o.globals.minYArr[i] < 5 ? t.toFixed(1) : t.toFixed(0)), t;
    } }, { key: "setLabelFormatters", value: function() {
      var t = this, n = this.w;
      return n.globals.xaxisTooltipFormatter = function(i) {
        return t.defaultGeneralFormatter(i);
      }, n.globals.ttKeyFormatter = function(i) {
        return t.defaultGeneralFormatter(i);
      }, n.globals.ttZFormatter = function(i) {
        return i;
      }, n.globals.legendFormatter = function(i) {
        return t.defaultGeneralFormatter(i);
      }, n.config.xaxis.labels.formatter !== void 0 ? n.globals.xLabelFormatter = n.config.xaxis.labels.formatter : n.globals.xLabelFormatter = function(i) {
        if (K.isNumber(i)) {
          if (!n.config.xaxis.convertedCatToNumeric && n.config.xaxis.type === "numeric") {
            if (K.isNumber(n.config.xaxis.decimalsInFloat))
              return i.toFixed(n.config.xaxis.decimalsInFloat);
            var o = n.globals.maxX - n.globals.minX;
            return o > 0 && o < 100 ? i.toFixed(1) : i.toFixed(0);
          }
          return n.globals.isBarHorizontal && n.globals.maxY - n.globals.minYArr < 4 ? i.toFixed(1) : i.toFixed(0);
        }
        return i;
      }, typeof n.config.tooltip.x.formatter == "function" ? n.globals.ttKeyFormatter = n.config.tooltip.x.formatter : n.globals.ttKeyFormatter = n.globals.xLabelFormatter, typeof n.config.xaxis.tooltip.formatter == "function" && (n.globals.xaxisTooltipFormatter = n.config.xaxis.tooltip.formatter), (Array.isArray(n.config.tooltip.y) || n.config.tooltip.y.formatter !== void 0) && (n.globals.ttVal = n.config.tooltip.y), n.config.tooltip.z.formatter !== void 0 && (n.globals.ttZFormatter = n.config.tooltip.z.formatter), n.config.legend.formatter !== void 0 && (n.globals.legendFormatter = n.config.legend.formatter), n.config.yaxis.forEach(function(i, o) {
        i.labels.formatter !== void 0 ? n.globals.yLabelFormatters[o] = i.labels.formatter : n.globals.yLabelFormatters[o] = function(d) {
          return n.globals.xyCharts ? Array.isArray(d) ? d.map(function(f) {
            return t.defaultYFormatter(f, i, o);
          }) : t.defaultYFormatter(d, i, o) : d;
        };
      }), n.globals;
    } }, { key: "heatmapLabelFormatters", value: function() {
      var t = this.w;
      if (t.config.chart.type === "heatmap") {
        t.globals.yAxisScale[0].result = t.globals.seriesNames.slice();
        var n = t.globals.seriesNames.reduce(function(i, o) {
          return i.length > o.length ? i : o;
        }, 0);
        t.globals.yAxisScale[0].niceMax = n, t.globals.yAxisScale[0].niceMin = n;
      }
    } }]), B;
  }(), Et = function(B) {
    var t, n = B.isTimeline, i = B.ctx, o = B.seriesIndex, d = B.dataPointIndex, f = B.y1, p = B.y2, y = B.w, S = y.globals.seriesRangeStart[o][d], A = y.globals.seriesRangeEnd[o][d], E = y.globals.labels[d], L = y.config.series[o].name ? y.config.series[o].name : "", O = y.globals.ttKeyFormatter, P = y.config.tooltip.y.title.formatter, I = { w: y, seriesIndex: o, dataPointIndex: d, start: S, end: A };
    typeof P == "function" && (L = P(L, I)), (t = y.config.series[o].data[d]) !== null && t !== void 0 && t.x && (E = y.config.series[o].data[d].x), n || y.config.xaxis.type === "datetime" && (E = new Vt(i).xLabelFormat(y.globals.ttKeyFormatter, E, E, { i: void 0, dateFormatter: new Ze(i).formatDate, w: y })), typeof O == "function" && (E = O(E, I)), Number.isFinite(f) && Number.isFinite(p) && (S = f, A = p);
    var j = "", V = "", Z = y.globals.colors[o];
    if (y.config.tooltip.x.formatter === void 0)
      if (y.config.xaxis.type === "datetime") {
        var b = new Ze(i);
        j = b.formatDate(b.getDate(S), y.config.tooltip.x.format), V = b.formatDate(b.getDate(A), y.config.tooltip.x.format);
      } else
        j = S, V = A;
    else
      j = y.config.tooltip.x.formatter(S), V = y.config.tooltip.x.formatter(A);
    return { start: S, end: A, startVal: j, endVal: V, ylabel: E, color: Z, seriesName: L };
  }, an = function(B) {
    var t = B.color, n = B.seriesName, i = B.ylabel, o = B.start, d = B.end, f = B.seriesIndex, p = B.dataPointIndex, y = B.ctx.tooltip.tooltipLabels.getFormatters(f);
    o = y.yLbFormatter(o), d = y.yLbFormatter(d);
    var S = y.yLbFormatter(B.w.globals.series[f][p]), A = `<span class="value start-value">
  `.concat(o, `
  </span> <span class="separator">-</span> <span class="value end-value">
  `).concat(d, `
  </span>`);
    return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + t + '">' + (n || "") + '</span></div><div> <span class="category">' + i + ": </span> " + (B.w.globals.comboCharts ? B.w.config.series[f].type === "rangeArea" || B.w.config.series[f].type === "rangeBar" ? A : "<span>".concat(S, "</span>") : A) + " </div></div>";
  }, We = function() {
    function B(t) {
      C(this, B), this.opts = t;
    }
    return F(B, [{ key: "hideYAxis", value: function() {
      this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0;
    } }, { key: "line", value: function() {
      return { chart: { animations: { easing: "swing" } }, dataLabels: { enabled: !1 }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "sparkline", value: function(t) {
      return this.hideYAxis(), K.extend(t, { grid: { show: !1, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: !1 }, xaxis: { labels: { show: !1 }, tooltip: { enabled: !1 }, axisBorder: { show: !1 }, axisTicks: { show: !1 } }, chart: { toolbar: { show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !1 } });
    } }, { key: "bar", value: function() {
      return { chart: { stacked: !1, animations: { easing: "swing" } }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] }, background: { enabled: !1 } }, stroke: { width: 0, lineCap: "round" }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square", radius: 2, size: 8 } }, tooltip: { shared: !1, intersect: !0 }, xaxis: { tooltip: { enabled: !1 }, tickPlacement: "between", crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: !1 }, stroke: { width: 0 } } } };
    } }, { key: "funnel", value: function() {
      return this.hideYAxis(), v(v({}, this.bar()), {}, { chart: { animations: { easing: "linear", speed: 800, animateGradually: { enabled: !1 } } }, plotOptions: { bar: { horizontal: !0, borderRadiusApplication: "around", borderRadius: 0, dataLabels: { position: "center" } } }, grid: { show: !1, padding: { left: 0, right: 0 } }, xaxis: { labels: { show: !1 }, tooltip: { enabled: !1 }, axisBorder: { show: !1 }, axisTicks: { show: !1 } } });
    } }, { key: "candlestick", value: function() {
      var t = this;
      return { stroke: { width: 1, colors: ["#333"] }, fill: { opacity: 1 }, dataLabels: { enabled: !1 }, tooltip: { shared: !0, custom: function(n) {
        var i = n.seriesIndex, o = n.dataPointIndex, d = n.w;
        return t._getBoxTooltip(d, i, o, ["Open", "High", "", "Low", "Close"], "candlestick");
      } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "boxPlot", value: function() {
      var t = this;
      return { chart: { animations: { dynamicAnimation: { enabled: !1 } } }, stroke: { width: 1, colors: ["#24292e"] }, dataLabels: { enabled: !1 }, tooltip: { shared: !0, custom: function(n) {
        var i = n.seriesIndex, o = n.dataPointIndex, d = n.w;
        return t._getBoxTooltip(d, i, o, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
      } }, markers: { size: 5, strokeWidth: 1, strokeColors: "#111" }, xaxis: { crosshairs: { width: 1 } } };
    } }, { key: "rangeBar", value: function() {
      return { chart: { animations: { animateGradually: !1 } }, stroke: { width: 0, lineCap: "square" }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } }, dataLabels: { enabled: !1, formatter: function(t, n) {
        n.ctx;
        var i = n.seriesIndex, o = n.dataPointIndex, d = n.w, f = function() {
          var p = d.globals.seriesRangeStart[i][o];
          return d.globals.seriesRangeEnd[i][o] - p;
        };
        return d.globals.comboCharts ? d.config.series[i].type === "rangeBar" || d.config.series[i].type === "rangeArea" ? f() : t : f();
      }, background: { enabled: !1 }, style: { colors: ["#fff"] } }, markers: { size: 10 }, tooltip: { shared: !1, followCursor: !0, custom: function(t) {
        return t.w.config.plotOptions && t.w.config.plotOptions.bar && t.w.config.plotOptions.bar.horizontal ? function(n) {
          var i = Et(v(v({}, n), {}, { isTimeline: !0 })), o = i.color, d = i.seriesName, f = i.ylabel, p = i.startVal, y = i.endVal;
          return an(v(v({}, n), {}, { color: o, seriesName: d, ylabel: f, start: p, end: y }));
        }(t) : function(n) {
          var i = Et(n), o = i.color, d = i.seriesName, f = i.ylabel, p = i.start, y = i.end;
          return an(v(v({}, n), {}, { color: o, seriesName: d, ylabel: f, start: p, end: y }));
        }(t);
      } }, xaxis: { tickPlacement: "between", tooltip: { enabled: !1 }, crosshairs: { stroke: { width: 0 } } } };
    } }, { key: "dumbbell", value: function(t) {
      var n, i;
      return (n = t.plotOptions.bar) !== null && n !== void 0 && n.barHeight || (t.plotOptions.bar.barHeight = 2), (i = t.plotOptions.bar) !== null && i !== void 0 && i.columnWidth || (t.plotOptions.bar.columnWidth = 2), t;
    } }, { key: "area", value: function() {
      return { stroke: { width: 4, fill: { type: "solid", gradient: { inverseColors: !1, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } } }, fill: { type: "gradient", gradient: { inverseColors: !1, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: !1 } };
    } }, { key: "rangeArea", value: function() {
      return { stroke: { curve: "straight", width: 0 }, fill: { type: "solid", opacity: 0.6 }, markers: { size: 0 }, states: { hover: { filter: { type: "none" } }, active: { filter: { type: "none" } } }, tooltip: { intersect: !1, shared: !0, followCursor: !0, custom: function(t) {
        return function(n) {
          var i = Et(n), o = i.color, d = i.seriesName, f = i.ylabel, p = i.start, y = i.end;
          return an(v(v({}, n), {}, { color: o, seriesName: d, ylabel: f, start: p, end: y }));
        }(t);
      } } };
    } }, { key: "brush", value: function(t) {
      return K.extend(t, { chart: { toolbar: { autoSelected: "selection", show: !1 }, zoom: { enabled: !1 } }, dataLabels: { enabled: !1 }, stroke: { width: 1 }, tooltip: { enabled: !1 }, xaxis: { tooltip: { enabled: !1 } } });
    } }, { key: "stacked100", value: function(t) {
      t.dataLabels = t.dataLabels || {}, t.dataLabels.formatter = t.dataLabels.formatter || void 0;
      var n = t.dataLabels.formatter;
      return t.yaxis.forEach(function(i, o) {
        t.yaxis[o].min = 0, t.yaxis[o].max = 100;
      }), t.chart.type === "bar" && (t.dataLabels.formatter = n || function(i) {
        return typeof i == "number" && i ? i.toFixed(0) + "%" : i;
      }), t;
    } }, { key: "stackedBars", value: function() {
      var t = this.bar();
      return v(v({}, t), {}, { plotOptions: v(v({}, t.plotOptions), {}, { bar: v(v({}, t.plotOptions.bar), {}, { borderRadiusApplication: "end", borderRadiusWhenStacked: "last" }) }) });
    } }, { key: "convertCatToNumeric", value: function(t) {
      return t.xaxis.convertedCatToNumeric = !0, t;
    } }, { key: "convertCatToNumericXaxis", value: function(t, n, i) {
      t.xaxis.type = "numeric", t.xaxis.labels = t.xaxis.labels || {}, t.xaxis.labels.formatter = t.xaxis.labels.formatter || function(f) {
        return K.isNumber(f) ? Math.floor(f) : f;
      };
      var o = t.xaxis.labels.formatter, d = t.xaxis.categories && t.xaxis.categories.length ? t.xaxis.categories : t.labels;
      return i && i.length && (d = i.map(function(f) {
        return Array.isArray(f) ? f : String(f);
      })), d && d.length && (t.xaxis.labels.formatter = function(f) {
        return K.isNumber(f) ? o(d[Math.floor(f) - 1]) : o(f);
      }), t.xaxis.categories = [], t.labels = [], t.xaxis.tickAmount = t.xaxis.tickAmount || "dataPoints", t;
    } }, { key: "bubble", value: function() {
      return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: !1, intersect: !0 }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: !0, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
    } }, { key: "scatter", value: function() {
      return { dataLabels: { enabled: !1 }, tooltip: { shared: !1, intersect: !0 }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
    } }, { key: "heatmap", value: function() {
      return { chart: { stacked: !1 }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: !0, marker: { show: !1 }, x: { show: !1 } }, legend: { position: "top", markers: { shape: "square", size: 10, offsetY: 2 } }, grid: { padding: { right: 20 } } };
    } }, { key: "treemap", value: function() {
      return { chart: { zoom: { enabled: !1 } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } }, stroke: { show: !0, width: 2, colors: ["#fff"] }, legend: { show: !1 }, fill: { gradient: { stops: [0, 100] } }, tooltip: { followCursor: !0, x: { show: !1 } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: !1 }, tooltip: { enabled: !1 } } };
    } }, { key: "pie", value: function() {
      return { chart: { toolbar: { show: !1 } }, plotOptions: { pie: { donut: { labels: { show: !1 } } } }, dataLabels: { formatter: function(t) {
        return t.toFixed(1) + "%";
      }, style: { colors: ["#fff"] }, background: { enabled: !1 }, dropShadow: { enabled: !0 } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" } };
    } }, { key: "donut", value: function() {
      return { chart: { toolbar: { show: !1 } }, dataLabels: { formatter: function(t) {
        return t.toFixed(1) + "%";
      }, style: { colors: ["#fff"] }, background: { enabled: !1 }, dropShadow: { enabled: !0 } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" } };
    } }, { key: "polarArea", value: function() {
      return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6, { chart: { toolbar: { show: !1 } }, dataLabels: { formatter: function(t) {
        return t.toFixed(1) + "%";
      }, enabled: !1 }, stroke: { show: !0, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: "dark", fillSeriesColor: !0 }, legend: { position: "right" } };
    } }, { key: "radar", value: function() {
      return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: !1, style: { fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 3, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: !1, intersect: !0, followCursor: !0 }, grid: { show: !1 }, xaxis: { labels: { formatter: function(t) {
        return t;
      }, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, tooltip: { enabled: !1 }, crosshairs: { show: !1 } } };
    } }, { key: "radialBar", value: function() {
      return { chart: { animations: { dynamicAnimation: { enabled: !0, speed: 800 } }, toolbar: { show: !1 } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: !1, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: !1, position: "right" }, tooltip: { enabled: !1, fillSeriesColor: !0 } };
    } }, { key: "_getBoxTooltip", value: function(t, n, i, o, d) {
      var f = t.globals.seriesCandleO[n][i], p = t.globals.seriesCandleH[n][i], y = t.globals.seriesCandleM[n][i], S = t.globals.seriesCandleL[n][i], A = t.globals.seriesCandleC[n][i];
      return t.config.series[n].type && t.config.series[n].type !== d ? `<div class="apexcharts-custom-tooltip">
          `.concat(t.config.series[n].name ? t.config.series[n].name : "series-" + (n + 1), ": <strong>").concat(t.globals.series[n][i], `</strong>
        </div>`) : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t.config.chart.type, '">') + "<div>".concat(o[0], ': <span class="value">') + f + "</span></div>" + "<div>".concat(o[1], ': <span class="value">') + p + "</span></div>" + (y ? "<div>".concat(o[2], ': <span class="value">') + y + "</span></div>" : "") + "<div>".concat(o[3], ': <span class="value">') + S + "</span></div>" + "<div>".concat(o[4], ': <span class="value">') + A + "</span></div></div>";
    } }]), B;
  }(), ft = function() {
    function B(t) {
      C(this, B), this.opts = t;
    }
    return F(B, [{ key: "init", value: function(t) {
      var n = t.responsiveOverride, i = this.opts, o = new dt(), d = new We(i);
      this.chartType = i.chart.type, i = this.extendYAxis(i), i = this.extendAnnotations(i);
      var f = o.init(), p = {};
      if (i && w(i) === "object") {
        var y, S, A, E, L, O, P, I, j = {};
        j = ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(i.chart.type) !== -1 ? d[i.chart.type]() : d.line(), (y = i.plotOptions) !== null && y !== void 0 && (S = y.bar) !== null && S !== void 0 && S.isFunnel && (j = d.funnel()), i.chart.stacked && i.chart.type === "bar" && (j = d.stackedBars()), (A = i.chart.brush) !== null && A !== void 0 && A.enabled && (j = d.brush(j)), i.chart.stacked && i.chart.stackType === "100%" && (i = d.stacked100(i)), (E = i.plotOptions) !== null && E !== void 0 && (L = E.bar) !== null && L !== void 0 && L.isDumbbell && (i = d.dumbbell(i)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(i), i.xaxis = i.xaxis || window.Apex.xaxis || {}, n || (i.xaxis.convertedCatToNumeric = !1), ((O = (i = this.checkForCatToNumericXAxis(this.chartType, j, i)).chart.sparkline) !== null && O !== void 0 && O.enabled || (P = window.Apex.chart) !== null && P !== void 0 && (I = P.sparkline) !== null && I !== void 0 && I.enabled) && (j = d.sparkline(j)), p = K.extend(f, j);
      }
      var V = K.extend(p, window.Apex);
      return f = K.extend(V, i), f = this.handleUserInputErrors(f);
    } }, { key: "checkForCatToNumericXAxis", value: function(t, n, i) {
      var o, d, f = new We(i), p = (t === "bar" || t === "boxPlot") && ((o = i.plotOptions) === null || o === void 0 || (d = o.bar) === null || d === void 0 ? void 0 : d.horizontal), y = t === "pie" || t === "polarArea" || t === "donut" || t === "radar" || t === "radialBar" || t === "heatmap", S = i.xaxis.type !== "datetime" && i.xaxis.type !== "numeric", A = i.xaxis.tickPlacement ? i.xaxis.tickPlacement : n.xaxis && n.xaxis.tickPlacement;
      return p || y || !S || A === "between" || (i = f.convertCatToNumeric(i)), i;
    } }, { key: "extendYAxis", value: function(t, n) {
      var i = new dt();
      (t.yaxis === void 0 || !t.yaxis || Array.isArray(t.yaxis) && t.yaxis.length === 0) && (t.yaxis = {}), t.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t.yaxis = K.extend(t.yaxis, window.Apex.yaxis)), t.yaxis.constructor !== Array ? t.yaxis = [K.extend(i.yAxis, t.yaxis)] : t.yaxis = K.extendArray(t.yaxis, i.yAxis);
      var o = !1;
      t.yaxis.forEach(function(f) {
        f.logarithmic && (o = !0);
      });
      var d = t.series;
      return n && !d && (d = n.config.series), o && d.length !== t.yaxis.length && d.length && (t.yaxis = d.map(function(f, p) {
        if (f.name || (d[p].name = "series-".concat(p + 1)), t.yaxis[p])
          return t.yaxis[p].seriesName = d[p].name, t.yaxis[p];
        var y = K.extend(i.yAxis, t.yaxis[0]);
        return y.show = !1, y;
      })), o && d.length > 1 && d.length !== t.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes. Please make sure to equalize both."), t;
    } }, { key: "extendAnnotations", value: function(t) {
      return t.annotations === void 0 && (t.annotations = {}, t.annotations.yaxis = [], t.annotations.xaxis = [], t.annotations.points = []), t = this.extendYAxisAnnotations(t), t = this.extendXAxisAnnotations(t), t = this.extendPointAnnotations(t);
    } }, { key: "extendYAxisAnnotations", value: function(t) {
      var n = new dt();
      return t.annotations.yaxis = K.extendArray(t.annotations.yaxis !== void 0 ? t.annotations.yaxis : [], n.yAxisAnnotation), t;
    } }, { key: "extendXAxisAnnotations", value: function(t) {
      var n = new dt();
      return t.annotations.xaxis = K.extendArray(t.annotations.xaxis !== void 0 ? t.annotations.xaxis : [], n.xAxisAnnotation), t;
    } }, { key: "extendPointAnnotations", value: function(t) {
      var n = new dt();
      return t.annotations.points = K.extendArray(t.annotations.points !== void 0 ? t.annotations.points : [], n.pointAnnotation), t;
    } }, { key: "checkForDarkTheme", value: function(t) {
      t.theme && t.theme.mode === "dark" && (t.tooltip || (t.tooltip = {}), t.tooltip.theme !== "light" && (t.tooltip.theme = "dark"), t.chart.foreColor || (t.chart.foreColor = "#f6f7f8"), t.chart.background || (t.chart.background = "#424242"), t.theme.palette || (t.theme.palette = "palette4"));
    } }, { key: "handleUserInputErrors", value: function(t) {
      var n = t;
      if (n.tooltip.shared && n.tooltip.intersect)
        throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
      if (n.chart.type === "bar" && n.plotOptions.bar.horizontal) {
        if (n.yaxis.length > 1)
          throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
        n.yaxis[0].reversed && (n.yaxis[0].opposite = !0), n.xaxis.tooltip.enabled = !1, n.yaxis[0].tooltip.enabled = !1, n.chart.zoom.enabled = !1;
      }
      return n.chart.type !== "bar" && n.chart.type !== "rangeBar" || n.tooltip.shared && n.xaxis.crosshairs.width === "barWidth" && n.series.length > 1 && (n.xaxis.crosshairs.width = "tickWidth"), n.chart.type !== "candlestick" && n.chart.type !== "boxPlot" || n.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(n.chart.type, " chart is not supported.")), n.yaxis[0].reversed = !1), n;
    } }]), B;
  }(), ye = function() {
    function B() {
      C(this, B);
    }
    return F(B, [{ key: "initGlobalVars", value: function(t) {
      t.series = [], t.seriesCandleO = [], t.seriesCandleH = [], t.seriesCandleM = [], t.seriesCandleL = [], t.seriesCandleC = [], t.seriesRangeStart = [], t.seriesRangeEnd = [], t.seriesRange = [], t.seriesPercent = [], t.seriesGoals = [], t.seriesX = [], t.seriesZ = [], t.seriesNames = [], t.seriesTotals = [], t.seriesLog = [], t.seriesColors = [], t.stackedSeriesTotals = [], t.seriesXvalues = [], t.seriesYvalues = [], t.labels = [], t.hasXaxisGroups = !1, t.groups = [], t.hasSeriesGroups = !1, t.seriesGroups = [], t.categoryLabels = [], t.timescaleLabels = [], t.noLabelsProvided = !1, t.resizeTimer = null, t.selectionResizeTimer = null, t.delayedElements = [], t.pointsArray = [], t.dataLabelsRects = [], t.isXNumeric = !1, t.skipLastTimelinelabel = !1, t.skipFirstTimelinelabel = !1, t.isDataXYZ = !1, t.isMultiLineX = !1, t.isMultipleYAxis = !1, t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE, t.minYArr = [], t.maxYArr = [], t.maxX = -Number.MAX_VALUE, t.minX = Number.MAX_VALUE, t.initialMaxX = -Number.MAX_VALUE, t.initialMinX = Number.MAX_VALUE, t.maxDate = 0, t.minDate = Number.MAX_VALUE, t.minZ = Number.MAX_VALUE, t.maxZ = -Number.MAX_VALUE, t.minXDiff = Number.MAX_VALUE, t.yAxisScale = [], t.xAxisScale = null, t.xAxisTicksPositions = [], t.yLabelsCoords = [], t.yTitleCoords = [], t.barPadForNumericAxis = 0, t.padHorizontal = 0, t.xRange = 0, t.yRange = [], t.zRange = 0, t.dataPoints = 0, t.xTickAmount = 0;
    } }, { key: "globalVars", value: function(t) {
      return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: t.markers.size, largestSize: 0 }, animationEnded: !1, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: !1, isExecCalled: !1, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: !1, allSeriesCollapsed: !1, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: !1, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], goldenPadding: 35, invalidLogScale: !1, ignoreYAxisIndexes: [], yAxisSameScaleIndices: [], maxValsInArrayIndex: 0, radialSize: 0, selection: void 0, zoomEnabled: t.chart.toolbar.autoSelected === "zoom" && t.chart.toolbar.tools.zoom && t.chart.zoom.enabled, panEnabled: t.chart.toolbar.autoSelected === "pan" && t.chart.toolbar.tools.pan, selectionEnabled: t.chart.toolbar.autoSelected === "selection" && t.chart.toolbar.tools.selection, yaxis: null, mousedown: !1, lastClientPosition: {}, visibleXRange: void 0, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: !1, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: !0, skipLastTimelinelabel: !1, skipFirstTimelinelabel: !1, delayedElements: [], axisCharts: !0, isDataXYZ: !1, resized: !1, resizeTimer: null, comboCharts: !1, dataChanged: !1, previousPaths: [], allSeriesHasEqualX: !0, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: !1, easing: null, zoomed: !1, gridWidth: 0, gridHeight: 0, rotateXLabels: !1, defaultLabels: !1, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null };
    } }, { key: "init", value: function(t) {
      var n = this.globalVars(t);
      return this.initGlobalVars(n), n.initialConfig = K.extend({}, t), n.initialSeries = K.clone(t.series), n.lastXAxis = K.clone(n.initialConfig.xaxis), n.lastYAxis = K.clone(n.initialConfig.yaxis), n;
    } }]), B;
  }(), Ue = function() {
    function B(t) {
      C(this, B), this.opts = t;
    }
    return F(B, [{ key: "init", value: function() {
      var t = new ft(this.opts).init({ responsiveOverride: !1 });
      return { config: t, globals: new ye().init(t) };
    } }]), B;
  }(), Qe = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w, this.opts = null, this.seriesIndex = 0;
    }
    return F(B, [{ key: "clippedImgArea", value: function(t) {
      var n = this.w, i = n.config, o = parseInt(n.globals.gridWidth, 10), d = parseInt(n.globals.gridHeight, 10), f = o > d ? o : d, p = t.image, y = 0, S = 0;
      t.width === void 0 && t.height === void 0 ? i.fill.image.width !== void 0 && i.fill.image.height !== void 0 ? (y = i.fill.image.width + 1, S = i.fill.image.height) : (y = f + 1, S = f) : (y = t.width, S = t.height);
      var A = document.createElementNS(n.globals.SVGNS, "pattern");
      re.setAttrs(A, { id: t.patternID, patternUnits: t.patternUnits ? t.patternUnits : "userSpaceOnUse", width: y + "px", height: S + "px" });
      var E = document.createElementNS(n.globals.SVGNS, "image");
      A.appendChild(E), E.setAttributeNS(window.SVG.xlink, "href", p), re.setAttrs(E, { x: 0, y: 0, preserveAspectRatio: "none", width: y + "px", height: S + "px" }), E.style.opacity = t.opacity, n.globals.dom.elDefs.node.appendChild(A);
    } }, { key: "getSeriesIndex", value: function(t) {
      var n = this.w, i = n.config.chart.type;
      return (i === "bar" || i === "rangeBar") && n.config.plotOptions.bar.distributed || i === "heatmap" || i === "treemap" ? this.seriesIndex = t.seriesNumber : this.seriesIndex = t.seriesNumber % n.globals.series.length, this.seriesIndex;
    } }, { key: "fillPath", value: function(t) {
      var n = this.w;
      this.opts = t;
      var i, o, d, f = this.w.config;
      this.seriesIndex = this.getSeriesIndex(t);
      var p = this.getFillColors()[this.seriesIndex];
      n.globals.seriesColors[this.seriesIndex] !== void 0 && (p = n.globals.seriesColors[this.seriesIndex]), typeof p == "function" && (p = p({ seriesIndex: this.seriesIndex, dataPointIndex: t.dataPointIndex, value: t.value, w: n }));
      var y = t.fillType ? t.fillType : this.getFillType(this.seriesIndex), S = Array.isArray(f.fill.opacity) ? f.fill.opacity[this.seriesIndex] : f.fill.opacity;
      t.color && (p = t.color);
      var A = p;
      if (p.indexOf("rgb") === -1 ? p.length < 9 && (A = K.hexToRgba(p, S)) : p.indexOf("rgba") > -1 && (S = K.getOpacityFromRGBA(p)), t.opacity && (S = t.opacity), y === "pattern" && (o = this.handlePatternFill({ fillConfig: t.fillConfig, patternFill: o, fillColor: p, fillOpacity: S, defaultColor: A })), y === "gradient" && (d = this.handleGradientFill({ fillConfig: t.fillConfig, fillColor: p, fillOpacity: S, i: this.seriesIndex })), y === "image") {
        var E = f.fill.image.src, L = t.patternID ? t.patternID : "";
        this.clippedImgArea({ opacity: S, image: Array.isArray(E) ? t.seriesNumber < E.length ? E[t.seriesNumber] : E[0] : E, width: t.width ? t.width : void 0, height: t.height ? t.height : void 0, patternUnits: t.patternUnits, patternID: "pattern".concat(n.globals.cuid).concat(t.seriesNumber + 1).concat(L) }), i = "url(#pattern".concat(n.globals.cuid).concat(t.seriesNumber + 1).concat(L, ")");
      } else
        i = y === "gradient" ? d : y === "pattern" ? o : A;
      return t.solid && (i = A), i;
    } }, { key: "getFillType", value: function(t) {
      var n = this.w;
      return Array.isArray(n.config.fill.type) ? n.config.fill.type[t] : n.config.fill.type;
    } }, { key: "getFillColors", value: function() {
      var t = this.w, n = t.config, i = this.opts, o = [];
      return t.globals.comboCharts ? t.config.series[this.seriesIndex].type === "line" ? Array.isArray(t.globals.stroke.colors) ? o = t.globals.stroke.colors : o.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? o = t.globals.fill.colors : o.push(t.globals.fill.colors) : n.chart.type === "line" ? Array.isArray(t.globals.stroke.colors) ? o = t.globals.stroke.colors : o.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? o = t.globals.fill.colors : o.push(t.globals.fill.colors), i.fillColors !== void 0 && (o = [], Array.isArray(i.fillColors) ? o = i.fillColors.slice() : o.push(i.fillColors)), o;
    } }, { key: "handlePatternFill", value: function(t) {
      var n = t.fillConfig, i = t.patternFill, o = t.fillColor, d = t.fillOpacity, f = t.defaultColor, p = this.w.config.fill;
      n && (p = n);
      var y = this.opts, S = new re(this.ctx), A = Array.isArray(p.pattern.strokeWidth) ? p.pattern.strokeWidth[this.seriesIndex] : p.pattern.strokeWidth, E = o;
      return Array.isArray(p.pattern.style) ? i = p.pattern.style[y.seriesNumber] !== void 0 ? S.drawPattern(p.pattern.style[y.seriesNumber], p.pattern.width, p.pattern.height, E, A, d) : f : i = S.drawPattern(p.pattern.style, p.pattern.width, p.pattern.height, E, A, d), i;
    } }, { key: "handleGradientFill", value: function(t) {
      var n = t.fillColor, i = t.fillOpacity, o = t.fillConfig, d = t.i, f = this.w.config.fill;
      o && (f = v(v({}, f), o));
      var p, y = this.opts, S = new re(this.ctx), A = new K(), E = f.gradient.type, L = n, O = f.gradient.opacityFrom === void 0 ? i : Array.isArray(f.gradient.opacityFrom) ? f.gradient.opacityFrom[d] : f.gradient.opacityFrom;
      L.indexOf("rgba") > -1 && (O = K.getOpacityFromRGBA(L));
      var P = f.gradient.opacityTo === void 0 ? i : Array.isArray(f.gradient.opacityTo) ? f.gradient.opacityTo[d] : f.gradient.opacityTo;
      if (f.gradient.gradientToColors === void 0 || f.gradient.gradientToColors.length === 0)
        p = f.gradient.shade === "dark" ? A.shadeColor(-1 * parseFloat(f.gradient.shadeIntensity), n.indexOf("rgb") > -1 ? K.rgb2hex(n) : n) : A.shadeColor(parseFloat(f.gradient.shadeIntensity), n.indexOf("rgb") > -1 ? K.rgb2hex(n) : n);
      else if (f.gradient.gradientToColors[y.seriesNumber]) {
        var I = f.gradient.gradientToColors[y.seriesNumber];
        p = I, I.indexOf("rgba") > -1 && (P = K.getOpacityFromRGBA(I));
      } else
        p = n;
      if (f.gradient.gradientFrom && (L = f.gradient.gradientFrom), f.gradient.gradientTo && (p = f.gradient.gradientTo), f.gradient.inverseColors) {
        var j = L;
        L = p, p = j;
      }
      return L.indexOf("rgb") > -1 && (L = K.rgb2hex(L)), p.indexOf("rgb") > -1 && (p = K.rgb2hex(p)), S.drawGradient(E, L, p, O, P, y.size, f.gradient.stops, f.gradient.colorStops, d);
    } }]), B;
  }(), St = function() {
    function B(t, n) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "setGlobalMarkerSize", value: function() {
      var t = this.w;
      if (t.globals.markers.size = Array.isArray(t.config.markers.size) ? t.config.markers.size : [t.config.markers.size], t.globals.markers.size.length > 0) {
        if (t.globals.markers.size.length < t.globals.series.length + 1)
          for (var n = 0; n <= t.globals.series.length; n++)
            t.globals.markers.size[n] === void 0 && t.globals.markers.size.push(t.globals.markers.size[0]);
      } else
        t.globals.markers.size = t.config.series.map(function(i) {
          return t.config.markers.size;
        });
    } }, { key: "plotChartMarkers", value: function(t, n, i, o) {
      var d, f = arguments.length > 4 && arguments[4] !== void 0 && arguments[4], p = this.w, y = n, S = t, A = null, E = new re(this.ctx), L = p.config.markers.discrete && p.config.markers.discrete.length;
      if ((p.globals.markers.size[n] > 0 || f || L) && (A = E.group({ class: f || L ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(p.globals.cuid, ")")), Array.isArray(S.x))
        for (var O = 0; O < S.x.length; O++) {
          var P = i;
          i === 1 && O === 0 && (P = 0), i === 1 && O === 1 && (P = 1);
          var I = "apexcharts-marker";
          if (p.config.chart.type !== "line" && p.config.chart.type !== "area" || p.globals.comboCharts || p.config.tooltip.intersect || (I += " no-pointer-events"), (Array.isArray(p.config.markers.size) ? p.globals.markers.size[n] > 0 : p.config.markers.size > 0) || f || L) {
            K.isNumber(S.y[O]) ? I += " w".concat(K.randomId()) : I = "apexcharts-nullpoint";
            var j = this.getMarkerConfig({ cssClass: I, seriesIndex: n, dataPointIndex: P });
            p.config.series[y].data[P] && (p.config.series[y].data[P].fillColor && (j.pointFillColor = p.config.series[y].data[P].fillColor), p.config.series[y].data[P].strokeColor && (j.pointStrokeColor = p.config.series[y].data[P].strokeColor)), o && (j.pSize = o), (S.x[O] < 0 || S.x[O] > p.globals.gridWidth || S.y[O] < 0 || S.y[O] > p.globals.gridHeight) && (j.pSize = 0), (d = E.drawMarker(S.x[O], S.y[O], j)).attr("rel", P), d.attr("j", P), d.attr("index", n), d.node.setAttribute("default-marker-size", j.pSize), new Re(this.ctx).setSelectionFilter(d, n, P), this.addEvents(d), A && A.add(d);
          } else
            p.globals.pointsArray[n] === void 0 && (p.globals.pointsArray[n] = []), p.globals.pointsArray[n].push([S.x[O], S.y[O]]);
        }
      return A;
    } }, { key: "getMarkerConfig", value: function(t) {
      var n = t.cssClass, i = t.seriesIndex, o = t.dataPointIndex, d = o === void 0 ? null : o, f = t.finishRadius, p = f === void 0 ? null : f, y = this.w, S = this.getMarkerStyle(i), A = y.globals.markers.size[i], E = y.config.markers;
      return d !== null && E.discrete.length && E.discrete.map(function(L) {
        L.seriesIndex === i && L.dataPointIndex === d && (S.pointStrokeColor = L.strokeColor, S.pointFillColor = L.fillColor, A = L.size, S.pointShape = L.shape);
      }), { pSize: p === null ? A : p, pRadius: E.radius, width: Array.isArray(E.width) ? E.width[i] : E.width, height: Array.isArray(E.height) ? E.height[i] : E.height, pointStrokeWidth: Array.isArray(E.strokeWidth) ? E.strokeWidth[i] : E.strokeWidth, pointStrokeColor: S.pointStrokeColor, pointFillColor: S.pointFillColor, shape: S.pointShape || (Array.isArray(E.shape) ? E.shape[i] : E.shape), class: n, pointStrokeOpacity: Array.isArray(E.strokeOpacity) ? E.strokeOpacity[i] : E.strokeOpacity, pointStrokeDashArray: Array.isArray(E.strokeDashArray) ? E.strokeDashArray[i] : E.strokeDashArray, pointFillOpacity: Array.isArray(E.fillOpacity) ? E.fillOpacity[i] : E.fillOpacity, seriesIndex: i };
    } }, { key: "addEvents", value: function(t) {
      var n = this.w, i = new re(this.ctx);
      t.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, t)), t.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, t)), t.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, t)), t.node.addEventListener("click", n.config.markers.onClick), t.node.addEventListener("dblclick", n.config.markers.onDblClick), t.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, t), { passive: !0 });
    } }, { key: "getMarkerStyle", value: function(t) {
      var n = this.w, i = n.globals.markers.colors, o = n.config.markers.strokeColor || n.config.markers.strokeColors;
      return { pointStrokeColor: Array.isArray(o) ? o[t] : o, pointFillColor: Array.isArray(i) ? i[t] : i };
    } }]), B;
  }(), kt = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled;
    }
    return F(B, [{ key: "draw", value: function(t, n, i) {
      var o = this.w, d = new re(this.ctx), f = i.realIndex, p = i.pointsPos, y = i.zRatio, S = i.elParent, A = d.group({ class: "apexcharts-series-markers apexcharts-series-".concat(o.config.chart.type) });
      if (A.attr("clip-path", "url(#gridRectMarkerMask".concat(o.globals.cuid, ")")), Array.isArray(p.x))
        for (var E = 0; E < p.x.length; E++) {
          var L = n + 1, O = !0;
          n === 0 && E === 0 && (L = 0), n === 0 && E === 1 && (L = 1);
          var P = 0, I = o.globals.markers.size[f];
          if (y !== 1 / 0) {
            var j = o.config.plotOptions.bubble;
            I = o.globals.seriesZ[f][L], j.zScaling && (I /= y), j.minBubbleRadius && I < j.minBubbleRadius && (I = j.minBubbleRadius), j.maxBubbleRadius && I > j.maxBubbleRadius && (I = j.maxBubbleRadius);
          }
          o.config.chart.animations.enabled || (P = I);
          var V = p.x[E], Z = p.y[E];
          if (P = P || 0, Z !== null && o.globals.series[f][L] !== void 0 || (O = !1), O) {
            var b = this.drawPoint(V, Z, P, I, f, L, n);
            A.add(b);
          }
          S.add(A);
        }
    } }, { key: "drawPoint", value: function(t, n, i, o, d, f, p) {
      var y = this.w, S = d, A = new we(this.ctx), E = new Re(this.ctx), L = new Qe(this.ctx), O = new St(this.ctx), P = new re(this.ctx), I = O.getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: S, dataPointIndex: f, finishRadius: y.config.chart.type === "bubble" || y.globals.comboCharts && y.config.series[d] && y.config.series[d].type === "bubble" ? o : null });
      o = I.pSize;
      var j, V = L.fillPath({ seriesNumber: d, dataPointIndex: f, color: I.pointFillColor, patternUnits: "objectBoundingBox", value: y.globals.series[d][p] });
      if (I.shape === "circle" ? j = P.drawCircle(i) : I.shape !== "square" && I.shape !== "rect" || (j = P.drawRect(0, 0, I.width - I.pointStrokeWidth / 2, I.height - I.pointStrokeWidth / 2, I.pRadius)), y.config.series[S].data[f] && y.config.series[S].data[f].fillColor && (V = y.config.series[S].data[f].fillColor), j.attr({ x: t - I.width / 2 - I.pointStrokeWidth / 2, y: n - I.height / 2 - I.pointStrokeWidth / 2, cx: t, cy: n, fill: V, "fill-opacity": I.pointFillOpacity, stroke: I.pointStrokeColor, r: o, "stroke-width": I.pointStrokeWidth, "stroke-dasharray": I.pointStrokeDashArray, "stroke-opacity": I.pointStrokeOpacity }), y.config.chart.dropShadow.enabled) {
        var Z = y.config.chart.dropShadow;
        E.dropShadow(j, Z, d);
      }
      if (!this.initialAnim || y.globals.dataChanged || y.globals.resized)
        y.globals.animationEnded = !0;
      else {
        var b = y.config.chart.animations.speed;
        A.animateMarker(j, 0, I.shape === "circle" ? o : { width: I.width, height: I.height }, b, y.globals.easing, function() {
          window.setTimeout(function() {
            A.animationCompleted(j);
          }, 100);
        });
      }
      if (y.globals.dataChanged && I.shape === "circle")
        if (this.dynamicAnim) {
          var M, N, X, Q, ee = y.config.chart.animations.dynamicAnimation.speed;
          (Q = y.globals.previousPaths[d] && y.globals.previousPaths[d][p]) != null && (M = Q.x, N = Q.y, X = Q.r !== void 0 ? Q.r : o);
          for (var oe = 0; oe < y.globals.collapsedSeries.length; oe++)
            y.globals.collapsedSeries[oe].index === d && (ee = 1, o = 0);
          t === 0 && n === 0 && (o = 0), A.animateCircle(j, { cx: M, cy: N, r: X }, { cx: t, cy: n, r: o }, ee, y.globals.easing);
        } else
          j.attr({ r: o });
      return j.attr({ rel: f, j: f, index: d, "default-marker-size": o }), E.setSelectionFilter(j, d, f), O.addEvents(j), j.node.classList.add("apexcharts-marker"), j;
    } }, { key: "centerTextInBubble", value: function(t) {
      var n = this.w;
      return { y: t += parseInt(n.config.dataLabels.style.fontSize, 10) / 4 };
    } }]), B;
  }(), Ht = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "dataLabelsCorrection", value: function(t, n, i, o, d, f, p) {
      var y = this.w, S = !1, A = new re(this.ctx).getTextRects(i, p), E = A.width, L = A.height;
      n < 0 && (n = 0), n > y.globals.gridHeight + L && (n = y.globals.gridHeight + L / 2), y.globals.dataLabelsRects[o] === void 0 && (y.globals.dataLabelsRects[o] = []), y.globals.dataLabelsRects[o].push({ x: t, y: n, width: E, height: L });
      var O = y.globals.dataLabelsRects[o].length - 2, P = y.globals.lastDrawnDataLabelsIndexes[o] !== void 0 ? y.globals.lastDrawnDataLabelsIndexes[o][y.globals.lastDrawnDataLabelsIndexes[o].length - 1] : 0;
      if (y.globals.dataLabelsRects[o][O] !== void 0) {
        var I = y.globals.dataLabelsRects[o][P];
        (t > I.x + I.width + 2 || n > I.y + I.height + 2 || t + E < I.x) && (S = !0);
      }
      return (d === 0 || f) && (S = !0), { x: t, y: n, textRects: A, drawnextLabel: S };
    } }, { key: "drawDataLabel", value: function(t) {
      var n = this, i = t.type, o = t.pos, d = t.i, f = t.j, p = t.isRangeStart, y = t.strokeWidth, S = y === void 0 ? 2 : y, A = this.w, E = new re(this.ctx), L = A.config.dataLabels, O = 0, P = 0, I = f, j = null;
      if (!L.enabled || !Array.isArray(o.x))
        return j;
      j = E.group({ class: "apexcharts-data-labels" });
      for (var V = 0; V < o.x.length; V++)
        if (O = o.x[V] + L.offsetX, P = o.y[V] + L.offsetY + S, !isNaN(O)) {
          f === 1 && V === 0 && (I = 0), f === 1 && V === 1 && (I = 1);
          var Z = A.globals.series[d][I];
          i === "rangeArea" && (Z = p ? A.globals.seriesRangeStart[d][I] : A.globals.seriesRangeEnd[d][I]);
          var b = "", M = function(N) {
            return A.config.dataLabels.formatter(N, { ctx: n.ctx, seriesIndex: d, dataPointIndex: I, w: A });
          };
          A.config.chart.type === "bubble" ? (b = M(Z = A.globals.seriesZ[d][I]), P = o.y[V], P = new kt(this.ctx).centerTextInBubble(P, d, I).y) : Z !== void 0 && (b = M(Z)), this.plotDataLabelsText({ x: O, y: P, text: b, i: d, j: I, parent: j, offsetCorrection: !0, dataLabelsConfig: A.config.dataLabels });
        }
      return j;
    } }, { key: "plotDataLabelsText", value: function(t) {
      var n = this.w, i = new re(this.ctx), o = t.x, d = t.y, f = t.i, p = t.j, y = t.text, S = t.textAnchor, A = t.fontSize, E = t.parent, L = t.dataLabelsConfig, O = t.color, P = t.alwaysDrawDataLabel, I = t.offsetCorrection;
      if (!(Array.isArray(n.config.dataLabels.enabledOnSeries) && n.config.dataLabels.enabledOnSeries.indexOf(f) < 0)) {
        var j = { x: o, y: d, drawnextLabel: !0, textRects: null };
        I && (j = this.dataLabelsCorrection(o, d, y, f, p, P, parseInt(L.style.fontSize, 10))), n.globals.zoomed || (o = j.x, d = j.y), j.textRects && (o < -10 - j.textRects.width || o > n.globals.gridWidth + j.textRects.width + 10) && (y = "");
        var V = n.globals.dataLabels.style.colors[f];
        ((n.config.chart.type === "bar" || n.config.chart.type === "rangeBar") && n.config.plotOptions.bar.distributed || n.config.dataLabels.distributed) && (V = n.globals.dataLabels.style.colors[p]), typeof V == "function" && (V = V({ series: n.globals.series, seriesIndex: f, dataPointIndex: p, w: n })), O && (V = O);
        var Z = L.offsetX, b = L.offsetY;
        if (n.config.chart.type !== "bar" && n.config.chart.type !== "rangeBar" || (Z = 0, b = 0), j.drawnextLabel) {
          var M = i.drawText({ width: 100, height: parseInt(L.style.fontSize, 10), x: o + Z, y: d + b, foreColor: V, textAnchor: S || L.textAnchor, text: y, fontSize: A || L.style.fontSize, fontFamily: L.style.fontFamily, fontWeight: L.style.fontWeight || "normal" });
          if (M.attr({ class: "apexcharts-datalabel", cx: o, cy: d }), L.dropShadow.enabled) {
            var N = L.dropShadow;
            new Re(this.ctx).dropShadow(M, N);
          }
          E.add(M), n.globals.lastDrawnDataLabelsIndexes[f] === void 0 && (n.globals.lastDrawnDataLabelsIndexes[f] = []), n.globals.lastDrawnDataLabelsIndexes[f].push(p);
        }
      }
    } }, { key: "addBackgroundToDataLabel", value: function(t, n) {
      var i = this.w, o = i.config.dataLabels.background, d = o.padding, f = o.padding / 2, p = n.width, y = n.height, S = new re(this.ctx).drawRect(n.x - d, n.y - f / 2, p + 2 * d, y + f, o.borderRadius, i.config.chart.background === "transparent" ? "#fff" : i.config.chart.background, o.opacity, o.borderWidth, o.borderColor);
      return o.dropShadow.enabled && new Re(this.ctx).dropShadow(S, o.dropShadow), S;
    } }, { key: "dataLabelsBackground", value: function() {
      var t = this.w;
      if (t.config.chart.type !== "bubble")
        for (var n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i = 0; i < n.length; i++) {
          var o = n[i], d = o.getBBox(), f = null;
          if (d.width && d.height && (f = this.addBackgroundToDataLabel(o, d)), f) {
            o.parentNode.insertBefore(f.node, o);
            var p = o.getAttribute("fill");
            t.config.chart.animations.enabled && !t.globals.resized && !t.globals.dataChanged ? f.animate().attr({ fill: p }) : f.attr({ fill: p }), o.setAttribute("fill", t.config.dataLabels.background.foreColor);
          }
        }
    } }, { key: "bringForward", value: function() {
      for (var t = this.w, n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i = t.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), o = 0; o < n.length; o++)
        i && i.insertBefore(n[o], i.nextSibling);
    } }]), B;
  }(), ot = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w, this.legendInactiveClass = "legend-mouseover-inactive";
    }
    return F(B, [{ key: "getAllSeriesEls", value: function() {
      return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
    } }, { key: "getSeriesByName", value: function(t) {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(K.escapeString(t), "']"));
    } }, { key: "isSeriesHidden", value: function(t) {
      var n = this.getSeriesByName(t), i = parseInt(n.getAttribute("data:realIndex"), 10);
      return { isHidden: n.classList.contains("apexcharts-series-collapsed"), realIndex: i };
    } }, { key: "addCollapsedClassToSeries", value: function(t, n) {
      var i = this.w;
      function o(d) {
        for (var f = 0; f < d.length; f++)
          d[f].index === n && t.node.classList.add("apexcharts-series-collapsed");
      }
      o(i.globals.collapsedSeries), o(i.globals.ancillaryCollapsedSeries);
    } }, { key: "toggleSeries", value: function(t) {
      var n = this.isSeriesHidden(t);
      return this.ctx.legend.legendHelpers.toggleDataSeries(n.realIndex, n.isHidden), n.isHidden;
    } }, { key: "showSeries", value: function(t) {
      var n = this.isSeriesHidden(t);
      n.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(n.realIndex, !0);
    } }, { key: "hideSeries", value: function(t) {
      var n = this.isSeriesHidden(t);
      n.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(n.realIndex, !1);
    } }, { key: "resetSeries", value: function() {
      var t = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], o = this.w, d = K.clone(o.globals.initialSeries);
      o.globals.previousPaths = [], i ? (o.globals.collapsedSeries = [], o.globals.ancillaryCollapsedSeries = [], o.globals.collapsedSeriesIndices = [], o.globals.ancillaryCollapsedSeriesIndices = []) : d = this.emptyCollapsedSeries(d), o.config.series = d, t && (n && (o.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(d, o.config.chart.animations.dynamicAnimation.enabled));
    } }, { key: "emptyCollapsedSeries", value: function(t) {
      for (var n = this.w, i = 0; i < t.length; i++)
        n.globals.collapsedSeriesIndices.indexOf(i) > -1 && (t[i].data = []);
      return t;
    } }, { key: "toggleSeriesOnHover", value: function(t, n) {
      var i = this.w;
      n || (n = t.target);
      var o = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
      if (t.type === "mousemove") {
        var d = parseInt(n.getAttribute("rel"), 10) - 1, f = null, p = null;
        i.globals.axisCharts || i.config.chart.type === "radialBar" ? i.globals.axisCharts ? (f = i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(d, "']")), p = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(d, "']"))) : f = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(d + 1, "']")) : f = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(d + 1, "'] path"));
        for (var y = 0; y < o.length; y++)
          o[y].classList.add(this.legendInactiveClass);
        f !== null && (i.globals.axisCharts || f.parentNode.classList.remove(this.legendInactiveClass), f.classList.remove(this.legendInactiveClass), p !== null && p.classList.remove(this.legendInactiveClass));
      } else if (t.type === "mouseout")
        for (var S = 0; S < o.length; S++)
          o[S].classList.remove(this.legendInactiveClass);
    } }, { key: "highlightRangeInSeries", value: function(t, n) {
      var i = this, o = this.w, d = o.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), f = function(y) {
        for (var S = 0; S < d.length; S++)
          d[S].classList[y](i.legendInactiveClass);
      };
      if (t.type === "mousemove") {
        var p = parseInt(n.getAttribute("rel"), 10) - 1;
        f("add"), function(y) {
          for (var S = 0; S < d.length; S++) {
            var A = parseInt(d[S].getAttribute("val"), 10);
            A >= y.from && A <= y.to && d[S].classList.remove(i.legendInactiveClass);
          }
        }(o.config.plotOptions.heatmap.colorScale.ranges[p]);
      } else
        t.type === "mouseout" && f("remove");
    } }, { key: "getActiveConfigSeriesIndex", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "asc", n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], i = this.w, o = 0;
      if (i.config.series.length > 1) {
        for (var d = i.config.series.map(function(p, y) {
          return p.data && p.data.length > 0 && i.globals.collapsedSeriesIndices.indexOf(y) === -1 && (!i.globals.comboCharts || n.length === 0 || n.length && n.indexOf(i.config.series[y].type) > -1) ? y : -1;
        }), f = t === "asc" ? 0 : d.length - 1; t === "asc" ? f < d.length : f >= 0; t === "asc" ? f++ : f--)
          if (d[f] !== -1) {
            o = d[f];
            break;
          }
      }
      return o;
    } }, { key: "getBarSeriesIndices", value: function() {
      return this.w.globals.comboCharts ? this.w.config.series.map(function(t, n) {
        return t.type === "bar" || t.type === "column" ? n : -1;
      }).filter(function(t) {
        return t !== -1;
      }) : this.w.config.series.map(function(t, n) {
        return n;
      });
    } }, { key: "getPreviousPaths", value: function() {
      var t = this.w;
      function n(f, p, y) {
        for (var S = f[p].childNodes, A = { type: y, paths: [], realIndex: f[p].getAttribute("data:realIndex") }, E = 0; E < S.length; E++)
          if (S[E].hasAttribute("pathTo")) {
            var L = S[E].getAttribute("pathTo");
            A.paths.push({ d: L });
          }
        t.globals.previousPaths.push(A);
      }
      t.globals.previousPaths = [], ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function(f) {
        for (var p, y = (p = f, t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(p, "-series .apexcharts-series"))), S = 0; S < y.length; S++)
          n(y, S, f);
      }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
      var i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type, " .apexcharts-series"));
      if (i.length > 0)
        for (var o = function(f) {
          for (var p = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(f, "'] rect")), y = [], S = function(E) {
            var L = function(P) {
              return p[E].getAttribute(P);
            }, O = { x: parseFloat(L("x")), y: parseFloat(L("y")), width: parseFloat(L("width")), height: parseFloat(L("height")) };
            y.push({ rect: O, color: p[E].getAttribute("color") });
          }, A = 0; A < p.length; A++)
            S(A);
          t.globals.previousPaths.push(y);
        }, d = 0; d < i.length; d++)
          o(d);
      t.globals.axisCharts || (t.globals.previousPaths = t.globals.series);
    } }, { key: "handlePrevBubbleScatterPaths", value: function(t) {
      var n = this.w, i = n.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series"));
      if (i.length > 0)
        for (var o = 0; o < i.length; o++) {
          for (var d = n.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series[data\\:realIndex='").concat(o, "'] circle")), f = [], p = 0; p < d.length; p++)
            f.push({ x: d[p].getAttribute("cx"), y: d[p].getAttribute("cy"), r: d[p].getAttribute("r") });
          n.globals.previousPaths.push(f);
        }
    } }, { key: "clearPreviousPaths", value: function() {
      var t = this.w;
      t.globals.previousPaths = [], t.globals.allSeriesCollapsed = !1;
    } }, { key: "handleNoData", value: function() {
      var t = this.w, n = t.config.noData, i = new re(this.ctx), o = t.globals.svgWidth / 2, d = t.globals.svgHeight / 2, f = "middle";
      if (t.globals.noData = !0, t.globals.animationEnded = !0, n.align === "left" ? (o = 10, f = "start") : n.align === "right" && (o = t.globals.svgWidth - 10, f = "end"), n.verticalAlign === "top" ? d = 50 : n.verticalAlign === "bottom" && (d = t.globals.svgHeight - 50), o += n.offsetX, d = d + parseInt(n.style.fontSize, 10) + 2 + n.offsetY, n.text !== void 0 && n.text !== "") {
        var p = i.drawText({ x: o, y: d, text: n.text, textAnchor: f, fontSize: n.style.fontSize, fontFamily: n.style.fontFamily, foreColor: n.style.color, opacity: 1, class: "apexcharts-text-nodata" });
        t.globals.dom.Paper.add(p);
      }
    } }, { key: "setNullSeriesToZeroValues", value: function(t) {
      for (var n = this.w, i = 0; i < t.length; i++)
        if (t[i].length === 0)
          for (var o = 0; o < t[n.globals.maxValsInArrayIndex].length; o++)
            t[i].push(0);
      return t;
    } }, { key: "hasAllSeriesEqualX", value: function() {
      for (var t = !0, n = this.w, i = this.filteredSeriesX(), o = 0; o < i.length - 1; o++)
        if (i[o][0] !== i[o + 1][0]) {
          t = !1;
          break;
        }
      return n.globals.allSeriesHasEqualX = t, t;
    } }, { key: "filteredSeriesX", value: function() {
      var t = this.w.globals.seriesX.map(function(n) {
        return n.length > 0 ? n : [];
      });
      return t;
    } }]), B;
  }(), It = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new ve(this.ctx);
    }
    return F(B, [{ key: "isMultiFormat", value: function() {
      return this.isFormatXY() || this.isFormat2DArray();
    } }, { key: "isFormatXY", value: function() {
      var t = this.w.config.series.slice(), n = new ot(this.ctx);
      if (this.activeSeriesIndex = n.getActiveConfigSeriesIndex(), t[this.activeSeriesIndex].data !== void 0 && t[this.activeSeriesIndex].data.length > 0 && t[this.activeSeriesIndex].data[0] !== null && t[this.activeSeriesIndex].data[0].x !== void 0 && t[this.activeSeriesIndex].data[0] !== null)
        return !0;
    } }, { key: "isFormat2DArray", value: function() {
      var t = this.w.config.series.slice(), n = new ot(this.ctx);
      if (this.activeSeriesIndex = n.getActiveConfigSeriesIndex(), t[this.activeSeriesIndex].data !== void 0 && t[this.activeSeriesIndex].data.length > 0 && t[this.activeSeriesIndex].data[0] !== void 0 && t[this.activeSeriesIndex].data[0] !== null && t[this.activeSeriesIndex].data[0].constructor === Array)
        return !0;
    } }, { key: "handleFormat2DArray", value: function(t, n) {
      for (var i = this.w.config, o = this.w.globals, d = i.chart.type === "boxPlot" || i.series[n].type === "boxPlot", f = 0; f < t[n].data.length; f++)
        if (t[n].data[f][1] !== void 0 && (Array.isArray(t[n].data[f][1]) && t[n].data[f][1].length === 4 && !d ? this.twoDSeries.push(K.parseNumber(t[n].data[f][1][3])) : t[n].data[f].length >= 5 ? this.twoDSeries.push(K.parseNumber(t[n].data[f][4])) : this.twoDSeries.push(K.parseNumber(t[n].data[f][1])), o.dataFormatXNumeric = !0), i.xaxis.type === "datetime") {
          var p = new Date(t[n].data[f][0]);
          p = new Date(p).getTime(), this.twoDSeriesX.push(p);
        } else
          this.twoDSeriesX.push(t[n].data[f][0]);
      for (var y = 0; y < t[n].data.length; y++)
        t[n].data[y][2] !== void 0 && (this.threeDSeries.push(t[n].data[y][2]), o.isDataXYZ = !0);
    } }, { key: "handleFormatXY", value: function(t, n) {
      var i = this.w.config, o = this.w.globals, d = new Ze(this.ctx), f = n;
      o.collapsedSeriesIndices.indexOf(n) > -1 && (f = this.activeSeriesIndex);
      for (var p = 0; p < t[n].data.length; p++)
        t[n].data[p].y !== void 0 && (Array.isArray(t[n].data[p].y) ? this.twoDSeries.push(K.parseNumber(t[n].data[p].y[t[n].data[p].y.length - 1])) : this.twoDSeries.push(K.parseNumber(t[n].data[p].y))), t[n].data[p].goals !== void 0 && Array.isArray(t[n].data[p].goals) ? (this.seriesGoals[n] === void 0 && (this.seriesGoals[n] = []), this.seriesGoals[n].push(t[n].data[p].goals)) : (this.seriesGoals[n] === void 0 && (this.seriesGoals[n] = []), this.seriesGoals[n].push(null));
      for (var y = 0; y < t[f].data.length; y++) {
        var S = typeof t[f].data[y].x == "string", A = Array.isArray(t[f].data[y].x), E = !A && !!d.isValidDate(t[f].data[y].x.toString());
        if (S || E)
          if (S || i.xaxis.convertedCatToNumeric) {
            var L = o.isBarHorizontal && o.isRangeData;
            i.xaxis.type !== "datetime" || L ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[f].data[y].x)) : this.twoDSeriesX.push(d.parseDate(t[f].data[y].x));
          } else
            i.xaxis.type === "datetime" ? this.twoDSeriesX.push(d.parseDate(t[f].data[y].x.toString())) : (o.dataFormatXNumeric = !0, o.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(t[f].data[y].x)));
        else
          A ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[f].data[y].x)) : (o.isXNumeric = !0, o.dataFormatXNumeric = !0, this.twoDSeriesX.push(t[f].data[y].x));
      }
      if (t[n].data[0] && t[n].data[0].z !== void 0) {
        for (var O = 0; O < t[n].data.length; O++)
          this.threeDSeries.push(t[n].data[O].z);
        o.isDataXYZ = !0;
      }
    } }, { key: "handleRangeData", value: function(t, n) {
      var i = this.w.globals, o = {};
      return this.isFormat2DArray() ? o = this.handleRangeDataFormat("array", t, n) : this.isFormatXY() && (o = this.handleRangeDataFormat("xy", t, n)), i.seriesRangeStart.push(o.start), i.seriesRangeEnd.push(o.end), i.seriesRange.push(o.rangeUniques), i.seriesRange.forEach(function(d, f) {
        d && d.forEach(function(p, y) {
          p.y.forEach(function(S, A) {
            for (var E = 0; E < p.y.length; E++)
              if (A !== E) {
                var L = S.y1, O = S.y2, P = p.y[E].y1;
                L <= p.y[E].y2 && P <= O && (p.overlaps.indexOf(S.rangeName) < 0 && p.overlaps.push(S.rangeName), p.overlaps.indexOf(p.y[E].rangeName) < 0 && p.overlaps.push(p.y[E].rangeName));
              }
          });
        });
      }), o;
    } }, { key: "handleCandleStickBoxData", value: function(t, n) {
      var i = this.w.globals, o = {};
      return this.isFormat2DArray() ? o = this.handleCandleStickBoxDataFormat("array", t, n) : this.isFormatXY() && (o = this.handleCandleStickBoxDataFormat("xy", t, n)), i.seriesCandleO[n] = o.o, i.seriesCandleH[n] = o.h, i.seriesCandleM[n] = o.m, i.seriesCandleL[n] = o.l, i.seriesCandleC[n] = o.c, o;
    } }, { key: "handleRangeDataFormat", value: function(t, n, i) {
      var o = [], d = [], f = n[i].data.filter(function(A, E, L) {
        return E === L.findIndex(function(O) {
          return O.x === A.x;
        });
      }).map(function(A, E) {
        return { x: A.x, overlaps: [], y: [] };
      });
      if (t === "array")
        for (var p = 0; p < n[i].data.length; p++)
          Array.isArray(n[i].data[p]) ? (o.push(n[i].data[p][1][0]), d.push(n[i].data[p][1][1])) : (o.push(n[i].data[p]), d.push(n[i].data[p]));
      else if (t === "xy")
        for (var y = function(A) {
          var E = Array.isArray(n[i].data[A].y), L = K.randomId(), O = n[i].data[A].x, P = { y1: E ? n[i].data[A].y[0] : n[i].data[A].y, y2: E ? n[i].data[A].y[1] : n[i].data[A].y, rangeName: L };
          n[i].data[A].rangeName = L;
          var I = f.findIndex(function(j) {
            return j.x === O;
          });
          f[I].y.push(P), o.push(P.y1), d.push(P.y2);
        }, S = 0; S < n[i].data.length; S++)
          y(S);
      return { start: o, end: d, rangeUniques: f };
    } }, { key: "handleCandleStickBoxDataFormat", value: function(t, n, i) {
      var o = this.w, d = o.config.chart.type === "boxPlot" || o.config.series[i].type === "boxPlot", f = [], p = [], y = [], S = [], A = [];
      if (t === "array")
        if (d && n[i].data[0].length === 6 || !d && n[i].data[0].length === 5)
          for (var E = 0; E < n[i].data.length; E++)
            f.push(n[i].data[E][1]), p.push(n[i].data[E][2]), d ? (y.push(n[i].data[E][3]), S.push(n[i].data[E][4]), A.push(n[i].data[E][5])) : (S.push(n[i].data[E][3]), A.push(n[i].data[E][4]));
        else
          for (var L = 0; L < n[i].data.length; L++)
            Array.isArray(n[i].data[L][1]) && (f.push(n[i].data[L][1][0]), p.push(n[i].data[L][1][1]), d ? (y.push(n[i].data[L][1][2]), S.push(n[i].data[L][1][3]), A.push(n[i].data[L][1][4])) : (S.push(n[i].data[L][1][2]), A.push(n[i].data[L][1][3])));
      else if (t === "xy")
        for (var O = 0; O < n[i].data.length; O++)
          Array.isArray(n[i].data[O].y) && (f.push(n[i].data[O].y[0]), p.push(n[i].data[O].y[1]), d ? (y.push(n[i].data[O].y[2]), S.push(n[i].data[O].y[3]), A.push(n[i].data[O].y[4])) : (S.push(n[i].data[O].y[2]), A.push(n[i].data[O].y[3])));
      return { o: f, h: p, m: y, l: S, c: A };
    } }, { key: "parseDataAxisCharts", value: function(t) {
      var n, i = this, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.ctx, d = this.w.config, f = this.w.globals, p = new Ze(o), y = d.labels.length > 0 ? d.labels.slice() : d.xaxis.categories.slice();
      if (f.isRangeBar = d.chart.type === "rangeBar" && f.isBarHorizontal, f.hasXaxisGroups = d.xaxis.type === "category" && d.xaxis.group.groups.length > 0, f.hasXaxisGroups && (f.groups = d.xaxis.group.groups), f.hasSeriesGroups = (n = t[0]) === null || n === void 0 ? void 0 : n.group, f.hasSeriesGroups) {
        var S = [], A = ue(new Set(t.map(function(P) {
          return P.group;
        })));
        t.forEach(function(P, I) {
          var j = A.indexOf(P.group);
          S[j] || (S[j] = []), S[j].push(P.name);
        }), f.seriesGroups = S;
      }
      for (var E = function() {
        for (var P = 0; P < y.length; P++)
          if (typeof y[P] == "string") {
            if (!p.isValidDate(y[P]))
              throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
            i.twoDSeriesX.push(p.parseDate(y[P]));
          } else
            i.twoDSeriesX.push(y[P]);
      }, L = 0; L < t.length; L++) {
        if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], t[L].data === void 0)
          return void console.error("It is a possibility that you may have not included 'data' property in series.");
        if (d.chart.type !== "rangeBar" && d.chart.type !== "rangeArea" && t[L].type !== "rangeBar" && t[L].type !== "rangeArea" || (f.isRangeData = !0, f.isComboCharts ? t[L].type !== "rangeBar" && t[L].type !== "rangeArea" || this.handleRangeData(t, L) : d.chart.type !== "rangeBar" && d.chart.type !== "rangeArea" || this.handleRangeData(t, L)), this.isMultiFormat())
          this.isFormat2DArray() ? this.handleFormat2DArray(t, L) : this.isFormatXY() && this.handleFormatXY(t, L), d.chart.type !== "candlestick" && t[L].type !== "candlestick" && d.chart.type !== "boxPlot" && t[L].type !== "boxPlot" || this.handleCandleStickBoxData(t, L), f.series.push(this.twoDSeries), f.labels.push(this.twoDSeriesX), f.seriesX.push(this.twoDSeriesX), f.seriesGoals = this.seriesGoals, L !== this.activeSeriesIndex || this.fallbackToCategory || (f.isXNumeric = !0);
        else {
          d.xaxis.type === "datetime" ? (f.isXNumeric = !0, E(), f.seriesX.push(this.twoDSeriesX)) : d.xaxis.type === "numeric" && (f.isXNumeric = !0, y.length > 0 && (this.twoDSeriesX = y, f.seriesX.push(this.twoDSeriesX))), f.labels.push(this.twoDSeriesX);
          var O = t[L].data.map(function(P) {
            return K.parseNumber(P);
          });
          f.series.push(O);
        }
        f.seriesZ.push(this.threeDSeries), t[L].name !== void 0 ? f.seriesNames.push(t[L].name) : f.seriesNames.push("series-" + parseInt(L + 1, 10)), t[L].color !== void 0 ? f.seriesColors.push(t[L].color) : f.seriesColors.push(void 0);
      }
      return this.w;
    } }, { key: "parseDataNonAxisCharts", value: function(t) {
      var n = this.w.globals, i = this.w.config;
      n.series = t.slice(), n.seriesNames = i.labels.slice();
      for (var o = 0; o < n.series.length; o++)
        n.seriesNames[o] === void 0 && n.seriesNames.push("series-" + (o + 1));
      return this.w;
    } }, { key: "handleExternalLabelsData", value: function(t) {
      var n = this.w.config, i = this.w.globals;
      n.xaxis.categories.length > 0 ? i.labels = n.xaxis.categories : n.labels.length > 0 ? i.labels = n.labels.slice() : this.fallbackToCategory ? (i.labels = i.labels[0], i.seriesRange.length && (i.seriesRange.map(function(o) {
        o.forEach(function(d) {
          i.labels.indexOf(d.x) < 0 && d.x && i.labels.push(d.x);
        });
      }), i.labels = Array.from(new Set(i.labels.map(JSON.stringify)), JSON.parse)), n.xaxis.convertedCatToNumeric && (new We(n).convertCatToNumericXaxis(n, this.ctx, i.seriesX[0]), this._generateExternalLabels(t))) : this._generateExternalLabels(t);
    } }, { key: "_generateExternalLabels", value: function(t) {
      var n = this.w.globals, i = this.w.config, o = [];
      if (n.axisCharts) {
        if (n.series.length > 0)
          if (this.isFormatXY())
            for (var d = i.series.map(function(E, L) {
              return E.data.filter(function(O, P, I) {
                return I.findIndex(function(j) {
                  return j.x === O.x;
                }) === P;
              });
            }), f = d.reduce(function(E, L, O, P) {
              return P[E].length > L.length ? E : O;
            }, 0), p = 0; p < d[f].length; p++)
              o.push(p + 1);
          else
            for (var y = 0; y < n.series[n.maxValsInArrayIndex].length; y++)
              o.push(y + 1);
        n.seriesX = [];
        for (var S = 0; S < t.length; S++)
          n.seriesX.push(o);
        this.w.globals.isBarHorizontal || (n.isXNumeric = !0);
      }
      if (o.length === 0) {
        o = n.axisCharts ? [] : n.series.map(function(E, L) {
          return L + 1;
        });
        for (var A = 0; A < t.length; A++)
          n.seriesX.push(o);
      }
      n.labels = o, i.xaxis.convertedCatToNumeric && (n.categoryLabels = o.map(function(E) {
        return i.xaxis.labels.formatter(E);
      })), n.noLabelsProvided = !0;
    } }, { key: "parseData", value: function(t) {
      var n = this.w, i = n.config, o = n.globals;
      if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), o.axisCharts ? (this.parseDataAxisCharts(t), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(t), i.chart.stacked) {
        var d = new ot(this.ctx);
        o.series = d.setNullSeriesToZeroValues(o.series);
      }
      this.coreUtils.getSeriesTotals(), o.axisCharts && (o.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals()), this.coreUtils.getPercentSeries(), o.dataFormatXNumeric || o.isXNumeric && (i.xaxis.type !== "numeric" || i.labels.length !== 0 || i.xaxis.categories.length !== 0) || this.handleExternalLabelsData(t);
      for (var f = this.coreUtils.getCategoryLabels(o.labels), p = 0; p < f.length; p++)
        if (Array.isArray(f[p])) {
          o.isMultiLineX = !0;
          break;
        }
    } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
      var t = this, n = this.w;
      n.globals.ignoreYAxisIndexes = n.globals.collapsedSeries.map(function(i, o) {
        if (t.w.globals.isMultipleYAxis && !n.config.chart.stacked)
          return i.index;
      });
    } }]), B;
  }(), Rt = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "getLabel", value: function(t, n, i, o) {
      var d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "12px", p = !(arguments.length > 6 && arguments[6] !== void 0) || arguments[6], y = this.w, S = t[o] === void 0 ? "" : t[o], A = S, E = y.globals.xLabelFormatter, L = y.config.xaxis.labels.formatter, O = !1, P = new Vt(this.ctx), I = S;
      p && (A = P.xLabelFormat(E, S, I, { i: o, dateFormatter: new Ze(this.ctx).formatDate, w: y }), L !== void 0 && (A = L(S, t[o], { i: o, dateFormatter: new Ze(this.ctx).formatDate, w: y })));
      var j, V;
      n.length > 0 ? (j = n[o].unit, V = null, n.forEach(function(N) {
        N.unit === "month" ? V = "year" : N.unit === "day" ? V = "month" : N.unit === "hour" ? V = "day" : N.unit === "minute" && (V = "hour");
      }), O = V === j, i = n[o].position, A = n[o].value) : y.config.xaxis.type === "datetime" && L === void 0 && (A = ""), A === void 0 && (A = ""), A = Array.isArray(A) ? A : A.toString();
      var Z = new re(this.ctx), b = {};
      b = y.globals.rotateXLabels && p ? Z.getTextRects(A, parseInt(f, 10), null, "rotate(".concat(y.config.xaxis.labels.rotate, " 0 0)"), !1) : Z.getTextRects(A, parseInt(f, 10));
      var M = !y.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
      return !Array.isArray(A) && (A.indexOf("NaN") === 0 || A.toLowerCase().indexOf("invalid") === 0 || A.toLowerCase().indexOf("infinity") >= 0 || d.indexOf(A) >= 0 && M) && (A = ""), { x: i, text: A, textRect: b, isBold: O };
    } }, { key: "checkLabelBasedOnTickamount", value: function(t, n, i) {
      var o = this.w, d = o.config.xaxis.tickAmount;
      return d === "dataPoints" && (d = Math.round(o.globals.gridWidth / 120)), d > i || t % Math.round(i / (d + 1)) == 0 || (n.text = ""), n;
    } }, { key: "checkForOverflowingLabels", value: function(t, n, i, o, d) {
      var f = this.w;
      if (t === 0 && f.globals.skipFirstTimelinelabel && (n.text = ""), t === i - 1 && f.globals.skipLastTimelinelabel && (n.text = ""), f.config.xaxis.labels.hideOverlappingLabels && o.length > 0) {
        var p = d[d.length - 1];
        n.x < p.textRect.width / (f.globals.rotateXLabels ? Math.abs(f.config.xaxis.labels.rotate) / 12 : 1.01) + p.x && (n.text = "");
      }
      return n;
    } }, { key: "checkForReversedLabels", value: function(t, n) {
      var i = this.w;
      return i.config.yaxis[t] && i.config.yaxis[t].reversed && n.reverse(), n;
    } }, { key: "isYAxisHidden", value: function(t) {
      var n = this.w, i = new ve(this.ctx);
      return !n.config.yaxis[t].show || !n.config.yaxis[t].showForNullSeries && i.isSeriesNull(t) && n.globals.collapsedSeriesIndices.indexOf(t) === -1;
    } }, { key: "getYAxisForeColor", value: function(t, n) {
      var i = this.w;
      return Array.isArray(t) && i.globals.yAxisScale[n] && this.ctx.theme.pushExtraColors(t, i.globals.yAxisScale[n].result.length, !1), t;
    } }, { key: "drawYAxisTicks", value: function(t, n, i, o, d, f, p) {
      var y = this.w, S = new re(this.ctx), A = y.globals.translateY;
      if (o.show && n > 0) {
        y.config.yaxis[d].opposite === !0 && (t += o.width);
        for (var E = n; E >= 0; E--) {
          var L = A + n / 10 + y.config.yaxis[d].labels.offsetY - 1;
          y.globals.isBarHorizontal && (L = f * E), y.config.chart.type === "heatmap" && (L += f / 2);
          var O = S.drawLine(t + i.offsetX - o.width + o.offsetX, L + o.offsetY, t + i.offsetX + o.offsetX, L + o.offsetY, o.color);
          p.add(O), A += f;
        }
      }
    } }]), B;
  }(), jt = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "scaleSvgNode", value: function(t, n) {
      var i = parseFloat(t.getAttributeNS(null, "width")), o = parseFloat(t.getAttributeNS(null, "height"));
      t.setAttributeNS(null, "width", i * n), t.setAttributeNS(null, "height", o * n), t.setAttributeNS(null, "viewBox", "0 0 " + i + " " + o);
    } }, { key: "fixSvgStringForIe11", value: function(t) {
      if (!K.isIE11())
        return t.replace(/&nbsp;/g, "&#160;");
      var n = 0, i = t.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function(o) {
        return ++n === 2 ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : o;
      });
      return i = (i = i.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1");
    } }, { key: "getSvgString", value: function(t) {
      t == null && (t = 1);
      var n = this.w.globals.dom.Paper.svg();
      if (t !== 1) {
        var i = this.w.globals.dom.Paper.node.cloneNode(!0);
        this.scaleSvgNode(i, t), n = new XMLSerializer().serializeToString(i);
      }
      return this.fixSvgStringForIe11(n);
    } }, { key: "cleanup", value: function() {
      var t = this.w, n = t.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"), i = t.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"), o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
      Array.prototype.forEach.call(o, function(d) {
        d.setAttribute("width", 0);
      }), n && n[0] && (n[0].setAttribute("x", -500), n[0].setAttribute("x1", -500), n[0].setAttribute("x2", -500)), i && i[0] && (i[0].setAttribute("y", -100), i[0].setAttribute("y1", -100), i[0].setAttribute("y2", -100));
    } }, { key: "svgUrl", value: function() {
      this.cleanup();
      var t = this.getSvgString(), n = new Blob([t], { type: "image/svg+xml;charset=utf-8" });
      return URL.createObjectURL(n);
    } }, { key: "dataURI", value: function(t) {
      var n = this;
      return new Promise(function(i) {
        var o = n.w, d = t ? t.scale || t.width / o.globals.svgWidth : 1;
        n.cleanup();
        var f = document.createElement("canvas");
        f.width = o.globals.svgWidth * d, f.height = parseInt(o.globals.dom.elWrap.style.height, 10) * d;
        var p = o.config.chart.background === "transparent" ? "#fff" : o.config.chart.background, y = f.getContext("2d");
        y.fillStyle = p, y.fillRect(0, 0, f.width * d, f.height * d);
        var S = n.getSvgString(d);
        if (window.canvg && K.isIE11()) {
          var A = window.canvg.Canvg.fromString(y, S, { ignoreClear: !0, ignoreDimensions: !0 });
          A.start();
          var E = f.msToBlob();
          A.stop(), i({ blob: E });
        } else {
          var L = "data:image/svg+xml," + encodeURIComponent(S), O = new Image();
          O.crossOrigin = "anonymous", O.onload = function() {
            if (y.drawImage(O, 0, 0), f.msToBlob) {
              var P = f.msToBlob();
              i({ blob: P });
            } else {
              var I = f.toDataURL("image/png");
              i({ imgURI: I });
            }
          }, O.src = L;
        }
      });
    } }, { key: "exportToSVG", value: function() {
      this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg");
    } }, { key: "exportToPng", value: function() {
      var t = this;
      this.dataURI().then(function(n) {
        var i = n.imgURI, o = n.blob;
        o ? navigator.msSaveOrOpenBlob(o, t.w.globals.chartID + ".png") : t.triggerDownload(i, t.w.config.chart.toolbar.export.png.filename, ".png");
      });
    } }, { key: "exportToCSV", value: function(t) {
      var n = this, i = t.series, o = t.fileName, d = t.columnDelimiter, f = d === void 0 ? "," : d, p = t.lineDelimiter, y = p === void 0 ? `
` : p, S = this.w;
      i || (i = S.config.series);
      var A = [], E = [], L = "", O = S.globals.series.map(function(b, M) {
        return S.globals.collapsedSeriesIndices.indexOf(M) === -1 ? b : [];
      }), P = Math.max.apply(Math, ue(i.map(function(b) {
        return b.data ? b.data.length : 0;
      }))), I = new It(this.ctx), j = new Rt(this.ctx), V = function(b) {
        var M = "";
        if (S.globals.axisCharts) {
          if (S.config.xaxis.type === "category" || S.config.xaxis.convertedCatToNumeric)
            if (S.globals.isBarHorizontal) {
              var N = S.globals.yLabelFormatters[0], X = new ot(n.ctx).getActiveConfigSeriesIndex();
              M = N(S.globals.labels[b], { seriesIndex: X, dataPointIndex: b, w: S });
            } else
              M = j.getLabel(S.globals.labels, S.globals.timescaleLabels, 0, b).text;
          S.config.xaxis.type === "datetime" && (S.config.xaxis.categories.length ? M = S.config.xaxis.categories[b] : S.config.labels.length && (M = S.config.labels[b]));
        } else
          M = S.config.labels[b];
        return Array.isArray(M) && (M = M.join(" ")), K.isNumber(M) ? M : M.split(f).join("");
      }, Z = function(b, M) {
        if (A.length && M === 0 && E.push(A.join(f)), b.data) {
          b.data = b.data.length && b.data || ue(Array(P)).map(function() {
            return "";
          });
          for (var N = 0; N < b.data.length; N++) {
            A = [];
            var X = V(N);
            if (X || (I.isFormatXY() ? X = i[M].data[N].x : I.isFormat2DArray() && (X = i[M].data[N] ? i[M].data[N][0] : "")), M === 0) {
              A.push((oe = X, S.config.xaxis.type === "datetime" && String(oe).length >= 10 ? S.config.chart.toolbar.export.csv.dateFormatter(X) : K.isNumber(X) ? X : X.split(f).join("")));
              for (var Q = 0; Q < S.globals.series.length; Q++) {
                var ee;
                I.isFormatXY() ? A.push((ee = i[Q].data[N]) === null || ee === void 0 ? void 0 : ee.y) : A.push(O[Q][N]);
              }
            }
            (S.config.chart.type === "candlestick" || b.type && b.type === "candlestick") && (A.pop(), A.push(S.globals.seriesCandleO[M][N]), A.push(S.globals.seriesCandleH[M][N]), A.push(S.globals.seriesCandleL[M][N]), A.push(S.globals.seriesCandleC[M][N])), (S.config.chart.type === "boxPlot" || b.type && b.type === "boxPlot") && (A.pop(), A.push(S.globals.seriesCandleO[M][N]), A.push(S.globals.seriesCandleH[M][N]), A.push(S.globals.seriesCandleM[M][N]), A.push(S.globals.seriesCandleL[M][N]), A.push(S.globals.seriesCandleC[M][N])), S.config.chart.type === "rangeBar" && (A.pop(), A.push(S.globals.seriesRangeStart[M][N]), A.push(S.globals.seriesRangeEnd[M][N])), A.length && E.push(A.join(f));
          }
        }
        var oe;
      };
      A.push(S.config.chart.toolbar.export.csv.headerCategory), S.config.chart.type === "boxPlot" ? (A.push("minimum"), A.push("q1"), A.push("median"), A.push("q3"), A.push("maximum")) : S.config.chart.type === "candlestick" ? (A.push("open"), A.push("high"), A.push("low"), A.push("close")) : S.config.chart.type === "rangeBar" ? (A.push("minimum"), A.push("maximum")) : i.map(function(b, M) {
        var N = (b.name ? b.name : "series-".concat(M)) + "";
        S.globals.axisCharts && A.push(N.split(f).join("") ? N.split(f).join("") : "series-".concat(M));
      }), S.globals.axisCharts || (A.push(S.config.chart.toolbar.export.csv.headerValue), E.push(A.join(f))), i.map(function(b, M) {
        S.globals.axisCharts ? Z(b, M) : ((A = []).push(S.globals.labels[M].split(f).join("")), A.push(O[M]), E.push(A.join(f)));
      }), L += E.join(y), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + L), o || S.config.chart.toolbar.export.csv.filename, ".csv");
    } }, { key: "triggerDownload", value: function(t, n, i) {
      var o = document.createElement("a");
      o.href = t, o.download = (n || this.w.globals.chartID) + i, document.body.appendChild(o), o.click(), document.body.removeChild(o);
    } }]), B;
  }(), Ut = function() {
    function B(t, n) {
      C(this, B), this.ctx = t, this.elgrid = n, this.w = t.w;
      var i = this.w;
      this.axesUtils = new Rt(t), this.xaxisLabels = i.globals.labels.slice(), i.globals.timescaleLabels.length > 0 && !i.globals.isBarHorizontal && (this.xaxisLabels = i.globals.timescaleLabels.slice()), i.config.xaxis.overwriteCategories && (this.xaxisLabels = i.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], i.config.xaxis.position === "top" ? this.offY = 0 : this.offY = i.globals.gridHeight + 1, this.offY = this.offY + i.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = i.config.chart.type === "bar" && i.config.plotOptions.bar.horizontal, this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.xaxisBorderWidth = i.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = i.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = i.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = i.config.xaxis.axisBorder.height, this.yaxis = i.config.yaxis[0];
    }
    return F(B, [{ key: "drawXaxis", value: function() {
      var t = this.w, n = new re(this.ctx), i = n.group({ class: "apexcharts-xaxis", transform: "translate(".concat(t.config.xaxis.offsetX, ", ").concat(t.config.xaxis.offsetY, ")") }), o = n.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(t.globals.translateXAxisX, ", ").concat(t.globals.translateXAxisY, ")") });
      i.add(o);
      for (var d = [], f = 0; f < this.xaxisLabels.length; f++)
        d.push(this.xaxisLabels[f]);
      if (this.drawXAxisLabelAndGroup(!0, n, o, d, t.globals.isXNumeric, function(P, I) {
        return I;
      }), t.globals.hasXaxisGroups) {
        var p = t.globals.groups;
        d = [];
        for (var y = 0; y < p.length; y++)
          d.push(p[y].title);
        var S = {};
        t.config.xaxis.group.style && (S.xaxisFontSize = t.config.xaxis.group.style.fontSize, S.xaxisFontFamily = t.config.xaxis.group.style.fontFamily, S.xaxisForeColors = t.config.xaxis.group.style.colors, S.fontWeight = t.config.xaxis.group.style.fontWeight, S.cssClass = t.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(!1, n, o, d, !1, function(P, I) {
          return p[P].cols * I;
        }, S);
      }
      if (t.config.xaxis.title.text !== void 0) {
        var A = n.group({ class: "apexcharts-xaxis-title" }), E = n.drawText({ x: t.globals.gridWidth / 2 + t.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + (t.config.xaxis.position === "bottom" ? t.globals.xAxisLabelsHeight : -t.globals.xAxisLabelsHeight - 10) + t.config.xaxis.title.offsetY, text: t.config.xaxis.title.text, textAnchor: "middle", fontSize: t.config.xaxis.title.style.fontSize, fontFamily: t.config.xaxis.title.style.fontFamily, fontWeight: t.config.xaxis.title.style.fontWeight, foreColor: t.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + t.config.xaxis.title.style.cssClass });
        A.add(E), i.add(A);
      }
      if (t.config.xaxis.axisBorder.show) {
        var L = t.globals.barPadForNumericAxis, O = n.drawLine(t.globals.padHorizontal + t.config.xaxis.axisBorder.offsetX - L, this.offY, this.xaxisBorderWidth + L, this.offY, t.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
        this.elgrid && this.elgrid.elGridBorders && t.config.grid.show ? this.elgrid.elGridBorders.add(O) : i.add(O);
      }
      return i;
    } }, { key: "drawXAxisLabelAndGroup", value: function(t, n, i, o, d, f) {
      var p, y = this, S = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : {}, A = [], E = [], L = this.w, O = S.xaxisFontSize || this.xaxisFontSize, P = S.xaxisFontFamily || this.xaxisFontFamily, I = S.xaxisForeColors || this.xaxisForeColors, j = S.fontWeight || L.config.xaxis.labels.style.fontWeight, V = S.cssClass || L.config.xaxis.labels.style.cssClass, Z = L.globals.padHorizontal, b = o.length, M = L.config.xaxis.type === "category" ? L.globals.dataPoints : b;
      if (M === 0 && b > M && (M = b), d) {
        var N = M > 1 ? M - 1 : M;
        p = L.globals.gridWidth / N, Z = Z + f(0, p) / 2 + L.config.xaxis.labels.offsetX;
      } else
        p = L.globals.gridWidth / M, Z = Z + f(0, p) + L.config.xaxis.labels.offsetX;
      for (var X = function(ee) {
        var oe = Z - f(ee, p) / 2 + L.config.xaxis.labels.offsetX;
        ee === 0 && b === 1 && p / 2 === Z && M === 1 && (oe = L.globals.gridWidth / 2);
        var fe = y.axesUtils.getLabel(o, L.globals.timescaleLabels, oe, ee, A, O, t), ke = 28;
        if (L.globals.rotateXLabels && t && (ke = 22), L.config.xaxis.title.text && L.config.xaxis.position === "top" && (ke += parseFloat(L.config.xaxis.title.style.fontSize) + 2), t || (ke = ke + parseFloat(O) + (L.globals.xAxisLabelsHeight - L.globals.xAxisGroupLabelsHeight) + (L.globals.rotateXLabels ? 10 : 0)), fe = L.config.xaxis.tickAmount !== void 0 && L.config.xaxis.tickAmount !== "dataPoints" && L.config.xaxis.type !== "datetime" ? y.axesUtils.checkLabelBasedOnTickamount(ee, fe, b) : y.axesUtils.checkForOverflowingLabels(ee, fe, b, A, E), L.config.xaxis.labels.show) {
          var _e = n.drawText({ x: fe.x, y: y.offY + L.config.xaxis.labels.offsetY + ke - (L.config.xaxis.position === "top" ? L.globals.xAxisHeight + L.config.xaxis.axisTicks.height - 2 : 0), text: fe.text, textAnchor: "middle", fontWeight: fe.isBold ? 600 : j, fontSize: O, fontFamily: P, foreColor: Array.isArray(I) ? t && L.config.xaxis.convertedCatToNumeric ? I[L.globals.minX + ee - 1] : I[ee] : I, isPlainText: !1, cssClass: (t ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + V });
          if (i.add(_e), _e.on("click", function(Ie) {
            if (typeof L.config.chart.events.xAxisLabelClick == "function") {
              var at = Object.assign({}, L, { labelIndex: ee });
              L.config.chart.events.xAxisLabelClick(Ie, y.ctx, at);
            }
          }), t) {
            var Le = document.createElementNS(L.globals.SVGNS, "title");
            Le.textContent = Array.isArray(fe.text) ? fe.text.join(" ") : fe.text, _e.node.appendChild(Le), fe.text !== "" && (A.push(fe.text), E.push(fe));
          }
        }
        ee < b - 1 && (Z += f(ee + 1, p));
      }, Q = 0; Q <= b - 1; Q++)
        X(Q);
    } }, { key: "drawXaxisInversed", value: function(t) {
      var n, i, o = this, d = this.w, f = new re(this.ctx), p = d.config.yaxis[0].opposite ? d.globals.translateYAxisX[t] : 0, y = f.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: t }), S = f.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + p + ", 0)" });
      y.add(S);
      var A = [];
      if (d.config.yaxis[t].show)
        for (var E = 0; E < this.xaxisLabels.length; E++)
          A.push(this.xaxisLabels[E]);
      n = d.globals.gridHeight / A.length, i = -n / 2.2;
      var L = d.globals.yLabelFormatters[0], O = d.config.yaxis[0].labels;
      if (O.show)
        for (var P = function(N) {
          var X = A[N] === void 0 ? "" : A[N];
          X = L(X, { seriesIndex: t, dataPointIndex: N, w: d });
          var Q = o.axesUtils.getYAxisForeColor(O.style.colors, t), ee = 0;
          Array.isArray(X) && (ee = X.length / 2 * parseInt(O.style.fontSize, 10));
          var oe = O.offsetX - 15, fe = "end";
          o.yaxis.opposite && (fe = "start"), d.config.yaxis[0].labels.align === "left" ? (oe = O.offsetX, fe = "start") : d.config.yaxis[0].labels.align === "center" ? (oe = O.offsetX, fe = "middle") : d.config.yaxis[0].labels.align === "right" && (fe = "end");
          var ke = f.drawText({ x: oe, y: i + n + O.offsetY - ee, text: X, textAnchor: fe, foreColor: Array.isArray(Q) ? Q[N] : Q, fontSize: O.style.fontSize, fontFamily: O.style.fontFamily, fontWeight: O.style.fontWeight, isPlainText: !1, cssClass: "apexcharts-yaxis-label " + O.style.cssClass, maxWidth: O.maxWidth });
          S.add(ke), ke.on("click", function(Ie) {
            if (typeof d.config.chart.events.xAxisLabelClick == "function") {
              var at = Object.assign({}, d, { labelIndex: N });
              d.config.chart.events.xAxisLabelClick(Ie, o.ctx, at);
            }
          });
          var _e = document.createElementNS(d.globals.SVGNS, "title");
          if (_e.textContent = Array.isArray(X) ? X.join(" ") : X, ke.node.appendChild(_e), d.config.yaxis[t].labels.rotate !== 0) {
            var Le = f.rotateAroundCenter(ke.node);
            ke.node.setAttribute("transform", "rotate(".concat(d.config.yaxis[t].labels.rotate, " 0 ").concat(Le.y, ")"));
          }
          i += n;
        }, I = 0; I <= A.length - 1; I++)
          P(I);
      if (d.config.yaxis[0].title.text !== void 0) {
        var j = f.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + p + ", 0)" }), V = f.drawText({ x: d.config.yaxis[0].title.offsetX, y: d.globals.gridHeight / 2 + d.config.yaxis[0].title.offsetY, text: d.config.yaxis[0].title.text, textAnchor: "middle", foreColor: d.config.yaxis[0].title.style.color, fontSize: d.config.yaxis[0].title.style.fontSize, fontWeight: d.config.yaxis[0].title.style.fontWeight, fontFamily: d.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + d.config.yaxis[0].title.style.cssClass });
        j.add(V), y.add(j);
      }
      var Z = 0;
      this.isCategoryBarHorizontal && d.config.yaxis[0].opposite && (Z = d.globals.gridWidth);
      var b = d.config.xaxis.axisBorder;
      if (b.show) {
        var M = f.drawLine(d.globals.padHorizontal + b.offsetX + Z, 1 + b.offsetY, d.globals.padHorizontal + b.offsetX + Z, d.globals.gridHeight + b.offsetY, b.color, 0);
        this.elgrid && this.elgrid.elGridBorders && d.config.grid.show ? this.elgrid.elGridBorders.add(M) : y.add(M);
      }
      return d.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(Z, A.length, d.config.yaxis[0].axisBorder, d.config.yaxis[0].axisTicks, 0, n, y), y;
    } }, { key: "drawXaxisTicks", value: function(t, n, i) {
      var o = this.w, d = t;
      if (!(t < 0 || t - 2 > o.globals.gridWidth)) {
        var f = this.offY + o.config.xaxis.axisTicks.offsetY;
        if (n = n + f + o.config.xaxis.axisTicks.height, o.config.xaxis.position === "top" && (n = f - o.config.xaxis.axisTicks.height), o.config.xaxis.axisTicks.show) {
          var p = new re(this.ctx).drawLine(t + o.config.xaxis.axisTicks.offsetX, f + o.config.xaxis.offsetY, d + o.config.xaxis.axisTicks.offsetX, n + o.config.xaxis.offsetY, o.config.xaxis.axisTicks.color);
          i.add(p), p.node.classList.add("apexcharts-xaxis-tick");
        }
      }
    } }, { key: "getXAxisTicksPositions", value: function() {
      var t = this.w, n = [], i = this.xaxisLabels.length, o = t.globals.padHorizontal;
      if (t.globals.timescaleLabels.length > 0)
        for (var d = 0; d < i; d++)
          o = this.xaxisLabels[d].position, n.push(o);
      else
        for (var f = i, p = 0; p < f; p++) {
          var y = f;
          t.globals.isXNumeric && t.config.chart.type !== "bar" && (y -= 1), o += t.globals.gridWidth / y, n.push(o);
        }
      return n;
    } }, { key: "xAxisLabelCorrections", value: function() {
      var t = this.w, n = new re(this.ctx), i = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), d = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), f = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
      if (t.globals.rotateXLabels || t.config.xaxis.labels.rotateAlways)
        for (var p = 0; p < o.length; p++) {
          var y = n.rotateAroundCenter(o[p]);
          y.y = y.y - 1, y.x = y.x + 1, o[p].setAttribute("transform", "rotate(".concat(t.config.xaxis.labels.rotate, " ").concat(y.x, " ").concat(y.y, ")")), o[p].setAttribute("text-anchor", "end"), i.setAttribute("transform", "translate(0, ".concat(-10, ")"));
          var S = o[p].childNodes;
          t.config.xaxis.labels.trim && Array.prototype.forEach.call(S, function(O) {
            n.placeTextWithEllipsis(O, O.textContent, t.globals.xAxisLabelsHeight - (t.config.legend.position === "bottom" ? 20 : 10));
          });
        }
      else
        (function() {
          for (var O = t.globals.gridWidth / (t.globals.labels.length + 1), P = 0; P < o.length; P++) {
            var I = o[P].childNodes;
            t.config.xaxis.labels.trim && t.config.xaxis.type !== "datetime" && Array.prototype.forEach.call(I, function(j) {
              n.placeTextWithEllipsis(j, j.textContent, O);
            });
          }
        })();
      if (d.length > 0) {
        var A = d[d.length - 1].getBBox(), E = d[0].getBBox();
        A.x < -20 && d[d.length - 1].parentNode.removeChild(d[d.length - 1]), E.x + E.width > t.globals.gridWidth && !t.globals.isBarHorizontal && d[0].parentNode.removeChild(d[0]);
        for (var L = 0; L < f.length; L++)
          n.placeTextWithEllipsis(f[L], f[L].textContent, t.config.yaxis[0].labels.maxWidth - (t.config.yaxis[0].title.text ? 2 * parseFloat(t.config.yaxis[0].title.style.fontSize) : 0) - 15);
      }
    } }]), B;
  }(), vn = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
      var n = this.w;
      this.xaxisLabels = n.globals.labels.slice(), this.axesUtils = new Rt(t), this.isRangeBar = n.globals.seriesRange.length && n.globals.isBarHorizontal, n.globals.timescaleLabels.length > 0 && (this.xaxisLabels = n.globals.timescaleLabels.slice());
    }
    return F(B, [{ key: "drawGridArea", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, n = this.w, i = new re(this.ctx);
      t === null && (t = i.group({ class: "apexcharts-grid" }));
      var o = i.drawLine(n.globals.padHorizontal, 1, n.globals.padHorizontal, n.globals.gridHeight, "transparent"), d = i.drawLine(n.globals.padHorizontal, n.globals.gridHeight, n.globals.gridWidth, n.globals.gridHeight, "transparent");
      return t.add(d), t.add(o), t;
    } }, { key: "drawGrid", value: function() {
      var t = null;
      return this.w.globals.axisCharts && (t = this.renderGrid(), this.drawGridArea(t.el)), t;
    } }, { key: "createGridMask", value: function() {
      var t = this.w, n = t.globals, i = new re(this.ctx), o = Array.isArray(t.config.stroke.width) ? 0 : t.config.stroke.width;
      if (Array.isArray(t.config.stroke.width)) {
        var d = 0;
        t.config.stroke.width.forEach(function(E) {
          d = Math.max(d, E);
        }), o = d;
      }
      n.dom.elGridRectMask = document.createElementNS(n.SVGNS, "clipPath"), n.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(n.cuid)), n.dom.elGridRectMarkerMask = document.createElementNS(n.SVGNS, "clipPath"), n.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(n.cuid)), n.dom.elForecastMask = document.createElementNS(n.SVGNS, "clipPath"), n.dom.elForecastMask.setAttribute("id", "forecastMask".concat(n.cuid)), n.dom.elNonForecastMask = document.createElementNS(n.SVGNS, "clipPath"), n.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(n.cuid));
      var f = t.config.chart.type, p = 0, y = 0;
      (f === "bar" || f === "rangeBar" || f === "candlestick" || f === "boxPlot" || t.globals.comboBarCount > 0) && t.globals.isXNumeric && !t.globals.isBarHorizontal && (p = t.config.grid.padding.left, y = t.config.grid.padding.right, n.barPadForNumericAxis > p && (p = n.barPadForNumericAxis, y = n.barPadForNumericAxis)), n.dom.elGridRect = i.drawRect(-o / 2 - p - 2, -o / 2, n.gridWidth + o + y + p + 4, n.gridHeight + o, 0, "#fff");
      var S = t.globals.markers.largestSize + 1;
      n.dom.elGridRectMarker = i.drawRect(2 * -S, 2 * -S, n.gridWidth + 4 * S, n.gridHeight + 4 * S, 0, "#fff"), n.dom.elGridRectMask.appendChild(n.dom.elGridRect.node), n.dom.elGridRectMarkerMask.appendChild(n.dom.elGridRectMarker.node);
      var A = n.dom.baseEl.querySelector("defs");
      A.appendChild(n.dom.elGridRectMask), A.appendChild(n.dom.elForecastMask), A.appendChild(n.dom.elNonForecastMask), A.appendChild(n.dom.elGridRectMarkerMask);
    } }, { key: "_drawGridLines", value: function(t) {
      var n = t.i, i = t.x1, o = t.y1, d = t.x2, f = t.y2, p = t.xCount, y = t.parent, S = this.w;
      if (!(n === 0 && S.globals.skipFirstTimelinelabel || n === p - 1 && S.globals.skipLastTimelinelabel && !S.config.xaxis.labels.formatter || S.config.chart.type === "radar")) {
        S.config.grid.xaxis.lines.show && this._drawGridLine({ i: n, x1: i, y1: o, x2: d, y2: f, xCount: p, parent: y });
        var A = 0;
        if (S.globals.hasXaxisGroups && S.config.xaxis.tickPlacement === "between") {
          var E = S.globals.groups;
          if (E) {
            for (var L = 0, O = 0; L < n && O < E.length; O++)
              L += E[O].cols;
            L === n && (A = 0.6 * S.globals.xAxisLabelsHeight);
          }
        }
        new Ut(this.ctx).drawXaxisTicks(i, A, S.globals.dom.elGraphical);
      }
    } }, { key: "_drawGridLine", value: function(t) {
      var n = t.i, i = t.x1, o = t.y1, d = t.x2, f = t.y2, p = t.xCount, y = t.parent, S = this.w, A = !1, E = y.node.classList.contains("apexcharts-gridlines-horizontal"), L = S.config.grid.strokeDashArray, O = S.globals.barPadForNumericAxis;
      (o === 0 && f === 0 || i === 0 && d === 0) && (A = !0), o === S.globals.gridHeight && f === S.globals.gridHeight && (A = !0), !S.globals.isBarHorizontal || n !== 0 && n !== p - 1 || (A = !0);
      var P = new re(this).drawLine(i - (E ? O : 0), o, d + (E ? O : 0), f, S.config.grid.borderColor, L);
      P.node.classList.add("apexcharts-gridline"), A && S.config.grid.show ? this.elGridBorders.add(P) : y.add(P);
    } }, { key: "_drawGridBandRect", value: function(t) {
      var n = t.c, i = t.x1, o = t.y1, d = t.x2, f = t.y2, p = t.type, y = this.w, S = new re(this.ctx), A = y.globals.barPadForNumericAxis;
      if (p !== "column" || y.config.xaxis.type !== "datetime") {
        var E = y.config.grid[p].colors[n], L = S.drawRect(i - (p === "row" ? A : 0), o, d + (p === "row" ? 2 * A : 0), f, 0, E, y.config.grid[p].opacity);
        this.elg.add(L), L.attr("clip-path", "url(#gridRectMask".concat(y.globals.cuid, ")")), L.node.classList.add("apexcharts-grid-".concat(p));
      }
    } }, { key: "_drawXYLines", value: function(t) {
      var n = this, i = t.xCount, o = t.tickAmount, d = this.w;
      if (d.config.grid.xaxis.lines.show || d.config.xaxis.axisTicks.show) {
        var f, p = d.globals.padHorizontal, y = d.globals.gridHeight;
        d.globals.timescaleLabels.length ? function(P) {
          for (var I = P.xC, j = P.x1, V = P.y1, Z = P.x2, b = P.y2, M = 0; M < I; M++)
            j = n.xaxisLabels[M].position, Z = n.xaxisLabels[M].position, n._drawGridLines({ i: M, x1: j, y1: V, x2: Z, y2: b, xCount: i, parent: n.elgridLinesV });
        }({ xC: i, x1: p, y1: 0, x2: f, y2: y }) : (d.globals.isXNumeric && (i = d.globals.xAxisScale.result.length), function(P) {
          for (var I = P.xC, j = P.x1, V = P.y1, Z = P.x2, b = P.y2, M = 0; M < I + (d.globals.isXNumeric ? 0 : 1); M++)
            M === 0 && I === 1 && d.globals.dataPoints === 1 && (Z = j = d.globals.gridWidth / 2), n._drawGridLines({ i: M, x1: j, y1: V, x2: Z, y2: b, xCount: i, parent: n.elgridLinesV }), Z = j += d.globals.gridWidth / (d.globals.isXNumeric ? I - 1 : I);
        }({ xC: i, x1: p, y1: 0, x2: f, y2: y }));
      }
      if (d.config.grid.yaxis.lines.show) {
        var S = 0, A = 0, E = d.globals.gridWidth, L = o + 1;
        this.isRangeBar && (L = d.globals.labels.length);
        for (var O = 0; O < L + (this.isRangeBar ? 1 : 0); O++)
          this._drawGridLine({ i: O, xCount: L + (this.isRangeBar ? 1 : 0), x1: 0, y1: S, x2: E, y2: A, parent: this.elgridLinesH }), A = S += d.globals.gridHeight / (this.isRangeBar ? L : o);
      }
    } }, { key: "_drawInvertedXYLines", value: function(t) {
      var n = t.xCount, i = this.w;
      if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show)
        for (var o, d = i.globals.padHorizontal, f = i.globals.gridHeight, p = 0; p < n + 1; p++)
          i.config.grid.xaxis.lines.show && this._drawGridLine({ i: p, xCount: n + 1, x1: d, y1: 0, x2: o, y2: f, parent: this.elgridLinesV }), new Ut(this.ctx).drawXaxisTicks(d, 0, i.globals.dom.elGraphical), o = d = d + i.globals.gridWidth / n + 0.3;
      if (i.config.grid.yaxis.lines.show)
        for (var y = 0, S = 0, A = i.globals.gridWidth, E = 0; E < i.globals.dataPoints + 1; E++)
          this._drawGridLine({ i: E, xCount: i.globals.dataPoints + 1, x1: 0, y1: y, x2: A, y2: S, parent: this.elgridLinesH }), S = y += i.globals.gridHeight / i.globals.dataPoints;
    } }, { key: "renderGrid", value: function() {
      var t = this.w, n = new re(this.ctx);
      this.elg = n.group({ class: "apexcharts-grid" }), this.elgridLinesH = n.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = n.group({ class: "apexcharts-gridlines-vertical" }), this.elGridBorders = n.group({ class: "apexcharts-grid-borders" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
      for (var i, o = t.globals.yAxisScale.length ? t.globals.yAxisScale[0].result.length - 1 : 5, d = 0; d < t.globals.series.length && (t.globals.yAxisScale[d] !== void 0 && (o = t.globals.yAxisScale[d].result.length - 1), !(o > 2)); d++)
        ;
      return !t.globals.isBarHorizontal || this.isRangeBar ? (i = this.xaxisLabels.length, this.isRangeBar && (i--, o = t.globals.labels.length, t.config.xaxis.tickAmount && t.config.xaxis.labels.formatter && (i = t.config.xaxis.tickAmount)), this._drawXYLines({ xCount: i, tickAmount: o })) : (i = o, o = t.globals.xTickAmount, this._drawInvertedXYLines({ xCount: i, tickAmount: o })), this.drawGridBands(i, o), { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: t.globals.gridWidth / i };
    } }, { key: "drawGridBands", value: function(t, n) {
      var i = this.w;
      if (i.config.grid.row.colors !== void 0 && i.config.grid.row.colors.length > 0)
        for (var o = 0, d = i.globals.gridHeight / n, f = i.globals.gridWidth, p = 0, y = 0; p < n; p++, y++)
          y >= i.config.grid.row.colors.length && (y = 0), this._drawGridBandRect({ c: y, x1: 0, y1: o, x2: f, y2: d, type: "row" }), o += i.globals.gridHeight / n;
      if (i.config.grid.column.colors !== void 0 && i.config.grid.column.colors.length > 0)
        for (var S = i.globals.isBarHorizontal || i.config.xaxis.type !== "category" && !i.config.xaxis.convertedCatToNumeric ? t : t - 1, A = i.globals.padHorizontal, E = i.globals.padHorizontal + i.globals.gridWidth / S, L = i.globals.gridHeight, O = 0, P = 0; O < t; O++, P++)
          P >= i.config.grid.column.colors.length && (P = 0), this._drawGridBandRect({ c: P, x1: A, y1: 0, x2: E, y2: L, type: "column" }), A += i.globals.gridWidth / S;
    } }]), B;
  }(), qe = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "niceScale", value: function(t, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, d = arguments.length > 4 ? arguments[4] : void 0, f = this.w, p = Math.abs(n - t);
      if ((i = this._adjustTicksForSmallRange(i, o, p)) === "dataPoints" && (i = f.globals.dataPoints - 1), t === Number.MIN_VALUE && n === 0 || !K.isNumber(t) && !K.isNumber(n) || t === Number.MIN_VALUE && n === -Number.MAX_VALUE)
        return t = 0, n = i, this.linearScale(t, n, i);
      t > n ? (console.warn("axis.min cannot be greater than axis.max"), n = t + 0.1) : t === n && (t = t === 0 ? 0 : t - 0.5, n = n === 0 ? 2 : n + 0.5);
      var y = [];
      p < 1 && d && (f.config.chart.type === "candlestick" || f.config.series[o].type === "candlestick" || f.config.chart.type === "boxPlot" || f.config.series[o].type === "boxPlot" || f.globals.isRangeData) && (n *= 1.01);
      var S = i + 1;
      S < 2 ? S = 2 : S > 2 && (S -= 2);
      var A = p / S, E = Math.floor(K.log10(A)), L = Math.pow(10, E), O = Math.round(A / L);
      O < 1 && (O = 1);
      var P = O * L, I = P * Math.floor(t / P), j = P * Math.ceil(n / P), V = I;
      if (d && p > 2) {
        for (; y.push(K.stripNumber(V, 7)), !((V += P) > j); )
          ;
        return { result: y, niceMin: y[0], niceMax: y[y.length - 1] };
      }
      var Z = t;
      (y = []).push(K.stripNumber(Z, 7));
      for (var b = Math.abs(n - t) / i, M = 0; M <= i; M++)
        Z += b, y.push(Z);
      return y[y.length - 2] >= n && y.pop(), { result: y, niceMin: y[0], niceMax: y[y.length - 1] };
    } }, { key: "linearScale", value: function(t, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, o = arguments.length > 3 ? arguments[3] : void 0, d = Math.abs(n - t);
      (i = this._adjustTicksForSmallRange(i, o, d)) === "dataPoints" && (i = this.w.globals.dataPoints - 1);
      var f = d / i;
      i === Number.MAX_VALUE && (i = 10, f = 1);
      for (var p = [], y = t; i >= 0; )
        p.push(y), y += f, i -= 1;
      return { result: p, niceMin: p[0], niceMax: p[p.length - 1] };
    } }, { key: "logarithmicScaleNice", value: function(t, n, i) {
      n <= 0 && (n = Math.max(t, i)), t <= 0 && (t = Math.min(n, i));
      for (var o = [], d = Math.ceil(Math.log(n) / Math.log(i) + 1), f = Math.floor(Math.log(t) / Math.log(i)); f < d; f++)
        o.push(Math.pow(i, f));
      return { result: o, niceMin: o[0], niceMax: o[o.length - 1] };
    } }, { key: "logarithmicScale", value: function(t, n, i) {
      n <= 0 && (n = Math.max(t, i)), t <= 0 && (t = Math.min(n, i));
      for (var o = [], d = Math.log(n) / Math.log(i), f = Math.log(t) / Math.log(i), p = d - f, y = Math.round(p), S = p / y, A = 0, E = f; A < y; A++, E += S)
        o.push(Math.pow(i, E));
      return o.push(Math.pow(i, d)), { result: o, niceMin: t, niceMax: n };
    } }, { key: "_adjustTicksForSmallRange", value: function(t, n, i) {
      var o = t;
      if (n !== void 0 && this.w.config.yaxis[n].labels.formatter && this.w.config.yaxis[n].tickAmount === void 0) {
        var d = Number(this.w.config.yaxis[n].labels.formatter(1));
        K.isNumber(d) && this.w.globals.yValueDecimal === 0 && (o = Math.ceil(i));
      }
      return o < t ? o : t;
    } }, { key: "setYScaleForIndex", value: function(t, n, i) {
      var o = this.w.globals, d = this.w.config, f = o.isBarHorizontal ? d.xaxis : d.yaxis[t];
      o.yAxisScale[t] === void 0 && (o.yAxisScale[t] = []);
      var p = Math.abs(i - n);
      if (f.logarithmic && p <= 5 && (o.invalidLogScale = !0), f.logarithmic && p > 5)
        o.allSeriesCollapsed = !1, o.yAxisScale[t] = this.logarithmicScale(n, i, f.logBase), o.yAxisScale[t] = f.forceNiceScale ? this.logarithmicScaleNice(n, i, f.logBase) : this.logarithmicScale(n, i, f.logBase);
      else if (i !== -Number.MAX_VALUE && K.isNumber(i))
        if (o.allSeriesCollapsed = !1, f.min === void 0 && f.max === void 0 || f.forceNiceScale) {
          var y = d.yaxis[t].max === void 0 && d.yaxis[t].min === void 0 || d.yaxis[t].forceNiceScale;
          o.yAxisScale[t] = this.niceScale(n, i, f.tickAmount ? f.tickAmount : p < 5 && p > 1 ? p + 1 : 5, t, y);
        } else
          o.yAxisScale[t] = this.linearScale(n, i, f.tickAmount, t);
      else
        o.yAxisScale[t] = this.linearScale(0, 5, 5);
    } }, { key: "setXScale", value: function(t, n) {
      var i = this.w, o = i.globals, d = i.config.xaxis, f = Math.abs(n - t);
      return n !== -Number.MAX_VALUE && K.isNumber(n) ? o.xAxisScale = this.linearScale(t, n, d.tickAmount ? d.tickAmount : f < 5 && f > 1 ? f + 1 : 5, 0) : o.xAxisScale = this.linearScale(0, 5, 5), o.xAxisScale;
    } }, { key: "setMultipleYScales", value: function() {
      var t = this, n = this.w.globals, i = this.w.config, o = n.minYArr.concat([]), d = n.maxYArr.concat([]), f = [];
      i.yaxis.forEach(function(p, y) {
        var S = y;
        i.series.forEach(function(L, O) {
          L.name === p.seriesName && (S = O, y !== O ? f.push({ index: O, similarIndex: y, alreadyExists: !0 }) : f.push({ index: O }));
        });
        var A = o[S], E = d[S];
        t.setYScaleForIndex(y, A, E);
      }), this.sameScaleInMultipleAxes(o, d, f);
    } }, { key: "sameScaleInMultipleAxes", value: function(t, n, i) {
      var o = this, d = this.w.config, f = this.w.globals, p = [];
      i.forEach(function(I) {
        I.alreadyExists && (p[I.index] === void 0 && (p[I.index] = []), p[I.index].push(I.index), p[I.index].push(I.similarIndex));
      }), f.yAxisSameScaleIndices = p, p.forEach(function(I, j) {
        p.forEach(function(V, Z) {
          var b, M;
          j !== Z && (b = I, M = V, b.filter(function(N) {
            return M.indexOf(N) !== -1;
          })).length > 0 && (p[j] = p[j].concat(p[Z]));
        });
      });
      var y = p.map(function(I) {
        return I.filter(function(j, V) {
          return I.indexOf(j) === V;
        });
      }).map(function(I) {
        return I.sort();
      });
      p = p.filter(function(I) {
        return !!I;
      });
      var S = y.slice(), A = S.map(function(I) {
        return JSON.stringify(I);
      });
      S = S.filter(function(I, j) {
        return A.indexOf(JSON.stringify(I)) === j;
      });
      var E = [], L = [];
      t.forEach(function(I, j) {
        S.forEach(function(V, Z) {
          V.indexOf(j) > -1 && (E[Z] === void 0 && (E[Z] = [], L[Z] = []), E[Z].push({ key: j, value: I }), L[Z].push({ key: j, value: n[j] }));
        });
      });
      var O = Array.apply(null, Array(S.length)).map(Number.prototype.valueOf, Number.MIN_VALUE), P = Array.apply(null, Array(S.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
      E.forEach(function(I, j) {
        I.forEach(function(V, Z) {
          O[j] = Math.min(V.value, O[j]);
        });
      }), L.forEach(function(I, j) {
        I.forEach(function(V, Z) {
          P[j] = Math.max(V.value, P[j]);
        });
      }), t.forEach(function(I, j) {
        L.forEach(function(V, Z) {
          var b = O[Z], M = P[Z];
          d.chart.stacked && (M = 0, V.forEach(function(N, X) {
            N.value !== -Number.MAX_VALUE && (M += N.value), b !== Number.MIN_VALUE && (b += E[Z][X].value);
          })), V.forEach(function(N, X) {
            V[X].key === j && (d.yaxis[j].min !== void 0 && (b = typeof d.yaxis[j].min == "function" ? d.yaxis[j].min(f.minY) : d.yaxis[j].min), d.yaxis[j].max !== void 0 && (M = typeof d.yaxis[j].max == "function" ? d.yaxis[j].max(f.maxY) : d.yaxis[j].max), o.setYScaleForIndex(j, b, M));
          });
        });
      });
    } }, { key: "autoScaleY", value: function(t, n, i) {
      t || (t = this);
      var o = t.w;
      if (o.globals.isMultipleYAxis || o.globals.collapsedSeries.length)
        return console.warn("autoScaleYaxis is not supported in a multi-yaxis chart."), n;
      var d = o.globals.seriesX[0], f = o.config.chart.stacked;
      return n.forEach(function(p, y) {
        for (var S = 0, A = 0; A < d.length; A++)
          if (d[A] >= i.xaxis.min) {
            S = A;
            break;
          }
        var E, L, O = o.globals.minYArr[y], P = o.globals.maxYArr[y], I = o.globals.stackedSeriesTotals;
        o.globals.series.forEach(function(j, V) {
          var Z = j[S];
          f ? (Z = I[S], E = L = Z, I.forEach(function(b, M) {
            d[M] <= i.xaxis.max && d[M] >= i.xaxis.min && (b > L && b !== null && (L = b), j[M] < E && j[M] !== null && (E = j[M]));
          })) : (E = L = Z, j.forEach(function(b, M) {
            if (d[M] <= i.xaxis.max && d[M] >= i.xaxis.min) {
              var N = b, X = b;
              o.globals.series.forEach(function(Q, ee) {
                b !== null && (N = Math.min(Q[M], N), X = Math.max(Q[M], X));
              }), X > L && X !== null && (L = X), N < E && N !== null && (E = N);
            }
          })), E === void 0 && L === void 0 && (E = O, L = P), L *= L < 0 ? 0.9 : 1.1, (E *= E < 0 ? 1.1 : 0.9) === 0 && L === 0 && (E = -1, L = 1), L < 0 && L < P && (L = P), E < 0 && E > O && (E = O), n.length > 1 ? (n[V].min = p.min === void 0 ? E : p.min, n[V].max = p.max === void 0 ? L : p.max) : (n[0].min = p.min === void 0 ? E : p.min, n[0].max = p.max === void 0 ? L : p.max);
        });
      }), n;
    } }]), B;
  }(), pn = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w, this.scales = new qe(t);
    }
    return F(B, [{ key: "init", value: function() {
      this.setYRange(), this.setXRange(), this.setZRange();
    } }, { key: "getMinYMaxY", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -Number.MAX_VALUE, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, d = this.w.config, f = this.w.globals, p = -Number.MAX_VALUE, y = Number.MIN_VALUE;
      o === null && (o = t + 1);
      var S = f.series, A = S, E = S;
      d.chart.type === "candlestick" ? (A = f.seriesCandleL, E = f.seriesCandleH) : d.chart.type === "boxPlot" ? (A = f.seriesCandleO, E = f.seriesCandleC) : f.isRangeData && (A = f.seriesRangeStart, E = f.seriesRangeEnd);
      for (var L = t; L < o; L++) {
        f.dataPoints = Math.max(f.dataPoints, S[L].length), f.categoryLabels.length && (f.dataPoints = f.categoryLabels.filter(function(I) {
          return I !== void 0;
        }).length), f.labels.length && d.xaxis.type !== "datetime" && f.series.reduce(function(I, j) {
          return I + j.length;
        }, 0) !== 0 && (f.dataPoints = Math.max(f.dataPoints, f.labels.length));
        for (var O = 0; O < f.series[L].length; O++) {
          var P = S[L][O];
          P !== null && K.isNumber(P) ? (E[L][O] !== void 0 && (p = Math.max(p, E[L][O]), n = Math.min(n, E[L][O])), A[L][O] !== void 0 && (n = Math.min(n, A[L][O]), i = Math.max(i, A[L][O])), this.w.config.chart.type !== "candlestick" && this.w.config.chart.type !== "boxPlot" && this.w.config.chart.type === "rangeArea" && this.w.config.chart.type === "rangeBar" || (this.w.config.chart.type !== "candlestick" && this.w.config.chart.type !== "boxPlot" || f.seriesCandleC[L][O] !== void 0 && (p = Math.max(p, f.seriesCandleO[L][O]), p = Math.max(p, f.seriesCandleH[L][O]), p = Math.max(p, f.seriesCandleL[L][O]), p = Math.max(p, f.seriesCandleC[L][O]), this.w.config.chart.type === "boxPlot" && (p = Math.max(p, f.seriesCandleM[L][O]))), !d.series[L].type || d.series[L].type === "candlestick" && d.series[L].type === "boxPlot" && d.series[L].type === "rangeArea" && d.series[L].type === "rangeBar" || (p = Math.max(p, f.series[L][O]), n = Math.min(n, f.series[L][O])), i = p), f.seriesGoals[L] && f.seriesGoals[L][O] && Array.isArray(f.seriesGoals[L][O]) && f.seriesGoals[L][O].forEach(function(I) {
            y !== Number.MIN_VALUE && (y = Math.min(y, I.value), n = y), p = Math.max(p, I.value), i = p;
          }), K.isFloat(P) && (P = K.noExponents(P), f.yValueDecimal = Math.max(f.yValueDecimal, P.toString().split(".")[1].length)), y > A[L][O] && A[L][O] < 0 && (y = A[L][O])) : f.hasNullValues = !0;
        }
      }
      return d.chart.type === "rangeBar" && f.seriesRangeStart.length && f.isBarHorizontal && (y = n), d.chart.type === "bar" && (y < 0 && p < 0 && (p = 0), y === Number.MIN_VALUE && (y = 0)), { minY: y, maxY: p, lowestY: n, highestY: i };
    } }, { key: "setYRange", value: function() {
      var t = this.w.globals, n = this.w.config;
      t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE;
      var i = Number.MAX_VALUE;
      if (t.isMultipleYAxis)
        for (var o = 0; o < t.series.length; o++) {
          var d = this.getMinYMaxY(o, i, null, o + 1);
          t.minYArr.push(d.minY), t.maxYArr.push(d.maxY), i = d.lowestY;
        }
      var f = this.getMinYMaxY(0, i, null, t.series.length);
      if (t.minY = f.minY, t.maxY = f.maxY, i = f.lowestY, n.chart.stacked && this._setStackedMinMax(), (n.chart.type === "line" || n.chart.type === "area" || n.chart.type === "candlestick" || n.chart.type === "boxPlot" || n.chart.type === "rangeBar" && !t.isBarHorizontal) && t.minY === Number.MIN_VALUE && i !== -Number.MAX_VALUE && i !== t.maxY) {
        var p = t.maxY - i;
        (i >= 0 && i <= 10 || n.yaxis[0].min !== void 0 || n.yaxis[0].max !== void 0) && (p = 0), t.minY = i - 5 * p / 100, i > 0 && t.minY < 0 && (t.minY = 0), t.maxY = t.maxY + 5 * p / 100;
      }
      return n.yaxis.forEach(function(y, S) {
        y.max !== void 0 && (typeof y.max == "number" ? t.maxYArr[S] = y.max : typeof y.max == "function" && (t.maxYArr[S] = y.max(t.isMultipleYAxis ? t.maxYArr[S] : t.maxY)), t.maxY = t.maxYArr[S]), y.min !== void 0 && (typeof y.min == "number" ? t.minYArr[S] = y.min : typeof y.min == "function" && (t.minYArr[S] = y.min(t.isMultipleYAxis ? t.minYArr[S] === Number.MIN_VALUE ? 0 : t.minYArr[S] : t.minY)), t.minY = t.minYArr[S]);
      }), t.isBarHorizontal && ["min", "max"].forEach(function(y) {
        n.xaxis[y] !== void 0 && typeof n.xaxis[y] == "number" && (y === "min" ? t.minY = n.xaxis[y] : t.maxY = n.xaxis[y]);
      }), t.isMultipleYAxis ? (this.scales.setMultipleYScales(), t.minY = i, t.yAxisScale.forEach(function(y, S) {
        t.minYArr[S] = y.niceMin, t.maxYArr[S] = y.niceMax;
      })) : (this.scales.setYScaleForIndex(0, t.minY, t.maxY), t.minY = t.yAxisScale[0].niceMin, t.maxY = t.yAxisScale[0].niceMax, t.minYArr[0] = t.yAxisScale[0].niceMin, t.maxYArr[0] = t.yAxisScale[0].niceMax), { minY: t.minY, maxY: t.maxY, minYArr: t.minYArr, maxYArr: t.maxYArr, yAxisScale: t.yAxisScale };
    } }, { key: "setXRange", value: function() {
      var t = this.w.globals, n = this.w.config, i = n.xaxis.type === "numeric" || n.xaxis.type === "datetime" || n.xaxis.type === "category" && !t.noLabelsProvided || t.noLabelsProvided || t.isXNumeric;
      if (t.isXNumeric && function() {
        for (var p = 0; p < t.series.length; p++)
          if (t.labels[p])
            for (var y = 0; y < t.labels[p].length; y++)
              t.labels[p][y] !== null && K.isNumber(t.labels[p][y]) && (t.maxX = Math.max(t.maxX, t.labels[p][y]), t.initialMaxX = Math.max(t.maxX, t.labels[p][y]), t.minX = Math.min(t.minX, t.labels[p][y]), t.initialMinX = Math.min(t.minX, t.labels[p][y]));
      }(), t.noLabelsProvided && n.xaxis.categories.length === 0 && (t.maxX = t.labels[t.labels.length - 1], t.initialMaxX = t.labels[t.labels.length - 1], t.minX = 1, t.initialMinX = 1), t.isXNumeric || t.noLabelsProvided || t.dataFormatXNumeric) {
        var o;
        if (n.xaxis.tickAmount === void 0 ? (o = Math.round(t.svgWidth / 150), n.xaxis.type === "numeric" && t.dataPoints < 30 && (o = t.dataPoints - 1), o > t.dataPoints && t.dataPoints !== 0 && (o = t.dataPoints - 1)) : n.xaxis.tickAmount === "dataPoints" ? (t.series.length > 1 && (o = t.series[t.maxValsInArrayIndex].length - 1), t.isXNumeric && (o = t.maxX - t.minX - 1)) : o = n.xaxis.tickAmount, t.xTickAmount = o, n.xaxis.max !== void 0 && typeof n.xaxis.max == "number" && (t.maxX = n.xaxis.max), n.xaxis.min !== void 0 && typeof n.xaxis.min == "number" && (t.minX = n.xaxis.min), n.xaxis.range !== void 0 && (t.minX = t.maxX - n.xaxis.range), t.minX !== Number.MAX_VALUE && t.maxX !== -Number.MAX_VALUE)
          if (n.xaxis.convertedCatToNumeric && !t.dataFormatXNumeric) {
            for (var d = [], f = t.minX - 1; f < t.maxX; f++)
              d.push(f + 1);
            t.xAxisScale = { result: d, niceMin: d[0], niceMax: d[d.length - 1] };
          } else
            t.xAxisScale = this.scales.setXScale(t.minX, t.maxX);
        else
          t.xAxisScale = this.scales.linearScale(1, o, o), t.noLabelsProvided && t.labels.length > 0 && (t.xAxisScale = this.scales.linearScale(1, t.labels.length, o - 1), t.seriesX = t.labels.slice());
        i && (t.labels = t.xAxisScale.result.slice());
      }
      return t.isBarHorizontal && t.labels.length && (t.xTickAmount = t.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: t.minX, maxX: t.maxX };
    } }, { key: "setZRange", value: function() {
      var t = this.w.globals;
      if (t.isDataXYZ) {
        for (var n = 0; n < t.series.length; n++)
          if (t.seriesZ[n] !== void 0)
            for (var i = 0; i < t.seriesZ[n].length; i++)
              t.seriesZ[n][i] !== null && K.isNumber(t.seriesZ[n][i]) && (t.maxZ = Math.max(t.maxZ, t.seriesZ[n][i]), t.minZ = Math.min(t.minZ, t.seriesZ[n][i]));
      }
    } }, { key: "_handleSingleDataPoint", value: function() {
      var t = this.w.globals, n = this.w.config;
      if (t.minX === t.maxX) {
        var i = new Ze(this.ctx);
        if (n.xaxis.type === "datetime") {
          var o = i.getDate(t.minX);
          n.xaxis.labels.datetimeUTC ? o.setUTCDate(o.getUTCDate() - 2) : o.setDate(o.getDate() - 2), t.minX = new Date(o).getTime();
          var d = i.getDate(t.maxX);
          n.xaxis.labels.datetimeUTC ? d.setUTCDate(d.getUTCDate() + 2) : d.setDate(d.getDate() + 2), t.maxX = new Date(d).getTime();
        } else
          (n.xaxis.type === "numeric" || n.xaxis.type === "category" && !t.noLabelsProvided) && (t.minX = t.minX - 2, t.initialMinX = t.minX, t.maxX = t.maxX + 2, t.initialMaxX = t.maxX);
      }
    } }, { key: "_getMinXDiff", value: function() {
      var t = this.w.globals;
      t.isXNumeric && t.seriesX.forEach(function(n, i) {
        n.length === 1 && n.push(t.seriesX[t.maxValsInArrayIndex][t.seriesX[t.maxValsInArrayIndex].length - 1]);
        var o = n.slice();
        o.sort(function(d, f) {
          return d - f;
        }), o.forEach(function(d, f) {
          if (f > 0) {
            var p = d - o[f - 1];
            p > 0 && (t.minXDiff = Math.min(p, t.minXDiff));
          }
        }), t.dataPoints !== 1 && t.minXDiff !== Number.MAX_VALUE || (t.minXDiff = 0.5);
      });
    } }, { key: "_setStackedMinMax", value: function() {
      var t = this, n = this.w.globals;
      if (n.series.length) {
        var i = n.seriesGroups;
        i.length || (i = [this.w.config.series.map(function(f) {
          return f.name;
        })]);
        var o = {}, d = {};
        i.forEach(function(f) {
          o[f] = [], d[f] = [], t.w.config.series.map(function(p, y) {
            return f.indexOf(p.name) > -1 ? y : null;
          }).filter(function(p) {
            return p !== null;
          }).forEach(function(p) {
            for (var y = 0; y < n.series[n.maxValsInArrayIndex].length; y++)
              o[f][y] === void 0 && (o[f][y] = 0, d[f][y] = 0), n.series[p][y] !== null && K.isNumber(n.series[p][y]) && (n.series[p][y] > 0 ? o[f][y] += parseFloat(n.series[p][y]) + 1e-4 : d[f][y] += parseFloat(n.series[p][y]));
          });
        }), Object.entries(o).forEach(function(f) {
          var p = ae(f, 1)[0];
          o[p].forEach(function(y, S) {
            n.maxY = Math.max(n.maxY, o[p][S]), n.minY = Math.min(n.minY, d[p][S]);
          });
        });
      }
    } }]), B;
  }(), jn = function() {
    function B(t, n) {
      C(this, B), this.ctx = t, this.elgrid = n, this.w = t.w;
      var i = this.w;
      this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.axisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = i.config.chart.type === "bar" && i.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, i.config.xaxis.position === "bottom" && (this.xAxisoffX = i.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new Rt(t);
    }
    return F(B, [{ key: "drawYaxis", value: function(t) {
      var n = this, i = this.w, o = new re(this.ctx), d = i.config.yaxis[t].labels.style, f = d.fontSize, p = d.fontFamily, y = d.fontWeight, S = o.group({ class: "apexcharts-yaxis", rel: t, transform: "translate(" + i.globals.translateYAxisX[t] + ", 0)" });
      if (this.axesUtils.isYAxisHidden(t))
        return S;
      var A = o.group({ class: "apexcharts-yaxis-texts-g" });
      S.add(A);
      var E = i.globals.yAxisScale[t].result.length - 1, L = i.globals.gridHeight / E, O = i.globals.translateY, P = i.globals.yLabelFormatters[t], I = i.globals.yAxisScale[t].result.slice();
      I = this.axesUtils.checkForReversedLabels(t, I);
      var j = "";
      if (i.config.yaxis[t].labels.show)
        for (var V = function(oe) {
          var fe = I[oe];
          fe = P(fe, oe, i);
          var ke = i.config.yaxis[t].labels.padding;
          i.config.yaxis[t].opposite && i.config.yaxis.length !== 0 && (ke *= -1);
          var _e = "end";
          i.config.yaxis[t].opposite && (_e = "start"), i.config.yaxis[t].labels.align === "left" ? _e = "start" : i.config.yaxis[t].labels.align === "center" ? _e = "middle" : i.config.yaxis[t].labels.align === "right" && (_e = "end");
          var Le = n.axesUtils.getYAxisForeColor(d.colors, t), Ie = o.drawText({ x: ke, y: O + E / 10 + i.config.yaxis[t].labels.offsetY + 1, text: fe, textAnchor: _e, fontSize: f, fontFamily: p, fontWeight: y, maxWidth: i.config.yaxis[t].labels.maxWidth, foreColor: Array.isArray(Le) ? Le[oe] : Le, isPlainText: !1, cssClass: "apexcharts-yaxis-label " + d.cssClass });
          oe === E && (j = Ie), A.add(Ie);
          var at = document.createElementNS(i.globals.SVGNS, "title");
          if (at.textContent = Array.isArray(fe) ? fe.join(" ") : fe, Ie.node.appendChild(at), i.config.yaxis[t].labels.rotate !== 0) {
            var Qt = o.rotateAroundCenter(j.node), Kt = o.rotateAroundCenter(Ie.node);
            Ie.node.setAttribute("transform", "rotate(".concat(i.config.yaxis[t].labels.rotate, " ").concat(Qt.x, " ").concat(Kt.y, ")"));
          }
          O += L;
        }, Z = E; Z >= 0; Z--)
          V(Z);
      if (i.config.yaxis[t].title.text !== void 0) {
        var b = o.group({ class: "apexcharts-yaxis-title" }), M = 0;
        i.config.yaxis[t].opposite && (M = i.globals.translateYAxisX[t]);
        var N = o.drawText({ x: M, y: i.globals.gridHeight / 2 + i.globals.translateY + i.config.yaxis[t].title.offsetY, text: i.config.yaxis[t].title.text, textAnchor: "end", foreColor: i.config.yaxis[t].title.style.color, fontSize: i.config.yaxis[t].title.style.fontSize, fontWeight: i.config.yaxis[t].title.style.fontWeight, fontFamily: i.config.yaxis[t].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + i.config.yaxis[t].title.style.cssClass });
        b.add(N), S.add(b);
      }
      var X = i.config.yaxis[t].axisBorder, Q = 31 + X.offsetX;
      if (i.config.yaxis[t].opposite && (Q = -31 - X.offsetX), X.show) {
        var ee = o.drawLine(Q, i.globals.translateY + X.offsetY - 2, Q, i.globals.gridHeight + i.globals.translateY + X.offsetY + 2, X.color, 0, X.width);
        S.add(ee);
      }
      return i.config.yaxis[t].axisTicks.show && this.axesUtils.drawYAxisTicks(Q, E, X, i.config.yaxis[t].axisTicks, t, L, S), S;
    } }, { key: "drawYaxisInversed", value: function(t) {
      var n = this.w, i = new re(this.ctx), o = i.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), d = i.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(n.globals.translateXAxisX, ", ").concat(n.globals.translateXAxisY, ")") });
      o.add(d);
      var f = n.globals.yAxisScale[t].result.length - 1, p = n.globals.gridWidth / f + 0.1, y = p + n.config.xaxis.labels.offsetX, S = n.globals.xLabelFormatter, A = n.globals.yAxisScale[t].result.slice(), E = n.globals.timescaleLabels;
      E.length > 0 && (this.xaxisLabels = E.slice(), f = (A = E.slice()).length), A = this.axesUtils.checkForReversedLabels(t, A);
      var L = E.length;
      if (n.config.xaxis.labels.show)
        for (var O = L ? 0 : f; L ? O < L : O >= 0; L ? O++ : O--) {
          var P = A[O];
          P = S(P, O, n);
          var I = n.globals.gridWidth + n.globals.padHorizontal - (y - p + n.config.xaxis.labels.offsetX);
          if (E.length) {
            var j = this.axesUtils.getLabel(A, E, I, O, this.drawnLabels, this.xaxisFontSize);
            I = j.x, P = j.text, this.drawnLabels.push(j.text), O === 0 && n.globals.skipFirstTimelinelabel && (P = ""), O === A.length - 1 && n.globals.skipLastTimelinelabel && (P = "");
          }
          var V = i.drawText({ x: I, y: this.xAxisoffX + n.config.xaxis.labels.offsetY + 30 - (n.config.xaxis.position === "top" ? n.globals.xAxisHeight + n.config.xaxis.axisTicks.height - 2 : 0), text: P, textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: n.config.xaxis.labels.style.fontWeight, isPlainText: !1, cssClass: "apexcharts-xaxis-label " + n.config.xaxis.labels.style.cssClass });
          d.add(V), V.tspan(P);
          var Z = document.createElementNS(n.globals.SVGNS, "title");
          Z.textContent = P, V.node.appendChild(Z), y += p;
        }
      return this.inversedYAxisTitleText(o), this.inversedYAxisBorder(o), o;
    } }, { key: "inversedYAxisBorder", value: function(t) {
      var n = this.w, i = new re(this.ctx), o = n.config.xaxis.axisBorder;
      if (o.show) {
        var d = 0;
        n.config.chart.type === "bar" && n.globals.isXNumeric && (d -= 15);
        var f = i.drawLine(n.globals.padHorizontal + d + o.offsetX, this.xAxisoffX, n.globals.gridWidth, this.xAxisoffX, o.color, 0, o.height);
        this.elgrid && this.elgrid.elGridBorders && n.config.grid.show ? this.elgrid.elGridBorders.add(f) : t.add(f);
      }
    } }, { key: "inversedYAxisTitleText", value: function(t) {
      var n = this.w, i = new re(this.ctx);
      if (n.config.xaxis.title.text !== void 0) {
        var o = i.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), d = i.drawText({ x: n.globals.gridWidth / 2 + n.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(n.config.xaxis.title.style.fontSize) + n.config.xaxis.title.offsetY + 20, text: n.config.xaxis.title.text, textAnchor: "middle", fontSize: n.config.xaxis.title.style.fontSize, fontFamily: n.config.xaxis.title.style.fontFamily, fontWeight: n.config.xaxis.title.style.fontWeight, foreColor: n.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + n.config.xaxis.title.style.cssClass });
        o.add(d), t.add(o);
      }
    } }, { key: "yAxisTitleRotate", value: function(t, n) {
      var i = this.w, o = new re(this.ctx), d = { width: 0, height: 0 }, f = { width: 0, height: 0 }, p = i.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-texts-g"));
      p !== null && (d = p.getBoundingClientRect());
      var y = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-title text"));
      if (y !== null && (f = y.getBoundingClientRect()), y !== null) {
        var S = this.xPaddingForYAxisTitle(t, d, f, n);
        y.setAttribute("x", S.xPos - (n ? 10 : 0));
      }
      if (y !== null) {
        var A = o.rotateAroundCenter(y);
        y.setAttribute("transform", "rotate(".concat(n ? -1 * i.config.yaxis[t].title.rotate : i.config.yaxis[t].title.rotate, " ").concat(A.x, " ").concat(A.y, ")"));
      }
    } }, { key: "xPaddingForYAxisTitle", value: function(t, n, i, o) {
      var d = this.w, f = 0, p = 0, y = 10;
      return d.config.yaxis[t].title.text === void 0 || t < 0 ? { xPos: p, padd: 0 } : (o ? (p = n.width + d.config.yaxis[t].title.offsetX + i.width / 2 + y / 2, (f += 1) === 0 && (p -= y / 2)) : (p = -1 * n.width + d.config.yaxis[t].title.offsetX + y / 2 + i.width / 2, d.globals.isBarHorizontal && (y = 25, p = -1 * n.width - d.config.yaxis[t].title.offsetX - y)), { xPos: p, padd: y });
    } }, { key: "setYAxisXPosition", value: function(t, n) {
      var i = this.w, o = 0, d = 0, f = 18, p = 1;
      i.config.yaxis.length > 1 && (this.multipleYs = !0), i.config.yaxis.map(function(y, S) {
        var A = i.globals.ignoreYAxisIndexes.indexOf(S) > -1 || !y.show || y.floating || t[S].width === 0, E = t[S].width + n[S].width;
        y.opposite ? i.globals.isBarHorizontal ? (d = i.globals.gridWidth + i.globals.translateX - 1, i.globals.translateYAxisX[S] = d - y.labels.offsetX) : (d = i.globals.gridWidth + i.globals.translateX + p, A || (p = p + E + 20), i.globals.translateYAxisX[S] = d - y.labels.offsetX + 20) : (o = i.globals.translateX - f, A || (f = f + E + 20), i.globals.translateYAxisX[S] = o + y.labels.offsetX);
      });
    } }, { key: "setYAxisTextAlignments", value: function() {
      var t = this.w, n = t.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
      (n = K.listToArray(n)).forEach(function(i, o) {
        var d = t.config.yaxis[o];
        if (d && !d.floating && d.labels.align !== void 0) {
          var f = t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(o, "'] .apexcharts-yaxis-texts-g")), p = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(o, "'] .apexcharts-yaxis-label"));
          p = K.listToArray(p);
          var y = f.getBoundingClientRect();
          d.labels.align === "left" ? (p.forEach(function(S, A) {
            S.setAttribute("text-anchor", "start");
          }), d.opposite || f.setAttribute("transform", "translate(-".concat(y.width, ", 0)"))) : d.labels.align === "center" ? (p.forEach(function(S, A) {
            S.setAttribute("text-anchor", "middle");
          }), f.setAttribute("transform", "translate(".concat(y.width / 2 * (d.opposite ? 1 : -1), ", 0)"))) : d.labels.align === "right" && (p.forEach(function(S, A) {
            S.setAttribute("text-anchor", "end");
          }), d.opposite && f.setAttribute("transform", "translate(".concat(y.width, ", 0)")));
        }
      });
    } }]), B;
  }(), ir = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w, this.documentEvent = K.bind(this.documentEvent, this);
    }
    return F(B, [{ key: "addEventListener", value: function(t, n) {
      var i = this.w;
      i.globals.events.hasOwnProperty(t) ? i.globals.events[t].push(n) : i.globals.events[t] = [n];
    } }, { key: "removeEventListener", value: function(t, n) {
      var i = this.w;
      if (i.globals.events.hasOwnProperty(t)) {
        var o = i.globals.events[t].indexOf(n);
        o !== -1 && i.globals.events[t].splice(o, 1);
      }
    } }, { key: "fireEvent", value: function(t, n) {
      var i = this.w;
      if (i.globals.events.hasOwnProperty(t)) {
        n && n.length || (n = []);
        for (var o = i.globals.events[t], d = o.length, f = 0; f < d; f++)
          o[f].apply(null, n);
      }
    } }, { key: "setupEventHandlers", value: function() {
      var t = this, n = this.w, i = this.ctx, o = n.globals.dom.baseEl.querySelector(n.globals.chartClass);
      this.ctx.eventList.forEach(function(d) {
        o.addEventListener(d, function(f) {
          var p = Object.assign({}, n, { seriesIndex: n.globals.capturedSeriesIndex, dataPointIndex: n.globals.capturedDataPointIndex });
          f.type === "mousemove" || f.type === "touchmove" ? typeof n.config.chart.events.mouseMove == "function" && n.config.chart.events.mouseMove(f, i, p) : f.type === "mouseleave" || f.type === "touchleave" ? typeof n.config.chart.events.mouseLeave == "function" && n.config.chart.events.mouseLeave(f, i, p) : (f.type === "mouseup" && f.which === 1 || f.type === "touchend") && (typeof n.config.chart.events.click == "function" && n.config.chart.events.click(f, i, p), i.ctx.events.fireEvent("click", [f, i, p]));
        }, { capture: !1, passive: !0 });
      }), this.ctx.eventList.forEach(function(d) {
        n.globals.dom.baseEl.addEventListener(d, t.documentEvent, { passive: !0 });
      }), this.ctx.core.setupBrushHandler();
    } }, { key: "documentEvent", value: function(t) {
      var n = this.w, i = t.target.className;
      if (t.type === "click") {
        var o = n.globals.dom.baseEl.querySelector(".apexcharts-menu");
        o && o.classList.contains("apexcharts-menu-open") && i !== "apexcharts-menu-icon" && o.classList.remove("apexcharts-menu-open");
      }
      n.globals.clientX = t.type === "touchmove" ? t.touches[0].clientX : t.clientX, n.globals.clientY = t.type === "touchmove" ? t.touches[0].clientY : t.clientY;
    } }]), B;
  }(), Dr = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "setCurrentLocaleValues", value: function(t) {
      var n = this.w.config.chart.locales;
      window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (n = this.w.config.chart.locales.concat(window.Apex.chart.locales));
      var i = n.filter(function(d) {
        return d.name === t;
      })[0];
      if (!i)
        throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
      var o = K.extend(it, i);
      this.w.globals.locale = o.options;
    } }]), B;
  }(), Or = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "drawAxis", value: function(t, n) {
      var i, o, d = this, f = this.w.globals, p = this.w.config, y = new Ut(this.ctx, n), S = new jn(this.ctx, n);
      f.axisCharts && t !== "radar" && (f.isBarHorizontal ? (o = S.drawYaxisInversed(0), i = y.drawXaxisInversed(0), f.dom.elGraphical.add(i), f.dom.elGraphical.add(o)) : (i = y.drawXaxis(), f.dom.elGraphical.add(i), p.yaxis.map(function(A, E) {
        if (f.ignoreYAxisIndexes.indexOf(E) === -1 && (o = S.drawYaxis(E), f.dom.Paper.add(o), d.w.config.grid.position === "back")) {
          var L = f.dom.Paper.children()[1];
          L.remove(), f.dom.Paper.add(L);
        }
      })));
    } }]), B;
  }(), ti = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "drawXCrosshairs", value: function() {
      var t = this.w, n = new re(this.ctx), i = new Re(this.ctx), o = t.config.xaxis.crosshairs.fill.gradient, d = t.config.xaxis.crosshairs.dropShadow, f = t.config.xaxis.crosshairs.fill.type, p = o.colorFrom, y = o.colorTo, S = o.opacityFrom, A = o.opacityTo, E = o.stops, L = d.enabled, O = d.left, P = d.top, I = d.blur, j = d.color, V = d.opacity, Z = t.config.xaxis.crosshairs.fill.color;
      if (t.config.xaxis.crosshairs.show) {
        f === "gradient" && (Z = n.drawGradient("vertical", p, y, S, A, null, E, null));
        var b = n.drawRect();
        t.config.xaxis.crosshairs.width === 1 && (b = n.drawLine());
        var M = t.globals.gridHeight;
        (!K.isNumber(M) || M < 0) && (M = 0);
        var N = t.config.xaxis.crosshairs.width;
        (!K.isNumber(N) || N < 0) && (N = 0), b.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2: M, width: N, height: M, fill: Z, filter: "none", "fill-opacity": t.config.xaxis.crosshairs.opacity, stroke: t.config.xaxis.crosshairs.stroke.color, "stroke-width": t.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": t.config.xaxis.crosshairs.stroke.dashArray }), L && (b = i.dropShadow(b, { left: O, top: P, blur: I, color: j, opacity: V })), t.globals.dom.elGraphical.add(b);
      }
    } }, { key: "drawYCrosshairs", value: function() {
      var t = this.w, n = new re(this.ctx), i = t.config.yaxis[0].crosshairs, o = t.globals.barPadForNumericAxis;
      if (t.config.yaxis[0].crosshairs.show) {
        var d = n.drawLine(-o, 0, t.globals.gridWidth + o, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width);
        d.attr({ class: "apexcharts-ycrosshairs" }), t.globals.dom.elGraphical.add(d);
      }
      var f = n.drawLine(-o, 0, t.globals.gridWidth + o, 0, i.stroke.color, 0, 0);
      f.attr({ class: "apexcharts-ycrosshairs-hidden" }), t.globals.dom.elGraphical.add(f);
    } }]), B;
  }(), Zi = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "checkResponsiveConfig", value: function(t) {
      var n = this, i = this.w, o = i.config;
      if (o.responsive.length !== 0) {
        var d = o.responsive.slice();
        d.sort(function(S, A) {
          return S.breakpoint > A.breakpoint ? 1 : A.breakpoint > S.breakpoint ? -1 : 0;
        }).reverse();
        var f = new ft({}), p = function() {
          var S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, A = d[0].breakpoint, E = window.innerWidth > 0 ? window.innerWidth : screen.width;
          if (E > A) {
            var L = ve.extendArrayProps(f, i.globals.initialConfig, i);
            S = K.extend(L, S), S = K.extend(i.config, S), n.overrideResponsiveOptions(S);
          } else
            for (var O = 0; O < d.length; O++)
              E < d[O].breakpoint && (S = ve.extendArrayProps(f, d[O].options, i), S = K.extend(i.config, S), n.overrideResponsiveOptions(S));
        };
        if (t) {
          var y = ve.extendArrayProps(f, t, i);
          y = K.extend(i.config, y), p(y = K.extend(y, t));
        } else
          p({});
      }
    } }, { key: "overrideResponsiveOptions", value: function(t) {
      var n = new ft(t).init({ responsiveOverride: !0 });
      this.w.config = n;
    } }]), B;
  }(), _a = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.colors = [], this.w = t.w;
      var n = this.w;
      this.isColorFn = !1, this.isHeatmapDistributed = n.config.chart.type === "treemap" && n.config.plotOptions.treemap.distributed || n.config.chart.type === "heatmap" && n.config.plotOptions.heatmap.distributed, this.isBarDistributed = n.config.plotOptions.bar.distributed && (n.config.chart.type === "bar" || n.config.chart.type === "rangeBar");
    }
    return F(B, [{ key: "init", value: function() {
      this.setDefaultColors();
    } }, { key: "setDefaultColors", value: function() {
      var t, n = this, i = this.w, o = new K();
      if (i.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(i.config.theme.mode)), i.config.colors === void 0 || ((t = i.config.colors) === null || t === void 0 ? void 0 : t.length) === 0 ? i.globals.colors = this.predefined() : (i.globals.colors = i.config.colors, Array.isArray(i.config.colors) && i.config.colors.length > 0 && typeof i.config.colors[0] == "function" && (i.globals.colors = i.config.series.map(function(P, I) {
        var j = i.config.colors[I];
        return j || (j = i.config.colors[0]), typeof j == "function" ? (n.isColorFn = !0, j({ value: i.globals.axisCharts ? i.globals.series[I][0] ? i.globals.series[I][0] : 0 : i.globals.series[I], seriesIndex: I, dataPointIndex: I, w: i })) : j;
      }))), i.globals.seriesColors.map(function(P, I) {
        P && (i.globals.colors[I] = P);
      }), i.config.theme.monochrome.enabled) {
        var d = [], f = i.globals.series.length;
        (this.isBarDistributed || this.isHeatmapDistributed) && (f = i.globals.series[0].length * i.globals.series.length);
        for (var p = i.config.theme.monochrome.color, y = 1 / (f / i.config.theme.monochrome.shadeIntensity), S = i.config.theme.monochrome.shadeTo, A = 0, E = 0; E < f; E++) {
          var L = void 0;
          S === "dark" ? (L = o.shadeColor(-1 * A, p), A += y) : (L = o.shadeColor(A, p), A += y), d.push(L);
        }
        i.globals.colors = d.slice();
      }
      var O = i.globals.colors.slice();
      this.pushExtraColors(i.globals.colors), ["fill", "stroke"].forEach(function(P) {
        i.config[P].colors === void 0 ? i.globals[P].colors = n.isColorFn ? i.config.colors : O : i.globals[P].colors = i.config[P].colors.slice(), n.pushExtraColors(i.globals[P].colors);
      }), i.config.dataLabels.style.colors === void 0 ? i.globals.dataLabels.style.colors = O : i.globals.dataLabels.style.colors = i.config.dataLabels.style.colors.slice(), this.pushExtraColors(i.globals.dataLabels.style.colors, 50), i.config.plotOptions.radar.polygons.fill.colors === void 0 ? i.globals.radarPolygons.fill.colors = [i.config.theme.mode === "dark" ? "#424242" : "none"] : i.globals.radarPolygons.fill.colors = i.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(i.globals.radarPolygons.fill.colors, 20), i.config.markers.colors === void 0 ? i.globals.markers.colors = O : i.globals.markers.colors = i.config.markers.colors.slice(), this.pushExtraColors(i.globals.markers.colors);
    } }, { key: "pushExtraColors", value: function(t, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, o = this.w, d = n || o.globals.series.length;
      if (i === null && (i = this.isBarDistributed || this.isHeatmapDistributed || o.config.chart.type === "heatmap" && o.config.plotOptions.heatmap.colorScale.inverse), i && o.globals.series.length && (d = o.globals.series[o.globals.maxValsInArrayIndex].length * o.globals.series.length), t.length < d)
        for (var f = d - t.length, p = 0; p < f; p++)
          t.push(t[p]);
    } }, { key: "updateThemeOptions", value: function(t) {
      t.chart = t.chart || {}, t.tooltip = t.tooltip || {};
      var n = t.theme.mode || "light", i = t.theme.palette ? t.theme.palette : n === "dark" ? "palette4" : "palette1", o = t.chart.foreColor ? t.chart.foreColor : n === "dark" ? "#f6f7f8" : "#373d3f";
      return t.tooltip.theme = n, t.chart.foreColor = o, t.theme.palette = i, t;
    } }, { key: "predefined", value: function() {
      switch (this.w.config.theme.palette) {
        case "palette1":
        default:
          this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
          break;
        case "palette2":
          this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
          break;
        case "palette3":
          this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
          break;
        case "palette4":
          this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
          break;
        case "palette5":
          this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
          break;
        case "palette6":
          this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
          break;
        case "palette7":
          this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
          break;
        case "palette8":
          this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
          break;
        case "palette9":
          this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
          break;
        case "palette10":
          this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"];
      }
      return this.colors;
    } }]), B;
  }(), da = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "draw", value: function() {
      this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
    } }, { key: "drawTitleSubtitle", value: function(t) {
      var n = this.w, i = t === "title" ? n.config.title : n.config.subtitle, o = n.globals.svgWidth / 2, d = i.offsetY, f = "middle";
      if (i.align === "left" ? (o = 10, f = "start") : i.align === "right" && (o = n.globals.svgWidth - 10, f = "end"), o += i.offsetX, d = d + parseInt(i.style.fontSize, 10) + i.margin / 2, i.text !== void 0) {
        var p = new re(this.ctx).drawText({ x: o, y: d, text: i.text, textAnchor: f, fontSize: i.style.fontSize, fontFamily: i.style.fontFamily, fontWeight: i.style.fontWeight, foreColor: i.style.color, opacity: 1 });
        p.node.setAttribute("class", "apexcharts-".concat(t, "-text")), n.globals.dom.Paper.add(p);
      }
    } }]), B;
  }(), Qi = function() {
    function B(t) {
      C(this, B), this.w = t.w, this.dCtx = t;
    }
    return F(B, [{ key: "getTitleSubtitleCoords", value: function(t) {
      var n = this.w, i = 0, o = 0, d = t === "title" ? n.config.title.floating : n.config.subtitle.floating, f = n.globals.dom.baseEl.querySelector(".apexcharts-".concat(t, "-text"));
      if (f !== null && !d) {
        var p = f.getBoundingClientRect();
        i = p.width, o = n.globals.axisCharts ? p.height + 5 : p.height;
      }
      return { width: i, height: o };
    } }, { key: "getLegendsRect", value: function() {
      var t = this.w, n = t.globals.dom.elLegendWrap;
      t.config.legend.height || t.config.legend.position !== "top" && t.config.legend.position !== "bottom" || (n.style.maxHeight = t.globals.svgHeight / 2 + "px");
      var i = Object.assign({}, K.getBoundingClientRect(n));
      return n !== null && !t.config.legend.floating && t.config.legend.show ? this.dCtx.lgRect = { x: i.x, y: i.y, height: i.height, width: i.height === 0 ? 0 : i.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, t.config.legend.position !== "left" && t.config.legend.position !== "right" || 1.5 * this.dCtx.lgRect.width > t.globals.svgWidth && (this.dCtx.lgRect.width = t.globals.svgWidth / 1.5), this.dCtx.lgRect;
    } }, { key: "getLargestStringFromMultiArr", value: function(t, n) {
      var i = t;
      if (this.w.globals.isMultiLineX) {
        var o = n.map(function(f, p) {
          return Array.isArray(f) ? f.length : 1;
        }), d = Math.max.apply(Math, ue(o));
        i = n[o.indexOf(d)];
      }
      return i;
    } }]), B;
  }(), yi = function() {
    function B(t) {
      C(this, B), this.w = t.w, this.dCtx = t;
    }
    return F(B, [{ key: "getxAxisLabelsCoords", value: function() {
      var t, n = this.w, i = n.globals.labels.slice();
      if (n.config.xaxis.convertedCatToNumeric && i.length === 0 && (i = n.globals.categoryLabels), n.globals.timescaleLabels.length > 0) {
        var o = this.getxAxisTimeScaleLabelsCoords();
        t = { width: o.width, height: o.height }, n.globals.rotateXLabels = !1;
      } else {
        this.dCtx.lgWidthForSideLegends = n.config.legend.position !== "left" && n.config.legend.position !== "right" || n.config.legend.floating ? 0 : this.dCtx.lgRect.width;
        var d = n.globals.xLabelFormatter, f = K.getLargestStringFromArr(i), p = this.dCtx.dimHelpers.getLargestStringFromMultiArr(f, i);
        n.globals.isBarHorizontal && (p = f = n.globals.yAxisScale[0].result.reduce(function(P, I) {
          return P.length > I.length ? P : I;
        }, 0));
        var y = new Vt(this.dCtx.ctx), S = f;
        f = y.xLabelFormat(d, f, S, { i: void 0, dateFormatter: new Ze(this.dCtx.ctx).formatDate, w: n }), p = y.xLabelFormat(d, p, S, { i: void 0, dateFormatter: new Ze(this.dCtx.ctx).formatDate, w: n }), (n.config.xaxis.convertedCatToNumeric && f === void 0 || String(f).trim() === "") && (p = f = "1");
        var A = new re(this.dCtx.ctx), E = A.getTextRects(f, n.config.xaxis.labels.style.fontSize), L = E;
        if (f !== p && (L = A.getTextRects(p, n.config.xaxis.labels.style.fontSize)), (t = { width: E.width >= L.width ? E.width : L.width, height: E.height >= L.height ? E.height : L.height }).width * i.length > n.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && n.config.xaxis.labels.rotate !== 0 || n.config.xaxis.labels.rotateAlways) {
          if (!n.globals.isBarHorizontal) {
            n.globals.rotateXLabels = !0;
            var O = function(P) {
              return A.getTextRects(P, n.config.xaxis.labels.style.fontSize, n.config.xaxis.labels.style.fontFamily, "rotate(".concat(n.config.xaxis.labels.rotate, " 0 0)"), !1);
            };
            E = O(f), f !== p && (L = O(p)), t.height = (E.height > L.height ? E.height : L.height) / 1.5, t.width = E.width > L.width ? E.width : L.width;
          }
        } else
          n.globals.rotateXLabels = !1;
      }
      return n.config.xaxis.labels.show || (t = { width: 0, height: 0 }), { width: t.width, height: t.height };
    } }, { key: "getxAxisGroupLabelsCoords", value: function() {
      var t, n = this.w;
      if (!n.globals.hasXaxisGroups)
        return { width: 0, height: 0 };
      var i, o = ((t = n.config.xaxis.group.style) === null || t === void 0 ? void 0 : t.fontSize) || n.config.xaxis.labels.style.fontSize, d = n.globals.groups.map(function(E) {
        return E.title;
      }), f = K.getLargestStringFromArr(d), p = this.dCtx.dimHelpers.getLargestStringFromMultiArr(f, d), y = new re(this.dCtx.ctx), S = y.getTextRects(f, o), A = S;
      return f !== p && (A = y.getTextRects(p, o)), i = { width: S.width >= A.width ? S.width : A.width, height: S.height >= A.height ? S.height : A.height }, n.config.xaxis.labels.show || (i = { width: 0, height: 0 }), { width: i.width, height: i.height };
    } }, { key: "getxAxisTitleCoords", value: function() {
      var t = this.w, n = 0, i = 0;
      if (t.config.xaxis.title.text !== void 0) {
        var o = new re(this.dCtx.ctx).getTextRects(t.config.xaxis.title.text, t.config.xaxis.title.style.fontSize);
        n = o.width, i = o.height;
      }
      return { width: n, height: i };
    } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
      var t, n = this.w;
      this.dCtx.timescaleLabels = n.globals.timescaleLabels.slice();
      var i = this.dCtx.timescaleLabels.map(function(d) {
        return d.value;
      }), o = i.reduce(function(d, f) {
        return d === void 0 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : d.length > f.length ? d : f;
      }, 0);
      return 1.05 * (t = new re(this.dCtx.ctx).getTextRects(o, n.config.xaxis.labels.style.fontSize)).width * i.length > n.globals.gridWidth && n.config.xaxis.labels.rotate !== 0 && (n.globals.overlappingXLabels = !0), t;
    } }, { key: "additionalPaddingXLabels", value: function(t) {
      var n = this, i = this.w, o = i.globals, d = i.config, f = d.xaxis.type, p = t.width;
      o.skipLastTimelinelabel = !1, o.skipFirstTimelinelabel = !1;
      var y = i.config.yaxis[0].opposite && i.globals.isBarHorizontal, S = function(A, E) {
        d.yaxis.length > 1 && function(L) {
          return o.collapsedSeriesIndices.indexOf(L) !== -1;
        }(E) || function(L) {
          if (n.dCtx.timescaleLabels && n.dCtx.timescaleLabels.length) {
            var O = n.dCtx.timescaleLabels[0], P = n.dCtx.timescaleLabels[n.dCtx.timescaleLabels.length - 1].position + p / 1.75 - n.dCtx.yAxisWidthRight, I = O.position - p / 1.75 + n.dCtx.yAxisWidthLeft, j = i.config.legend.position === "right" && n.dCtx.lgRect.width > 0 ? n.dCtx.lgRect.width : 0;
            P > o.svgWidth - o.translateX - j && (o.skipLastTimelinelabel = !0), I < -(L.show && !L.floating || d.chart.type !== "bar" && d.chart.type !== "candlestick" && d.chart.type !== "rangeBar" && d.chart.type !== "boxPlot" ? 10 : p / 1.75) && (o.skipFirstTimelinelabel = !0);
          } else
            f === "datetime" ? n.dCtx.gridPad.right < p && !o.rotateXLabels && (o.skipLastTimelinelabel = !0) : f !== "datetime" && n.dCtx.gridPad.right < p / 2 - n.dCtx.yAxisWidthRight && !o.rotateXLabels && !i.config.xaxis.labels.trim && (i.config.xaxis.tickPlacement !== "between" || i.globals.isBarHorizontal) && (n.dCtx.xPadRight = p / 2 + 1);
        }(A);
      };
      d.yaxis.forEach(function(A, E) {
        y ? (n.dCtx.gridPad.left < p && (n.dCtx.xPadLeft = p / 2 + 1), n.dCtx.xPadRight = p / 2 + 1) : S(A, E);
      });
    } }]), B;
  }(), fa = function() {
    function B(t) {
      C(this, B), this.w = t.w, this.dCtx = t;
    }
    return F(B, [{ key: "getyAxisLabelsCoords", value: function() {
      var t = this, n = this.w, i = [], o = 10, d = new Rt(this.dCtx.ctx);
      return n.config.yaxis.map(function(f, p) {
        var y = n.globals.yAxisScale[p], S = 0;
        if (!d.isYAxisHidden(p) && f.labels.show && f.labels.minWidth !== void 0 && (S = f.labels.minWidth), !d.isYAxisHidden(p) && f.labels.show && y.result.length) {
          var A = n.globals.yLabelFormatters[p], E = y.niceMin === Number.MIN_VALUE ? 0 : y.niceMin, L = String(E).length > String(y.niceMax).length ? E : y.niceMax, O = A(L, { seriesIndex: p, dataPointIndex: -1, w: n }), P = O;
          if (O !== void 0 && O.length !== 0 || (O = L), n.globals.isBarHorizontal) {
            o = 0;
            var I = n.globals.labels.slice();
            O = A(O = K.getLargestStringFromArr(I), { seriesIndex: p, dataPointIndex: -1, w: n }), P = t.dCtx.dimHelpers.getLargestStringFromMultiArr(O, I);
          }
          var j = new re(t.dCtx.ctx), V = "rotate(".concat(f.labels.rotate, " 0 0)"), Z = j.getTextRects(O, f.labels.style.fontSize, f.labels.style.fontFamily, V, !1), b = Z;
          O !== P && (b = j.getTextRects(P, f.labels.style.fontSize, f.labels.style.fontFamily, V, !1)), i.push({ width: (S > b.width || S > Z.width ? S : b.width > Z.width ? b.width : Z.width) + o, height: b.height > Z.height ? b.height : Z.height });
        } else
          i.push({ width: 0, height: 0 });
      }), i;
    } }, { key: "getyAxisTitleCoords", value: function() {
      var t = this, n = this.w, i = [];
      return n.config.yaxis.map(function(o, d) {
        if (o.show && o.title.text !== void 0) {
          var f = new re(t.dCtx.ctx), p = "rotate(".concat(o.title.rotate, " 0 0)"), y = f.getTextRects(o.title.text, o.title.style.fontSize, o.title.style.fontFamily, p, !1);
          i.push({ width: y.width, height: y.height });
        } else
          i.push({ width: 0, height: 0 });
      }), i;
    } }, { key: "getTotalYAxisWidth", value: function() {
      var t = this.w, n = 0, i = 0, o = 0, d = t.globals.yAxisScale.length > 1 ? 10 : 0, f = new Rt(this.dCtx.ctx), p = function(y, S) {
        var A = t.config.yaxis[S].floating, E = 0;
        y.width > 0 && !A ? (E = y.width + d, function(L) {
          return t.globals.ignoreYAxisIndexes.indexOf(L) > -1;
        }(S) && (E = E - y.width - d)) : E = A || f.isYAxisHidden(S) ? 0 : 5, t.config.yaxis[S].opposite ? o += E : i += E, n += E;
      };
      return t.globals.yLabelsCoords.map(function(y, S) {
        p(y, S);
      }), t.globals.yTitleCoords.map(function(y, S) {
        p(y, S);
      }), t.globals.isBarHorizontal && !t.config.yaxis[0].floating && (n = t.globals.yLabelsCoords[0].width + t.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i, this.dCtx.yAxisWidthRight = o, n;
    } }]), B;
  }(), xi = function() {
    function B(t) {
      C(this, B), this.w = t.w, this.dCtx = t;
    }
    return F(B, [{ key: "gridPadForColumnsInNumericAxis", value: function(t) {
      var n = this.w;
      if (n.globals.noData || n.globals.allSeriesCollapsed)
        return 0;
      var i = function(A) {
        return A === "bar" || A === "rangeBar" || A === "candlestick" || A === "boxPlot";
      }, o = n.config.chart.type, d = 0, f = i(o) ? n.config.series.length : 1;
      if (n.globals.comboBarCount > 0 && (f = n.globals.comboBarCount), n.globals.collapsedSeries.forEach(function(A) {
        i(A.type) && (f -= 1);
      }), n.config.chart.stacked && (f = 1), (i(o) || n.globals.comboBarCount > 0) && n.globals.isXNumeric && !n.globals.isBarHorizontal && f > 0) {
        var p, y, S = Math.abs(n.globals.initialMaxX - n.globals.initialMinX);
        S <= 3 && (S = n.globals.dataPoints), p = S / t, n.globals.minXDiff && n.globals.minXDiff / p > 0 && (y = n.globals.minXDiff / p), y > t / 2 && (y /= 2), (d = y / f * parseInt(n.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (d = 1), d = d / (f > 1 ? 1 : 1.5) + 5, n.globals.barPadForNumericAxis = d;
      }
      return d;
    } }, { key: "gridPadFortitleSubtitle", value: function() {
      var t = this, n = this.w, i = n.globals, o = this.dCtx.isSparkline || !n.globals.axisCharts ? 0 : 10;
      ["title", "subtitle"].forEach(function(p) {
        n.config[p].text !== void 0 ? o += n.config[p].margin : o += t.dCtx.isSparkline || !n.globals.axisCharts ? 0 : 5;
      }), !n.config.legend.show || n.config.legend.position !== "bottom" || n.config.legend.floating || n.globals.axisCharts || (o += 10);
      var d = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), f = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
      i.gridHeight = i.gridHeight - d.height - f.height - o, i.translateY = i.translateY + d.height + f.height + o;
    } }, { key: "setGridXPosForDualYAxis", value: function(t, n) {
      var i = this.w, o = new Rt(this.dCtx.ctx);
      i.config.yaxis.map(function(d, f) {
        i.globals.ignoreYAxisIndexes.indexOf(f) !== -1 || d.floating || o.isYAxisHidden(f) || (d.opposite && (i.globals.translateX = i.globals.translateX - (n[f].width + t[f].width) - parseInt(i.config.yaxis[f].labels.style.fontSize, 10) / 1.2 - 12), i.globals.translateX < 2 && (i.globals.translateX = 2));
      });
    } }]), B;
  }(), ni = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new Qi(this), this.dimYAxis = new fa(this), this.dimXAxis = new yi(this), this.dimGrid = new xi(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
    }
    return F(B, [{ key: "plotCoords", value: function() {
      var t = this, n = this.w, i = n.globals;
      this.lgRect = this.dimHelpers.getLegendsRect(), this.isSparkline && (n.config.markers.discrete.length > 0 || n.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(d) {
        var f = ae(d, 2), p = f[0], y = f[1];
        t.gridPad[p] = Math.max(y, t.w.globals.markers.largestSize / 1.5);
      }), i.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i.gridHeight = i.gridHeight - this.gridPad.top - this.gridPad.bottom, i.gridWidth = i.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
      var o = this.dimGrid.gridPadForColumnsInNumericAxis(i.gridWidth);
      i.gridWidth = i.gridWidth - 2 * o, i.translateX = i.translateX + this.gridPad.left + this.xPadLeft + (o > 0 ? o + 4 : 0), i.translateY = i.translateY + this.gridPad.top;
    } }, { key: "setDimensionsForAxisCharts", value: function() {
      var t = this, n = this.w, i = n.globals, o = this.dimYAxis.getyAxisLabelsCoords(), d = this.dimYAxis.getyAxisTitleCoords();
      n.globals.yLabelsCoords = [], n.globals.yTitleCoords = [], n.config.yaxis.map(function(O, P) {
        n.globals.yLabelsCoords.push({ width: o[P].width, index: P }), n.globals.yTitleCoords.push({ width: d[P].width, index: P });
      }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
      var f = this.dimXAxis.getxAxisLabelsCoords(), p = this.dimXAxis.getxAxisGroupLabelsCoords(), y = this.dimXAxis.getxAxisTitleCoords();
      this.conditionalChecksForAxisCoords(f, y, p), i.translateXAxisY = n.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i.translateXAxisX = n.globals.rotateXLabels && n.globals.isXNumeric && n.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, n.globals.isBarHorizontal && (i.rotateXLabels = !1, i.translateXAxisY = parseInt(n.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i.translateXAxisY = i.translateXAxisY + n.config.xaxis.labels.offsetY, i.translateXAxisX = i.translateXAxisX + n.config.xaxis.labels.offsetX;
      var S = this.yAxisWidth, A = this.xAxisHeight;
      i.xAxisLabelsHeight = this.xAxisHeight - y.height, i.xAxisGroupLabelsHeight = i.xAxisLabelsHeight - f.height, i.xAxisLabelsWidth = this.xAxisWidth, i.xAxisHeight = this.xAxisHeight;
      var E = 10;
      (n.config.chart.type === "radar" || this.isSparkline) && (S = 0, A = i.goldenPadding), this.isSparkline && (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || n.config.chart.type === "treemap") && (S = 0, A = 0, E = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(f);
      var L = function() {
        i.translateX = S, i.gridHeight = i.svgHeight - t.lgRect.height - A - (t.isSparkline || n.config.chart.type === "treemap" ? 0 : n.globals.rotateXLabels ? 10 : 15), i.gridWidth = i.svgWidth - S;
      };
      switch (n.config.xaxis.position === "top" && (E = i.xAxisHeight - n.config.xaxis.axisTicks.height - 5), n.config.legend.position) {
        case "bottom":
          i.translateY = E, L();
          break;
        case "top":
          i.translateY = this.lgRect.height + E, L();
          break;
        case "left":
          i.translateY = E, i.translateX = this.lgRect.width + S, i.gridHeight = i.svgHeight - A - 12, i.gridWidth = i.svgWidth - this.lgRect.width - S;
          break;
        case "right":
          i.translateY = E, i.translateX = S, i.gridHeight = i.svgHeight - A - 12, i.gridWidth = i.svgWidth - this.lgRect.width - S - 5;
          break;
        default:
          throw new Error("Legend position not supported");
      }
      this.dimGrid.setGridXPosForDualYAxis(d, o), new jn(this.ctx).setYAxisXPosition(o, d);
    } }, { key: "setDimensionsForNonAxisCharts", value: function() {
      var t = this.w, n = t.globals, i = t.config, o = 0;
      t.config.legend.show && !t.config.legend.floating && (o = 20);
      var d = i.chart.type === "pie" || i.chart.type === "polarArea" || i.chart.type === "donut" ? "pie" : "radialBar", f = i.plotOptions[d].offsetY, p = i.plotOptions[d].offsetX;
      if (!i.legend.show || i.legend.floating)
        return n.gridHeight = n.svgHeight - i.grid.padding.left + i.grid.padding.right, n.gridWidth = n.gridHeight, n.translateY = f, void (n.translateX = p + (n.svgWidth - n.gridWidth) / 2);
      switch (i.legend.position) {
        case "bottom":
          n.gridHeight = n.svgHeight - this.lgRect.height - n.goldenPadding, n.gridWidth = n.svgWidth, n.translateY = f - 10, n.translateX = p + (n.svgWidth - n.gridWidth) / 2;
          break;
        case "top":
          n.gridHeight = n.svgHeight - this.lgRect.height - n.goldenPadding, n.gridWidth = n.svgWidth, n.translateY = this.lgRect.height + f + 10, n.translateX = p + (n.svgWidth - n.gridWidth) / 2;
          break;
        case "left":
          n.gridWidth = n.svgWidth - this.lgRect.width - o, n.gridHeight = i.chart.height !== "auto" ? n.svgHeight : n.gridWidth, n.translateY = f, n.translateX = p + this.lgRect.width + o;
          break;
        case "right":
          n.gridWidth = n.svgWidth - this.lgRect.width - o - 5, n.gridHeight = i.chart.height !== "auto" ? n.svgHeight : n.gridWidth, n.translateY = f, n.translateX = p + 10;
          break;
        default:
          throw new Error("Legend position not supported");
      }
    } }, { key: "conditionalChecksForAxisCoords", value: function(t, n, i) {
      var o = this.w, d = o.globals.hasXaxisGroups ? 2 : 1, f = i.height + t.height + n.height, p = o.globals.isMultiLineX ? 1.2 : o.globals.LINE_HEIGHT_RATIO, y = o.globals.rotateXLabels ? 22 : 10, S = o.globals.rotateXLabels && o.config.legend.position === "bottom" ? 10 : 0;
      this.xAxisHeight = f * p + d * y + S, this.xAxisWidth = t.width, this.xAxisHeight - n.height > o.config.xaxis.labels.maxHeight && (this.xAxisHeight = o.config.xaxis.labels.maxHeight), o.config.xaxis.labels.minHeight && this.xAxisHeight < o.config.xaxis.labels.minHeight && (this.xAxisHeight = o.config.xaxis.labels.minHeight), o.config.xaxis.floating && (this.xAxisHeight = 0);
      var A = 0, E = 0;
      o.config.yaxis.forEach(function(L) {
        A += L.labels.minWidth, E += L.labels.maxWidth;
      }), this.yAxisWidth < A && (this.yAxisWidth = A), this.yAxisWidth > E && (this.yAxisWidth = E);
    } }]), B;
  }(), ar = function() {
    function B(t) {
      C(this, B), this.w = t.w, this.lgCtx = t;
    }
    return F(B, [{ key: "getLegendStyles", value: function() {
      var t = document.createElement("style");
      t.setAttribute("type", "text/css");
      var n = document.createTextNode(`	
    	
      .apexcharts-legend {	
        display: flex;	
        overflow: auto;	
        padding: 0 10px;	
      }	
      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {	
        flex-wrap: wrap	
      }	
      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {	
        flex-direction: column;	
        bottom: 0;	
      }	
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {	
        justify-content: flex-start;	
      }	
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {	
        justify-content: center;  	
      }	
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {	
        justify-content: flex-end;	
      }	
      .apexcharts-legend-series {	
        cursor: pointer;	
        line-height: normal;	
      }	
      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{	
        display: flex;	
        align-items: center;	
      }	
      .apexcharts-legend-text {	
        position: relative;	
        font-size: 14px;	
      }	
      .apexcharts-legend-text *, .apexcharts-legend-marker * {	
        pointer-events: none;	
      }	
      .apexcharts-legend-marker {	
        position: relative;	
        display: inline-block;	
        cursor: pointer;	
        margin-right: 3px;	
        border-style: solid;
      }	
      	
      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{	
        display: inline-block;	
      }	
      .apexcharts-legend-series.apexcharts-no-click {	
        cursor: auto;	
      }	
      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {	
        display: none !important;	
      }	
      .apexcharts-inactive-legend {	
        opacity: 0.45;	
      }`);
      return t.appendChild(n), t;
    } }, { key: "getLegendBBox", value: function() {
      var t = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), n = t.width;
      return { clwh: t.height, clww: n };
    } }, { key: "appendToForeignObject", value: function() {
      this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
    } }, { key: "toggleDataSeries", value: function(t, n) {
      var i = this, o = this.w;
      if (o.globals.axisCharts || o.config.chart.type === "radialBar") {
        o.globals.resized = !0;
        var d = null, f = null;
        o.globals.risingSeries = [], o.globals.axisCharts ? (d = o.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "']")), f = parseInt(d.getAttribute("data:realIndex"), 10)) : (d = o.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t + 1, "']")), f = parseInt(d.getAttribute("rel"), 10) - 1), n ? [{ cs: o.globals.collapsedSeries, csi: o.globals.collapsedSeriesIndices }, { cs: o.globals.ancillaryCollapsedSeries, csi: o.globals.ancillaryCollapsedSeriesIndices }].forEach(function(A) {
          i.riseCollapsedSeries(A.cs, A.csi, f);
        }) : this.hideSeries({ seriesEl: d, realIndex: f });
      } else {
        var p = o.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t + 1, "'] path")), y = o.config.chart.type;
        if (y === "pie" || y === "polarArea" || y === "donut") {
          var S = o.config.plotOptions.pie.donut.labels;
          new re(this.lgCtx.ctx).pathMouseDown(p.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(p.members[0].node, S);
        }
        p.fire("click");
      }
    } }, { key: "hideSeries", value: function(t) {
      var n = t.seriesEl, i = t.realIndex, o = this.w, d = K.clone(o.config.series);
      if (o.globals.axisCharts) {
        var f = !1;
        if (o.config.yaxis[i] && o.config.yaxis[i].show && o.config.yaxis[i].showAlways && (f = !0, o.globals.ancillaryCollapsedSeriesIndices.indexOf(i) < 0 && (o.globals.ancillaryCollapsedSeries.push({ index: i, data: d[i].data.slice(), type: n.parentNode.className.baseVal.split("-")[1] }), o.globals.ancillaryCollapsedSeriesIndices.push(i))), !f) {
          o.globals.collapsedSeries.push({ index: i, data: d[i].data.slice(), type: n.parentNode.className.baseVal.split("-")[1] }), o.globals.collapsedSeriesIndices.push(i);
          var p = o.globals.risingSeries.indexOf(i);
          o.globals.risingSeries.splice(p, 1);
        }
      } else
        o.globals.collapsedSeries.push({ index: i, data: d[i] }), o.globals.collapsedSeriesIndices.push(i);
      for (var y = n.childNodes, S = 0; S < y.length; S++)
        y[S].classList.contains("apexcharts-series-markers-wrap") && (y[S].classList.contains("apexcharts-hide") ? y[S].classList.remove("apexcharts-hide") : y[S].classList.add("apexcharts-hide"));
      o.globals.allSeriesCollapsed = o.globals.collapsedSeries.length === o.config.series.length, d = this._getSeriesBasedOnCollapsedState(d), this.lgCtx.ctx.updateHelpers._updateSeries(d, o.config.chart.animations.dynamicAnimation.enabled);
    } }, { key: "riseCollapsedSeries", value: function(t, n, i) {
      var o = this.w, d = K.clone(o.config.series);
      if (t.length > 0) {
        for (var f = 0; f < t.length; f++)
          t[f].index === i && (o.globals.axisCharts ? (d[i].data = t[f].data.slice(), t.splice(f, 1), n.splice(f, 1), o.globals.risingSeries.push(i)) : (d[i] = t[f].data, t.splice(f, 1), n.splice(f, 1), o.globals.risingSeries.push(i)));
        d = this._getSeriesBasedOnCollapsedState(d), this.lgCtx.ctx.updateHelpers._updateSeries(d, o.config.chart.animations.dynamicAnimation.enabled);
      }
    } }, { key: "_getSeriesBasedOnCollapsedState", value: function(t) {
      var n = this.w;
      return n.globals.axisCharts ? t.forEach(function(i, o) {
        n.globals.collapsedSeriesIndices.indexOf(o) > -1 && (t[o].data = []);
      }) : t.forEach(function(i, o) {
        n.globals.collapsedSeriesIndices.indexOf(o) > -1 && (t[o] = 0);
      }), t;
    } }]), B;
  }(), ri = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = this.w.config.chart.type === "bar" && this.w.config.plotOptions.bar.distributed && this.w.config.series.length === 1, this.legendHelpers = new ar(this);
    }
    return F(B, [{ key: "init", value: function() {
      var t = this.w, n = t.globals, i = t.config;
      if ((i.legend.showForSingleSeries && n.series.length === 1 || this.isBarsDistributed || n.series.length > 1 || !n.axisCharts) && i.legend.show) {
        for (; n.dom.elLegendWrap.firstChild; )
          n.dom.elLegendWrap.removeChild(n.dom.elLegendWrap.firstChild);
        this.drawLegends(), K.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), i.legend.position === "bottom" || i.legend.position === "top" ? this.legendAlignHorizontal() : i.legend.position !== "right" && i.legend.position !== "left" || this.legendAlignVertical();
      }
    } }, { key: "drawLegends", value: function() {
      var t = this, n = this.w, i = n.config.legend.fontFamily, o = n.globals.seriesNames, d = n.globals.colors.slice();
      if (n.config.chart.type === "heatmap") {
        var f = n.config.plotOptions.heatmap.colorScale.ranges;
        o = f.map(function(Le) {
          return Le.name ? Le.name : Le.from + " - " + Le.to;
        }), d = f.map(function(Le) {
          return Le.color;
        });
      } else
        this.isBarsDistributed && (o = n.globals.labels.slice());
      n.config.legend.customLegendItems.length && (o = n.config.legend.customLegendItems);
      for (var p = n.globals.legendFormatter, y = n.config.legend.inverseOrder, S = y ? o.length - 1 : 0; y ? S >= 0 : S <= o.length - 1; y ? S-- : S++) {
        var A, E = p(o[S], { seriesIndex: S, w: n }), L = !1, O = !1;
        if (n.globals.collapsedSeries.length > 0)
          for (var P = 0; P < n.globals.collapsedSeries.length; P++)
            n.globals.collapsedSeries[P].index === S && (L = !0);
        if (n.globals.ancillaryCollapsedSeriesIndices.length > 0)
          for (var I = 0; I < n.globals.ancillaryCollapsedSeriesIndices.length; I++)
            n.globals.ancillaryCollapsedSeriesIndices[I] === S && (O = !0);
        var j = document.createElement("span");
        j.classList.add("apexcharts-legend-marker");
        var V = n.config.legend.markers.offsetX, Z = n.config.legend.markers.offsetY, b = n.config.legend.markers.height, M = n.config.legend.markers.width, N = n.config.legend.markers.strokeWidth, X = n.config.legend.markers.strokeColor, Q = n.config.legend.markers.radius, ee = j.style;
        ee.background = d[S], ee.color = d[S], ee.setProperty("background", d[S], "important"), n.config.legend.markers.fillColors && n.config.legend.markers.fillColors[S] && (ee.background = n.config.legend.markers.fillColors[S]), n.globals.seriesColors[S] !== void 0 && (ee.background = n.globals.seriesColors[S], ee.color = n.globals.seriesColors[S]), ee.height = Array.isArray(b) ? parseFloat(b[S]) + "px" : parseFloat(b) + "px", ee.width = Array.isArray(M) ? parseFloat(M[S]) + "px" : parseFloat(M) + "px", ee.left = (Array.isArray(V) ? parseFloat(V[S]) : parseFloat(V)) + "px", ee.top = (Array.isArray(Z) ? parseFloat(Z[S]) : parseFloat(Z)) + "px", ee.borderWidth = Array.isArray(N) ? N[S] : N, ee.borderColor = Array.isArray(X) ? X[S] : X, ee.borderRadius = Array.isArray(Q) ? parseFloat(Q[S]) + "px" : parseFloat(Q) + "px", n.config.legend.markers.customHTML && (Array.isArray(n.config.legend.markers.customHTML) ? n.config.legend.markers.customHTML[S] && (j.innerHTML = n.config.legend.markers.customHTML[S]()) : j.innerHTML = n.config.legend.markers.customHTML()), re.setAttrs(j, { rel: S + 1, "data:collapsed": L || O }), (L || O) && j.classList.add("apexcharts-inactive-legend");
        var oe = document.createElement("div"), fe = document.createElement("span");
        fe.classList.add("apexcharts-legend-text"), fe.innerHTML = Array.isArray(E) ? E.join(" ") : E;
        var ke = n.config.legend.labels.useSeriesColors ? n.globals.colors[S] : Array.isArray(n.config.legend.labels.colors) ? (A = n.config.legend.labels.colors) === null || A === void 0 ? void 0 : A[S] : n.config.legend.labels.colors;
        ke || (ke = n.config.chart.foreColor), fe.style.color = ke, fe.style.fontSize = parseFloat(n.config.legend.fontSize) + "px", fe.style.fontWeight = n.config.legend.fontWeight, fe.style.fontFamily = i || n.config.chart.fontFamily, re.setAttrs(fe, { rel: S + 1, i: S, "data:default-text": encodeURIComponent(E), "data:collapsed": L || O }), oe.appendChild(j), oe.appendChild(fe);
        var _e = new ve(this.ctx);
        n.config.legend.showForZeroSeries || _e.getSeriesTotalByIndex(S) === 0 && _e.seriesHaveSameValues(S) && !_e.isSeriesNull(S) && n.globals.collapsedSeriesIndices.indexOf(S) === -1 && n.globals.ancillaryCollapsedSeriesIndices.indexOf(S) === -1 && oe.classList.add("apexcharts-hidden-zero-series"), n.config.legend.showForNullSeries || _e.isSeriesNull(S) && n.globals.collapsedSeriesIndices.indexOf(S) === -1 && n.globals.ancillaryCollapsedSeriesIndices.indexOf(S) === -1 && oe.classList.add("apexcharts-hidden-null-series"), n.globals.dom.elLegendWrap.appendChild(oe), n.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(n.config.legend.horizontalAlign)), n.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + n.config.legend.position), oe.classList.add("apexcharts-legend-series"), oe.style.margin = "".concat(n.config.legend.itemMargin.vertical, "px ").concat(n.config.legend.itemMargin.horizontal, "px"), n.globals.dom.elLegendWrap.style.width = n.config.legend.width ? n.config.legend.width + "px" : "", n.globals.dom.elLegendWrap.style.height = n.config.legend.height ? n.config.legend.height + "px" : "", re.setAttrs(oe, { rel: S + 1, seriesName: K.escapeString(o[S]), "data:collapsed": L || O }), (L || O) && oe.classList.add("apexcharts-inactive-legend"), n.config.legend.onItemClick.toggleDataSeries || oe.classList.add("apexcharts-no-click");
      }
      n.globals.dom.elWrap.addEventListener("click", t.onLegendClick, !0), n.config.legend.onItemHover.highlightDataSeries && n.config.legend.customLegendItems.length === 0 && (n.globals.dom.elWrap.addEventListener("mousemove", t.onLegendHovered, !0), n.globals.dom.elWrap.addEventListener("mouseout", t.onLegendHovered, !0));
    } }, { key: "setLegendWrapXY", value: function(t, n) {
      var i = this.w, o = i.globals.dom.elLegendWrap, d = o.getBoundingClientRect(), f = 0, p = 0;
      if (i.config.legend.position === "bottom")
        p += i.globals.svgHeight - d.height / 2;
      else if (i.config.legend.position === "top") {
        var y = new ni(this.ctx), S = y.dimHelpers.getTitleSubtitleCoords("title").height, A = y.dimHelpers.getTitleSubtitleCoords("subtitle").height;
        p = p + (S > 0 ? S - 10 : 0) + (A > 0 ? A - 10 : 0);
      }
      o.style.position = "absolute", f = f + t + i.config.legend.offsetX, p = p + n + i.config.legend.offsetY, o.style.left = f + "px", o.style.top = p + "px", i.config.legend.position === "bottom" ? (o.style.top = "auto", o.style.bottom = 5 - i.config.legend.offsetY + "px") : i.config.legend.position === "right" && (o.style.left = "auto", o.style.right = 25 + i.config.legend.offsetX + "px"), ["width", "height"].forEach(function(E) {
        o.style[E] && (o.style[E] = parseInt(i.config.legend[E], 10) + "px");
      });
    } }, { key: "legendAlignHorizontal", value: function() {
      var t = this.w;
      t.globals.dom.elLegendWrap.style.right = 0;
      var n = this.legendHelpers.getLegendBBox(), i = new ni(this.ctx), o = i.dimHelpers.getTitleSubtitleCoords("title"), d = i.dimHelpers.getTitleSubtitleCoords("subtitle"), f = 0;
      t.config.legend.position === "bottom" ? f = -n.clwh / 1.8 : t.config.legend.position === "top" && (f = o.height + d.height + t.config.title.margin + t.config.subtitle.margin - 10), this.setLegendWrapXY(20, f);
    } }, { key: "legendAlignVertical", value: function() {
      var t = this.w, n = this.legendHelpers.getLegendBBox(), i = 0;
      t.config.legend.position === "left" && (i = 20), t.config.legend.position === "right" && (i = t.globals.svgWidth - n.clww - 10), this.setLegendWrapXY(i, 20);
    } }, { key: "onLegendHovered", value: function(t) {
      var n = this.w, i = t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker");
      if (n.config.chart.type === "heatmap" || this.isBarsDistributed) {
        if (i) {
          var o = parseInt(t.target.getAttribute("rel"), 10) - 1;
          this.ctx.events.fireEvent("legendHover", [this.ctx, o, this.w]), new ot(this.ctx).highlightRangeInSeries(t, t.target);
        }
      } else
        !t.target.classList.contains("apexcharts-inactive-legend") && i && new ot(this.ctx).toggleSeriesOnHover(t, t.target);
    } }, { key: "onLegendClick", value: function(t) {
      var n = this.w;
      if (!n.config.legend.customLegendItems.length && (t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker"))) {
        var i = parseInt(t.target.getAttribute("rel"), 10) - 1, o = t.target.getAttribute("data:collapsed") === "true", d = this.w.config.chart.events.legendClick;
        typeof d == "function" && d(this.ctx, i, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i, this.w]);
        var f = this.w.config.legend.markers.onClick;
        typeof f == "function" && t.target.classList.contains("apexcharts-legend-marker") && (f(this.ctx, i, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i, this.w])), n.config.chart.type !== "treemap" && n.config.chart.type !== "heatmap" && !this.isBarsDistributed && n.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i, o);
      }
    } }]), B;
  }(), Pa = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
      var n = this.w;
      this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = n.globals.minX, this.maxX = n.globals.maxX;
    }
    return F(B, [{ key: "createToolbar", value: function() {
      var t = this, n = this.w, i = function() {
        return document.createElement("div");
      }, o = i();
      if (o.setAttribute("class", "apexcharts-toolbar"), o.style.top = n.config.chart.toolbar.offsetY + "px", o.style.right = 3 - n.config.chart.toolbar.offsetX + "px", n.globals.dom.elWrap.appendChild(o), this.elZoom = i(), this.elZoomIn = i(), this.elZoomOut = i(), this.elPan = i(), this.elSelection = i(), this.elZoomReset = i(), this.elMenuIcon = i(), this.elMenu = i(), this.elCustomIcons = [], this.t = n.config.chart.toolbar.tools, Array.isArray(this.t.customIcons))
        for (var d = 0; d < this.t.customIcons.length; d++)
          this.elCustomIcons.push(i());
      var f = [], p = function(E, L, O) {
        var P = E.toLowerCase();
        t.t[P] && n.config.chart.zoom.enabled && f.push({ el: L, icon: typeof t.t[P] == "string" ? t.t[P] : O, title: t.localeValues[E], class: "apexcharts-".concat(P, "-icon") });
      };
      p("zoomIn", this.elZoomIn, `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
</svg>
`), p("zoomOut", this.elZoomOut, `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
</svg>
`);
      var y = function(E) {
        t.t[E] && n.config.chart[E].enabled && f.push({ el: E === "zoom" ? t.elZoom : t.elSelection, icon: typeof t.t[E] == "string" ? t.t[E] : E === "zoom" ? `<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0V0z" fill="none"/>
    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>
</svg>` : `<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>
</svg>`, title: t.localeValues[E === "zoom" ? "selectionZoom" : "selection"], class: n.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(E, "-icon") });
      };
      y("zoom"), y("selection"), this.t.pan && n.config.chart.zoom.enabled && f.push({ el: this.elPan, icon: typeof this.t.pan == "string" ? this.t.pan : `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">
    <defs>
        <path d="M0 0h24v24H0z" id="a"/>
    </defs>
    <clipPath id="b">
        <use overflow="visible" xlink:href="#a"/>
    </clipPath>
    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>
</svg>`, title: this.localeValues.pan, class: n.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon" }), p("reset", this.elZoomReset, `<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`), this.t.download && f.push({ el: this.elMenuIcon, icon: typeof this.t.download == "string" ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: "apexcharts-menu-icon" });
      for (var S = 0; S < this.elCustomIcons.length; S++)
        f.push({ el: this.elCustomIcons[S], icon: this.t.customIcons[S].icon, title: this.t.customIcons[S].title, index: this.t.customIcons[S].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[S].class });
      f.forEach(function(E, L) {
        E.index && K.moveIndexInArray(f, L, E.index);
      });
      for (var A = 0; A < f.length; A++)
        re.setAttrs(f[A].el, { class: f[A].class, title: f[A].title }), f[A].el.innerHTML = f[A].icon, o.appendChild(f[A].el);
      this._createHamburgerMenu(o), n.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : n.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : n.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
    } }, { key: "_createHamburgerMenu", value: function(t) {
      this.elMenuItems = [], t.appendChild(this.elMenu), re.setAttrs(this.elMenu, { class: "apexcharts-menu" });
      var n = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }, { name: "exportCSV", title: this.localeValues.exportToCSV }];
      this.w.globals.allSeriesHasEqualX || n.splice(2, 1);
      for (var i = 0; i < n.length; i++)
        this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i].innerHTML = n[i].title, re.setAttrs(this.elMenuItems[i], { class: "apexcharts-menu-item ".concat(n[i].name), title: n[i].title }), this.elMenu.appendChild(this.elMenuItems[i]);
    } }, { key: "addToolbarEventListeners", value: function() {
      var t = this;
      this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(i) {
        i.classList.contains("exportSVG") ? i.addEventListener("click", t.handleDownload.bind(t, "svg")) : i.classList.contains("exportPNG") ? i.addEventListener("click", t.handleDownload.bind(t, "png")) : i.classList.contains("exportCSV") && i.addEventListener("click", t.handleDownload.bind(t, "csv"));
      });
      for (var n = 0; n < this.t.customIcons.length; n++)
        this.elCustomIcons[n].addEventListener("click", this.t.customIcons[n].click.bind(this, this.ctx, this.ctx.w));
    } }, { key: "toggleZoomSelection", value: function(t) {
      this.ctx.getSyncedCharts().forEach(function(n) {
        n.ctx.toolbar.toggleOtherControls();
        var i = t === "selection" ? n.ctx.toolbar.elSelection : n.ctx.toolbar.elZoom, o = t === "selection" ? "selectionEnabled" : "zoomEnabled";
        n.w.globals[o] = !n.w.globals[o], i.classList.contains(n.ctx.toolbar.selectedClass) ? i.classList.remove(n.ctx.toolbar.selectedClass) : i.classList.add(n.ctx.toolbar.selectedClass);
      });
    } }, { key: "getToolbarIconsReference", value: function() {
      var t = this.w;
      this.elZoom || (this.elZoom = t.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
    } }, { key: "enableZoomPanFromToolbar", value: function(t) {
      this.toggleOtherControls(), t === "pan" ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
      var n = t === "pan" ? this.elPan : this.elZoom, i = t === "pan" ? this.elZoom : this.elPan;
      n && n.classList.add(this.selectedClass), i && i.classList.remove(this.selectedClass);
    } }, { key: "togglePanning", value: function() {
      this.ctx.getSyncedCharts().forEach(function(t) {
        t.ctx.toolbar.toggleOtherControls(), t.w.globals.panEnabled = !t.w.globals.panEnabled, t.ctx.toolbar.elPan.classList.contains(t.ctx.toolbar.selectedClass) ? t.ctx.toolbar.elPan.classList.remove(t.ctx.toolbar.selectedClass) : t.ctx.toolbar.elPan.classList.add(t.ctx.toolbar.selectedClass);
      });
    } }, { key: "toggleOtherControls", value: function() {
      var t = this, n = this.w;
      n.globals.panEnabled = !1, n.globals.zoomEnabled = !1, n.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(i) {
        i && i.classList.remove(t.selectedClass);
      });
    } }, { key: "handleZoomIn", value: function() {
      var t = this.w;
      t.globals.isRangeBar && (this.minX = t.globals.minY, this.maxX = t.globals.maxY);
      var n = (this.minX + this.maxX) / 2, i = (this.minX + n) / 2, o = (this.maxX + n) / 2, d = this._getNewMinXMaxX(i, o);
      t.globals.disableZoomIn || this.zoomUpdateOptions(d.minX, d.maxX);
    } }, { key: "handleZoomOut", value: function() {
      var t = this.w;
      if (t.globals.isRangeBar && (this.minX = t.globals.minY, this.maxX = t.globals.maxY), !(t.config.xaxis.type === "datetime" && new Date(this.minX).getUTCFullYear() < 1e3)) {
        var n = (this.minX + this.maxX) / 2, i = this.minX - (n - this.minX), o = this.maxX - (n - this.maxX), d = this._getNewMinXMaxX(i, o);
        t.globals.disableZoomOut || this.zoomUpdateOptions(d.minX, d.maxX);
      }
    } }, { key: "_getNewMinXMaxX", value: function(t, n) {
      var i = this.w.config.xaxis.convertedCatToNumeric;
      return { minX: i ? Math.floor(t) : t, maxX: i ? Math.floor(n) : n };
    } }, { key: "zoomUpdateOptions", value: function(t, n) {
      var i = this.w;
      if (t !== void 0 || n !== void 0) {
        if (!(i.config.xaxis.convertedCatToNumeric && (t < 1 && (t = 1, n = i.globals.dataPoints), n - t < 2))) {
          var o = { min: t, max: n }, d = this.getBeforeZoomRange(o);
          d && (o = d.xaxis);
          var f = { xaxis: o }, p = K.clone(i.globals.initialConfig.yaxis);
          i.config.chart.zoom.autoScaleYaxis && (p = new qe(this.ctx).autoScaleY(this.ctx, p, { xaxis: o })), i.config.chart.group || (f.yaxis = p), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(f, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(o, p);
        }
      } else
        this.handleZoomReset();
    } }, { key: "zoomCallback", value: function(t, n) {
      typeof this.ev.zoomed == "function" && this.ev.zoomed(this.ctx, { xaxis: t, yaxis: n });
    } }, { key: "getBeforeZoomRange", value: function(t, n) {
      var i = null;
      return typeof this.ev.beforeZoom == "function" && (i = this.ev.beforeZoom(this, { xaxis: t, yaxis: n })), i;
    } }, { key: "toggleMenu", value: function() {
      var t = this;
      window.setTimeout(function() {
        t.elMenu.classList.contains("apexcharts-menu-open") ? t.elMenu.classList.remove("apexcharts-menu-open") : t.elMenu.classList.add("apexcharts-menu-open");
      }, 0);
    } }, { key: "handleDownload", value: function(t) {
      var n = this.w, i = new jt(this.ctx);
      switch (t) {
        case "svg":
          i.exportToSVG(this.ctx);
          break;
        case "png":
          i.exportToPng(this.ctx);
          break;
        case "csv":
          i.exportToCSV({ series: n.config.series, columnDelimiter: n.config.chart.toolbar.export.csv.columnDelimiter });
      }
    } }, { key: "handleZoomReset", value: function(t) {
      this.ctx.getSyncedCharts().forEach(function(n) {
        var i = n.w;
        if (i.globals.lastXAxis.min = void 0, i.globals.lastXAxis.max = void 0, n.updateHelpers.revertDefaultAxisMinMax(), typeof i.config.chart.events.beforeResetZoom == "function") {
          var o = i.config.chart.events.beforeResetZoom(n, i);
          o && n.updateHelpers.revertDefaultAxisMinMax(o);
        }
        typeof i.config.chart.events.zoomed == "function" && n.ctx.toolbar.zoomCallback({ min: i.config.xaxis.min, max: i.config.xaxis.max }), i.globals.zoomed = !1;
        var d = n.ctx.series.emptyCollapsedSeries(K.clone(i.globals.initialSeries));
        n.updateHelpers._updateSeries(d, i.config.chart.animations.dynamicAnimation.enabled);
      });
    } }, { key: "destroy", value: function() {
      this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
    } }]), B;
  }(), Ki = function(B) {
    U(n, Pa);
    var t = se(n);
    function n(i) {
      var o;
      return C(this, n), (o = t.call(this, i)).ctx = i, o.w = i.w, o.dragged = !1, o.graphics = new re(o.ctx), o.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], o.clientX = 0, o.clientY = 0, o.startX = 0, o.endX = 0, o.dragX = 0, o.startY = 0, o.endY = 0, o.dragY = 0, o.moveDirection = "none", o;
    }
    return F(n, [{ key: "init", value: function(i) {
      var o = this, d = i.xyRatios, f = this.w, p = this;
      this.xyRatios = d, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = f.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), f.globals.dom.elGraphical.add(this.zoomRect), f.globals.dom.elGraphical.add(this.selectionRect), f.config.chart.selection.type === "x" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: f.globals.gridWidth, maxY: f.globals.gridHeight }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : f.config.chart.selection.type === "y" ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: f.globals.gridWidth }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = f.globals.dom.baseEl.querySelector("".concat(f.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(y) {
        o.hoverArea.addEventListener(y, p.svgMouseEvents.bind(p, d), { capture: !1, passive: !0 });
      });
    } }, { key: "destroy", value: function() {
      this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
    } }, { key: "svgMouseEvents", value: function(i, o) {
      var d = this.w, f = this, p = this.ctx.toolbar, y = d.globals.zoomEnabled ? d.config.chart.zoom.type : d.config.chart.selection.type, S = d.config.chart.toolbar.autoSelected;
      if (o.shiftKey ? (this.shiftWasPressed = !0, p.enableZoomPanFromToolbar(S === "pan" ? "zoom" : "pan")) : this.shiftWasPressed && (p.enableZoomPanFromToolbar(S), this.shiftWasPressed = !1), o.target) {
        var A, E = o.target.classList;
        if (o.target.parentNode && o.target.parentNode !== null && (A = o.target.parentNode.classList), !(E.contains("apexcharts-selection-rect") || E.contains("apexcharts-legend-marker") || E.contains("apexcharts-legend-text") || A && A.contains("apexcharts-toolbar"))) {
          if (f.clientX = o.type === "touchmove" || o.type === "touchstart" ? o.touches[0].clientX : o.type === "touchend" ? o.changedTouches[0].clientX : o.clientX, f.clientY = o.type === "touchmove" || o.type === "touchstart" ? o.touches[0].clientY : o.type === "touchend" ? o.changedTouches[0].clientY : o.clientY, o.type === "mousedown" && o.which === 1) {
            var L = f.gridRect.getBoundingClientRect();
            f.startX = f.clientX - L.left, f.startY = f.clientY - L.top, f.dragged = !1, f.w.globals.mousedown = !0;
          }
          if ((o.type === "mousemove" && o.which === 1 || o.type === "touchmove") && (f.dragged = !0, d.globals.panEnabled ? (d.globals.selection = null, f.w.globals.mousedown && f.panDragging({ context: f, zoomtype: y, xyRatios: i })) : (f.w.globals.mousedown && d.globals.zoomEnabled || f.w.globals.mousedown && d.globals.selectionEnabled) && (f.selection = f.selectionDrawing({ context: f, zoomtype: y }))), o.type === "mouseup" || o.type === "touchend" || o.type === "mouseleave") {
            var O = f.gridRect.getBoundingClientRect();
            f.w.globals.mousedown && (f.endX = f.clientX - O.left, f.endY = f.clientY - O.top, f.dragX = Math.abs(f.endX - f.startX), f.dragY = Math.abs(f.endY - f.startY), (d.globals.zoomEnabled || d.globals.selectionEnabled) && f.selectionDrawn({ context: f, zoomtype: y }), d.globals.panEnabled && d.config.xaxis.convertedCatToNumeric && f.delayedPanScrolled()), d.globals.zoomEnabled && f.hideSelectionRect(this.selectionRect), f.dragged = !1, f.w.globals.mousedown = !1;
          }
          this.makeSelectionRectDraggable();
        }
      }
    } }, { key: "makeSelectionRectDraggable", value: function() {
      var i = this.w;
      if (this.selectionRect) {
        var o = this.selectionRect.node.getBoundingClientRect();
        o.width > 0 && o.height > 0 && this.slDraggableRect.selectize({ points: "l, r", pointSize: 8, pointType: "rect" }).resize({ constraint: { minX: 0, minY: 0, maxX: i.globals.gridWidth, maxY: i.globals.gridHeight } }).on("resizing", this.selectionDragging.bind(this, "resizing"));
      }
    } }, { key: "preselectedSelection", value: function() {
      var i = this.w, o = this.xyRatios;
      if (!i.globals.zoomEnabled) {
        if (i.globals.selection !== void 0 && i.globals.selection !== null)
          this.drawSelectionRect(i.globals.selection);
        else if (i.config.chart.selection.xaxis.min !== void 0 && i.config.chart.selection.xaxis.max !== void 0) {
          var d = (i.config.chart.selection.xaxis.min - i.globals.minX) / o.xRatio, f = { x: d, y: 0, width: i.globals.gridWidth - (i.globals.maxX - i.config.chart.selection.xaxis.max) / o.xRatio - d, height: i.globals.gridHeight, translateX: 0, translateY: 0, selectionEnabled: !0 };
          this.drawSelectionRect(f), this.makeSelectionRectDraggable(), typeof i.config.chart.events.selection == "function" && i.config.chart.events.selection(this.ctx, { xaxis: { min: i.config.chart.selection.xaxis.min, max: i.config.chart.selection.xaxis.max }, yaxis: {} });
        }
      }
    } }, { key: "drawSelectionRect", value: function(i) {
      var o = i.x, d = i.y, f = i.width, p = i.height, y = i.translateX, S = y === void 0 ? 0 : y, A = i.translateY, E = A === void 0 ? 0 : A, L = this.w, O = this.zoomRect, P = this.selectionRect;
      if (this.dragged || L.globals.selection !== null) {
        var I = { transform: "translate(" + S + ", " + E + ")" };
        L.globals.zoomEnabled && this.dragged && (f < 0 && (f = 1), O.attr({ x: o, y: d, width: f, height: p, fill: L.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": L.config.chart.zoom.zoomedArea.fill.opacity, stroke: L.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": L.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": L.config.chart.zoom.zoomedArea.stroke.opacity }), re.setAttrs(O.node, I)), L.globals.selectionEnabled && (P.attr({ x: o, y: d, width: f > 0 ? f : 0, height: p > 0 ? p : 0, fill: L.config.chart.selection.fill.color, "fill-opacity": L.config.chart.selection.fill.opacity, stroke: L.config.chart.selection.stroke.color, "stroke-width": L.config.chart.selection.stroke.width, "stroke-dasharray": L.config.chart.selection.stroke.dashArray, "stroke-opacity": L.config.chart.selection.stroke.opacity }), re.setAttrs(P.node, I));
      }
    } }, { key: "hideSelectionRect", value: function(i) {
      i && i.attr({ x: 0, y: 0, width: 0, height: 0 });
    } }, { key: "selectionDrawing", value: function(i) {
      var o = i.context, d = i.zoomtype, f = this.w, p = o, y = this.gridRect.getBoundingClientRect(), S = p.startX - 1, A = p.startY, E = !1, L = !1, O = p.clientX - y.left - S, P = p.clientY - y.top - A, I = {};
      return Math.abs(O + S) > f.globals.gridWidth ? O = f.globals.gridWidth - S : p.clientX - y.left < 0 && (O = S), S > p.clientX - y.left && (E = !0, O = Math.abs(O)), A > p.clientY - y.top && (L = !0, P = Math.abs(P)), I = d === "x" ? { x: E ? S - O : S, y: 0, width: O, height: f.globals.gridHeight } : d === "y" ? { x: 0, y: L ? A - P : A, width: f.globals.gridWidth, height: P } : { x: E ? S - O : S, y: L ? A - P : A, width: O, height: P }, p.drawSelectionRect(I), p.selectionDragging("resizing"), I;
    } }, { key: "selectionDragging", value: function(i, o) {
      var d = this, f = this.w, p = this.xyRatios, y = this.selectionRect, S = 0;
      i === "resizing" && (S = 30);
      var A = function(L) {
        return parseFloat(y.node.getAttribute(L));
      }, E = { x: A("x"), y: A("y"), width: A("width"), height: A("height") };
      f.globals.selection = E, typeof f.config.chart.events.selection == "function" && f.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
        var L = d.gridRect.getBoundingClientRect(), O = y.node.getBoundingClientRect(), P = { xaxis: { min: f.globals.xAxisScale.niceMin + (O.left - L.left) * p.xRatio, max: f.globals.xAxisScale.niceMin + (O.right - L.left) * p.xRatio }, yaxis: { min: f.globals.yAxisScale[0].niceMin + (L.bottom - O.bottom) * p.yRatio[0], max: f.globals.yAxisScale[0].niceMax - (O.top - L.top) * p.yRatio[0] } };
        f.config.chart.events.selection(d.ctx, P), f.config.chart.brush.enabled && f.config.chart.events.brushScrolled !== void 0 && f.config.chart.events.brushScrolled(d.ctx, P);
      }, S));
    } }, { key: "selectionDrawn", value: function(i) {
      var o = i.context, d = i.zoomtype, f = this.w, p = o, y = this.xyRatios, S = this.ctx.toolbar;
      if (p.startX > p.endX) {
        var A = p.startX;
        p.startX = p.endX, p.endX = A;
      }
      if (p.startY > p.endY) {
        var E = p.startY;
        p.startY = p.endY, p.endY = E;
      }
      var L = void 0, O = void 0;
      f.globals.isRangeBar ? (L = f.globals.yAxisScale[0].niceMin + p.startX * y.invertedYRatio, O = f.globals.yAxisScale[0].niceMin + p.endX * y.invertedYRatio) : (L = f.globals.xAxisScale.niceMin + p.startX * y.xRatio, O = f.globals.xAxisScale.niceMin + p.endX * y.xRatio);
      var P = [], I = [];
      if (f.config.yaxis.forEach(function(Q, ee) {
        P.push(f.globals.yAxisScale[ee].niceMax - y.yRatio[ee] * p.startY), I.push(f.globals.yAxisScale[ee].niceMax - y.yRatio[ee] * p.endY);
      }), p.dragged && (p.dragX > 10 || p.dragY > 10) && L !== O) {
        if (f.globals.zoomEnabled) {
          var j = K.clone(f.globals.initialConfig.yaxis), V = K.clone(f.globals.initialConfig.xaxis);
          if (f.globals.zoomed = !0, f.config.xaxis.convertedCatToNumeric && (L = Math.floor(L), O = Math.floor(O), L < 1 && (L = 1, O = f.globals.dataPoints), O - L < 2 && (O = L + 1)), d !== "xy" && d !== "x" || (V = { min: L, max: O }), d !== "xy" && d !== "y" || j.forEach(function(Q, ee) {
            j[ee].min = I[ee], j[ee].max = P[ee];
          }), f.config.chart.zoom.autoScaleYaxis) {
            var Z = new qe(p.ctx);
            j = Z.autoScaleY(p.ctx, j, { xaxis: V });
          }
          if (S) {
            var b = S.getBeforeZoomRange(V, j);
            b && (V = b.xaxis ? b.xaxis : V, j = b.yaxis ? b.yaxis : j);
          }
          var M = { xaxis: V };
          f.config.chart.group || (M.yaxis = j), p.ctx.updateHelpers._updateOptions(M, !1, p.w.config.chart.animations.dynamicAnimation.enabled), typeof f.config.chart.events.zoomed == "function" && S.zoomCallback(V, j);
        } else if (f.globals.selectionEnabled) {
          var N, X = null;
          N = { min: L, max: O }, d !== "xy" && d !== "y" || (X = K.clone(f.config.yaxis)).forEach(function(Q, ee) {
            X[ee].min = I[ee], X[ee].max = P[ee];
          }), f.globals.selection = p.selection, typeof f.config.chart.events.selection == "function" && f.config.chart.events.selection(p.ctx, { xaxis: N, yaxis: X });
        }
      }
    } }, { key: "panDragging", value: function(i) {
      var o = i.context, d = this.w, f = o;
      if (d.globals.lastClientPosition.x !== void 0) {
        var p = d.globals.lastClientPosition.x - f.clientX, y = d.globals.lastClientPosition.y - f.clientY;
        Math.abs(p) > Math.abs(y) && p > 0 ? this.moveDirection = "left" : Math.abs(p) > Math.abs(y) && p < 0 ? this.moveDirection = "right" : Math.abs(y) > Math.abs(p) && y > 0 ? this.moveDirection = "up" : Math.abs(y) > Math.abs(p) && y < 0 && (this.moveDirection = "down");
      }
      d.globals.lastClientPosition = { x: f.clientX, y: f.clientY };
      var S = d.globals.isRangeBar ? d.globals.minY : d.globals.minX, A = d.globals.isRangeBar ? d.globals.maxY : d.globals.maxX;
      d.config.xaxis.convertedCatToNumeric || f.panScrolled(S, A);
    } }, { key: "delayedPanScrolled", value: function() {
      var i = this.w, o = i.globals.minX, d = i.globals.maxX, f = (i.globals.maxX - i.globals.minX) / 2;
      this.moveDirection === "left" ? (o = i.globals.minX + f, d = i.globals.maxX + f) : this.moveDirection === "right" && (o = i.globals.minX - f, d = i.globals.maxX - f), o = Math.floor(o), d = Math.floor(d), this.updateScrolledChart({ xaxis: { min: o, max: d } }, o, d);
    } }, { key: "panScrolled", value: function(i, o) {
      var d = this.w, f = this.xyRatios, p = K.clone(d.globals.initialConfig.yaxis), y = f.xRatio, S = d.globals.minX, A = d.globals.maxX;
      d.globals.isRangeBar && (y = f.invertedYRatio, S = d.globals.minY, A = d.globals.maxY), this.moveDirection === "left" ? (i = S + d.globals.gridWidth / 15 * y, o = A + d.globals.gridWidth / 15 * y) : this.moveDirection === "right" && (i = S - d.globals.gridWidth / 15 * y, o = A - d.globals.gridWidth / 15 * y), d.globals.isRangeBar || (i < d.globals.initialMinX || o > d.globals.initialMaxX) && (i = S, o = A);
      var E = { min: i, max: o };
      d.config.chart.zoom.autoScaleYaxis && (p = new qe(this.ctx).autoScaleY(this.ctx, p, { xaxis: E }));
      var L = { xaxis: { min: i, max: o } };
      d.config.chart.group || (L.yaxis = p), this.updateScrolledChart(L, i, o);
    } }, { key: "updateScrolledChart", value: function(i, o, d) {
      var f = this.w;
      this.ctx.updateHelpers._updateOptions(i, !1, !1), typeof f.config.chart.events.scrolled == "function" && f.config.chart.events.scrolled(this.ctx, { xaxis: { min: o, max: d } });
    } }]), n;
  }(), Je = function() {
    function B(t) {
      C(this, B), this.w = t.w, this.ttCtx = t, this.ctx = t.ctx;
    }
    return F(B, [{ key: "getNearestValues", value: function(t) {
      var n = t.hoverArea, i = t.elGrid, o = t.clientX, d = t.clientY, f = this.w, p = i.getBoundingClientRect(), y = p.width, S = p.height, A = y / (f.globals.dataPoints - 1), E = S / f.globals.dataPoints, L = this.hasBars();
      !f.globals.comboCharts && !L || f.config.xaxis.convertedCatToNumeric || (A = y / f.globals.dataPoints);
      var O = o - p.left - f.globals.barPadForNumericAxis, P = d - p.top;
      O < 0 || P < 0 || O > y || P > S ? (n.classList.remove("hovering-zoom"), n.classList.remove("hovering-pan")) : f.globals.zoomEnabled ? (n.classList.remove("hovering-pan"), n.classList.add("hovering-zoom")) : f.globals.panEnabled && (n.classList.remove("hovering-zoom"), n.classList.add("hovering-pan"));
      var I = Math.round(O / A), j = Math.floor(P / E);
      L && !f.config.xaxis.convertedCatToNumeric && (I = Math.ceil(O / A), I -= 1);
      var V = null, Z = null, b = [], M = [];
      if (f.globals.seriesXvalues.forEach(function(ee) {
        b.push([ee[0] + 1e-6].concat(ee));
      }), f.globals.seriesYvalues.forEach(function(ee) {
        M.push([ee[0] + 1e-6].concat(ee));
      }), b = b.map(function(ee) {
        return ee.filter(function(oe) {
          return K.isNumber(oe);
        });
      }), M = M.map(function(ee) {
        return ee.filter(function(oe) {
          return K.isNumber(oe);
        });
      }), f.globals.isXNumeric) {
        var N = this.ttCtx.getElGrid().getBoundingClientRect(), X = O * (N.width / y), Q = P * (N.height / S);
        V = (Z = this.closestInMultiArray(X, Q, b, M)).index, I = Z.j, V !== null && (b = f.globals.seriesXvalues[V], I = (Z = this.closestInArray(X, b)).index);
      }
      return f.globals.capturedSeriesIndex = V === null ? -1 : V, (!I || I < 1) && (I = 0), f.globals.isBarHorizontal ? f.globals.capturedDataPointIndex = j : f.globals.capturedDataPointIndex = I, { capturedSeries: V, j: f.globals.isBarHorizontal ? j : I, hoverX: O, hoverY: P };
    } }, { key: "closestInMultiArray", value: function(t, n, i, o) {
      var d = this.w, f = 0, p = null, y = -1;
      d.globals.series.length > 1 ? f = this.getFirstActiveXArray(i) : p = 0;
      var S = i[f][0], A = Math.abs(t - S);
      if (i.forEach(function(O) {
        O.forEach(function(P, I) {
          var j = Math.abs(t - P);
          j < A && (A = j, y = I);
        });
      }), y !== -1) {
        var E = o[f][y], L = Math.abs(n - E);
        p = f, o.forEach(function(O, P) {
          var I = Math.abs(n - O[y]);
          I < L && (L = I, p = P);
        });
      }
      return { index: p, j: y };
    } }, { key: "getFirstActiveXArray", value: function(t) {
      for (var n = this.w, i = 0, o = t.map(function(f, p) {
        return f.length > 0 ? p : -1;
      }), d = 0; d < o.length; d++)
        if (o[d] !== -1 && n.globals.collapsedSeriesIndices.indexOf(d) === -1 && n.globals.ancillaryCollapsedSeriesIndices.indexOf(d) === -1) {
          i = o[d];
          break;
        }
      return i;
    } }, { key: "closestInArray", value: function(t, n) {
      for (var i = n[0], o = null, d = Math.abs(t - i), f = 0; f < n.length; f++) {
        var p = Math.abs(t - n[f]);
        p < d && (d = p, o = f);
      }
      return { index: o };
    } }, { key: "isXoverlap", value: function(t) {
      var n = [], i = this.w.globals.seriesX.filter(function(d) {
        return d[0] !== void 0;
      });
      if (i.length > 0)
        for (var o = 0; o < i.length - 1; o++)
          i[o][t] !== void 0 && i[o + 1][t] !== void 0 && i[o][t] !== i[o + 1][t] && n.push("unEqual");
      return n.length === 0;
    } }, { key: "isInitialSeriesSameLen", value: function() {
      for (var t = !0, n = this.w.globals.initialSeries, i = 0; i < n.length - 1; i++)
        if (n[i].data.length !== n[i + 1].data.length) {
          t = !1;
          break;
        }
      return t;
    } }, { key: "getBarsHeight", value: function(t) {
      return ue(t).reduce(function(n, i) {
        return n + i.getBBox().height;
      }, 0);
    } }, { key: "getElMarkers", value: function(t) {
      return typeof t == "number" ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *");
    } }, { key: "getAllMarkers", value: function() {
      var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
      (t = ue(t)).sort(function(i, o) {
        var d = Number(i.getAttribute("data:realIndex")), f = Number(o.getAttribute("data:realIndex"));
        return f < d ? 1 : f > d ? -1 : 0;
      });
      var n = [];
      return t.forEach(function(i) {
        n.push(i.querySelector(".apexcharts-marker"));
      }), n;
    } }, { key: "hasMarkers", value: function(t) {
      return this.getElMarkers(t).length > 0;
    } }, { key: "getElBars", value: function() {
      return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
    } }, { key: "hasBars", value: function() {
      return this.getElBars().length > 0;
    } }, { key: "getHoverMarkerSize", value: function(t) {
      var n = this.w, i = n.config.markers.hover.size;
      return i === void 0 && (i = n.globals.markers.size[t] + n.config.markers.hover.sizeOffset), i;
    } }, { key: "toggleAllTooltipSeriesGroups", value: function(t) {
      var n = this.w, i = this.ttCtx;
      i.allTooltipSeriesGroups.length === 0 && (i.allTooltipSeriesGroups = n.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
      for (var o = i.allTooltipSeriesGroups, d = 0; d < o.length; d++)
        t === "enable" ? (o[d].classList.add("apexcharts-active"), o[d].style.display = n.config.tooltip.items.display) : (o[d].classList.remove("apexcharts-active"), o[d].style.display = "none");
    } }]), B;
  }(), Lt = function() {
    function B(t) {
      C(this, B), this.w = t.w, this.ctx = t.ctx, this.ttCtx = t, this.tooltipUtil = new Je(t);
    }
    return F(B, [{ key: "drawSeriesTexts", value: function(t) {
      var n = t.shared, i = n === void 0 || n, o = t.ttItems, d = t.i, f = d === void 0 ? 0 : d, p = t.j, y = p === void 0 ? null : p, S = t.y1, A = t.y2, E = t.e, L = this.w;
      L.config.tooltip.custom !== void 0 ? this.handleCustomTooltip({ i: f, j: y, y1: S, y2: A, w: L }) : this.toggleActiveInactiveSeries(i);
      var O = this.getValuesToPrint({ i: f, j: y });
      this.printLabels({ i: f, j: y, values: O, ttItems: o, shared: i, e: E });
      var P = this.ttCtx.getElTooltip();
      this.ttCtx.tooltipRect.ttWidth = P.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = P.getBoundingClientRect().height;
    } }, { key: "printLabels", value: function(t) {
      var n, i = this, o = t.i, d = t.j, f = t.values, p = t.ttItems, y = t.shared, S = t.e, A = this.w, E = [], L = function(N) {
        return A.globals.seriesGoals[N] && A.globals.seriesGoals[N][d] && Array.isArray(A.globals.seriesGoals[N][d]);
      }, O = f.xVal, P = f.zVal, I = f.xAxisTTVal, j = "", V = A.globals.colors[o];
      d !== null && A.config.plotOptions.bar.distributed && (V = A.globals.colors[d]);
      for (var Z = function(N, X) {
        var Q = i.getFormatters(o);
        j = i.getSeriesName({ fn: Q.yLbTitleFormatter, index: o, seriesIndex: o, j: d }), A.config.chart.type === "treemap" && (j = Q.yLbTitleFormatter(String(A.config.series[o].data[d].x), { series: A.globals.series, seriesIndex: o, dataPointIndex: d, w: A }));
        var ee = A.config.tooltip.inverseOrder ? X : N;
        if (A.globals.axisCharts) {
          var oe = function(_e) {
            var Le, Ie, at, Qt;
            return A.globals.isRangeData ? Q.yLbFormatter((Le = A.globals.seriesRangeStart) === null || Le === void 0 || (Ie = Le[_e]) === null || Ie === void 0 ? void 0 : Ie[d], { series: A.globals.seriesRangeStart, seriesIndex: _e, dataPointIndex: d, w: A }) + " - " + Q.yLbFormatter((at = A.globals.seriesRangeEnd) === null || at === void 0 || (Qt = at[_e]) === null || Qt === void 0 ? void 0 : Qt[d], { series: A.globals.seriesRangeEnd, seriesIndex: _e, dataPointIndex: d, w: A }) : Q.yLbFormatter(A.globals.series[_e][d], { series: A.globals.series, seriesIndex: _e, dataPointIndex: d, w: A });
          };
          if (y)
            Q = i.getFormatters(ee), j = i.getSeriesName({ fn: Q.yLbTitleFormatter, index: ee, seriesIndex: o, j: d }), V = A.globals.colors[ee], n = oe(ee), L(ee) && (E = A.globals.seriesGoals[ee][d].map(function(_e) {
              return { attrs: _e, val: Q.yLbFormatter(_e.value, { seriesIndex: ee, dataPointIndex: d, w: A }) };
            }));
          else {
            var fe, ke = S == null || (fe = S.target) === null || fe === void 0 ? void 0 : fe.getAttribute("fill");
            ke && (V = ke.indexOf("url") !== -1 ? document.querySelector(ke.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : ke), n = oe(o), L(o) && Array.isArray(A.globals.seriesGoals[o][d]) && (E = A.globals.seriesGoals[o][d].map(function(_e) {
              return { attrs: _e, val: Q.yLbFormatter(_e.value, { seriesIndex: o, dataPointIndex: d, w: A }) };
            }));
          }
        }
        d === null && (n = Q.yLbFormatter(A.globals.series[o], v(v({}, A), {}, { seriesIndex: o, dataPointIndex: o }))), i.DOMHandling({ i: o, t: ee, j: d, ttItems: p, values: { val: n, goalVals: E, xVal: O, xAxisTTVal: I, zVal: P }, seriesName: j, shared: y, pColor: V });
      }, b = 0, M = A.globals.series.length - 1; b < A.globals.series.length; b++, M--)
        Z(b, M);
    } }, { key: "getFormatters", value: function(t) {
      var n, i = this.w, o = i.globals.yLabelFormatters[t];
      return i.globals.ttVal !== void 0 ? Array.isArray(i.globals.ttVal) ? (o = i.globals.ttVal[t] && i.globals.ttVal[t].formatter, n = i.globals.ttVal[t] && i.globals.ttVal[t].title && i.globals.ttVal[t].title.formatter) : (o = i.globals.ttVal.formatter, typeof i.globals.ttVal.title.formatter == "function" && (n = i.globals.ttVal.title.formatter)) : n = i.config.tooltip.y.title.formatter, typeof o != "function" && (o = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function(d) {
        return d;
      }), typeof n != "function" && (n = function(d) {
        return d;
      }), { yLbFormatter: o, yLbTitleFormatter: n };
    } }, { key: "getSeriesName", value: function(t) {
      var n = t.fn, i = t.index, o = t.seriesIndex, d = t.j, f = this.w;
      return n(String(f.globals.seriesNames[i]), { series: f.globals.series, seriesIndex: o, dataPointIndex: d, w: f });
    } }, { key: "DOMHandling", value: function(t) {
      t.i;
      var n = t.t, i = t.j, o = t.ttItems, d = t.values, f = t.seriesName, p = t.shared, y = t.pColor, S = this.w, A = this.ttCtx, E = d.val, L = d.goalVals, O = d.xVal, P = d.xAxisTTVal, I = d.zVal, j = null;
      j = o[n].children, S.config.tooltip.fillSeriesColor && (o[n].style.backgroundColor = y, j[0].style.display = "none"), A.showTooltipTitle && (A.tooltipTitle === null && (A.tooltipTitle = S.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), A.tooltipTitle.innerHTML = O), A.isXAxisTooltipEnabled && (A.xaxisTooltipText.innerHTML = P !== "" ? P : O);
      var V = o[n].querySelector(".apexcharts-tooltip-text-y-label");
      V && (V.innerHTML = f || "");
      var Z = o[n].querySelector(".apexcharts-tooltip-text-y-value");
      Z && (Z.innerHTML = E !== void 0 ? E : ""), j[0] && j[0].classList.contains("apexcharts-tooltip-marker") && (S.config.tooltip.marker.fillColors && Array.isArray(S.config.tooltip.marker.fillColors) && (y = S.config.tooltip.marker.fillColors[n]), j[0].style.backgroundColor = y), S.config.tooltip.marker.show || (j[0].style.display = "none");
      var b = o[n].querySelector(".apexcharts-tooltip-text-goals-label"), M = o[n].querySelector(".apexcharts-tooltip-text-goals-value");
      if (L.length && S.globals.seriesGoals[n]) {
        var N = function() {
          var X = "<div >", Q = "<div>";
          L.forEach(function(ee, oe) {
            X += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(ee.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(ee.attrs.name, "</div>"), Q += "<div>".concat(ee.val, "</div>");
          }), b.innerHTML = X + "</div>", M.innerHTML = Q + "</div>";
        };
        p ? S.globals.seriesGoals[n][i] && Array.isArray(S.globals.seriesGoals[n][i]) ? N() : (b.innerHTML = "", M.innerHTML = "") : N();
      } else
        b.innerHTML = "", M.innerHTML = "";
      I !== null && (o[n].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = S.config.tooltip.z.title, o[n].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = I !== void 0 ? I : ""), p && j[0] && (E == null || S.globals.ancillaryCollapsedSeriesIndices.indexOf(n) > -1 || S.globals.collapsedSeriesIndices.indexOf(n) > -1 ? j[0].parentNode.style.display = "none" : j[0].parentNode.style.display = S.config.tooltip.items.display);
    } }, { key: "toggleActiveInactiveSeries", value: function(t) {
      var n = this.w;
      if (t)
        this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
      else {
        this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
        var i = n.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
        i && (i.classList.add("apexcharts-active"), i.style.display = n.config.tooltip.items.display);
      }
    } }, { key: "getValuesToPrint", value: function(t) {
      var n = t.i, i = t.j, o = this.w, d = this.ctx.series.filteredSeriesX(), f = "", p = "", y = null, S = null, A = { series: o.globals.series, seriesIndex: n, dataPointIndex: i, w: o }, E = o.globals.ttZFormatter;
      i === null ? S = o.globals.series[n] : o.globals.isXNumeric && o.config.chart.type !== "treemap" ? (f = d[n][i], d[n].length === 0 && (f = d[this.tooltipUtil.getFirstActiveXArray(d)][i])) : f = o.globals.labels[i] !== void 0 ? o.globals.labels[i] : "";
      var L = f;
      return o.globals.isXNumeric && o.config.xaxis.type === "datetime" ? f = new Vt(this.ctx).xLabelFormat(o.globals.ttKeyFormatter, L, L, { i: void 0, dateFormatter: new Ze(this.ctx).formatDate, w: this.w }) : f = o.globals.isBarHorizontal ? o.globals.yLabelFormatters[0](L, A) : o.globals.xLabelFormatter(L, A), o.config.tooltip.x.formatter !== void 0 && (f = o.globals.ttKeyFormatter(L, A)), o.globals.seriesZ.length > 0 && o.globals.seriesZ[n].length > 0 && (y = E(o.globals.seriesZ[n][i], o)), p = typeof o.config.xaxis.tooltip.formatter == "function" ? o.globals.xaxisTooltipFormatter(L, A) : f, { val: Array.isArray(S) ? S.join(" ") : S, xVal: Array.isArray(f) ? f.join(" ") : f, xAxisTTVal: Array.isArray(p) ? p.join(" ") : p, zVal: y };
    } }, { key: "handleCustomTooltip", value: function(t) {
      var n = t.i, i = t.j, o = t.y1, d = t.y2, f = t.w, p = this.ttCtx.getElTooltip(), y = f.config.tooltip.custom;
      Array.isArray(y) && y[n] && (y = y[n]), p.innerHTML = y({ ctx: this.ctx, series: f.globals.series, seriesIndex: n, dataPointIndex: i, y1: o, y2: d, w: f });
    } }]), B;
  }(), tn = function() {
    function B(t) {
      C(this, B), this.ttCtx = t, this.ctx = t.ctx, this.w = t.w;
    }
    return F(B, [{ key: "moveXCrosshairs", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = this.ttCtx, o = this.w, d = i.getElXCrosshairs(), f = t - i.xcrosshairsWidth / 2, p = o.globals.labels.slice().length;
      if (n !== null && (f = o.globals.gridWidth / p * n), d === null || o.globals.isBarHorizontal || (d.setAttribute("x", f), d.setAttribute("x1", f), d.setAttribute("x2", f), d.setAttribute("y2", o.globals.gridHeight), d.classList.add("apexcharts-active")), f < 0 && (f = 0), f > o.globals.gridWidth && (f = o.globals.gridWidth), i.isXAxisTooltipEnabled) {
        var y = f;
        o.config.xaxis.crosshairs.width !== "tickWidth" && o.config.xaxis.crosshairs.width !== "barWidth" || (y = f + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(y);
      }
    } }, { key: "moveYCrosshairs", value: function(t) {
      var n = this.ttCtx;
      n.ycrosshairs !== null && re.setAttrs(n.ycrosshairs, { y1: t, y2: t }), n.ycrosshairsHidden !== null && re.setAttrs(n.ycrosshairsHidden, { y1: t, y2: t });
    } }, { key: "moveXAxisTooltip", value: function(t) {
      var n = this.w, i = this.ttCtx;
      if (i.xaxisTooltip !== null && i.xcrosshairsWidth !== 0) {
        i.xaxisTooltip.classList.add("apexcharts-active");
        var o = i.xaxisOffY + n.config.xaxis.tooltip.offsetY + n.globals.translateY + 1 + n.config.xaxis.offsetY;
        if (t -= i.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t)) {
          t += n.globals.translateX;
          var d;
          d = new re(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML), i.xaxisTooltipText.style.minWidth = d.width + "px", i.xaxisTooltip.style.left = t + "px", i.xaxisTooltip.style.top = o + "px";
        }
      }
    } }, { key: "moveYAxisTooltip", value: function(t) {
      var n = this.w, i = this.ttCtx;
      i.yaxisTTEls === null && (i.yaxisTTEls = n.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
      var o = parseInt(i.ycrosshairsHidden.getAttribute("y1"), 10), d = n.globals.translateY + o, f = i.yaxisTTEls[t].getBoundingClientRect().height, p = n.globals.translateYAxisX[t] - 2;
      n.config.yaxis[t].opposite && (p -= 26), d -= f / 2, n.globals.ignoreYAxisIndexes.indexOf(t) === -1 ? (i.yaxisTTEls[t].classList.add("apexcharts-active"), i.yaxisTTEls[t].style.top = d + "px", i.yaxisTTEls[t].style.left = p + n.config.yaxis[t].tooltip.offsetX + "px") : i.yaxisTTEls[t].classList.remove("apexcharts-active");
    } }, { key: "moveTooltip", value: function(t, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, o = this.w, d = this.ttCtx, f = d.getElTooltip(), p = d.tooltipRect, y = i !== null ? parseFloat(i) : 1, S = parseFloat(t) + y + 5, A = parseFloat(n) + y / 2;
      if (S > o.globals.gridWidth / 2 && (S = S - p.ttWidth - y - 10), S > o.globals.gridWidth - p.ttWidth - 10 && (S = o.globals.gridWidth - p.ttWidth), S < -20 && (S = -20), o.config.tooltip.followCursor) {
        var E = d.getElGrid().getBoundingClientRect();
        (S = d.e.clientX - E.left) > o.globals.gridWidth / 2 && (S -= d.tooltipRect.ttWidth), (A = d.e.clientY + o.globals.translateY - E.top) > o.globals.gridHeight / 2 && (A -= d.tooltipRect.ttHeight);
      } else
        o.globals.isBarHorizontal || p.ttHeight / 2 + A > o.globals.gridHeight && (A = o.globals.gridHeight - p.ttHeight + o.globals.translateY);
      isNaN(S) || (S += o.globals.translateX, f.style.left = S + "px", f.style.top = A + "px");
    } }, { key: "moveMarkers", value: function(t, n) {
      var i = this.w, o = this.ttCtx;
      if (i.globals.markers.size[t] > 0)
        for (var d = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-marker")), f = 0; f < d.length; f++)
          parseInt(d[f].getAttribute("rel"), 10) === n && (o.marker.resetPointsSize(), o.marker.enlargeCurrentPoint(n, d[f]));
      else
        o.marker.resetPointsSize(), this.moveDynamicPointOnHover(n, t);
    } }, { key: "moveDynamicPointOnHover", value: function(t, n) {
      var i, o, d = this.w, f = this.ttCtx, p = d.globals.pointsArray, y = f.tooltipUtil.getHoverMarkerSize(n), S = d.config.series[n].type;
      if (!S || S !== "column" && S !== "candlestick" && S !== "boxPlot") {
        i = p[n][t][0], o = p[n][t][1] ? p[n][t][1] : 0;
        var A = d.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(n, "'] .apexcharts-series-markers circle"));
        A && o < d.globals.gridHeight && o > 0 && (A.setAttribute("r", y), A.setAttribute("cx", i), A.setAttribute("cy", o)), this.moveXCrosshairs(i), f.fixedTooltip || this.moveTooltip(i, o, y);
      }
    } }, { key: "moveDynamicPointsOnHover", value: function(t) {
      var n, i = this.ttCtx, o = i.w, d = 0, f = 0, p = o.globals.pointsArray;
      n = new ot(this.ctx).getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
      var y = i.tooltipUtil.getHoverMarkerSize(n);
      p[n] && (d = p[n][t][0], f = p[n][t][1]);
      var S = i.tooltipUtil.getAllMarkers();
      if (S !== null)
        for (var A = 0; A < o.globals.series.length; A++) {
          var E = p[A];
          if (o.globals.comboCharts && E === void 0 && S.splice(A, 0, null), E && E.length) {
            var L = p[A][t][1], O = void 0;
            if (S[A].setAttribute("cx", d), o.config.chart.type === "rangeArea" && !o.globals.comboCharts) {
              var P = t + o.globals.series[A].length;
              O = p[A][P][1], L -= Math.abs(L - O) / 2;
            }
            L !== null && !isNaN(L) && L < o.globals.gridHeight + y && L + y > 0 ? (S[A] && S[A].setAttribute("r", y), S[A] && S[A].setAttribute("cy", L)) : S[A] && S[A].setAttribute("r", 0);
          }
        }
      this.moveXCrosshairs(d), i.fixedTooltip || this.moveTooltip(d, f || o.globals.gridHeight, y);
    } }, { key: "moveStickyTooltipOverBars", value: function(t, n) {
      var i = this.w, o = this.ttCtx, d = i.globals.columnSeries ? i.globals.columnSeries.length : i.globals.series.length, f = d >= 2 && d % 2 == 0 ? Math.floor(d / 2) : Math.floor(d / 2) + 1;
      i.globals.isBarHorizontal && (f = new ot(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
      var p = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(f, "'] path[j='").concat(t, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(f, "'] path[j='").concat(t, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(f, "'] path[j='").concat(t, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(f, "'] path[j='").concat(t, "']"));
      p || typeof n != "number" || (p = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(n, "'] path[j='").concat(t, `'],
        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='`).concat(n, "'] path[j='").concat(t, `'],
        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='`).concat(n, "'] path[j='").concat(t, `'],
        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='`).concat(n, "'] path[j='").concat(t, "']")));
      var y = p ? parseFloat(p.getAttribute("cx")) : 0, S = p ? parseFloat(p.getAttribute("cy")) : 0, A = p ? parseFloat(p.getAttribute("barWidth")) : 0, E = o.getElGrid().getBoundingClientRect(), L = p && (p.classList.contains("apexcharts-candlestick-area") || p.classList.contains("apexcharts-boxPlot-area"));
      i.globals.isXNumeric ? (p && !L && (y -= d % 2 != 0 ? A / 2 : 0), p && L && i.globals.comboCharts && (y -= A / 2)) : i.globals.isBarHorizontal || (y = o.xAxisTicksPositions[t - 1] + o.dataPointsDividedWidth / 2, isNaN(y) && (y = o.xAxisTicksPositions[t] - o.dataPointsDividedWidth / 2)), i.globals.isBarHorizontal ? S -= o.tooltipRect.ttHeight : i.config.tooltip.followCursor ? S = o.e.clientY - E.top - o.tooltipRect.ttHeight / 2 : S + o.tooltipRect.ttHeight + 15 > i.globals.gridHeight && (S = i.globals.gridHeight), i.globals.isBarHorizontal || this.moveXCrosshairs(y), o.fixedTooltip || this.moveTooltip(y, S || i.globals.gridHeight);
    } }]), B;
  }(), bn = function() {
    function B(t) {
      C(this, B), this.w = t.w, this.ttCtx = t, this.ctx = t.ctx, this.tooltipPosition = new tn(t);
    }
    return F(B, [{ key: "drawDynamicPoints", value: function() {
      var t = this.w, n = new re(this.ctx), i = new St(this.ctx), o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
      o = ue(o), t.config.chart.stacked && o.sort(function(E, L) {
        return parseFloat(E.getAttribute("data:realIndex")) - parseFloat(L.getAttribute("data:realIndex"));
      });
      for (var d = 0; d < o.length; d++) {
        var f = o[d].querySelector(".apexcharts-series-markers-wrap");
        if (f !== null) {
          var p = void 0, y = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
          t.config.chart.type !== "line" && t.config.chart.type !== "area" || t.globals.comboCharts || t.config.tooltip.intersect || (y += " no-pointer-events");
          var S = i.getMarkerConfig({ cssClass: y, seriesIndex: Number(f.getAttribute("data:realIndex")) });
          (p = n.drawMarker(0, 0, S)).node.setAttribute("default-marker-size", 0);
          var A = document.createElementNS(t.globals.SVGNS, "g");
          A.classList.add("apexcharts-series-markers"), A.appendChild(p.node), f.appendChild(A);
        }
      }
    } }, { key: "enlargeCurrentPoint", value: function(t, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, d = this.w;
      d.config.chart.type !== "bubble" && this.newPointSize(t, n);
      var f = n.getAttribute("cx"), p = n.getAttribute("cy");
      if (i !== null && o !== null && (f = i, p = o), this.tooltipPosition.moveXCrosshairs(f), !this.fixedTooltip) {
        if (d.config.chart.type === "radar") {
          var y = this.ttCtx.getElGrid().getBoundingClientRect();
          f = this.ttCtx.e.clientX - y.left;
        }
        this.tooltipPosition.moveTooltip(f, p, d.config.markers.hover.size);
      }
    } }, { key: "enlargePoints", value: function(t) {
      for (var n = this.w, i = this, o = this.ttCtx, d = t, f = n.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), p = n.config.markers.hover.size, y = 0; y < f.length; y++) {
        var S = f[y].getAttribute("rel"), A = f[y].getAttribute("index");
        if (p === void 0 && (p = n.globals.markers.size[A] + n.config.markers.hover.sizeOffset), d === parseInt(S, 10)) {
          i.newPointSize(d, f[y]);
          var E = f[y].getAttribute("cx"), L = f[y].getAttribute("cy");
          i.tooltipPosition.moveXCrosshairs(E), o.fixedTooltip || i.tooltipPosition.moveTooltip(E, L, p);
        } else
          i.oldPointSize(f[y]);
      }
    } }, { key: "newPointSize", value: function(t, n) {
      var i = this.w, o = i.config.markers.hover.size, d = t === 0 ? n.parentNode.firstChild : n.parentNode.lastChild;
      if (d.getAttribute("default-marker-size") !== "0") {
        var f = parseInt(d.getAttribute("index"), 10);
        o === void 0 && (o = i.globals.markers.size[f] + i.config.markers.hover.sizeOffset), o < 0 && (o = 0), d.setAttribute("r", o);
      }
    } }, { key: "oldPointSize", value: function(t) {
      var n = parseFloat(t.getAttribute("default-marker-size"));
      t.setAttribute("r", n);
    } }, { key: "resetPointsSize", value: function() {
      for (var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), n = 0; n < t.length; n++) {
        var i = parseFloat(t[n].getAttribute("default-marker-size"));
        K.isNumber(i) && i >= 0 ? t[n].setAttribute("r", i) : t[n].setAttribute("r", 0);
      }
    } }]), B;
  }(), Un = function() {
    function B(t) {
      C(this, B), this.w = t.w;
      var n = this.w;
      this.ttCtx = t, this.isVerticalGroupedRangeBar = !n.globals.isBarHorizontal && n.config.chart.type === "rangeBar" && n.config.plotOptions.bar.rangeBarGroupRows;
    }
    return F(B, [{ key: "getAttr", value: function(t, n) {
      return parseFloat(t.target.getAttribute(n));
    } }, { key: "handleHeatTreeTooltip", value: function(t) {
      var n = t.e, i = t.opt, o = t.x, d = t.y, f = t.type, p = this.ttCtx, y = this.w;
      if (n.target.classList.contains("apexcharts-".concat(f, "-rect"))) {
        var S = this.getAttr(n, "i"), A = this.getAttr(n, "j"), E = this.getAttr(n, "cx"), L = this.getAttr(n, "cy"), O = this.getAttr(n, "width"), P = this.getAttr(n, "height");
        if (p.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: S, j: A, shared: !1, e: n }), y.globals.capturedSeriesIndex = S, y.globals.capturedDataPointIndex = A, o = E + p.tooltipRect.ttWidth / 2 + O, d = L + p.tooltipRect.ttHeight / 2 - P / 2, p.tooltipPosition.moveXCrosshairs(E + O / 2), o > y.globals.gridWidth / 2 && (o = E - p.tooltipRect.ttWidth / 2 + O), p.w.config.tooltip.followCursor) {
          var I = y.globals.dom.elWrap.getBoundingClientRect();
          o = y.globals.clientX - I.left - (o > y.globals.gridWidth / 2 ? p.tooltipRect.ttWidth : 0), d = y.globals.clientY - I.top - (d > y.globals.gridHeight / 2 ? p.tooltipRect.ttHeight : 0);
        }
      }
      return { x: o, y: d };
    } }, { key: "handleMarkerTooltip", value: function(t) {
      var n, i, o = t.e, d = t.opt, f = t.x, p = t.y, y = this.w, S = this.ttCtx;
      if (o.target.classList.contains("apexcharts-marker")) {
        var A = parseInt(d.paths.getAttribute("cx"), 10), E = parseInt(d.paths.getAttribute("cy"), 10), L = parseFloat(d.paths.getAttribute("val"));
        if (i = parseInt(d.paths.getAttribute("rel"), 10), n = parseInt(d.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, S.intersect) {
          var O = K.findAncestor(d.paths, "apexcharts-series");
          O && (n = parseInt(O.getAttribute("data:realIndex"), 10));
        }
        if (S.tooltipLabels.drawSeriesTexts({ ttItems: d.ttItems, i: n, j: i, shared: !S.showOnIntersect && y.config.tooltip.shared, e: o }), o.type === "mouseup" && S.markerClick(o, n, i), y.globals.capturedSeriesIndex = n, y.globals.capturedDataPointIndex = i, f = A, p = E + y.globals.translateY - 1.4 * S.tooltipRect.ttHeight, S.w.config.tooltip.followCursor) {
          var P = S.getElGrid().getBoundingClientRect();
          p = S.e.clientY + y.globals.translateY - P.top;
        }
        L < 0 && (p = E), S.marker.enlargeCurrentPoint(i, d.paths, f, p);
      }
      return { x: f, y: p };
    } }, { key: "handleBarTooltip", value: function(t) {
      var n, i, o = t.e, d = t.opt, f = this.w, p = this.ttCtx, y = p.getElTooltip(), S = 0, A = 0, E = 0, L = this.getBarTooltipXY({ e: o, opt: d });
      n = L.i;
      var O = L.barHeight, P = L.j;
      f.globals.capturedSeriesIndex = n, f.globals.capturedDataPointIndex = P, f.globals.isBarHorizontal && p.tooltipUtil.hasBars() || !f.config.tooltip.shared ? (A = L.x, E = L.y, i = Array.isArray(f.config.stroke.width) ? f.config.stroke.width[n] : f.config.stroke.width, S = A) : f.globals.comboCharts || f.config.tooltip.shared || (S /= 2), isNaN(E) && (E = f.globals.svgHeight - p.tooltipRect.ttHeight);
      var I = parseInt(d.paths.parentNode.getAttribute("data:realIndex"), 10), j = f.globals.isMultipleYAxis ? f.config.yaxis[I] && f.config.yaxis[I].reversed : f.config.yaxis[0].reversed;
      if (A + p.tooltipRect.ttWidth > f.globals.gridWidth && !j ? A -= p.tooltipRect.ttWidth : A < 0 && (A = 0), p.w.config.tooltip.followCursor) {
        var V = p.getElGrid().getBoundingClientRect();
        E = p.e.clientY - V.top;
      }
      p.tooltip === null && (p.tooltip = f.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), f.config.tooltip.shared || (f.globals.comboBarCount > 0 ? p.tooltipPosition.moveXCrosshairs(S + i / 2) : p.tooltipPosition.moveXCrosshairs(S)), !p.fixedTooltip && (!f.config.tooltip.shared || f.globals.isBarHorizontal && p.tooltipUtil.hasBars()) && (j && (A -= p.tooltipRect.ttWidth) < 0 && (A = 0), !j || f.globals.isBarHorizontal && p.tooltipUtil.hasBars() || (E = E + O - 2 * (f.globals.series[n][P] < 0 ? O : 0)), E = E + f.globals.translateY - p.tooltipRect.ttHeight / 2, y.style.left = A + f.globals.translateX + "px", y.style.top = E + "px");
    } }, { key: "getBarTooltipXY", value: function(t) {
      var n = this, i = t.e, o = t.opt, d = this.w, f = null, p = this.ttCtx, y = 0, S = 0, A = 0, E = 0, L = 0, O = i.target.classList;
      if (O.contains("apexcharts-bar-area") || O.contains("apexcharts-candlestick-area") || O.contains("apexcharts-boxPlot-area") || O.contains("apexcharts-rangebar-area")) {
        var P = i.target, I = P.getBoundingClientRect(), j = o.elGrid.getBoundingClientRect(), V = I.height;
        L = I.height;
        var Z = I.width, b = parseInt(P.getAttribute("cx"), 10), M = parseInt(P.getAttribute("cy"), 10);
        E = parseFloat(P.getAttribute("barWidth"));
        var N = i.type === "touchmove" ? i.touches[0].clientX : i.clientX;
        f = parseInt(P.getAttribute("j"), 10), y = parseInt(P.parentNode.getAttribute("rel"), 10) - 1;
        var X = P.getAttribute("data-range-y1"), Q = P.getAttribute("data-range-y2");
        d.globals.comboCharts && (y = parseInt(P.parentNode.getAttribute("data:realIndex"), 10));
        var ee = function(fe) {
          return d.globals.isXNumeric ? b - Z / 2 : n.isVerticalGroupedRangeBar ? b + Z / 2 : b - p.dataPointsDividedWidth + Z / 2;
        }, oe = function() {
          return M - p.dataPointsDividedHeight + V / 2 - p.tooltipRect.ttHeight / 2;
        };
        p.tooltipLabels.drawSeriesTexts({ ttItems: o.ttItems, i: y, j: f, y1: X ? parseInt(X, 10) : null, y2: Q ? parseInt(Q, 10) : null, shared: !p.showOnIntersect && d.config.tooltip.shared, e: i }), d.config.tooltip.followCursor ? d.globals.isBarHorizontal ? (S = N - j.left + 15, A = oe()) : (S = ee(), A = i.clientY - j.top - p.tooltipRect.ttHeight / 2 - 15) : d.globals.isBarHorizontal ? ((S = b) < p.xyRatios.baseLineInvertedY && (S = b - p.tooltipRect.ttWidth), A = oe()) : (S = ee(), A = M);
      }
      return { x: S, y: A, barHeight: L, barWidth: E, i: y, j: f };
    } }]), B;
  }(), vr = function() {
    function B(t) {
      C(this, B), this.w = t.w, this.ttCtx = t;
    }
    return F(B, [{ key: "drawXaxisTooltip", value: function() {
      var t = this.w, n = this.ttCtx, i = t.config.xaxis.position === "bottom";
      n.xaxisOffY = i ? t.globals.gridHeight + 1 : -t.globals.xAxisHeight - t.config.xaxis.axisTicks.height + 3;
      var o = i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", d = t.globals.dom.elWrap;
      n.isXAxisTooltipEnabled && t.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") === null && (n.xaxisTooltip = document.createElement("div"), n.xaxisTooltip.setAttribute("class", o + " apexcharts-theme-" + t.config.tooltip.theme), d.appendChild(n.xaxisTooltip), n.xaxisTooltipText = document.createElement("div"), n.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), n.xaxisTooltipText.style.fontFamily = t.config.xaxis.tooltip.style.fontFamily || t.config.chart.fontFamily, n.xaxisTooltipText.style.fontSize = t.config.xaxis.tooltip.style.fontSize, n.xaxisTooltip.appendChild(n.xaxisTooltipText));
    } }, { key: "drawYaxisTooltip", value: function() {
      for (var t = this.w, n = this.ttCtx, i = function(d) {
        var f = t.config.yaxis[d].opposite || t.config.yaxis[d].crosshairs.opposite;
        n.yaxisOffX = f ? t.globals.gridWidth + 1 : 1;
        var p = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(d, f ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
        t.globals.yAxisSameScaleIndices.map(function(S, A) {
          S.map(function(E, L) {
            L === d && (p += t.config.yaxis[L].show ? " " : " apexcharts-yaxistooltip-hidden");
          });
        });
        var y = t.globals.dom.elWrap;
        t.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(d)) === null && (n.yaxisTooltip = document.createElement("div"), n.yaxisTooltip.setAttribute("class", p + " apexcharts-theme-" + t.config.tooltip.theme), y.appendChild(n.yaxisTooltip), d === 0 && (n.yaxisTooltipText = []), n.yaxisTooltipText[d] = document.createElement("div"), n.yaxisTooltipText[d].classList.add("apexcharts-yaxistooltip-text"), n.yaxisTooltip.appendChild(n.yaxisTooltipText[d]));
      }, o = 0; o < t.config.yaxis.length; o++)
        i(o);
    } }, { key: "setXCrosshairWidth", value: function() {
      var t = this.w, n = this.ttCtx, i = n.getElXCrosshairs();
      if (n.xcrosshairsWidth = parseInt(t.config.xaxis.crosshairs.width, 10), t.globals.comboCharts) {
        var o = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
        if (o !== null && t.config.xaxis.crosshairs.width === "barWidth") {
          var d = parseFloat(o.getAttribute("barWidth"));
          n.xcrosshairsWidth = d;
        } else if (t.config.xaxis.crosshairs.width === "tickWidth") {
          var f = t.globals.labels.length;
          n.xcrosshairsWidth = t.globals.gridWidth / f;
        }
      } else if (t.config.xaxis.crosshairs.width === "tickWidth") {
        var p = t.globals.labels.length;
        n.xcrosshairsWidth = t.globals.gridWidth / p;
      } else if (t.config.xaxis.crosshairs.width === "barWidth") {
        var y = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
        if (y !== null) {
          var S = parseFloat(y.getAttribute("barWidth"));
          n.xcrosshairsWidth = S;
        } else
          n.xcrosshairsWidth = 1;
      }
      t.globals.isBarHorizontal && (n.xcrosshairsWidth = 0), i !== null && n.xcrosshairsWidth > 0 && i.setAttribute("width", n.xcrosshairsWidth);
    } }, { key: "handleYCrosshair", value: function() {
      var t = this.w, n = this.ttCtx;
      n.ycrosshairs = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), n.ycrosshairsHidden = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
    } }, { key: "drawYaxisTooltipText", value: function(t, n, i) {
      var o = this.ttCtx, d = this.w, f = d.globals.yLabelFormatters[t];
      if (o.yaxisTooltips[t]) {
        var p = o.getElGrid().getBoundingClientRect(), y = (n - p.top) * i.yRatio[t], S = d.globals.maxYArr[t] - d.globals.minYArr[t], A = d.globals.minYArr[t] + (S - y);
        o.tooltipPosition.moveYCrosshairs(n - p.top), o.yaxisTooltipText[t].innerHTML = f(A), o.tooltipPosition.moveYAxisTooltip(t);
      }
    } }]), B;
  }(), $n = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
      var n = this.w;
      this.tConfig = n.config.tooltip, this.tooltipUtil = new Je(this), this.tooltipLabels = new Lt(this), this.tooltipPosition = new tn(this), this.marker = new bn(this), this.intersect = new Un(this), this.axesTooltip = new vr(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !n.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
    }
    return F(B, [{ key: "getElTooltip", value: function(t) {
      return t || (t = this), t.w.globals.dom.baseEl ? t.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
    } }, { key: "getElXCrosshairs", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
    } }, { key: "getElGrid", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
    } }, { key: "drawTooltip", value: function(t) {
      var n = this.w;
      this.xyRatios = t, this.isXAxisTooltipEnabled = n.config.xaxis.tooltip.enabled && n.globals.axisCharts, this.yaxisTooltips = n.config.yaxis.map(function(f, p) {
        return !!(f.show && f.tooltip.enabled && n.globals.axisCharts);
      }), this.allTooltipSeriesGroups = [], n.globals.axisCharts || (this.showTooltipTitle = !1);
      var i = document.createElement("div");
      if (i.classList.add("apexcharts-tooltip"), n.config.tooltip.cssClass && i.classList.add(n.config.tooltip.cssClass), i.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), n.globals.dom.elWrap.appendChild(i), n.globals.axisCharts) {
        this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
        var o = new Ut(this.ctx);
        this.xAxisTicksPositions = o.getXAxisTicksPositions();
      }
      if (!n.globals.comboCharts && !this.tConfig.intersect && n.config.chart.type !== "rangeBar" || this.tConfig.shared || (this.showOnIntersect = !0), n.config.markers.size !== 0 && n.globals.markers.largestSize !== 0 || this.marker.drawDynamicPoints(this), n.globals.collapsedSeries.length !== n.globals.series.length) {
        this.dataPointsDividedHeight = n.globals.gridHeight / n.globals.dataPoints, this.dataPointsDividedWidth = n.globals.gridWidth / n.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || n.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i.appendChild(this.tooltipTitle));
        var d = n.globals.series.length;
        (n.globals.xyCharts || n.globals.comboCharts) && this.tConfig.shared && (d = this.showOnIntersect ? 1 : n.globals.series.length), this.legendLabels = n.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(d), this.addSVGEvents();
      }
    } }, { key: "createTTElements", value: function(t) {
      for (var n = this, i = this.w, o = [], d = this.getElTooltip(), f = function(y) {
        var S = document.createElement("div");
        S.classList.add("apexcharts-tooltip-series-group"), S.style.order = i.config.tooltip.inverseOrder ? t - y : y + 1, n.tConfig.shared && n.tConfig.enabledOnSeries && Array.isArray(n.tConfig.enabledOnSeries) && n.tConfig.enabledOnSeries.indexOf(y) < 0 && S.classList.add("apexcharts-tooltip-series-group-hidden");
        var A = document.createElement("span");
        A.classList.add("apexcharts-tooltip-marker"), A.style.backgroundColor = i.globals.colors[y], S.appendChild(A);
        var E = document.createElement("div");
        E.classList.add("apexcharts-tooltip-text"), E.style.fontFamily = n.tConfig.style.fontFamily || i.config.chart.fontFamily, E.style.fontSize = n.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function(L) {
          var O = document.createElement("div");
          O.classList.add("apexcharts-tooltip-".concat(L, "-group"));
          var P = document.createElement("span");
          P.classList.add("apexcharts-tooltip-text-".concat(L, "-label")), O.appendChild(P);
          var I = document.createElement("span");
          I.classList.add("apexcharts-tooltip-text-".concat(L, "-value")), O.appendChild(I), E.appendChild(O);
        }), S.appendChild(E), d.appendChild(S), o.push(S);
      }, p = 0; p < t; p++)
        f(p);
      return o;
    } }, { key: "addSVGEvents", value: function() {
      var t = this.w, n = t.config.chart.type, i = this.getElTooltip(), o = !(n !== "bar" && n !== "candlestick" && n !== "boxPlot" && n !== "rangeBar"), d = n === "area" || n === "line" || n === "scatter" || n === "bubble" || n === "radar", f = t.globals.dom.Paper.node, p = this.getElGrid();
      p && (this.seriesBound = p.getBoundingClientRect());
      var y, S = [], A = [], E = { hoverArea: f, elGrid: p, tooltipEl: i, tooltipY: S, tooltipX: A, ttItems: this.ttItems };
      if (t.globals.axisCharts && (d ? y = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : o ? y = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : n !== "heatmap" && n !== "treemap" || (y = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), y && y.length))
        for (var L = 0; L < y.length; L++)
          S.push(y[L].getAttribute("cy")), A.push(y[L].getAttribute("cx"));
      if (t.globals.xyCharts && !this.showOnIntersect || t.globals.comboCharts && !this.showOnIntersect || o && this.tooltipUtil.hasBars() && this.tConfig.shared)
        this.addPathsEventListeners([f], E);
      else if (o && !t.globals.comboCharts || d && this.showOnIntersect)
        this.addDatapointEventsListeners(E);
      else if (!t.globals.axisCharts || n === "heatmap" || n === "treemap") {
        var O = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
        this.addPathsEventListeners(O, E);
      }
      if (this.showOnIntersect) {
        var P = t.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
        P.length > 0 && this.addPathsEventListeners(P, E), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(E);
      }
    } }, { key: "drawFixedTooltipRect", value: function() {
      var t = this.w, n = this.getElTooltip(), i = n.getBoundingClientRect(), o = i.width + 10, d = i.height + 10, f = this.tConfig.fixed.offsetX, p = this.tConfig.fixed.offsetY, y = this.tConfig.fixed.position.toLowerCase();
      return y.indexOf("right") > -1 && (f = f + t.globals.svgWidth - o + 10), y.indexOf("bottom") > -1 && (p = p + t.globals.svgHeight - d - 10), n.style.left = f + "px", n.style.top = p + "px", { x: f, y: p, ttWidth: o, ttHeight: d };
    } }, { key: "addDatapointEventsListeners", value: function(t) {
      var n = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
      this.addPathsEventListeners(n, t);
    } }, { key: "addPathsEventListeners", value: function(t, n) {
      for (var i = this, o = function(f) {
        var p = { paths: t[f], tooltipEl: n.tooltipEl, tooltipY: n.tooltipY, tooltipX: n.tooltipX, elGrid: n.elGrid, hoverArea: n.hoverArea, ttItems: n.ttItems };
        ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(y) {
          return t[f].addEventListener(y, i.onSeriesHover.bind(i, p), { capture: !1, passive: !0 });
        });
      }, d = 0; d < t.length; d++)
        o(d);
    } }, { key: "onSeriesHover", value: function(t, n) {
      var i = this, o = Date.now() - this.lastHoverTime;
      o >= 100 ? this.seriesHover(t, n) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
        i.seriesHover(t, n);
      }, 100 - o));
    } }, { key: "seriesHover", value: function(t, n) {
      var i = this;
      this.lastHoverTime = Date.now();
      var o = [], d = this.w;
      d.config.chart.group && (o = this.ctx.getGroupedCharts()), d.globals.axisCharts && (d.globals.minX === -1 / 0 && d.globals.maxX === 1 / 0 || d.globals.dataPoints === 0) || (o.length ? o.forEach(function(f) {
        var p = i.getElTooltip(f), y = { paths: t.paths, tooltipEl: p, tooltipY: t.tooltipY, tooltipX: t.tooltipX, elGrid: t.elGrid, hoverArea: t.hoverArea, ttItems: f.w.globals.tooltip.ttItems };
        f.w.globals.minX === i.w.globals.minX && f.w.globals.maxX === i.w.globals.maxX && f.w.globals.tooltip.seriesHoverByContext({ chartCtx: f, ttCtx: f.w.globals.tooltip, opt: y, e: n });
      }) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t, e: n }));
    } }, { key: "seriesHoverByContext", value: function(t) {
      var n = t.chartCtx, i = t.ttCtx, o = t.opt, d = t.e, f = n.w, p = this.getElTooltip();
      p && (i.tooltipRect = { x: 0, y: 0, ttWidth: p.getBoundingClientRect().width, ttHeight: p.getBoundingClientRect().height }, i.e = d, i.tooltipUtil.hasBars() && !f.globals.comboCharts && !i.isBarShared && this.tConfig.onDatasetHover.highlightDataSeries && new ot(n).toggleSeriesOnHover(d, d.target.parentNode), i.fixedTooltip && i.drawFixedTooltipRect(), f.globals.axisCharts ? i.axisChartsTooltips({ e: d, opt: o, tooltipRect: i.tooltipRect }) : i.nonAxisChartsTooltips({ e: d, opt: o, tooltipRect: i.tooltipRect }));
    } }, { key: "axisChartsTooltips", value: function(t) {
      var n, i, o = t.e, d = t.opt, f = this.w, p = d.elGrid.getBoundingClientRect(), y = o.type === "touchmove" ? o.touches[0].clientX : o.clientX, S = o.type === "touchmove" ? o.touches[0].clientY : o.clientY;
      if (this.clientY = S, this.clientX = y, f.globals.capturedSeriesIndex = -1, f.globals.capturedDataPointIndex = -1, S < p.top || S > p.top + p.height)
        this.handleMouseOut(d);
      else {
        if (Array.isArray(this.tConfig.enabledOnSeries) && !f.config.tooltip.shared) {
          var A = parseInt(d.paths.getAttribute("index"), 10);
          if (this.tConfig.enabledOnSeries.indexOf(A) < 0)
            return void this.handleMouseOut(d);
        }
        var E = this.getElTooltip(), L = this.getElXCrosshairs(), O = f.globals.xyCharts || f.config.chart.type === "bar" && !f.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || f.globals.comboCharts && this.tooltipUtil.hasBars();
        if (o.type === "mousemove" || o.type === "touchmove" || o.type === "mouseup") {
          if (f.globals.collapsedSeries.length + f.globals.ancillaryCollapsedSeries.length === f.globals.series.length)
            return;
          L !== null && L.classList.add("apexcharts-active");
          var P = this.yaxisTooltips.filter(function(V) {
            return V === !0;
          });
          if (this.ycrosshairs !== null && P.length && this.ycrosshairs.classList.add("apexcharts-active"), O && !this.showOnIntersect)
            this.handleStickyTooltip(o, y, S, d);
          else if (f.config.chart.type === "heatmap" || f.config.chart.type === "treemap") {
            var I = this.intersect.handleHeatTreeTooltip({ e: o, opt: d, x: n, y: i, type: f.config.chart.type });
            n = I.x, i = I.y, E.style.left = n + "px", E.style.top = i + "px";
          } else
            this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: o, opt: d }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({ e: o, opt: d, x: n, y: i });
          if (this.yaxisTooltips.length)
            for (var j = 0; j < f.config.yaxis.length; j++)
              this.axesTooltip.drawYaxisTooltipText(j, S, this.xyRatios);
          d.tooltipEl.classList.add("apexcharts-active");
        } else
          o.type !== "mouseout" && o.type !== "touchend" || this.handleMouseOut(d);
      }
    } }, { key: "nonAxisChartsTooltips", value: function(t) {
      var n = t.e, i = t.opt, o = t.tooltipRect, d = this.w, f = i.paths.getAttribute("rel"), p = this.getElTooltip(), y = d.globals.dom.elWrap.getBoundingClientRect();
      if (n.type === "mousemove" || n.type === "touchmove") {
        p.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: parseInt(f, 10) - 1, shared: !1 });
        var S = d.globals.clientX - y.left - o.ttWidth / 2, A = d.globals.clientY - y.top - o.ttHeight - 10;
        if (p.style.left = S + "px", p.style.top = A + "px", d.config.legend.tooltipHoverFormatter) {
          var E = f - 1, L = (0, d.config.legend.tooltipHoverFormatter)(this.legendLabels[E].getAttribute("data:default-text"), { seriesIndex: E, dataPointIndex: E, w: d });
          this.legendLabels[E].innerHTML = L;
        }
      } else
        n.type !== "mouseout" && n.type !== "touchend" || (p.classList.remove("apexcharts-active"), d.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(O) {
          var P = O.getAttribute("data:default-text");
          O.innerHTML = decodeURIComponent(P);
        }));
    } }, { key: "handleStickyTooltip", value: function(t, n, i, o) {
      var d = this.w, f = this.tooltipUtil.getNearestValues({ context: this, hoverArea: o.hoverArea, elGrid: o.elGrid, clientX: n, clientY: i }), p = f.j, y = f.capturedSeries;
      d.globals.collapsedSeriesIndices.includes(y) && (y = null);
      var S = o.elGrid.getBoundingClientRect();
      if (f.hoverX < 0 || f.hoverX > S.width)
        this.handleMouseOut(o);
      else if (y !== null)
        this.handleStickyCapturedSeries(t, y, o, p);
      else if (this.tooltipUtil.isXoverlap(p) || d.globals.isBarHorizontal) {
        var A = d.globals.series.findIndex(function(E, L) {
          return !d.globals.collapsedSeriesIndices.includes(L);
        });
        this.create(t, this, A, p, o.ttItems);
      }
    } }, { key: "handleStickyCapturedSeries", value: function(t, n, i, o) {
      var d = this.w;
      if (!this.tConfig.shared && d.globals.series[n][o] === null)
        return void this.handleMouseOut(i);
      if (d.globals.series[n][o] !== void 0)
        this.tConfig.shared && this.tooltipUtil.isXoverlap(o) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t, this, n, o, i.ttItems) : this.create(t, this, n, o, i.ttItems, !1);
      else if (this.tooltipUtil.isXoverlap(o)) {
        var f = d.globals.series.findIndex(function(p, y) {
          return !d.globals.collapsedSeriesIndices.includes(y);
        });
        this.create(t, this, f, o, i.ttItems);
      }
    } }, { key: "deactivateHoverFilter", value: function() {
      for (var t = this.w, n = new re(this.ctx), i = t.globals.dom.Paper.select(".apexcharts-bar-area"), o = 0; o < i.length; o++)
        n.pathMouseLeave(i[o]);
    } }, { key: "handleMouseOut", value: function(t) {
      var n = this.w, i = this.getElXCrosshairs();
      if (t.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), n.config.chart.type !== "bubble" && this.marker.resetPointsSize(), i !== null && i.classList.remove("apexcharts-active"), this.ycrosshairs !== null && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
        this.yaxisTTEls === null && (this.yaxisTTEls = n.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
        for (var o = 0; o < this.yaxisTTEls.length; o++)
          this.yaxisTTEls[o].classList.remove("apexcharts-active");
      }
      n.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(d) {
        var f = d.getAttribute("data:default-text");
        d.innerHTML = decodeURIComponent(f);
      });
    } }, { key: "markerClick", value: function(t, n, i) {
      var o = this.w;
      typeof o.config.chart.events.markerClick == "function" && o.config.chart.events.markerClick(t, this.ctx, { seriesIndex: n, dataPointIndex: i, w: o }), this.ctx.events.fireEvent("markerClick", [t, this.ctx, { seriesIndex: n, dataPointIndex: i, w: o }]);
    } }, { key: "create", value: function(t, n, i, o, d) {
      var f, p, y, S, A, E, L, O, P, I, j, V, Z, b, M, N, X = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, Q = this.w, ee = n;
      t.type === "mouseup" && this.markerClick(t, i, o), X === null && (X = this.tConfig.shared);
      var oe = this.tooltipUtil.hasMarkers(i), fe = this.tooltipUtil.getElBars();
      if (Q.config.legend.tooltipHoverFormatter) {
        var ke = Q.config.legend.tooltipHoverFormatter, _e = Array.from(this.legendLabels);
        _e.forEach(function(Ur) {
          var Dn = Ur.getAttribute("data:default-text");
          Ur.innerHTML = decodeURIComponent(Dn);
        });
        for (var Le = 0; Le < _e.length; Le++) {
          var Ie = _e[Le], at = parseInt(Ie.getAttribute("i"), 10), Qt = decodeURIComponent(Ie.getAttribute("data:default-text")), Kt = ke(Qt, { seriesIndex: X ? at : i, dataPointIndex: o, w: Q });
          if (X)
            Ie.innerHTML = Q.globals.collapsedSeriesIndices.indexOf(at) < 0 ? Kt : Qt;
          else if (Ie.innerHTML = at === i ? Kt : Qt, i === at)
            break;
        }
      }
      var yt = v(v({ ttItems: d, i, j: o }, ((f = Q.globals.seriesRange) === null || f === void 0 || (p = f[i]) === null || p === void 0 || (y = p[o]) === null || y === void 0 || (S = y.y[0]) === null || S === void 0 ? void 0 : S.y1) !== void 0 && { y1: (A = Q.globals.seriesRange) === null || A === void 0 || (E = A[i]) === null || E === void 0 || (L = E[o]) === null || L === void 0 || (O = L.y[0]) === null || O === void 0 ? void 0 : O.y1 }), ((P = Q.globals.seriesRange) === null || P === void 0 || (I = P[i]) === null || I === void 0 || (j = I[o]) === null || j === void 0 || (V = j.y[0]) === null || V === void 0 ? void 0 : V.y2) !== void 0 && { y2: (Z = Q.globals.seriesRange) === null || Z === void 0 || (b = Z[i]) === null || b === void 0 || (M = b[o]) === null || M === void 0 || (N = M.y[0]) === null || N === void 0 ? void 0 : N.y2 });
      if (X) {
        if (ee.tooltipLabels.drawSeriesTexts(v(v({}, yt), {}, { shared: !this.showOnIntersect && this.tConfig.shared })), oe)
          Q.globals.markers.largestSize > 0 ? ee.marker.enlargePoints(o) : ee.tooltipPosition.moveDynamicPointsOnHover(o);
        else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(fe), this.barSeriesHeight > 0)) {
          var Mn = new re(this.ctx), zn = Q.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(o, "']"));
          this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(o, i);
          for (var vt = 0; vt < zn.length; vt++)
            Mn.pathMouseEnter(zn[vt]);
        }
      } else
        ee.tooltipLabels.drawSeriesTexts(v({ shared: !1 }, yt)), this.tooltipUtil.hasBars() && ee.tooltipPosition.moveStickyTooltipOverBars(o, i), oe && ee.tooltipPosition.moveMarkers(i, o);
    } }]), B;
  }(), ii = function() {
    function B(t) {
      C(this, B), this.w = t.w, this.barCtx = t, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
    }
    return F(B, [{ key: "handleBarDataLabels", value: function(t) {
      var n = t.x, i = t.y, o = t.y1, d = t.y2, f = t.i, p = t.j, y = t.realIndex, S = t.groupIndex, A = t.series, E = t.barHeight, L = t.barWidth, O = t.barXPosition, P = t.barYPosition, I = t.visibleSeries, j = t.renderedPath, V = this.w, Z = new re(this.barCtx.ctx), b = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[y] : this.barCtx.strokeWidth, M = n + parseFloat(L * I), N = i + parseFloat(E * I);
      V.globals.isXNumeric && !V.globals.isBarHorizontal && (M = n + parseFloat(L * (I + 1)), N = i + parseFloat(E * (I + 1)) - b);
      var X, Q = null, ee = n, oe = i, fe = {}, ke = V.config.dataLabels, _e = this.barCtx.barOptions.dataLabels, Le = this.barCtx.barOptions.dataLabels.total;
      P !== void 0 && this.barCtx.isRangeBar && (N = P, oe = P), O !== void 0 && this.barCtx.isVerticalGroupedRangeBar && (M = O, ee = O);
      var Ie = ke.offsetX, at = ke.offsetY, Qt = { width: 0, height: 0 };
      if (V.config.dataLabels.enabled) {
        var Kt = this.barCtx.series[f][p];
        Qt = Z.getTextRects(V.globals.yLabelFormatters[0](Kt), parseFloat(ke.style.fontSize));
      }
      var yt = { x: n, y: i, i: f, j: p, realIndex: y, groupIndex: S || -1, renderedPath: j, bcx: M, bcy: N, barHeight: E, barWidth: L, textRects: Qt, strokeWidth: b, dataLabelsX: ee, dataLabelsY: oe, dataLabelsConfig: ke, barDataLabelsConfig: _e, barTotalDataLabelsConfig: Le, offX: Ie, offY: at };
      return fe = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(yt) : this.calculateColumnsDataLabelsPosition(yt), j.attr({ cy: fe.bcy, cx: fe.bcx, j: p, val: A[f][p], barHeight: E, barWidth: L }), X = this.drawCalculatedDataLabels({ x: fe.dataLabelsX, y: fe.dataLabelsY, val: this.barCtx.isRangeBar ? [o, d] : A[f][p], i: y, j: p, barWidth: L, barHeight: E, textRects: Qt, dataLabelsConfig: ke }), V.config.chart.stacked && Le.enabled && (Q = this.drawTotalDataLabels({ x: fe.totalDataLabelsX, y: fe.totalDataLabelsY, realIndex: y, textAnchor: fe.totalDataLabelsAnchor, val: this.getStackedTotalDataLabel({ realIndex: y, j: p }), dataLabelsConfig: ke, barTotalDataLabelsConfig: Le })), { dataLabels: X, totalDataLabels: Q };
    } }, { key: "getStackedTotalDataLabel", value: function(t) {
      var n = t.realIndex, i = t.j, o = this.w, d = this.barCtx.stackedSeriesTotals[i];
      return this.totalFormatter && (d = this.totalFormatter(d, v(v({}, o), {}, { seriesIndex: n, dataPointIndex: i, w: o }))), d;
    } }, { key: "calculateColumnsDataLabelsPosition", value: function(t) {
      var n, i, o = this.w, d = t.i, f = t.j, p = t.realIndex, y = t.groupIndex, S = t.y, A = t.bcx, E = t.barWidth, L = t.barHeight, O = t.textRects, P = t.dataLabelsX, I = t.dataLabelsY, j = t.dataLabelsConfig, V = t.barDataLabelsConfig, Z = t.barTotalDataLabelsConfig, b = t.strokeWidth, M = t.offX, N = t.offY;
      L = Math.abs(L);
      var X = o.config.plotOptions.bar.dataLabels.orientation === "vertical";
      A = A - b / 2 + (y !== -1 ? y * E : 0);
      var Q = o.globals.gridWidth / o.globals.dataPoints;
      this.barCtx.isVerticalGroupedRangeBar ? P += E / 2 : P = o.globals.isXNumeric ? A - E / 2 + M : A - Q + E / 2 + M, X && (P = P + O.height / 2 - b / 2 - 2);
      var ee = this.barCtx.series[d][f] < 0, oe = S;
      switch (this.barCtx.isReversed && (oe = S - L + (ee ? 2 * L : 0), S -= L), V.position) {
        case "center":
          I = X ? ee ? oe + L / 2 + N : oe + L / 2 - N : ee ? oe - L / 2 + O.height / 2 + N : oe + L / 2 + O.height / 2 - N;
          break;
        case "bottom":
          I = X ? ee ? oe + L + N : oe + L - N : ee ? oe - L + O.height + b + N : oe + L - O.height / 2 + b - N;
          break;
        case "top":
          I = X ? ee ? oe + N : oe - N : ee ? oe - O.height / 2 - N : oe + O.height + N;
      }
      if (this.barCtx.lastActiveBarSerieIndex === p && Z.enabled) {
        var fe = new re(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: p, j: f }), j.fontSize);
        n = ee ? oe - fe.height / 2 - N - Z.offsetY + 18 : oe + fe.height + N + Z.offsetY - 18, i = P + Z.offsetX;
      }
      return o.config.chart.stacked || (I < 0 ? I = 0 + b : I + O.height / 3 > o.globals.gridHeight && (I = o.globals.gridHeight - b)), { bcx: A, bcy: S, dataLabelsX: P, dataLabelsY: I, totalDataLabelsX: i, totalDataLabelsY: n, totalDataLabelsAnchor: "middle" };
    } }, { key: "calculateBarsDataLabelsPosition", value: function(t) {
      var n = this.w, i = t.x, o = t.i, d = t.j, f = t.realIndex, p = t.groupIndex, y = t.bcy, S = t.barHeight, A = t.barWidth, E = t.textRects, L = t.dataLabelsX, O = t.strokeWidth, P = t.dataLabelsConfig, I = t.barDataLabelsConfig, j = t.barTotalDataLabelsConfig, V = t.offX, Z = t.offY, b = n.globals.gridHeight / n.globals.dataPoints;
      A = Math.abs(A);
      var M, N, X = (y += p !== -1 ? p * S : 0) - (this.barCtx.isRangeBar ? 0 : b) + S / 2 + E.height / 2 + Z - 3, Q = "start", ee = this.barCtx.series[o][d] < 0, oe = i;
      switch (this.barCtx.isReversed && (oe = i + A - (ee ? 2 * A : 0), i = n.globals.gridWidth - A), I.position) {
        case "center":
          L = ee ? oe + A / 2 - V : Math.max(E.width / 2, oe - A / 2) + V;
          break;
        case "bottom":
          L = ee ? oe + A - O - Math.round(E.width / 2) - V : oe - A + O + Math.round(E.width / 2) + V;
          break;
        case "top":
          L = ee ? oe - O + Math.round(E.width / 2) - V : oe - O - Math.round(E.width / 2) + V;
      }
      if (this.barCtx.lastActiveBarSerieIndex === f && j.enabled) {
        var fe = new re(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: f, j: d }), P.fontSize);
        ee ? (M = oe - O + Math.round(fe.width / 2) - V - j.offsetX - 15, Q = "end") : M = oe - O - Math.round(fe.width / 2) + V + j.offsetX + 15, N = X + j.offsetY;
      }
      return n.config.chart.stacked || (L < 0 ? L = L + E.width + O : L + E.width / 2 > n.globals.gridWidth && (L = n.globals.gridWidth - E.width - O)), { bcx: i, bcy: y, dataLabelsX: L, dataLabelsY: X, totalDataLabelsX: M, totalDataLabelsY: N, totalDataLabelsAnchor: Q };
    } }, { key: "drawCalculatedDataLabels", value: function(t) {
      var n = t.x, i = t.y, o = t.val, d = t.i, f = t.j, p = t.textRects, y = t.barHeight, S = t.barWidth, A = t.dataLabelsConfig, E = this.w, L = "rotate(0)";
      E.config.plotOptions.bar.dataLabels.orientation === "vertical" && (L = "rotate(-90, ".concat(n, ", ").concat(i, ")"));
      var O = new Ht(this.barCtx.ctx), P = new re(this.barCtx.ctx), I = A.formatter, j = null, V = E.globals.collapsedSeriesIndices.indexOf(d) > -1;
      if (A.enabled && !V) {
        j = P.group({ class: "apexcharts-data-labels", transform: L });
        var Z = "";
        o !== void 0 && (Z = I(o, v(v({}, E), {}, { seriesIndex: d, dataPointIndex: f, w: E }))), !o && E.config.plotOptions.bar.hideZeroBarsWhenGrouped && (Z = "");
        var b = E.globals.series[d][f] < 0, M = E.config.plotOptions.bar.dataLabels.position;
        E.config.plotOptions.bar.dataLabels.orientation === "vertical" && (M === "top" && (A.textAnchor = b ? "end" : "start"), M === "center" && (A.textAnchor = "middle"), M === "bottom" && (A.textAnchor = b ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && S < P.getTextRects(Z, parseFloat(A.style.fontSize)).width && (Z = ""), E.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? p.width / 1.6 > Math.abs(S) && (Z = "") : p.height / 1.6 > Math.abs(y) && (Z = ""));
        var N = v({}, A);
        this.barCtx.isHorizontal && o < 0 && (A.textAnchor === "start" ? N.textAnchor = "end" : A.textAnchor === "end" && (N.textAnchor = "start")), O.plotDataLabelsText({ x: n, y: i, text: Z, i: d, j: f, parent: j, dataLabelsConfig: N, alwaysDrawDataLabel: !0, offsetCorrection: !0 });
      }
      return j;
    } }, { key: "drawTotalDataLabels", value: function(t) {
      var n, i = t.x, o = t.y, d = t.val, f = t.realIndex, p = t.textAnchor, y = t.barTotalDataLabelsConfig, S = new re(this.barCtx.ctx);
      return y.enabled && i !== void 0 && o !== void 0 && this.barCtx.lastActiveBarSerieIndex === f && (n = S.drawText({ x: i, y: o, foreColor: y.style.color, text: d, textAnchor: p, fontFamily: y.style.fontFamily, fontSize: y.style.fontSize, fontWeight: y.style.fontWeight })), n;
    } }]), B;
  }(), Ln = function() {
    function B(t) {
      C(this, B), this.w = t.w, this.barCtx = t;
    }
    return F(B, [{ key: "initVariables", value: function(t) {
      var n = this.w;
      this.barCtx.series = t, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
      for (var i = 0; i < t.length; i++)
        if (t[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t[i].length), n.globals.isXNumeric)
          for (var o = 0; o < t[i].length; o++)
            n.globals.seriesX[i][o] > n.globals.minX && n.globals.seriesX[i][o] < n.globals.maxX && this.barCtx.visibleItems++;
        else
          this.barCtx.visibleItems = n.globals.dataPoints;
      this.barCtx.seriesLen === 0 && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], n.globals.comboCharts || this.checkZeroSeries({ series: t });
    } }, { key: "initialPositions", value: function() {
      var t, n, i, o, d, f, p, y, S = this.w, A = S.globals.dataPoints;
      this.barCtx.isRangeBar && (A = S.globals.labels.length);
      var E = this.barCtx.seriesLen;
      if (S.config.plotOptions.bar.rangeBarGroupRows && (E = 1), this.barCtx.isHorizontal)
        d = (i = S.globals.gridHeight / A) / E, S.globals.isXNumeric && (d = (i = S.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), d = d * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, String(this.barCtx.barOptions.barHeight).indexOf("%") === -1 && (d = parseInt(this.barCtx.barOptions.barHeight, 10)), y = this.barCtx.baseLineInvertedY + S.globals.padHorizontal + (this.barCtx.isReversed ? S.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (y = S.globals.gridWidth / 2), n = (i - d * this.barCtx.seriesLen) / 2;
      else {
        if (o = S.globals.gridWidth / this.barCtx.visibleItems, S.config.xaxis.convertedCatToNumeric && (o = S.globals.gridWidth / S.globals.dataPoints), f = o / E * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, S.globals.isXNumeric) {
          var L = this.barCtx.xRatio;
          S.config.xaxis.convertedCatToNumeric && (L = this.barCtx.initialXRatio), S.globals.minXDiff && S.globals.minXDiff !== 0.5 && S.globals.minXDiff / L > 0 && (o = S.globals.minXDiff / L), (f = o / E * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (f = 1);
        }
        String(this.barCtx.barOptions.columnWidth).indexOf("%") === -1 && (f = parseInt(this.barCtx.barOptions.columnWidth, 10)), p = S.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? S.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), t = S.globals.padHorizontal + (o - f * this.barCtx.seriesLen) / 2;
      }
      return { x: t, y: n, yDivision: i, xDivision: o, barHeight: d, barWidth: f, zeroH: p, zeroW: y };
    } }, { key: "initializeStackedPrevVars", value: function(t) {
      var n = t.w;
      n.globals.hasSeriesGroups ? n.globals.seriesGroups.forEach(function(i) {
        t[i] || (t[i] = {}), t[i].prevY = [], t[i].prevX = [], t[i].prevYF = [], t[i].prevXF = [], t[i].prevYVal = [], t[i].prevXVal = [];
      }) : (t.prevY = [], t.prevX = [], t.prevYF = [], t.prevXF = [], t.prevYVal = [], t.prevXVal = []);
    } }, { key: "initializeStackedXYVars", value: function(t) {
      var n = t.w;
      n.globals.hasSeriesGroups ? n.globals.seriesGroups.forEach(function(i) {
        t[i] || (t[i] = {}), t[i].xArrj = [], t[i].xArrjF = [], t[i].xArrjVal = [], t[i].yArrj = [], t[i].yArrjF = [], t[i].yArrjVal = [];
      }) : (t.xArrj = [], t.xArrjF = [], t.xArrjVal = [], t.yArrj = [], t.yArrjF = [], t.yArrjVal = []);
    } }, { key: "getPathFillColor", value: function(t, n, i, o) {
      var d, f, p, y, S = this.w, A = new Qe(this.barCtx.ctx), E = null, L = this.barCtx.barOptions.distributed ? i : n;
      return this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(O) {
        t[n][i] >= O.from && t[n][i] <= O.to && (E = O.color);
      }), S.config.series[n].data[i] && S.config.series[n].data[i].fillColor && (E = S.config.series[n].data[i].fillColor), A.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? L : o, dataPointIndex: i, color: E, value: t[n][i], fillConfig: (d = S.config.series[n].data[i]) === null || d === void 0 ? void 0 : d.fill, fillType: (f = S.config.series[n].data[i]) !== null && f !== void 0 && (p = f.fill) !== null && p !== void 0 && p.type ? (y = S.config.series[n].data[i]) === null || y === void 0 ? void 0 : y.fill.type : S.config.fill.type });
    } }, { key: "getStrokeWidth", value: function(t, n, i) {
      var o = 0, d = this.w;
      return this.barCtx.series[t][n] ? this.barCtx.isNullValue = !1 : this.barCtx.isNullValue = !0, d.config.stroke.show && (this.barCtx.isNullValue || (o = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)), o;
    } }, { key: "shouldApplyRadius", value: function(t) {
      var n = this.w, i = !1;
      return n.config.plotOptions.bar.borderRadius > 0 && (n.config.chart.stacked && n.config.plotOptions.bar.borderRadiusWhenStacked === "last" ? this.barCtx.lastActiveBarSerieIndex === t && (i = !0) : i = !0), i;
    } }, { key: "barBackground", value: function(t) {
      var n = t.j, i = t.i, o = t.x1, d = t.x2, f = t.y1, p = t.y2, y = t.elSeries, S = this.w, A = new re(this.barCtx.ctx), E = new ot(this.barCtx.ctx).getActiveConfigSeriesIndex();
      if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && E === i) {
        n >= this.barCtx.barOptions.colors.backgroundBarColors.length && (n %= this.barCtx.barOptions.colors.backgroundBarColors.length);
        var L = this.barCtx.barOptions.colors.backgroundBarColors[n], O = A.drawRect(o !== void 0 ? o : 0, f !== void 0 ? f : 0, d !== void 0 ? d : S.globals.gridWidth, p !== void 0 ? p : S.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, L, this.barCtx.barOptions.colors.backgroundBarOpacity);
        y.add(O), O.node.classList.add("apexcharts-backgroundBar");
      }
    } }, { key: "getColumnPaths", value: function(t) {
      var n, i = t.barWidth, o = t.barXPosition, d = t.y1, f = t.y2, p = t.strokeWidth, y = t.seriesGroup, S = t.realIndex, A = t.i, E = t.j, L = t.w, O = new re(this.barCtx.ctx);
      (p = Array.isArray(p) ? p[S] : p) || (p = 0);
      var P = i, I = o;
      (n = L.config.series[S].data[E]) !== null && n !== void 0 && n.columnWidthOffset && (I = o - L.config.series[S].data[E].columnWidthOffset / 2, P = i + L.config.series[S].data[E].columnWidthOffset);
      var j = I, V = I + P;
      d += 1e-3, f += 1e-3;
      var Z = O.move(j, d), b = O.move(j, d), M = O.line(V - p, d);
      if (L.globals.previousPaths.length > 0 && (b = this.barCtx.getPreviousPath(S, E, !1)), Z = Z + O.line(j, f) + O.line(V - p, f) + O.line(V - p, d) + (L.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), b = b + O.line(j, d) + M + M + M + M + M + O.line(j, d) + (L.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), this.shouldApplyRadius(S) && (Z = O.roundPathCorners(Z, L.config.plotOptions.bar.borderRadius)), L.config.chart.stacked) {
        var N = this.barCtx;
        L.globals.hasSeriesGroups && y && (N = this.barCtx[y]), N.yArrj.push(f), N.yArrjF.push(Math.abs(d - f)), N.yArrjVal.push(this.barCtx.series[A][E]);
      }
      return { pathTo: Z, pathFrom: b };
    } }, { key: "getBarpaths", value: function(t) {
      var n, i = t.barYPosition, o = t.barHeight, d = t.x1, f = t.x2, p = t.strokeWidth, y = t.seriesGroup, S = t.realIndex, A = t.i, E = t.j, L = t.w, O = new re(this.barCtx.ctx);
      (p = Array.isArray(p) ? p[S] : p) || (p = 0);
      var P = i, I = o;
      (n = L.config.series[S].data[E]) !== null && n !== void 0 && n.barHeightOffset && (P = i - L.config.series[S].data[E].barHeightOffset / 2, I = o + L.config.series[S].data[E].barHeightOffset);
      var j = P, V = P + I;
      d += 1e-3, f += 1e-3;
      var Z = O.move(d, j), b = O.move(d, j);
      L.globals.previousPaths.length > 0 && (b = this.barCtx.getPreviousPath(S, E, !1));
      var M = O.line(d, V - p);
      if (Z = Z + O.line(f, j) + O.line(f, V - p) + M + (L.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), b = b + O.line(d, j) + M + M + M + M + M + O.line(d, j) + (L.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), this.shouldApplyRadius(S) && (Z = O.roundPathCorners(Z, L.config.plotOptions.bar.borderRadius)), L.config.chart.stacked) {
        var N = this.barCtx;
        L.globals.hasSeriesGroups && y && (N = this.barCtx[y]), N.xArrj.push(f), N.xArrjF.push(Math.abs(d - f)), N.xArrjVal.push(this.barCtx.series[A][E]);
      }
      return { pathTo: Z, pathFrom: b };
    } }, { key: "checkZeroSeries", value: function(t) {
      for (var n = t.series, i = this.w, o = 0; o < n.length; o++) {
        for (var d = 0, f = 0; f < n[i.globals.maxValsInArrayIndex].length; f++)
          d += n[o][f];
        d === 0 && this.barCtx.zeroSerieses.push(o);
      }
    } }, { key: "getXForValue", value: function(t, n) {
      var i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2] ? n : null;
      return t != null && (i = n + t / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t / this.barCtx.invertedYRatio : 0)), i;
    } }, { key: "getYForValue", value: function(t, n) {
      var i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2] ? n : null;
      return t != null && (i = n - t / this.barCtx.yRatio[this.barCtx.yaxisIndex] + 2 * (this.barCtx.isReversed ? t / this.barCtx.yRatio[this.barCtx.yaxisIndex] : 0)), i;
    } }, { key: "getGoalValues", value: function(t, n, i, o, d) {
      var f = this, p = this.w, y = [], S = function(L, O) {
        var P;
        y.push((Y(P = {}, t, t === "x" ? f.getXForValue(L, n, !1) : f.getYForValue(L, i, !1)), Y(P, "attrs", O), P));
      };
      if (p.globals.seriesGoals[o] && p.globals.seriesGoals[o][d] && Array.isArray(p.globals.seriesGoals[o][d]) && p.globals.seriesGoals[o][d].forEach(function(L) {
        S(L.value, L);
      }), this.barCtx.barOptions.isDumbbell && p.globals.seriesRange.length) {
        var A = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : p.globals.colors, E = { strokeHeight: t === "x" ? 0 : p.globals.markers.size[o], strokeWidth: t === "x" ? p.globals.markers.size[o] : 0, strokeDashArray: 0, strokeLineCap: "round", strokeColor: Array.isArray(A[o]) ? A[o][0] : A[o] };
        S(p.globals.seriesRangeStart[o][d], E), S(p.globals.seriesRangeEnd[o][d], v(v({}, E), {}, { strokeColor: Array.isArray(A[o]) ? A[o][1] : A[o] }));
      }
      return y;
    } }, { key: "drawGoalLine", value: function(t) {
      var n = t.barXPosition, i = t.barYPosition, o = t.goalX, d = t.goalY, f = t.barWidth, p = t.barHeight, y = new re(this.barCtx.ctx), S = y.group({ className: "apexcharts-bar-goals-groups" });
      S.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({ el: S.node }), S.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
      var A = null;
      return this.barCtx.isHorizontal ? Array.isArray(o) && o.forEach(function(E) {
        var L = E.attrs.strokeHeight !== void 0 ? E.attrs.strokeHeight : p / 2, O = i + L + p / 2;
        A = y.drawLine(E.x, O - 2 * L, E.x, O, E.attrs.strokeColor ? E.attrs.strokeColor : void 0, E.attrs.strokeDashArray, E.attrs.strokeWidth ? E.attrs.strokeWidth : 2, E.attrs.strokeLineCap), S.add(A);
      }) : Array.isArray(d) && d.forEach(function(E) {
        var L = E.attrs.strokeWidth !== void 0 ? E.attrs.strokeWidth : f / 2, O = n + L + f / 2;
        A = y.drawLine(O - 2 * L, E.y, O, E.y, E.attrs.strokeColor ? E.attrs.strokeColor : void 0, E.attrs.strokeDashArray, E.attrs.strokeHeight ? E.attrs.strokeHeight : 2, E.attrs.strokeLineCap), S.add(A);
      }), S;
    } }, { key: "drawBarShadow", value: function(t) {
      var n = t.prevPaths, i = t.currPaths, o = t.color, d = this.w, f = n.x, p = n.x1, y = n.barYPosition, S = i.x, A = i.x1, E = i.barYPosition, L = y + i.barHeight, O = new re(this.barCtx.ctx), P = new K(), I = O.move(p, L) + O.line(f, L) + O.line(S, E) + O.line(A, E) + O.line(p, L) + (d.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z");
      return O.drawPath({ d: I, fill: P.shadeColor(0.5, K.rgb2hex(o)), stroke: "none", strokeWidth: 0, fillOpacity: 1, classes: "apexcharts-bar-shadows" });
    } }]), B;
  }(), mr = function() {
    function B(t, n) {
      C(this, B), this.ctx = t, this.w = t.w;
      var i = this.w;
      this.barOptions = i.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = i.config.stroke.width, this.isNullValue = !1, this.isRangeBar = i.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !i.globals.isBarHorizontal && i.globals.seriesRange.length && i.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = n, this.xyRatios !== null && (this.xRatio = n.xRatio, this.initialXRatio = n.initialXRatio, this.yRatio = n.yRatio, this.invertedXRatio = n.invertedXRatio, this.invertedYRatio = n.invertedYRatio, this.baseLineY = n.baseLineY, this.baseLineInvertedY = n.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.pathArr = [];
      var o = new ot(this.ctx);
      this.lastActiveBarSerieIndex = o.getActiveConfigSeriesIndex("desc", ["bar", "column"]);
      var d = o.getBarSeriesIndices(), f = new ve(this.ctx);
      this.stackedSeriesTotals = f.getStackedSeriesTotals(this.w.config.series.map(function(p, y) {
        return d.indexOf(y) === -1 ? y : -1;
      }).filter(function(p) {
        return p !== -1;
      })), this.barHelpers = new Ln(this);
    }
    return F(B, [{ key: "draw", value: function(t, n) {
      var i = this.w, o = new re(this.ctx), d = new ve(this.ctx, i);
      t = d.getLogSeries(t), this.series = t, this.yRatio = d.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t);
      var f = o.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
      i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.");
      for (var p = 0, y = 0; p < t.length; p++, y++) {
        var S, A, E, L, O = void 0, P = void 0, I = [], j = [], V = i.globals.comboCharts ? n[p] : p, Z = o.group({ class: "apexcharts-series", rel: p + 1, seriesName: K.escapeString(i.globals.seriesNames[V]), "data:realIndex": V });
        this.ctx.series.addCollapsedClassToSeries(Z, V), t[p].length > 0 && (this.visibleI = this.visibleI + 1);
        var b = 0, M = 0;
        this.yRatio.length > 1 && (this.yaxisIndex = V), this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
        var N = this.barHelpers.initialPositions();
        P = N.y, b = N.barHeight, A = N.yDivision, L = N.zeroW, O = N.x, M = N.barWidth, S = N.xDivision, E = N.zeroH, this.horizontal || j.push(O + M / 2);
        var X = o.group({ class: "apexcharts-datalabels", "data:realIndex": V });
        i.globals.delayedElements.push({ el: X.node }), X.node.classList.add("apexcharts-element-hidden");
        var Q = o.group({ class: "apexcharts-bar-goals-markers" }), ee = o.group({ class: "apexcharts-bar-shadows" });
        i.globals.delayedElements.push({ el: ee.node }), ee.node.classList.add("apexcharts-element-hidden");
        for (var oe = 0; oe < i.globals.dataPoints; oe++) {
          var fe = this.barHelpers.getStrokeWidth(p, oe, V), ke = null, _e = { indexes: { i: p, j: oe, realIndex: V, bc: y }, x: O, y: P, strokeWidth: fe, elSeries: Z };
          this.isHorizontal ? (ke = this.drawBarPaths(v(v({}, _e), {}, { barHeight: b, zeroW: L, yDivision: A })), M = this.series[p][oe] / this.invertedYRatio) : (ke = this.drawColumnPaths(v(v({}, _e), {}, { xDivision: S, barWidth: M, zeroH: E })), b = this.series[p][oe] / this.yRatio[this.yaxisIndex]);
          var Le = this.barHelpers.getPathFillColor(t, p, oe, V);
          if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && oe > 0) {
            var Ie = this.barHelpers.drawBarShadow({ color: typeof Le == "string" && (Le == null ? void 0 : Le.indexOf("url")) === -1 ? Le : K.hexToRgba(i.globals.colors[p]), prevPaths: this.pathArr[this.pathArr.length - 1], currPaths: ke });
            Ie && ee.add(Ie);
          }
          this.pathArr.push(ke);
          var at = this.barHelpers.drawGoalLine({ barXPosition: ke.barXPosition, barYPosition: ke.barYPosition, goalX: ke.goalX, goalY: ke.goalY, barHeight: b, barWidth: M });
          at && Q.add(at), P = ke.y, O = ke.x, oe > 0 && j.push(O + M / 2), I.push(P), this.renderSeries({ realIndex: V, pathFill: Le, j: oe, i: p, pathFrom: ke.pathFrom, pathTo: ke.pathTo, strokeWidth: fe, elSeries: Z, x: O, y: P, series: t, barHeight: ke.barHeight ? ke.barHeight : b, barWidth: ke.barWidth ? ke.barWidth : M, elDataLabelsWrap: X, elGoalsMarkers: Q, elBarShadows: ee, visibleSeries: this.visibleI, type: "bar" });
        }
        i.globals.seriesXvalues[V] = j, i.globals.seriesYvalues[V] = I, f.add(Z);
      }
      return f;
    } }, { key: "renderSeries", value: function(t) {
      var n = t.realIndex, i = t.pathFill, o = t.lineFill, d = t.j, f = t.i, p = t.groupIndex, y = t.pathFrom, S = t.pathTo, A = t.strokeWidth, E = t.elSeries, L = t.x, O = t.y, P = t.y1, I = t.y2, j = t.series, V = t.barHeight, Z = t.barWidth, b = t.barXPosition, M = t.barYPosition, N = t.elDataLabelsWrap, X = t.elGoalsMarkers, Q = t.elBarShadows, ee = t.visibleSeries, oe = t.type, fe = this.w, ke = new re(this.ctx);
      o || (o = this.barOptions.distributed ? fe.globals.stroke.colors[d] : fe.globals.stroke.colors[n]), fe.config.series[f].data[d] && fe.config.series[f].data[d].strokeColor && (o = fe.config.series[f].data[d].strokeColor), this.isNullValue && (i = "none");
      var _e = d / fe.config.chart.animations.animateGradually.delay * (fe.config.chart.animations.speed / fe.globals.dataPoints) / 2.4, Le = ke.renderPaths({ i: f, j: d, realIndex: n, pathFrom: y, pathTo: S, stroke: o, strokeWidth: A, strokeLineCap: fe.config.stroke.lineCap, fill: i, animationDelay: _e, initialSpeed: fe.config.chart.animations.speed, dataChangeSpeed: fe.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(oe, "-area") });
      Le.attr("clip-path", "url(#gridRectMask".concat(fe.globals.cuid, ")"));
      var Ie = fe.config.forecastDataPoints;
      Ie.count > 0 && d >= fe.globals.dataPoints - Ie.count && (Le.node.setAttribute("stroke-dasharray", Ie.dashArray), Le.node.setAttribute("stroke-width", Ie.strokeWidth), Le.node.setAttribute("fill-opacity", Ie.fillOpacity)), P !== void 0 && I !== void 0 && (Le.attr("data-range-y1", P), Le.attr("data-range-y2", I)), new Re(this.ctx).setSelectionFilter(Le, n, d), E.add(Le);
      var at = new ii(this).handleBarDataLabels({ x: L, y: O, y1: P, y2: I, i: f, j: d, series: j, realIndex: n, groupIndex: p, barHeight: V, barWidth: Z, barXPosition: b, barYPosition: M, renderedPath: Le, visibleSeries: ee });
      return at.dataLabels !== null && N.add(at.dataLabels), at.totalDataLabels && N.add(at.totalDataLabels), E.add(N), X && E.add(X), Q && E.add(Q), E;
    } }, { key: "drawBarPaths", value: function(t) {
      var n, i = t.indexes, o = t.barHeight, d = t.strokeWidth, f = t.zeroW, p = t.x, y = t.y, S = t.yDivision, A = t.elSeries, E = this.w, L = i.i, O = i.j;
      if (E.globals.isXNumeric)
        n = (y = (E.globals.seriesX[L][O] - E.globals.minX) / this.invertedXRatio - o) + o * this.visibleI;
      else if (E.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
        var P = 0, I = 0;
        E.globals.seriesPercent.forEach(function(V, Z) {
          V[O] && P++, Z < L && V[O] === 0 && I++;
        }), P > 0 && (o = this.seriesLen * o / P), n = y + o * this.visibleI, n -= o * I;
      } else
        n = y + o * this.visibleI;
      this.isFunnel && (f -= (this.barHelpers.getXForValue(this.series[L][O], f) - f) / 2), p = this.barHelpers.getXForValue(this.series[L][O], f);
      var j = this.barHelpers.getBarpaths({ barYPosition: n, barHeight: o, x1: f, x2: p, strokeWidth: d, series: this.series, realIndex: i.realIndex, i: L, j: O, w: E });
      return E.globals.isXNumeric || (y += S), this.barHelpers.barBackground({ j: O, i: L, y1: n - o * this.visibleI, y2: o * this.seriesLen, elSeries: A }), { pathTo: j.pathTo, pathFrom: j.pathFrom, x1: f, x: p, y, goalX: this.barHelpers.getGoalValues("x", f, null, L, O), barYPosition: n, barHeight: o };
    } }, { key: "drawColumnPaths", value: function(t) {
      var n, i = t.indexes, o = t.x, d = t.y, f = t.xDivision, p = t.barWidth, y = t.zeroH, S = t.strokeWidth, A = t.elSeries, E = this.w, L = i.realIndex, O = i.i, P = i.j, I = i.bc;
      if (E.globals.isXNumeric) {
        var j = L;
        E.globals.seriesX[L].length || (j = E.globals.maxValsInArrayIndex), E.globals.seriesX[j][P] && (o = (E.globals.seriesX[j][P] - E.globals.minX) / this.xRatio - p * this.seriesLen / 2), n = o + p * this.visibleI;
      } else if (E.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
        var V = 0, Z = 0;
        E.globals.seriesPercent.forEach(function(M, N) {
          M[P] && V++, N < O && M[P] === 0 && Z++;
        }), V > 0 && (p = this.seriesLen * p / V), n = o + p * this.visibleI, n -= p * Z;
      } else
        n = o + p * this.visibleI;
      d = this.barHelpers.getYForValue(this.series[O][P], y);
      var b = this.barHelpers.getColumnPaths({ barXPosition: n, barWidth: p, y1: y, y2: d, strokeWidth: S, series: this.series, realIndex: i.realIndex, i: O, j: P, w: E });
      return E.globals.isXNumeric || (o += f), this.barHelpers.barBackground({ bc: I, j: P, i: O, x1: n - S / 2 - p * this.visibleI, x2: p * this.seriesLen + S / 2, elSeries: A }), { pathTo: b.pathTo, pathFrom: b.pathFrom, x: o, y: d, goalY: this.barHelpers.getGoalValues("y", null, y, O, P), barXPosition: n, barWidth: p };
    } }, { key: "getPreviousPath", value: function(t, n) {
      for (var i, o = this.w, d = 0; d < o.globals.previousPaths.length; d++) {
        var f = o.globals.previousPaths[d];
        f.paths && f.paths.length > 0 && parseInt(f.realIndex, 10) === parseInt(t, 10) && o.globals.previousPaths[d].paths[n] !== void 0 && (i = o.globals.previousPaths[d].paths[n].d);
      }
      return i;
    } }]), B;
  }(), kn = function(B) {
    U(n, mr);
    var t = se(n);
    function n() {
      return C(this, n), t.apply(this, arguments);
    }
    return F(n, [{ key: "draw", value: function(i, o) {
      var d = this, f = this.w;
      this.graphics = new re(this.ctx), this.bar = new mr(this.ctx, this.xyRatios);
      var p = new ve(this.ctx, f);
      i = p.getLogSeries(i), this.yRatio = p.getLogYRatios(this.yRatio), this.barHelpers.initVariables(i), f.config.chart.stackType === "100%" && (i = f.globals.seriesPercent.slice()), this.series = i, this.barHelpers.initializeStackedPrevVars(this);
      for (var y = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), S = 0, A = 0, E = function(P, I) {
        var j = void 0, V = void 0, Z = void 0, b = void 0, M = -1;
        d.groupCtx = d, f.globals.seriesGroups.forEach(function(zn, vt) {
          zn.indexOf(f.config.series[P].name) > -1 && (M = vt);
        }), M !== -1 && (d.groupCtx = d[f.globals.seriesGroups[M]]);
        var N = [], X = [], Q = f.globals.comboCharts ? o[P] : P;
        d.yRatio.length > 1 && (d.yaxisIndex = Q), d.isReversed = f.config.yaxis[d.yaxisIndex] && f.config.yaxis[d.yaxisIndex].reversed;
        var ee = d.graphics.group({ class: "apexcharts-series", seriesName: K.escapeString(f.globals.seriesNames[Q]), rel: P + 1, "data:realIndex": Q });
        d.ctx.series.addCollapsedClassToSeries(ee, Q);
        var oe = d.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": Q }), fe = d.graphics.group({ class: "apexcharts-bar-goals-markers" }), ke = 0, _e = 0, Le = d.initialPositions(S, A, j, V, Z, b);
        A = Le.y, ke = Le.barHeight, V = Le.yDivision, b = Le.zeroW, S = Le.x, _e = Le.barWidth, j = Le.xDivision, Z = Le.zeroH, d.barHelpers.initializeStackedXYVars(d), d.groupCtx.prevY.length === 1 && d.groupCtx.prevY[0].every(function(zn) {
          return isNaN(zn);
        }) && (d.groupCtx.prevY[0] = d.groupCtx.prevY[0].map(function(zn) {
          return Z;
        }), d.groupCtx.prevYF[0] = d.groupCtx.prevYF[0].map(function(zn) {
          return 0;
        }));
        for (var Ie = 0; Ie < f.globals.dataPoints; Ie++) {
          var at = d.barHelpers.getStrokeWidth(P, Ie, Q), Qt = { indexes: { i: P, j: Ie, realIndex: Q, bc: I }, strokeWidth: at, x: S, y: A, elSeries: ee, groupIndex: M, seriesGroup: f.globals.seriesGroups[M] }, Kt = null;
          d.isHorizontal ? (Kt = d.drawStackedBarPaths(v(v({}, Qt), {}, { zeroW: b, barHeight: ke, yDivision: V })), _e = d.series[P][Ie] / d.invertedYRatio) : (Kt = d.drawStackedColumnPaths(v(v({}, Qt), {}, { xDivision: j, barWidth: _e, zeroH: Z })), ke = d.series[P][Ie] / d.yRatio[d.yaxisIndex]);
          var yt = d.barHelpers.drawGoalLine({ barXPosition: Kt.barXPosition, barYPosition: Kt.barYPosition, goalX: Kt.goalX, goalY: Kt.goalY, barHeight: ke, barWidth: _e });
          yt && fe.add(yt), A = Kt.y, S = Kt.x, N.push(S), X.push(A);
          var Mn = d.barHelpers.getPathFillColor(i, P, Ie, Q);
          ee = d.renderSeries({ realIndex: Q, pathFill: Mn, j: Ie, i: P, groupIndex: M, pathFrom: Kt.pathFrom, pathTo: Kt.pathTo, strokeWidth: at, elSeries: ee, x: S, y: A, series: i, barHeight: ke, barWidth: _e, elDataLabelsWrap: oe, elGoalsMarkers: fe, type: "bar", visibleSeries: 0 });
        }
        f.globals.seriesXvalues[Q] = N, f.globals.seriesYvalues[Q] = X, d.groupCtx.prevY.push(d.groupCtx.yArrj), d.groupCtx.prevYF.push(d.groupCtx.yArrjF), d.groupCtx.prevYVal.push(d.groupCtx.yArrjVal), d.groupCtx.prevX.push(d.groupCtx.xArrj), d.groupCtx.prevXF.push(d.groupCtx.xArrjF), d.groupCtx.prevXVal.push(d.groupCtx.xArrjVal), y.add(ee);
      }, L = 0, O = 0; L < i.length; L++, O++)
        E(L, O);
      return y;
    } }, { key: "initialPositions", value: function(i, o, d, f, p, y) {
      var S, A, E, L, O = this.w;
      return this.isHorizontal ? (E = (E = f = O.globals.gridHeight / O.globals.dataPoints) * parseInt(O.config.plotOptions.bar.barHeight, 10) / 100, String(O.config.plotOptions.bar.barHeight).indexOf("%") === -1 && (E = parseInt(O.config.plotOptions.bar.barHeight, 10)), y = this.baseLineInvertedY + O.globals.padHorizontal + (this.isReversed ? O.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), o = (f - E) / 2) : (L = d = O.globals.gridWidth / O.globals.dataPoints, L = O.globals.isXNumeric && O.globals.dataPoints > 1 ? (d = O.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : L * parseInt(O.config.plotOptions.bar.columnWidth, 10) / 100, String(O.config.plotOptions.bar.columnWidth).indexOf("%") === -1 && (L = parseInt(O.config.plotOptions.bar.columnWidth, 10)), p = O.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? O.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), i = O.globals.padHorizontal + (d - L) / 2), { x: i, y: o, yDivision: f, xDivision: d, barHeight: (S = O.globals.seriesGroups) !== null && S !== void 0 && S.length ? E / O.globals.seriesGroups.length : E, barWidth: (A = O.globals.seriesGroups) !== null && A !== void 0 && A.length ? L / O.globals.seriesGroups.length : L, zeroH: p, zeroW: y };
    } }, { key: "drawStackedBarPaths", value: function(i) {
      for (var o, d = i.indexes, f = i.barHeight, p = i.strokeWidth, y = i.zeroW, S = i.x, A = i.y, E = i.groupIndex, L = i.seriesGroup, O = i.yDivision, P = i.elSeries, I = this.w, j = A + (E !== -1 ? E * f : 0), V = d.i, Z = d.j, b = 0, M = 0; M < this.groupCtx.prevXF.length; M++)
        b += this.groupCtx.prevXF[M][Z];
      var N = V;
      if (L && (N = L.indexOf(I.config.series[V].name)), N > 0) {
        var X = y;
        this.groupCtx.prevXVal[N - 1][Z] < 0 ? X = this.series[V][Z] >= 0 ? this.groupCtx.prevX[N - 1][Z] + b - 2 * (this.isReversed ? b : 0) : this.groupCtx.prevX[N - 1][Z] : this.groupCtx.prevXVal[N - 1][Z] >= 0 && (X = this.series[V][Z] >= 0 ? this.groupCtx.prevX[N - 1][Z] : this.groupCtx.prevX[N - 1][Z] - b + 2 * (this.isReversed ? b : 0)), o = X;
      } else
        o = y;
      S = this.series[V][Z] === null ? o : o + this.series[V][Z] / this.invertedYRatio - 2 * (this.isReversed ? this.series[V][Z] / this.invertedYRatio : 0);
      var Q = this.barHelpers.getBarpaths({ barYPosition: j, barHeight: f, x1: o, x2: S, strokeWidth: p, series: this.series, realIndex: d.realIndex, seriesGroup: L, i: V, j: Z, w: I });
      return this.barHelpers.barBackground({ j: Z, i: V, y1: j, y2: f, elSeries: P }), A += O, { pathTo: Q.pathTo, pathFrom: Q.pathFrom, goalX: this.barHelpers.getGoalValues("x", y, null, V, Z), barYPosition: j, x: S, y: A };
    } }, { key: "drawStackedColumnPaths", value: function(i) {
      var o = i.indexes, d = i.x, f = i.y, p = i.xDivision, y = i.barWidth, S = i.zeroH, A = i.groupIndex, E = i.seriesGroup, L = i.elSeries, O = this.w, P = o.i, I = o.j, j = o.bc;
      if (O.globals.isXNumeric) {
        var V = O.globals.seriesX[P][I];
        V || (V = 0), d = (V - O.globals.minX) / this.xRatio - y / 2, O.globals.seriesGroups.length && (d = (V - O.globals.minX) / this.xRatio - y / 2 * O.globals.seriesGroups.length);
      }
      for (var Z, b = d + (A !== -1 ? A * y : 0), M = 0, N = 0; N < this.groupCtx.prevYF.length; N++)
        M += isNaN(this.groupCtx.prevYF[N][I]) ? 0 : this.groupCtx.prevYF[N][I];
      var X = P;
      if (E && (X = E.indexOf(O.config.series[P].name)), X > 0 && !O.globals.isXNumeric || X > 0 && O.globals.isXNumeric && O.globals.seriesX[P - 1][I] === O.globals.seriesX[P][I]) {
        var Q, ee, oe, fe = Math.min(this.yRatio.length + 1, P + 1);
        if (this.groupCtx.prevY[X - 1] !== void 0 && this.groupCtx.prevY[X - 1].length)
          for (var ke = 1; ke < fe; ke++) {
            var _e;
            if (!isNaN((_e = this.groupCtx.prevY[X - ke]) === null || _e === void 0 ? void 0 : _e[I])) {
              oe = this.groupCtx.prevY[X - ke][I];
              break;
            }
          }
        for (var Le = 1; Le < fe; Le++) {
          var Ie, at;
          if (((Ie = this.groupCtx.prevYVal[X - Le]) === null || Ie === void 0 ? void 0 : Ie[I]) < 0) {
            ee = this.series[P][I] >= 0 ? oe - M + 2 * (this.isReversed ? M : 0) : oe;
            break;
          }
          if (((at = this.groupCtx.prevYVal[X - Le]) === null || at === void 0 ? void 0 : at[I]) >= 0) {
            ee = this.series[P][I] >= 0 ? oe : oe + M - 2 * (this.isReversed ? M : 0);
            break;
          }
        }
        ee === void 0 && (ee = O.globals.gridHeight), Z = (Q = this.groupCtx.prevYF[0]) !== null && Q !== void 0 && Q.every(function(Kt) {
          return Kt === 0;
        }) && this.groupCtx.prevYF.slice(1, X).every(function(Kt) {
          return Kt.every(function(yt) {
            return isNaN(yt);
          });
        }) ? S : ee;
      } else
        Z = S;
      f = this.series[P][I] ? Z - this.series[P][I] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[P][I] / this.yRatio[this.yaxisIndex] : 0) : Z;
      var Qt = this.barHelpers.getColumnPaths({ barXPosition: b, barWidth: y, y1: Z, y2: f, yRatio: this.yRatio[this.yaxisIndex], strokeWidth: this.strokeWidth, series: this.series, seriesGroup: E, realIndex: o.realIndex, i: P, j: I, w: O });
      return this.barHelpers.barBackground({ bc: j, j: I, i: P, x1: b, x2: y, elSeries: L }), d += p, { pathTo: Qt.pathTo, pathFrom: Qt.pathFrom, goalY: this.barHelpers.getGoalValues("y", null, S, P, I), barXPosition: b, x: O.globals.isXNumeric ? d - p : d, y: f };
    } }]), n;
  }(), Cn = function(B) {
    U(n, mr);
    var t = se(n);
    function n() {
      return C(this, n), t.apply(this, arguments);
    }
    return F(n, [{ key: "draw", value: function(i, o, d) {
      var f = this, p = this.w, y = new re(this.ctx), S = p.globals.comboCharts ? o : p.config.chart.type, A = new Qe(this.ctx);
      this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = p.config.plotOptions.bar.horizontal;
      var E = new ve(this.ctx, p);
      i = E.getLogSeries(i), this.series = i, this.yRatio = E.getLogYRatios(this.yRatio), this.barHelpers.initVariables(i);
      for (var L = y.group({ class: "apexcharts-".concat(S, "-series apexcharts-plot-series") }), O = function(I) {
        f.isBoxPlot = p.config.chart.type === "boxPlot" || p.config.series[I].type === "boxPlot";
        var j, V, Z, b, M = void 0, N = void 0, X = [], Q = [], ee = p.globals.comboCharts ? d[I] : I, oe = y.group({ class: "apexcharts-series", seriesName: K.escapeString(p.globals.seriesNames[ee]), rel: I + 1, "data:realIndex": ee });
        f.ctx.series.addCollapsedClassToSeries(oe, ee), i[I].length > 0 && (f.visibleI = f.visibleI + 1);
        var fe, ke;
        f.yRatio.length > 1 && (f.yaxisIndex = ee);
        var _e = f.barHelpers.initialPositions();
        N = _e.y, fe = _e.barHeight, V = _e.yDivision, b = _e.zeroW, M = _e.x, ke = _e.barWidth, j = _e.xDivision, Z = _e.zeroH, Q.push(M + ke / 2);
        for (var Le = y.group({ class: "apexcharts-datalabels", "data:realIndex": ee }), Ie = function(Qt) {
          var Kt = f.barHelpers.getStrokeWidth(I, Qt, ee), yt = null, Mn = { indexes: { i: I, j: Qt, realIndex: ee }, x: M, y: N, strokeWidth: Kt, elSeries: oe };
          yt = f.isHorizontal ? f.drawHorizontalBoxPaths(v(v({}, Mn), {}, { yDivision: V, barHeight: fe, zeroW: b })) : f.drawVerticalBoxPaths(v(v({}, Mn), {}, { xDivision: j, barWidth: ke, zeroH: Z })), N = yt.y, M = yt.x, Qt > 0 && Q.push(M + ke / 2), X.push(N), yt.pathTo.forEach(function(zn, vt) {
            var Ur = !f.isBoxPlot && f.candlestickOptions.wick.useFillColor ? yt.color[vt] : p.globals.stroke.colors[I], Dn = A.fillPath({ seriesNumber: ee, dataPointIndex: Qt, color: yt.color[vt], value: i[I][Qt] });
            f.renderSeries({ realIndex: ee, pathFill: Dn, lineFill: Ur, j: Qt, i: I, pathFrom: yt.pathFrom, pathTo: zn, strokeWidth: Kt, elSeries: oe, x: M, y: N, series: i, barHeight: fe, barWidth: ke, elDataLabelsWrap: Le, visibleSeries: f.visibleI, type: p.config.chart.type });
          });
        }, at = 0; at < p.globals.dataPoints; at++)
          Ie(at);
        p.globals.seriesXvalues[ee] = Q, p.globals.seriesYvalues[ee] = X, L.add(oe);
      }, P = 0; P < i.length; P++)
        O(P);
      return L;
    } }, { key: "drawVerticalBoxPaths", value: function(i) {
      var o = i.indexes, d = i.x;
      i.y;
      var f = i.xDivision, p = i.barWidth, y = i.zeroH, S = i.strokeWidth, A = this.w, E = new re(this.ctx), L = o.i, O = o.j, P = !0, I = A.config.plotOptions.candlestick.colors.upward, j = A.config.plotOptions.candlestick.colors.downward, V = "";
      this.isBoxPlot && (V = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
      var Z = this.yRatio[this.yaxisIndex], b = o.realIndex, M = this.getOHLCValue(b, O), N = y, X = y;
      M.o > M.c && (P = !1);
      var Q = Math.min(M.o, M.c), ee = Math.max(M.o, M.c), oe = M.m;
      A.globals.isXNumeric && (d = (A.globals.seriesX[b][O] - A.globals.minX) / this.xRatio - p / 2);
      var fe = d + p * this.visibleI;
      this.series[L][O] === void 0 || this.series[L][O] === null ? (Q = y, ee = y) : (Q = y - Q / Z, ee = y - ee / Z, N = y - M.h / Z, X = y - M.l / Z, oe = y - M.m / Z);
      var ke = E.move(fe, y), _e = E.move(fe + p / 2, Q);
      return A.globals.previousPaths.length > 0 && (_e = this.getPreviousPath(b, O, !0)), ke = this.isBoxPlot ? [E.move(fe, Q) + E.line(fe + p / 2, Q) + E.line(fe + p / 2, N) + E.line(fe + p / 4, N) + E.line(fe + p - p / 4, N) + E.line(fe + p / 2, N) + E.line(fe + p / 2, Q) + E.line(fe + p, Q) + E.line(fe + p, oe) + E.line(fe, oe) + E.line(fe, Q + S / 2), E.move(fe, oe) + E.line(fe + p, oe) + E.line(fe + p, ee) + E.line(fe + p / 2, ee) + E.line(fe + p / 2, X) + E.line(fe + p - p / 4, X) + E.line(fe + p / 4, X) + E.line(fe + p / 2, X) + E.line(fe + p / 2, ee) + E.line(fe, ee) + E.line(fe, oe) + "z"] : [E.move(fe, ee) + E.line(fe + p / 2, ee) + E.line(fe + p / 2, N) + E.line(fe + p / 2, ee) + E.line(fe + p, ee) + E.line(fe + p, Q) + E.line(fe + p / 2, Q) + E.line(fe + p / 2, X) + E.line(fe + p / 2, Q) + E.line(fe, Q) + E.line(fe, ee - S / 2)], _e += E.move(fe, Q), A.globals.isXNumeric || (d += f), { pathTo: ke, pathFrom: _e, x: d, y: ee, barXPosition: fe, color: this.isBoxPlot ? V : P ? [I] : [j] };
    } }, { key: "drawHorizontalBoxPaths", value: function(i) {
      var o = i.indexes;
      i.x;
      var d = i.y, f = i.yDivision, p = i.barHeight, y = i.zeroW, S = i.strokeWidth, A = this.w, E = new re(this.ctx), L = o.i, O = o.j, P = this.boxOptions.colors.lower;
      this.isBoxPlot && (P = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
      var I = this.invertedYRatio, j = o.realIndex, V = this.getOHLCValue(j, O), Z = y, b = y, M = Math.min(V.o, V.c), N = Math.max(V.o, V.c), X = V.m;
      A.globals.isXNumeric && (d = (A.globals.seriesX[j][O] - A.globals.minX) / this.invertedXRatio - p / 2);
      var Q = d + p * this.visibleI;
      this.series[L][O] === void 0 || this.series[L][O] === null ? (M = y, N = y) : (M = y + M / I, N = y + N / I, Z = y + V.h / I, b = y + V.l / I, X = y + V.m / I);
      var ee = E.move(y, Q), oe = E.move(M, Q + p / 2);
      return A.globals.previousPaths.length > 0 && (oe = this.getPreviousPath(j, O, !0)), ee = [E.move(M, Q) + E.line(M, Q + p / 2) + E.line(Z, Q + p / 2) + E.line(Z, Q + p / 2 - p / 4) + E.line(Z, Q + p / 2 + p / 4) + E.line(Z, Q + p / 2) + E.line(M, Q + p / 2) + E.line(M, Q + p) + E.line(X, Q + p) + E.line(X, Q) + E.line(M + S / 2, Q), E.move(X, Q) + E.line(X, Q + p) + E.line(N, Q + p) + E.line(N, Q + p / 2) + E.line(b, Q + p / 2) + E.line(b, Q + p - p / 4) + E.line(b, Q + p / 4) + E.line(b, Q + p / 2) + E.line(N, Q + p / 2) + E.line(N, Q) + E.line(X, Q) + "z"], oe += E.move(M, Q), A.globals.isXNumeric || (d += f), { pathTo: ee, pathFrom: oe, x: N, y: d, barYPosition: Q, color: P };
    } }, { key: "getOHLCValue", value: function(i, o) {
      var d = this.w;
      return { o: this.isBoxPlot ? d.globals.seriesCandleH[i][o] : d.globals.seriesCandleO[i][o], h: this.isBoxPlot ? d.globals.seriesCandleO[i][o] : d.globals.seriesCandleH[i][o], m: d.globals.seriesCandleM[i][o], l: this.isBoxPlot ? d.globals.seriesCandleC[i][o] : d.globals.seriesCandleL[i][o], c: this.isBoxPlot ? d.globals.seriesCandleL[i][o] : d.globals.seriesCandleC[i][o] };
    } }]), n;
  }(), cs = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "checkColorRange", value: function() {
      var t = this.w, n = !1, i = t.config.plotOptions[t.config.chart.type];
      return i.colorScale.ranges.length > 0 && i.colorScale.ranges.map(function(o, d) {
        o.from <= 0 && (n = !0);
      }), n;
    } }, { key: "getShadeColor", value: function(t, n, i, o) {
      var d = this.w, f = 1, p = d.config.plotOptions[t].shadeIntensity, y = this.determineColor(t, n, i);
      d.globals.hasNegs || o ? f = d.config.plotOptions[t].reverseNegativeShade ? y.percent < 0 ? y.percent / 100 * (1.25 * p) : (1 - y.percent / 100) * (1.25 * p) : y.percent <= 0 ? 1 - (1 + y.percent / 100) * p : (1 - y.percent / 100) * p : (f = 1 - y.percent / 100, t === "treemap" && (f = (1 - y.percent / 100) * (1.25 * p)));
      var S = y.color, A = new K();
      return d.config.plotOptions[t].enableShades && (S = this.w.config.theme.mode === "dark" ? K.hexToRgba(A.shadeColor(-1 * f, y.color), d.config.fill.opacity) : K.hexToRgba(A.shadeColor(f, y.color), d.config.fill.opacity)), { color: S, colorProps: y };
    } }, { key: "determineColor", value: function(t, n, i) {
      var o = this.w, d = o.globals.series[n][i], f = o.config.plotOptions[t], p = f.colorScale.inverse ? i : n;
      f.distributed && o.config.chart.type === "treemap" && (p = i);
      var y = o.globals.colors[p], S = null, A = Math.min.apply(Math, ue(o.globals.series[n])), E = Math.max.apply(Math, ue(o.globals.series[n]));
      f.distributed || t !== "heatmap" || (A = o.globals.minY, E = o.globals.maxY), f.colorScale.min !== void 0 && (A = f.colorScale.min < o.globals.minY ? f.colorScale.min : o.globals.minY, E = f.colorScale.max > o.globals.maxY ? f.colorScale.max : o.globals.maxY);
      var L = Math.abs(E) + Math.abs(A), O = 100 * d / (L === 0 ? L - 1e-6 : L);
      return f.colorScale.ranges.length > 0 && f.colorScale.ranges.map(function(P, I) {
        if (d >= P.from && d <= P.to) {
          y = P.color, S = P.foreColor ? P.foreColor : null, A = P.from, E = P.to;
          var j = Math.abs(E) + Math.abs(A);
          O = 100 * d / (j === 0 ? j - 1e-6 : j);
        }
      }), { color: y, foreColor: S, percent: O };
    } }, { key: "calculateDataLabels", value: function(t) {
      var n = t.text, i = t.x, o = t.y, d = t.i, f = t.j, p = t.colorProps, y = t.fontSize, S = this.w.config.dataLabels, A = new re(this.ctx), E = new Ht(this.ctx), L = null;
      if (S.enabled) {
        L = A.group({ class: "apexcharts-data-labels" });
        var O = S.offsetX, P = S.offsetY, I = i + O, j = o + parseFloat(S.style.fontSize) / 3 + P;
        E.plotDataLabelsText({ x: I, y: j, text: n, i: d, j: f, color: p.foreColor, parent: L, fontSize: y, dataLabelsConfig: S });
      }
      return L;
    } }, { key: "addListeners", value: function(t) {
      var n = new re(this.ctx);
      t.node.addEventListener("mouseenter", n.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", n.pathMouseLeave.bind(this, t)), t.node.addEventListener("mousedown", n.pathMouseDown.bind(this, t));
    } }]), B;
  }(), ds = function() {
    function B(t, n) {
      C(this, B), this.ctx = t, this.w = t.w, this.xRatio = n.xRatio, this.yRatio = n.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new cs(t), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
    }
    return F(B, [{ key: "draw", value: function(t) {
      var n = this.w, i = new re(this.ctx), o = i.group({ class: "apexcharts-heatmap" });
      o.attr("clip-path", "url(#gridRectMask".concat(n.globals.cuid, ")"));
      var d = n.globals.gridWidth / n.globals.dataPoints, f = n.globals.gridHeight / n.globals.series.length, p = 0, y = !1;
      this.negRange = this.helpers.checkColorRange();
      var S = t.slice();
      n.config.yaxis[0].reversed && (y = !0, S.reverse());
      for (var A = y ? 0 : S.length - 1; y ? A < S.length : A >= 0; y ? A++ : A--) {
        var E = i.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: K.escapeString(n.globals.seriesNames[A]), rel: A + 1, "data:realIndex": A });
        if (this.ctx.series.addCollapsedClassToSeries(E, A), n.config.chart.dropShadow.enabled) {
          var L = n.config.chart.dropShadow;
          new Re(this.ctx).dropShadow(E, L, A);
        }
        for (var O = 0, P = n.config.plotOptions.heatmap.shadeIntensity, I = 0; I < S[A].length; I++) {
          var j = this.helpers.getShadeColor(n.config.chart.type, A, I, this.negRange), V = j.color, Z = j.colorProps;
          n.config.fill.type === "image" && (V = new Qe(this.ctx).fillPath({ seriesNumber: A, dataPointIndex: I, opacity: n.globals.hasNegs ? Z.percent < 0 ? 1 - (1 + Z.percent / 100) : P + Z.percent / 100 : Z.percent / 100, patternID: K.randomId(), width: n.config.fill.image.width ? n.config.fill.image.width : d, height: n.config.fill.image.height ? n.config.fill.image.height : f }));
          var b = this.rectRadius, M = i.drawRect(O, p, d, f, b);
          if (M.attr({ cx: O, cy: p }), M.node.classList.add("apexcharts-heatmap-rect"), E.add(M), M.attr({ fill: V, i: A, index: A, j: I, val: S[A][I], "stroke-width": this.strokeWidth, stroke: n.config.plotOptions.heatmap.useFillColorAsStroke ? V : n.globals.stroke.colors[0], color: V }), this.helpers.addListeners(M), n.config.chart.animations.enabled && !n.globals.dataChanged) {
            var N = 1;
            n.globals.resized || (N = n.config.chart.animations.speed), this.animateHeatMap(M, O, p, d, f, N);
          }
          if (n.globals.dataChanged) {
            var X = 1;
            if (this.dynamicAnim.enabled && n.globals.shouldAnimate) {
              X = this.dynamicAnim.speed;
              var Q = n.globals.previousPaths[A] && n.globals.previousPaths[A][I] && n.globals.previousPaths[A][I].color;
              Q || (Q = "rgba(255, 255, 255, 0)"), this.animateHeatColor(M, K.isColorHex(Q) ? Q : K.rgb2hex(Q), K.isColorHex(V) ? V : K.rgb2hex(V), X);
            }
          }
          var ee = (0, n.config.dataLabels.formatter)(n.globals.series[A][I], { value: n.globals.series[A][I], seriesIndex: A, dataPointIndex: I, w: n }), oe = this.helpers.calculateDataLabels({ text: ee, x: O + d / 2, y: p + f / 2, i: A, j: I, colorProps: Z, series: S });
          oe !== null && E.add(oe), O += d;
        }
        p += f, o.add(E);
      }
      var fe = n.globals.yAxisScale[0].result.slice();
      n.config.yaxis[0].reversed ? fe.unshift("") : fe.push(""), n.globals.yAxisScale[0].result = fe;
      var ke = n.globals.gridHeight / n.globals.series.length;
      return n.config.yaxis[0].labels.offsetY = -ke / 2, o;
    } }, { key: "animateHeatMap", value: function(t, n, i, o, d, f) {
      var p = new we(this.ctx);
      p.animateRect(t, { x: n + o / 2, y: i + d / 2, width: 0, height: 0 }, { x: n, y: i, width: o, height: d }, f, function() {
        p.animationCompleted(t);
      });
    } }, { key: "animateHeatColor", value: function(t, n, i, o) {
      t.attr({ fill: n }).animate(o).attr({ fill: i });
    } }]), B;
  }(), fs = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "drawYAxisTexts", value: function(t, n, i, o) {
      var d = this.w, f = d.config.yaxis[0], p = d.globals.yLabelFormatters[0];
      return new re(this.ctx).drawText({ x: t + f.labels.offsetX, y: n + f.labels.offsetY, text: p(o, i), textAnchor: "middle", fontSize: f.labels.style.fontSize, fontFamily: f.labels.style.fontFamily, foreColor: Array.isArray(f.labels.style.colors) ? f.labels.style.colors[i] : f.labels.style.colors });
    } }]), B;
  }(), Vs = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
      var n = this.w;
      this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = n.globals.stroke.colors !== void 0 ? n.globals.stroke.colors : n.globals.colors, this.defaultSize = Math.min(n.globals.gridWidth, n.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = n.globals.gridWidth / 2, n.config.chart.type === "radialBar" ? this.fullAngle = 360 : this.fullAngle = Math.abs(n.config.plotOptions.pie.endAngle - n.config.plotOptions.pie.startAngle), this.initialAngle = n.config.plotOptions.pie.startAngle % this.fullAngle, n.globals.radialSize = this.defaultSize / 2.05 - n.config.stroke.width - (n.config.chart.sparkline.enabled ? 0 : n.config.chart.dropShadow.blur), this.donutSize = n.globals.radialSize * parseInt(n.config.plotOptions.pie.donut.size, 10) / 100, this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
    }
    return F(B, [{ key: "draw", value: function(t) {
      var n = this, i = this.w, o = new re(this.ctx);
      if (this.ret = o.group({ class: "apexcharts-pie" }), i.globals.noData)
        return this.ret;
      for (var d = 0, f = 0; f < t.length; f++)
        d += K.negToZero(t[f]);
      var p = [], y = o.group();
      d === 0 && (d = 1e-5), t.forEach(function(Q) {
        n.maxY = Math.max(n.maxY, Q);
      }), i.config.yaxis[0].max && (this.maxY = i.config.yaxis[0].max), i.config.grid.position === "back" && this.chartType === "polarArea" && this.drawPolarElements(this.ret);
      for (var S = 0; S < t.length; S++) {
        var A = this.fullAngle * K.negToZero(t[S]) / d;
        p.push(A), this.chartType === "polarArea" ? (p[S] = this.fullAngle / t.length, this.sliceSizes.push(i.globals.radialSize * t[S] / this.maxY)) : this.sliceSizes.push(i.globals.radialSize);
      }
      if (i.globals.dataChanged) {
        for (var E, L = 0, O = 0; O < i.globals.previousPaths.length; O++)
          L += K.negToZero(i.globals.previousPaths[O]);
        for (var P = 0; P < i.globals.previousPaths.length; P++)
          E = this.fullAngle * K.negToZero(i.globals.previousPaths[P]) / L, this.prevSectorAngleArr.push(E);
      }
      this.donutSize < 0 && (this.donutSize = 0);
      var I = i.config.plotOptions.pie.customScale, j = i.globals.gridWidth / 2, V = i.globals.gridHeight / 2, Z = j - i.globals.gridWidth / 2 * I, b = V - i.globals.gridHeight / 2 * I;
      if (this.chartType === "donut") {
        var M = o.drawCircle(this.donutSize);
        M.attr({ cx: this.centerX, cy: this.centerY, fill: i.config.plotOptions.pie.donut.background ? i.config.plotOptions.pie.donut.background : "transparent" }), y.add(M);
      }
      var N = this.drawArcs(p, t);
      if (this.sliceLabels.forEach(function(Q) {
        N.add(Q);
      }), y.attr({ transform: "translate(".concat(Z, ", ").concat(b, ") scale(").concat(I, ")") }), y.add(N), this.ret.add(y), this.donutDataLabels.show) {
        var X = this.renderInnerDataLabels(this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show, translateX: Z, translateY: b });
        this.ret.add(X);
      }
      return i.config.grid.position === "front" && this.chartType === "polarArea" && this.drawPolarElements(this.ret), this.ret;
    } }, { key: "drawArcs", value: function(t, n) {
      var i = this.w, o = new Re(this.ctx), d = new re(this.ctx), f = new Qe(this.ctx), p = d.group({ class: "apexcharts-slices" }), y = this.initialAngle, S = this.initialAngle, A = this.initialAngle, E = this.initialAngle;
      this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;
      for (var L = 0; L < t.length; L++) {
        var O = d.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: K.escapeString(i.globals.seriesNames[L]), rel: L + 1, "data:realIndex": L });
        p.add(O), S = E, A = (y = A) + t[L], E = S + this.prevSectorAngleArr[L];
        var P = A < y ? this.fullAngle + A - y : A - y, I = f.fillPath({ seriesNumber: L, size: this.sliceSizes[L], value: n[L] }), j = this.getChangedPath(S, E), V = d.drawPath({ d: j, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[L] : this.lineColorArr, strokeWidth: 0, fill: I, fillOpacity: i.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(L) });
        if (V.attr({ index: 0, j: L }), o.setSelectionFilter(V, 0, L), i.config.chart.dropShadow.enabled) {
          var Z = i.config.chart.dropShadow;
          o.dropShadow(V, Z, L);
        }
        this.addListeners(V, this.donutDataLabels), re.setAttrs(V.node, { "data:angle": P, "data:startAngle": y, "data:strokeWidth": this.strokeWidth, "data:value": n[L] });
        var b = { x: 0, y: 0 };
        this.chartType === "pie" || this.chartType === "polarArea" ? b = K.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, (y + P / 2) % this.fullAngle) : this.chartType === "donut" && (b = K.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, (y + P / 2) % this.fullAngle)), O.add(V);
        var M = 0;
        if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : ((M = P / this.fullAngle * i.config.chart.animations.speed) === 0 && (M = 1), this.animDur = M + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i.globals.dataChanged ? this.animatePaths(V, { size: this.sliceSizes[L], endAngle: A, startAngle: y, prevStartAngle: S, prevEndAngle: E, animateStartingPos: !0, i: L, animBeginArr: this.animBeginArr, shouldSetPrevPaths: !0, dur: i.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(V, { size: this.sliceSizes[L], endAngle: A, startAngle: y, i: L, totalItems: t.length - 1, animBeginArr: this.animBeginArr, dur: M }), i.config.plotOptions.pie.expandOnClick && this.chartType !== "polarArea" && V.click(this.pieClicked.bind(this, L)), i.globals.selectedDataPoints[0] !== void 0 && i.globals.selectedDataPoints[0].indexOf(L) > -1 && this.pieClicked(L), i.config.dataLabels.enabled) {
          var N = b.x, X = b.y, Q = 100 * P / this.fullAngle + "%";
          if (P !== 0 && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t[L]) {
            var ee = i.config.dataLabels.formatter;
            ee !== void 0 && (Q = ee(i.globals.seriesPercent[L][0], { seriesIndex: L, w: i }));
            var oe = i.globals.dataLabels.style.colors[L], fe = d.group({ class: "apexcharts-datalabels" }), ke = d.drawText({ x: N, y: X, text: Q, textAnchor: "middle", fontSize: i.config.dataLabels.style.fontSize, fontFamily: i.config.dataLabels.style.fontFamily, fontWeight: i.config.dataLabels.style.fontWeight, foreColor: oe });
            if (fe.add(ke), i.config.dataLabels.dropShadow.enabled) {
              var _e = i.config.dataLabels.dropShadow;
              o.dropShadow(ke, _e);
            }
            ke.node.classList.add("apexcharts-pie-label"), i.config.chart.animations.animate && i.globals.resized === !1 && (ke.node.classList.add("apexcharts-pie-label-delay"), ke.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(fe);
          }
        }
      }
      return p;
    } }, { key: "addListeners", value: function(t, n) {
      var i = new re(this.ctx);
      t.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, t)), t.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t.node, n)), t.node.addEventListener("mousedown", i.pathMouseDown.bind(this, t)), this.donutDataLabels.total.showAlways || (t.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t.node, n)), t.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t.node, n)));
    } }, { key: "animatePaths", value: function(t, n) {
      var i = this.w, o = n.endAngle < n.startAngle ? this.fullAngle + n.endAngle - n.startAngle : n.endAngle - n.startAngle, d = o, f = n.startAngle, p = n.startAngle;
      n.prevStartAngle !== void 0 && n.prevEndAngle !== void 0 && (f = n.prevEndAngle, d = n.prevEndAngle < n.prevStartAngle ? this.fullAngle + n.prevEndAngle - n.prevStartAngle : n.prevEndAngle - n.prevStartAngle), n.i === i.config.series.length - 1 && (o + p > this.fullAngle ? n.endAngle = n.endAngle - (o + p) : o + p < this.fullAngle && (n.endAngle = n.endAngle + (this.fullAngle - (o + p)))), o === this.fullAngle && (o = this.fullAngle - 0.01), this.animateArc(t, f, p, o, d, n);
    } }, { key: "animateArc", value: function(t, n, i, o, d, f) {
      var p, y = this, S = this.w, A = new we(this.ctx), E = f.size;
      (isNaN(n) || isNaN(d)) && (n = i, d = o, f.dur = 0);
      var L = o, O = i, P = n < i ? this.fullAngle + n - i : n - i;
      S.globals.dataChanged && f.shouldSetPrevPaths && f.prevEndAngle && (p = y.getPiePath({ me: y, startAngle: f.prevStartAngle, angle: f.prevEndAngle < f.prevStartAngle ? this.fullAngle + f.prevEndAngle - f.prevStartAngle : f.prevEndAngle - f.prevStartAngle, size: E }), t.attr({ d: p })), f.dur !== 0 ? t.animate(f.dur, S.globals.easing, f.animBeginArr[f.i]).afterAll(function() {
        y.chartType !== "pie" && y.chartType !== "donut" && y.chartType !== "polarArea" || this.animate(S.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": y.strokeWidth }), f.i === S.config.series.length - 1 && A.animationCompleted(t);
      }).during(function(I) {
        L = P + (o - P) * I, f.animateStartingPos && (L = d + (o - d) * I, O = n - d + (i - (n - d)) * I), p = y.getPiePath({ me: y, startAngle: O, angle: L, size: E }), t.node.setAttribute("data:pathOrig", p), t.attr({ d: p });
      }) : (p = y.getPiePath({ me: y, startAngle: O, angle: o, size: E }), f.isTrack || (S.globals.animationEnded = !0), t.node.setAttribute("data:pathOrig", p), t.attr({ d: p, "stroke-width": y.strokeWidth }));
    } }, { key: "pieClicked", value: function(t) {
      var n, i = this.w, o = this, d = o.sliceSizes[t] + (i.config.plotOptions.pie.expandOnClick ? 4 : 0), f = i.globals.dom.Paper.select(".apexcharts-".concat(o.chartType.toLowerCase(), "-slice-").concat(t)).members[0];
      if (f.attr("data:pieClicked") !== "true") {
        var p = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
        Array.prototype.forEach.call(p, function(E) {
          E.setAttribute("data:pieClicked", "false");
          var L = E.getAttribute("data:pathOrig");
          L && E.setAttribute("d", L);
        }), f.attr("data:pieClicked", "true");
        var y = parseInt(f.attr("data:startAngle"), 10), S = parseInt(f.attr("data:angle"), 10);
        n = o.getPiePath({ me: o, startAngle: y, angle: S, size: d }), S !== 360 && f.plot(n);
      } else {
        f.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(f.node, this.donutDataLabels);
        var A = f.attr("data:pathOrig");
        f.attr({ d: A });
      }
    } }, { key: "getChangedPath", value: function(t, n) {
      var i = "";
      return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({ me: this, startAngle: t, angle: n - t, size: this.size })), i;
    } }, { key: "getPiePath", value: function(t) {
      var n = t.me, i = t.startAngle, o = t.angle, d = t.size, f = i, p = Math.PI * (f - 90) / 180, y = o + i;
      Math.ceil(y) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (y = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(y) > this.fullAngle && (y -= this.fullAngle);
      var S = Math.PI * (y - 90) / 180, A = n.centerX + d * Math.cos(p), E = n.centerY + d * Math.sin(p), L = n.centerX + d * Math.cos(S), O = n.centerY + d * Math.sin(S), P = K.polarToCartesian(n.centerX, n.centerY, n.donutSize, y), I = K.polarToCartesian(n.centerX, n.centerY, n.donutSize, f), j = o > 180 ? 1 : 0, V = ["M", A, E, "A", d, d, 0, j, 1, L, O];
      return n.chartType === "donut" ? [].concat(V, ["L", P.x, P.y, "A", n.donutSize, n.donutSize, 0, j, 0, I.x, I.y, "L", A, E, "z"]).join(" ") : n.chartType === "pie" || n.chartType === "polarArea" ? [].concat(V, ["L", n.centerX, n.centerY, "L", A, E]).join(" ") : [].concat(V).join(" ");
    } }, { key: "drawPolarElements", value: function(t) {
      var n = this.w, i = new qe(this.ctx), o = new re(this.ctx), d = new fs(this.ctx), f = o.group(), p = o.group(), y = i.niceScale(0, Math.ceil(this.maxY), n.config.yaxis[0].tickAmount, 0, !0), S = y.result.reverse(), A = y.result.length;
      this.maxY = y.niceMax;
      for (var E = n.globals.radialSize, L = E / (A - 1), O = 0; O < A - 1; O++) {
        var P = o.drawCircle(E);
        if (P.attr({ cx: this.centerX, cy: this.centerY, fill: "none", "stroke-width": n.config.plotOptions.polarArea.rings.strokeWidth, stroke: n.config.plotOptions.polarArea.rings.strokeColor }), n.config.yaxis[0].show) {
          var I = d.drawYAxisTexts(this.centerX, this.centerY - E + parseInt(n.config.yaxis[0].labels.style.fontSize, 10) / 2, O, S[O]);
          p.add(I);
        }
        f.add(P), E -= L;
      }
      this.drawSpokes(t), t.add(f), t.add(p);
    } }, { key: "renderInnerDataLabels", value: function(t, n) {
      var i = this.w, o = new re(this.ctx), d = o.group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(n.translateX ? n.translateX : 0, ", ").concat(n.translateY ? n.translateY : 0, ") scale(").concat(i.config.plotOptions.pie.customScale, ")") }), f = t.total.show;
      d.node.style.opacity = n.opacity;
      var p, y, S = n.centerX, A = n.centerY;
      p = t.name.color === void 0 ? i.globals.colors[0] : t.name.color;
      var E = t.name.fontSize, L = t.name.fontFamily, O = t.name.fontWeight;
      y = t.value.color === void 0 ? i.config.chart.foreColor : t.value.color;
      var P = t.value.formatter, I = "", j = "";
      if (f ? (p = t.total.color, E = t.total.fontSize, L = t.total.fontFamily, O = t.total.fontWeight, j = t.total.label, I = t.total.formatter(i)) : i.globals.series.length === 1 && (I = P(i.globals.series[0], i), j = i.globals.seriesNames[0]), j && (j = t.name.formatter(j, t.total.show, i)), t.name.show) {
        var V = o.drawText({ x: S, y: A + parseFloat(t.name.offsetY), text: j, textAnchor: "middle", foreColor: p, fontSize: E, fontWeight: O, fontFamily: L });
        V.node.classList.add("apexcharts-datalabel-label"), d.add(V);
      }
      if (t.value.show) {
        var Z = t.name.show ? parseFloat(t.value.offsetY) + 16 : t.value.offsetY, b = o.drawText({ x: S, y: A + Z, text: I, textAnchor: "middle", foreColor: y, fontWeight: t.value.fontWeight, fontSize: t.value.fontSize, fontFamily: t.value.fontFamily });
        b.node.classList.add("apexcharts-datalabel-value"), d.add(b);
      }
      return d;
    } }, { key: "printInnerLabels", value: function(t, n, i, o) {
      var d, f = this.w;
      o ? d = t.name.color === void 0 ? f.globals.colors[parseInt(o.parentNode.getAttribute("rel"), 10) - 1] : t.name.color : f.globals.series.length > 1 && t.total.show && (d = t.total.color);
      var p = f.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), y = f.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
      i = (0, t.value.formatter)(i, f), o || typeof t.total.formatter != "function" || (i = t.total.formatter(f));
      var S = n === t.total.label;
      n = t.name.formatter(n, S, f), p !== null && (p.textContent = n), y !== null && (y.textContent = i), p !== null && (p.style.fill = d);
    } }, { key: "printDataLabelsInner", value: function(t, n) {
      var i = this.w, o = t.getAttribute("data:value"), d = i.globals.seriesNames[parseInt(t.parentNode.getAttribute("rel"), 10) - 1];
      i.globals.series.length > 1 && this.printInnerLabels(n, d, o, t);
      var f = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
      f !== null && (f.style.opacity = 1);
    } }, { key: "drawSpokes", value: function(t) {
      var n = this, i = this.w, o = new re(this.ctx), d = i.config.plotOptions.polarArea.spokes;
      if (d.strokeWidth !== 0) {
        for (var f = [], p = 360 / i.globals.series.length, y = 0; y < i.globals.series.length; y++)
          f.push(K.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize, i.config.plotOptions.pie.startAngle + p * y));
        f.forEach(function(S, A) {
          var E = o.drawLine(S.x, S.y, n.centerX, n.centerY, Array.isArray(d.connectorColors) ? d.connectorColors[A] : d.connectorColors);
          t.add(E);
        });
      }
    } }, { key: "revertDataLabelsInner", value: function(t, n, i) {
      var o = this, d = this.w, f = d.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"), p = !1, y = d.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"), S = function(L) {
        var O = L.makeSliceOut, P = L.printLabel;
        Array.prototype.forEach.call(y, function(I) {
          I.getAttribute("data:pieClicked") === "true" && (O && (p = !0), P && o.printDataLabelsInner(I, n));
        });
      };
      if (S({ makeSliceOut: !0, printLabel: !1 }), n.total.show && d.globals.series.length > 1)
        p && !n.total.showAlways ? S({ makeSliceOut: !1, printLabel: !0 }) : this.printInnerLabels(n, n.total.label, n.total.formatter(d));
      else if (S({ makeSliceOut: !1, printLabel: !0 }), !p)
        if (d.globals.selectedDataPoints.length && d.globals.series.length > 1)
          if (d.globals.selectedDataPoints[0].length > 0) {
            var A = d.globals.selectedDataPoints[0], E = d.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(A));
            this.printDataLabelsInner(E, n);
          } else
            f && d.globals.selectedDataPoints.length && d.globals.selectedDataPoints[0].length === 0 && (f.style.opacity = 0);
        else
          f && d.globals.series.length > 1 && (f.style.opacity = 0);
    } }]), B;
  }(), Ml = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
      var n = this.w;
      this.graphics = new re(this.ctx), this.lineColorArr = n.globals.stroke.colors !== void 0 ? n.globals.stroke.colors : n.globals.colors, this.defaultSize = n.globals.svgHeight < n.globals.svgWidth ? n.globals.gridHeight + 1.5 * n.globals.goldenPadding : n.globals.gridWidth, this.isLog = n.config.yaxis[0].logarithmic, this.coreUtils = new ve(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(n.globals.maxY, 0) : n.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : n.globals.minY, this.polygons = n.config.plotOptions.radar.polygons, this.strokeWidth = n.config.stroke.show ? n.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - n.config.chart.dropShadow.blur, n.config.xaxis.labels.show && (this.size = this.size - n.globals.xAxisLabelsWidth / 1.75), n.config.plotOptions.radar.size !== void 0 && (this.size = n.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
    }
    return F(B, [{ key: "draw", value: function(t) {
      var n = this, i = this.w, o = new Qe(this.ctx), d = [], f = new Ht(this.ctx);
      t.length && (this.dataPointsLen = t[i.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
      var p = i.globals.gridWidth / 2, y = i.globals.gridHeight / 2, S = p + i.config.plotOptions.radar.offsetX, A = y + i.config.plotOptions.radar.offsetY, E = this.graphics.group({ class: "apexcharts-radar-series apexcharts-plot-series", transform: "translate(".concat(S || 0, ", ").concat(A || 0, ")") }), L = [], O = null, P = null;
      if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), t.forEach(function(j, V) {
        var Z = j.length === i.globals.dataPoints, b = n.graphics.group().attr({ class: "apexcharts-series", "data:longestSeries": Z, seriesName: K.escapeString(i.globals.seriesNames[V]), rel: V + 1, "data:realIndex": V });
        n.dataRadiusOfPercent[V] = [], n.dataRadius[V] = [], n.angleArr[V] = [], j.forEach(function(Le, Ie) {
          var at = Math.abs(n.maxValue - n.minValue);
          Le += Math.abs(n.minValue), n.isLog && (Le = n.coreUtils.getLogVal(Le, 0)), n.dataRadiusOfPercent[V][Ie] = Le / at, n.dataRadius[V][Ie] = n.dataRadiusOfPercent[V][Ie] * n.size, n.angleArr[V][Ie] = Ie * n.disAngle;
        }), L = n.getDataPointsPos(n.dataRadius[V], n.angleArr[V]);
        var M = n.createPaths(L, { x: 0, y: 0 });
        O = n.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), P = n.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": V }), i.globals.delayedElements.push({ el: O.node, index: V });
        var N = { i: V, realIndex: V, animationDelay: V, initialSpeed: i.config.chart.animations.speed, dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: !1, bindEventsOnPaths: !1, stroke: i.globals.stroke.colors[V], strokeLineCap: i.config.stroke.lineCap }, X = null;
        i.globals.previousPaths.length > 0 && (X = n.getPreviousPath(V));
        for (var Q = 0; Q < M.linePathsTo.length; Q++) {
          var ee = n.graphics.renderPaths(v(v({}, N), {}, { pathFrom: X === null ? M.linePathsFrom[Q] : X, pathTo: M.linePathsTo[Q], strokeWidth: Array.isArray(n.strokeWidth) ? n.strokeWidth[V] : n.strokeWidth, fill: "none", drawShadow: !1 }));
          b.add(ee);
          var oe = o.fillPath({ seriesNumber: V }), fe = n.graphics.renderPaths(v(v({}, N), {}, { pathFrom: X === null ? M.areaPathsFrom[Q] : X, pathTo: M.areaPathsTo[Q], strokeWidth: 0, fill: oe, drawShadow: !1 }));
          if (i.config.chart.dropShadow.enabled) {
            var ke = new Re(n.ctx), _e = i.config.chart.dropShadow;
            ke.dropShadow(fe, Object.assign({}, _e, { noUserSpaceOnUse: !0 }), V);
          }
          b.add(fe);
        }
        j.forEach(function(Le, Ie) {
          var at = new St(n.ctx).getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: V, dataPointIndex: Ie }), Qt = n.graphics.drawMarker(L[Ie].x, L[Ie].y, at);
          Qt.attr("rel", Ie), Qt.attr("j", Ie), Qt.attr("index", V), Qt.node.setAttribute("default-marker-size", at.pSize);
          var Kt = n.graphics.group({ class: "apexcharts-series-markers" });
          Kt && Kt.add(Qt), O.add(Kt), b.add(O);
          var yt = i.config.dataLabels;
          if (yt.enabled) {
            var Mn = yt.formatter(i.globals.series[V][Ie], { seriesIndex: V, dataPointIndex: Ie, w: i });
            f.plotDataLabelsText({ x: L[Ie].x, y: L[Ie].y, text: Mn, textAnchor: "middle", i: V, j: V, parent: P, offsetCorrection: !1, dataLabelsConfig: v({}, yt) });
          }
          b.add(P);
        }), d.push(b);
      }), this.drawPolygons({ parent: E }), i.config.xaxis.labels.show) {
        var I = this.drawXAxisTexts();
        E.add(I);
      }
      return d.forEach(function(j) {
        E.add(j);
      }), E.add(this.yaxisLabels), E;
    } }, { key: "drawPolygons", value: function(t) {
      for (var n = this, i = this.w, o = t.parent, d = new fs(this.ctx), f = i.globals.yAxisScale[0].result.reverse(), p = f.length, y = [], S = this.size / (p - 1), A = 0; A < p; A++)
        y[A] = S * A;
      y.reverse();
      var E = [], L = [];
      y.forEach(function(O, P) {
        var I = K.getPolygonPos(O, n.dataPointsLen), j = "";
        I.forEach(function(V, Z) {
          if (P === 0) {
            var b = n.graphics.drawLine(V.x, V.y, 0, 0, Array.isArray(n.polygons.connectorColors) ? n.polygons.connectorColors[Z] : n.polygons.connectorColors);
            L.push(b);
          }
          Z === 0 && n.yaxisLabelsTextsPos.push({ x: V.x, y: V.y }), j += V.x + "," + V.y + " ";
        }), E.push(j);
      }), E.forEach(function(O, P) {
        var I = n.polygons.strokeColors, j = n.polygons.strokeWidth, V = n.graphics.drawPolygon(O, Array.isArray(I) ? I[P] : I, Array.isArray(j) ? j[P] : j, i.globals.radarPolygons.fill.colors[P]);
        o.add(V);
      }), L.forEach(function(O) {
        o.add(O);
      }), i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(O, P) {
        var I = d.drawYAxisTexts(O.x, O.y, P, f[P]);
        n.yaxisLabels.add(I);
      });
    } }, { key: "drawXAxisTexts", value: function() {
      var t = this, n = this.w, i = n.config.xaxis.labels, o = this.graphics.group({ class: "apexcharts-xaxis" }), d = K.getPolygonPos(this.size, this.dataPointsLen);
      return n.globals.labels.forEach(function(f, p) {
        var y = n.config.xaxis.labels.formatter, S = new Ht(t.ctx);
        if (d[p]) {
          var A = t.getTextPos(d[p], t.size), E = y(f, { seriesIndex: -1, dataPointIndex: p, w: n });
          S.plotDataLabelsText({ x: A.newX, y: A.newY, text: E, textAnchor: A.textAnchor, i: p, j: p, parent: o, color: Array.isArray(i.style.colors) && i.style.colors[p] ? i.style.colors[p] : "#a8a8a8", dataLabelsConfig: v({ textAnchor: A.textAnchor, dropShadow: { enabled: !1 } }, i), offsetCorrection: !1 });
        }
      }), o;
    } }, { key: "createPaths", value: function(t, n) {
      var i = this, o = [], d = [], f = [], p = [];
      if (t.length) {
        d = [this.graphics.move(n.x, n.y)], p = [this.graphics.move(n.x, n.y)];
        var y = this.graphics.move(t[0].x, t[0].y), S = this.graphics.move(t[0].x, t[0].y);
        t.forEach(function(A, E) {
          y += i.graphics.line(A.x, A.y), S += i.graphics.line(A.x, A.y), E === t.length - 1 && (y += "Z", S += "Z");
        }), o.push(y), f.push(S);
      }
      return { linePathsFrom: d, linePathsTo: o, areaPathsFrom: p, areaPathsTo: f };
    } }, { key: "getTextPos", value: function(t, n) {
      var i = "middle", o = t.x, d = t.y;
      return Math.abs(t.x) >= 10 ? t.x > 0 ? (i = "start", o += 10) : t.x < 0 && (i = "end", o -= 10) : i = "middle", Math.abs(t.y) >= n - 10 && (t.y < 0 ? d -= 10 : t.y > 0 && (d += 10)), { textAnchor: i, newX: o, newY: d };
    } }, { key: "getPreviousPath", value: function(t) {
      for (var n = this.w, i = null, o = 0; o < n.globals.previousPaths.length; o++) {
        var d = n.globals.previousPaths[o];
        d.paths.length > 0 && parseInt(d.realIndex, 10) === parseInt(t, 10) && n.globals.previousPaths[o].paths[0] !== void 0 && (i = n.globals.previousPaths[o].paths[0].d);
      }
      return i;
    } }, { key: "getDataPointsPos", value: function(t, n) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.dataPointsLen;
      t = t || [], n = n || [];
      for (var o = [], d = 0; d < i; d++) {
        var f = {};
        f.x = t[d] * Math.sin(n[d]), f.y = -t[d] * Math.cos(n[d]), o.push(f);
      }
      return o;
    } }]), B;
  }(), hs = function(B) {
    U(n, Vs);
    var t = se(n);
    function n(i) {
      var o;
      C(this, n), (o = t.call(this, i)).ctx = i, o.w = i.w, o.animBeginArr = [0], o.animDur = 0;
      var d = o.w;
      return o.startAngle = d.config.plotOptions.radialBar.startAngle, o.endAngle = d.config.plotOptions.radialBar.endAngle, o.totalAngle = Math.abs(d.config.plotOptions.radialBar.endAngle - d.config.plotOptions.radialBar.startAngle), o.trackStartAngle = d.config.plotOptions.radialBar.track.startAngle, o.trackEndAngle = d.config.plotOptions.radialBar.track.endAngle, o.donutDataLabels = o.w.config.plotOptions.radialBar.dataLabels, o.radialDataLabels = o.donutDataLabels, o.trackStartAngle || (o.trackStartAngle = o.startAngle), o.trackEndAngle || (o.trackEndAngle = o.endAngle), o.endAngle === 360 && (o.endAngle = 359.99), o.margin = parseInt(d.config.plotOptions.radialBar.track.margin, 10), o;
    }
    return F(n, [{ key: "draw", value: function(i) {
      var o = this.w, d = new re(this.ctx), f = d.group({ class: "apexcharts-radialbar" });
      if (o.globals.noData)
        return f;
      var p = d.group(), y = this.defaultSize / 2, S = o.globals.gridWidth / 2, A = this.defaultSize / 2.05;
      o.config.chart.sparkline.enabled || (A = A - o.config.stroke.width - o.config.chart.dropShadow.blur);
      var E = o.globals.fill.colors;
      if (o.config.plotOptions.radialBar.track.show) {
        var L = this.drawTracks({ size: A, centerX: S, centerY: y, colorArr: E, series: i });
        p.add(L);
      }
      var O = this.drawArcs({ size: A, centerX: S, centerY: y, colorArr: E, series: i }), P = 360;
      o.config.plotOptions.radialBar.startAngle < 0 && (P = this.totalAngle);
      var I = (360 - P) / 360;
      if (o.globals.radialSize = A - A * I, this.radialDataLabels.value.show) {
        var j = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
        o.globals.radialSize += j * I;
      }
      return p.add(O.g), o.config.plotOptions.radialBar.hollow.position === "front" && (O.g.add(O.elHollow), O.dataLabels && O.g.add(O.dataLabels)), f.add(p), f;
    } }, { key: "drawTracks", value: function(i) {
      var o = this.w, d = new re(this.ctx), f = d.group({ class: "apexcharts-tracks" }), p = new Re(this.ctx), y = new Qe(this.ctx), S = this.getStrokeWidth(i);
      i.size = i.size - S / 2;
      for (var A = 0; A < i.series.length; A++) {
        var E = d.group({ class: "apexcharts-radialbar-track apexcharts-track" });
        f.add(E), E.attr({ rel: A + 1 }), i.size = i.size - S - this.margin;
        var L = o.config.plotOptions.radialBar.track, O = y.fillPath({ seriesNumber: 0, size: i.size, fillColors: Array.isArray(L.background) ? L.background[A] : L.background, solid: !0 }), P = this.trackStartAngle, I = this.trackEndAngle;
        Math.abs(I) + Math.abs(P) >= 360 && (I = 360 - Math.abs(this.startAngle) - 0.1);
        var j = d.drawPath({ d: "", stroke: O, strokeWidth: S * parseInt(L.strokeWidth, 10) / 100, fill: "none", strokeOpacity: L.opacity, classes: "apexcharts-radialbar-area" });
        if (L.dropShadow.enabled) {
          var V = L.dropShadow;
          p.dropShadow(j, V);
        }
        E.add(j), j.attr("id", "apexcharts-radialbarTrack-" + A), this.animatePaths(j, { centerX: i.centerX, centerY: i.centerY, endAngle: I, startAngle: P, size: i.size, i: A, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: !0, easing: o.globals.easing });
      }
      return f;
    } }, { key: "drawArcs", value: function(i) {
      var o = this.w, d = new re(this.ctx), f = new Qe(this.ctx), p = new Re(this.ctx), y = d.group(), S = this.getStrokeWidth(i);
      i.size = i.size - S / 2;
      var A = o.config.plotOptions.radialBar.hollow.background, E = i.size - S * i.series.length - this.margin * i.series.length - S * parseInt(o.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, L = E - o.config.plotOptions.radialBar.hollow.margin;
      o.config.plotOptions.radialBar.hollow.image !== void 0 && (A = this.drawHollowImage(i, y, E, A));
      var O = this.drawHollow({ size: L, centerX: i.centerX, centerY: i.centerY, fill: A || "transparent" });
      if (o.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
        var P = o.config.plotOptions.radialBar.hollow.dropShadow;
        p.dropShadow(O, P);
      }
      var I = 1;
      !this.radialDataLabels.total.show && o.globals.series.length > 1 && (I = 0);
      var j = null;
      this.radialDataLabels.show && (j = this.renderInnerDataLabels(this.radialDataLabels, { hollowSize: E, centerX: i.centerX, centerY: i.centerY, opacity: I })), o.config.plotOptions.radialBar.hollow.position === "back" && (y.add(O), j && y.add(j));
      var V = !1;
      o.config.plotOptions.radialBar.inverseOrder && (V = !0);
      for (var Z = V ? i.series.length - 1 : 0; V ? Z >= 0 : Z < i.series.length; V ? Z-- : Z++) {
        var b = d.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: K.escapeString(o.globals.seriesNames[Z]) });
        y.add(b), b.attr({ rel: Z + 1, "data:realIndex": Z }), this.ctx.series.addCollapsedClassToSeries(b, Z), i.size = i.size - S - this.margin;
        var M = f.fillPath({ seriesNumber: Z, size: i.size, value: i.series[Z] }), N = this.startAngle, X = void 0, Q = K.negToZero(i.series[Z] > 100 ? 100 : i.series[Z]) / 100, ee = Math.round(this.totalAngle * Q) + this.startAngle, oe = void 0;
        o.globals.dataChanged && (X = this.startAngle, oe = Math.round(this.totalAngle * K.negToZero(o.globals.previousPaths[Z]) / 100) + X), Math.abs(ee) + Math.abs(N) >= 360 && (ee -= 0.01), Math.abs(oe) + Math.abs(X) >= 360 && (oe -= 0.01);
        var fe = ee - N, ke = Array.isArray(o.config.stroke.dashArray) ? o.config.stroke.dashArray[Z] : o.config.stroke.dashArray, _e = d.drawPath({ d: "", stroke: M, strokeWidth: S, fill: "none", fillOpacity: o.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + Z, strokeDashArray: ke });
        if (re.setAttrs(_e.node, { "data:angle": fe, "data:value": i.series[Z] }), o.config.chart.dropShadow.enabled) {
          var Le = o.config.chart.dropShadow;
          p.dropShadow(_e, Le, Z);
        }
        p.setSelectionFilter(_e, 0, Z), this.addListeners(_e, this.radialDataLabels), b.add(_e), _e.attr({ index: 0, j: Z });
        var Ie = 0;
        !this.initialAnim || o.globals.resized || o.globals.dataChanged || (Ie = o.config.chart.animations.speed), o.globals.dataChanged && (Ie = o.config.chart.animations.dynamicAnimation.speed), this.animDur = Ie / (1.2 * i.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(_e, { centerX: i.centerX, centerY: i.centerY, endAngle: ee, startAngle: N, prevEndAngle: oe, prevStartAngle: X, size: i.size, i: Z, totalItems: 2, animBeginArr: this.animBeginArr, dur: Ie, shouldSetPrevPaths: !0, easing: o.globals.easing });
      }
      return { g: y, elHollow: O, dataLabels: j };
    } }, { key: "drawHollow", value: function(i) {
      var o = new re(this.ctx).drawCircle(2 * i.size);
      return o.attr({ class: "apexcharts-radialbar-hollow", cx: i.centerX, cy: i.centerY, r: i.size, fill: i.fill }), o;
    } }, { key: "drawHollowImage", value: function(i, o, d, f) {
      var p = this.w, y = new Qe(this.ctx), S = K.randomId(), A = p.config.plotOptions.radialBar.hollow.image;
      if (p.config.plotOptions.radialBar.hollow.imageClipped)
        y.clippedImgArea({ width: d, height: d, image: A, patternID: "pattern".concat(p.globals.cuid).concat(S) }), f = "url(#pattern".concat(p.globals.cuid).concat(S, ")");
      else {
        var E = p.config.plotOptions.radialBar.hollow.imageWidth, L = p.config.plotOptions.radialBar.hollow.imageHeight;
        if (E === void 0 && L === void 0) {
          var O = p.globals.dom.Paper.image(A).loaded(function(I) {
            this.move(i.centerX - I.width / 2 + p.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - I.height / 2 + p.config.plotOptions.radialBar.hollow.imageOffsetY);
          });
          o.add(O);
        } else {
          var P = p.globals.dom.Paper.image(A).loaded(function(I) {
            this.move(i.centerX - E / 2 + p.config.plotOptions.radialBar.hollow.imageOffsetX, i.centerY - L / 2 + p.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(E, L);
          });
          o.add(P);
        }
      }
      return f;
    } }, { key: "getStrokeWidth", value: function(i) {
      var o = this.w;
      return i.size * (100 - parseInt(o.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (i.series.length + 1) - this.margin;
    } }]), n;
  }(), Gs = function(B) {
    U(n, mr);
    var t = se(n);
    function n() {
      return C(this, n), t.apply(this, arguments);
    }
    return F(n, [{ key: "draw", value: function(i, o) {
      var d = this.w, f = new re(this.ctx);
      this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = i, this.seriesRangeStart = d.globals.seriesRangeStart, this.seriesRangeEnd = d.globals.seriesRangeEnd, this.barHelpers.initVariables(i);
      for (var p = f.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), y = 0; y < i.length; y++) {
        var S, A, E, L, O = void 0, P = void 0, I = d.globals.comboCharts ? o[y] : y, j = f.group({ class: "apexcharts-series", seriesName: K.escapeString(d.globals.seriesNames[I]), rel: y + 1, "data:realIndex": I });
        this.ctx.series.addCollapsedClassToSeries(j, I), i[y].length > 0 && (this.visibleI = this.visibleI + 1);
        var V = 0, Z = 0;
        this.yRatio.length > 1 && (this.yaxisIndex = I);
        var b = this.barHelpers.initialPositions();
        P = b.y, L = b.zeroW, O = b.x, Z = b.barWidth, V = b.barHeight, S = b.xDivision, A = b.yDivision, E = b.zeroH;
        for (var M = f.group({ class: "apexcharts-datalabels", "data:realIndex": I }), N = f.group({ class: "apexcharts-rangebar-goals-markers" }), X = 0; X < d.globals.dataPoints; X++) {
          var Q, ee = this.barHelpers.getStrokeWidth(y, X, I), oe = this.seriesRangeStart[y][X], fe = this.seriesRangeEnd[y][X], ke = null, _e = null, Le = null, Ie = { x: O, y: P, strokeWidth: ee, elSeries: j }, at = this.seriesLen;
          if (d.config.plotOptions.bar.rangeBarGroupRows && (at = 1), d.config.series[y].data[X] === void 0)
            break;
          if (this.isHorizontal) {
            Le = P + V * this.visibleI;
            var Qt = (A - V * at) / 2;
            if (d.config.series[y].data[X].x) {
              var Kt = this.detectOverlappingBars({ i: y, j: X, barYPosition: Le, srty: Qt, barHeight: V, yDivision: A, initPositions: b });
              V = Kt.barHeight, Le = Kt.barYPosition;
            }
            Z = (ke = this.drawRangeBarPaths(v({ indexes: { i: y, j: X, realIndex: I }, barHeight: V, barYPosition: Le, zeroW: L, yDivision: A, y1: oe, y2: fe }, Ie))).barWidth;
          } else {
            d.globals.isXNumeric && (O = (d.globals.seriesX[y][X] - d.globals.minX) / this.xRatio - Z / 2), _e = O + Z * this.visibleI;
            var yt = (S - Z * at) / 2;
            if (d.config.series[y].data[X].x) {
              var Mn = this.detectOverlappingBars({ i: y, j: X, barXPosition: _e, srtx: yt, barWidth: Z, xDivision: S, initPositions: b });
              Z = Mn.barWidth, _e = Mn.barXPosition;
            }
            V = (ke = this.drawRangeColumnPaths(v({ indexes: { i: y, j: X, realIndex: I }, barWidth: Z, barXPosition: _e, zeroH: E, xDivision: S }, Ie))).barHeight;
          }
          var zn = this.barHelpers.drawGoalLine({ barXPosition: ke.barXPosition, barYPosition: Le, goalX: ke.goalX, goalY: ke.goalY, barHeight: V, barWidth: Z });
          zn && N.add(zn), P = ke.y, O = ke.x;
          var vt = this.barHelpers.getPathFillColor(i, y, X, I), Ur = d.globals.stroke.colors[I];
          this.renderSeries((Y(Q = { realIndex: I, pathFill: vt, lineFill: Ur, j: X, i: y, x: O, y: P, y1: oe, y2: fe, pathFrom: ke.pathFrom, pathTo: ke.pathTo, strokeWidth: ee, elSeries: j, series: i, barHeight: V, barWidth: Z, barXPosition: _e, barYPosition: Le }, "barWidth", Z), Y(Q, "elDataLabelsWrap", M), Y(Q, "elGoalsMarkers", N), Y(Q, "visibleSeries", this.visibleI), Y(Q, "type", "rangebar"), Q));
        }
        p.add(j);
      }
      return p;
    } }, { key: "detectOverlappingBars", value: function(i) {
      var o = i.i, d = i.j, f = i.barYPosition, p = i.barXPosition, y = i.srty, S = i.srtx, A = i.barHeight, E = i.barWidth, L = i.yDivision, O = i.xDivision, P = i.initPositions, I = this.w, j = [], V = I.config.series[o].data[d].rangeName, Z = I.config.series[o].data[d].x, b = Array.isArray(Z) ? Z.join(" ") : Z, M = I.globals.labels.map(function(X) {
        return Array.isArray(X) ? X.join(" ") : X;
      }).indexOf(b), N = I.globals.seriesRange[o].findIndex(function(X) {
        return X.x === b && X.overlaps.length > 0;
      });
      return this.isHorizontal ? (f = I.config.plotOptions.bar.rangeBarGroupRows ? y + L * M : y + A * this.visibleI + L * M, N > -1 && !I.config.plotOptions.bar.rangeBarOverlap && (j = I.globals.seriesRange[o][N].overlaps).indexOf(V) > -1 && (f = (A = P.barHeight / j.length) * this.visibleI + L * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + A * (this.visibleI + j.indexOf(V)) + L * M)) : (M > -1 && (p = I.config.plotOptions.bar.rangeBarGroupRows ? S + O * M : S + E * this.visibleI + O * M), N > -1 && !I.config.plotOptions.bar.rangeBarOverlap && (j = I.globals.seriesRange[o][N].overlaps).indexOf(V) > -1 && (p = (E = P.barWidth / j.length) * this.visibleI + O * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + E * (this.visibleI + j.indexOf(V)) + O * M)), { barYPosition: f, barXPosition: p, barHeight: A, barWidth: E };
    } }, { key: "drawRangeColumnPaths", value: function(i) {
      var o = i.indexes, d = i.x, f = i.xDivision, p = i.barWidth, y = i.barXPosition, S = i.zeroH, A = this.w, E = o.i, L = o.j, O = this.yRatio[this.yaxisIndex], P = o.realIndex, I = this.getRangeValue(P, L), j = Math.min(I.start, I.end), V = Math.max(I.start, I.end);
      this.series[E][L] === void 0 || this.series[E][L] === null ? j = S : (j = S - j / O, V = S - V / O);
      var Z = Math.abs(V - j), b = this.barHelpers.getColumnPaths({ barXPosition: y, barWidth: p, y1: j, y2: V, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: o.realIndex, i: P, j: L, w: A });
      return A.globals.isXNumeric || (d += f), { pathTo: b.pathTo, pathFrom: b.pathFrom, barHeight: Z, x: d, y: V, goalY: this.barHelpers.getGoalValues("y", null, S, E, L), barXPosition: y };
    } }, { key: "drawRangeBarPaths", value: function(i) {
      var o = i.indexes, d = i.y, f = i.y1, p = i.y2, y = i.yDivision, S = i.barHeight, A = i.barYPosition, E = i.zeroW, L = this.w, O = E + f / this.invertedYRatio, P = E + p / this.invertedYRatio, I = Math.abs(P - O), j = this.barHelpers.getBarpaths({ barYPosition: A, barHeight: S, x1: O, x2: P, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: o.realIndex, realIndex: o.realIndex, j: o.j, w: L });
      return L.globals.isXNumeric || (d += y), { pathTo: j.pathTo, pathFrom: j.pathFrom, barWidth: I, x: P, goalX: this.barHelpers.getGoalValues("x", E, null, o.realIndex, o.j), y: d };
    } }, { key: "getRangeValue", value: function(i, o) {
      var d = this.w;
      return { start: d.globals.seriesRangeStart[i][o], end: d.globals.seriesRangeEnd[i][o] };
    } }]), n;
  }(), ps = function() {
    function B(t) {
      C(this, B), this.w = t.w, this.lineCtx = t;
    }
    return F(B, [{ key: "sameValueSeriesFix", value: function(t, n) {
      var i = this.w;
      if ((i.config.fill.type === "gradient" || i.config.fill.type[t] === "gradient") && new ve(this.lineCtx.ctx, i).seriesHaveSameValues(t)) {
        var o = n[t].slice();
        o[o.length - 1] = o[o.length - 1] + 1e-6, n[t] = o;
      }
      return n;
    } }, { key: "calculatePoints", value: function(t) {
      var n = t.series, i = t.realIndex, o = t.x, d = t.y, f = t.i, p = t.j, y = t.prevY, S = this.w, A = [], E = [];
      if (p === 0) {
        var L = this.lineCtx.categoryAxisCorrection + S.config.markers.offsetX;
        S.globals.isXNumeric && (L = (S.globals.seriesX[i][0] - S.globals.minX) / this.lineCtx.xRatio + S.config.markers.offsetX), A.push(L), E.push(K.isNumber(n[f][0]) ? y + S.config.markers.offsetY : null), A.push(o + S.config.markers.offsetX), E.push(K.isNumber(n[f][p + 1]) ? d + S.config.markers.offsetY : null);
      } else
        A.push(o + S.config.markers.offsetX), E.push(K.isNumber(n[f][p + 1]) ? d + S.config.markers.offsetY : null);
      return { x: A, y: E };
    } }, { key: "checkPreviousPaths", value: function(t) {
      for (var n = t.pathFromLine, i = t.pathFromArea, o = t.realIndex, d = this.w, f = 0; f < d.globals.previousPaths.length; f++) {
        var p = d.globals.previousPaths[f];
        (p.type === "line" || p.type === "area") && p.paths.length > 0 && parseInt(p.realIndex, 10) === parseInt(o, 10) && (p.type === "line" ? (this.lineCtx.appendPathFrom = !1, n = d.globals.previousPaths[f].paths[0].d) : p.type === "area" && (this.lineCtx.appendPathFrom = !1, i = d.globals.previousPaths[f].paths[0].d, d.config.stroke.show && d.globals.previousPaths[f].paths[1] && (n = d.globals.previousPaths[f].paths[1].d)));
      }
      return { pathFromLine: n, pathFromArea: i };
    } }, { key: "determineFirstPrevY", value: function(t) {
      var n, i = t.i, o = t.series, d = t.prevY, f = t.lineYPosition, p = this.w;
      if (((n = o[i]) === null || n === void 0 ? void 0 : n[0]) !== void 0)
        d = (f = p.config.chart.stacked && i > 0 ? this.lineCtx.prevSeriesY[i - 1][0] : this.lineCtx.zeroY) - o[i][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? o[i][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);
      else if (p.config.chart.stacked && i > 0 && o[i][0] === void 0) {
        for (var y = i - 1; y >= 0; y--)
          if (o[y][0] !== null && o[y][0] !== void 0) {
            d = f = this.lineCtx.prevSeriesY[y][0];
            break;
          }
      }
      return { prevY: d, lineYPosition: f };
    } }]), B;
  }(), $s = function(B) {
    for (var t, n, i, o, d = function(A) {
      for (var E = [], L = A[0], O = A[1], P = E[0] = jr(L, O), I = 1, j = A.length - 1; I < j; I++)
        L = O, O = A[I + 1], E[I] = 0.5 * (P + (P = jr(L, O)));
      return E[I] = P, E;
    }(B), f = B.length - 1, p = [], y = 0; y < f; y++)
      i = jr(B[y], B[y + 1]), Math.abs(i) < 1e-6 ? d[y] = d[y + 1] = 0 : (o = (t = d[y] / i) * t + (n = d[y + 1] / i) * n) > 9 && (o = 3 * i / Math.sqrt(o), d[y] = o * t, d[y + 1] = o * n);
    for (var S = 0; S <= f; S++)
      o = (B[Math.min(f, S + 1)][0] - B[Math.max(0, S - 1)][0]) / (6 * (1 + d[S] * d[S])), p.push([o || 0, d[S] * o || 0]);
    return p;
  }, Oi = function(B) {
    for (var t = "", n = 0; n < B.length; n++) {
      var i = B[n], o = i.length;
      o > 4 ? (t += "C".concat(i[0], ", ").concat(i[1]), t += ", ".concat(i[2], ", ").concat(i[3]), t += ", ".concat(i[4], ", ").concat(i[5])) : o > 2 && (t += "S".concat(i[0], ", ").concat(i[1]), t += ", ".concat(i[2], ", ").concat(i[3]));
    }
    return t;
  }, Na = function(B) {
    var t = $s(B), n = B[1], i = B[0], o = [], d = t[1], f = t[0];
    o.push(i, [i[0] + f[0], i[1] + f[1], n[0] - d[0], n[1] - d[1], n[0], n[1]]);
    for (var p = 2, y = t.length; p < y; p++) {
      var S = B[p], A = t[p];
      o.push([S[0] - A[0], S[1] - A[1], S[0], S[1]]);
    }
    return o;
  };
  function jr(B, t) {
    return (t[1] - B[1]) / (t[0] - B[0]);
  }
  var bi = function() {
    function B(t, n, i) {
      C(this, B), this.ctx = t, this.w = t.w, this.xyRatios = n, this.pointsChart = !(this.w.config.chart.type !== "bubble" && this.w.config.chart.type !== "scatter") || i, this.scatter = new kt(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new ps(this), this.markers = new St(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
    }
    return F(B, [{ key: "draw", value: function(t, n, i, o) {
      var d = this.w, f = new re(this.ctx), p = d.globals.comboCharts ? n : d.config.chart.type, y = f.group({ class: "apexcharts-".concat(p, "-series apexcharts-plot-series") }), S = new ve(this.ctx, d);
      this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t = S.getLogSeries(t), this.yRatio = S.getLogYRatios(this.yRatio);
      for (var A = [], E = 0; E < t.length; E++) {
        t = this.lineHelpers.sameValueSeriesFix(E, t);
        var L = d.globals.comboCharts ? i[E] : E;
        this._initSerieVariables(t, E, L);
        var O = [], P = [], I = [], j = d.globals.padHorizontal + this.categoryAxisCorrection;
        this.ctx.series.addCollapsedClassToSeries(this.elSeries, L), d.globals.isXNumeric && d.globals.seriesX.length > 0 && (j = (d.globals.seriesX[L][0] - d.globals.minX) / this.xRatio), I.push(j);
        var V, Z = j, b = void 0, M = Z, N = this.zeroY, X = this.zeroY;
        N = this.lineHelpers.determineFirstPrevY({ i: E, series: t, prevY: N, lineYPosition: 0 }).prevY, O.push(N), V = N, p === "rangeArea" && (b = X = this.lineHelpers.determineFirstPrevY({ i: E, series: o, prevY: X, lineYPosition: 0 }).prevY, P.push(X));
        var Q = { type: p, series: t, realIndex: L, i: E, x: j, y: 1, pX: Z, pY: V, pathsFrom: this._calculatePathsFrom({ type: p, series: t, i: E, realIndex: L, prevX: M, prevY: N, prevY2: X }), linePaths: [], areaPaths: [], seriesIndex: i, lineYPosition: 0, xArrj: I, yArrj: O, y2Arrj: P, seriesRangeEnd: o }, ee = this._iterateOverDataPoints(v(v({}, Q), {}, { iterations: p === "rangeArea" ? t[E].length - 1 : void 0, isRangeStart: !0 }));
        if (p === "rangeArea") {
          var oe = this._calculatePathsFrom({ series: o, i: E, realIndex: L, prevX: M, prevY: X }), fe = this._iterateOverDataPoints(v(v({}, Q), {}, { series: o, pY: b, pathsFrom: oe, iterations: o[E].length - 1, isRangeStart: !1 }));
          ee.linePaths[0] = fe.linePath + ee.linePath, ee.pathFromLine = fe.pathFromLine + ee.pathFromLine;
        }
        this._handlePaths({ type: p, realIndex: L, i: E, paths: ee }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), A.push(this.elSeries);
      }
      if (d.config.chart.stacked)
        for (var ke = A.length; ke > 0; ke--)
          y.add(A[ke - 1]);
      else
        for (var _e = 0; _e < A.length; _e++)
          y.add(A[_e]);
      return y;
    } }, { key: "_initSerieVariables", value: function(t, n, i) {
      var o = this.w, d = new re(this.ctx);
      this.xDivision = o.globals.gridWidth / (o.globals.dataPoints - (o.config.xaxis.tickPlacement === "on" ? 1 : 0)), this.strokeWidth = Array.isArray(o.config.stroke.width) ? o.config.stroke.width[i] : o.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = i), this.isReversed = o.config.yaxis[this.yaxisIndex] && o.config.yaxis[this.yaxisIndex].reversed, this.zeroY = o.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? o.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, (this.zeroY > o.globals.gridHeight || o.config.plotOptions.area.fillTo === "end") && (this.areaBottomY = o.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = d.group({ class: "apexcharts-series", seriesName: K.escapeString(o.globals.seriesNames[i]) }), this.elPointsMain = d.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": i }), this.elDataLabelsWrap = d.group({ class: "apexcharts-datalabels", "data:realIndex": i });
      var f = t[n].length === o.globals.dataPoints;
      this.elSeries.attr({ "data:longestSeries": f, rel: n + 1, "data:realIndex": i }), this.appendPathFrom = !0;
    } }, { key: "_calculatePathsFrom", value: function(t) {
      var n, i, o, d, f = t.type, p = t.series, y = t.i, S = t.realIndex, A = t.prevX, E = t.prevY, L = t.prevY2, O = this.w, P = new re(this.ctx);
      if (p[y][0] === null) {
        for (var I = 0; I < p[y].length; I++)
          if (p[y][I] !== null) {
            A = this.xDivision * I, E = this.zeroY - p[y][I] / this.yRatio[this.yaxisIndex], n = P.move(A, E), i = P.move(A, this.areaBottomY);
            break;
          }
      } else
        n = P.move(A, E), f === "rangeArea" && (n = P.move(A, L) + P.line(A, E)), i = P.move(A, this.areaBottomY) + P.line(A, E);
      if (o = P.move(-1, this.zeroY) + P.line(-1, this.zeroY), d = P.move(-1, this.zeroY) + P.line(-1, this.zeroY), O.globals.previousPaths.length > 0) {
        var j = this.lineHelpers.checkPreviousPaths({ pathFromLine: o, pathFromArea: d, realIndex: S });
        o = j.pathFromLine, d = j.pathFromArea;
      }
      return { prevX: A, prevY: E, linePath: n, areaPath: i, pathFromLine: o, pathFromArea: d };
    } }, { key: "_handlePaths", value: function(t) {
      var n = t.type, i = t.realIndex, o = t.i, d = t.paths, f = this.w, p = new re(this.ctx), y = new Qe(this.ctx);
      this.prevSeriesY.push(d.yArrj), f.globals.seriesXvalues[i] = d.xArrj, f.globals.seriesYvalues[i] = d.yArrj;
      var S = f.config.forecastDataPoints;
      if (S.count > 0 && n !== "rangeArea") {
        var A = f.globals.seriesXvalues[i][f.globals.seriesXvalues[i].length - S.count - 1], E = p.drawRect(A, 0, f.globals.gridWidth, f.globals.gridHeight, 0);
        f.globals.dom.elForecastMask.appendChild(E.node);
        var L = p.drawRect(0, 0, A, f.globals.gridHeight, 0);
        f.globals.dom.elNonForecastMask.appendChild(L.node);
      }
      this.pointsChart || f.globals.delayedElements.push({ el: this.elPointsMain.node, index: i });
      var O = { i: o, realIndex: i, animationDelay: o, initialSpeed: f.config.chart.animations.speed, dataChangeSpeed: f.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(n) };
      if (n === "area")
        for (var P = y.fillPath({ seriesNumber: i }), I = 0; I < d.areaPaths.length; I++) {
          var j = p.renderPaths(v(v({}, O), {}, { pathFrom: d.pathFromArea, pathTo: d.areaPaths[I], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: P }));
          this.elSeries.add(j);
        }
      if (f.config.stroke.show && !this.pointsChart) {
        var V = null;
        if (n === "line")
          V = y.fillPath({ seriesNumber: i, i: o });
        else if (f.config.stroke.fill.type === "solid")
          V = f.globals.stroke.colors[i];
        else {
          var Z = f.config.fill;
          f.config.fill = f.config.stroke.fill, V = y.fillPath({ seriesNumber: i, i: o }), f.config.fill = Z;
        }
        for (var b = 0; b < d.linePaths.length; b++) {
          var M = V;
          n === "rangeArea" && (M = y.fillPath({ seriesNumber: i }));
          var N = v(v({}, O), {}, { pathFrom: d.pathFromLine, pathTo: d.linePaths[b], stroke: V, strokeWidth: this.strokeWidth, strokeLineCap: f.config.stroke.lineCap, fill: n === "rangeArea" ? M : "none" }), X = p.renderPaths(N);
          if (this.elSeries.add(X), X.attr("fill-rule", "evenodd"), S.count > 0 && n !== "rangeArea") {
            var Q = p.renderPaths(N);
            Q.node.setAttribute("stroke-dasharray", S.dashArray), S.strokeWidth && Q.node.setAttribute("stroke-width", S.strokeWidth), this.elSeries.add(Q), Q.attr("clip-path", "url(#forecastMask".concat(f.globals.cuid, ")")), X.attr("clip-path", "url(#nonForecastMask".concat(f.globals.cuid, ")"));
          }
        }
      }
    } }, { key: "_iterateOverDataPoints", value: function(t) {
      var n = t.type, i = t.series, o = t.iterations, d = t.realIndex, f = t.i, p = t.x, y = t.y, S = t.pX, A = t.pY, E = t.pathsFrom, L = t.linePaths, O = t.areaPaths, P = t.seriesIndex, I = t.lineYPosition, j = t.xArrj, V = t.yArrj, Z = t.y2Arrj, b = t.isRangeStart, M = t.seriesRangeEnd, N = this.w, X = new re(this.ctx), Q = this.yRatio, ee = E.prevY, oe = E.linePath, fe = E.areaPath, ke = E.pathFromLine, _e = E.pathFromArea, Le = K.isNumber(N.globals.minYArr[d]) ? N.globals.minYArr[d] : N.globals.minY;
      o || (o = N.globals.dataPoints > 1 ? N.globals.dataPoints - 1 : N.globals.dataPoints);
      for (var Ie = y, at = 0; at < o; at++) {
        var Qt = i[f][at + 1] === void 0 || i[f][at + 1] === null;
        if (N.globals.isXNumeric) {
          var Kt = N.globals.seriesX[d][at + 1];
          N.globals.seriesX[d][at + 1] === void 0 && (Kt = N.globals.seriesX[d][o - 1]), p = (Kt - N.globals.minX) / this.xRatio;
        } else
          p += this.xDivision;
        N.config.chart.stacked ? f > 0 && N.globals.collapsedSeries.length < N.config.series.length - 1 ? I = this.prevSeriesY[function(zn) {
          for (var vt = zn, Ur = 0; Ur < N.globals.series.length; Ur++)
            if (N.globals.collapsedSeriesIndices.indexOf(zn) > -1) {
              vt--;
              break;
            }
          return vt >= 0 ? vt : 0;
        }(f - 1)][at + 1] : I = this.zeroY : I = this.zeroY, Qt ? y = I - Le / Q[this.yaxisIndex] + 2 * (this.isReversed ? Le / Q[this.yaxisIndex] : 0) : (y = I - i[f][at + 1] / Q[this.yaxisIndex] + 2 * (this.isReversed ? i[f][at + 1] / Q[this.yaxisIndex] : 0), n === "rangeArea" && (Ie = I - M[f][at + 1] / Q[this.yaxisIndex] + 2 * (this.isReversed ? M[f][at + 1] / Q[this.yaxisIndex] : 0))), j.push(p), V.push(y), Z.push(Ie);
        var yt = this.lineHelpers.calculatePoints({ series: i, x: p, y, realIndex: d, i: f, j: at, prevY: ee }), Mn = this._createPaths({ type: n, series: i, i: f, realIndex: d, j: at, x: p, y, y2: Ie, xArrj: j, yArrj: V, y2Arrj: Z, pX: S, pY: A, linePath: oe, areaPath: fe, linePaths: L, areaPaths: O, seriesIndex: P, isRangeStart: b });
        O = Mn.areaPaths, L = Mn.linePaths, S = Mn.pX, A = Mn.pY, fe = Mn.areaPath, oe = Mn.linePath, !this.appendPathFrom || N.config.stroke.curve === "monotoneCubic" && n === "rangeArea" || (ke += X.line(p, this.zeroY), _e += X.line(p, this.zeroY)), this.handleNullDataPoints(i, yt, f, at, d), this._handleMarkersAndLabels({ type: n, pointsPos: yt, i: f, j: at, realIndex: d, isRangeStart: b });
      }
      return { yArrj: V, xArrj: j, pathFromArea: _e, areaPaths: O, pathFromLine: ke, linePaths: L, linePath: oe, areaPath: fe };
    } }, { key: "_handleMarkersAndLabels", value: function(t) {
      var n = t.type, i = t.pointsPos, o = t.isRangeStart, d = t.i, f = t.j, p = t.realIndex, y = this.w, S = new Ht(this.ctx);
      if (this.pointsChart)
        this.scatter.draw(this.elSeries, f, { realIndex: p, pointsPos: i, zRatio: this.zRatio, elParent: this.elPointsMain });
      else {
        y.globals.series[d].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
        var A = this.markers.plotChartMarkers(i, p, f + 1);
        A !== null && this.elPointsMain.add(A);
      }
      var E = S.drawDataLabel({ type: n, isRangeStart: o, pos: i, i: p, j: f + 1 });
      E !== null && this.elDataLabelsWrap.add(E);
    } }, { key: "_createPaths", value: function(t) {
      var n = t.type, i = t.series, o = t.i, d = t.realIndex, f = t.j, p = t.x, y = t.y, S = t.xArrj, A = t.yArrj, E = t.y2, L = t.y2Arrj, O = t.pX, P = t.pY, I = t.linePath, j = t.areaPath, V = t.linePaths, Z = t.areaPaths, b = t.seriesIndex, M = t.isRangeStart, N = this.w, X = new re(this.ctx), Q = N.config.stroke.curve, ee = this.areaBottomY;
      if (Array.isArray(N.config.stroke.curve) && (Q = Array.isArray(b) ? N.config.stroke.curve[b[o]] : N.config.stroke.curve[o]), (n === "rangeArea" && (N.globals.hasNullValues || N.config.forecastDataPoints.count > 0) || N.globals.hasNullValues) && Q === "monotoneCubic" && (Q = "straight"), Q === "smooth") {
        var oe = 0.35 * (p - O);
        N.globals.hasNullValues ? (i[o][f] !== null && (i[o][f + 1] !== null ? (I = X.move(O, P) + X.curve(O + oe, P, p - oe, y, p + 1, y), j = X.move(O + 1, P) + X.curve(O + oe, P, p - oe, y, p + 1, y) + X.line(p, ee) + X.line(O, ee) + "z") : (I = X.move(O, P), j = X.move(O, P) + "z")), V.push(I), Z.push(j)) : (I += X.curve(O + oe, P, p - oe, y, p, y), j += X.curve(O + oe, P, p - oe, y, p, y)), O = p, P = y, f === i[o].length - 2 && (j += X.curve(O, P, p, y, p, ee) + X.move(p, y) + "z", n === "rangeArea" && M ? I += X.curve(O, P, p, y, p, E) + X.move(p, E) + "z" : N.globals.hasNullValues || (V.push(I), Z.push(j)));
      } else if (Q === "monotoneCubic") {
        if (n === "rangeArea" ? S.length === N.globals.dataPoints : f === i[o].length - 2) {
          var fe = S.map(function(Kt, yt) {
            return [S[yt], A[yt]];
          }), ke = Na(fe);
          if (I += Oi(ke), j += Oi(ke), O = p, P = y, n === "rangeArea" && M) {
            I += X.line(S[S.length - 1], L[L.length - 1]);
            var _e = S.slice().reverse(), Le = L.slice().reverse(), Ie = _e.map(function(Kt, yt) {
              return [_e[yt], Le[yt]];
            }), at = Na(Ie);
            j = I += Oi(at);
          } else
            j += X.curve(O, P, p, y, p, ee) + X.move(p, y) + "z";
          V.push(I), Z.push(j);
        }
      } else {
        if (i[o][f + 1] === null) {
          I += X.move(p, y);
          var Qt = N.globals.isXNumeric ? (N.globals.seriesX[d][f] - N.globals.minX) / this.xRatio : p - this.xDivision;
          j = j + X.line(Qt, ee) + X.move(p, y) + "z";
        }
        i[o][f] === null && (I += X.move(p, y), j += X.move(p, ee)), Q === "stepline" ? (I = I + X.line(p, null, "H") + X.line(null, y, "V"), j = j + X.line(p, null, "H") + X.line(null, y, "V")) : Q === "straight" && (I += X.line(p, y), j += X.line(p, y)), f === i[o].length - 2 && (j = j + X.line(p, ee) + X.move(p, y) + "z", n === "rangeArea" && M ? I = I + X.line(p, E) + X.move(p, E) + "z" : (V.push(I), Z.push(j)));
      }
      return { linePaths: V, areaPaths: Z, pX: O, pY: P, linePath: I, areaPath: j };
    } }, { key: "handleNullDataPoints", value: function(t, n, i, o, d) {
      var f = this.w;
      if (t[i][o] === null && f.config.markers.showNullDataPoints || t[i].length === 1) {
        var p = this.markers.plotChartMarkers(n, d, o + 1, this.strokeWidth - f.config.markers.strokeWidth / 2, !0);
        p !== null && this.elPointsMain.add(p);
      }
    } }]), B;
  }();
  window.TreemapSquared = {}, window.TreemapSquared.generate = function() {
    function B(p, y, S, A) {
      this.xoffset = p, this.yoffset = y, this.height = A, this.width = S, this.shortestEdge = function() {
        return Math.min(this.height, this.width);
      }, this.getCoordinates = function(E) {
        var L, O = [], P = this.xoffset, I = this.yoffset, j = d(E) / this.height, V = d(E) / this.width;
        if (this.width >= this.height)
          for (L = 0; L < E.length; L++)
            O.push([P, I, P + j, I + E[L] / j]), I += E[L] / j;
        else
          for (L = 0; L < E.length; L++)
            O.push([P, I, P + E[L] / V, I + V]), P += E[L] / V;
        return O;
      }, this.cutArea = function(E) {
        var L;
        if (this.width >= this.height) {
          var O = E / this.height, P = this.width - O;
          L = new B(this.xoffset + O, this.yoffset, P, this.height);
        } else {
          var I = E / this.width, j = this.height - I;
          L = new B(this.xoffset, this.yoffset + I, this.width, j);
        }
        return L;
      };
    }
    function t(p, y, S, A, E) {
      A = A === void 0 ? 0 : A, E = E === void 0 ? 0 : E;
      var L = n(function(O, P) {
        var I, j = [], V = P / d(O);
        for (I = 0; I < O.length; I++)
          j[I] = O[I] * V;
        return j;
      }(p, y * S), [], new B(A, E, y, S), []);
      return function(O) {
        var P, I, j = [];
        for (P = 0; P < O.length; P++)
          for (I = 0; I < O[P].length; I++)
            j.push(O[P][I]);
        return j;
      }(L);
    }
    function n(p, y, S, A) {
      var E, L, O;
      if (p.length !== 0)
        return E = S.shortestEdge(), function(P, I, j) {
          var V;
          if (P.length === 0)
            return !0;
          (V = P.slice()).push(I);
          var Z = i(P, j), b = i(V, j);
          return Z >= b;
        }(y, L = p[0], E) ? (y.push(L), n(p.slice(1), y, S, A)) : (O = S.cutArea(d(y), A), A.push(S.getCoordinates(y)), n(p, [], O, A)), A;
      A.push(S.getCoordinates(y));
    }
    function i(p, y) {
      var S = Math.min.apply(Math, p), A = Math.max.apply(Math, p), E = d(p);
      return Math.max(Math.pow(y, 2) * A / Math.pow(E, 2), Math.pow(E, 2) / (Math.pow(y, 2) * S));
    }
    function o(p) {
      return p && p.constructor === Array;
    }
    function d(p) {
      var y, S = 0;
      for (y = 0; y < p.length; y++)
        S += p[y];
      return S;
    }
    function f(p) {
      var y, S = 0;
      if (o(p[0]))
        for (y = 0; y < p.length; y++)
          S += f(p[y]);
      else
        S = d(p);
      return S;
    }
    return function p(y, S, A, E, L) {
      E = E === void 0 ? 0 : E, L = L === void 0 ? 0 : L;
      var O, P, I = [], j = [];
      if (o(y[0])) {
        for (P = 0; P < y.length; P++)
          I[P] = f(y[P]);
        for (O = t(I, S, A, E, L), P = 0; P < y.length; P++)
          j.push(p(y[P], O[P][2] - O[P][0], O[P][3] - O[P][1], O[P][0], O[P][1]));
      } else
        j = t(y, S, A, E, L);
      return j;
    };
  }();
  var ai, le, Ye = function() {
    function B(t, n) {
      C(this, B), this.ctx = t, this.w = t.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new cs(t), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
    }
    return F(B, [{ key: "draw", value: function(t) {
      var n = this, i = this.w, o = new re(this.ctx), d = new Qe(this.ctx), f = o.group({ class: "apexcharts-treemap" });
      if (i.globals.noData)
        return f;
      var p = [];
      return t.forEach(function(y) {
        var S = y.map(function(A) {
          return Math.abs(A);
        });
        p.push(S);
      }), this.negRange = this.helpers.checkColorRange(), i.config.series.forEach(function(y, S) {
        y.data.forEach(function(A) {
          Array.isArray(n.labels[S]) || (n.labels[S] = []), n.labels[S].push(A.x);
        });
      }), window.TreemapSquared.generate(p, i.globals.gridWidth, i.globals.gridHeight).forEach(function(y, S) {
        var A = o.group({ class: "apexcharts-series apexcharts-treemap-series", seriesName: K.escapeString(i.globals.seriesNames[S]), rel: S + 1, "data:realIndex": S });
        if (i.config.chart.dropShadow.enabled) {
          var E = i.config.chart.dropShadow;
          new Re(n.ctx).dropShadow(f, E, S);
        }
        var L = o.group({ class: "apexcharts-data-labels" });
        y.forEach(function(O, P) {
          var I = O[0], j = O[1], V = O[2], Z = O[3], b = o.drawRect(I, j, V - I, Z - j, 0, "#fff", 1, n.strokeWidth, i.config.plotOptions.treemap.useFillColorAsStroke ? N : i.globals.stroke.colors[S]);
          b.attr({ cx: I, cy: j, index: S, i: S, j: P, width: V - I, height: Z - j });
          var M = n.helpers.getShadeColor(i.config.chart.type, S, P, n.negRange), N = M.color;
          i.config.series[S].data[P] !== void 0 && i.config.series[S].data[P].fillColor && (N = i.config.series[S].data[P].fillColor);
          var X = d.fillPath({ color: N, seriesNumber: S, dataPointIndex: P });
          b.node.classList.add("apexcharts-treemap-rect"), b.attr({ fill: X }), n.helpers.addListeners(b);
          var Q = { x: I + (V - I) / 2, y: j + (Z - j) / 2, width: 0, height: 0 }, ee = { x: I, y: j, width: V - I, height: Z - j };
          if (i.config.chart.animations.enabled && !i.globals.dataChanged) {
            var oe = 1;
            i.globals.resized || (oe = i.config.chart.animations.speed), n.animateTreemap(b, Q, ee, oe);
          }
          if (i.globals.dataChanged) {
            var fe = 1;
            n.dynamicAnim.enabled && i.globals.shouldAnimate && (fe = n.dynamicAnim.speed, i.globals.previousPaths[S] && i.globals.previousPaths[S][P] && i.globals.previousPaths[S][P].rect && (Q = i.globals.previousPaths[S][P].rect), n.animateTreemap(b, Q, ee, fe));
          }
          var ke = n.getFontSize(O), _e = i.config.dataLabels.formatter(n.labels[S][P], { value: i.globals.series[S][P], seriesIndex: S, dataPointIndex: P, w: i });
          i.config.plotOptions.treemap.dataLabels.format === "truncate" && (ke = parseInt(i.config.dataLabels.style.fontSize, 10), _e = n.truncateLabels(_e, ke, I, j, V, Z));
          var Le = n.helpers.calculateDataLabels({ text: _e, x: (I + V) / 2, y: (j + Z) / 2 + n.strokeWidth / 2 + ke / 3, i: S, j: P, colorProps: M, fontSize: ke, series: t });
          i.config.dataLabels.enabled && Le && n.rotateToFitLabel(Le, ke, _e, I, j, V, Z), A.add(b), Le !== null && A.add(Le);
        }), A.add(L), f.add(A);
      }), f;
    } }, { key: "getFontSize", value: function(t) {
      var n = this.w, i, o, d, f, p = function y(S) {
        var A, E = 0;
        if (Array.isArray(S[0]))
          for (A = 0; A < S.length; A++)
            E += y(S[A]);
        else
          for (A = 0; A < S.length; A++)
            E += S[A].length;
        return E;
      }(this.labels) / function y(S) {
        var A, E = 0;
        if (Array.isArray(S[0]))
          for (A = 0; A < S.length; A++)
            E += y(S[A]);
        else
          for (A = 0; A < S.length; A++)
            E += 1;
        return E;
      }(this.labels);
      return i = t[2] - t[0], o = t[3] - t[1], d = i * o, f = Math.pow(d, 0.5), Math.min(f / p, parseInt(n.config.dataLabels.style.fontSize, 10));
    } }, { key: "rotateToFitLabel", value: function(t, n, i, o, d, f, p) {
      var y = new re(this.ctx), S = y.getTextRects(i, n);
      if (S.width + this.w.config.stroke.width + 5 > f - o && S.width <= p - d) {
        var A = y.rotateAroundCenter(t.node);
        t.node.setAttribute("transform", "rotate(-90 ".concat(A.x, " ").concat(A.y, ") translate(").concat(S.height / 3, ")"));
      }
    } }, { key: "truncateLabels", value: function(t, n, i, o, d, f) {
      var p = new re(this.ctx), y = p.getTextRects(t, n).width + this.w.config.stroke.width + 5 > d - i && f - o > d - i ? f - o : d - i, S = p.getTextBasedOnMaxWidth({ text: t, maxWidth: y, fontSize: n });
      return t.length !== S.length && y / n < 5 ? "" : S;
    } }, { key: "animateTreemap", value: function(t, n, i, o) {
      var d = new we(this.ctx);
      d.animateRect(t, { x: n.x, y: n.y, width: n.width, height: n.height }, { x: i.x, y: i.y, width: i.width, height: i.height }, o, function() {
        d.animationCompleted(t);
      });
    } }]), B;
  }(), tt = 86400, Dt = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
    }
    return F(B, [{ key: "calculateTimeScaleTicks", value: function(t, n) {
      var i = this, o = this.w;
      if (o.globals.allSeriesCollapsed)
        return o.globals.labels = [], o.globals.timescaleLabels = [], [];
      var d = new Ze(this.ctx), f = (n - t) / 864e5;
      this.determineInterval(f), o.globals.disableZoomIn = !1, o.globals.disableZoomOut = !1, f < 11574074074074075e-20 ? o.globals.disableZoomIn = !0 : f > 5e4 && (o.globals.disableZoomOut = !0);
      var p = d.getTimeUnitsfromTimestamp(t, n, this.utc), y = o.globals.gridWidth / f, S = y / 24, A = S / 60, E = A / 60, L = Math.floor(24 * f), O = Math.floor(1440 * f), P = Math.floor(f * tt), I = Math.floor(f), j = Math.floor(f / 30), V = Math.floor(f / 365), Z = { minMillisecond: p.minMillisecond, minSecond: p.minSecond, minMinute: p.minMinute, minHour: p.minHour, minDate: p.minDate, minMonth: p.minMonth, minYear: p.minYear }, b = { firstVal: Z, currentMillisecond: Z.minMillisecond, currentSecond: Z.minSecond, currentMinute: Z.minMinute, currentHour: Z.minHour, currentMonthDate: Z.minDate, currentDate: Z.minDate, currentMonth: Z.minMonth, currentYear: Z.minYear, daysWidthOnXAxis: y, hoursWidthOnXAxis: S, minutesWidthOnXAxis: A, secondsWidthOnXAxis: E, numberOfSeconds: P, numberOfMinutes: O, numberOfHours: L, numberOfDays: I, numberOfMonths: j, numberOfYears: V };
      switch (this.tickInterval) {
        case "years":
          this.generateYearScale(b);
          break;
        case "months":
        case "half_year":
          this.generateMonthScale(b);
          break;
        case "months_days":
        case "months_fortnight":
        case "days":
        case "week_days":
          this.generateDayScale(b);
          break;
        case "hours":
          this.generateHourScale(b);
          break;
        case "minutes_fives":
        case "minutes":
          this.generateMinuteScale(b);
          break;
        case "seconds_tens":
        case "seconds_fives":
        case "seconds":
          this.generateSecondScale(b);
      }
      var M = this.timeScaleArray.map(function(N) {
        var X = { position: N.position, unit: N.unit, year: N.year, day: N.day ? N.day : 1, hour: N.hour ? N.hour : 0, month: N.month + 1 };
        return N.unit === "month" ? v(v({}, X), {}, { day: 1, value: N.value + 1 }) : N.unit === "day" || N.unit === "hour" ? v(v({}, X), {}, { value: N.value }) : N.unit === "minute" ? v(v({}, X), {}, { value: N.value, minute: N.value }) : N.unit === "second" ? v(v({}, X), {}, { value: N.value, minute: N.minute, second: N.second }) : N;
      });
      return M.filter(function(N) {
        var X = 1, Q = Math.ceil(o.globals.gridWidth / 120), ee = N.value;
        o.config.xaxis.tickAmount !== void 0 && (Q = o.config.xaxis.tickAmount), M.length > Q && (X = Math.floor(M.length / Q));
        var oe = !1, fe = !1;
        switch (i.tickInterval) {
          case "years":
            N.unit === "year" && (oe = !0);
            break;
          case "half_year":
            X = 7, N.unit === "year" && (oe = !0);
            break;
          case "months":
            X = 1, N.unit === "year" && (oe = !0);
            break;
          case "months_fortnight":
            X = 15, N.unit !== "year" && N.unit !== "month" || (oe = !0), ee === 30 && (fe = !0);
            break;
          case "months_days":
            X = 10, N.unit === "month" && (oe = !0), ee === 30 && (fe = !0);
            break;
          case "week_days":
            X = 8, N.unit === "month" && (oe = !0);
            break;
          case "days":
            X = 1, N.unit === "month" && (oe = !0);
            break;
          case "hours":
            N.unit === "day" && (oe = !0);
            break;
          case "minutes_fives":
          case "seconds_fives":
            ee % 5 != 0 && (fe = !0);
            break;
          case "seconds_tens":
            ee % 10 != 0 && (fe = !0);
        }
        if (i.tickInterval === "hours" || i.tickInterval === "minutes_fives" || i.tickInterval === "seconds_tens" || i.tickInterval === "seconds_fives") {
          if (!fe)
            return !0;
        } else if ((ee % X == 0 || oe) && !fe)
          return !0;
      });
    } }, { key: "recalcDimensionsBasedOnFormat", value: function(t, n) {
      var i = this.w, o = this.formatDates(t), d = this.removeOverlappingTS(o);
      i.globals.timescaleLabels = d.slice(), new ni(this.ctx).plotCoords();
    } }, { key: "determineInterval", value: function(t) {
      var n = 24 * t, i = 60 * n;
      switch (!0) {
        case t / 365 > 5:
          this.tickInterval = "years";
          break;
        case t > 800:
          this.tickInterval = "half_year";
          break;
        case t > 180:
          this.tickInterval = "months";
          break;
        case t > 90:
          this.tickInterval = "months_fortnight";
          break;
        case t > 60:
          this.tickInterval = "months_days";
          break;
        case t > 30:
          this.tickInterval = "week_days";
          break;
        case t > 2:
          this.tickInterval = "days";
          break;
        case n > 2.4:
          this.tickInterval = "hours";
          break;
        case i > 15:
          this.tickInterval = "minutes_fives";
          break;
        case i > 5:
          this.tickInterval = "minutes";
          break;
        case i > 1:
          this.tickInterval = "seconds_tens";
          break;
        case 60 * i > 20:
          this.tickInterval = "seconds_fives";
          break;
        default:
          this.tickInterval = "seconds";
      }
    } }, { key: "generateYearScale", value: function(t) {
      var n = t.firstVal, i = t.currentMonth, o = t.currentYear, d = t.daysWidthOnXAxis, f = t.numberOfYears, p = n.minYear, y = 0, S = new Ze(this.ctx), A = "year";
      if (n.minDate > 1 || n.minMonth > 0) {
        var E = S.determineRemainingDaysOfYear(n.minYear, n.minMonth, n.minDate);
        y = (S.determineDaysOfYear(n.minYear) - E + 1) * d, p = n.minYear + 1, this.timeScaleArray.push({ position: y, value: p, unit: A, year: p, month: K.monthMod(i + 1) });
      } else
        n.minDate === 1 && n.minMonth === 0 && this.timeScaleArray.push({ position: y, value: p, unit: A, year: o, month: K.monthMod(i + 1) });
      for (var L = p, O = y, P = 0; P < f; P++)
        L++, O = S.determineDaysOfYear(L - 1) * d + O, this.timeScaleArray.push({ position: O, value: L, unit: A, year: L, month: 1 });
    } }, { key: "generateMonthScale", value: function(t) {
      var n = t.firstVal, i = t.currentMonthDate, o = t.currentMonth, d = t.currentYear, f = t.daysWidthOnXAxis, p = t.numberOfMonths, y = o, S = 0, A = new Ze(this.ctx), E = "month", L = 0;
      if (n.minDate > 1) {
        S = (A.determineDaysOfMonths(o + 1, n.minYear) - i + 1) * f, y = K.monthMod(o + 1);
        var O = d + L, P = K.monthMod(y), I = y;
        y === 0 && (E = "year", I = O, P = 1, O += L += 1), this.timeScaleArray.push({ position: S, value: I, unit: E, year: O, month: P });
      } else
        this.timeScaleArray.push({ position: S, value: y, unit: E, year: d, month: K.monthMod(o) });
      for (var j = y + 1, V = S, Z = 0, b = 1; Z < p; Z++, b++) {
        (j = K.monthMod(j)) === 0 ? (E = "year", L += 1) : E = "month";
        var M = this._getYear(d, j, L);
        V = A.determineDaysOfMonths(j, M) * f + V;
        var N = j === 0 ? M : j;
        this.timeScaleArray.push({ position: V, value: N, unit: E, year: M, month: j === 0 ? 1 : j }), j++;
      }
    } }, { key: "generateDayScale", value: function(t) {
      var n = t.firstVal, i = t.currentMonth, o = t.currentYear, d = t.hoursWidthOnXAxis, f = t.numberOfDays, p = new Ze(this.ctx), y = "day", S = n.minDate + 1, A = S, E = function(b, M, N) {
        return b > p.determineDaysOfMonths(M + 1, N) && (A = 1, y = "month", O = M += 1), M;
      }, L = (24 - n.minHour) * d, O = S, P = E(A, i, o);
      n.minHour === 0 && n.minDate === 1 ? (L = 0, O = K.monthMod(n.minMonth), y = "month", A = n.minDate, f++) : n.minDate !== 1 && n.minHour === 0 && n.minMinute === 0 && (L = 0, S = n.minDate, O = S, P = E(A = S, i, o)), this.timeScaleArray.push({ position: L, value: O, unit: y, year: this._getYear(o, P, 0), month: K.monthMod(P), day: A });
      for (var I = L, j = 0; j < f; j++) {
        y = "day", P = E(A += 1, P, this._getYear(o, P, 0));
        var V = this._getYear(o, P, 0);
        I = 24 * d + I;
        var Z = A === 1 ? K.monthMod(P) : A;
        this.timeScaleArray.push({ position: I, value: Z, unit: y, year: V, month: K.monthMod(P), day: Z });
      }
    } }, { key: "generateHourScale", value: function(t) {
      var n = t.firstVal, i = t.currentDate, o = t.currentMonth, d = t.currentYear, f = t.minutesWidthOnXAxis, p = t.numberOfHours, y = new Ze(this.ctx), S = "hour", A = function(X, Q) {
        return X > y.determineDaysOfMonths(Q + 1, d) && (j = 1, Q += 1), { month: Q, date: j };
      }, E = function(X, Q) {
        return X > y.determineDaysOfMonths(Q + 1, d) ? Q += 1 : Q;
      }, L = 60 - (n.minMinute + n.minSecond / 60), O = L * f, P = n.minHour + 1, I = P + 1;
      L === 60 && (O = 0, I = (P = n.minHour) + 1);
      var j = i, V = E(j, o);
      this.timeScaleArray.push({ position: O, value: P, unit: S, day: j, hour: I, year: d, month: K.monthMod(V) });
      for (var Z = O, b = 0; b < p; b++) {
        S = "hour", I >= 24 && (I = 0, S = "day", V = A(j += 1, V).month, V = E(j, V));
        var M = this._getYear(d, V, 0);
        Z = 60 * f + Z;
        var N = I === 0 ? j : I;
        this.timeScaleArray.push({ position: Z, value: N, unit: S, hour: I, day: j, year: M, month: K.monthMod(V) }), I++;
      }
    } }, { key: "generateMinuteScale", value: function(t) {
      for (var n = t.currentMillisecond, i = t.currentSecond, o = t.currentMinute, d = t.currentHour, f = t.currentDate, p = t.currentMonth, y = t.currentYear, S = t.minutesWidthOnXAxis, A = t.secondsWidthOnXAxis, E = t.numberOfMinutes, L = o + 1, O = f, P = p, I = y, j = d, V = (60 - i - n / 1e3) * A, Z = 0; Z < E; Z++)
        L >= 60 && (L = 0, (j += 1) === 24 && (j = 0)), this.timeScaleArray.push({ position: V, value: L, unit: "minute", hour: j, minute: L, day: O, year: this._getYear(I, P, 0), month: K.monthMod(P) }), V += S, L++;
    } }, { key: "generateSecondScale", value: function(t) {
      for (var n = t.currentMillisecond, i = t.currentSecond, o = t.currentMinute, d = t.currentHour, f = t.currentDate, p = t.currentMonth, y = t.currentYear, S = t.secondsWidthOnXAxis, A = t.numberOfSeconds, E = i + 1, L = o, O = f, P = p, I = y, j = d, V = (1e3 - n) / 1e3 * S, Z = 0; Z < A; Z++)
        E >= 60 && (E = 0, ++L >= 60 && (L = 0, ++j === 24 && (j = 0))), this.timeScaleArray.push({ position: V, value: E, unit: "second", hour: j, minute: L, second: E, day: O, year: this._getYear(I, P, 0), month: K.monthMod(P) }), V += S, E++;
    } }, { key: "createRawDateString", value: function(t, n) {
      var i = t.year;
      return t.month === 0 && (t.month = 1), i += "-" + ("0" + t.month.toString()).slice(-2), t.unit === "day" ? i += t.unit === "day" ? "-" + ("0" + n).slice(-2) : "-01" : i += "-" + ("0" + (t.day ? t.day : "1")).slice(-2), t.unit === "hour" ? i += t.unit === "hour" ? "T" + ("0" + n).slice(-2) : "T00" : i += "T" + ("0" + (t.hour ? t.hour : "0")).slice(-2), t.unit === "minute" ? i += ":" + ("0" + n).slice(-2) : i += ":" + (t.minute ? ("0" + t.minute).slice(-2) : "00"), t.unit === "second" ? i += ":" + ("0" + n).slice(-2) : i += ":00", this.utc && (i += ".000Z"), i;
    } }, { key: "formatDates", value: function(t) {
      var n = this, i = this.w;
      return t.map(function(o) {
        var d = o.value.toString(), f = new Ze(n.ctx), p = n.createRawDateString(o, d), y = f.getDate(f.parseDate(p));
        if (n.utc || (y = f.getDate(f.parseDateWithTimezone(p))), i.config.xaxis.labels.format === void 0) {
          var S = "dd MMM", A = i.config.xaxis.labels.datetimeFormatter;
          o.unit === "year" && (S = A.year), o.unit === "month" && (S = A.month), o.unit === "day" && (S = A.day), o.unit === "hour" && (S = A.hour), o.unit === "minute" && (S = A.minute), o.unit === "second" && (S = A.second), d = f.formatDate(y, S);
        } else
          d = f.formatDate(y, i.config.xaxis.labels.format);
        return { dateString: p, position: o.position, value: d, unit: o.unit, year: o.year, month: o.month };
      });
    } }, { key: "removeOverlappingTS", value: function(t) {
      var n, i = this, o = new re(this.ctx), d = !1;
      t.length > 0 && t[0].value && t.every(function(y) {
        return y.value.length === t[0].value.length;
      }) && (d = !0, n = o.getTextRects(t[0].value).width);
      var f = 0, p = t.map(function(y, S) {
        if (S > 0 && i.w.config.xaxis.labels.hideOverlappingLabels) {
          var A = d ? n : o.getTextRects(t[f].value).width, E = t[f].position;
          return y.position > E + A + 10 ? (f = S, y) : null;
        }
        return y;
      });
      return p = p.filter(function(y) {
        return y !== null;
      });
    } }, { key: "_getYear", value: function(t, n, i) {
      return t + Math.floor(n / 12) + i;
    } }]), B;
  }(), qt = function() {
    function B(t, n) {
      C(this, B), this.ctx = n, this.w = n.w, this.el = t;
    }
    return F(B, [{ key: "setupElements", value: function() {
      var t = this.w.globals, n = this.w.config, i = n.chart.type;
      t.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(i) > -1, t.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(i) > -1, t.isBarHorizontal = (n.chart.type === "bar" || n.chart.type === "rangeBar" || n.chart.type === "boxPlot") && n.plotOptions.bar.horizontal, t.chartClass = ".apexcharts" + t.chartID, t.dom.baseEl = this.el, t.dom.elWrap = document.createElement("div"), re.setAttrs(t.dom.elWrap, { id: t.chartClass.substring(1), class: "apexcharts-canvas " + t.chartClass.substring(1) }), this.el.appendChild(t.dom.elWrap), t.dom.Paper = new window.SVG.Doc(t.dom.elWrap), t.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(n.chart.offsetX, ", ").concat(n.chart.offsetY, ")") }), t.dom.Paper.node.style.background = n.chart.background, this.setSVGDimensions(), t.dom.elLegendForeign = document.createElementNS(t.SVGNS, "foreignObject"), re.setAttrs(t.dom.elLegendForeign, { x: 0, y: 0, width: t.svgWidth, height: t.svgHeight }), t.dom.elLegendWrap = document.createElement("div"), t.dom.elLegendWrap.classList.add("apexcharts-legend"), t.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), t.dom.elLegendForeign.appendChild(t.dom.elLegendWrap), t.dom.Paper.node.appendChild(t.dom.elLegendForeign), t.dom.elGraphical = t.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), t.dom.elDefs = t.dom.Paper.defs(), t.dom.Paper.add(t.dom.elGraphical), t.dom.elGraphical.add(t.dom.elDefs);
    } }, { key: "plotChartType", value: function(t, n) {
      var i = this.w, o = i.config, d = i.globals, f = { series: [], i: [] }, p = { series: [], i: [] }, y = { series: [], i: [] }, S = { series: [], i: [] }, A = { series: [], i: [] }, E = { series: [], i: [] }, L = { series: [], i: [] }, O = { series: [], i: [] }, P = { series: [], seriesRangeEnd: [], i: [] };
      d.series.map(function(Q, ee) {
        var oe = 0;
        t[ee].type !== void 0 ? (t[ee].type === "column" || t[ee].type === "bar" ? (d.series.length > 1 && o.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"), A.series.push(Q), A.i.push(ee), oe++, i.globals.columnSeries = A.series) : t[ee].type === "area" ? (p.series.push(Q), p.i.push(ee), oe++) : t[ee].type === "line" ? (f.series.push(Q), f.i.push(ee), oe++) : t[ee].type === "scatter" ? (y.series.push(Q), y.i.push(ee)) : t[ee].type === "bubble" ? (S.series.push(Q), S.i.push(ee), oe++) : t[ee].type === "candlestick" ? (E.series.push(Q), E.i.push(ee), oe++) : t[ee].type === "boxPlot" ? (L.series.push(Q), L.i.push(ee), oe++) : t[ee].type === "rangeBar" ? (O.series.push(Q), O.i.push(ee), oe++) : t[ee].type === "rangeArea" ? (P.series.push(d.seriesRangeStart[ee]), P.seriesRangeEnd.push(d.seriesRangeEnd[ee]), P.i.push(ee), oe++) : console.warn("You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble/candlestick/boxPlot/rangeBar/rangeArea"), oe > 1 && (d.comboCharts = !0)) : (f.series.push(Q), f.i.push(ee));
      });
      var I = new bi(this.ctx, n), j = new Cn(this.ctx, n);
      this.ctx.pie = new Vs(this.ctx);
      var V = new hs(this.ctx);
      this.ctx.rangeBar = new Gs(this.ctx, n);
      var Z = new Ml(this.ctx), b = [];
      if (d.comboCharts) {
        if (p.series.length > 0 && b.push(I.draw(p.series, "area", p.i)), A.series.length > 0)
          if (i.config.chart.stacked) {
            var M = new kn(this.ctx, n);
            b.push(M.draw(A.series, A.i));
          } else
            this.ctx.bar = new mr(this.ctx, n), b.push(this.ctx.bar.draw(A.series, A.i));
        if (P.series.length > 0 && b.push(I.draw(P.series, "rangeArea", P.i, P.seriesRangeEnd)), f.series.length > 0 && b.push(I.draw(f.series, "line", f.i)), E.series.length > 0 && b.push(j.draw(E.series, "candlestick", E.i)), L.series.length > 0 && b.push(j.draw(L.series, "boxPlot", L.i)), O.series.length > 0 && b.push(this.ctx.rangeBar.draw(O.series, O.i)), y.series.length > 0) {
          var N = new bi(this.ctx, n, !0);
          b.push(N.draw(y.series, "scatter", y.i));
        }
        if (S.series.length > 0) {
          var X = new bi(this.ctx, n, !0);
          b.push(X.draw(S.series, "bubble", S.i));
        }
      } else
        switch (o.chart.type) {
          case "line":
            b = I.draw(d.series, "line");
            break;
          case "area":
            b = I.draw(d.series, "area");
            break;
          case "bar":
            o.chart.stacked ? b = new kn(this.ctx, n).draw(d.series) : (this.ctx.bar = new mr(this.ctx, n), b = this.ctx.bar.draw(d.series));
            break;
          case "candlestick":
            b = new Cn(this.ctx, n).draw(d.series, "candlestick");
            break;
          case "boxPlot":
            b = new Cn(this.ctx, n).draw(d.series, o.chart.type);
            break;
          case "rangeBar":
            b = this.ctx.rangeBar.draw(d.series);
            break;
          case "rangeArea":
            b = I.draw(d.seriesRangeStart, "rangeArea", void 0, d.seriesRangeEnd);
            break;
          case "heatmap":
            b = new ds(this.ctx, n).draw(d.series);
            break;
          case "treemap":
            b = new Ye(this.ctx, n).draw(d.series);
            break;
          case "pie":
          case "donut":
          case "polarArea":
            b = this.ctx.pie.draw(d.series);
            break;
          case "radialBar":
            b = V.draw(d.series);
            break;
          case "radar":
            b = Z.draw(d.series);
            break;
          default:
            b = I.draw(d.series);
        }
      return b;
    } }, { key: "setSVGDimensions", value: function() {
      var t = this.w.globals, n = this.w.config;
      t.svgWidth = n.chart.width, t.svgHeight = n.chart.height;
      var i = K.getDimensions(this.el), o = n.chart.width.toString().split(/[0-9]+/g).pop();
      o === "%" ? K.isNumber(i[0]) && (i[0].width === 0 && (i = K.getDimensions(this.el.parentNode)), t.svgWidth = i[0] * parseInt(n.chart.width, 10) / 100) : o !== "px" && o !== "" || (t.svgWidth = parseInt(n.chart.width, 10));
      var d = n.chart.height.toString().split(/[0-9]+/g).pop();
      if (t.svgHeight !== "auto" && t.svgHeight !== "")
        if (d === "%") {
          var f = K.getDimensions(this.el.parentNode);
          t.svgHeight = f[1] * parseInt(n.chart.height, 10) / 100;
        } else
          t.svgHeight = parseInt(n.chart.height, 10);
      else
        t.axisCharts ? t.svgHeight = t.svgWidth / 1.61 : t.svgHeight = t.svgWidth / 1.2;
      if (t.svgWidth < 0 && (t.svgWidth = 0), t.svgHeight < 0 && (t.svgHeight = 0), re.setAttrs(t.dom.Paper.node, { width: t.svgWidth, height: t.svgHeight }), d !== "%") {
        var p = n.chart.sparkline.enabled ? 0 : t.axisCharts ? n.chart.parentHeightOffset : 0;
        t.dom.Paper.node.parentNode.parentNode.style.minHeight = t.svgHeight + p + "px";
      }
      t.dom.elWrap.style.width = t.svgWidth + "px", t.dom.elWrap.style.height = t.svgHeight + "px";
    } }, { key: "shiftGraphPosition", value: function() {
      var t = this.w.globals, n = t.translateY, i = { transform: "translate(" + t.translateX + ", " + n + ")" };
      re.setAttrs(t.dom.elGraphical.node, i);
    } }, { key: "resizeNonAxisCharts", value: function() {
      var t = this.w, n = t.globals, i = 0, o = t.config.chart.sparkline.enabled ? 1 : 15;
      o += t.config.grid.padding.bottom, t.config.legend.position !== "top" && t.config.legend.position !== "bottom" || !t.config.legend.show || t.config.legend.floating || (i = new ri(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
      var d = t.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), f = 2.05 * t.globals.radialSize;
      if (d && !t.config.chart.sparkline.enabled && t.config.plotOptions.radialBar.startAngle !== 0) {
        var p = K.getBoundingClientRect(d);
        f = p.bottom;
        var y = p.bottom - p.top;
        f = Math.max(2.05 * t.globals.radialSize, y);
      }
      var S = f + n.translateY + i + o;
      n.dom.elLegendForeign && n.dom.elLegendForeign.setAttribute("height", S), t.config.chart.height && String(t.config.chart.height).indexOf("%") > 0 || (n.dom.elWrap.style.height = S + "px", re.setAttrs(n.dom.Paper.node, { height: S }), n.dom.Paper.node.parentNode.parentNode.style.minHeight = S + "px");
    } }, { key: "coreCalculations", value: function() {
      new pn(this.ctx).init();
    } }, { key: "resetGlobals", value: function() {
      var t = this, n = function() {
        return t.w.config.series.map(function(d) {
          return [];
        });
      }, i = new ye(), o = this.w.globals;
      i.initGlobalVars(o), o.seriesXvalues = n(), o.seriesYvalues = n();
    } }, { key: "isMultipleY", value: function() {
      if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1)
        return this.w.globals.isMultipleYAxis = !0, !0;
    } }, { key: "xySettings", value: function() {
      var t = null, n = this.w;
      if (n.globals.axisCharts) {
        if (n.config.xaxis.crosshairs.position === "back" && new ti(this.ctx).drawXCrosshairs(), n.config.yaxis[0].crosshairs.position === "back" && new ti(this.ctx).drawYCrosshairs(), n.config.xaxis.type === "datetime" && n.config.xaxis.labels.formatter === void 0) {
          this.ctx.timeScale = new Dt(this.ctx);
          var i = [];
          isFinite(n.globals.minX) && isFinite(n.globals.maxX) && !n.globals.isBarHorizontal ? i = this.ctx.timeScale.calculateTimeScaleTicks(n.globals.minX, n.globals.maxX) : n.globals.isBarHorizontal && (i = this.ctx.timeScale.calculateTimeScaleTicks(n.globals.minY, n.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i);
        }
        t = new ve(this.ctx).getCalculatedRatios();
      }
      return t;
    } }, { key: "updateSourceChart", value: function(t) {
      this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: t.w.globals.minX, max: t.w.globals.maxX } } } }, !1, !1);
    } }, { key: "setupBrushHandler", value: function() {
      var t = this, n = this.w;
      if (n.config.chart.brush.enabled && typeof n.config.chart.events.selection != "function") {
        var i = Array.isArray(n.config.chart.brush.targets) || [n.config.chart.brush.target];
        i.forEach(function(o) {
          var d = ApexCharts.getChartByID(o);
          d.w.globals.brushSource = t.ctx, typeof d.w.config.chart.events.zoomed != "function" && (d.w.config.chart.events.zoomed = function() {
            t.updateSourceChart(d);
          }), typeof d.w.config.chart.events.scrolled != "function" && (d.w.config.chart.events.scrolled = function() {
            t.updateSourceChart(d);
          });
        }), n.config.chart.events.selection = function(o, d) {
          i.forEach(function(f) {
            var p = ApexCharts.getChartByID(f), y = K.clone(n.config.yaxis);
            if (n.config.chart.brush.autoScaleYaxis && p.w.globals.series.length === 1) {
              var S = new qe(p);
              y = S.autoScaleY(p, y, d);
            }
            var A = p.w.config.yaxis.reduce(function(E, L, O) {
              return [].concat(ue(E), [v(v({}, p.w.config.yaxis[O]), {}, { min: y[0].min, max: y[0].max })]);
            }, []);
            p.ctx.updateHelpers._updateOptions({ xaxis: { min: d.xaxis.min, max: d.xaxis.max }, yaxis: A }, !1, !1, !1, !1);
          });
        };
      }
    } }]), B;
  }(), cn = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "_updateOptions", value: function(t) {
      var n = this, i = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], o = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], d = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], f = arguments.length > 4 && arguments[4] !== void 0 && arguments[4];
      return new Promise(function(p) {
        var y = [n.ctx];
        d && (y = n.ctx.getSyncedCharts()), n.ctx.w.globals.isExecCalled && (y = [n.ctx], n.ctx.w.globals.isExecCalled = !1), y.forEach(function(S, A) {
          var E = S.w;
          if (E.globals.shouldAnimate = o, i || (E.globals.resized = !0, E.globals.dataChanged = !0, o && S.series.getPreviousPaths()), t && w(t) === "object" && (S.config = new ft(t), t = ve.extendArrayProps(S.config, t, E), S.w.globals.chartID !== n.ctx.w.globals.chartID && delete t.series, E.config = K.extend(E.config, t), f && (E.globals.lastXAxis = t.xaxis ? K.clone(t.xaxis) : [], E.globals.lastYAxis = t.yaxis ? K.clone(t.yaxis) : [], E.globals.initialConfig = K.extend({}, E.config), E.globals.initialSeries = K.clone(E.config.series), t.series))) {
            for (var L = 0; L < E.globals.collapsedSeriesIndices.length; L++) {
              var O = E.config.series[E.globals.collapsedSeriesIndices[L]];
              E.globals.collapsedSeries[L].data = E.globals.axisCharts ? O.data.slice() : O;
            }
            for (var P = 0; P < E.globals.ancillaryCollapsedSeriesIndices.length; P++) {
              var I = E.config.series[E.globals.ancillaryCollapsedSeriesIndices[P]];
              E.globals.ancillaryCollapsedSeries[P].data = E.globals.axisCharts ? I.data.slice() : I;
            }
            S.series.emptyCollapsedSeries(E.config.series);
          }
          return S.update(t).then(function() {
            A === y.length - 1 && p(S);
          });
        });
      });
    } }, { key: "_updateSeries", value: function(t, n) {
      var i = this, o = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
      return new Promise(function(d) {
        var f, p = i.w;
        return p.globals.shouldAnimate = n, p.globals.dataChanged = !0, n && i.ctx.series.getPreviousPaths(), p.globals.axisCharts ? ((f = t.map(function(y, S) {
          return i._extendSeries(y, S);
        })).length === 0 && (f = [{ data: [] }]), p.config.series = f) : p.config.series = t.slice(), o && (p.globals.initialConfig.series = K.clone(p.config.series), p.globals.initialSeries = K.clone(p.config.series)), i.ctx.update().then(function() {
          d(i.ctx);
        });
      });
    } }, { key: "_extendSeries", value: function(t, n) {
      var i = this.w, o = i.config.series[n];
      return v(v({}, i.config.series[n]), {}, { name: t.name ? t.name : o && o.name, color: t.color ? t.color : o && o.color, type: t.type ? t.type : o && o.type, group: t.group ? t.group : o && o.group, data: t.data ? t.data : o && o.data });
    } }, { key: "toggleDataPointSelection", value: function(t, n) {
      var i = this.w, o = null, d = ".apexcharts-series[data\\:realIndex='".concat(t, "']");
      return i.globals.axisCharts ? o = i.globals.dom.Paper.select("".concat(d, " path[j='").concat(n, "'], ").concat(d, " circle[j='").concat(n, "'], ").concat(d, " rect[j='").concat(n, "']")).members[0] : n === void 0 && (o = i.globals.dom.Paper.select("".concat(d, " path[j='").concat(t, "']")).members[0], i.config.chart.type !== "pie" && i.config.chart.type !== "polarArea" && i.config.chart.type !== "donut" || this.ctx.pie.pieClicked(t)), o ? (new re(this.ctx).pathMouseDown(o, null), o.node ? o.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
    } }, { key: "forceXAxisUpdate", value: function(t) {
      var n = this.w;
      if (["min", "max"].forEach(function(o) {
        t.xaxis[o] !== void 0 && (n.config.xaxis[o] = t.xaxis[o], n.globals.lastXAxis[o] = t.xaxis[o]);
      }), t.xaxis.categories && t.xaxis.categories.length && (n.config.xaxis.categories = t.xaxis.categories), n.config.xaxis.convertedCatToNumeric) {
        var i = new We(t);
        t = i.convertCatToNumericXaxis(t, this.ctx);
      }
      return t;
    } }, { key: "forceYAxisUpdate", value: function(t) {
      return t.chart && t.chart.stacked && t.chart.stackType === "100%" && (Array.isArray(t.yaxis) ? t.yaxis.forEach(function(n, i) {
        t.yaxis[i].min = 0, t.yaxis[i].max = 100;
      }) : (t.yaxis.min = 0, t.yaxis.max = 100)), t;
    } }, { key: "revertDefaultAxisMinMax", value: function(t) {
      var n = this, i = this.w, o = i.globals.lastXAxis, d = i.globals.lastYAxis;
      t && t.xaxis && (o = t.xaxis), t && t.yaxis && (d = t.yaxis), i.config.xaxis.min = o.min, i.config.xaxis.max = o.max;
      var f = function(p) {
        d[p] !== void 0 && (i.config.yaxis[p].min = d[p].min, i.config.yaxis[p].max = d[p].max);
      };
      i.config.yaxis.map(function(p, y) {
        i.globals.zoomed || d[y] !== void 0 ? f(y) : n.ctx.opts.yaxis[y] !== void 0 && (p.min = n.ctx.opts.yaxis[y].min, p.max = n.ctx.opts.yaxis[y].max);
      });
    } }]), B;
  }();
  ai = typeof window < "u" ? window : void 0, le = function(B, t) {
    var n = (this !== void 0 ? this : B).SVG = function(b) {
      if (n.supported)
        return b = new n.Doc(b), n.parser.draw || n.prepare(), b;
    };
    if (n.ns = "http://www.w3.org/2000/svg", n.xmlns = "http://www.w3.org/2000/xmlns/", n.xlink = "http://www.w3.org/1999/xlink", n.svgjs = "http://svgjs.dev", n.supported = !0, !n.supported)
      return !1;
    n.did = 1e3, n.eid = function(b) {
      return "Svgjs" + A(b) + n.did++;
    }, n.create = function(b) {
      var M = t.createElementNS(this.ns, b);
      return M.setAttribute("id", this.eid(b)), M;
    }, n.extend = function() {
      var b, M;
      M = (b = [].slice.call(arguments)).pop();
      for (var N = b.length - 1; N >= 0; N--)
        if (b[N])
          for (var X in M)
            b[N].prototype[X] = M[X];
      n.Set && n.Set.inherit && n.Set.inherit();
    }, n.invent = function(b) {
      var M = typeof b.create == "function" ? b.create : function() {
        this.constructor.call(this, n.create(b.create));
      };
      return b.inherit && (M.prototype = new b.inherit()), b.extend && n.extend(M, b.extend), b.construct && n.extend(b.parent || n.Container, b.construct), M;
    }, n.adopt = function(b) {
      return b ? b.instance ? b.instance : ((M = b.nodeName == "svg" ? b.parentNode instanceof B.SVGElement ? new n.Nested() : new n.Doc() : b.nodeName == "linearGradient" ? new n.Gradient("linear") : b.nodeName == "radialGradient" ? new n.Gradient("radial") : n[A(b.nodeName)] ? new n[A(b.nodeName)]() : new n.Element(b)).type = b.nodeName, M.node = b, b.instance = M, M instanceof n.Doc && M.namespace().defs(), M.setData(JSON.parse(b.getAttribute("svgjs:data")) || {}), M) : null;
      var M;
    }, n.prepare = function() {
      var b = t.getElementsByTagName("body")[0], M = (b ? new n.Doc(b) : n.adopt(t.documentElement).nested()).size(2, 0);
      n.parser = { body: b || t.documentElement, draw: M.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node, poly: M.polyline().node, path: M.path().node, native: n.create("svg") };
    }, n.parser = { native: n.create("svg") }, t.addEventListener("DOMContentLoaded", function() {
      n.parser.draw || n.prepare();
    }, !1), n.regex = { numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, rgb: /rgb\((\d+),(\d+),(\d+)\)/, reference: /#([a-z0-9\-_]+)/i, transforms: /\)\s*,?\s*/, whitespace: /\s/g, isHex: /^#[a-f0-9]{3,6}$/i, isRgb: /^rgb\(/, isCss: /[^:]+:[^;]+;?/, isBlank: /^(\s+)?$/, isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, isPercent: /^-?[\d\.]+%$/, isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, delimiter: /[\s,]+/, hyphen: /([^e])\-/gi, pathLetters: /[MLHVCSQTAZ]/gi, isPathLetter: /[MLHVCSQTAZ]/i, numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi, dots: /\./g }, n.utils = { map: function(b, M) {
      for (var N = b.length, X = [], Q = 0; Q < N; Q++)
        X.push(M(b[Q]));
      return X;
    }, filter: function(b, M) {
      for (var N = b.length, X = [], Q = 0; Q < N; Q++)
        M(b[Q]) && X.push(b[Q]);
      return X;
    }, filterSVGElements: function(b) {
      return this.filter(b, function(M) {
        return M instanceof B.SVGElement;
      });
    } }, n.defaults = { attrs: { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "font-size": 16, "font-family": "Helvetica, Arial, sans-serif", "text-anchor": "start" } }, n.Color = function(b) {
      var M, N;
      this.r = 0, this.g = 0, this.b = 0, b && (typeof b == "string" ? n.regex.isRgb.test(b) ? (M = n.regex.rgb.exec(b.replace(n.regex.whitespace, "")), this.r = parseInt(M[1]), this.g = parseInt(M[2]), this.b = parseInt(M[3])) : n.regex.isHex.test(b) && (M = n.regex.hex.exec((N = b).length == 4 ? ["#", N.substring(1, 2), N.substring(1, 2), N.substring(2, 3), N.substring(2, 3), N.substring(3, 4), N.substring(3, 4)].join("") : N), this.r = parseInt(M[1], 16), this.g = parseInt(M[2], 16), this.b = parseInt(M[3], 16)) : w(b) === "object" && (this.r = b.r, this.g = b.g, this.b = b.b));
    }, n.extend(n.Color, { toString: function() {
      return this.toHex();
    }, toHex: function() {
      return "#" + E(this.r) + E(this.g) + E(this.b);
    }, toRgb: function() {
      return "rgb(" + [this.r, this.g, this.b].join() + ")";
    }, brightness: function() {
      return this.r / 255 * 0.3 + this.g / 255 * 0.59 + this.b / 255 * 0.11;
    }, morph: function(b) {
      return this.destination = new n.Color(b), this;
    }, at: function(b) {
      return this.destination ? (b = b < 0 ? 0 : b > 1 ? 1 : b, new n.Color({ r: ~~(this.r + (this.destination.r - this.r) * b), g: ~~(this.g + (this.destination.g - this.g) * b), b: ~~(this.b + (this.destination.b - this.b) * b) })) : this;
    } }), n.Color.test = function(b) {
      return b += "", n.regex.isHex.test(b) || n.regex.isRgb.test(b);
    }, n.Color.isRgb = function(b) {
      return b && typeof b.r == "number" && typeof b.g == "number" && typeof b.b == "number";
    }, n.Color.isColor = function(b) {
      return n.Color.isRgb(b) || n.Color.test(b);
    }, n.Array = function(b, M) {
      (b = (b || []).valueOf()).length == 0 && M && (b = M.valueOf()), this.value = this.parse(b);
    }, n.extend(n.Array, { toString: function() {
      return this.value.join(" ");
    }, valueOf: function() {
      return this.value;
    }, parse: function(b) {
      return b = b.valueOf(), Array.isArray(b) ? b : this.split(b);
    } }), n.PointArray = function(b, M) {
      n.Array.call(this, b, M || [[0, 0]]);
    }, n.PointArray.prototype = new n.Array(), n.PointArray.prototype.constructor = n.PointArray;
    for (var i = { M: function(b, M, N) {
      return M.x = N.x = b[0], M.y = N.y = b[1], ["M", M.x, M.y];
    }, L: function(b, M) {
      return M.x = b[0], M.y = b[1], ["L", b[0], b[1]];
    }, H: function(b, M) {
      return M.x = b[0], ["H", b[0]];
    }, V: function(b, M) {
      return M.y = b[0], ["V", b[0]];
    }, C: function(b, M) {
      return M.x = b[4], M.y = b[5], ["C", b[0], b[1], b[2], b[3], b[4], b[5]];
    }, Q: function(b, M) {
      return M.x = b[2], M.y = b[3], ["Q", b[0], b[1], b[2], b[3]];
    }, S: function(b, M) {
      return M.x = b[2], M.y = b[3], ["S", b[0], b[1], b[2], b[3]];
    }, Z: function(b, M, N) {
      return M.x = N.x, M.y = N.y, ["Z"];
    } }, o = "mlhvqtcsaz".split(""), d = 0, f = o.length; d < f; ++d)
      i[o[d]] = function(b) {
        return function(M, N, X) {
          if (b == "H")
            M[0] = M[0] + N.x;
          else if (b == "V")
            M[0] = M[0] + N.y;
          else if (b == "A")
            M[5] = M[5] + N.x, M[6] = M[6] + N.y;
          else
            for (var Q = 0, ee = M.length; Q < ee; ++Q)
              M[Q] = M[Q] + (Q % 2 ? N.y : N.x);
          if (i && typeof i[b] == "function")
            return i[b](M, N, X);
        };
      }(o[d].toUpperCase());
    n.PathArray = function(b, M) {
      n.Array.call(this, b, M || [["M", 0, 0]]);
    }, n.PathArray.prototype = new n.Array(), n.PathArray.prototype.constructor = n.PathArray, n.extend(n.PathArray, { toString: function() {
      return function(b) {
        for (var M = 0, N = b.length, X = ""; M < N; M++)
          X += b[M][0], b[M][1] != null && (X += b[M][1], b[M][2] != null && (X += " ", X += b[M][2], b[M][3] != null && (X += " ", X += b[M][3], X += " ", X += b[M][4], b[M][5] != null && (X += " ", X += b[M][5], X += " ", X += b[M][6], b[M][7] != null && (X += " ", X += b[M][7])))));
        return X + " ";
      }(this.value);
    }, move: function(b, M) {
      var N = this.bbox();
      return N.x, N.y, this;
    }, at: function(b) {
      if (!this.destination)
        return this;
      for (var M = this.value, N = this.destination.value, X = [], Q = new n.PathArray(), ee = 0, oe = M.length; ee < oe; ee++) {
        X[ee] = [M[ee][0]];
        for (var fe = 1, ke = M[ee].length; fe < ke; fe++)
          X[ee][fe] = M[ee][fe] + (N[ee][fe] - M[ee][fe]) * b;
        X[ee][0] === "A" && (X[ee][4] = +(X[ee][4] != 0), X[ee][5] = +(X[ee][5] != 0));
      }
      return Q.value = X, Q;
    }, parse: function(b) {
      if (b instanceof n.PathArray)
        return b.valueOf();
      var M, N = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 };
      b = typeof b == "string" ? b.replace(n.regex.numbersWithDots, y).replace(n.regex.pathLetters, " $& ").replace(n.regex.hyphen, "$1 -").trim().split(n.regex.delimiter) : b.reduce(function(ke, _e) {
        return [].concat.call(ke, _e);
      }, []);
      var X = [], Q = new n.Point(), ee = new n.Point(), oe = 0, fe = b.length;
      do
        n.regex.isPathLetter.test(b[oe]) ? (M = b[oe], ++oe) : M == "M" ? M = "L" : M == "m" && (M = "l"), X.push(i[M].call(null, b.slice(oe, oe += N[M.toUpperCase()]).map(parseFloat), Q, ee));
      while (fe > oe);
      return X;
    }, bbox: function() {
      return n.parser.draw || n.prepare(), n.parser.path.setAttribute("d", this.toString()), n.parser.path.getBBox();
    } }), n.Number = n.invent({ create: function(b, M) {
      this.value = 0, this.unit = M || "", typeof b == "number" ? this.value = isNaN(b) ? 0 : isFinite(b) ? b : b < 0 ? -34e37 : 34e37 : typeof b == "string" ? (M = b.match(n.regex.numberAndUnit)) && (this.value = parseFloat(M[1]), M[5] == "%" ? this.value /= 100 : M[5] == "s" && (this.value *= 1e3), this.unit = M[5]) : b instanceof n.Number && (this.value = b.valueOf(), this.unit = b.unit);
    }, extend: { toString: function() {
      return (this.unit == "%" ? ~~(1e8 * this.value) / 1e6 : this.unit == "s" ? this.value / 1e3 : this.value) + this.unit;
    }, toJSON: function() {
      return this.toString();
    }, valueOf: function() {
      return this.value;
    }, plus: function(b) {
      return b = new n.Number(b), new n.Number(this + b, this.unit || b.unit);
    }, minus: function(b) {
      return b = new n.Number(b), new n.Number(this - b, this.unit || b.unit);
    }, times: function(b) {
      return b = new n.Number(b), new n.Number(this * b, this.unit || b.unit);
    }, divide: function(b) {
      return b = new n.Number(b), new n.Number(this / b, this.unit || b.unit);
    }, to: function(b) {
      var M = new n.Number(this);
      return typeof b == "string" && (M.unit = b), M;
    }, morph: function(b) {
      return this.destination = new n.Number(b), b.relative && (this.destination.value += this.value), this;
    }, at: function(b) {
      return this.destination ? new n.Number(this.destination).minus(this).times(b).plus(this) : this;
    } } }), n.Element = n.invent({ create: function(b) {
      this._stroke = n.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = b) && (this.type = b.nodeName, this.node.instance = this, this._stroke = b.getAttribute("stroke") || this._stroke);
    }, extend: { x: function(b) {
      return this.attr("x", b);
    }, y: function(b) {
      return this.attr("y", b);
    }, cx: function(b) {
      return b == null ? this.x() + this.width() / 2 : this.x(b - this.width() / 2);
    }, cy: function(b) {
      return b == null ? this.y() + this.height() / 2 : this.y(b - this.height() / 2);
    }, move: function(b, M) {
      return this.x(b).y(M);
    }, center: function(b, M) {
      return this.cx(b).cy(M);
    }, width: function(b) {
      return this.attr("width", b);
    }, height: function(b) {
      return this.attr("height", b);
    }, size: function(b, M) {
      var N = L(this, b, M);
      return this.width(new n.Number(N.width)).height(new n.Number(N.height));
    }, clone: function(b) {
      this.writeDataToDom();
      var M = I(this.node.cloneNode(!0));
      return b ? b.add(M) : this.after(M), M;
    }, remove: function() {
      return this.parent() && this.parent().removeElement(this), this;
    }, replace: function(b) {
      return this.after(b).remove(), b;
    }, addTo: function(b) {
      return b.put(this);
    }, putIn: function(b) {
      return b.add(this);
    }, id: function(b) {
      return this.attr("id", b);
    }, show: function() {
      return this.style("display", "");
    }, hide: function() {
      return this.style("display", "none");
    }, visible: function() {
      return this.style("display") != "none";
    }, toString: function() {
      return this.attr("id");
    }, classes: function() {
      var b = this.attr("class");
      return b == null ? [] : b.trim().split(n.regex.delimiter);
    }, hasClass: function(b) {
      return this.classes().indexOf(b) != -1;
    }, addClass: function(b) {
      if (!this.hasClass(b)) {
        var M = this.classes();
        M.push(b), this.attr("class", M.join(" "));
      }
      return this;
    }, removeClass: function(b) {
      return this.hasClass(b) && this.attr("class", this.classes().filter(function(M) {
        return M != b;
      }).join(" ")), this;
    }, toggleClass: function(b) {
      return this.hasClass(b) ? this.removeClass(b) : this.addClass(b);
    }, reference: function(b) {
      return n.get(this.attr(b));
    }, parent: function(b) {
      var M = this;
      if (!M.node.parentNode)
        return null;
      if (M = n.adopt(M.node.parentNode), !b)
        return M;
      for (; M && M.node instanceof B.SVGElement; ) {
        if (typeof b == "string" ? M.matches(b) : M instanceof b)
          return M;
        if (!M.node.parentNode || M.node.parentNode.nodeName == "#document")
          return null;
        M = n.adopt(M.node.parentNode);
      }
    }, doc: function() {
      return this instanceof n.Doc ? this : this.parent(n.Doc);
    }, parents: function(b) {
      var M = [], N = this;
      do {
        if (!(N = N.parent(b)) || !N.node)
          break;
        M.push(N);
      } while (N.parent);
      return M;
    }, matches: function(b) {
      return function(M, N) {
        return (M.matches || M.matchesSelector || M.msMatchesSelector || M.mozMatchesSelector || M.webkitMatchesSelector || M.oMatchesSelector).call(M, N);
      }(this.node, b);
    }, native: function() {
      return this.node;
    }, svg: function(b) {
      var M = t.createElement("svg");
      if (!(b && this instanceof n.Parent))
        return M.appendChild(b = t.createElement("svg")), this.writeDataToDom(), b.appendChild(this.node.cloneNode(!0)), M.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
      M.innerHTML = "<svg>" + b.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
      for (var N = 0, X = M.firstChild.childNodes.length; N < X; N++)
        this.node.appendChild(M.firstChild.firstChild);
      return this;
    }, writeDataToDom: function() {
      return (this.each || this.lines) && (this.each ? this : this.lines()).each(function() {
        this.writeDataToDom();
      }), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this;
    }, setData: function(b) {
      return this.dom = b, this;
    }, is: function(b) {
      return function(M, N) {
        return M instanceof N;
      }(this, b);
    } } }), n.easing = { "-": function(b) {
      return b;
    }, "<>": function(b) {
      return -Math.cos(b * Math.PI) / 2 + 0.5;
    }, ">": function(b) {
      return Math.sin(b * Math.PI / 2);
    }, "<": function(b) {
      return 1 - Math.cos(b * Math.PI / 2);
    } }, n.morph = function(b) {
      return function(M, N) {
        return new n.MorphObj(M, N).at(b);
      };
    }, n.Situation = n.invent({ create: function(b) {
      this.init = !1, this.reversed = !1, this.reversing = !1, this.duration = new n.Number(b.duration).valueOf(), this.delay = new n.Number(b.delay).valueOf(), this.start = +/* @__PURE__ */ new Date() + this.delay, this.finish = this.start + this.duration, this.ease = b.ease, this.loop = 0, this.loops = !1, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {};
    } }), n.FX = n.invent({ create: function(b) {
      this._target = b, this.situations = [], this.active = !1, this.situation = null, this.paused = !1, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1;
    }, extend: { animate: function(b, M, N) {
      w(b) === "object" && (M = b.ease, N = b.delay, b = b.duration);
      var X = new n.Situation({ duration: b || 1e3, delay: N || 0, ease: n.easing[M || "-"] || M });
      return this.queue(X), this;
    }, target: function(b) {
      return b && b instanceof n.Element ? (this._target = b, this) : this._target;
    }, timeToAbsPos: function(b) {
      return (b - this.situation.start) / (this.situation.duration / this._speed);
    }, absPosToTime: function(b) {
      return this.situation.duration / this._speed * b + this.situation.start;
    }, startAnimFrame: function() {
      this.stopAnimFrame(), this.animationFrame = B.requestAnimationFrame((function() {
        this.step();
      }).bind(this));
    }, stopAnimFrame: function() {
      B.cancelAnimationFrame(this.animationFrame);
    }, start: function() {
      return !this.active && this.situation && (this.active = !0, this.startCurrent()), this;
    }, startCurrent: function() {
      return this.situation.start = +/* @__PURE__ */ new Date() + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step();
    }, queue: function(b) {
      return (typeof b == "function" || b instanceof n.Situation) && this.situations.push(b), this.situation || (this.situation = this.situations.shift()), this;
    }, dequeue: function() {
      return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof n.Situation ? this.start() : this.situation.call(this)), this;
    }, initAnimations: function() {
      var b, M = this.situation;
      if (M.init)
        return this;
      for (var N in M.animations) {
        b = this.target()[N](), Array.isArray(b) || (b = [b]), Array.isArray(M.animations[N]) || (M.animations[N] = [M.animations[N]]);
        for (var X = b.length; X--; )
          M.animations[N][X] instanceof n.Number && (b[X] = new n.Number(b[X])), M.animations[N][X] = b[X].morph(M.animations[N][X]);
      }
      for (var N in M.attrs)
        M.attrs[N] = new n.MorphObj(this.target().attr(N), M.attrs[N]);
      for (var N in M.styles)
        M.styles[N] = new n.MorphObj(this.target().style(N), M.styles[N]);
      return M.initialTransformation = this.target().matrixify(), M.init = !0, this;
    }, clearQueue: function() {
      return this.situations = [], this;
    }, clearCurrent: function() {
      return this.situation = null, this;
    }, stop: function(b, M) {
      var N = this.active;
      return this.active = !1, M && this.clearQueue(), b && this.situation && (!N && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent();
    }, after: function(b) {
      var M = this.last();
      return this.target().on("finished.fx", function N(X) {
        X.detail.situation == M && (b.call(this, M), this.off("finished.fx", N));
      }), this._callStart();
    }, during: function(b) {
      var M = this.last(), N = function(X) {
        X.detail.situation == M && b.call(this, X.detail.pos, n.morph(X.detail.pos), X.detail.eased, M);
      };
      return this.target().off("during.fx", N).on("during.fx", N), this.after(function() {
        this.off("during.fx", N);
      }), this._callStart();
    }, afterAll: function(b) {
      var M = function N(X) {
        b.call(this), this.off("allfinished.fx", N);
      };
      return this.target().off("allfinished.fx", M).on("allfinished.fx", M), this._callStart();
    }, last: function() {
      return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;
    }, add: function(b, M, N) {
      return this.last()[N || "animations"][b] = M, this._callStart();
    }, step: function(b) {
      var M, N, X;
      b || (this.absPos = this.timeToAbsPos(+/* @__PURE__ */ new Date())), this.situation.loops !== !1 ? (M = Math.max(this.absPos, 0), N = Math.floor(M), this.situation.loops === !0 || N < this.situation.loops ? (this.pos = M - N, X = this.situation.loop, this.situation.loop = N) : (this.absPos = this.situation.loops, this.pos = 1, X = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != !!((this.situation.loop - X) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
      var Q = this.situation.ease(this.pos);
      for (var ee in this.situation.once)
        ee > this.lastPos && ee <= Q && (this.situation.once[ee].call(this.target(), this.pos, Q), delete this.situation.once[ee]);
      return this.active && this.target().fire("during", { pos: this.pos, eased: Q, fx: this, situation: this.situation }), this.situation ? (this.eachAt(), this.pos == 1 && !this.situation.reversed || this.situation.reversed && this.pos == 0 ? (this.stopAnimFrame(), this.target().fire("finished", { fx: this, situation: this.situation }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = !1)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = Q, this) : this;
    }, eachAt: function() {
      var b, M = this, N = this.target(), X = this.situation;
      for (var Q in X.animations)
        b = [].concat(X.animations[Q]).map(function(fe) {
          return typeof fe != "string" && fe.at ? fe.at(X.ease(M.pos), M.pos) : fe;
        }), N[Q].apply(N, b);
      for (var Q in X.attrs)
        b = [Q].concat(X.attrs[Q]).map(function(ke) {
          return typeof ke != "string" && ke.at ? ke.at(X.ease(M.pos), M.pos) : ke;
        }), N.attr.apply(N, b);
      for (var Q in X.styles)
        b = [Q].concat(X.styles[Q]).map(function(ke) {
          return typeof ke != "string" && ke.at ? ke.at(X.ease(M.pos), M.pos) : ke;
        }), N.style.apply(N, b);
      if (X.transforms.length) {
        b = X.initialTransformation, Q = 0;
        for (var ee = X.transforms.length; Q < ee; Q++) {
          var oe = X.transforms[Q];
          oe instanceof n.Matrix ? b = oe.relative ? b.multiply(new n.Matrix().morph(oe).at(X.ease(this.pos))) : b.morph(oe).at(X.ease(this.pos)) : (oe.relative || oe.undo(b.extract()), b = b.multiply(oe.at(X.ease(this.pos))));
        }
        N.matrix(b);
      }
      return this;
    }, once: function(b, M, N) {
      var X = this.last();
      return N || (b = X.ease(b)), X.once[b] = M, this;
    }, _callStart: function() {
      return setTimeout((function() {
        this.start();
      }).bind(this), 0), this;
    } }, parent: n.Element, construct: { animate: function(b, M, N) {
      return (this.fx || (this.fx = new n.FX(this))).animate(b, M, N);
    }, delay: function(b) {
      return (this.fx || (this.fx = new n.FX(this))).delay(b);
    }, stop: function(b, M) {
      return this.fx && this.fx.stop(b, M), this;
    }, finish: function() {
      return this.fx && this.fx.finish(), this;
    } } }), n.MorphObj = n.invent({ create: function(b, M) {
      return n.Color.isColor(M) ? new n.Color(b).morph(M) : n.regex.delimiter.test(b) ? n.regex.pathLetters.test(b) ? new n.PathArray(b).morph(M) : new n.Array(b).morph(M) : n.regex.numberAndUnit.test(M) ? new n.Number(b).morph(M) : (this.value = b, void (this.destination = M));
    }, extend: { at: function(b, M) {
      return M < 1 ? this.value : this.destination;
    }, valueOf: function() {
      return this.value;
    } } }), n.extend(n.FX, { attr: function(b, M, N) {
      if (w(b) === "object")
        for (var X in b)
          this.attr(X, b[X]);
      else
        this.add(b, M, "attrs");
      return this;
    }, plot: function(b, M, N, X) {
      return arguments.length == 4 ? this.plot([b, M, N, X]) : this.add("plot", new (this.target()).morphArray(b));
    } }), n.Box = n.invent({ create: function(b, M, N, X) {
      if (!(w(b) !== "object" || b instanceof n.Element))
        return n.Box.call(this, b.left != null ? b.left : b.x, b.top != null ? b.top : b.y, b.width, b.height);
      var Q;
      arguments.length == 4 && (this.x = b, this.y = M, this.width = N, this.height = X), (Q = this).x == null && (Q.x = 0, Q.y = 0, Q.width = 0, Q.height = 0), Q.w = Q.width, Q.h = Q.height, Q.x2 = Q.x + Q.width, Q.y2 = Q.y + Q.height, Q.cx = Q.x + Q.width / 2, Q.cy = Q.y + Q.height / 2;
    } }), n.BBox = n.invent({ create: function(b) {
      if (n.Box.apply(this, [].slice.call(arguments)), b instanceof n.Element) {
        var M;
        try {
          if (!t.documentElement.contains) {
            for (var N = b.node; N.parentNode; )
              N = N.parentNode;
            if (N != t)
              throw new Error("Element not in the dom");
          }
          M = b.node.getBBox();
        } catch {
          if (b instanceof n.Shape) {
            n.parser.draw || n.prepare();
            var X = b.clone(n.parser.draw.instance).show();
            X && X.node && typeof X.node.getBBox == "function" && (M = X.node.getBBox()), X && typeof X.remove == "function" && X.remove();
          } else
            M = { x: b.node.clientLeft, y: b.node.clientTop, width: b.node.clientWidth, height: b.node.clientHeight };
        }
        n.Box.call(this, M);
      }
    }, inherit: n.Box, parent: n.Element, construct: { bbox: function() {
      return new n.BBox(this);
    } } }), n.BBox.prototype.constructor = n.BBox, n.Matrix = n.invent({ create: function(b) {
      var M = P([1, 0, 0, 1, 0, 0]);
      b = b === null ? M : b instanceof n.Element ? b.matrixify() : typeof b == "string" ? P(b.split(n.regex.delimiter).map(parseFloat)) : arguments.length == 6 ? P([].slice.call(arguments)) : Array.isArray(b) ? P(b) : b && w(b) === "object" ? b : M;
      for (var N = V.length - 1; N >= 0; --N)
        this[V[N]] = b[V[N]] != null ? b[V[N]] : M[V[N]];
    }, extend: { extract: function() {
      var b = O(this, 0, 1);
      O(this, 1, 0);
      var M = 180 / Math.PI * Math.atan2(b.y, b.x) - 90;
      return { x: this.e, y: this.f, transformedX: (this.e * Math.cos(M * Math.PI / 180) + this.f * Math.sin(M * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b), transformedY: (this.f * Math.cos(M * Math.PI / 180) + this.e * Math.sin(-M * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d), rotation: M, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f, matrix: new n.Matrix(this) };
    }, clone: function() {
      return new n.Matrix(this);
    }, morph: function(b) {
      return this.destination = new n.Matrix(b), this;
    }, multiply: function(b) {
      return new n.Matrix(this.native().multiply(function(M) {
        return M instanceof n.Matrix || (M = new n.Matrix(M)), M;
      }(b).native()));
    }, inverse: function() {
      return new n.Matrix(this.native().inverse());
    }, translate: function(b, M) {
      return new n.Matrix(this.native().translate(b || 0, M || 0));
    }, native: function() {
      for (var b = n.parser.native.createSVGMatrix(), M = V.length - 1; M >= 0; M--)
        b[V[M]] = this[V[M]];
      return b;
    }, toString: function() {
      return "matrix(" + j(this.a) + "," + j(this.b) + "," + j(this.c) + "," + j(this.d) + "," + j(this.e) + "," + j(this.f) + ")";
    } }, parent: n.Element, construct: { ctm: function() {
      return new n.Matrix(this.node.getCTM());
    }, screenCTM: function() {
      if (this instanceof n.Nested) {
        var b = this.rect(1, 1), M = b.node.getScreenCTM();
        return b.remove(), new n.Matrix(M);
      }
      return new n.Matrix(this.node.getScreenCTM());
    } } }), n.Point = n.invent({ create: function(b, M) {
      var N;
      N = Array.isArray(b) ? { x: b[0], y: b[1] } : w(b) === "object" ? { x: b.x, y: b.y } : b != null ? { x: b, y: M ?? b } : { x: 0, y: 0 }, this.x = N.x, this.y = N.y;
    }, extend: { clone: function() {
      return new n.Point(this);
    }, morph: function(b, M) {
      return this.destination = new n.Point(b, M), this;
    } } }), n.extend(n.Element, { point: function(b, M) {
      return new n.Point(b, M).transform(this.screenCTM().inverse());
    } }), n.extend(n.Element, { attr: function(b, M, N) {
      if (b == null) {
        for (b = {}, N = (M = this.node.attributes).length - 1; N >= 0; N--)
          b[M[N].nodeName] = n.regex.isNumber.test(M[N].nodeValue) ? parseFloat(M[N].nodeValue) : M[N].nodeValue;
        return b;
      }
      if (w(b) === "object")
        for (var X in b)
          this.attr(X, b[X]);
      else if (M === null)
        this.node.removeAttribute(b);
      else {
        if (M == null)
          return (M = this.node.getAttribute(b)) == null ? n.defaults.attrs[b] : n.regex.isNumber.test(M) ? parseFloat(M) : M;
        b == "stroke-width" ? this.attr("stroke", parseFloat(M) > 0 ? this._stroke : null) : b == "stroke" && (this._stroke = M), b != "fill" && b != "stroke" || (n.regex.isImage.test(M) && (M = this.doc().defs().image(M, 0, 0)), M instanceof n.Image && (M = this.doc().defs().pattern(0, 0, function() {
          this.add(M);
        }))), typeof M == "number" ? M = new n.Number(M) : n.Color.isColor(M) ? M = new n.Color(M) : Array.isArray(M) && (M = new n.Array(M)), b == "leading" ? this.leading && this.leading(M) : typeof N == "string" ? this.node.setAttributeNS(N, b, M.toString()) : this.node.setAttribute(b, M.toString()), !this.rebuild || b != "font-size" && b != "x" || this.rebuild(b, M);
      }
      return this;
    } }), n.extend(n.Element, { transform: function(b, M) {
      var N;
      return w(b) !== "object" ? (N = new n.Matrix(this).extract(), typeof b == "string" ? N[b] : N) : (N = new n.Matrix(this), M = !!M || !!b.relative, b.a != null && (N = M ? N.multiply(new n.Matrix(b)) : new n.Matrix(b)), this.attr("transform", N));
    } }), n.extend(n.Element, { untransform: function() {
      return this.attr("transform", null);
    }, matrixify: function() {
      return (this.attr("transform") || "").split(n.regex.transforms).slice(0, -1).map(function(b) {
        var M = b.trim().split("(");
        return [M[0], M[1].split(n.regex.delimiter).map(function(N) {
          return parseFloat(N);
        })];
      }).reduce(function(b, M) {
        return M[0] == "matrix" ? b.multiply(P(M[1])) : b[M[0]].apply(b, M[1]);
      }, new n.Matrix());
    }, toParent: function(b) {
      if (this == b)
        return this;
      var M = this.screenCTM(), N = b.screenCTM().inverse();
      return this.addTo(b).untransform().transform(N.multiply(M)), this;
    }, toDoc: function() {
      return this.toParent(this.doc());
    } }), n.Transformation = n.invent({ create: function(b, M) {
      if (arguments.length > 1 && typeof M != "boolean")
        return this.constructor.call(this, [].slice.call(arguments));
      if (Array.isArray(b))
        for (var N = 0, X = this.arguments.length; N < X; ++N)
          this[this.arguments[N]] = b[N];
      else if (b && w(b) === "object")
        for (N = 0, X = this.arguments.length; N < X; ++N)
          this[this.arguments[N]] = b[this.arguments[N]];
      this.inversed = !1, M === !0 && (this.inversed = !0);
    } }), n.Translate = n.invent({ parent: n.Matrix, inherit: n.Transformation, create: function(b, M) {
      this.constructor.apply(this, [].slice.call(arguments));
    }, extend: { arguments: ["transformedX", "transformedY"], method: "translate" } }), n.extend(n.Element, { style: function(b, M) {
      if (arguments.length == 0)
        return this.node.style.cssText || "";
      if (arguments.length < 2)
        if (w(b) === "object")
          for (var N in b)
            this.style(N, b[N]);
        else {
          if (!n.regex.isCss.test(b))
            return this.node.style[S(b)];
          for (b = b.split(/\s*;\s*/).filter(function(X) {
            return !!X;
          }).map(function(X) {
            return X.split(/\s*:\s*/);
          }); M = b.pop(); )
            this.style(M[0], M[1]);
        }
      else
        this.node.style[S(b)] = M === null || n.regex.isBlank.test(M) ? "" : M;
      return this;
    } }), n.Parent = n.invent({ create: function(b) {
      this.constructor.call(this, b);
    }, inherit: n.Element, extend: { children: function() {
      return n.utils.map(n.utils.filterSVGElements(this.node.childNodes), function(b) {
        return n.adopt(b);
      });
    }, add: function(b, M) {
      return M == null ? this.node.appendChild(b.node) : b.node != this.node.childNodes[M] && this.node.insertBefore(b.node, this.node.childNodes[M]), this;
    }, put: function(b, M) {
      return this.add(b, M), b;
    }, has: function(b) {
      return this.index(b) >= 0;
    }, index: function(b) {
      return [].slice.call(this.node.childNodes).indexOf(b.node);
    }, get: function(b) {
      return n.adopt(this.node.childNodes[b]);
    }, first: function() {
      return this.get(0);
    }, last: function() {
      return this.get(this.node.childNodes.length - 1);
    }, each: function(b, M) {
      for (var N = this.children(), X = 0, Q = N.length; X < Q; X++)
        N[X] instanceof n.Element && b.apply(N[X], [X, N]), M && N[X] instanceof n.Container && N[X].each(b, M);
      return this;
    }, removeElement: function(b) {
      return this.node.removeChild(b.node), this;
    }, clear: function() {
      for (; this.node.hasChildNodes(); )
        this.node.removeChild(this.node.lastChild);
      return delete this._defs, this;
    }, defs: function() {
      return this.doc().defs();
    } } }), n.extend(n.Parent, { ungroup: function(b, M) {
      return M === 0 || this instanceof n.Defs || this.node == n.parser.draw || (b = b || (this instanceof n.Doc ? this : this.parent(n.Parent)), M = M || 1 / 0, this.each(function() {
        return this instanceof n.Defs ? this : this instanceof n.Parent ? this.ungroup(b, M - 1) : this.toParent(b);
      }), this.node.firstChild || this.remove()), this;
    }, flatten: function(b, M) {
      return this.ungroup(b, M);
    } }), n.Container = n.invent({ create: function(b) {
      this.constructor.call(this, b);
    }, inherit: n.Parent }), n.ViewBox = n.invent({ parent: n.Container, construct: {} }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function(b) {
      n.Element.prototype[b] = function(M) {
        return n.on(this.node, b, M), this;
      };
    }), n.listeners = [], n.handlerMap = [], n.listenerId = 0, n.on = function(b, M, N, X, Q) {
      var ee = N.bind(X || b.instance || b), oe = (n.handlerMap.indexOf(b) + 1 || n.handlerMap.push(b)) - 1, fe = M.split(".")[0], ke = M.split(".")[1] || "*";
      n.listeners[oe] = n.listeners[oe] || {}, n.listeners[oe][fe] = n.listeners[oe][fe] || {}, n.listeners[oe][fe][ke] = n.listeners[oe][fe][ke] || {}, N._svgjsListenerId || (N._svgjsListenerId = ++n.listenerId), n.listeners[oe][fe][ke][N._svgjsListenerId] = ee, b.addEventListener(fe, ee, Q || { passive: !0 });
    }, n.off = function(b, M, N) {
      var X = n.handlerMap.indexOf(b), Q = M && M.split(".")[0], ee = M && M.split(".")[1], oe = "";
      if (X != -1)
        if (N) {
          if (typeof N == "function" && (N = N._svgjsListenerId), !N)
            return;
          n.listeners[X][Q] && n.listeners[X][Q][ee || "*"] && (b.removeEventListener(Q, n.listeners[X][Q][ee || "*"][N], !1), delete n.listeners[X][Q][ee || "*"][N]);
        } else if (ee && Q) {
          if (n.listeners[X][Q] && n.listeners[X][Q][ee]) {
            for (var fe in n.listeners[X][Q][ee])
              n.off(b, [Q, ee].join("."), fe);
            delete n.listeners[X][Q][ee];
          }
        } else if (ee)
          for (var ke in n.listeners[X])
            for (var oe in n.listeners[X][ke])
              ee === oe && n.off(b, [ke, ee].join("."));
        else if (Q) {
          if (n.listeners[X][Q]) {
            for (var oe in n.listeners[X][Q])
              n.off(b, [Q, oe].join("."));
            delete n.listeners[X][Q];
          }
        } else {
          for (var ke in n.listeners[X])
            n.off(b, ke);
          delete n.listeners[X], delete n.handlerMap[X];
        }
    }, n.extend(n.Element, { on: function(b, M, N, X) {
      return n.on(this.node, b, M, N, X), this;
    }, off: function(b, M) {
      return n.off(this.node, b, M), this;
    }, fire: function(b, M) {
      return b instanceof B.Event ? this.node.dispatchEvent(b) : this.node.dispatchEvent(b = new n.CustomEvent(b, { detail: M, cancelable: !0 })), this._event = b, this;
    }, event: function() {
      return this._event;
    } }), n.Defs = n.invent({ create: "defs", inherit: n.Container }), n.G = n.invent({ create: "g", inherit: n.Container, extend: { x: function(b) {
      return b == null ? this.transform("x") : this.transform({ x: b - this.x() }, !0);
    } }, construct: { group: function() {
      return this.put(new n.G());
    } } }), n.Doc = n.invent({ create: function(b) {
      b && ((b = typeof b == "string" ? t.getElementById(b) : b).nodeName == "svg" ? this.constructor.call(this, b) : (this.constructor.call(this, n.create("svg")), b.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs());
    }, inherit: n.Container, extend: { namespace: function() {
      return this.attr({ xmlns: n.ns, version: "1.1" }).attr("xmlns:xlink", n.xlink, n.xmlns).attr("xmlns:svgjs", n.svgjs, n.xmlns);
    }, defs: function() {
      var b;
      return this._defs || ((b = this.node.getElementsByTagName("defs")[0]) ? this._defs = n.adopt(b) : this._defs = new n.Defs(), this.node.appendChild(this._defs.node)), this._defs;
    }, parent: function() {
      return this.node.parentNode && this.node.parentNode.nodeName != "#document" ? this.node.parentNode : null;
    }, remove: function() {
      return this.parent() && this.parent().removeChild(this.node), this;
    }, clear: function() {
      for (; this.node.hasChildNodes(); )
        this.node.removeChild(this.node.lastChild);
      return delete this._defs, n.parser.draw && !n.parser.draw.parentNode && this.node.appendChild(n.parser.draw), this;
    }, clone: function(b) {
      this.writeDataToDom();
      var M = this.node, N = I(M.cloneNode(!0));
      return b ? (b.node || b).appendChild(N.node) : M.parentNode.insertBefore(N.node, M.nextSibling), N;
    } } }), n.extend(n.Element, {}), n.Gradient = n.invent({ create: function(b) {
      this.constructor.call(this, n.create(b + "Gradient")), this.type = b;
    }, inherit: n.Container, extend: { at: function(b, M, N) {
      return this.put(new n.Stop()).update(b, M, N);
    }, update: function(b) {
      return this.clear(), typeof b == "function" && b.call(this, this), this;
    }, fill: function() {
      return "url(#" + this.id() + ")";
    }, toString: function() {
      return this.fill();
    }, attr: function(b, M, N) {
      return b == "transform" && (b = "gradientTransform"), n.Container.prototype.attr.call(this, b, M, N);
    } }, construct: { gradient: function(b, M) {
      return this.defs().gradient(b, M);
    } } }), n.extend(n.Gradient, n.FX, { from: function(b, M) {
      return (this._target || this).type == "radial" ? this.attr({ fx: new n.Number(b), fy: new n.Number(M) }) : this.attr({ x1: new n.Number(b), y1: new n.Number(M) });
    }, to: function(b, M) {
      return (this._target || this).type == "radial" ? this.attr({ cx: new n.Number(b), cy: new n.Number(M) }) : this.attr({ x2: new n.Number(b), y2: new n.Number(M) });
    } }), n.extend(n.Defs, { gradient: function(b, M) {
      return this.put(new n.Gradient(b)).update(M);
    } }), n.Stop = n.invent({ create: "stop", inherit: n.Element, extend: { update: function(b) {
      return (typeof b == "number" || b instanceof n.Number) && (b = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), b.opacity != null && this.attr("stop-opacity", b.opacity), b.color != null && this.attr("stop-color", b.color), b.offset != null && this.attr("offset", new n.Number(b.offset)), this;
    } } }), n.Pattern = n.invent({ create: "pattern", inherit: n.Container, extend: { fill: function() {
      return "url(#" + this.id() + ")";
    }, update: function(b) {
      return this.clear(), typeof b == "function" && b.call(this, this), this;
    }, toString: function() {
      return this.fill();
    }, attr: function(b, M, N) {
      return b == "transform" && (b = "patternTransform"), n.Container.prototype.attr.call(this, b, M, N);
    } }, construct: { pattern: function(b, M, N) {
      return this.defs().pattern(b, M, N);
    } } }), n.extend(n.Defs, { pattern: function(b, M, N) {
      return this.put(new n.Pattern()).update(N).attr({ x: 0, y: 0, width: b, height: M, patternUnits: "userSpaceOnUse" });
    } }), n.Shape = n.invent({ create: function(b) {
      this.constructor.call(this, b);
    }, inherit: n.Element }), n.Symbol = n.invent({ create: "symbol", inherit: n.Container, construct: { symbol: function() {
      return this.put(new n.Symbol());
    } } }), n.Use = n.invent({ create: "use", inherit: n.Shape, extend: { element: function(b, M) {
      return this.attr("href", (M || "") + "#" + b, n.xlink);
    } }, construct: { use: function(b, M) {
      return this.put(new n.Use()).element(b, M);
    } } }), n.Rect = n.invent({ create: "rect", inherit: n.Shape, construct: { rect: function(b, M) {
      return this.put(new n.Rect()).size(b, M);
    } } }), n.Circle = n.invent({ create: "circle", inherit: n.Shape, construct: { circle: function(b) {
      return this.put(new n.Circle()).rx(new n.Number(b).divide(2)).move(0, 0);
    } } }), n.extend(n.Circle, n.FX, { rx: function(b) {
      return this.attr("r", b);
    }, ry: function(b) {
      return this.rx(b);
    } }), n.Ellipse = n.invent({ create: "ellipse", inherit: n.Shape, construct: { ellipse: function(b, M) {
      return this.put(new n.Ellipse()).size(b, M).move(0, 0);
    } } }), n.extend(n.Ellipse, n.Rect, n.FX, { rx: function(b) {
      return this.attr("rx", b);
    }, ry: function(b) {
      return this.attr("ry", b);
    } }), n.extend(n.Circle, n.Ellipse, { x: function(b) {
      return b == null ? this.cx() - this.rx() : this.cx(b + this.rx());
    }, y: function(b) {
      return b == null ? this.cy() - this.ry() : this.cy(b + this.ry());
    }, cx: function(b) {
      return b == null ? this.attr("cx") : this.attr("cx", b);
    }, cy: function(b) {
      return b == null ? this.attr("cy") : this.attr("cy", b);
    }, width: function(b) {
      return b == null ? 2 * this.rx() : this.rx(new n.Number(b).divide(2));
    }, height: function(b) {
      return b == null ? 2 * this.ry() : this.ry(new n.Number(b).divide(2));
    }, size: function(b, M) {
      var N = L(this, b, M);
      return this.rx(new n.Number(N.width).divide(2)).ry(new n.Number(N.height).divide(2));
    } }), n.Line = n.invent({ create: "line", inherit: n.Shape, extend: { array: function() {
      return new n.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
    }, plot: function(b, M, N, X) {
      return b == null ? this.array() : (b = M !== void 0 ? { x1: b, y1: M, x2: N, y2: X } : new n.PointArray(b).toLine(), this.attr(b));
    }, move: function(b, M) {
      return this.attr(this.array().move(b, M).toLine());
    }, size: function(b, M) {
      var N = L(this, b, M);
      return this.attr(this.array().size(N.width, N.height).toLine());
    } }, construct: { line: function(b, M, N, X) {
      return n.Line.prototype.plot.apply(this.put(new n.Line()), b != null ? [b, M, N, X] : [0, 0, 0, 0]);
    } } }), n.Polyline = n.invent({ create: "polyline", inherit: n.Shape, construct: { polyline: function(b) {
      return this.put(new n.Polyline()).plot(b || new n.PointArray());
    } } }), n.Polygon = n.invent({ create: "polygon", inherit: n.Shape, construct: { polygon: function(b) {
      return this.put(new n.Polygon()).plot(b || new n.PointArray());
    } } }), n.extend(n.Polyline, n.Polygon, { array: function() {
      return this._array || (this._array = new n.PointArray(this.attr("points")));
    }, plot: function(b) {
      return b == null ? this.array() : this.clear().attr("points", typeof b == "string" ? b : this._array = new n.PointArray(b));
    }, clear: function() {
      return delete this._array, this;
    }, move: function(b, M) {
      return this.attr("points", this.array().move(b, M));
    }, size: function(b, M) {
      var N = L(this, b, M);
      return this.attr("points", this.array().size(N.width, N.height));
    } }), n.extend(n.Line, n.Polyline, n.Polygon, { morphArray: n.PointArray, x: function(b) {
      return b == null ? this.bbox().x : this.move(b, this.bbox().y);
    }, y: function(b) {
      return b == null ? this.bbox().y : this.move(this.bbox().x, b);
    }, width: function(b) {
      var M = this.bbox();
      return b == null ? M.width : this.size(b, M.height);
    }, height: function(b) {
      var M = this.bbox();
      return b == null ? M.height : this.size(M.width, b);
    } }), n.Path = n.invent({ create: "path", inherit: n.Shape, extend: { morphArray: n.PathArray, array: function() {
      return this._array || (this._array = new n.PathArray(this.attr("d")));
    }, plot: function(b) {
      return b == null ? this.array() : this.clear().attr("d", typeof b == "string" ? b : this._array = new n.PathArray(b));
    }, clear: function() {
      return delete this._array, this;
    } }, construct: { path: function(b) {
      return this.put(new n.Path()).plot(b || new n.PathArray());
    } } }), n.Image = n.invent({ create: "image", inherit: n.Shape, extend: { load: function(b) {
      if (!b)
        return this;
      var M = this, N = new B.Image();
      return n.on(N, "load", function() {
        n.off(N);
        var X = M.parent(n.Pattern);
        X !== null && (M.width() == 0 && M.height() == 0 && M.size(N.width, N.height), X && X.width() == 0 && X.height() == 0 && X.size(M.width(), M.height()), typeof M._loaded == "function" && M._loaded.call(M, { width: N.width, height: N.height, ratio: N.width / N.height, url: b }));
      }), n.on(N, "error", function(X) {
        n.off(N), typeof M._error == "function" && M._error.call(M, X);
      }), this.attr("href", N.src = this.src = b, n.xlink);
    }, loaded: function(b) {
      return this._loaded = b, this;
    }, error: function(b) {
      return this._error = b, this;
    } }, construct: { image: function(b, M, N) {
      return this.put(new n.Image()).load(b).size(M || 0, N || M || 0);
    } } }), n.Text = n.invent({ create: function() {
      this.constructor.call(this, n.create("text")), this.dom.leading = new n.Number(1.3), this._rebuild = !0, this._build = !1, this.attr("font-family", n.defaults.attrs["font-family"]);
    }, inherit: n.Shape, extend: { x: function(b) {
      return b == null ? this.attr("x") : this.attr("x", b);
    }, text: function(b) {
      if (b === void 0) {
        b = "";
        for (var M = this.node.childNodes, N = 0, X = M.length; N < X; ++N)
          N != 0 && M[N].nodeType != 3 && n.adopt(M[N]).dom.newLined == 1 && (b += `
`), b += M[N].textContent;
        return b;
      }
      if (this.clear().build(!0), typeof b == "function")
        b.call(this, this);
      else {
        N = 0;
        for (var Q = (b = b.split(`
`)).length; N < Q; N++)
          this.tspan(b[N]).newLine();
      }
      return this.build(!1).rebuild();
    }, size: function(b) {
      return this.attr("font-size", b).rebuild();
    }, leading: function(b) {
      return b == null ? this.dom.leading : (this.dom.leading = new n.Number(b), this.rebuild());
    }, lines: function() {
      var b = (this.textPath && this.textPath() || this).node, M = n.utils.map(n.utils.filterSVGElements(b.childNodes), function(N) {
        return n.adopt(N);
      });
      return new n.Set(M);
    }, rebuild: function(b) {
      if (typeof b == "boolean" && (this._rebuild = b), this._rebuild) {
        var M = this, N = 0, X = this.dom.leading * new n.Number(this.attr("font-size"));
        this.lines().each(function() {
          this.dom.newLined && (M.textPath() || this.attr("x", M.attr("x")), this.text() == `
` ? N += X : (this.attr("dy", X + N), N = 0));
        }), this.fire("rebuild");
      }
      return this;
    }, build: function(b) {
      return this._build = !!b, this;
    }, setData: function(b) {
      return this.dom = b, this.dom.leading = new n.Number(b.leading || 1.3), this;
    } }, construct: { text: function(b) {
      return this.put(new n.Text()).text(b);
    }, plain: function(b) {
      return this.put(new n.Text()).plain(b);
    } } }), n.Tspan = n.invent({ create: "tspan", inherit: n.Shape, extend: { text: function(b) {
      return b == null ? this.node.textContent + (this.dom.newLined ? `
` : "") : (typeof b == "function" ? b.call(this, this) : this.plain(b), this);
    }, dx: function(b) {
      return this.attr("dx", b);
    }, dy: function(b) {
      return this.attr("dy", b);
    }, newLine: function() {
      var b = this.parent(n.Text);
      return this.dom.newLined = !0, this.dy(b.dom.leading * b.attr("font-size")).attr("x", b.x());
    } } }), n.extend(n.Text, n.Tspan, { plain: function(b) {
      return this._build === !1 && this.clear(), this.node.appendChild(t.createTextNode(b)), this;
    }, tspan: function(b) {
      var M = (this.textPath && this.textPath() || this).node, N = new n.Tspan();
      return this._build === !1 && this.clear(), M.appendChild(N.node), N.text(b);
    }, clear: function() {
      for (var b = (this.textPath && this.textPath() || this).node; b.hasChildNodes(); )
        b.removeChild(b.lastChild);
      return this;
    }, length: function() {
      return this.node.getComputedTextLength();
    } }), n.TextPath = n.invent({ create: "textPath", inherit: n.Parent, parent: n.Text, construct: { morphArray: n.PathArray, array: function() {
      var b = this.track();
      return b ? b.array() : null;
    }, plot: function(b) {
      var M = this.track(), N = null;
      return M && (N = M.plot(b)), b == null ? N : this;
    }, track: function() {
      var b = this.textPath();
      if (b)
        return b.reference("href");
    }, textPath: function() {
      if (this.node.firstChild && this.node.firstChild.nodeName == "textPath")
        return n.adopt(this.node.firstChild);
    } } }), n.Nested = n.invent({ create: function() {
      this.constructor.call(this, n.create("svg")), this.style("overflow", "visible");
    }, inherit: n.Container, construct: { nested: function() {
      return this.put(new n.Nested());
    } } });
    var p = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(b, M) {
      return M == "color" ? b : b + "-" + M;
    } };
    function y(b, M, N, X) {
      return N + X.replace(n.regex.dots, " .");
    }
    function S(b) {
      return b.toLowerCase().replace(/-(.)/g, function(M, N) {
        return N.toUpperCase();
      });
    }
    function A(b) {
      return b.charAt(0).toUpperCase() + b.slice(1);
    }
    function E(b) {
      var M = b.toString(16);
      return M.length == 1 ? "0" + M : M;
    }
    function L(b, M, N) {
      if (M == null || N == null) {
        var X = b.bbox();
        M == null ? M = X.width / X.height * N : N == null && (N = X.height / X.width * M);
      }
      return { width: M, height: N };
    }
    function O(b, M, N) {
      return { x: M * b.a + N * b.c + 0, y: M * b.b + N * b.d + 0 };
    }
    function P(b) {
      return { a: b[0], b: b[1], c: b[2], d: b[3], e: b[4], f: b[5] };
    }
    function I(b) {
      for (var M = b.childNodes.length - 1; M >= 0; M--)
        b.childNodes[M] instanceof B.SVGElement && I(b.childNodes[M]);
      return n.adopt(b).id(n.eid(b.nodeName));
    }
    function j(b) {
      return Math.abs(b) > 1e-37 ? b : 0;
    }
    ["fill", "stroke"].forEach(function(b) {
      var M = {};
      M[b] = function(N) {
        if (N === void 0)
          return this;
        if (typeof N == "string" || n.Color.isRgb(N) || N && typeof N.fill == "function")
          this.attr(b, N);
        else
          for (var X = p[b].length - 1; X >= 0; X--)
            N[p[b][X]] != null && this.attr(p.prefix(b, p[b][X]), N[p[b][X]]);
        return this;
      }, n.extend(n.Element, n.FX, M);
    }), n.extend(n.Element, n.FX, { translate: function(b, M) {
      return this.transform({ x: b, y: M });
    }, matrix: function(b) {
      return this.attr("transform", new n.Matrix(arguments.length == 6 ? [].slice.call(arguments) : b));
    }, opacity: function(b) {
      return this.attr("opacity", b);
    }, dx: function(b) {
      return this.x(new n.Number(b).plus(this instanceof n.FX ? 0 : this.x()), !0);
    }, dy: function(b) {
      return this.y(new n.Number(b).plus(this instanceof n.FX ? 0 : this.y()), !0);
    } }), n.extend(n.Path, { length: function() {
      return this.node.getTotalLength();
    }, pointAt: function(b) {
      return this.node.getPointAtLength(b);
    } }), n.Set = n.invent({ create: function(b) {
      Array.isArray(b) ? this.members = b : this.clear();
    }, extend: { add: function() {
      for (var b = [].slice.call(arguments), M = 0, N = b.length; M < N; M++)
        this.members.push(b[M]);
      return this;
    }, remove: function(b) {
      var M = this.index(b);
      return M > -1 && this.members.splice(M, 1), this;
    }, each: function(b) {
      for (var M = 0, N = this.members.length; M < N; M++)
        b.apply(this.members[M], [M, this.members]);
      return this;
    }, clear: function() {
      return this.members = [], this;
    }, length: function() {
      return this.members.length;
    }, has: function(b) {
      return this.index(b) >= 0;
    }, index: function(b) {
      return this.members.indexOf(b);
    }, get: function(b) {
      return this.members[b];
    }, first: function() {
      return this.get(0);
    }, last: function() {
      return this.get(this.members.length - 1);
    }, valueOf: function() {
      return this.members;
    } }, construct: { set: function(b) {
      return new n.Set(b);
    } } }), n.FX.Set = n.invent({ create: function(b) {
      this.set = b;
    } }), n.Set.inherit = function() {
      var b = [];
      for (var M in n.Shape.prototype)
        typeof n.Shape.prototype[M] == "function" && typeof n.Set.prototype[M] != "function" && b.push(M);
      for (var M in b.forEach(function(X) {
        n.Set.prototype[X] = function() {
          for (var Q = 0, ee = this.members.length; Q < ee; Q++)
            this.members[Q] && typeof this.members[Q][X] == "function" && this.members[Q][X].apply(this.members[Q], arguments);
          return X == "animate" ? this.fx || (this.fx = new n.FX.Set(this)) : this;
        };
      }), b = [], n.FX.prototype)
        typeof n.FX.prototype[M] == "function" && typeof n.FX.Set.prototype[M] != "function" && b.push(M);
      b.forEach(function(N) {
        n.FX.Set.prototype[N] = function() {
          for (var X = 0, Q = this.set.members.length; X < Q; X++)
            this.set.members[X].fx[N].apply(this.set.members[X].fx, arguments);
          return this;
        };
      });
    }, n.extend(n.Element, {}), n.extend(n.Element, { remember: function(b, M) {
      if (w(arguments[0]) === "object")
        for (var N in b)
          this.remember(N, b[N]);
      else {
        if (arguments.length == 1)
          return this.memory()[b];
        this.memory()[b] = M;
      }
      return this;
    }, forget: function() {
      if (arguments.length == 0)
        this._memory = {};
      else
        for (var b = arguments.length - 1; b >= 0; b--)
          delete this.memory()[arguments[b]];
      return this;
    }, memory: function() {
      return this._memory || (this._memory = {});
    } }), n.get = function(b) {
      var M = t.getElementById(function(N) {
        var X = (N || "").toString().match(n.regex.reference);
        if (X)
          return X[1];
      }(b) || b);
      return n.adopt(M);
    }, n.select = function(b, M) {
      return new n.Set(n.utils.map((M || t).querySelectorAll(b), function(N) {
        return n.adopt(N);
      }));
    }, n.extend(n.Parent, { select: function(b) {
      return n.select(b, this.node);
    } });
    var V = "abcdef".split("");
    if (typeof B.CustomEvent != "function") {
      var Z = function(b, M) {
        M = M || { bubbles: !1, cancelable: !1, detail: void 0 };
        var N = t.createEvent("CustomEvent");
        return N.initCustomEvent(b, M.bubbles, M.cancelable, M.detail), N;
      };
      Z.prototype = B.Event.prototype, n.CustomEvent = Z;
    } else
      n.CustomEvent = B.CustomEvent;
    return n;
  }, w(u) === "object" ? s.exports = ai.document ? le(ai, ai.document) : function(B) {
    return le(B, B.document);
  } : ai.SVG = le(ai, ai.document), /*! svg.filter.js - v2.0.2 - 2016-02-24
  * https://github.com/wout/svg.filter.js
  * Copyright (c) 2016 Wout Fierens; Licensed MIT */
  (function() {
    SVG.Filter = SVG.invent({ create: "filter", inherit: SVG.Parent, extend: { source: "SourceGraphic", sourceAlpha: "SourceAlpha", background: "BackgroundImage", backgroundAlpha: "BackgroundAlpha", fill: "FillPaint", stroke: "StrokePaint", autoSetIn: !0, put: function(f, p) {
      return this.add(f, p), !f.attr("in") && this.autoSetIn && f.attr("in", this.source), f.attr("result") || f.attr("result", f), f;
    }, blend: function(f, p, y) {
      return this.put(new SVG.BlendEffect(f, p, y));
    }, colorMatrix: function(f, p) {
      return this.put(new SVG.ColorMatrixEffect(f, p));
    }, convolveMatrix: function(f) {
      return this.put(new SVG.ConvolveMatrixEffect(f));
    }, componentTransfer: function(f) {
      return this.put(new SVG.ComponentTransferEffect(f));
    }, composite: function(f, p, y) {
      return this.put(new SVG.CompositeEffect(f, p, y));
    }, flood: function(f, p) {
      return this.put(new SVG.FloodEffect(f, p));
    }, offset: function(f, p) {
      return this.put(new SVG.OffsetEffect(f, p));
    }, image: function(f) {
      return this.put(new SVG.ImageEffect(f));
    }, merge: function() {
      var f = [void 0];
      for (var p in arguments)
        f.push(arguments[p]);
      return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, f))());
    }, gaussianBlur: function(f, p) {
      return this.put(new SVG.GaussianBlurEffect(f, p));
    }, morphology: function(f, p) {
      return this.put(new SVG.MorphologyEffect(f, p));
    }, diffuseLighting: function(f, p, y) {
      return this.put(new SVG.DiffuseLightingEffect(f, p, y));
    }, displacementMap: function(f, p, y, S, A) {
      return this.put(new SVG.DisplacementMapEffect(f, p, y, S, A));
    }, specularLighting: function(f, p, y, S) {
      return this.put(new SVG.SpecularLightingEffect(f, p, y, S));
    }, tile: function() {
      return this.put(new SVG.TileEffect());
    }, turbulence: function(f, p, y, S, A) {
      return this.put(new SVG.TurbulenceEffect(f, p, y, S, A));
    }, toString: function() {
      return "url(#" + this.attr("id") + ")";
    } } }), SVG.extend(SVG.Defs, { filter: function(f) {
      var p = this.put(new SVG.Filter());
      return typeof f == "function" && f.call(p, p), p;
    } }), SVG.extend(SVG.Container, { filter: function(f) {
      return this.defs().filter(f);
    } }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, { filter: function(f) {
      return this.filterer = f instanceof SVG.Element ? f : this.doc().filter(f), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer;
    }, unfilter: function(f) {
      return this.filterer && f === !0 && this.filterer.remove(), delete this.filterer, this.attr("filter", null);
    } }), SVG.Effect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Element, extend: { in: function(f) {
      return f == null ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", f);
    }, result: function(f) {
      return f == null ? this.attr("result") : this.attr("result", f);
    }, toString: function() {
      return this.result();
    } } }), SVG.ParentEffect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Parent, extend: { in: function(f) {
      return f == null ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", f);
    }, result: function(f) {
      return f == null ? this.attr("result") : this.attr("result", f);
    }, toString: function() {
      return this.result();
    } } });
    var B = { blend: function(f, p) {
      return this.parent() && this.parent().blend(this, f, p);
    }, colorMatrix: function(f, p) {
      return this.parent() && this.parent().colorMatrix(f, p).in(this);
    }, convolveMatrix: function(f) {
      return this.parent() && this.parent().convolveMatrix(f).in(this);
    }, componentTransfer: function(f) {
      return this.parent() && this.parent().componentTransfer(f).in(this);
    }, composite: function(f, p) {
      return this.parent() && this.parent().composite(this, f, p);
    }, flood: function(f, p) {
      return this.parent() && this.parent().flood(f, p);
    }, offset: function(f, p) {
      return this.parent() && this.parent().offset(f, p).in(this);
    }, image: function(f) {
      return this.parent() && this.parent().image(f);
    }, merge: function() {
      return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments));
    }, gaussianBlur: function(f, p) {
      return this.parent() && this.parent().gaussianBlur(f, p).in(this);
    }, morphology: function(f, p) {
      return this.parent() && this.parent().morphology(f, p).in(this);
    }, diffuseLighting: function(f, p, y) {
      return this.parent() && this.parent().diffuseLighting(f, p, y).in(this);
    }, displacementMap: function(f, p, y, S) {
      return this.parent() && this.parent().displacementMap(this, f, p, y, S);
    }, specularLighting: function(f, p, y, S) {
      return this.parent() && this.parent().specularLighting(f, p, y, S).in(this);
    }, tile: function() {
      return this.parent() && this.parent().tile().in(this);
    }, turbulence: function(f, p, y, S, A) {
      return this.parent() && this.parent().turbulence(f, p, y, S, A).in(this);
    } };
    SVG.extend(SVG.Effect, B), SVG.extend(SVG.ParentEffect, B), SVG.ChildEffect = SVG.invent({ create: function() {
      this.constructor.call(this);
    }, inherit: SVG.Element, extend: { in: function(f) {
      this.attr("in", f);
    } } });
    var t = { blend: function(f, p, y) {
      this.attr({ in: f, in2: p, mode: y || "normal" });
    }, colorMatrix: function(f, p) {
      f == "matrix" && (p = o(p)), this.attr({ type: f, values: p === void 0 ? null : p });
    }, convolveMatrix: function(f) {
      f = o(f), this.attr({ order: Math.sqrt(f.split(" ").length), kernelMatrix: f });
    }, composite: function(f, p, y) {
      this.attr({ in: f, in2: p, operator: y });
    }, flood: function(f, p) {
      this.attr("flood-color", f), p != null && this.attr("flood-opacity", p);
    }, offset: function(f, p) {
      this.attr({ dx: f, dy: p });
    }, image: function(f) {
      this.attr("href", f, SVG.xlink);
    }, displacementMap: function(f, p, y, S, A) {
      this.attr({ in: f, in2: p, scale: y, xChannelSelector: S, yChannelSelector: A });
    }, gaussianBlur: function(f, p) {
      f != null || p != null ? this.attr("stdDeviation", function(y) {
        if (!Array.isArray(y))
          return y;
        for (var S = 0, A = y.length, E = []; S < A; S++)
          E.push(y[S]);
        return E.join(" ");
      }(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0");
    }, morphology: function(f, p) {
      this.attr({ operator: f, radius: p });
    }, tile: function() {
    }, turbulence: function(f, p, y, S, A) {
      this.attr({ numOctaves: p, seed: y, stitchTiles: S, baseFrequency: f, type: A });
    } }, n = { merge: function() {
      var f;
      if (arguments[0] instanceof SVG.Set) {
        var p = this;
        arguments[0].each(function(S) {
          this instanceof SVG.MergeNode ? p.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && p.put(new SVG.MergeNode(this));
        });
      } else {
        f = Array.isArray(arguments[0]) ? arguments[0] : arguments;
        for (var y = 0; y < f.length; y++)
          f[y] instanceof SVG.MergeNode ? this.put(f[y]) : this.put(new SVG.MergeNode(f[y]));
      }
    }, componentTransfer: function(f) {
      if (this.rgb = new SVG.Set(), ["r", "g", "b", "a"].forEach((function(y) {
        this[y] = new SVG["Func" + y.toUpperCase()]("identity"), this.rgb.add(this[y]), this.node.appendChild(this[y].node);
      }).bind(this)), f)
        for (var p in f.rgb && (["r", "g", "b"].forEach((function(y) {
          this[y].attr(f.rgb);
        }).bind(this)), delete f.rgb), f)
          this[p].attr(f[p]);
    }, diffuseLighting: function(f, p, y) {
      this.attr({ surfaceScale: f, diffuseConstant: p, kernelUnitLength: y });
    }, specularLighting: function(f, p, y, S) {
      this.attr({ surfaceScale: f, diffuseConstant: p, specularExponent: y, kernelUnitLength: S });
    } }, i = { distantLight: function(f, p) {
      this.attr({ azimuth: f, elevation: p });
    }, pointLight: function(f, p, y) {
      this.attr({ x: f, y: p, z: y });
    }, spotLight: function(f, p, y, S, A, E) {
      this.attr({ x: f, y: p, z: y, pointsAtX: S, pointsAtY: A, pointsAtZ: E });
    }, mergeNode: function(f) {
      this.attr("in", f);
    } };
    function o(f) {
      return Array.isArray(f) && (f = new SVG.Array(f)), f.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
    }
    function d() {
      var f = function() {
      };
      for (var p in typeof arguments[arguments.length - 1] == "function" && (f = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments)
        for (var y in arguments[p])
          f(arguments[p][y], y, arguments[p]);
    }
    ["r", "g", "b", "a"].forEach(function(f) {
      i["Func" + f.toUpperCase()] = function(p) {
        switch (this.attr("type", p), p) {
          case "table":
            this.attr("tableValues", arguments[1]);
            break;
          case "linear":
            this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
            break;
          case "gamma":
            this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2]);
        }
      };
    }), d(t, function(f, p) {
      var y = p.charAt(0).toUpperCase() + p.slice(1);
      SVG[y + "Effect"] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + y)), f.apply(this, arguments), this.result(this.attr("id") + "Out");
      }, inherit: SVG.Effect, extend: {} });
    }), d(n, function(f, p) {
      var y = p.charAt(0).toUpperCase() + p.slice(1);
      SVG[y + "Effect"] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + y)), f.apply(this, arguments), this.result(this.attr("id") + "Out");
      }, inherit: SVG.ParentEffect, extend: {} });
    }), d(i, function(f, p) {
      var y = p.charAt(0).toUpperCase() + p.slice(1);
      SVG[y] = SVG.invent({ create: function() {
        this.constructor.call(this, SVG.create("fe" + y)), f.apply(this, arguments);
      }, inherit: SVG.ChildEffect, extend: {} });
    }), SVG.extend(SVG.MergeEffect, { in: function(f) {
      return f instanceof SVG.MergeNode ? this.add(f, 0) : this.add(new SVG.MergeNode(f), 0), this;
    } }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, { in2: function(f) {
      return f == null ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", f);
    } }), SVG.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
  }).call(void 0), function() {
    function B(d, f, p, y, S, A, E) {
      for (var L = d.slice(f, p || E), O = y.slice(S, A || E), P = 0, I = { pos: [0, 0], start: [0, 0] }, j = { pos: [0, 0], start: [0, 0] }; L[P] = t.call(I, L[P]), O[P] = t.call(j, O[P]), L[P][0] != O[P][0] || L[P][0] == "M" || L[P][0] == "A" && (L[P][4] != O[P][4] || L[P][5] != O[P][5]) ? (Array.prototype.splice.apply(L, [P, 1].concat(i.call(I, L[P]))), Array.prototype.splice.apply(O, [P, 1].concat(i.call(j, O[P])))) : (L[P] = n.call(I, L[P]), O[P] = n.call(j, O[P])), !(++P == L.length && P == O.length); )
        P == L.length && L.push(["C", I.pos[0], I.pos[1], I.pos[0], I.pos[1], I.pos[0], I.pos[1]]), P == O.length && O.push(["C", j.pos[0], j.pos[1], j.pos[0], j.pos[1], j.pos[0], j.pos[1]]);
      return { start: L, dest: O };
    }
    function t(d) {
      switch (d[0]) {
        case "z":
        case "Z":
          d[0] = "L", d[1] = this.start[0], d[2] = this.start[1];
          break;
        case "H":
          d[0] = "L", d[2] = this.pos[1];
          break;
        case "V":
          d[0] = "L", d[2] = d[1], d[1] = this.pos[0];
          break;
        case "T":
          d[0] = "Q", d[3] = d[1], d[4] = d[2], d[1] = this.reflection[1], d[2] = this.reflection[0];
          break;
        case "S":
          d[0] = "C", d[6] = d[4], d[5] = d[3], d[4] = d[2], d[3] = d[1], d[2] = this.reflection[1], d[1] = this.reflection[0];
      }
      return d;
    }
    function n(d) {
      var f = d.length;
      return this.pos = [d[f - 2], d[f - 1]], "SCQT".indexOf(d[0]) != -1 && (this.reflection = [2 * this.pos[0] - d[f - 4], 2 * this.pos[1] - d[f - 3]]), d;
    }
    function i(d) {
      var f = [d];
      switch (d[0]) {
        case "M":
          return this.pos = this.start = [d[1], d[2]], f;
        case "L":
          d[5] = d[3] = d[1], d[6] = d[4] = d[2], d[1] = this.pos[0], d[2] = this.pos[1];
          break;
        case "Q":
          d[6] = d[4], d[5] = d[3], d[4] = 1 * d[4] / 3 + 2 * d[2] / 3, d[3] = 1 * d[3] / 3 + 2 * d[1] / 3, d[2] = 1 * this.pos[1] / 3 + 2 * d[2] / 3, d[1] = 1 * this.pos[0] / 3 + 2 * d[1] / 3;
          break;
        case "A":
          f = function(p, y) {
            var S, A, E, L, O, P, I, j, V, Z, b, M, N, X, Q, ee, oe, fe, ke, _e, Le, Ie, at, Qt, Kt, yt, Mn = Math.abs(y[1]), zn = Math.abs(y[2]), vt = y[3] % 360, Ur = y[4], Dn = y[5], si = y[6], oi = y[7], yr = new SVG.Point(p), ln = new SVG.Point(si, oi), wn = [];
            if (Mn === 0 || zn === 0 || yr.x === ln.x && yr.y === ln.y)
              return [["C", yr.x, yr.y, ln.x, ln.y, ln.x, ln.y]];
            for (S = new SVG.Point((yr.x - ln.x) / 2, (yr.y - ln.y) / 2).transform(new SVG.Matrix().rotate(vt)), (A = S.x * S.x / (Mn * Mn) + S.y * S.y / (zn * zn)) > 1 && (Mn *= A = Math.sqrt(A), zn *= A), E = new SVG.Matrix().rotate(vt).scale(1 / Mn, 1 / zn).rotate(-vt), yr = yr.transform(E), ln = ln.transform(E), L = [ln.x - yr.x, ln.y - yr.y], P = L[0] * L[0] + L[1] * L[1], O = Math.sqrt(P), L[0] /= O, L[1] /= O, I = P < 4 ? Math.sqrt(1 - P / 4) : 0, Ur === Dn && (I *= -1), j = new SVG.Point((ln.x + yr.x) / 2 + I * -L[1], (ln.y + yr.y) / 2 + I * L[0]), V = new SVG.Point(yr.x - j.x, yr.y - j.y), Z = new SVG.Point(ln.x - j.x, ln.y - j.y), b = Math.acos(V.x / Math.sqrt(V.x * V.x + V.y * V.y)), V.y < 0 && (b *= -1), M = Math.acos(Z.x / Math.sqrt(Z.x * Z.x + Z.y * Z.y)), Z.y < 0 && (M *= -1), Dn && b > M && (M += 2 * Math.PI), !Dn && b < M && (M -= 2 * Math.PI), X = Math.ceil(2 * Math.abs(b - M) / Math.PI), ee = [], oe = b, N = (M - b) / X, Q = 4 * Math.tan(N / 4) / 3, Le = 0; Le <= X; Le++)
              ke = Math.cos(oe), fe = Math.sin(oe), _e = new SVG.Point(j.x + ke, j.y + fe), ee[Le] = [new SVG.Point(_e.x + Q * fe, _e.y - Q * ke), _e, new SVG.Point(_e.x - Q * fe, _e.y + Q * ke)], oe += N;
            for (ee[0][0] = ee[0][1].clone(), ee[ee.length - 1][2] = ee[ee.length - 1][1].clone(), E = new SVG.Matrix().rotate(vt).scale(Mn, zn).rotate(-vt), Le = 0, Ie = ee.length; Le < Ie; Le++)
              ee[Le][0] = ee[Le][0].transform(E), ee[Le][1] = ee[Le][1].transform(E), ee[Le][2] = ee[Le][2].transform(E);
            for (Le = 1, Ie = ee.length; Le < Ie; Le++)
              at = (_e = ee[Le - 1][2]).x, Qt = _e.y, Kt = (_e = ee[Le][0]).x, yt = _e.y, si = (_e = ee[Le][1]).x, oi = _e.y, wn.push(["C", at, Qt, Kt, yt, si, oi]);
            return wn;
          }(this.pos, d), d = f[0];
      }
      return d[0] = "C", this.pos = [d[5], d[6]], this.reflection = [2 * d[5] - d[3], 2 * d[6] - d[4]], f;
    }
    function o(d, f) {
      if (f === !1)
        return !1;
      for (var p = f, y = d.length; p < y; ++p)
        if (d[p][0] == "M")
          return p;
      return !1;
    }
    SVG.extend(SVG.PathArray, { morph: function(d) {
      for (var f = this.value, p = this.parse(d), y = 0, S = 0, A = !1, E = !1; y !== !1 || S !== !1; ) {
        var L;
        A = o(f, y !== !1 && y + 1), E = o(p, S !== !1 && S + 1), y === !1 && (y = (L = new SVG.PathArray(O.start).bbox()).height == 0 || L.width == 0 ? f.push(f[0]) - 1 : f.push(["M", L.x + L.width / 2, L.y + L.height / 2]) - 1), S === !1 && (S = (L = new SVG.PathArray(O.dest).bbox()).height == 0 || L.width == 0 ? p.push(p[0]) - 1 : p.push(["M", L.x + L.width / 2, L.y + L.height / 2]) - 1);
        var O = B(f, y, A, p, S, E);
        f = f.slice(0, y).concat(O.start, A === !1 ? [] : f.slice(A)), p = p.slice(0, S).concat(O.dest, E === !1 ? [] : p.slice(E)), y = A !== !1 && y + O.start.length, S = E !== !1 && S + O.dest.length;
      }
      return this.value = f, this.destination = new SVG.PathArray(), this.destination.value = p, this;
    } });
  }(), /*! svg.draggable.js - v2.2.2 - 2019-01-08
  * https://github.com/svgdotjs/svg.draggable.js
  * Copyright (c) 2019 Wout Fierens; Licensed MIT */
  (function() {
    function B(t) {
      t.remember("_draggable", this), this.el = t;
    }
    B.prototype.init = function(t, n) {
      var i = this;
      this.constraint = t, this.value = n, this.el.on("mousedown.drag", function(o) {
        i.start(o);
      }), this.el.on("touchstart.drag", function(o) {
        i.start(o);
      });
    }, B.prototype.transformPoint = function(t, n) {
      var i = (t = t || window.event).changedTouches && t.changedTouches[0] || t;
      return this.p.x = i.clientX - (n || 0), this.p.y = i.clientY, this.p.matrixTransform(this.m);
    }, B.prototype.getBBox = function() {
      var t = this.el.bbox();
      return this.el instanceof SVG.Nested && (t = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t.x = this.el.x(), t.y = this.el.y()), t;
    }, B.prototype.start = function(t) {
      if (t.type != "click" && t.type != "mousedown" && t.type != "mousemove" || (t.which || t.buttons) == 1) {
        var n = this;
        if (this.el.fire("beforedrag", { event: t, handler: this }), !this.el.event().defaultPrevented) {
          t.preventDefault(), t.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
          var i, o = this.getBBox();
          if (this.el instanceof SVG.Text)
            switch (i = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
              case "middle":
                i /= 2;
                break;
              case "start":
                i = 0;
            }
          this.startPoints = { point: this.transformPoint(t, i), box: o, transform: this.el.transform() }, SVG.on(window, "mousemove.drag", function(d) {
            n.drag(d);
          }), SVG.on(window, "touchmove.drag", function(d) {
            n.drag(d);
          }), SVG.on(window, "mouseup.drag", function(d) {
            n.end(d);
          }), SVG.on(window, "touchend.drag", function(d) {
            n.end(d);
          }), this.el.fire("dragstart", { event: t, p: this.startPoints.point, m: this.m, handler: this });
        }
      }
    }, B.prototype.drag = function(t) {
      var n = this.getBBox(), i = this.transformPoint(t), o = this.startPoints.box.x + i.x - this.startPoints.point.x, d = this.startPoints.box.y + i.y - this.startPoints.point.y, f = this.constraint, p = i.x - this.startPoints.point.x, y = i.y - this.startPoints.point.y;
      if (this.el.fire("dragmove", { event: t, p: i, m: this.m, handler: this }), this.el.event().defaultPrevented)
        return i;
      if (typeof f == "function") {
        var S = f.call(this.el, o, d, this.m);
        typeof S == "boolean" && (S = { x: S, y: S }), S.x === !0 ? this.el.x(o) : S.x !== !1 && this.el.x(S.x), S.y === !0 ? this.el.y(d) : S.y !== !1 && this.el.y(S.y);
      } else
        typeof f == "object" && (f.minX != null && o < f.minX ? p = (o = f.minX) - this.startPoints.box.x : f.maxX != null && o > f.maxX - n.width && (p = (o = f.maxX - n.width) - this.startPoints.box.x), f.minY != null && d < f.minY ? y = (d = f.minY) - this.startPoints.box.y : f.maxY != null && d > f.maxY - n.height && (y = (d = f.maxY - n.height) - this.startPoints.box.y), f.snapToGrid != null && (o -= o % f.snapToGrid, d -= d % f.snapToGrid, p -= p % f.snapToGrid, y -= y % f.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({ x: p, y }, !0) : this.el.move(o, d));
      return i;
    }, B.prototype.end = function(t) {
      var n = this.drag(t);
      this.el.fire("dragend", { event: t, p: n, m: this.m, handler: this }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag");
    }, SVG.extend(SVG.Element, { draggable: function(t, n) {
      typeof t != "function" && typeof t != "object" || (n = t, t = !0);
      var i = this.remember("_draggable") || new B(this);
      return (t = t === void 0 || t) ? i.init(n || {}, t) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this;
    } });
  }).call(void 0), function() {
    function B(t) {
      this.el = t, t.remember("_selectHandler", this), this.pointSelection = { isSelected: !1 }, this.rectSelection = { isSelected: !1 }, this.pointsList = { lt: [0, 0], rt: ["width", 0], rb: ["width", "height"], lb: [0, "height"], t: ["width", 0], r: ["width", "height"], b: ["width", "height"], l: [0, "height"] }, this.pointCoord = function(n, i, o) {
        var d = typeof n != "string" ? n : i[n];
        return o ? d / 2 : d;
      }, this.pointCoords = function(n, i) {
        var o = this.pointsList[n];
        return { x: this.pointCoord(o[0], i, n === "t" || n === "b"), y: this.pointCoord(o[1], i, n === "r" || n === "l") };
      };
    }
    B.prototype.init = function(t, n) {
      var i = this.el.bbox();
      this.options = {};
      var o = this.el.selectize.defaults.points;
      for (var d in this.el.selectize.defaults)
        this.options[d] = this.el.selectize.defaults[d], n[d] !== void 0 && (this.options[d] = n[d]);
      var f = ["points", "pointsExclude"];
      for (var d in f) {
        var p = this.options[f[d]];
        typeof p == "string" ? p = p.length > 0 ? p.split(/\s*,\s*/i) : [] : typeof p == "boolean" && f[d] === "points" && (p = p ? o : []), this.options[f[d]] = p;
      }
      this.options.points = [o, this.options.points].reduce(function(y, S) {
        return y.filter(function(A) {
          return S.indexOf(A) > -1;
        });
      }), this.options.points = [this.options.points, this.options.pointsExclude].reduce(function(y, S) {
        return y.filter(function(A) {
          return S.indexOf(A) < 0;
        });
      }), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i.x, i.y)), this.options.deepSelect && ["line", "polyline", "polygon"].indexOf(this.el.type) !== -1 ? this.selectPoints(t) : this.selectRect(t), this.observe(), this.cleanup();
    }, B.prototype.selectPoints = function(t) {
      return this.pointSelection.isSelected = t, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this;
    }, B.prototype.getPointArray = function() {
      var t = this.el.bbox();
      return this.el.array().valueOf().map(function(n) {
        return [n[0] - t.x, n[1] - t.y];
      });
    }, B.prototype.drawPoints = function() {
      for (var t = this, n = this.getPointArray(), i = 0, o = n.length; i < o; ++i) {
        var d = function(p) {
          return function(y) {
            (y = y || window.event).preventDefault ? y.preventDefault() : y.returnValue = !1, y.stopPropagation();
            var S = y.pageX || y.touches[0].pageX, A = y.pageY || y.touches[0].pageY;
            t.el.fire("point", { x: S, y: A, i: p, event: y });
          };
        }(i), f = this.drawPoint(n[i][0], n[i][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", d).on("mousedown", d);
        this.pointSelection.set.add(f);
      }
    }, B.prototype.drawPoint = function(t, n) {
      var i = this.options.pointType;
      switch (i) {
        case "circle":
          return this.drawCircle(t, n);
        case "rect":
          return this.drawRect(t, n);
        default:
          if (typeof i == "function")
            return i.call(this, t, n);
          throw new Error("Unknown " + i + " point type!");
      }
    }, B.prototype.drawCircle = function(t, n) {
      return this.nested.circle(this.options.pointSize).center(t, n);
    }, B.prototype.drawRect = function(t, n) {
      return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t, n);
    }, B.prototype.updatePointSelection = function() {
      var t = this.getPointArray();
      this.pointSelection.set.each(function(n) {
        this.cx() === t[n][0] && this.cy() === t[n][1] || this.center(t[n][0], t[n][1]);
      });
    }, B.prototype.updateRectSelection = function() {
      var t = this, n = this.el.bbox();
      if (this.rectSelection.set.get(0).attr({ width: n.width, height: n.height }), this.options.points.length && this.options.points.map(function(o, d) {
        var f = t.pointCoords(o, n);
        t.rectSelection.set.get(d + 1).center(f.x, f.y);
      }), this.options.rotationPoint) {
        var i = this.rectSelection.set.length();
        this.rectSelection.set.get(i - 1).center(n.width / 2, 20);
      }
    }, B.prototype.selectRect = function(t) {
      var n = this, i = this.el.bbox();
      function o(p) {
        return function(y) {
          (y = y || window.event).preventDefault ? y.preventDefault() : y.returnValue = !1, y.stopPropagation();
          var S = y.pageX || y.touches[0].pageX, A = y.pageY || y.touches[0].pageY;
          n.el.fire(p, { x: S, y: A, event: y });
        };
      }
      if (this.rectSelection.isSelected = t, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i.width, i.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2 && (this.options.points.map(function(p, y) {
        var S = n.pointCoords(p, i), A = n.drawPoint(S.x, S.y).attr("class", n.options.classPoints + "_" + p).on("mousedown", o(p)).on("touchstart", o(p));
        n.rectSelection.set.add(A);
      }), this.rectSelection.set.each(function() {
        this.addClass(n.options.classPoints);
      })), this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
        var d = function(p) {
          (p = p || window.event).preventDefault ? p.preventDefault() : p.returnValue = !1, p.stopPropagation();
          var y = p.pageX || p.touches[0].pageX, S = p.pageY || p.touches[0].pageY;
          n.el.fire("rot", { x: y, y: S, event: p });
        }, f = this.drawPoint(i.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", d).on("mousedown", d);
        this.rectSelection.set.add(f);
      }
    }, B.prototype.handler = function() {
      var t = this.el.bbox();
      this.nested.matrix(new SVG.Matrix(this.el).translate(t.x, t.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection();
    }, B.prototype.observe = function() {
      var t = this;
      if (MutationObserver)
        if (this.rectSelection.isSelected || this.pointSelection.isSelected)
          this.observerInst = this.observerInst || new MutationObserver(function() {
            t.handler();
          }), this.observerInst.observe(this.el.node, { attributes: !0 });
        else
          try {
            this.observerInst.disconnect(), delete this.observerInst;
          } catch {
          }
      else
        this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function() {
          t.handler();
        });
    }, B.prototype.cleanup = function() {
      !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function() {
        this.remove();
      }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function() {
        this.remove();
      }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested);
    }, SVG.extend(SVG.Element, { selectize: function(t, n) {
      return typeof t == "object" && (n = t, t = !0), (this.remember("_selectHandler") || new B(this)).init(t === void 0 || t, n || {}), this;
    } }), SVG.Element.prototype.selectize.defaults = { points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"], pointsExclude: [], classRect: "svg_select_boundingRect", classPoints: "svg_select_points", pointSize: 7, rotationPoint: !0, deepSelect: !1, pointType: "circle" };
  }(), function() {
    (function() {
      function B(t) {
        t.remember("_resizeHandler", this), this.el = t, this.parameters = {}, this.lastUpdateCall = null, this.p = t.doc().node.createSVGPoint();
      }
      B.prototype.transformPoint = function(t, n, i) {
        return this.p.x = t - (this.offset.x - window.pageXOffset), this.p.y = n - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i || this.m);
      }, B.prototype._extractPosition = function(t) {
        return { x: t.clientX != null ? t.clientX : t.touches[0].clientX, y: t.clientY != null ? t.clientY : t.touches[0].clientY };
      }, B.prototype.init = function(t) {
        var n = this;
        if (this.stop(), t !== "stop") {
          for (var i in this.options = {}, this.el.resize.defaults)
            this.options[i] = this.el.resize.defaults[i], t[i] !== void 0 && (this.options[i] = t[i]);
          this.el.on("lt.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("rt.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("rb.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("lb.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("t.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("r.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("b.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("l.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("rot.resize", function(o) {
            n.resize(o || window.event);
          }), this.el.on("point.resize", function(o) {
            n.resize(o || window.event);
          }), this.update();
        }
      }, B.prototype.stop = function() {
        return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this;
      }, B.prototype.resize = function(t) {
        var n = this;
        this.m = this.el.node.getScreenCTM().inverse(), this.offset = { x: window.pageXOffset, y: window.pageYOffset };
        var i = this._extractPosition(t.detail.event);
        if (this.parameters = { type: this.el.type, p: this.transformPoint(i.x, i.y), x: t.detail.x, y: t.detail.y, box: this.el.bbox(), rotation: this.el.transform().rotation }, this.el.type === "text" && (this.parameters.fontSize = this.el.attr()["font-size"]), t.detail.i !== void 0) {
          var o = this.el.array().valueOf();
          this.parameters.i = t.detail.i, this.parameters.pointCoords = [o[t.detail.i][0], o[t.detail.i][1]];
        }
        switch (t.type) {
          case "lt":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f);
              if (this.parameters.box.width - p[0] > 0 && this.parameters.box.height - p[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x + p[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - p[0]);
                p = this.checkAspectRatio(p), this.el.move(this.parameters.box.x + p[0], this.parameters.box.y + p[1]).size(this.parameters.box.width - p[0], this.parameters.box.height - p[1]);
              }
            };
            break;
          case "rt":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 2);
              if (this.parameters.box.width + p[0] > 0 && this.parameters.box.height - p[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x - p[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + p[0]);
                p = this.checkAspectRatio(p, !0), this.el.move(this.parameters.box.x, this.parameters.box.y + p[1]).size(this.parameters.box.width + p[0], this.parameters.box.height - p[1]);
              }
            };
            break;
          case "rb":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 0);
              if (this.parameters.box.width + p[0] > 0 && this.parameters.box.height + p[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x - p[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + p[0]);
                p = this.checkAspectRatio(p), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + p[0], this.parameters.box.height + p[1]);
              }
            };
            break;
          case "lb":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 1);
              if (this.parameters.box.width - p[0] > 0 && this.parameters.box.height + p[1] > 0) {
                if (this.parameters.type === "text")
                  return this.el.move(this.parameters.box.x + p[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - p[0]);
                p = this.checkAspectRatio(p, !0), this.el.move(this.parameters.box.x + p[0], this.parameters.box.y).size(this.parameters.box.width - p[0], this.parameters.box.height + p[1]);
              }
            };
            break;
          case "t":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 2);
              if (this.parameters.box.height - p[1] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y + p[1]).height(this.parameters.box.height - p[1]);
              }
            };
            break;
          case "r":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 0);
              if (this.parameters.box.width + p[0] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + p[0]);
              }
            };
            break;
          case "b":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 0);
              if (this.parameters.box.height + p[1] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + p[1]);
              }
            };
            break;
          case "l":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, 1);
              if (this.parameters.box.width - p[0] > 0) {
                if (this.parameters.type === "text")
                  return;
                this.el.move(this.parameters.box.x + p[0], this.parameters.box.y).width(this.parameters.box.width - p[0]);
              }
            };
            break;
          case "rot":
            this.calc = function(d, f) {
              var p = d + this.parameters.p.x, y = f + this.parameters.p.y, S = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2), A = Math.atan2(y - this.parameters.box.y - this.parameters.box.height / 2, p - this.parameters.box.x - this.parameters.box.width / 2), E = this.parameters.rotation + 180 * (A - S) / Math.PI + this.options.snapToAngle / 2;
              this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(E - E % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);
            };
            break;
          case "point":
            this.calc = function(d, f) {
              var p = this.snapToGrid(d, f, this.parameters.pointCoords[0], this.parameters.pointCoords[1]), y = this.el.array().valueOf();
              y[this.parameters.i][0] = this.parameters.pointCoords[0] + p[0], y[this.parameters.i][1] = this.parameters.pointCoords[1] + p[1], this.el.plot(y);
            };
        }
        this.el.fire("resizestart", { dx: this.parameters.x, dy: this.parameters.y, event: t }), SVG.on(window, "touchmove.resize", function(d) {
          n.update(d || window.event);
        }), SVG.on(window, "touchend.resize", function() {
          n.done();
        }), SVG.on(window, "mousemove.resize", function(d) {
          n.update(d || window.event);
        }), SVG.on(window, "mouseup.resize", function() {
          n.done();
        });
      }, B.prototype.update = function(t) {
        if (t) {
          var n = this._extractPosition(t), i = this.transformPoint(n.x, n.y), o = i.x - this.parameters.p.x, d = i.y - this.parameters.p.y;
          this.lastUpdateCall = [o, d], this.calc(o, d), this.el.fire("resizing", { dx: o, dy: d, event: t });
        } else
          this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);
      }, B.prototype.done = function() {
        this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone");
      }, B.prototype.snapToGrid = function(t, n, i, o) {
        var d;
        return o !== void 0 ? d = [(i + t) % this.options.snapToGrid, (o + n) % this.options.snapToGrid] : (i = i ?? 3, d = [(this.parameters.box.x + t + (1 & i ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + n + (2 & i ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), t < 0 && (d[0] -= this.options.snapToGrid), n < 0 && (d[1] -= this.options.snapToGrid), t -= Math.abs(d[0]) < this.options.snapToGrid / 2 ? d[0] : d[0] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid), n -= Math.abs(d[1]) < this.options.snapToGrid / 2 ? d[1] : d[1] - (n < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t, n, i, o);
      }, B.prototype.constraintToBox = function(t, n, i, o) {
        var d, f, p = this.options.constraint || {};
        return o !== void 0 ? (d = i, f = o) : (d = this.parameters.box.x + (1 & i ? 0 : this.parameters.box.width), f = this.parameters.box.y + (2 & i ? 0 : this.parameters.box.height)), p.minX !== void 0 && d + t < p.minX && (t = p.minX - d), p.maxX !== void 0 && d + t > p.maxX && (t = p.maxX - d), p.minY !== void 0 && f + n < p.minY && (n = p.minY - f), p.maxY !== void 0 && f + n > p.maxY && (n = p.maxY - f), [t, n];
      }, B.prototype.checkAspectRatio = function(t, n) {
        if (!this.options.saveAspectRatio)
          return t;
        var i = t.slice(), o = this.parameters.box.width / this.parameters.box.height, d = this.parameters.box.width + t[0], f = this.parameters.box.height - t[1], p = d / f;
        return p < o ? (i[1] = d / o - this.parameters.box.height, n && (i[1] = -i[1])) : p > o && (i[0] = this.parameters.box.width - f * o, n && (i[0] = -i[0])), i;
      }, SVG.extend(SVG.Element, { resize: function(t) {
        return (this.remember("_resizeHandler") || new B(this)).init(t || {}), this;
      } }), SVG.Element.prototype.resize.defaults = { snapToAngle: 0.1, snapToGrid: 1, constraint: {}, saveAspectRatio: !1 };
    }).call(this);
  }(), window.Apex === void 0 && (window.Apex = {});
  var Zt = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "initModules", value: function() {
      this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new we(this.ctx), this.ctx.axes = new Or(this.ctx), this.ctx.core = new qt(this.ctx.el, this.ctx), this.ctx.config = new ft({}), this.ctx.data = new It(this.ctx), this.ctx.grid = new vn(this.ctx), this.ctx.graphics = new re(this.ctx), this.ctx.coreUtils = new ve(this.ctx), this.ctx.crosshairs = new ti(this.ctx), this.ctx.events = new ir(this.ctx), this.ctx.exports = new jt(this.ctx), this.ctx.localization = new Dr(this.ctx), this.ctx.options = new dt(), this.ctx.responsive = new Zi(this.ctx), this.ctx.series = new ot(this.ctx), this.ctx.theme = new _a(this.ctx), this.ctx.formatters = new Vt(this.ctx), this.ctx.titleSubtitle = new da(this.ctx), this.ctx.legend = new ri(this.ctx), this.ctx.toolbar = new Pa(this.ctx), this.ctx.tooltip = new $n(this.ctx), this.ctx.dimensions = new ni(this.ctx), this.ctx.updateHelpers = new cn(this.ctx), this.ctx.zoomPanSelection = new Ki(this.ctx), this.ctx.w.globals.tooltip = new $n(this.ctx);
    } }]), B;
  }(), Ot = function() {
    function B(t) {
      C(this, B), this.ctx = t, this.w = t.w;
    }
    return F(B, [{ key: "clear", value: function(t) {
      var n = t.isUpdating;
      this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: n });
    } }, { key: "killSVG", value: function(t) {
      t.each(function(n, i) {
        this.removeClass("*"), this.off(), this.stop();
      }, !0), t.ungroup(), t.clear();
    } }, { key: "clearDomElements", value: function(t) {
      var n = this, i = t.isUpdating, o = this.w.globals.dom.Paper.node;
      o.parentNode && o.parentNode.parentNode && !i && (o.parentNode.parentNode.style.minHeight = "unset");
      var d = this.w.globals.dom.baseEl;
      d && this.ctx.eventList.forEach(function(p) {
        d.removeEventListener(p, n.ctx.events.documentEvent);
      });
      var f = this.w.globals.dom;
      if (this.ctx.el !== null)
        for (; this.ctx.el.firstChild; )
          this.ctx.el.removeChild(this.ctx.el.firstChild);
      this.killSVG(f.Paper), f.Paper.remove(), f.elWrap = null, f.elGraphical = null, f.elLegendWrap = null, f.elLegendForeign = null, f.baseEl = null, f.elGridRect = null, f.elGridRectMask = null, f.elGridRectMarkerMask = null, f.elForecastMask = null, f.elNonForecastMask = null, f.elDefs = null;
    } }]), B;
  }(), sr = /* @__PURE__ */ new WeakMap(), Yn = function() {
    function B(t, n) {
      C(this, B), this.opts = n, this.ctx = this, this.w = new Ue(n).init(), this.el = t, this.w.globals.cuid = K.randomId(), this.w.globals.chartID = this.w.config.chart.id ? K.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new Zt(this).initModules(), this.create = K.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
    }
    return F(B, [{ key: "render", value: function() {
      var t = this;
      return new Promise(function(n, i) {
        if (t.el !== null) {
          Apex._chartInstances === void 0 && (Apex._chartInstances = []), t.w.config.chart.id && Apex._chartInstances.push({ id: t.w.globals.chartID, group: t.w.config.chart.group, chart: t }), t.setLocale(t.w.config.chart.defaultLocale);
          var o = t.w.config.chart.events.beforeMount;
          if (typeof o == "function" && o(t, t.w), t.events.fireEvent("beforeMount", [t, t.w]), window.addEventListener("resize", t.windowResizeHandler), function(A, E) {
            var L = !1;
            if (A.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
              var O = A.getBoundingClientRect();
              A.style.display !== "none" && O.width !== 0 || (L = !0);
            }
            var P = new ResizeObserver(function(I) {
              L && E.call(A, I), L = !0;
            });
            A.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(A.children).forEach(function(I) {
              return P.observe(I);
            }) : P.observe(A), sr.set(E, P);
          }(t.el.parentNode, t.parentResizeHandler), !t.css) {
            var d = t.el.getRootNode && t.el.getRootNode(), f = K.is("ShadowRoot", d), p = t.el.ownerDocument, y = p.getElementById("apexcharts-css");
            !f && y || (t.css = document.createElement("style"), t.css.id = "apexcharts-css", t.css.textContent = `@keyframes opaque {
  0% {
      opacity: 0
  }

  to {
      opacity: 1
  }
}

@keyframes resizeanim {
  0%,to {
      opacity: 0
  }
}

.apexcharts-canvas {
  position: relative;
  user-select: none
}

.apexcharts-canvas ::-webkit-scrollbar {
  -webkit-appearance: none;
  width: 6px
}

.apexcharts-canvas ::-webkit-scrollbar-thumb {
  border-radius: 4px;
  background-color: rgba(0,0,0,.5);
  box-shadow: 0 0 1px rgba(255,255,255,.5);
  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5)
}

.apexcharts-inner {
  position: relative
}

.apexcharts-text tspan {
  font-family: inherit
}

.legend-mouseover-inactive {
  transition: .15s ease all;
  opacity: .2
}

.apexcharts-legend-text {
  padding-left: 15px;
  margin-left: -15px;
}

.apexcharts-series-collapsed {
  opacity: 0
}

.apexcharts-tooltip {
  border-radius: 5px;
  box-shadow: 2px 2px 6px -4px #999;
  cursor: default;
  font-size: 14px;
  left: 62px;
  opacity: 0;
  pointer-events: none;
  position: absolute;
  top: 20px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  white-space: nowrap;
  z-index: 12;
  transition: .15s ease all
}

.apexcharts-tooltip.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-tooltip.apexcharts-theme-light {
  border: 1px solid #e3e3e3;
  background: rgba(255,255,255,.96)
}

.apexcharts-tooltip.apexcharts-theme-dark {
  color: #fff;
  background: rgba(30,30,30,.8)
}

.apexcharts-tooltip * {
  font-family: inherit
}

.apexcharts-tooltip-title {
  padding: 6px;
  font-size: 15px;
  margin-bottom: 4px
}

.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {
  background: #eceff1;
  border-bottom: 1px solid #ddd
}

.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {
  background: rgba(0,0,0,.7);
  border-bottom: 1px solid #333
}

.apexcharts-tooltip-text-goals-value,.apexcharts-tooltip-text-y-value,.apexcharts-tooltip-text-z-value {
  display: inline-block;
  margin-left: 5px;
  font-weight: 600
}

.apexcharts-tooltip-text-goals-label:empty,.apexcharts-tooltip-text-goals-value:empty,.apexcharts-tooltip-text-y-label:empty,.apexcharts-tooltip-text-y-value:empty,.apexcharts-tooltip-text-z-value:empty,.apexcharts-tooltip-title:empty {
  display: none
}

.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {
  padding: 6px 0 5px
}

.apexcharts-tooltip-goals-group,.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {
  display: flex
}

.apexcharts-tooltip-text-goals-label:not(:empty),.apexcharts-tooltip-text-goals-value:not(:empty) {
  margin-top: -6px
}

.apexcharts-tooltip-marker {
  width: 12px;
  height: 12px;
  position: relative;
  top: 0;
  margin-right: 10px;
  border-radius: 50%
}

.apexcharts-tooltip-series-group {
  padding: 0 10px;
  display: none;
  text-align: left;
  justify-content: left;
  align-items: center
}

.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {
  opacity: 1
}

.apexcharts-tooltip-series-group.apexcharts-active,.apexcharts-tooltip-series-group:last-child {
  padding-bottom: 4px
}

.apexcharts-tooltip-series-group-hidden {
  opacity: 0;
  height: 0;
  line-height: 0;
  padding: 0!important
}

.apexcharts-tooltip-y-group {
  padding: 6px 0 5px
}

.apexcharts-custom-tooltip,.apexcharts-tooltip-box {
  padding: 4px 8px
}

.apexcharts-tooltip-boxPlot {
  display: flex;
  flex-direction: column-reverse
}

.apexcharts-tooltip-box>div {
  margin: 4px 0
}

.apexcharts-tooltip-box span.value {
  font-weight: 700
}

.apexcharts-tooltip-rangebar {
  padding: 5px 8px
}

.apexcharts-tooltip-rangebar .category {
  font-weight: 600;
  color: #777
}

.apexcharts-tooltip-rangebar .series-name {
  font-weight: 700;
  display: block;
  margin-bottom: 5px
}

.apexcharts-xaxistooltip,.apexcharts-yaxistooltip {
  opacity: 0;
  pointer-events: none;
  color: #373d3f;
  font-size: 13px;
  text-align: center;
  border-radius: 2px;
  position: absolute;
  z-index: 10;
  background: #eceff1;
  border: 1px solid #90a4ae
}

.apexcharts-xaxistooltip {
  padding: 9px 10px;
  transition: .15s ease all
}

.apexcharts-xaxistooltip.apexcharts-theme-dark {
  background: rgba(0,0,0,.7);
  border: 1px solid rgba(0,0,0,.5);
  color: #fff
}

.apexcharts-xaxistooltip:after,.apexcharts-xaxistooltip:before {
  left: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none
}

.apexcharts-xaxistooltip:after {
  border-color: transparent;
  border-width: 6px;
  margin-left: -6px
}

.apexcharts-xaxistooltip:before {
  border-color: transparent;
  border-width: 7px;
  margin-left: -7px
}

.apexcharts-xaxistooltip-bottom:after,.apexcharts-xaxistooltip-bottom:before {
  bottom: 100%
}

.apexcharts-xaxistooltip-top:after,.apexcharts-xaxistooltip-top:before {
  top: 100%
}

.apexcharts-xaxistooltip-bottom:after {
  border-bottom-color: #eceff1
}

.apexcharts-xaxistooltip-bottom:before {
  border-bottom-color: #90a4ae
}

.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {
  border-bottom-color: rgba(0,0,0,.5)
}

.apexcharts-xaxistooltip-top:after {
  border-top-color: #eceff1
}

.apexcharts-xaxistooltip-top:before {
  border-top-color: #90a4ae
}

.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {
  border-top-color: rgba(0,0,0,.5)
}

.apexcharts-xaxistooltip.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-yaxistooltip {
  padding: 4px 10px
}

.apexcharts-yaxistooltip.apexcharts-theme-dark {
  background: rgba(0,0,0,.7);
  border: 1px solid rgba(0,0,0,.5);
  color: #fff
}

.apexcharts-yaxistooltip:after,.apexcharts-yaxistooltip:before {
  top: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none
}

.apexcharts-yaxistooltip:after {
  border-color: transparent;
  border-width: 6px;
  margin-top: -6px
}

.apexcharts-yaxistooltip:before {
  border-color: transparent;
  border-width: 7px;
  margin-top: -7px
}

.apexcharts-yaxistooltip-left:after,.apexcharts-yaxistooltip-left:before {
  left: 100%
}

.apexcharts-yaxistooltip-right:after,.apexcharts-yaxistooltip-right:before {
  right: 100%
}

.apexcharts-yaxistooltip-left:after {
  border-left-color: #eceff1
}

.apexcharts-yaxistooltip-left:before {
  border-left-color: #90a4ae
}

.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {
  border-left-color: rgba(0,0,0,.5)
}

.apexcharts-yaxistooltip-right:after {
  border-right-color: #eceff1
}

.apexcharts-yaxistooltip-right:before {
  border-right-color: #90a4ae
}

.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {
  border-right-color: rgba(0,0,0,.5)
}

.apexcharts-yaxistooltip.apexcharts-active {
  opacity: 1
}

.apexcharts-yaxistooltip-hidden {
  display: none
}

.apexcharts-xcrosshairs,.apexcharts-ycrosshairs {
  pointer-events: none;
  opacity: 0;
  transition: .15s ease all
}

.apexcharts-xcrosshairs.apexcharts-active,.apexcharts-ycrosshairs.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-ycrosshairs-hidden {
  opacity: 0
}

.apexcharts-selection-rect {
  cursor: move
}

.svg_select_boundingRect,.svg_select_points_rot {
  pointer-events: none;
  opacity: 0;
  visibility: hidden
}

.apexcharts-selection-rect+g .svg_select_boundingRect,.apexcharts-selection-rect+g .svg_select_points_rot {
  opacity: 0;
  visibility: hidden
}

.apexcharts-selection-rect+g .svg_select_points_l,.apexcharts-selection-rect+g .svg_select_points_r {
  cursor: ew-resize;
  opacity: 1;
  visibility: visible
}

.svg_select_points {
  fill: #efefef;
  stroke: #333;
  rx: 2
}

.apexcharts-svg.apexcharts-zoomable.hovering-zoom {
  cursor: crosshair
}

.apexcharts-svg.apexcharts-zoomable.hovering-pan {
  cursor: move
}

.apexcharts-menu-icon,.apexcharts-pan-icon,.apexcharts-reset-icon,.apexcharts-selection-icon,.apexcharts-toolbar-custom-icon,.apexcharts-zoom-icon,.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {
  cursor: pointer;
  width: 20px;
  height: 20px;
  line-height: 24px;
  color: #6e8192;
  text-align: center
}

.apexcharts-menu-icon svg,.apexcharts-reset-icon svg,.apexcharts-zoom-icon svg,.apexcharts-zoomin-icon svg,.apexcharts-zoomout-icon svg {
  fill: #6e8192
}

.apexcharts-selection-icon svg {
  fill: #444;
  transform: scale(.76)
}

.apexcharts-theme-dark .apexcharts-menu-icon svg,.apexcharts-theme-dark .apexcharts-pan-icon svg,.apexcharts-theme-dark .apexcharts-reset-icon svg,.apexcharts-theme-dark .apexcharts-selection-icon svg,.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,.apexcharts-theme-dark .apexcharts-zoom-icon svg,.apexcharts-theme-dark .apexcharts-zoomin-icon svg,.apexcharts-theme-dark .apexcharts-zoomout-icon svg {
  fill: #f3f4f5
}

.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {
  fill: #008ffb
}

.apexcharts-theme-light .apexcharts-menu-icon:hover svg,.apexcharts-theme-light .apexcharts-reset-icon:hover svg,.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {
  fill: #333
}

.apexcharts-menu-icon,.apexcharts-selection-icon {
  position: relative
}

.apexcharts-reset-icon {
  margin-left: 5px
}

.apexcharts-menu-icon,.apexcharts-reset-icon,.apexcharts-zoom-icon {
  transform: scale(.85)
}

.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {
  transform: scale(.7)
}

.apexcharts-zoomout-icon {
  margin-right: 3px
}

.apexcharts-pan-icon {
  transform: scale(.62);
  position: relative;
  left: 1px;
  top: 0
}

.apexcharts-pan-icon svg {
  fill: #fff;
  stroke: #6e8192;
  stroke-width: 2
}

.apexcharts-pan-icon.apexcharts-selected svg {
  stroke: #008ffb
}

.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {
  stroke: #333
}

.apexcharts-toolbar {
  position: absolute;
  z-index: 11;
  max-width: 176px;
  text-align: right;
  border-radius: 3px;
  padding: 0 6px 2px;
  display: flex;
  justify-content: space-between;
  align-items: center
}

.apexcharts-menu {
  background: #fff;
  position: absolute;
  top: 100%;
  border: 1px solid #ddd;
  border-radius: 3px;
  padding: 3px;
  right: 10px;
  opacity: 0;
  min-width: 110px;
  transition: .15s ease all;
  pointer-events: none
}

.apexcharts-menu.apexcharts-menu-open {
  opacity: 1;
  pointer-events: all;
  transition: .15s ease all
}

.apexcharts-menu-item {
  padding: 6px 7px;
  font-size: 12px;
  cursor: pointer
}

.apexcharts-theme-light .apexcharts-menu-item:hover {
  background: #eee
}

.apexcharts-theme-dark .apexcharts-menu {
  background: rgba(0,0,0,.7);
  color: #fff
}

@media screen and (min-width:768px) {
  .apexcharts-canvas:hover .apexcharts-toolbar {
      opacity: 1
  }
}

.apexcharts-canvas .apexcharts-element-hidden,.apexcharts-datalabel.apexcharts-element-hidden,.apexcharts-hide .apexcharts-series-points {
  opacity: 0
}

.apexcharts-hidden-element-shown {
  opacity: 1;
  transition: 0.25s ease all;
}
.apexcharts-datalabel,.apexcharts-datalabel-label,.apexcharts-datalabel-value,.apexcharts-datalabels,.apexcharts-pie-label {
  cursor: default;
  pointer-events: none
}

.apexcharts-pie-label-delay {
  opacity: 0;
  animation-name: opaque;
  animation-duration: .3s;
  animation-fill-mode: forwards;
  animation-timing-function: ease
}

.apexcharts-annotation-rect,.apexcharts-area-series .apexcharts-area,.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-gridline,.apexcharts-line,.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-point-annotation-label,.apexcharts-radar-series path,.apexcharts-radar-series polygon,.apexcharts-toolbar svg,.apexcharts-tooltip .apexcharts-marker,.apexcharts-xaxis-annotation-label,.apexcharts-yaxis-annotation-label,.apexcharts-zoom-rect {
  pointer-events: none
}

.apexcharts-marker {
  transition: .15s ease all
}

.resize-triggers {
  animation: 1ms resizeanim;
  visibility: hidden;
  opacity: 0;
  height: 100%;
  width: 100%;
  overflow: hidden
}

.contract-trigger:before,.resize-triggers,.resize-triggers>div {
  content: " ";
  display: block;
  position: absolute;
  top: 0;
  left: 0
}

.resize-triggers>div {
  height: 100%;
  width: 100%;
  background: #eee;
  overflow: auto
}

.contract-trigger:before {
  overflow: hidden;
  width: 200%;
  height: 200%
}

.apexcharts-bar-goals-markers{
  pointer-events: none
}

.apexcharts-bar-shadows{
  pointer-events: none
}

.apexcharts-rangebar-goals-markers{
  pointer-events: none
}`, f ? d.prepend(t.css) : p.head.appendChild(t.css));
          }
          var S = t.create(t.w.config.series, {});
          if (!S)
            return n(t);
          t.mount(S).then(function() {
            typeof t.w.config.chart.events.mounted == "function" && t.w.config.chart.events.mounted(t, t.w), t.events.fireEvent("mounted", [t, t.w]), n(S);
          }).catch(function(A) {
            i(A);
          });
        } else
          i(new Error("Element not found"));
      });
    } }, { key: "create", value: function(t, n) {
      var i = this.w;
      new Zt(this).initModules();
      var o = this.w.globals;
      if (o.noData = !1, o.animationEnded = !1, this.responsive.checkResponsiveConfig(n), i.config.xaxis.convertedCatToNumeric && new We(i.config).convertCatToNumericXaxis(i.config, this.ctx), this.el === null || (this.core.setupElements(), i.config.chart.type === "treemap" && (i.config.grid.show = !1, i.config.yaxis[0].show = !1), o.svgWidth === 0))
        return o.animationEnded = !0, null;
      var d = ve.checkComboSeries(t);
      o.comboCharts = d.comboCharts, o.comboBarCount = d.comboBarCount;
      var f = t.every(function(A) {
        return A.data && A.data.length === 0;
      });
      (t.length === 0 || f) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t), this.theme.init(), new St(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), o.noData && o.collapsedSeries.length !== o.series.length && !i.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), o.axisCharts && (this.core.coreCalculations(), i.config.xaxis.type !== "category" && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = i.globals.minX, this.ctx.toolbar.maxX = i.globals.maxX), this.formatters.heatmapLabelFormatters(), new ve(this).getLargestMarkerSize(), this.dimensions.plotCoords();
      var p = this.core.xySettings();
      this.grid.createGridMask();
      var y = this.core.plotChartType(t, p), S = new Ht(this);
      return S.bringForward(), i.config.dataLabels.background.enabled && S.dataLabelsBackground(), this.core.shiftGraphPosition(), { elGraph: y, xyRatios: p, dimensions: { plot: { left: i.globals.translateX, top: i.globals.translateY, width: i.globals.gridWidth, height: i.globals.gridHeight } } };
    } }, { key: "mount", value: function() {
      var t = this, n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, i = this, o = i.w;
      return new Promise(function(d, f) {
        if (i.el === null)
          return f(new Error("Not enough data to display or target element not found"));
        (n === null || o.globals.allSeriesCollapsed) && i.series.handleNoData(), i.grid = new vn(i);
        var p, y, S = i.grid.drawGrid();
        if (i.annotations = new Ke(i), i.annotations.drawImageAnnos(), i.annotations.drawTextAnnos(), o.config.grid.position === "back" && (S && o.globals.dom.elGraphical.add(S.el), S != null && (p = S.elGridBorders) !== null && p !== void 0 && p.node && o.globals.dom.elGraphical.add(S.elGridBorders)), Array.isArray(n.elGraph))
          for (var A = 0; A < n.elGraph.length; A++)
            o.globals.dom.elGraphical.add(n.elGraph[A]);
        else
          o.globals.dom.elGraphical.add(n.elGraph);
        o.config.grid.position === "front" && (S && o.globals.dom.elGraphical.add(S.el), S != null && (y = S.elGridBorders) !== null && y !== void 0 && y.node && o.globals.dom.elGraphical.add(S.elGridBorders)), o.config.xaxis.crosshairs.position === "front" && i.crosshairs.drawXCrosshairs(), o.config.yaxis[0].crosshairs.position === "front" && i.crosshairs.drawYCrosshairs(), o.config.chart.type !== "treemap" && i.axes.drawAxis(o.config.chart.type, S);
        var E = new Ut(t.ctx, S), L = new jn(t.ctx, S);
        if (S !== null && (E.xAxisLabelCorrections(S.xAxisTickWidth), L.setYAxisTextAlignments(), o.config.yaxis.map(function(P, I) {
          o.globals.ignoreYAxisIndexes.indexOf(I) === -1 && L.yAxisTitleRotate(I, P.opposite);
        })), i.annotations.drawAxesAnnotations(), !o.globals.noData) {
          if (o.config.tooltip.enabled && !o.globals.noData && i.w.globals.tooltip.drawTooltip(n.xyRatios), o.globals.axisCharts && (o.globals.isXNumeric || o.config.xaxis.convertedCatToNumeric || o.globals.isRangeBar))
            (o.config.chart.zoom.enabled || o.config.chart.selection && o.config.chart.selection.enabled || o.config.chart.pan && o.config.chart.pan.enabled) && i.zoomPanSelection.init({ xyRatios: n.xyRatios });
          else {
            var O = o.config.chart.toolbar.tools;
            ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(P) {
              O[P] = !1;
            });
          }
          o.config.chart.toolbar.show && !o.globals.allSeriesCollapsed && i.toolbar.createToolbar();
        }
        o.globals.memory.methodsToExec.length > 0 && o.globals.memory.methodsToExec.forEach(function(P) {
          P.method(P.params, !1, P.context);
        }), o.globals.axisCharts || o.globals.noData || i.core.resizeNonAxisCharts(), d(i);
      });
    } }, { key: "destroy", value: function() {
      var t, n;
      window.removeEventListener("resize", this.windowResizeHandler), this.el.parentNode, t = this.parentResizeHandler, (n = sr.get(t)) && (n.disconnect(), sr.delete(t));
      var i = this.w.config.chart.id;
      i && Apex._chartInstances.forEach(function(o, d) {
        o.id === K.escapeString(i) && Apex._chartInstances.splice(d, 1);
      }), new Ot(this.ctx).clear({ isUpdating: !1 });
    } }, { key: "updateOptions", value: function(t) {
      var n = this, i = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], o = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], d = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], f = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], p = this.w;
      return p.globals.selection = void 0, t.series && (this.series.resetSeries(!1, !0, !1), t.series.length && t.series[0].data && (t.series = t.series.map(function(y, S) {
        return n.updateHelpers._extendSeries(y, S);
      })), this.updateHelpers.revertDefaultAxisMinMax()), t.xaxis && (t = this.updateHelpers.forceXAxisUpdate(t)), t.yaxis && (t = this.updateHelpers.forceYAxisUpdate(t)), p.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t.theme && (t = this.theme.updateThemeOptions(t)), this.updateHelpers._updateOptions(t, i, o, d, f);
    } }, { key: "updateSeries", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
      return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t, n, i);
    } }, { key: "appendSeries", value: function(t) {
      var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], o = this.w.config.series.slice();
      return o.push(t), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(o, n, i);
    } }, { key: "appendData", value: function(t) {
      var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = this;
      i.w.globals.dataChanged = !0, i.series.getPreviousPaths();
      for (var o = i.w.config.series.slice(), d = 0; d < o.length; d++)
        if (t[d] !== null && t[d] !== void 0)
          for (var f = 0; f < t[d].data.length; f++)
            o[d].data.push(t[d].data[f]);
      return i.w.config.series = o, n && (i.w.globals.initialSeries = K.clone(i.w.config.series)), this.update();
    } }, { key: "update", value: function(t) {
      var n = this;
      return new Promise(function(i, o) {
        new Ot(n.ctx).clear({ isUpdating: !0 });
        var d = n.create(n.w.config.series, t);
        if (!d)
          return i(n);
        n.mount(d).then(function() {
          typeof n.w.config.chart.events.updated == "function" && n.w.config.chart.events.updated(n, n.w), n.events.fireEvent("updated", [n, n.w]), n.w.globals.isDirty = !0, i(n);
        }).catch(function(f) {
          o(f);
        });
      });
    } }, { key: "getSyncedCharts", value: function() {
      var t = this.getGroupedCharts(), n = [this];
      return t.length && (n = [], t.forEach(function(i) {
        n.push(i);
      })), n;
    } }, { key: "getGroupedCharts", value: function() {
      var t = this;
      return Apex._chartInstances.filter(function(n) {
        if (n.group)
          return !0;
      }).map(function(n) {
        return t.w.config.chart.group === n.group ? n.chart : t;
      });
    } }, { key: "toggleSeries", value: function(t) {
      return this.series.toggleSeries(t);
    } }, { key: "highlightSeriesOnLegendHover", value: function(t, n) {
      return this.series.toggleSeriesOnHover(t, n);
    } }, { key: "showSeries", value: function(t) {
      this.series.showSeries(t);
    } }, { key: "hideSeries", value: function(t) {
      this.series.hideSeries(t);
    } }, { key: "resetSeries", value: function() {
      var t = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
      this.series.resetSeries(t, n);
    } }, { key: "addEventListener", value: function(t, n) {
      this.events.addEventListener(t, n);
    } }, { key: "removeEventListener", value: function(t, n) {
      this.events.removeEventListener(t, n);
    } }, { key: "addXaxisAnnotation", value: function(t) {
      var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, o = this;
      i && (o = i), o.annotations.addXaxisAnnotationExternal(t, n, o);
    } }, { key: "addYaxisAnnotation", value: function(t) {
      var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, o = this;
      i && (o = i), o.annotations.addYaxisAnnotationExternal(t, n, o);
    } }, { key: "addPointAnnotation", value: function(t) {
      var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, o = this;
      i && (o = i), o.annotations.addPointAnnotationExternal(t, n, o);
    } }, { key: "clearAnnotations", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0, n = this;
      t && (n = t), n.annotations.clearAnnotations(n);
    } }, { key: "removeAnnotation", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0, i = this;
      n && (i = n), i.annotations.removeAnnotation(i, t);
    } }, { key: "getChartArea", value: function() {
      return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
    } }, { key: "getSeriesTotalXRange", value: function(t, n) {
      return this.coreUtils.getSeriesTotalsXRange(t, n);
    } }, { key: "getHighestValueInSeries", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return new pn(this.ctx).getMinYMaxY(t).highestY;
    } }, { key: "getLowestValueInSeries", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return new pn(this.ctx).getMinYMaxY(t).lowestY;
    } }, { key: "getSeriesTotal", value: function() {
      return this.w.globals.seriesTotals;
    } }, { key: "toggleDataPointSelection", value: function(t, n) {
      return this.updateHelpers.toggleDataPointSelection(t, n);
    } }, { key: "zoomX", value: function(t, n) {
      this.ctx.toolbar.zoomUpdateOptions(t, n);
    } }, { key: "setLocale", value: function(t) {
      this.localization.setCurrentLocaleValues(t);
    } }, { key: "dataURI", value: function(t) {
      return new jt(this.ctx).dataURI(t);
    } }, { key: "exportToCSV", value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return new jt(this.ctx).exportToCSV(t);
    } }, { key: "paper", value: function() {
      return this.w.globals.dom.Paper;
    } }, { key: "_parentResizeCallback", value: function() {
      this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
    } }, { key: "_windowResize", value: function() {
      var t = this;
      clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
        t.w.globals.resized = !0, t.w.globals.dataChanged = !1, t.ctx.update();
      }, 150);
    } }, { key: "_windowResizeHandler", value: function() {
      var t = this.w.config.chart.redrawOnWindowResize;
      typeof t == "function" && (t = t()), t && this._windowResize();
    } }], [{ key: "getChartByID", value: function(t) {
      var n = K.escapeString(t), i = Apex._chartInstances.filter(function(o) {
        return o.id === n;
      })[0];
      return i && i.chart;
    } }, { key: "initOnLoad", value: function() {
      for (var t = document.querySelectorAll("[data-apexcharts]"), n = 0; n < t.length; n++)
        new B(t[n], JSON.parse(t[n].getAttribute("data-options"))).render();
    } }, { key: "exec", value: function(t, n) {
      var i = this.getChartByID(t);
      if (i) {
        i.w.globals.isExecCalled = !0;
        var o = null;
        if (i.publicMethods.indexOf(n) !== -1) {
          for (var d = arguments.length, f = new Array(d > 2 ? d - 2 : 0), p = 2; p < d; p++)
            f[p - 2] = arguments[p];
          o = i[n].apply(i, f);
        }
        return o;
      }
    } }, { key: "merge", value: function(t, n) {
      return K.extend(t, n);
    } }]), B;
  }();
  s.exports = Yn;
})(M1, M1.exports);
var pj = M1.exports, D1 = { exports: {} }, Ay = { exports: {} }, Pn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JT;
function gj() {
  if (JT)
    return Pn;
  JT = 1;
  var s = typeof Symbol == "function" && Symbol.for, u = s ? Symbol.for("react.element") : 60103, h = s ? Symbol.for("react.portal") : 60106, v = s ? Symbol.for("react.fragment") : 60107, w = s ? Symbol.for("react.strict_mode") : 60108, C = s ? Symbol.for("react.profiler") : 60114, T = s ? Symbol.for("react.provider") : 60109, F = s ? Symbol.for("react.context") : 60110, Y = s ? Symbol.for("react.async_mode") : 60111, U = s ? Symbol.for("react.concurrent_mode") : 60111, G = s ? Symbol.for("react.forward_ref") : 60112, q = s ? Symbol.for("react.suspense") : 60113, te = s ? Symbol.for("react.suspense_list") : 60120, se = s ? Symbol.for("react.memo") : 60115, ae = s ? Symbol.for("react.lazy") : 60116, ue = s ? Symbol.for("react.block") : 60121, Ce = s ? Symbol.for("react.fundamental") : 60117, Ne = s ? Symbol.for("react.responder") : 60118, K = s ? Symbol.for("react.scope") : 60119;
  function we(re) {
    if (typeof re == "object" && re !== null) {
      var ve = re.$$typeof;
      switch (ve) {
        case u:
          switch (re = re.type, re) {
            case Y:
            case U:
            case v:
            case C:
            case w:
            case q:
              return re;
            default:
              switch (re = re && re.$$typeof, re) {
                case F:
                case G:
                case ae:
                case se:
                case T:
                  return re;
                default:
                  return ve;
              }
          }
        case h:
          return ve;
      }
    }
  }
  function Re(re) {
    return we(re) === U;
  }
  return Pn.AsyncMode = Y, Pn.ConcurrentMode = U, Pn.ContextConsumer = F, Pn.ContextProvider = T, Pn.Element = u, Pn.ForwardRef = G, Pn.Fragment = v, Pn.Lazy = ae, Pn.Memo = se, Pn.Portal = h, Pn.Profiler = C, Pn.StrictMode = w, Pn.Suspense = q, Pn.isAsyncMode = function(re) {
    return Re(re) || we(re) === Y;
  }, Pn.isConcurrentMode = Re, Pn.isContextConsumer = function(re) {
    return we(re) === F;
  }, Pn.isContextProvider = function(re) {
    return we(re) === T;
  }, Pn.isElement = function(re) {
    return typeof re == "object" && re !== null && re.$$typeof === u;
  }, Pn.isForwardRef = function(re) {
    return we(re) === G;
  }, Pn.isFragment = function(re) {
    return we(re) === v;
  }, Pn.isLazy = function(re) {
    return we(re) === ae;
  }, Pn.isMemo = function(re) {
    return we(re) === se;
  }, Pn.isPortal = function(re) {
    return we(re) === h;
  }, Pn.isProfiler = function(re) {
    return we(re) === C;
  }, Pn.isStrictMode = function(re) {
    return we(re) === w;
  }, Pn.isSuspense = function(re) {
    return we(re) === q;
  }, Pn.isValidElementType = function(re) {
    return typeof re == "string" || typeof re == "function" || re === v || re === U || re === C || re === w || re === q || re === te || typeof re == "object" && re !== null && (re.$$typeof === ae || re.$$typeof === se || re.$$typeof === T || re.$$typeof === F || re.$$typeof === G || re.$$typeof === Ce || re.$$typeof === Ne || re.$$typeof === K || re.$$typeof === ue);
  }, Pn.typeOf = we, Pn;
}
var Nn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var eE;
function vj() {
  return eE || (eE = 1, process.env.NODE_ENV !== "production" && function() {
    var s = typeof Symbol == "function" && Symbol.for, u = s ? Symbol.for("react.element") : 60103, h = s ? Symbol.for("react.portal") : 60106, v = s ? Symbol.for("react.fragment") : 60107, w = s ? Symbol.for("react.strict_mode") : 60108, C = s ? Symbol.for("react.profiler") : 60114, T = s ? Symbol.for("react.provider") : 60109, F = s ? Symbol.for("react.context") : 60110, Y = s ? Symbol.for("react.async_mode") : 60111, U = s ? Symbol.for("react.concurrent_mode") : 60111, G = s ? Symbol.for("react.forward_ref") : 60112, q = s ? Symbol.for("react.suspense") : 60113, te = s ? Symbol.for("react.suspense_list") : 60120, se = s ? Symbol.for("react.memo") : 60115, ae = s ? Symbol.for("react.lazy") : 60116, ue = s ? Symbol.for("react.block") : 60121, Ce = s ? Symbol.for("react.fundamental") : 60117, Ne = s ? Symbol.for("react.responder") : 60118, K = s ? Symbol.for("react.scope") : 60119;
    function we(qe) {
      return typeof qe == "string" || typeof qe == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      qe === v || qe === U || qe === C || qe === w || qe === q || qe === te || typeof qe == "object" && qe !== null && (qe.$$typeof === ae || qe.$$typeof === se || qe.$$typeof === T || qe.$$typeof === F || qe.$$typeof === G || qe.$$typeof === Ce || qe.$$typeof === Ne || qe.$$typeof === K || qe.$$typeof === ue);
    }
    function Re(qe) {
      if (typeof qe == "object" && qe !== null) {
        var pn = qe.$$typeof;
        switch (pn) {
          case u:
            var jn = qe.type;
            switch (jn) {
              case Y:
              case U:
              case v:
              case C:
              case w:
              case q:
                return jn;
              default:
                var ir = jn && jn.$$typeof;
                switch (ir) {
                  case F:
                  case G:
                  case ae:
                  case se:
                  case T:
                    return ir;
                  default:
                    return pn;
                }
            }
          case h:
            return pn;
        }
      }
    }
    var re = Y, ve = U, Me = F, et = T, je = u, Ve = G, it = v, dt = ae, Ke = se, Ze = h, Vt = C, Et = w, an = q, We = !1;
    function ft(qe) {
      return We || (We = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), ye(qe) || Re(qe) === Y;
    }
    function ye(qe) {
      return Re(qe) === U;
    }
    function Ue(qe) {
      return Re(qe) === F;
    }
    function Qe(qe) {
      return Re(qe) === T;
    }
    function St(qe) {
      return typeof qe == "object" && qe !== null && qe.$$typeof === u;
    }
    function kt(qe) {
      return Re(qe) === G;
    }
    function Ht(qe) {
      return Re(qe) === v;
    }
    function ot(qe) {
      return Re(qe) === ae;
    }
    function It(qe) {
      return Re(qe) === se;
    }
    function Rt(qe) {
      return Re(qe) === h;
    }
    function jt(qe) {
      return Re(qe) === C;
    }
    function Ut(qe) {
      return Re(qe) === w;
    }
    function vn(qe) {
      return Re(qe) === q;
    }
    Nn.AsyncMode = re, Nn.ConcurrentMode = ve, Nn.ContextConsumer = Me, Nn.ContextProvider = et, Nn.Element = je, Nn.ForwardRef = Ve, Nn.Fragment = it, Nn.Lazy = dt, Nn.Memo = Ke, Nn.Portal = Ze, Nn.Profiler = Vt, Nn.StrictMode = Et, Nn.Suspense = an, Nn.isAsyncMode = ft, Nn.isConcurrentMode = ye, Nn.isContextConsumer = Ue, Nn.isContextProvider = Qe, Nn.isElement = St, Nn.isForwardRef = kt, Nn.isFragment = Ht, Nn.isLazy = ot, Nn.isMemo = It, Nn.isPortal = Rt, Nn.isProfiler = jt, Nn.isStrictMode = Ut, Nn.isSuspense = vn, Nn.isValidElementType = we, Nn.typeOf = Re;
  }()), Nn;
}
var tE;
function XR() {
  return tE || (tE = 1, process.env.NODE_ENV === "production" ? Ay.exports = gj() : Ay.exports = vj()), Ay.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var e1, nE;
function mj() {
  if (nE)
    return e1;
  nE = 1;
  var s = Object.getOwnPropertySymbols, u = Object.prototype.hasOwnProperty, h = Object.prototype.propertyIsEnumerable;
  function v(C) {
    if (C == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(C);
  }
  function w() {
    try {
      if (!Object.assign)
        return !1;
      var C = new String("abc");
      if (C[5] = "de", Object.getOwnPropertyNames(C)[0] === "5")
        return !1;
      for (var T = {}, F = 0; F < 10; F++)
        T["_" + String.fromCharCode(F)] = F;
      var Y = Object.getOwnPropertyNames(T).map(function(G) {
        return T[G];
      });
      if (Y.join("") !== "0123456789")
        return !1;
      var U = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(G) {
        U[G] = G;
      }), Object.keys(Object.assign({}, U)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return e1 = w() ? Object.assign : function(C, T) {
    for (var F, Y = v(C), U, G = 1; G < arguments.length; G++) {
      F = Object(arguments[G]);
      for (var q in F)
        u.call(F, q) && (Y[q] = F[q]);
      if (s) {
        U = s(F);
        for (var te = 0; te < U.length; te++)
          h.call(F, U[te]) && (Y[U[te]] = F[U[te]]);
      }
    }
    return Y;
  }, e1;
}
var t1, rE;
function pS() {
  if (rE)
    return t1;
  rE = 1;
  var s = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return t1 = s, t1;
}
var n1, iE;
function VR() {
  return iE || (iE = 1, n1 = Function.call.bind(Object.prototype.hasOwnProperty)), n1;
}
var r1, aE;
function yj() {
  if (aE)
    return r1;
  aE = 1;
  var s = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var u = pS(), h = {}, v = VR();
    s = function(C) {
      var T = "Warning: " + C;
      typeof console < "u" && console.error(T);
      try {
        throw new Error(T);
      } catch {
      }
    };
  }
  function w(C, T, F, Y, U) {
    if (process.env.NODE_ENV !== "production") {
      for (var G in C)
        if (v(C, G)) {
          var q;
          try {
            if (typeof C[G] != "function") {
              var te = Error(
                (Y || "React class") + ": " + F + " type `" + G + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof C[G] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw te.name = "Invariant Violation", te;
            }
            q = C[G](T, G, Y, F, null, u);
          } catch (ae) {
            q = ae;
          }
          if (q && !(q instanceof Error) && s(
            (Y || "React class") + ": type specification of " + F + " `" + G + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof q + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), q instanceof Error && !(q.message in h)) {
            h[q.message] = !0;
            var se = U ? U() : "";
            s(
              "Failed " + F + " type: " + q.message + (se ?? "")
            );
          }
        }
    }
  }
  return w.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (h = {});
  }, r1 = w, r1;
}
var i1, sE;
function xj() {
  if (sE)
    return i1;
  sE = 1;
  var s = XR(), u = mj(), h = pS(), v = VR(), w = yj(), C = function() {
  };
  process.env.NODE_ENV !== "production" && (C = function(F) {
    var Y = "Warning: " + F;
    typeof console < "u" && console.error(Y);
    try {
      throw new Error(Y);
    } catch {
    }
  });
  function T() {
    return null;
  }
  return i1 = function(F, Y) {
    var U = typeof Symbol == "function" && Symbol.iterator, G = "@@iterator";
    function q(ye) {
      var Ue = ye && (U && ye[U] || ye[G]);
      if (typeof Ue == "function")
        return Ue;
    }
    var te = "<<anonymous>>", se = {
      array: Ne("array"),
      bigint: Ne("bigint"),
      bool: Ne("boolean"),
      func: Ne("function"),
      number: Ne("number"),
      object: Ne("object"),
      string: Ne("string"),
      symbol: Ne("symbol"),
      any: K(),
      arrayOf: we,
      element: Re(),
      elementType: re(),
      instanceOf: ve,
      node: Ve(),
      objectOf: et,
      oneOf: Me,
      oneOfType: je,
      shape: dt,
      exact: Ke
    };
    function ae(ye, Ue) {
      return ye === Ue ? ye !== 0 || 1 / ye === 1 / Ue : ye !== ye && Ue !== Ue;
    }
    function ue(ye, Ue) {
      this.message = ye, this.data = Ue && typeof Ue == "object" ? Ue : {}, this.stack = "";
    }
    ue.prototype = Error.prototype;
    function Ce(ye) {
      if (process.env.NODE_ENV !== "production")
        var Ue = {}, Qe = 0;
      function St(Ht, ot, It, Rt, jt, Ut, vn) {
        if (Rt = Rt || te, Ut = Ut || It, vn !== h) {
          if (Y) {
            var qe = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw qe.name = "Invariant Violation", qe;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var pn = Rt + ":" + It;
            !Ue[pn] && // Avoid spamming the console because they are often not actionable except for lib authors
            Qe < 3 && (C(
              "You are manually calling a React.PropTypes validation function for the `" + Ut + "` prop on `" + Rt + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), Ue[pn] = !0, Qe++);
          }
        }
        return ot[It] == null ? Ht ? ot[It] === null ? new ue("The " + jt + " `" + Ut + "` is marked as required " + ("in `" + Rt + "`, but its value is `null`.")) : new ue("The " + jt + " `" + Ut + "` is marked as required in " + ("`" + Rt + "`, but its value is `undefined`.")) : null : ye(ot, It, Rt, jt, Ut);
      }
      var kt = St.bind(null, !1);
      return kt.isRequired = St.bind(null, !0), kt;
    }
    function Ne(ye) {
      function Ue(Qe, St, kt, Ht, ot, It) {
        var Rt = Qe[St], jt = Et(Rt);
        if (jt !== ye) {
          var Ut = an(Rt);
          return new ue(
            "Invalid " + Ht + " `" + ot + "` of type " + ("`" + Ut + "` supplied to `" + kt + "`, expected ") + ("`" + ye + "`."),
            { expectedType: ye }
          );
        }
        return null;
      }
      return Ce(Ue);
    }
    function K() {
      return Ce(T);
    }
    function we(ye) {
      function Ue(Qe, St, kt, Ht, ot) {
        if (typeof ye != "function")
          return new ue("Property `" + ot + "` of component `" + kt + "` has invalid PropType notation inside arrayOf.");
        var It = Qe[St];
        if (!Array.isArray(It)) {
          var Rt = Et(It);
          return new ue("Invalid " + Ht + " `" + ot + "` of type " + ("`" + Rt + "` supplied to `" + kt + "`, expected an array."));
        }
        for (var jt = 0; jt < It.length; jt++) {
          var Ut = ye(It, jt, kt, Ht, ot + "[" + jt + "]", h);
          if (Ut instanceof Error)
            return Ut;
        }
        return null;
      }
      return Ce(Ue);
    }
    function Re() {
      function ye(Ue, Qe, St, kt, Ht) {
        var ot = Ue[Qe];
        if (!F(ot)) {
          var It = Et(ot);
          return new ue("Invalid " + kt + " `" + Ht + "` of type " + ("`" + It + "` supplied to `" + St + "`, expected a single ReactElement."));
        }
        return null;
      }
      return Ce(ye);
    }
    function re() {
      function ye(Ue, Qe, St, kt, Ht) {
        var ot = Ue[Qe];
        if (!s.isValidElementType(ot)) {
          var It = Et(ot);
          return new ue("Invalid " + kt + " `" + Ht + "` of type " + ("`" + It + "` supplied to `" + St + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return Ce(ye);
    }
    function ve(ye) {
      function Ue(Qe, St, kt, Ht, ot) {
        if (!(Qe[St] instanceof ye)) {
          var It = ye.name || te, Rt = ft(Qe[St]);
          return new ue("Invalid " + Ht + " `" + ot + "` of type " + ("`" + Rt + "` supplied to `" + kt + "`, expected ") + ("instance of `" + It + "`."));
        }
        return null;
      }
      return Ce(Ue);
    }
    function Me(ye) {
      if (!Array.isArray(ye))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? C(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : C("Invalid argument supplied to oneOf, expected an array.")), T;
      function Ue(Qe, St, kt, Ht, ot) {
        for (var It = Qe[St], Rt = 0; Rt < ye.length; Rt++)
          if (ae(It, ye[Rt]))
            return null;
        var jt = JSON.stringify(ye, function(vn, qe) {
          var pn = an(qe);
          return pn === "symbol" ? String(qe) : qe;
        });
        return new ue("Invalid " + Ht + " `" + ot + "` of value `" + String(It) + "` " + ("supplied to `" + kt + "`, expected one of " + jt + "."));
      }
      return Ce(Ue);
    }
    function et(ye) {
      function Ue(Qe, St, kt, Ht, ot) {
        if (typeof ye != "function")
          return new ue("Property `" + ot + "` of component `" + kt + "` has invalid PropType notation inside objectOf.");
        var It = Qe[St], Rt = Et(It);
        if (Rt !== "object")
          return new ue("Invalid " + Ht + " `" + ot + "` of type " + ("`" + Rt + "` supplied to `" + kt + "`, expected an object."));
        for (var jt in It)
          if (v(It, jt)) {
            var Ut = ye(It, jt, kt, Ht, ot + "." + jt, h);
            if (Ut instanceof Error)
              return Ut;
          }
        return null;
      }
      return Ce(Ue);
    }
    function je(ye) {
      if (!Array.isArray(ye))
        return process.env.NODE_ENV !== "production" && C("Invalid argument supplied to oneOfType, expected an instance of array."), T;
      for (var Ue = 0; Ue < ye.length; Ue++) {
        var Qe = ye[Ue];
        if (typeof Qe != "function")
          return C(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + We(Qe) + " at index " + Ue + "."
          ), T;
      }
      function St(kt, Ht, ot, It, Rt) {
        for (var jt = [], Ut = 0; Ut < ye.length; Ut++) {
          var vn = ye[Ut], qe = vn(kt, Ht, ot, It, Rt, h);
          if (qe == null)
            return null;
          qe.data && v(qe.data, "expectedType") && jt.push(qe.data.expectedType);
        }
        var pn = jt.length > 0 ? ", expected one of type [" + jt.join(", ") + "]" : "";
        return new ue("Invalid " + It + " `" + Rt + "` supplied to " + ("`" + ot + "`" + pn + "."));
      }
      return Ce(St);
    }
    function Ve() {
      function ye(Ue, Qe, St, kt, Ht) {
        return Ze(Ue[Qe]) ? null : new ue("Invalid " + kt + " `" + Ht + "` supplied to " + ("`" + St + "`, expected a ReactNode."));
      }
      return Ce(ye);
    }
    function it(ye, Ue, Qe, St, kt) {
      return new ue(
        (ye || "React class") + ": " + Ue + " type `" + Qe + "." + St + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + kt + "`."
      );
    }
    function dt(ye) {
      function Ue(Qe, St, kt, Ht, ot) {
        var It = Qe[St], Rt = Et(It);
        if (Rt !== "object")
          return new ue("Invalid " + Ht + " `" + ot + "` of type `" + Rt + "` " + ("supplied to `" + kt + "`, expected `object`."));
        for (var jt in ye) {
          var Ut = ye[jt];
          if (typeof Ut != "function")
            return it(kt, Ht, ot, jt, an(Ut));
          var vn = Ut(It, jt, kt, Ht, ot + "." + jt, h);
          if (vn)
            return vn;
        }
        return null;
      }
      return Ce(Ue);
    }
    function Ke(ye) {
      function Ue(Qe, St, kt, Ht, ot) {
        var It = Qe[St], Rt = Et(It);
        if (Rt !== "object")
          return new ue("Invalid " + Ht + " `" + ot + "` of type `" + Rt + "` " + ("supplied to `" + kt + "`, expected `object`."));
        var jt = u({}, Qe[St], ye);
        for (var Ut in jt) {
          var vn = ye[Ut];
          if (v(ye, Ut) && typeof vn != "function")
            return it(kt, Ht, ot, Ut, an(vn));
          if (!vn)
            return new ue(
              "Invalid " + Ht + " `" + ot + "` key `" + Ut + "` supplied to `" + kt + "`.\nBad object: " + JSON.stringify(Qe[St], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(ye), null, "  ")
            );
          var qe = vn(It, Ut, kt, Ht, ot + "." + Ut, h);
          if (qe)
            return qe;
        }
        return null;
      }
      return Ce(Ue);
    }
    function Ze(ye) {
      switch (typeof ye) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !ye;
        case "object":
          if (Array.isArray(ye))
            return ye.every(Ze);
          if (ye === null || F(ye))
            return !0;
          var Ue = q(ye);
          if (Ue) {
            var Qe = Ue.call(ye), St;
            if (Ue !== ye.entries) {
              for (; !(St = Qe.next()).done; )
                if (!Ze(St.value))
                  return !1;
            } else
              for (; !(St = Qe.next()).done; ) {
                var kt = St.value;
                if (kt && !Ze(kt[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Vt(ye, Ue) {
      return ye === "symbol" ? !0 : Ue ? Ue["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && Ue instanceof Symbol : !1;
    }
    function Et(ye) {
      var Ue = typeof ye;
      return Array.isArray(ye) ? "array" : ye instanceof RegExp ? "object" : Vt(Ue, ye) ? "symbol" : Ue;
    }
    function an(ye) {
      if (typeof ye > "u" || ye === null)
        return "" + ye;
      var Ue = Et(ye);
      if (Ue === "object") {
        if (ye instanceof Date)
          return "date";
        if (ye instanceof RegExp)
          return "regexp";
      }
      return Ue;
    }
    function We(ye) {
      var Ue = an(ye);
      switch (Ue) {
        case "array":
        case "object":
          return "an " + Ue;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + Ue;
        default:
          return Ue;
      }
    }
    function ft(ye) {
      return !ye.constructor || !ye.constructor.name ? te : ye.constructor.name;
    }
    return se.checkPropTypes = w, se.resetWarningCache = w.resetWarningCache, se.PropTypes = se, se;
  }, i1;
}
var a1, oE;
function bj() {
  if (oE)
    return a1;
  oE = 1;
  var s = pS();
  function u() {
  }
  function h() {
  }
  return h.resetWarningCache = u, a1 = function() {
    function v(T, F, Y, U, G, q) {
      if (q !== s) {
        var te = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw te.name = "Invariant Violation", te;
      }
    }
    v.isRequired = v;
    function w() {
      return v;
    }
    var C = {
      array: v,
      bigint: v,
      bool: v,
      func: v,
      number: v,
      object: v,
      string: v,
      symbol: v,
      any: v,
      arrayOf: w,
      element: v,
      elementType: v,
      instanceOf: w,
      node: v,
      objectOf: w,
      oneOf: w,
      oneOfType: w,
      shape: w,
      exact: w,
      checkPropTypes: h,
      resetWarningCache: u
    };
    return C.PropTypes = C, C;
  }, a1;
}
if (process.env.NODE_ENV !== "production") {
  var wj = XR(), Sj = !0;
  D1.exports = xj()(wj.isElement, Sj);
} else
  D1.exports = bj()();
var kj = D1.exports, GR;
Object.defineProperty(WR, "__esModule", { value: !0 });
var Cj = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(s) {
  return typeof s;
} : function(s) {
  return s && typeof Symbol == "function" && s.constructor === Symbol && s !== Symbol.prototype ? "symbol" : typeof s;
}, Aj = Object.assign || function(s) {
  for (var u = 1; u < arguments.length; u++) {
    var h, v = arguments[u];
    for (h in v)
      Object.prototype.hasOwnProperty.call(v, h) && (s[h] = v[h]);
  }
  return s;
}, Tj = function() {
  function s(u, h) {
    for (var v = 0; v < h.length; v++) {
      var w = h[v];
      w.enumerable = w.enumerable || !1, w.configurable = !0, "value" in w && (w.writable = !0), Object.defineProperty(u, w.key, w);
    }
  }
  return function(u, h, v) {
    return h && s(u.prototype, h), v && s(u, v), u;
  };
}(), Ej = pj, $R = gS(Ej), qR = mi, sg = gS(qR), Rj = kj, Sl = gS(Rj);
function gS(s) {
  return s && s.__esModule ? s : { default: s };
}
function Lj(s, u, h) {
  return u in s ? Object.defineProperty(s, u, { value: h, enumerable: !0, configurable: !0, writable: !0 }) : s[u] = h, s;
}
function Mj(s, u) {
  var h, v = {};
  for (h in s)
    0 <= u.indexOf(h) || Object.prototype.hasOwnProperty.call(s, h) && (v[h] = s[h]);
  return v;
}
function Dj(s, u) {
  if (!(s instanceof u))
    throw new TypeError("Cannot call a class as a function");
}
function Oj(s, u) {
  if (s)
    return !u || typeof u != "object" && typeof u != "function" ? s : u;
  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
}
function _j(s, u) {
  if (typeof u != "function" && u !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof u);
  s.prototype = Object.create(u && u.prototype, { constructor: { value: s, enumerable: !1, writable: !0, configurable: !0 } }), u && (Object.setPrototypeOf ? Object.setPrototypeOf(s, u) : s.__proto__ = u);
}
window.ApexCharts = $R.default;
var lE = function() {
  function s(u) {
    Dj(this, s);
    var h = Oj(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, u));
    return sg.default.createRef ? h.chartRef = sg.default.createRef() : h.setRef = function(v) {
      return h.chartRef = v;
    }, h.chart = null, h;
  }
  return _j(s, qR.Component), Tj(s, [{ key: "render", value: function() {
    var u = Mj(this.props, []);
    return sg.default.createElement("div", Aj({ ref: sg.default.createRef ? this.chartRef : this.setRef }, u));
  } }, { key: "componentDidMount", value: function() {
    var u = sg.default.createRef ? this.chartRef.current : this.chartRef;
    this.chart = new $R.default(u, this.getConfig()), this.chart.render();
  } }, { key: "getConfig", value: function() {
    var C = this.props, u = C.type, h = C.height, v = C.width, w = C.series, C = C.options;
    return this.extend(C, { chart: { type: u, height: h, width: v }, series: w });
  } }, { key: "isObject", value: function(u) {
    return u && (u === void 0 ? "undefined" : Cj(u)) === "object" && !Array.isArray(u) && u != null;
  } }, { key: "extend", value: function(u, h) {
    var v = this, w = (typeof Object.assign != "function" && (Object.assign = function(C) {
      if (C == null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var T = Object(C), F = 1; F < arguments.length; F++) {
        var Y = arguments[F];
        if (Y != null)
          for (var U in Y)
            Y.hasOwnProperty(U) && (T[U] = Y[U]);
      }
      return T;
    }), Object.assign({}, u));
    return this.isObject(u) && this.isObject(h) && Object.keys(h).forEach(function(C) {
      v.isObject(h[C]) && C in u ? w[C] = v.extend(u[C], h[C]) : Object.assign(w, Lj({}, C, h[C]));
    }), w;
  } }, { key: "componentDidUpdate", value: function(u) {
    if (!this.chart)
      return null;
    var w = this.props, F = w.options, h = w.series, v = w.height, w = w.width, C = JSON.stringify(u.options), T = JSON.stringify(u.series), F = JSON.stringify(F), Y = JSON.stringify(h);
    C === F && T === Y && v === u.height && w === u.width || (T !== Y && C === F && v === u.height && w === u.width ? this.chart.updateSeries(h) : this.chart.updateOptions(this.getConfig()));
  } }, { key: "componentWillUnmount", value: function() {
    this.chart && typeof this.chart.destroy == "function" && this.chart.destroy();
  } }]), s;
}();
(GR = WR.default = lE).propTypes = { type: Sl.default.string.isRequired, width: Sl.default.oneOfType([Sl.default.string, Sl.default.number]), height: Sl.default.oneOfType([Sl.default.string, Sl.default.number]), series: Sl.default.array.isRequired, options: Sl.default.object.isRequired }, lE.defaultProps = { type: "line", width: "100%", height: "auto" };
const Pj = ({
  data: s,
  groupBy: u,
  labels: h,
  groupByFormatter: v = (C) => C,
  hidden: w = []
}) => {
  if ((s == null ? void 0 : s.length) === 0)
    return { series: [], labels: [] };
  const C = [];
  s.forEach((G) => {
    Object.keys(G).forEach((q) => {
      G[q] === 0 && C.push(q);
    });
  });
  const T = [], F = {};
  let Y = 0;
  const U = [];
  return Object.keys(s[0]).forEach((G) => {
    w.includes(G) || u === G || C.includes(G) || (T.push({ name: G, data: [] }), F[G] = Y, Y++);
  }), s.forEach((G) => {
    Object.entries(G).forEach(([q, te]) => {
      var ae, ue;
      if (u === q && U.push(
        v(te) ?? ""
      ), w.includes(q) || C.includes(q))
        return;
      let se = 0;
      typeof te == "number" && (se = te), (ue = (ae = T[F[q]]) == null ? void 0 : ae.data) == null || ue.push(se);
    });
  }), { series: T, labels: U ?? h };
}, Nj = ({
  type: s = "bar",
  foreColor: u = "var(--neutral-content)",
  id: h = "any",
  labelFormatter: v = (F) => F,
  dataLabelFormatter: w = (F) => F,
  series: C = [],
  labels: T = []
}) => ({
  options: {
    chart: {
      id: h,
      type: s,
      foreColor: u,
      toolbar: {
        show: !0
      }
    },
    plotOptions: {
      bar: {
        borderRadius: 4,
        borderRadiusApplication: "around"
      }
    },
    colors: [
      "var(--info)",
      "var(--info-hover)",
      "var(--danger)",
      "var(--danger-hover)",
      "var(--warning)",
      "var(--warning-hover)",
      "var(--primary)",
      "var(--primary-hover)"
    ],
    grid: {
      show: !1
    },
    legend: {
      position: "top",
      formatter: w
    },
    xaxis: {
      categories: T,
      labels: {
        formatter: v,
        style: {
          colors: ["var(--text-neutral-content)"]
        }
      }
    },
    dataLabels: {
      enabled: !0
      // formatter: dataLabelFormatter,
    },
    tooltip: {
      x: {},
      y: {
        title: {
          formatter: w
        }
      }
    },
    yaxis: {
      show: !1
    }
  },
  series: C ?? []
}), Jj = ({
  data: s,
  labelFormatter: u,
  groupBy: h,
  translation: v = "common",
  type: w = "bar",
  hidden: C = [],
  color: T = "neutral-content"
}) => (fE({ language: "pt-BR" }), /* @__PURE__ */ de.jsx(
  GR,
  {
    type: w,
    ...Nj({
      type: w,
      labelFormatter: u,
      dataLabelFormatter: (F) => kr(`${v}.${F}`),
      foreColor: `var(--${T})`,
      id: "any",
      ...Pj({
        data: s,
        groupBy: h,
        hidden: C
      })
    })
  }
));
export {
  jj as Chart,
  Wj as DateRangePicker,
  Vj as DetailedWorkDay,
  Jj as GenericChart,
  Gj as Header,
  tj as Modal,
  Xj as MultiSelect,
  Yy as Select,
  Bj as ShowPassword,
  $j as Sidebar,
  qj as Table,
  kN as Textfield,
  Kj as changeDesignLanguage,
  H1 as debounce,
  Qj as initDesignTranslator,
  BR as useModal,
  ij as useScroll,
  Zj as useToast
};
